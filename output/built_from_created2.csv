Section,section_id,req_id,Test Availability,class_def,method,module,method_text,full_key,requirement,key_as_number,search_terms,qualified_method,manual_search_terms,a_list_item,file_name,matched_files,methods_string,urls
,7.1.1.1,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.1.1/H-1-1,,07010101.720101,H-1-1 7.1.1.1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.1.4.6,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-1,,07010406.720101,H-1-1 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.1.4.6,H-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-2,,07010406.720102,7.1.4.6 H-1-2,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-2,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.1.4.6,H-1-3,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-3,,07010406.720103,H-1-3 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-3,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.1.4.6,H-1-4,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-4,,07010406.720104,H-1-4 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-4,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.8.16,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-1,,03081600.720101,H-1-1 3.8.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.8.16,H-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-2,,03081600.720102,3.8.16 H-1-2,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-2,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.8.16,H-1-3,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-3,,03081600.720103,H-1-3 3.8.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-3,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.8.16,H-1-4,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-4,,03081600.720104,H-1-4 3.8.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-4,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.2.3.5,C-2-6,,android.permission.cts.SmsManagerPermissionTest,setUp(),,"/*  *.  */ package android.permission.cts;  import static org.junit.Assert.assertNotNull; import static org.junit.Assume.assumeTrue;  import android.content.Context; import android.content.pm.PackageManager; import android.net.Uri; import android.telephony.SmsManager;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.ArrayList;  /**  * Test that sending SMS and MMS messages requires permissions.  */ @RunWith(AndroidJUnit4.class) public class SmsManagerPermissionTest {      private static final String SOURCE_ADDRESS = ""+15550000000"";     private static final String DESTINATION_ADDRESS = ""+15550000001"";      private boolean mHasTelephony;     private SmsManager mSmsManager;     private Context mContext;      @Before     public void setUp() throws Exception {         mContext = InstrumentationRegistry.getContext();         mHasTelephony = mContext.getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_TELEPHONY);         assumeTrue(mHasTelephony); // Don't run these tests if FEATURE_TELEPHONY is not available.          mSmsManager = SmsManager.getDefault();         assertNotNull(mSmsManager);     }      ",3.2.3.5/C-2-6,,03020305.670206,3.2.3.5 android.intent.action.SENDTO VIEW SMS ACTION_SENDTO C-2-6 android.intent.action.VIEW SENDTO,Test[None]:[android.permission.cts.SmsManagerPermissionTest:setUp()],,SMS,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.2.3.5,C-5-2,,android.app.notification.legacy.cts.ConditionProviderServiceTest,testUnboundCPSMaintainsCondition_otherProviderRuleChanges(),,"     public void testUnboundCPSMaintainsCondition_otherProviderRuleChanges() throws Exception {         // make sure both services get bound         pollForConnection(LegacyConditionProviderService.class, true);         pollForConnection(SecondaryConditionProviderService.class, true);          // add rules for both         mModeReceiver.reset();          addRule(LegacyConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, true);         pollForSubscribe(LegacyConditionProviderService.getInstance());          addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_ALARMS, true);         pollForSubscribe(SecondaryConditionProviderService.getInstance());          mModeReceiver.waitFor(2/*Legacy and Secondary*/, 1000/*Limit is 1 second*/);         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // unbind one of the services         SecondaryConditionProviderService.getInstance().requestUnbind();          // verify that DND state doesn't change         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // trigger a change in the bound service's rule         addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, false);          // verify that the unbound service maintains it's DND vote         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());     }      ",3.2.3.5/C-5-2,,03020305.670502,3.2.3.5 C-5-2 ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST REQUEST_DISCOVERABLE DND,Test[None]:[android.app.notification.legacy.cts.ConditionProviderServiceTest:testUnboundCPSMaintainsCondition_otherProviderRuleChanges()],,DND,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.2.3.5,C-6-1,,android.app.notification.legacy.cts.ConditionProviderServiceTest,testUnboundCPSMaintainsCondition_otherProviderRuleChanges(),,"     public void testUnboundCPSMaintainsCondition_otherProviderRuleChanges() throws Exception {         // make sure both services get bound         pollForConnection(LegacyConditionProviderService.class, true);         pollForConnection(SecondaryConditionProviderService.class, true);          // add rules for both         mModeReceiver.reset();          addRule(LegacyConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, true);         pollForSubscribe(LegacyConditionProviderService.getInstance());          addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_ALARMS, true);         pollForSubscribe(SecondaryConditionProviderService.getInstance());          mModeReceiver.waitFor(2/*Legacy and Secondary*/, 1000/*Limit is 1 second*/);         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // unbind one of the services         SecondaryConditionProviderService.getInstance().requestUnbind();          // verify that DND state doesn't change         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // trigger a change in the bound service's rule         addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, false);          // verify that the unbound service maintains it's DND vote         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());     }      ",3.2.3.5/C-6-1,,03020305.670601,MODE_TYPE_NORMAL 3.2.3.5 DND ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS C-6-1,Test[None]:[android.app.notification.legacy.cts.ConditionProviderServiceTest:testUnboundCPSMaintainsCondition_otherProviderRuleChanges()],,DND,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.2.3.5,C-8-1,,android.accessibilityservice.cts.AccessibilitySettingsTest,testAccessibilitySettingsIntentHandled(),CtsAccessibilityServiceTestCases,"     public void testAccessibilitySettingsIntentHandled() throws Throwable {         PackageManager packageManager = getContext().getPackageManager();         Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);         List<ResolveInfo> resolvedActivities = packageManager.queryIntentActivities(intent,                 PackageManager.MATCH_DEFAULT_ONLY);          // make sure accessibility settings exist         String message = ""Accessibility settings activity must be launched via Intent "" +                 ""Settings.ACTION_ACCESSIBILITY_SETTINGS"";         assertTrue(message, !resolvedActivities.isEmpty());     } }  ",3.2.3.5/C-8-1,,03020305.670801,ACTION_ACCESSIBILITY_SETTINGS 3.2.3.5 android.settings.ACCESSIBILITY C-8-1 ACCESSIBILITY_SETTINGS,Test[CtsAccessibilityServiceTestCases]:[android.accessibilityservice.cts.AccessibilitySettingsTest:testAccessibilitySettingsIntentHandled()],,ACCESSIBILITY_SETTINGS,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.2.3.5,C-11-1,,android.permission.cts.telephony.TelephonyManagerPermissionTest,testVoiceMailNumber(),,"     public void testVoiceMailNumber() {         if (!mHasTelephony) {             return;         }          try {             String vmnum = mTelephonyManager.getVoiceMailNumber();             fail(""Got voicemail number: "" + vmnum);         } catch (SecurityException e) {             // expected         }     }     /**      * Verify that AudioManager.setMode requires Permission.      * <p>      * Requires Permissions:      * {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS} and      * {@link android.Manifest.permission#MODIFY_PHONE_STATE} for      * {@link AudioManager#MODE_IN_CALL}.      */     ",3.2.3.5/C-11-1,,03020305.671101,android.hardware.camera.any 3.2.3.5 C-11-1 ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SET TINGS Settings.ACTION,Test[None]:[android.permission.cts.telephony.TelephonyManagerPermissionTest:testVoiceMailNumber()],,TINGS,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.2.3.5,C-13-2,,android.content.cts.ClipboardManagerTest,testPrimaryClipNotAvailableWithoutFocus(),,"     public void testPrimaryClipNotAvailableWithoutFocus() throws Exception {         ClipData textData = ClipData.newPlainText(""TextLabel"", ""Text1"");         assertSetPrimaryClip(textData, ""TextLabel"",                 new String[] {ClipDescription.MIMETYPE_TEXT_PLAIN},                 new ExpectedClipItem(""Text1"", null, null));          // Press the home button to unfocus the app.         mUiDevice.pressHome();         mUiDevice.wait(Until.gone(By.clazz(MockActivity.class)), 5000);          // We should see an empty clipboard now.         assertFalse(mClipboardManager.hasPrimaryClip());         assertFalse(mClipboardManager.hasText());         assertNull(mClipboardManager.getPrimaryClip());         assertNull(mClipboardManager.getPrimaryClipDescription());          // We should be able to set the clipboard but not see the contents.         mClipboardManager.setPrimaryClip(ClipData.newPlainText(""TextLabel"", ""Text2""));         assertFalse(mClipboardManager.hasPrimaryClip());         assertFalse(mClipboardManager.hasText());         assertNull(mClipboardManager.getPrimaryClip());         assertNull(mClipboardManager.getPrimaryClipDescription());          // Launch an activity to get back in focus.         launchActivity(MockActivity.class);           // Verify clipboard access is restored.         assertNotNull(mClipboardManager.getPrimaryClip());         assertNotNull(mClipboardManager.getPrimaryClipDescription());          // Verify we were unable to change the clipboard while out of focus.         assertClipData(mClipboardManager.getPrimaryClip(),                 ""TextLabel"",                 new String[] {ClipDescription.MIMETYPE_TEXT_PLAIN},                 new ExpectedClipItem(""Text2"", null, null));     }      private void launchActivity(Class<? extends Activity> clazz) {         Intent intent = new Intent(Intent.ACTION_MAIN);         intent.setClassName(mContext.getPackageName(), clazz.getName());         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         mContext.startActivity(intent);         mUiDevice.wait(Until.hasObject(By.clazz(clazz)), 5000);     }      private class ExpectedClipItem {         CharSequence mText;         Intent mIntent;         Uri mUri;          ExpectedClipItem(CharSequence text, Intent intent, Uri uri) {             mText = text;             mIntent = intent;             mUri = uri;         }     }      private void assertSetPrimaryClip(ClipData clipData,             String expectedLabel,             String[] expectedMimeTypes,             ExpectedClipItem... expectedClipItems) {         ClipboardManager clipboardManager = mClipboardManager;          clipboardManager.setPrimaryClip(clipData);         assertTrue(clipboardManager.hasPrimaryClip());          if (expectedClipItems != null                 && expectedClipItems.length > 0                 && expectedClipItems[0].mText != null) {             assertTrue(clipboardManager.hasText());         } else {             assertFalse(clipboardManager.hasText());         }          assertNotNull(clipboardManager.getPrimaryClip());         assertNotNull(clipboardManager.getPrimaryClipDescription());          assertClipData(clipboardManager.getPrimaryClip(),                 expectedLabel, expectedMimeTypes, expectedClipItems);          assertClipDescription(clipboardManager.getPrimaryClipDescription(),                 expectedLabel, expectedMimeTypes);     }      private static void assertClipData(ClipData actualData, String expectedLabel,             String[] expectedMimeTypes, ExpectedClipItem... expectedClipItems) {         if (expectedClipItems != null) {             assertEquals(expectedClipItems.length, actualData.getItemCount());             for (int i = 0; i < expectedClipItems.length; i++) {                 assertClipItem(expectedClipItems[i], actualData.getItemAt(i));             }         } else {             throw new IllegalArgumentException(""Should have at least one expectedClipItem..."");         }          assertClipDescription(actualData.getDescription(), expectedLabel, expectedMimeTypes);     }      private static void assertClipDescription(ClipDescription description, String expectedLabel,             String... mimeTypes) {         assertEquals(expectedLabel, description.getLabel());         assertEquals(mimeTypes.length, description.getMimeTypeCount());         int mimeTypeCount = description.getMimeTypeCount();         for (int i = 0; i < mimeTypeCount; i++) {             assertEquals(mimeTypes[i], description.getMimeType(i));         }     }      private static void assertClipItem(ExpectedClipItem expectedItem, Item item) {         assertEquals(expectedItem.mText, item.getText());         if (expectedItem.mIntent != null) {             assertNotNull(item.getIntent());         } else {             assertNull(item.getIntent());         }         if (expectedItem.mUri != null) {             assertEquals(expectedItem.mUri.toString(), item.getUri().toString());         } else {             assertNull(item.getUri());         }     }      private boolean hasAutoFillFeature() {         return mContext.getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_AUTOFILL);     } } ",3.2.3.5/C-13-2,,03020305.671302,android.app.action.ADMIN android.software.autofill PackageManager.html 3.2.3.5 ADMIN_POLICY_COMPLIANCE SET_NEW_PASSWORD PROVISIONING_SUCCESSFUL GET_PROVISIONING_MODE ACTION_START_ENCRYPTION android.app.action.PROVISIONING android.app.action.PROVISION PROVISION_MANAGED_PROFILE FEATURE_AUTOFILL SET_NEW_PARENT_PROFILE_PASSWORD PROVISION_MANAGED_DEVICE android.app.action.SET C-13-2 ACTION_ADMIN_POLICY_COMPLIANCE android.app.action.START START_ENCRYPTION android.app.action.GET,Test[None]:[android.content.cts.ClipboardManagerTest:testPrimaryClipNotAvailableWithoutFocus()],,FEATURE_AUTOFILL,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.2.3.5,C-14-1,,android.autofillservice.cts.SettingsIntentTest,testWarningShown_userRejectsByTappingBack(),CtsAutoFillServiceTestCases,"     public void testWarningShown_userRejectsByTappingBack() throws Exception {         disableService();          // Launches Settings.         mActivity.startForResult(newSettingsIntent(), MY_REQUEST_CODE);          // Asserts services are shown.         final UiObject2 object = mUiBot                 .assertShownByText(InstrumentedAutoFillService.sServiceLabel);         object.click();          // TODO(b/79615759): should assert that ""autofill_confirmation_message"" is shown, but that         // string belongs to Settings - we need to move it to frameworks/base first (and/or use         // a resource id, also on framework).         // So, for now, just asserts the service name is showing again (in the popup), and the other         // services are not showing (because the popup hides then).          final UiObject2 msgObj = mUiBot.assertShownById(""android:id/message"");         final String msg = msgObj.getText();         assertWithMessage(""Wrong warning message"").that(msg)                 .contains(InstrumentedAutoFillService.sServiceLabel);          // NOTE: assertion below is fine because it looks for the full text, not a substring         mUiBot.assertNotShowingForSure(InstrumentedAutoFillService.sServiceLabel);         mUiBot.assertNotShowingForSure(InstrumentedAutoFillServiceCompatMode.sServiceLabel);         mUiBot.assertNotShowingForSure(NoOpAutofillService.SERVICE_LABEL);         mUiBot.assertNotShowingForSure(BadAutofillService.SERVICE_LABEL);          // Finishes and asserts result.         mUiBot.pressBack();         mActivity.assertResult(Activity.RESULT_CANCELED);     }      // TODO(b/79615759): add testWarningShown_userRejectsByTappingCancel() and     // testWarningShown_userAccepts() - these tests would require adding the strings and resource     // ids to frameworks/base      private Intent newSettingsIntent() {         return new Intent(Settings.ACTION_REQUEST_SET_AUTOFILL_SERVICE)                 .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)                 .setData(Uri.parse(""package:"" + Helper.MY_PACKAGE));     } } ",3.2.3.5/C-14-1,,03020305.671401,3.2.3.5 ACTION_REQUEST_SET_AUTOFILL_SERVICE REQUEST_SET_AUTOFILL_SERVICE AutofillService.html android.settings.REQUEST AutofillManager.html Settings.html C-14-1,Test[CtsAutoFillServiceTestCases]:[android.autofillservice.cts.SettingsIntentTest:testWarningShown_userRejectsByTappingBack()],,REQUEST_SET_AUTOFILL_SERVICE,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.2.3.5,C-15-1,,android.accessibilityservice.cts.AccessibilityGestureDispatchTest,testContinuingGesture_withNothingToContinue_isCancelled(),CtsAccessibilityServiceTestCases,"     public void testContinuingGesture_withNothingToContinue_isCancelled() {         if (!mHasTouchScreen) {             return;         }          PointF startPoint = new PointF(mStartPoint.x, mStartPoint.y);         PointF midPoint = new PointF(mStartPoint.x + 10, mStartPoint.y);         PointF endPoint = new PointF(mStartPoint.x + 10, mStartPoint.y + 10);         int gestureTime = 500;          StrokeDescription stroke1 =                 new StrokeDescription(lineWithinView(startPoint, midPoint), 0, gestureTime, true);          StrokeDescription stroke2 =                 stroke1.continueStroke(lineWithinView(midPoint, endPoint), 0, gestureTime, false);         awaitCancellation(                 dispatchGesture(mService,                         new GestureDescription.Builder().addStroke(stroke2).build()),                 gestureTime + GESTURE_COMPLETION_TIMEOUT, MILLISECONDS);     }      public static class GestureDispatchActivity extends AccessibilityTestActivity {         public GestureDispatchActivity() {             super();         }          @Override         public void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             setContentView(R.layout.full_screen_frame_layout);         }     }      private void waitForMotionEvents(Matcher<MotionEvent> matcher, int numEventsExpected)             throws InterruptedException {         synchronized (mMotionEvents) {             long endMillis = SystemClock.uptimeMillis() + MOTION_EVENT_TIMEOUT;             boolean gotEvents = getEventsMatching(matcher).size() >= numEventsExpected;             while (!gotEvents && (SystemClock.uptimeMillis() < endMillis)) {                 mMotionEvents.wait(endMillis - SystemClock.uptimeMillis());                 gotEvents = getEventsMatching(matcher).size() >= numEventsExpected;             }             assertTrue(""Did not receive required events. Got:\n"" + mMotionEvents + ""\n filtered:\n""                     + getEventsMatching(matcher), gotEvents);         }     }      private List<MotionEvent> getEventsMatching(Matcher<MotionEvent> matcher) {         List<MotionEvent> events = new ArrayList<>();         synchronized (mMotionEvents) {             for (MotionEvent event : mMotionEvents) {                 if (matcher.matches(event)) {                     events.add(event);                 }             }         }         return events;     }      private float distance(MotionEvent.PointerCoords point1, MotionEvent.PointerCoords point2) {         return (float) Math.hypot((double) (point1.x - point2.x), (double) (point1.y - point2.y));     }      private class MyTouchListener implements View.OnTouchListener {         @Override         public boolean onTouch(View view, MotionEvent motionEvent) {             synchronized (mMotionEvents) {                 if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {                     mGotUpEvent = true;                 }                 mMotionEvents.add(MotionEvent.obtain(motionEvent));                 mMotionEvents.notifyAll();                 return true;             }         }     }      private GestureDescription clickWithinView(PointF clickPoint) {         return new GestureDescription.Builder()                 .addStroke(click(withinView(clickPoint)))                 .build();     }      private GestureDescription longClickWithinView(PointF clickPoint) {         return new GestureDescription.Builder()                 .addStroke(longClick(withinView(clickPoint)))                 .build();     }      private PointF withinView(PointF clickPoint) {         return add(clickPoint, mViewLocation[0], mViewLocation[1]);     }      private GestureDescription swipeWithinView(PointF start, PointF end, long duration) {         return new GestureDescription.Builder()                 .addStroke(new StrokeDescription(lineWithinView(start, end), 0, duration))                 .build();     }      private Path lineWithinView(PointF startPoint, PointF endPoint) {         return path(withinView(startPoint), withinView(endPoint));     }      private GestureDescription pinchWithinView(PointF centerPoint, int startSpacing,             int endSpacing, float orientation, long duration) {         if ((startSpacing < 0) || (endSpacing < 0)) {             throw new IllegalArgumentException(""Pinch spacing cannot be negative"");         }         PointF offsetCenter = withinView(centerPoint);         float[] startPoint1 = new float[2];         float[] endPoint1 = new float[2];         float[] startPoint2 = new float[2];         float[] endPoint2 = new float[2];          /* Build points for a horizontal gesture centered at the origin */         startPoint1[0] = startSpacing / 2;         startPoint1[1] = 0;         endPoint1[0] = endSpacing / 2;         endPoint1[1] = 0;         startPoint2[0] = -startSpacing / 2;         startPoint2[1] = 0;         endPoint2[0] = -endSpacing / 2;         endPoint2[1] = 0;          /* Rotate and translate the points */         Matrix matrix = new Matrix();         matrix.setRotate(orientation);         matrix.postTranslate(offsetCenter.x, offsetCenter.y);         matrix.mapPoints(startPoint1);         matrix.mapPoints(endPoint1);         matrix.mapPoints(startPoint2);         matrix.mapPoints(endPoint2);          Path path1 = new Path();         path1.moveTo(startPoint1[0], startPoint1[1]);         path1.lineTo(endPoint1[0], endPoint1[1]);         Path path2 = new Path();         path2.moveTo(startPoint2[0], startPoint2[1]);         path2.lineTo(endPoint2[0], endPoint2[1]);          return new GestureDescription.Builder()                 .addStroke(new StrokeDescription(path1, 0, duration))                 .addStroke(new StrokeDescription(path2, 0, duration))                 .build();     } } ",3.2.3.5/C-15-1,,03020305.671501,USAGE SETTINGS 3.2.3.5 android.settings.ACTION android.hardware.audio.output C-15-1 ACTION ACTION_USAGE_ACCESS_SETTINGS Settings.html ACCESS,Test[CtsAccessibilityServiceTestCases]:[android.accessibilityservice.cts.AccessibilityGestureDispatchTest:testContinuingGesture_withNothingToContinue_isCancelled()],,ACTION,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,3.9.2,C-2-1,,android.contentcaptureservice.cts.WhitelistTest,,CtsContentCaptureServiceTestCases,"/*  *.  */  package android.contentcaptureservice.cts;  import static android.contentcaptureservice.cts.Helper.MY_PACKAGE; import static android.contentcaptureservice.cts.Helper.NO_ACTIVITIES; import static android.contentcaptureservice.cts.Helper.NO_PACKAGES; import static android.contentcaptureservice.cts.Helper.read; import static android.contentcaptureservice.cts.Helper.sContext; import static android.contentcaptureservice.cts.Helper.toSet; import static android.contentcaptureservice.cts.OutOfProcessActivity.ACTION_CHECK_MANAGER_AND_FINISH;  import static com.google.common.truth.Truth.assertThat;  import android.content.ComponentName; import android.platform.test.annotations.AppModeFull; import android.service.contentcapture.ContentCaptureService;  import androidx.annotation.NonNull;  import org.junit.Ignore; import org.junit.Test;  import java.io.File; import java.util.Set;  /**  * Tests for {@link ContentCaptureService#setContentCaptureWhitelist(Set, Set)}.  *  * <p><b>NOTE</b>: not all cases are supported because in some of them the test package is  * whitelisted in 'lite' mode as it's the same as the service's.  */ @AppModeFull(reason = ""BlankWithTitleActivityTest is enough"") public class WhitelistTest extends AbstractContentCaptureIntegrationActivityLessTest {      @Ignore(""will be whitelisted 'lite'"")     ",3.9.2/C-2-1,,03090200.670201,admin.html ACTION_SET_NEW_PASSWORD DevicePolicyManager.html DevicePolicyManager.ACTION DPC index.html 3.9.2 C-2-1 android.content.ComponentName,Test[CtsContentCaptureServiceTestCases]:[android.contentcaptureservice.cts.WhitelistTest:],,android.content.ComponentName,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,6.1,C-0-11,,android.hardware.cts.LowRamDeviceTest,testMinDataPartitionSize(),,"     @CddTest(requirement=""7.6.1/H-9-2,7.6.1/H-10-1"")     public void testMinDataPartitionSize() {         long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;          if (lowRam) {             assertDataPartitionMinimumSize(                     ""Application data"",                     mContext.getFilesDir(),                     MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB);         } else {             assertDataPartitionMinimumSize(                     ""Application data"", mContext.getFilesDir(), MIN_APP_DATA_PARTITION_SIZE_GB);         }     }      /**      * @return the total memory accessible by the kernel as defined by      * {@code ActivityManager.MemoryInfo}.      */     private long getTotalMemory() {         ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();         mActivityManager.getMemoryInfo(memoryInfo);         return memoryInfo.totalMem;     }      /** @return the screen size as defined in {@Configuration}. */     private int getScreenSize() {         Configuration config = mContext.getResources().getConfiguration();         return config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;     }      /** @return true iff this device supports 64 bit ABIs */     private static boolean supportsSixtyFourBit() {         return Build.SUPPORTED_64_BIT_ABIS.length > 0;     }      /** Asserts that the given values conform to the specs in CDD 7.6.1 */     private void assertMinMemoryMb(long minMb) {          long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;         boolean lowRamDevice = mActivityManager.isLowRamDevice();          Log.i(TAG, String.format(""minMb=%,d"", minMb));         Log.i(TAG, String.format(""totalMemoryMb=%,d"", totalMemoryMb));         Log.i(TAG, ""lowRam="" + lowRam);         Log.i(TAG, ""lowRamDevice="" + lowRamDevice);          assertTrue(String.format(""Does not meet minimum memory requirements (CDD 7.6.1).""                 + ""Found = %d, Minimum = %d"", totalMemoryMb, minMb), totalMemoryMb >= minMb);          assertTrue(""Device must specify low RAM property: ro.config.low_ram=true"",                 !lowRam || (lowRam && lowRamDevice));     }      private static boolean lessThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi <= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      private static boolean greaterThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi >= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      /** @return true iff the {@code array} contains the {@code target} */     private static boolean contains(int [] array, int target) {         for(int a : array) {             if (a == target) {                 return true;             }         }         return false;     }      private void assertDataPartitionMinimumSize(             String partitionName, File fileInPartition, float minPartitionSizeGb) {         StatFs statFs = new StatFs(fileInPartition.getAbsolutePath());         long size = statFs.getTotalBytes();         long minSizeBytes = (long) minPartitionSizeGb * GB_TO_BYTES_MULTIPLIER;          assertTrue(                 String.format(""%s partition size does not meet requirement. ""                         + ""Found = %d, Minimum = %d"", partitionName, size, minSizeBytes),                 size > minSizeBytes);     } } ",6.1/C-0-11,,06010000.670011,6.1 C-0-11,Test[None]:[android.hardware.cts.LowRamDeviceTest:testMinDataPartitionSize()],,6.1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,6.1,C-3-1,,android.hardware.cts.LowRamDeviceTest,testMinDataPartitionSize(),,"     @CddTest(requirement=""7.6.1/H-9-2,7.6.1/H-10-1"")     public void testMinDataPartitionSize() {         long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;          if (lowRam) {             assertDataPartitionMinimumSize(                     ""Application data"",                     mContext.getFilesDir(),                     MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB);         } else {             assertDataPartitionMinimumSize(                     ""Application data"", mContext.getFilesDir(), MIN_APP_DATA_PARTITION_SIZE_GB);         }     }      /**      * @return the total memory accessible by the kernel as defined by      * {@code ActivityManager.MemoryInfo}.      */     private long getTotalMemory() {         ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();         mActivityManager.getMemoryInfo(memoryInfo);         return memoryInfo.totalMem;     }      /** @return the screen size as defined in {@Configuration}. */     private int getScreenSize() {         Configuration config = mContext.getResources().getConfiguration();         return config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;     }      /** @return true iff this device supports 64 bit ABIs */     private static boolean supportsSixtyFourBit() {         return Build.SUPPORTED_64_BIT_ABIS.length > 0;     }      /** Asserts that the given values conform to the specs in CDD 7.6.1 */     private void assertMinMemoryMb(long minMb) {          long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;         boolean lowRamDevice = mActivityManager.isLowRamDevice();          Log.i(TAG, String.format(""minMb=%,d"", minMb));         Log.i(TAG, String.format(""totalMemoryMb=%,d"", totalMemoryMb));         Log.i(TAG, ""lowRam="" + lowRam);         Log.i(TAG, ""lowRamDevice="" + lowRamDevice);          assertTrue(String.format(""Does not meet minimum memory requirements (CDD 7.6.1).""                 + ""Found = %d, Minimum = %d"", totalMemoryMb, minMb), totalMemoryMb >= minMb);          assertTrue(""Device must specify low RAM property: ro.config.low_ram=true"",                 !lowRam || (lowRam && lowRamDevice));     }      private static boolean lessThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi <= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      private static boolean greaterThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi >= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      /** @return true iff the {@code array} contains the {@code target} */     private static boolean contains(int [] array, int target) {         for(int a : array) {             if (a == target) {                 return true;             }         }         return false;     }      private void assertDataPartitionMinimumSize(             String partitionName, File fileInPartition, float minPartitionSizeGb) {         StatFs statFs = new StatFs(fileInPartition.getAbsolutePath());         long size = statFs.getTotalBytes();         long minSizeBytes = (long) minPartitionSizeGb * GB_TO_BYTES_MULTIPLIER;          assertTrue(                 String.format(""%s partition size does not meet requirement. ""                         + ""Found = %d, Minimum = %d"", partitionName, size, minSizeBytes),                 size > minSizeBytes);     } } ",6.1/C-3-1,,06010000.670301,6.1 C-3-1,Test[None]:[android.hardware.cts.LowRamDeviceTest:testMinDataPartitionSize()],,6.1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,6.1,C-3-2,,android.hardware.cts.LowRamDeviceTest,testMinDataPartitionSize(),,"     @CddTest(requirement=""7.6.1/H-9-2,7.6.1/H-10-1"")     public void testMinDataPartitionSize() {         long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;          if (lowRam) {             assertDataPartitionMinimumSize(                     ""Application data"",                     mContext.getFilesDir(),                     MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB);         } else {             assertDataPartitionMinimumSize(                     ""Application data"", mContext.getFilesDir(), MIN_APP_DATA_PARTITION_SIZE_GB);         }     }      /**      * @return the total memory accessible by the kernel as defined by      * {@code ActivityManager.MemoryInfo}.      */     private long getTotalMemory() {         ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();         mActivityManager.getMemoryInfo(memoryInfo);         return memoryInfo.totalMem;     }      /** @return the screen size as defined in {@Configuration}. */     private int getScreenSize() {         Configuration config = mContext.getResources().getConfiguration();         return config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;     }      /** @return true iff this device supports 64 bit ABIs */     private static boolean supportsSixtyFourBit() {         return Build.SUPPORTED_64_BIT_ABIS.length > 0;     }      /** Asserts that the given values conform to the specs in CDD 7.6.1 */     private void assertMinMemoryMb(long minMb) {          long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;         boolean lowRamDevice = mActivityManager.isLowRamDevice();          Log.i(TAG, String.format(""minMb=%,d"", minMb));         Log.i(TAG, String.format(""totalMemoryMb=%,d"", totalMemoryMb));         Log.i(TAG, ""lowRam="" + lowRam);         Log.i(TAG, ""lowRamDevice="" + lowRamDevice);          assertTrue(String.format(""Does not meet minimum memory requirements (CDD 7.6.1).""                 + ""Found = %d, Minimum = %d"", totalMemoryMb, minMb), totalMemoryMb >= minMb);          assertTrue(""Device must specify low RAM property: ro.config.low_ram=true"",                 !lowRam || (lowRam && lowRamDevice));     }      private static boolean lessThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi <= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      private static boolean greaterThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi >= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      /** @return true iff the {@code array} contains the {@code target} */     private static boolean contains(int [] array, int target) {         for(int a : array) {             if (a == target) {                 return true;             }         }         return false;     }      private void assertDataPartitionMinimumSize(             String partitionName, File fileInPartition, float minPartitionSizeGb) {         StatFs statFs = new StatFs(fileInPartition.getAbsolutePath());         long size = statFs.getTotalBytes();         long minSizeBytes = (long) minPartitionSizeGb * GB_TO_BYTES_MULTIPLIER;          assertTrue(                 String.format(""%s partition size does not meet requirement. ""                         + ""Found = %d, Minimum = %d"", partitionName, size, minSizeBytes),                 size > minSizeBytes);     } } ",6.1/C-3-2,,06010000.670302,6.1 C-3-2,Test[None]:[android.hardware.cts.LowRamDeviceTest:testMinDataPartitionSize()],,6.1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,6.1,C-4-1,,android.hardware.cts.LowRamDeviceTest,testMinDataPartitionSize(),,"     @CddTest(requirement=""7.6.1/H-9-2,7.6.1/H-10-1"")     public void testMinDataPartitionSize() {         long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;          if (lowRam) {             assertDataPartitionMinimumSize(                     ""Application data"",                     mContext.getFilesDir(),                     MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB);         } else {             assertDataPartitionMinimumSize(                     ""Application data"", mContext.getFilesDir(), MIN_APP_DATA_PARTITION_SIZE_GB);         }     }      /**      * @return the total memory accessible by the kernel as defined by      * {@code ActivityManager.MemoryInfo}.      */     private long getTotalMemory() {         ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();         mActivityManager.getMemoryInfo(memoryInfo);         return memoryInfo.totalMem;     }      /** @return the screen size as defined in {@Configuration}. */     private int getScreenSize() {         Configuration config = mContext.getResources().getConfiguration();         return config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;     }      /** @return true iff this device supports 64 bit ABIs */     private static boolean supportsSixtyFourBit() {         return Build.SUPPORTED_64_BIT_ABIS.length > 0;     }      /** Asserts that the given values conform to the specs in CDD 7.6.1 */     private void assertMinMemoryMb(long minMb) {          long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;         boolean lowRamDevice = mActivityManager.isLowRamDevice();          Log.i(TAG, String.format(""minMb=%,d"", minMb));         Log.i(TAG, String.format(""totalMemoryMb=%,d"", totalMemoryMb));         Log.i(TAG, ""lowRam="" + lowRam);         Log.i(TAG, ""lowRamDevice="" + lowRamDevice);          assertTrue(String.format(""Does not meet minimum memory requirements (CDD 7.6.1).""                 + ""Found = %d, Minimum = %d"", totalMemoryMb, minMb), totalMemoryMb >= minMb);          assertTrue(""Device must specify low RAM property: ro.config.low_ram=true"",                 !lowRam || (lowRam && lowRamDevice));     }      private static boolean lessThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi <= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      private static boolean greaterThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi >= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      /** @return true iff the {@code array} contains the {@code target} */     private static boolean contains(int [] array, int target) {         for(int a : array) {             if (a == target) {                 return true;             }         }         return false;     }      private void assertDataPartitionMinimumSize(             String partitionName, File fileInPartition, float minPartitionSizeGb) {         StatFs statFs = new StatFs(fileInPartition.getAbsolutePath());         long size = statFs.getTotalBytes();         long minSizeBytes = (long) minPartitionSizeGb * GB_TO_BYTES_MULTIPLIER;          assertTrue(                 String.format(""%s partition size does not meet requirement. ""                         + ""Found = %d, Minimum = %d"", partitionName, size, minSizeBytes),                 size > minSizeBytes);     } } ",6.1/C-4-1,,06010000.670401,6.1 C-4-1 isAdbWifiSupported(),Test[None]:[android.hardware.cts.LowRamDeviceTest:testMinDataPartitionSize()],,6.1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,6.1,C-5-1,,android.hardware.cts.LowRamDeviceTest,testMinDataPartitionSize(),,"     @CddTest(requirement=""7.6.1/H-9-2,7.6.1/H-10-1"")     public void testMinDataPartitionSize() {         long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;          if (lowRam) {             assertDataPartitionMinimumSize(                     ""Application data"",                     mContext.getFilesDir(),                     MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB);         } else {             assertDataPartitionMinimumSize(                     ""Application data"", mContext.getFilesDir(), MIN_APP_DATA_PARTITION_SIZE_GB);         }     }      /**      * @return the total memory accessible by the kernel as defined by      * {@code ActivityManager.MemoryInfo}.      */     private long getTotalMemory() {         ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();         mActivityManager.getMemoryInfo(memoryInfo);         return memoryInfo.totalMem;     }      /** @return the screen size as defined in {@Configuration}. */     private int getScreenSize() {         Configuration config = mContext.getResources().getConfiguration();         return config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;     }      /** @return true iff this device supports 64 bit ABIs */     private static boolean supportsSixtyFourBit() {         return Build.SUPPORTED_64_BIT_ABIS.length > 0;     }      /** Asserts that the given values conform to the specs in CDD 7.6.1 */     private void assertMinMemoryMb(long minMb) {          long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;         boolean lowRamDevice = mActivityManager.isLowRamDevice();          Log.i(TAG, String.format(""minMb=%,d"", minMb));         Log.i(TAG, String.format(""totalMemoryMb=%,d"", totalMemoryMb));         Log.i(TAG, ""lowRam="" + lowRam);         Log.i(TAG, ""lowRamDevice="" + lowRamDevice);          assertTrue(String.format(""Does not meet minimum memory requirements (CDD 7.6.1).""                 + ""Found = %d, Minimum = %d"", totalMemoryMb, minMb), totalMemoryMb >= minMb);          assertTrue(""Device must specify low RAM property: ro.config.low_ram=true"",                 !lowRam || (lowRam && lowRamDevice));     }      private static boolean lessThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi <= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      private static boolean greaterThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi >= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      /** @return true iff the {@code array} contains the {@code target} */     private static boolean contains(int [] array, int target) {         for(int a : array) {             if (a == target) {                 return true;             }         }         return false;     }      private void assertDataPartitionMinimumSize(             String partitionName, File fileInPartition, float minPartitionSizeGb) {         StatFs statFs = new StatFs(fileInPartition.getAbsolutePath());         long size = statFs.getTotalBytes();         long minSizeBytes = (long) minPartitionSizeGb * GB_TO_BYTES_MULTIPLIER;          assertTrue(                 String.format(""%s partition size does not meet requirement. ""                         + ""Found = %d, Minimum = %d"", partitionName, size, minSizeBytes),                 size > minSizeBytes);     } } ",6.1/C-5-1,,06010000.670501,6.1 isAdbWifiQrSupported() C-5-1,Test[None]:[android.hardware.cts.LowRamDeviceTest:testMinDataPartitionSize()],,6.1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.1.1.1,C-2-1,,android.appwidget.cts.RequestPinAppWidgetTest,testPinWidget_launcher2(),,"     public void testPinWidget_launcher2() throws Exception {         runPinWidgetTest(""android.appwidget.cts.packages.launcher2"");     }      @CddTest(requirement=""3.8.2/C-2-1"")     public void verifyIsRequestPinAppWidgetSupported(String launcherPkg, boolean expectedSupport)         throws Exception {         setLauncher(launcherPkg + ""/"" + LAUNCHER_CLASS);          Context context = getInstrumentation().getContext();         assertEquals(expectedSupport,                 AppWidgetManager.getInstance(context).isRequestPinAppWidgetSupported());     }      ",7.1.1.1/C-2-1,,07010101.670201,7.1.1.1 display(s) C-2-1 cs.android.com,Test[None]:[android.appwidget.cts.RequestPinAppWidgetTest:testPinWidget_launcher2()],,C-2-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.1.1.1,C-3-1,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.1.1.1/C-3-1,,07010101.670301,C-3-1 7.1.1.1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.1.4.2,C-1-10,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.1.4.2/C-1-10,,07010402.670110,7.1.4.2 C-1-10 EQP android.software.vulkan.deqp.level,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,7.1.4.2,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.2.3,C-3-1,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.2.3/C-3-1,,07020300.670301,KEYCODE_ASSIST KeyEvent.html 7.2.3 C-3-1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.2.4,C-3-2,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.4/C-3-2,,07020400.670302,7.2.4 android.hardware.faketouch C-3-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,android.hardware.faketouch,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.2.4,C-3-3,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.4/C-3-3,,07020400.670303,TOUCHSCREEN_NOTOUCH C-3-3 Configuration.html 7.2.4 Configuration.touchscreen,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,Configuration.touchscreen,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.2.6.1,C-2-1,,android.view.cts.ActionModeTest,testHide(),,     public void testHide() {         final ActionMode actionMode = new MockActionMode();          actionMode.hide(0);         actionMode.hide(ActionMode.DEFAULT_HIDE_DURATION);     }      ,7.2.6.1/C-2-1,,07020601.670201,KEYCODE_BACK 7.2.6.1 HID AXIS_HAT_X4 AXIS_LTRIGGER KEYCODE_BUTTON_B KEYCODE_BUTTON_Y AXIS_Y KEYCODE_BUTTON_X KEYCODE_BUTTON_L1 KEYCODE_BUTTON_R1 KEYCODE_BUTTON_A KEYCODE_HOME KEYCODE_BUTTON_THUMBR MotionEvent.html AXIS_HAT_Y4 AXIS_Z KEYCODE_BUTTON_THUMBL AXIS_RZ AXIS_RTRIGGER android.hardware.gamepad AXIS_X C-2-1,Test[None]:[android.view.cts.ActionModeTest:testHide()],,HID,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.3,C-1-6,,android.print.cts.PrintAttributesTest,Builder(),,"/*  *.  */  package android.print.cts;  import static org.junit.Assert.assertEquals;  import android.os.ParcelFileDescriptor; import android.print.PageRange; import android.print.PrintAttributes; import android.print.PrintAttributes.Margins; import android.print.PrintAttributes.MediaSize; import android.print.PrintAttributes.Resolution; import android.print.PrintDocumentAdapter; import android.print.PrintDocumentAdapter.LayoutResultCallback; import android.print.PrintDocumentAdapter.WriteResultCallback; import android.print.PrintDocumentInfo; import android.print.PrinterCapabilitiesInfo; import android.print.PrinterId; import android.print.PrinterInfo; import android.print.test.BasePrintTest; import android.print.test.services.FirstPrintService; import android.print.test.services.PrintServiceCallbacks; import android.print.test.services.PrinterDiscoverySessionCallbacks; import android.print.test.services.SecondPrintService; import android.print.test.services.StubbablePrinterDiscoverySession; import android.printservice.PrintJob; import android.util.Log;  import androidx.test.runner.AndroidJUnit4;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.ArrayList; import java.util.Arrays; import java.util.List;  /**  * Test that the print attributes are correctly propagated through the print framework  */ @RunWith(AndroidJUnit4.class) public class PrintAttributesTest extends BasePrintTest {     private static final String LOG_TAG = ""PrintAttributesTest"";     private final String PRINTER_NAME = ""Test printer"";      private final Margins[] MIN_MARGINS = {             new Margins(0, 0, 0, 0), new Margins(10, 10, 10, 10), new Margins(20, 20, 20, 20),     };      private final MediaSize MEDIA_SIZES[] = {             MediaSize.ISO_A3, MediaSize.ISO_A4, MediaSize.ISO_A5     };      private final int COLOR_MODES[] = {             PrintAttributes.COLOR_MODE_MONOCHROME, PrintAttributes.COLOR_MODE_COLOR     };      private final int DUPLEX_MODES[] = {             PrintAttributes.DUPLEX_MODE_NONE, PrintAttributes.DUPLEX_MODE_LONG_EDGE,             PrintAttributes.DUPLEX_MODE_SHORT_EDGE     };      private final Resolution RESOLUTIONS[] = {             new Resolution(""300x300"", ""300x300"", 300, 300),             new Resolution(""600x600"", ""600x600"", 600, 600),             new Resolution(""1200x1200"", ""1200x1200"", 1200, 1200)     };      /**      * Stores the {@link PrintAttributes} passed to the layout method      */     private PrintAttributes mLayoutAttributes;     private static boolean sHasBeenSetup;      /**      * Create a new {@link PrintAttributes} object with the given properties.      *      * All properties can be null/0 to remain unset.      *      * @param mediaSize {@link MediaSize} to use      * @param colorMode Color mode to use      * @param duplexMode Duplex mode to use      * @param resolution {@link Resolution} to use      *      * @return The newly created object or null if no properties are set      */     private PrintAttributes createAttributes(MediaSize mediaSize, int colorMode, int duplexMode,             Resolution resolution) {         if (mediaSize == null && colorMode == 0 && duplexMode == 0 && resolution == null) {             return null;         }          PrintAttributes.Builder builder = new PrintAttributes.Builder();          if (mediaSize != null) {             builder.setMediaSize(mediaSize);         }          if (colorMode != 0) {             builder.setColorMode(colorMode);         }          if (duplexMode != 0) {             builder.setDuplexMode(duplexMode);         }          if (resolution != null) {             builder.setResolution(resolution);         }          return builder.build();     }      /**      * Create {@link PrinterDiscoverySessionCallbacks} with a single printer that has the given      * capabilities      *      * @param minMargins The minMargins of the printer      * @param mediaSizes The {@link MediaSize media sizes} supported by the printer      * @param defaultMediaSize The default {@link MediaSize}      * @param colorModes The color modes supported by the printer      * @param defaultColorMode The default color mode      * @param duplexModes The duplex modes supported by the printer      * @param defaultDuplexMode The default duplex mode      * @param resolutions The {@link Resolution resolutions} supported by the printer      * @param defaultResolution The default {@link Resolution} to use      *      * @return New {@link PrinterDiscoverySessionCallbacks} with a single printer that has the      *         given capabilities      */     private PrinterDiscoverySessionCallbacks createMockPrinterDiscoverySessionCallbacks(             final Margins minMargins, final MediaSize mediaSizes[],             final MediaSize defaultMediaSize, final int colorModes[], final int defaultColorMode,             final int duplexModes[], final int defaultDuplexMode, final Resolution resolutions[],             final Resolution defaultResolution) {         return createMockPrinterDiscoverySessionCallbacks(invocation -> {             StubbablePrinterDiscoverySession session =                     ((PrinterDiscoverySessionCallbacks) invocation.getMock()).getSession();              if (session.getPrinters().isEmpty()) {                 List<PrinterInfo> printers = new ArrayList<>();                 PrinterId printerId = session.getService().generatePrinterId(PRINTER_NAME);                  PrinterCapabilitiesInfo.Builder builder =                         new PrinterCapabilitiesInfo.Builder(printerId);                  builder.setMinMargins(minMargins);                  int mediaSizesLength = mediaSizes.length;                 for (int i = 0; i < mediaSizesLength; i++) {                     if (mediaSizes[i].equals(defaultMediaSize)) {                         builder.addMediaSize(mediaSizes[i], true);                     } else {                         builder.addMediaSize(mediaSizes[i], false);                     }                 }                  int colorModesMask = 0;                 int colorModesLength = colorModes.length;                 for (int i = 0; i < colorModesLength; i++) {                     colorModesMask |= colorModes[i];                 }                 builder.setColorModes(colorModesMask, defaultColorMode);                  int duplexModesMask = 0;                 int duplexModeLength = duplexModes.length;                 for (int i = 0; i < duplexModeLength; i++) {                     duplexModesMask |= duplexModes[i];                 }                 builder.setDuplexModes(duplexModesMask, defaultDuplexMode);                  int resolutionsLength = resolutions.length;                 for (int i = 0; i < resolutionsLength; i++) {                     if (resolutions[i].equals(defaultResolution)) {                         builder.addResolution(resolutions[i], true);                     } else {                         builder.addResolution(resolutions[i], false);                     }                 }                  PrinterInfo printer = new PrinterInfo.Builder(printerId, PRINTER_NAME,                         PrinterInfo.STATUS_IDLE).setCapabilities(builder.build()).build();                 printers.add(printer);                  session.addPrinters(printers);             }             return null;         }, null, null, invocation -> null, null, null, invocation -> {             // Take a note onDestroy was called.             onPrinterDiscoverySessionDestroyCalled();             return null;         });     }      /**      * Create dummy {@link PrintServiceCallbacks}      *      * This is needed to as the print framework is trying to talk to any printer even if is not set      * up.      *      * @return Dummy {@link PrintServiceCallbacks}      */     private PrintServiceCallbacks createDummyMockPrintServiceCallbacks() {         return createMockPrintServiceCallbacks(null, null, null);     }      /**      * Create a {@link PrintDocumentAdapter} that serves empty pages      *      * @return A new {@link PrintDocumentAdapter}      */     private PrintDocumentAdapter createMockPrintDocumentAdapter() {         return createMockPrintDocumentAdapter(                 invocation -> {                     mLayoutAttributes = (PrintAttributes) invocation.getArguments()[1];                     LayoutResultCallback callback =                             (LayoutResultCallback) invocation.getArguments()[3];                     PrintDocumentInfo info = new PrintDocumentInfo.Builder(PRINT_JOB_NAME)                             .setContentType(PrintDocumentInfo.CONTENT_TYPE_DOCUMENT)                             .setPageCount(1)                             .build();                     callback.onLayoutFinished(info, false);                     // Mark layout was called.                     onLayoutCalled();                     return null;                 }, invocation -> {                     Object[] args = invocation.getArguments();                     PageRange[] pages = (PageRange[]) args[0];                     ParcelFileDescriptor fd = (ParcelFileDescriptor) args[1];                     WriteResultCallback callback = (WriteResultCallback) args[3];                     writeBlankPages(mLayoutAttributes, fd, pages[0].getStart(),                             pages[0].getEnd());                     fd.close();                     callback.onWriteFinished(pages);                     // Mark write was called.                     onWriteCalled();                     return null;                 }, invocation -> {                     // Mark finish was called.                     onFinishCalled();                     return null;                 });     }      /**      * Set up a single printer with the given capabilities      *      * @param minMargins The minMargins of the printer      * @param mediaSizes The {@link MediaSize media sizes} supported by the printer      * @param defaultMediaSize The default {@link MediaSize}      * @param colorModes The color modes supported by the printer      * @param defaultColorMode The default color mode      * @param duplexModes The duplex modes supported by the printer      * @param defaultDuplexMode The default duplex mode      * @param resolutions The {@link Resolution resolutions} supported by the printer      * @param defaultResolution The default {@link Resolution} to use      *      * @return A {@link PrintDocumentAdapter} that can be used for the new printer      */     private PrintDocumentAdapter setUpPrinter(Margins minMargins, MediaSize mediaSizes[],             MediaSize defaultMediaSize, int colorModes[], int defaultColorMode, int duplexModes[],             int defaultDuplexMode, Resolution resolutions[], Resolution defaultResolution) {         final PrinterDiscoverySessionCallbacks sessionCallbacks =                 createMockPrinterDiscoverySessionCallbacks(minMargins, mediaSizes,                         defaultMediaSize, colorModes, defaultColorMode, duplexModes,                         defaultDuplexMode, resolutions, defaultResolution);          PrintServiceCallbacks serviceCallbacks = createMockPrintServiceCallbacks(                 invocation -> sessionCallbacks,                 invocation -> {                     PrintJob printJob = (PrintJob) invocation.getArguments()[0];                     // We pretend the job is handled immediately.                     printJob.complete();                     return null;                 }, null);          // Configure the print services.         FirstPrintService.setCallbacks(serviceCallbacks);          // We need to set up the second print service too, otherwise we get a null pointer in the         // print framework         SecondPrintService.setCallbacks(createDummyMockPrintServiceCallbacks());          // Create a print adapter that respects the print contract.         return createMockPrintDocumentAdapter();     }      /**      * Check if a value is in an array.      *      * To be use instead of Arrays.asList(array).contains(value) for ints.      *      * @param array The array the value might be in      * @param value The value to search for      *      * @return true iff the value is in the array      */     private boolean isInArray(final int array[], int value) {         int arrayLength = array.length;         for (int i = 0; i < arrayLength; i++) {             if (array[i] == value) {                 return true;             }         }          return false;     }      @Before     public void setUpServicesAndAdapter() throws Throwable {         if (!sHasBeenSetup) {             // Set up printer with supported and default attributes             PrintDocumentAdapter adapter =                     setUpPrinter(MIN_MARGINS[0], MEDIA_SIZES, MEDIA_SIZES[0], COLOR_MODES,                             COLOR_MODES[0], DUPLEX_MODES, DUPLEX_MODES[0], RESOLUTIONS,                             RESOLUTIONS[0]);              Log.d(LOG_TAG, ""makeDefaultPrinter"");             // Make printer default. This is necessary as a different default printer might pre-select             // its default attributes and thereby overrides the defaults of the tested printer.             makeDefaultPrinter(adapter, PRINTER_NAME);              sHasBeenSetup = true;         }          resetCounters();     }      /**      * Flexible base test for all print attribute tests.      *      * Asserts that the default and suggested attributes are properly honored by the print      * framework.      *      * @param minMargins The minMargins of the printer      * @param mediaSizes The {@link MediaSize media sizes} supported by the printer      * @param defaultMediaSize The default {@link MediaSize}      * @param colorModes The color modes supported by the printer      * @param defaultColorMode The default color mode      * @param duplexModes The duplex modes supported by the printer      * @param defaultDuplexMode The default duplex mode      * @param resolutions The {@link Resolution resolutions} supported by the printer      * @param defaultResolution The default {@link Resolution} to use      * @param suggestedMediaSize The suggested {@link MediaSize} for the print job      * @param suggestedColorMode The suggested color mode for the print job      * @param suggestedDuplexMode The suggested duplex mode for the print job      * @param suggestedResolution The suggested resolution for the print job      *      * @throws Exception If anything is unexpected      */     private void baseTest(Margins minMargins, MediaSize mediaSizes[],             MediaSize defaultMediaSize, MediaSize suggestedMediaSize, int colorModes[],             int defaultColorMode, int suggestedColorMode, int duplexModes[],             int defaultDuplexMode, int suggestedDuplexMode, Resolution resolutions[],             Resolution defaultResolution, Resolution suggestedResolution) throws Exception {         PrintDocumentAdapter adapter =                 setUpPrinter(minMargins, mediaSizes, defaultMediaSize, colorModes, defaultColorMode,                         duplexModes, defaultDuplexMode, resolutions, defaultResolution);          // Select suggested attributes         PrintAttributes suggestedAttributes = createAttributes(suggestedMediaSize,                 suggestedColorMode, suggestedDuplexMode, suggestedResolution);          // Start print action and wait for layout, the result is stored in #layoutAttributes,         // @see createMockPrintDocumentAdapter         Log.d(LOG_TAG, ""print"");         print(adapter, suggestedAttributes);         Log.d(LOG_TAG, ""waitForWriteAdapterCallback"");         waitForWriteAdapterCallback(1);         Log.d(LOG_TAG, ""clickPrintButton"");         mPrintHelper.submitPrintJob();         Log.d(LOG_TAG, ""waitForPrinterDiscoverySessionDestroyCallbackCalled"");         waitForPrinterDiscoverySessionDestroyCallbackCalled(1);          // It does not make sense to suggest minMargins, hence the print framework always picks         // the one set up for the printer.         assertEquals(""Min margins not as expected"", minMargins, mLayoutAttributes.getMinMargins());          // Verify that the attributes are honored properly         if (suggestedMediaSize != null && Arrays.asList(mediaSizes).contains(suggestedMediaSize)) {             assertEquals(""Media size not as suggested"", suggestedMediaSize,                     mLayoutAttributes.getMediaSize());         } else {             assertEquals(""Media size not default"", defaultMediaSize,                     mLayoutAttributes.getMediaSize());         }          if (suggestedColorMode != 0 && isInArray(colorModes, suggestedColorMode)) {             assertEquals(""Color mode not as suggested"", suggestedColorMode,                     mLayoutAttributes.getColorMode());         } else {             assertEquals(""Color mode not default"", defaultColorMode,                     mLayoutAttributes.getColorMode());         }          if (suggestedDuplexMode != 0 && isInArray(duplexModes, suggestedDuplexMode)) {             assertEquals(""Duplex mode not as suggested"", suggestedDuplexMode,                     mLayoutAttributes.getDuplexMode());         } else {             assertEquals(""Duplex mode not default"", defaultDuplexMode,                     mLayoutAttributes.getDuplexMode());         }          if (suggestedResolution != null                 && Arrays.asList(resolutions).contains(suggestedResolution)) {             assertEquals(""Resolution not as suggested"", suggestedResolution,                     mLayoutAttributes.getResolution());         } else {             assertEquals(""Resolution not default"", defaultResolution,                     mLayoutAttributes.getResolution());         }     }      /**      * Test that attributes are as expected if the default attributes match the suggested ones.      *      * This test sets the default and suggested attributes to the first selection.      *      * @throws Exception If anything is unexpected      */     ",7.3/C-1-6,,07030000.670106,7.3 SystemClock.elapsedRealtimeNano SensorEvent.html elapsedRealtimeNano() Sensor.getResolution getResolution() C-1-6,Test[None]:[android.print.cts.PrintAttributesTest:Builder()],,getResolution(),/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.3,C-1-7,,android.database.cts.CursorWindowTest,testAccessDataValues(),,"     public void testAccessDataValues() {         final long NUMBER_LONG_INTEGER = (long) 0xaabbccddffL;         final long NUMBER_INTEGER = (int) NUMBER_LONG_INTEGER;         final long NUMBER_SHORT = (short) NUMBER_INTEGER;         final float NUMBER_FLOAT_SCIENCE = 7.332952E11f;         final double NUMBER_DOUBLE_SCIENCE = 7.33295205887E11;         final String NUMBER_FLOAT_SCIENCE_STRING = ""7.332952E11"";         final String NUMBER_DOUBLE_SCIENCE_STRING = ""7.33295205887E11"";         final String NUMBER_FLOAT_SCIENCE_STRING2 = ""7.33295e+11"";          byte[] originalBlob = new byte[Byte.MAX_VALUE];         for (int i = 0; i < Byte.MAX_VALUE; i++) {             originalBlob[i] = (byte) i;         }          CursorWindow cursorWindow = new CursorWindow(true);         cursorWindow.setNumColumns(5);         cursorWindow.allocRow();          // Test putString, getString, getLong, getInt, isBlob         assertTrue(cursorWindow.putString(Long.toString(NUMBER_LONG_INTEGER), 0, 0));         assertEquals(Long.toString(NUMBER_LONG_INTEGER), cursorWindow.getString(0, 0));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 0));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 0));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 0));         // Converting of Float, there would be some little precision differences. So just compare         // first 6 digits.         assertEquals(NUMBER_FLOAT_SCIENCE_STRING.substring(0, 6), Float.toString(                 cursorWindow.getFloat(0, 0)).substring(0, 6));         assertEquals(NUMBER_DOUBLE_SCIENCE_STRING, Double.toString(cursorWindow.getDouble(0, 0)));         assertFalse(cursorWindow.isNull(0, 0));         assertFalse(cursorWindow.isBlob(0, 0));          // Test null String         assertTrue(cursorWindow.putString("""", 0, 0));         assertEquals("""", cursorWindow.getString(0, 0));         assertEquals(0, cursorWindow.getLong(0, 0));         assertEquals(0, cursorWindow.getInt(0, 0));         assertEquals(0, cursorWindow.getShort(0, 0));         assertEquals(0.0, cursorWindow.getDouble(0, 0), 0.0);         assertEquals(0.0f, cursorWindow.getFloat(0, 0), 0.0);         assertFalse(cursorWindow.isNull(0, 0));         assertFalse(cursorWindow.isBlob(0, 0));          // Test putNull, getString, getLong, getDouble, getBlob, getInd, getShort, getFloat,         // isBlob.         assertTrue(cursorWindow.putNull(0, 1));         assertNull(cursorWindow.getString(0, 1));         assertEquals(0, cursorWindow.getLong(0, 1));         assertEquals(0, cursorWindow.getInt(0, 1));         assertEquals(0, cursorWindow.getShort(0, 1));         assertEquals(0.0, cursorWindow.getDouble(0, 1), 0.0);         assertEquals(0.0f, cursorWindow.getFloat(0, 1), 0.0);         assertNull(cursorWindow.getBlob(0, 1));         assertTrue(cursorWindow.isNull(0, 1));         // If the field is null, isBlob will return true.         assertTrue(cursorWindow.isBlob(0, 1));          // Test putLong, getLong, getInt, getString , getShort, getFloat, getDouble, isBlob.         assertTrue(cursorWindow.putLong(NUMBER_LONG_INTEGER, 0, 2));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 2));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 2));         assertEquals(Long.toString(NUMBER_LONG_INTEGER), cursorWindow.getString(0, 2));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 2));         assertEquals(NUMBER_FLOAT_SCIENCE, cursorWindow.getFloat(0, 2), 0.0);         assertEquals(NUMBER_DOUBLE_SCIENCE, cursorWindow.getDouble(0, 2), 0.0);         try {             cursorWindow.getBlob(0, 2);             fail(""Can't get Blob from a Integer value."");         } catch (SQLiteException e) {             // expected         }         assertFalse(cursorWindow.isNull(0, 2));         assertFalse(cursorWindow.isBlob(0, 2));          // Test putDouble         assertTrue(cursorWindow.putDouble(NUMBER_DOUBLE_SCIENCE, 0, 3));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 3));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 3));         // Converting from Double to String, there would be some little precision differences. So         // Just compare first 6 digits.         assertEquals(NUMBER_FLOAT_SCIENCE_STRING2.substring(0, 6), cursorWindow.getString(0, 3)                 .substring(0, 6));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 3));         assertEquals(NUMBER_FLOAT_SCIENCE, cursorWindow.getFloat(0, 3), 0.0);         assertEquals(NUMBER_DOUBLE_SCIENCE, cursorWindow.getDouble(0, 3), 0.0);         try {             cursorWindow.getBlob(0, 3);             fail(""Can't get Blob from a Double value."");         } catch (SQLiteException e) {             // expected         }         assertFalse(cursorWindow.isNull(0, 3));         assertFalse(cursorWindow.isBlob(0, 3));          // Test putBlob         assertTrue(cursorWindow.putBlob(originalBlob, 0, 4));         byte[] targetBlob = cursorWindow.getBlob(0, 4);         assertTrue(Arrays.equals(originalBlob, targetBlob));         assertFalse(cursorWindow.isNull(0, 4));         // Test isBlob         assertTrue(cursorWindow.isBlob(0, 4));     }      ",7.3/C-1-7,,07030000.670107,7.3 C-1-7,Test[None]:[android.database.cts.CursorWindowTest:testAccessDataValues()],,7.3,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.3.6,C-2-1,,android.appwidget.cts.RequestPinAppWidgetTest,testPinWidget_launcher2(),,"     public void testPinWidget_launcher2() throws Exception {         runPinWidgetTest(""android.appwidget.cts.packages.launcher2"");     }      @CddTest(requirement=""3.8.2/C-2-1"")     public void verifyIsRequestPinAppWidgetSupported(String launcherPkg, boolean expectedSupport)         throws Exception {         setLauncher(launcherPkg + ""/"" + LAUNCHER_CLASS);          Context context = getInstrumentation().getContext();         assertEquals(expectedSupport,                 AppWidgetManager.getInstance(context).isRequestPinAppWidgetSupported());     }      ",7.3.6/C-2-1,,07030600.670201,C-2-1 TYPE_AMBIENT_TEMPERATURE 7.3.6 SENSOR_TYPE_AMBIENT_TEMPERATURE,Test[None]:[android.appwidget.cts.RequestPinAppWidgetTest:testPinWidget_launcher2()],,C-2-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.3.10,C-6-2,,android.security.identity.cts.IdentityApiTest,,,"/*  *.  */  package android.security.identity.cts;  import android.content.Context; import android.hardware.biometrics.BiometricPrompt.CryptoObject; import android.security.identity.AccessControlProfileId; import android.security.identity.AlreadyPersonalizedException; import android.security.identity.CipherSuiteNotSupportedException; import android.security.identity.DocTypeNotSupportedException; import android.security.identity.EphemeralPublicKeyNotFoundException; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.InvalidReaderSignatureException; import android.security.identity.InvalidRequestMessageException; import android.security.identity.MessageDecryptionException; import android.security.identity.NoAuthenticationKeyAvailableException; import android.security.identity.SessionTranscriptMismatchException; import android.security.identity.UnknownAuthenticationKeyException;  import androidx.test.InstrumentationRegistry;  import org.junit.Test; import static org.junit.Assert.assertEquals;  public class IdentityApiTest {     private static final String TAG = ""IdentityApiTest"";      ",7.3.10/C-6-2,,07031000.670602,C-6-2 BIOMETRIC_STRONG 7.3.10 BiometricManager.Authenticators BiometricPrompt.CryptoObject,Test[None]:[android.security.identity.cts.IdentityApiTest:],,BiometricPrompt.CryptoObject,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.3.10,C-3-4,,android.server.wm.AssistantStackTests,testDisallowEnterPiPFromAssistantStack(),,"     public void testDisallowEnterPiPFromAssistantStack() throws Exception {         try (final AssistantSession assistantSession = new AssistantSession()) {             assistantSession.setVoiceInteractionService(ASSISTANT_VOICE_INTERACTION_SERVICE);              launchActivityNoWait(LAUNCH_ASSISTANT_ACTIVITY_INTO_STACK,                     EXTRA_ASSISTANT_ENTER_PIP, ""true"");         }         waitForValidStateWithActivityType(ASSISTANT_ACTIVITY, ACTIVITY_TYPE_ASSISTANT);         mWmState.assertDoesNotContainStack(""Must not contain pinned stack."",                 WINDOWING_MODE_PINNED, ACTIVITY_TYPE_STANDARD);     }      ",7.3.10/C-3-4,,07031000.670304,7.3.10 PIN C-3-4,Test[None]:[android.server.wm.AssistantStackTests:testDisallowEnterPiPFromAssistantStack()],,PIN,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.3.13,C-1-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",7.3.13/C-1-1,,07031300.670101,7.3.13 TYPE_HINGLE_ANGLE C-1-1 STRING_TYPE_HINGE_ANGLE,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-1-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.3.13,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.3.13/C-1-2,,07031300.670102,7.3.13 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.4.5.3,C-1-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",7.4.5.3/C-1-1,,07040503.670101,ACTION_CAPTIVE_PORTAL_SIGN_IN C-1-1 7.4.5.3,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-1-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.4.5.3,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.4.5.3/C-1-2,,07040503.670102,C-1-2 7.4.5.3,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.4.5.3,C-1-3,,android.net.wifi.cts.WifiBackupRestoreTest,testCanRestoreSoftApBackupData(),,"     public void testCanRestoreSoftApBackupData() {         UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();         SoftApConfiguration origSoftApConfig = null;         try {             uiAutomation.adoptShellPermissionIdentity();              // Retrieve original soft ap config.             origSoftApConfig = mWifiManager.getSoftApConfiguration();              // Retrieve backup data.             byte[] backupData = mWifiManager.retrieveSoftApBackupData();              // Modify softap config and set it.             SoftApConfiguration modSoftApConfig = new SoftApConfiguration.Builder(origSoftApConfig)                     .setSsid(origSoftApConfig.getSsid() + ""b"")                     .build();             mWifiManager.setSoftApConfiguration(modSoftApConfig);             // Ensure that it does not match the orig softap config.             assertThat(mWifiManager.getSoftApConfiguration()).isNotEqualTo(origSoftApConfig);              // Restore the original backup data & ensure that the orig softap config is restored.             mWifiManager.restoreSoftApBackupData(backupData);             assertThat(mWifiManager.getSoftApConfiguration()).isEqualTo(origSoftApConfig);         } finally {             if (origSoftApConfig != null) {                 mWifiManager.setSoftApConfiguration(origSoftApConfig);             }             uiAutomation.dropShellPermissionIdentity();         }     }      /**      * Read the content of the given resource file into a String.      *      * @param filename String name of the file      * @return Byte array of the contents of the file.      * @throws IOException      */     private byte[] loadResourceFile(String filename) throws IOException {         InputStream in = getClass().getClassLoader().getResourceAsStream(filename);         DataInputStream dis = new DataInputStream(in);         byte[] data = new byte[dis.available()];         dis.readFully(data);         return data;     }      private WifiConfiguration createExpectedLegacyWepWifiConfiguration() {         WifiConfiguration configuration = new WifiConfiguration();         configuration.SSID = ""\""TestSsid1\"""";         configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);         configuration.wepKeys = new String[4];         configuration.wepKeys[0] = ""\""WepAscii1\"""";         configuration.wepKeys[1] = ""\""WepAscii2\"""";         configuration.wepKeys[2] = ""45342312ab"";         configuration.wepKeys[3] = ""45342312ab45342312ab34ac12"";         configuration.wepTxKeyIndex = 1;         return configuration;     }      private WifiConfiguration createExpectedLegacyPskWifiConfiguration() {         WifiConfiguration configuration = new WifiConfiguration();         configuration.SSID = ""\""TestSsid2\"""";         configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);         configuration.preSharedKey = ""\""TestPsk123\"""";         return configuration;     }      private WifiConfiguration createExpectedLegacyOpenWifiConfiguration() {         WifiConfiguration configuration = new WifiConfiguration();         configuration.SSID = ""\""TestSsid3\"""";         configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);         return configuration;     }      private IpConfiguration createExpectedLegacyDHCPIpConfigurationWithPacProxy() throws Exception {         IpConfiguration ipConfiguration = new IpConfiguration();         ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.DHCP);         ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.PAC);         ipConfiguration.setHttpProxy(ProxyInfo.buildPacProxy(                 Uri.parse(EXPECTED_LEGACY_PAC_PROXY_LOCATION)));         return ipConfiguration;     }      private StaticIpConfiguration createExpectedLegacyStaticIpconfiguration() throws Exception {         return new StaticIpConfiguration.Builder()                 .setIpAddress(                         new LinkAddress(                                 InetAddress.getByName(EXPECTED_LEGACY_STATIC_IP_LINK_ADDRESS),                                 EXPECTED_LEGACY_STATIC_IP_LINK_PREFIX_LENGTH))                 .setGateway(InetAddress.getByName(EXPECTED_LEGACY_STATIC_IP_GATEWAY_ADDRESS))                 .setDnsServers(Arrays.asList(EXPECTED_LEGACY_STATIC_IP_DNS_SERVER_ADDRESSES)                         .stream()                         .map(s -> {                             try {                                 return InetAddress.getByName(s);                             } catch (UnknownHostException e) {                                 return null;                             }                         })                         .collect(Collectors.toList()))                 .build();     }      private IpConfiguration createExpectedLegacyStaticIpConfigurationWithPacProxy()             throws Exception {         IpConfiguration ipConfiguration = new IpConfiguration();         ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.STATIC);         ipConfiguration.setStaticIpConfiguration(createExpectedLegacyStaticIpconfiguration());         ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.PAC);         ipConfiguration.setHttpProxy(ProxyInfo.buildPacProxy(                 Uri.parse(EXPECTED_LEGACY_PAC_PROXY_LOCATION)));         return ipConfiguration;     }      private IpConfiguration createExpectedLegacyStaticIpConfigurationWithStaticProxy()             throws Exception {         IpConfiguration ipConfiguration = new IpConfiguration();         ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.STATIC);         ipConfiguration.setStaticIpConfiguration(createExpectedLegacyStaticIpconfiguration());         ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.STATIC);         ipConfiguration.setHttpProxy(ProxyInfo.buildDirectProxy(                 EXPECTED_LEGACY_STATIC_PROXY_HOST, EXPECTED_LEGACY_STATIC_PROXY_PORT,                 Arrays.asList(EXPECTED_LEGACY_STATIC_PROXY_EXCLUSION_LIST)));         return ipConfiguration;     }      /**      * Asserts that the 2 lists of WifiConfigurations are equal. This compares all the elements      * saved for backup/restore.      */     public static void assertConfigurationsEqual(             List<WifiConfiguration> expected, List<WifiConfiguration> actual) {         assertThat(actual.size()).isEqualTo(expected.size());         for (WifiConfiguration expectedConfiguration : expected) {             String expectedConfigKey = expectedConfiguration.getKey();             boolean didCompare = false;             for (WifiConfiguration actualConfiguration : actual) {                 String actualConfigKey = actualConfiguration.getKey();                 if (actualConfigKey.equals(expectedConfigKey)) {                     assertConfigurationEqual(                             expectedConfiguration, actualConfiguration);                     didCompare = true;                 }             }             assertWithMessage(""Didn't find matching config for key = ""                     + expectedConfigKey).that(didCompare).isTrue();         }     }      /**      * Asserts that the 2 WifiConfigurations are equal.      */     private static void assertConfigurationEqual(             WifiConfiguration expected, WifiConfiguration actual) {         assertThat(actual).isNotNull();         assertThat(expected).isNotNull();         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.SSID).isEqualTo(expected.SSID);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.preSharedKey).isEqualTo(expected.preSharedKey);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.wepKeys).isEqualTo(expected.wepKeys);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.wepTxKeyIndex).isEqualTo(expected.wepTxKeyIndex);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.hiddenSSID).isEqualTo(expected.hiddenSSID);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.requirePmf).isEqualTo(expected.requirePmf);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.allowedKeyManagement).isEqualTo(expected.allowedKeyManagement);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.shared).isEqualTo(expected.shared);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.allowAutojoin).isEqualTo(expected.allowAutojoin);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.getIpConfiguration()).isEqualTo(expected.getIpConfiguration());         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.meteredOverride).isEqualTo(expected.meteredOverride);     }      private void testRestoreFromBackupData(             List<WifiConfiguration> expectedConfigurations, ThrowingRunnable restoreMethod)         throws Exception {         UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();         List<WifiConfiguration> restoredSavedNetworks = null;         try {             uiAutomation.adoptShellPermissionIdentity();             Set<String> origSavedSsids = mWifiManager.getConfiguredNetworks().stream()                     .map(n -> n.SSID)                     .collect(Collectors.toSet());              restoreMethod.run();              restoredSavedNetworks = mWifiManager.getPrivilegedConfiguredNetworks().stream()                     .filter(n -> !origSavedSsids.contains(n.SSID))                     .collect(Collectors.toList());             assertConfigurationsEqual(                     expectedConfigurations, restoredSavedNetworks);         } finally {             // clean up all restored networks.             if (restoredSavedNetworks != null) {                 for (WifiConfiguration network : restoredSavedNetworks) {                     mWifiManager.removeNetwork(network.networkId);                 }             }             uiAutomation.dropShellPermissionIdentity();         }     }      private List<WifiConfiguration> createExpectedLegacyConfigurations() throws Exception {         List<WifiConfiguration> expectedConfigurations = new ArrayList<>();         WifiConfiguration wepNetwork = createExpectedLegacyWepWifiConfiguration();         wepNetwork.setIpConfiguration(createExpectedLegacyDHCPIpConfigurationWithPacProxy());         expectedConfigurations.add(wepNetwork);          WifiConfiguration pskNetwork = createExpectedLegacyPskWifiConfiguration();         pskNetwork.setIpConfiguration(createExpectedLegacyStaticIpConfigurationWithPacProxy());         expectedConfigurations.add(pskNetwork);          WifiConfiguration openNetwork = createExpectedLegacyOpenWifiConfiguration();         openNetwork.setIpConfiguration(                 createExpectedLegacyStaticIpConfigurationWithStaticProxy());         expectedConfigurations.add(openNetwork);         return expectedConfigurations;     }      /**      * Verify that 3 network configuration is deserialized correctly from AOSP      * legacy supplicant/ipconf backup data format.      */     ",7.4.5.3/C-1-3,,07040503.670103,DNS C-1-3 7.4.5.3,Test[None]:[android.net.wifi.cts.WifiBackupRestoreTest:testCanRestoreSoftApBackupData()],,DNS,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.4.5.3,C-1-4,,android.net.wifi.cts.WifiBackupRestoreTest,testCanRestoreSoftApBackupData(),,"     public void testCanRestoreSoftApBackupData() {         UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();         SoftApConfiguration origSoftApConfig = null;         try {             uiAutomation.adoptShellPermissionIdentity();              // Retrieve original soft ap config.             origSoftApConfig = mWifiManager.getSoftApConfiguration();              // Retrieve backup data.             byte[] backupData = mWifiManager.retrieveSoftApBackupData();              // Modify softap config and set it.             SoftApConfiguration modSoftApConfig = new SoftApConfiguration.Builder(origSoftApConfig)                     .setSsid(origSoftApConfig.getSsid() + ""b"")                     .build();             mWifiManager.setSoftApConfiguration(modSoftApConfig);             // Ensure that it does not match the orig softap config.             assertThat(mWifiManager.getSoftApConfiguration()).isNotEqualTo(origSoftApConfig);              // Restore the original backup data & ensure that the orig softap config is restored.             mWifiManager.restoreSoftApBackupData(backupData);             assertThat(mWifiManager.getSoftApConfiguration()).isEqualTo(origSoftApConfig);         } finally {             if (origSoftApConfig != null) {                 mWifiManager.setSoftApConfiguration(origSoftApConfig);             }             uiAutomation.dropShellPermissionIdentity();         }     }      /**      * Read the content of the given resource file into a String.      *      * @param filename String name of the file      * @return Byte array of the contents of the file.      * @throws IOException      */     private byte[] loadResourceFile(String filename) throws IOException {         InputStream in = getClass().getClassLoader().getResourceAsStream(filename);         DataInputStream dis = new DataInputStream(in);         byte[] data = new byte[dis.available()];         dis.readFully(data);         return data;     }      private WifiConfiguration createExpectedLegacyWepWifiConfiguration() {         WifiConfiguration configuration = new WifiConfiguration();         configuration.SSID = ""\""TestSsid1\"""";         configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);         configuration.wepKeys = new String[4];         configuration.wepKeys[0] = ""\""WepAscii1\"""";         configuration.wepKeys[1] = ""\""WepAscii2\"""";         configuration.wepKeys[2] = ""45342312ab"";         configuration.wepKeys[3] = ""45342312ab45342312ab34ac12"";         configuration.wepTxKeyIndex = 1;         return configuration;     }      private WifiConfiguration createExpectedLegacyPskWifiConfiguration() {         WifiConfiguration configuration = new WifiConfiguration();         configuration.SSID = ""\""TestSsid2\"""";         configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);         configuration.preSharedKey = ""\""TestPsk123\"""";         return configuration;     }      private WifiConfiguration createExpectedLegacyOpenWifiConfiguration() {         WifiConfiguration configuration = new WifiConfiguration();         configuration.SSID = ""\""TestSsid3\"""";         configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);         return configuration;     }      private IpConfiguration createExpectedLegacyDHCPIpConfigurationWithPacProxy() throws Exception {         IpConfiguration ipConfiguration = new IpConfiguration();         ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.DHCP);         ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.PAC);         ipConfiguration.setHttpProxy(ProxyInfo.buildPacProxy(                 Uri.parse(EXPECTED_LEGACY_PAC_PROXY_LOCATION)));         return ipConfiguration;     }      private StaticIpConfiguration createExpectedLegacyStaticIpconfiguration() throws Exception {         return new StaticIpConfiguration.Builder()                 .setIpAddress(                         new LinkAddress(                                 InetAddress.getByName(EXPECTED_LEGACY_STATIC_IP_LINK_ADDRESS),                                 EXPECTED_LEGACY_STATIC_IP_LINK_PREFIX_LENGTH))                 .setGateway(InetAddress.getByName(EXPECTED_LEGACY_STATIC_IP_GATEWAY_ADDRESS))                 .setDnsServers(Arrays.asList(EXPECTED_LEGACY_STATIC_IP_DNS_SERVER_ADDRESSES)                         .stream()                         .map(s -> {                             try {                                 return InetAddress.getByName(s);                             } catch (UnknownHostException e) {                                 return null;                             }                         })                         .collect(Collectors.toList()))                 .build();     }      private IpConfiguration createExpectedLegacyStaticIpConfigurationWithPacProxy()             throws Exception {         IpConfiguration ipConfiguration = new IpConfiguration();         ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.STATIC);         ipConfiguration.setStaticIpConfiguration(createExpectedLegacyStaticIpconfiguration());         ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.PAC);         ipConfiguration.setHttpProxy(ProxyInfo.buildPacProxy(                 Uri.parse(EXPECTED_LEGACY_PAC_PROXY_LOCATION)));         return ipConfiguration;     }      private IpConfiguration createExpectedLegacyStaticIpConfigurationWithStaticProxy()             throws Exception {         IpConfiguration ipConfiguration = new IpConfiguration();         ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.STATIC);         ipConfiguration.setStaticIpConfiguration(createExpectedLegacyStaticIpconfiguration());         ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.STATIC);         ipConfiguration.setHttpProxy(ProxyInfo.buildDirectProxy(                 EXPECTED_LEGACY_STATIC_PROXY_HOST, EXPECTED_LEGACY_STATIC_PROXY_PORT,                 Arrays.asList(EXPECTED_LEGACY_STATIC_PROXY_EXCLUSION_LIST)));         return ipConfiguration;     }      /**      * Asserts that the 2 lists of WifiConfigurations are equal. This compares all the elements      * saved for backup/restore.      */     public static void assertConfigurationsEqual(             List<WifiConfiguration> expected, List<WifiConfiguration> actual) {         assertThat(actual.size()).isEqualTo(expected.size());         for (WifiConfiguration expectedConfiguration : expected) {             String expectedConfigKey = expectedConfiguration.getKey();             boolean didCompare = false;             for (WifiConfiguration actualConfiguration : actual) {                 String actualConfigKey = actualConfiguration.getKey();                 if (actualConfigKey.equals(expectedConfigKey)) {                     assertConfigurationEqual(                             expectedConfiguration, actualConfiguration);                     didCompare = true;                 }             }             assertWithMessage(""Didn't find matching config for key = ""                     + expectedConfigKey).that(didCompare).isTrue();         }     }      /**      * Asserts that the 2 WifiConfigurations are equal.      */     private static void assertConfigurationEqual(             WifiConfiguration expected, WifiConfiguration actual) {         assertThat(actual).isNotNull();         assertThat(expected).isNotNull();         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.SSID).isEqualTo(expected.SSID);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.preSharedKey).isEqualTo(expected.preSharedKey);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.wepKeys).isEqualTo(expected.wepKeys);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.wepTxKeyIndex).isEqualTo(expected.wepTxKeyIndex);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.hiddenSSID).isEqualTo(expected.hiddenSSID);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.requirePmf).isEqualTo(expected.requirePmf);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.allowedKeyManagement).isEqualTo(expected.allowedKeyManagement);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.shared).isEqualTo(expected.shared);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.allowAutojoin).isEqualTo(expected.allowAutojoin);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.getIpConfiguration()).isEqualTo(expected.getIpConfiguration());         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.meteredOverride).isEqualTo(expected.meteredOverride);     }      private void testRestoreFromBackupData(             List<WifiConfiguration> expectedConfigurations, ThrowingRunnable restoreMethod)         throws Exception {         UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();         List<WifiConfiguration> restoredSavedNetworks = null;         try {             uiAutomation.adoptShellPermissionIdentity();             Set<String> origSavedSsids = mWifiManager.getConfiguredNetworks().stream()                     .map(n -> n.SSID)                     .collect(Collectors.toSet());              restoreMethod.run();              restoredSavedNetworks = mWifiManager.getPrivilegedConfiguredNetworks().stream()                     .filter(n -> !origSavedSsids.contains(n.SSID))                     .collect(Collectors.toList());             assertConfigurationsEqual(                     expectedConfigurations, restoredSavedNetworks);         } finally {             // clean up all restored networks.             if (restoredSavedNetworks != null) {                 for (WifiConfiguration network : restoredSavedNetworks) {                     mWifiManager.removeNetwork(network.networkId);                 }             }             uiAutomation.dropShellPermissionIdentity();         }     }      private List<WifiConfiguration> createExpectedLegacyConfigurations() throws Exception {         List<WifiConfiguration> expectedConfigurations = new ArrayList<>();         WifiConfiguration wepNetwork = createExpectedLegacyWepWifiConfiguration();         wepNetwork.setIpConfiguration(createExpectedLegacyDHCPIpConfigurationWithPacProxy());         expectedConfigurations.add(wepNetwork);          WifiConfiguration pskNetwork = createExpectedLegacyPskWifiConfiguration();         pskNetwork.setIpConfiguration(createExpectedLegacyStaticIpConfigurationWithPacProxy());         expectedConfigurations.add(pskNetwork);          WifiConfiguration openNetwork = createExpectedLegacyOpenWifiConfiguration();         openNetwork.setIpConfiguration(                 createExpectedLegacyStaticIpConfigurationWithStaticProxy());         expectedConfigurations.add(openNetwork);         return expectedConfigurations;     }      /**      * Verify that 3 network configuration is deserialized correctly from AOSP      * legacy supplicant/ipconf backup data format.      */     ",7.4.5.3/C-1-4,,07040503.670104,android.net.LinkProperties.getPrivateDnsServerName DNS C-1-4 android.net.LinkProperties.isPrivateDnsActive LinkProperties.html 7.4.5.3,Test[None]:[android.net.wifi.cts.WifiBackupRestoreTest:testCanRestoreSoftApBackupData()],,DNS,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.4.5.3,C-1-5,,android.os.cts.ParcelFileDescriptorTest,getContext(),,/*  *.  */  package android.os.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.content.Context; import android.os.Handler; import android.os.Looper; import android.os.Parcel; import android.os.ParcelFileDescriptor; import android.os.ParcelFileDescriptor.AutoCloseInputStream; import android.os.Parcelable; import android.os.cts.ParcelFileDescriptorPeer.FutureCloseListener; import android.platform.test.annotations.AppModeFull; import android.system.ErrnoException; import android.system.Os; import android.system.OsConstants; import android.test.MoreAsserts;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.google.common.util.concurrent.AbstractFuture;  import junit.framework.ComparisonFailure;  import org.junit.Test; import org.junit.runner.RunWith;  import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.TimeUnit;  @RunWith(AndroidJUnit4.class) public class ParcelFileDescriptorTest {     private static final long DURATION = 100l;      private Context getContext() {         return InstrumentationRegistry.getContext();     }      ,7.4.5.3/C-1-5,,07040503.670105,android.net.ConnectivityManager.NetworkCallback connect() C-1-5 java.net.Socket ConnectivityManager.registerDefaultNetworkCallback ConnectivityManager.getActiveNetwork 7.4.5.3,Test[None]:[android.os.cts.ParcelFileDescriptorTest:getContext()],,java.net.Socket,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.4.8,C-1-2,,android.omapi.accesscontrol1.cts.AccessControlTest,Object(),,"/*  *.  */  /* Contributed by Orange */  package android.omapi.accesscontrol1.cts;  import static org.hamcrest.CoreMatchers.is; import static org.junit.Assert.*; import static org.junit.Assume.assumeTrue;  import android.content.pm.PackageManager; import android.os.Build; import android.se.omapi.Channel; import android.se.omapi.Reader; import android.se.omapi.SEService; import android.se.omapi.SEService.OnConnectedListener; import android.se.omapi.Session;  import androidx.test.InstrumentationRegistry;  import com.android.compatibility.common.util.PropertyUtil;  import org.junit.After; import org.junit.Before; import org.junit.Test;  import java.util.Timer; import java.util.TimerTask; import java.util.concurrent.Executor; import java.util.concurrent.TimeoutException;  public class AccessControlTest {     private final static String UICC_READER_PREFIX = ""SIM"";     private final static String ESE_READER_PREFIX = ""eSE"";     private final static String SD_READER_PREFIX = ""SD"";      private final static byte[] AID_40 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x40 };     private final static byte[] AID_41 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x41 };     private final static byte[] AID_42 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x42 };     private final static byte[] AID_43 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x43 };     private final static byte[] AID_44 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x44 };     private final static byte[] AID_45 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x45 };     private final static byte[] AID_46 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x46 };     private final static byte[] AID_47 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x47 };     private final static byte[] AID_48 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x48 };     private final static byte[] AID_49 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x49 };     private final static byte[] AID_4A = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4A };     private final static byte[] AID_4B = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4B };     private final static byte[] AID_4C = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4C };     private final static byte[] AID_4D = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4D };     private final static byte[] AID_4E = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4E };     private final static byte[] AID_4F = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4F };      private final static byte[][] AUTHORIZED_AID = new byte[][] { AID_40,         AID_41, AID_42, AID_44, AID_45, AID_47, AID_48, AID_49, AID_4A,         AID_4B, AID_4C, AID_4D, AID_4E, AID_4F };     private final static byte[][] UNAUTHORIZED_AID = new byte[][] { AID_43,         AID_46 };      /* Authorized APDU for AID_40 */     private final static byte[][] AUTHORIZED_APDU_AID_40 = new byte[][] {         { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0xA0, 0x06, 0x00, 0x00 },};     /* Unauthorized APDU for AID_40 */     private final static byte[][] UNAUTHORIZED_APDU_AID_40 = new byte[][] {         { 0x00, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0x80, 0x06, 0x00, 0x00 },         { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0x94, 0x06, 0x00, 0x00, 0x00 }, };      /* Authorized APDU for AID_41 */     private final static byte[][] AUTHORIZED_APDU_AID_41 = new byte[][] {         { (byte) 0x94, 0x06, 0x00, 0x00 },         { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },         { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA } };     /* Unauthorized APDU for AID_41 */     private final static byte[][] UNAUTHORIZED_APDU_AID_41 = new byte[][] {         { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },         { (byte) 0xA0, 0x06, 0x00, 0x00 },         { 0x00, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },         { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },         { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },         { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },         { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },         { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },         { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },     };      private final long SERVICE_CONNECTION_TIME_OUT = 3000;     private SEService seService;     private Object serviceMutex = new Object();     private Timer connectionTimer;     private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();     private boolean connected = false;      private final OnConnectedListener mListener = new OnConnectedListener() {         public void onConnected() {             synchronized (serviceMutex) {                 connected = true;                 serviceMutex.notify();             }         }     };      class SynchronousExecutor implements Executor {         public void execute(Runnable r) {             r.run();         }     }      private boolean supportsHardware() {         final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();         boolean lowRamDevice = PropertyUtil.propertyEquals(""ro.config.low_ram"", ""true"");         return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")                 || hasSecureElementPackage(pm);     }      private boolean hasSecureElementPackage(PackageManager pm) {         try {             pm.getPackageInfo(""com.android.se"", 0 /* flags*/);             return true;         } catch (PackageManager.NameNotFoundException e) {             return false;         }     }      private boolean supportOMAPIReaders() {         final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();         return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)             || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)             || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));     }      @Before     public void setUp() throws Exception {         assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);         assumeTrue(supportsHardware());         assumeTrue(supportOMAPIReaders());         seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);         connectionTimer = new Timer();         connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);     }      @After     public void tearDown() throws Exception {         if (seService != null && seService.isConnected()) {             seService.shutdown();             connected = false;         }     }      private void waitForConnection() throws TimeoutException {         synchronized (serviceMutex) {             if (!connected) {                 try {                     serviceMutex.wait();                  } catch (InterruptedException e) {                     e.printStackTrace();                  }             }             if (!connected) {                 throw new TimeoutException(                     ""Service could not be connected after ""                     + SERVICE_CONNECTION_TIME_OUT + "" ms"");             }             if (connectionTimer != null) {                 connectionTimer.cancel();             }         }     }      ",7.4.8/C-1-2,,07040800.670102,android.hardware.se.omapi.uicc FEATURE_SE_OMAPI_SD UICC 7.4.8 android.hardware.se.omapi.ese FEATURE_SE_OMAPI_ESE C-1-2 android.hardware.se.omapi.sd FEATURE_SE_OMAPI_UICC,Test[None]:[android.omapi.accesscontrol1.cts.AccessControlTest:Object()],,FEATURE_SE_OMAPI_UICC,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,7.5.4,C-0-12,,android.hardware.camera2.cts.CameraManagerTest,setUp(),CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import static junit.framework.Assert.*;  import static org.mockito.Mockito.*;  import android.app.Instrumentation; import android.app.NotificationManager; import android.app.UiAutomation; import android.content.pm.PackageManager; import android.hardware.camera2.CameraAccessException; import android.hardware.camera2.CameraCharacteristics; import android.hardware.camera2.CameraDevice; import android.hardware.camera2.CameraDevice.StateCallback; import android.hardware.camera2.CameraManager; import android.hardware.camera2.cts.Camera2ParameterizedTestCase; import android.hardware.camera2.cts.CameraTestUtils.HandlerExecutor; import android.hardware.camera2.cts.CameraTestUtils.MockStateCallback; import android.hardware.camera2.cts.helpers.CameraErrorCollector; import android.os.Build; import android.os.Handler; import android.os.HandlerThread; import android.os.ParcelFileDescriptor; import android.platform.test.annotations.AppModeFull; import android.util.Log; import android.util.Pair;  import androidx.test.InstrumentationRegistry;  import com.android.compatibility.common.util.PropertyUtil; import com.android.ex.camera2.blocking.BlockingStateCallback;  import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.mockito.ArgumentCaptor; import org.mockito.InOrder;  import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.Executor; import java.util.concurrent.LinkedBlockingQueue;  /**  * <p>Basic test for CameraManager class.</p>  */  @RunWith(Parameterized.class) public class CameraManagerTest extends Camera2ParameterizedTestCase {     private static final String TAG = ""CameraManagerTest"";     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);     private static final int NUM_CAMERA_REOPENS = 10;     private static final int AVAILABILITY_TIMEOUT_MS = 10;      private PackageManager mPackageManager;     private NoopCameraListener mListener;     private HandlerThread mHandlerThread;     private Handler mHandler;     private BlockingStateCallback mCameraListener;     private CameraErrorCollector mCollector;     private Set<Set<String>> mConcurrentCameraIdCombinations;      /** Load validation jni on initialization. */     static {         System.loadLibrary(""ctscamera2_jni"");     }      @Override     public void setUp() throws Exception {         super.setUp();         mPackageManager = mContext.getPackageManager();         assertNotNull(""Can't get package manager"", mPackageManager);         mListener = new NoopCameraListener();          /**          * Workaround for mockito and JB-MR2 incompatibility          *          * Avoid java.lang.IllegalArgumentException: dexcache == null          * https://code.google.com/p/dexmaker/issues/detail?id=2          */         System.setProperty(""dexmaker.dexcache"", mContext.getCacheDir().toString());          mCameraListener = spy(new BlockingStateCallback());          mHandlerThread = new HandlerThread(TAG);         mHandlerThread.start();         mHandler = new Handler(mHandlerThread.getLooper());         mCollector = new CameraErrorCollector();         mConcurrentCameraIdCombinations =                 CameraTestUtils.getConcurrentCameraIds(mCameraManager, mAdoptShellPerm);     }      @Override     public void tearDown() throws Exception {         mHandlerThread.quitSafely();         mHandler = null;          try {             mCollector.verify();         } catch (Throwable e) {             // When new Exception(e) is used, exception info will be printed twice.             throw new Exception(e.getMessage());         } finally {             super.tearDown();         }     }      /**      * Verifies that the reason is in the range of public-only codes.      */     private static int checkCameraAccessExceptionReason(CameraAccessException e) {         int reason = e.getReason();          switch (reason) {             case CameraAccessException.CAMERA_DISABLED:             case CameraAccessException.CAMERA_DISCONNECTED:             case CameraAccessException.CAMERA_ERROR:             case CameraAccessException.CAMERA_IN_USE:             case CameraAccessException.MAX_CAMERAS_IN_USE:                 return reason;         }          fail(""Invalid CameraAccessException code: "" + reason);          return -1; // unreachable     }      ",7.5.4/C-0-12,,07050400.670012,C-0-12 android.hardware.Camera 7.5.4 android.hardware.camera,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.CameraManagerTest:setUp()],,android.hardware.camera,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.1,C-2-1,,android.appwidget.cts.RequestPinAppWidgetTest,testPinWidget_launcher2(),,"     public void testPinWidget_launcher2() throws Exception {         runPinWidgetTest(""android.appwidget.cts.packages.launcher2"");     }      @CddTest(requirement=""3.8.2/C-2-1"")     public void verifyIsRequestPinAppWidgetSupported(String launcherPkg, boolean expectedSupport)         throws Exception {         setLauncher(launcherPkg + ""/"" + LAUNCHER_CLASS);          Context context = getInstrumentation().getContext();         assertEquals(expectedSupport,                 AppWidgetManager.getInstance(context).isRequestPinAppWidgetSupported());     }      ",9.1/C-2-1,,09010000.670201,ACTION_MANAGE_OVERLAY_PERMISSION 9.1 C-2-1 Settings.html,Test[None]:[android.appwidget.cts.RequestPinAppWidgetTest:testPinWidget_launcher2()],,C-2-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.5,C-1-2,,android.graphics.cts.RectFTest,testWidth(),,"     public void testWidth() {         mRectF = new RectF(1.0f, 1.0f, 20.5f, 20.5f);         assertEquals(19.5f, mRectF.width(), 0.0f);     }      ",9.5/C-1-2,,09050000.670102,C-1-2 9.5 permissions.html,Test[None]:[android.graphics.cts.RectFTest:testWidth()],,9.5,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.8.9,C-0-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testMonochromeCharacteristics(),CtsCameraTestCases,"     public void testMonochromeCharacteristics() {         for (int i = 0; i < mAllCameraIds.length; i++) {             Log.i(TAG, ""testMonochromeCharacteristics: Testing camera ID "" + mAllCameraIds[i]);              CameraCharacteristics c = mCharacteristics.get(i);             int[] capabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);             assertNotNull(""android.request.availableCapabilities must never be null"",                     capabilities);             boolean supportMonochrome = arrayContains(capabilities, MONOCHROME);              if (!supportMonochrome) {                 continue;             }              List<Key<?>> allKeys = c.getKeys();             List<CaptureRequest.Key<?>> requestKeys = c.getAvailableCaptureRequestKeys();             List<CaptureResult.Key<?>> resultKeys = c.getAvailableCaptureResultKeys();              assertTrue(""Monochrome camera must have BACKWARD_COMPATIBLE capability"",                     arrayContains(capabilities, BC));             int colorFilterArrangement = c.get(                     CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT);             assertTrue(""Monochrome camera must have either MONO or NIR color filter pattern"",                     colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO                     || colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR);              assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX1));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT1));             assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX2));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT2));              assertFalse(                     ""Monochrome capture result must not contain SENSOR_NEUTRAL_COLOR_POINT key"",                     resultKeys.contains(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT));             assertFalse(""Monochrome capture result must not contain SENSOR_GREEN_SPLIT key"",                     resultKeys.contains(CaptureResult.SENSOR_GREEN_SPLIT));              // Check that color correction tags are not available for monochrome cameras             assertTrue(""Monochrome camera must not have MANUAL_POST_PROCESSING capability"",                     !arrayContains(capabilities, MANUAL_POSTPROC));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_GAINS));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_GAINS));              // Check that awbSupportedModes only contains AUTO             int[] awbAvailableModes = c.get(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES);             assertTrue(""availableAwbModes must not be null"", awbAvailableModes != null);             assertTrue(""availableAwbModes must contain only AUTO"", awbAvailableModes.length == 1 &&                     awbAvailableModes[0] == CaptureRequest.CONTROL_AWB_MODE_AUTO);         }     }      /**      * Check that all devices available through the legacy API are also      * accessible via Camera2.      */     @CddTest(requirement=""7.5.4/C-0-11"")     ",9.8.9/C-0-1,,09080900.670001,9.8.9 C-0-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testMonochromeCharacteristics()],,C-0-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.8.10,C-1-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",9.8.10/C-1-1,,09081000.670101,BUGREPORT_MODE_TELEPHONY C-1-1 9.8.10,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-1-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.8.10,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.8.10/C-1-2,,09081000.670102,9.8.10 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.8.10,C-1-4,,android.server.wm.ActivityTaskAffinityTests,testActivitiesWithSameAffinityUidDifferentAppSameTask(),,"     public void testActivitiesWithSameAffinityUidDifferentAppSameTask() {         testActivitiesShouldBeInTheSameTask(                 TEST_ACTIVITY_WITH_SAME_AFFINITY,                 TEST_ACTIVITY_WITH_SAME_AFFINITY_SHARE_UID,                 true /* sameTask */         );     }      ",9.8.10/C-1-4,,09081000.670104,9.8.10 C-1-4 UID,Test[None]:[android.server.wm.ActivityTaskAffinityTests:testActivitiesWithSameAffinityUidDifferentAppSameTask()],,UID,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.8.11,C-1-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",9.8.11/C-1-1,,09081100.670101,allowPackageAccess() allowSameSignatureAccess() C-1-1 allowPublicAccess() 9.8.11 BlobStoreManager.session,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-1-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.8.11,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.8.11/C-1-2,,09081100.670102,9.8.11 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.9.4,C-0-1,,android.mediav2.cts.CodecDecoderTest,isFormatSupported(),CtsMediaV2TestCases,"/*  *.  */  package android.mediav2.cts;  import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaExtractor; import android.media.MediaFormat; import android.util.Log; import android.view.Surface;  import androidx.test.filters.LargeTest; import androidx.test.filters.SmallTest;  import org.junit.Assume; import org.junit.Ignore; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.Parameterized;  import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.nio.channels.FileChannel; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.HashSet; import java.util.List; import java.util.Set;  import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  /**  * Validate decode functionality of listed decoder components  *  * The test aims to test all decoders advertised in MediaCodecList. Hence we are not using  * MediaCodecList#findDecoderForFormat to create codec. Further, it can so happen that the  * test clip chosen is not supported by component (codecCapabilities.isFormatSupported()  * fails), then it is better to replace the clip but not skip testing the component. The idea  * of these tests are not to cover CDD requirements but to test components and their plugins  */ @RunWith(Parameterized.class) public class CodecDecoderTest extends CodecDecoderTestBase {     private static final String LOG_TAG = CodecDecoderTest.class.getSimpleName();      private final String mRefFile;     private final String mReconfigFile;     private final float mRmsError;      public CodecDecoderTest(String mime, String testFile, String refFile, String reconfigFile,             float rmsError) {         super(mime, testFile);         mRefFile = refFile;         mReconfigFile = reconfigFile;         mRmsError = rmsError;     }      private short[] setUpAudioReference() throws IOException {         File refFile = new File(mInpPrefix + mRefFile);         short[] refData;         try (FileInputStream refStream = new FileInputStream(refFile)) {             FileChannel fileChannel = refStream.getChannel();             int length = (int) refFile.length();             ByteBuffer refBuffer = ByteBuffer.allocate(length);             refBuffer.order(ByteOrder.LITTLE_ENDIAN);             fileChannel.read(refBuffer);             refData = new short[length / 2];             refBuffer.position(0);             for (int i = 0; i < length / 2; i++) {                 refData[i] = refBuffer.getShort();             }         }         return refData;     }      private ArrayList<MediaCodec.BufferInfo> createSubFrames(ByteBuffer buffer, int sfCount) {         int size = (int) mExtractor.getSampleSize();         if (size < 0) return null;         mExtractor.readSampleData(buffer, 0);         long pts = mExtractor.getSampleTime();         int flags = mExtractor.getSampleFlags();         if (size < sfCount) sfCount = size;         ArrayList<MediaCodec.BufferInfo> list = new ArrayList<>();         int offset = 0;         for (int i = 0; i < sfCount; i++) {             MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();             info.offset = offset;             info.presentationTimeUs = pts;             info.flags = 0;             if ((flags & MediaExtractor.SAMPLE_FLAG_SYNC) != 0) {                 info.flags |= MediaCodec.BUFFER_FLAG_KEY_FRAME;             }             if ((flags & MediaExtractor.SAMPLE_FLAG_PARTIAL_FRAME) != 0) {                 info.flags |= MediaCodec.BUFFER_FLAG_PARTIAL_FRAME;             }             if (i != sfCount - 1) {                 info.size = size / sfCount;                 info.flags |= MediaExtractor.SAMPLE_FLAG_PARTIAL_FRAME;             } else {                 info.size = size - offset;             }             list.add(info);             offset += info.size;         }         return list;     }      @Parameterized.Parameters(name = ""{index}({0})"")     public static Collection<Object[]> input() {         Set<String> list = new HashSet<>();         if (hasAudioOutput()) {             // sec 5.1.2             list.add(MediaFormat.MIMETYPE_AUDIO_AAC);             list.add(MediaFormat.MIMETYPE_AUDIO_FLAC);             list.add(MediaFormat.MIMETYPE_AUDIO_MPEG);             list.add(MediaFormat.MIMETYPE_AUDIO_VORBIS);             list.add(MediaFormat.MIMETYPE_AUDIO_RAW);             list.add(MediaFormat.MIMETYPE_AUDIO_OPUS);         }         if (isHandheld() || isTv() || isAutomotive()) {             // sec 2.2.2, 2.3.2, 2.5.2             list.add(MediaFormat.MIMETYPE_AUDIO_AAC);             list.add(MediaFormat.MIMETYPE_VIDEO_AVC);             list.add(MediaFormat.MIMETYPE_VIDEO_MPEG4);             list.add(MediaFormat.MIMETYPE_VIDEO_H263);             list.add(MediaFormat.MIMETYPE_VIDEO_VP8);             list.add(MediaFormat.MIMETYPE_VIDEO_VP9);         }         if (isHandheld()) {             // sec 2.2.2             list.add(MediaFormat.MIMETYPE_AUDIO_AMR_NB);             list.add(MediaFormat.MIMETYPE_AUDIO_AMR_WB);             list.add(MediaFormat.MIMETYPE_VIDEO_HEVC);         }         if (isTv()) {             // sec 2.3.2             list.add(MediaFormat.MIMETYPE_VIDEO_HEVC);             list.add(MediaFormat.MIMETYPE_VIDEO_MPEG2);         }         ArrayList<String> cddRequiredMimeList = new ArrayList<>(list);         final List<Object[]> exhaustiveArgsList = Arrays.asList(new Object[][]{                 {MediaFormat.MIMETYPE_AUDIO_MPEG, ""bbb_1ch_8kHz_lame_cbr.mp3"",                         ""bbb_1ch_8kHz_s16le.raw"", ""bbb_2ch_44kHz_lame_vbr.mp3"",                         91.022f * 1.05f},                 {MediaFormat.MIMETYPE_AUDIO_MPEG, ""bbb_1ch_16kHz_lame_vbr.mp3"",                         ""bbb_1ch_16kHz_s16le.raw"", ""bbb_2ch_44kHz_lame_vbr.mp3"",                         119.256f * 1.05f},                 {MediaFormat.MIMETYPE_AUDIO_MPEG, ""bbb_2ch_44kHz_lame_cbr.mp3"",                         ""bbb_2ch_44kHz_s16le.raw"", ""bbb_1ch_16kHz_lame_vbr.mp3"",                         103.60f * 1.05f},                 {MediaFormat.MIMETYPE_AUDIO_MPEG, ""bbb_2ch_44kHz_lame_vbr.mp3"",                         ""bbb_2ch_44kHz_s16le.raw"", ""bbb_1ch_8kHz_lame_cbr.mp3"",                         53.066f * 1.05f},                 {MediaFormat.MIMETYPE_AUDIO_AMR_WB, ""bbb_1ch_16kHz_16kbps_amrwb.3gp"",                         ""bbb_1ch_16kHz_s16le.raw"", ""bbb_1ch_16kHz_23kbps_amrwb.3gp"",                         2393.598f * 1.05f},                 {MediaFormat.MIMETYPE_AUDIO_AMR_NB, ""bbb_1ch_8kHz_10kbps_amrnb.3gp"",                         ""bbb_1ch_8kHz_s16le.raw"", ""bbb_1ch_8kHz_8kbps_amrnb.3gp"", -1.0f},                 {MediaFormat.MIMETYPE_AUDIO_FLAC, ""bbb_1ch_16kHz_flac.mka"",                         ""bbb_1ch_16kHz_s16le.raw"", ""bbb_2ch_44kHz_flac.mka"", 0.0f},                 {MediaFormat.MIMETYPE_AUDIO_FLAC, ""bbb_2ch_44kHz_flac.mka"",                         ""bbb_2ch_44kHz_s16le.raw"", ""bbb_1ch_16kHz_flac.mka"", 0.0f},                 {MediaFormat.MIMETYPE_AUDIO_RAW, ""bbb_1ch_16kHz.wav"", ""bbb_1ch_16kHz_s16le.raw"",                         ""bbb_2ch_44kHz.wav"", 0.0f},                 {MediaFormat.MIMETYPE_AUDIO_RAW, ""bbb_2ch_44kHz.wav"", ""bbb_2ch_44kHz_s16le.raw"",                         ""bbb_1ch_16kHz.wav"", 0.0f},                 {MediaFormat.MIMETYPE_AUDIO_G711_ALAW, ""bbb_1ch_8kHz_alaw.wav"",                         ""bbb_1ch_8kHz_s16le.raw"", ""bbb_2ch_8kHz_alaw.wav"", 23.08678f * 1.05f},                 {MediaFormat.MIMETYPE_AUDIO_G711_MLAW, ""bbb_1ch_8kHz_mulaw.wav"",                         ""bbb_1ch_8kHz_s16le.raw"", ""bbb_2ch_8kHz_mulaw.wav"", 24.4131f * 1.05f},                 {MediaFormat.MIMETYPE_AUDIO_MSGSM, ""bbb_1ch_8kHz_gsm.wav"",                         ""bbb_1ch_8kHz_s16le.raw"", ""bbb_1ch_8kHz_gsm.wav"", 946.02698f * 1.05f},                 {MediaFormat.MIMETYPE_AUDIO_VORBIS, ""bbb_1ch_16kHz_vorbis.mka"",                         ""bbb_1ch_8kHz_s16le.raw"", ""bbb_2ch_44kHz_vorbis.mka"", -1.0f},                 {MediaFormat.MIMETYPE_AUDIO_OPUS, ""bbb_2ch_48kHz_opus.mka"",                         ""bbb_2ch_48kHz_s16le.raw"", ""bbb_1ch_48kHz_opus.mka"", -1.0f},                 {MediaFormat.MIMETYPE_AUDIO_AAC, ""bbb_1ch_16kHz_aac.mp4"",                         ""bbb_1ch_8kHz_s16le.raw"", ""bbb_2ch_44kHz_aac.mp4"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_MPEG2, ""bbb_340x280_768kbps_30fps_mpeg2.mp4"", null,                         ""bbb_520x390_1mbps_30fps_mpeg2.mp4"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_MPEG2,                         ""bbb_512x288_30fps_1mbps_mpeg2_interlaced_nob_2fields.mp4"", null,                         ""bbb_520x390_1mbps_30fps_mpeg2.mp4"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_MPEG2,                         ""bbb_512x288_30fps_1mbps_mpeg2_interlaced_nob_1field.ts"", null,                         ""bbb_520x390_1mbps_30fps_mpeg2.mp4"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_AVC, ""bbb_340x280_768kbps_30fps_avc.mp4"", null,                         ""bbb_520x390_1mbps_30fps_avc.mp4"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_HEVC, ""bbb_520x390_1mbps_30fps_hevc.mp4"", null,                         ""bbb_340x280_768kbps_30fps_hevc.mp4"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_MPEG4, ""bbb_128x96_64kbps_12fps_mpeg4.mp4"",                         null, ""bbb_176x144_192kbps_15fps_mpeg4.mp4"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_H263, ""bbb_176x144_128kbps_15fps_h263.3gp"",                         null, ""bbb_176x144_192kbps_10fps_h263.3gp"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_VP8, ""bbb_340x280_768kbps_30fps_vp8.webm"", null,                         ""bbb_520x390_1mbps_30fps_vp8.webm"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_VP9, ""bbb_340x280_768kbps_30fps_vp9.webm"", null,                         ""bbb_520x390_1mbps_30fps_vp9.webm"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_VP9,                         ""bbb_340x280_768kbps_30fps_split_non_display_frame_vp9.webm"", null,                         ""bbb_520x390_1mbps_30fps_split_non_display_frame_vp9.webm"", -1.0f},                 {MediaFormat.MIMETYPE_VIDEO_AV1, ""bbb_340x280_768kbps_30fps_av1.mp4"", null,                         ""bbb_520x390_1mbps_30fps_av1.mp4"", -1.0f},         });         return prepareParamList(cddRequiredMimeList, exhaustiveArgsList, false);     }      /**      * Tests decoder for combinations:      * 1. Codec Sync Mode, Signal Eos with Last frame      * 2. Codec Sync Mode, Signal Eos Separately      * 3. Codec Async Mode, Signal Eos with Last frame      * 4. Codec Async Mode, Signal Eos Separately      * In all these scenarios, Timestamp ordering is verified, For audio the Rms of output has to be      * within the allowed tolerance. The output has to be consistent (not flaky) in all runs.      */     @LargeTest     ",9.9.4/C-0-1,,09090400.670001,9.9.4 OTA RAM PIN C-0-1,Test[CtsMediaV2TestCases]:[android.mediav2.cts.CodecDecoderTest:isFormatSupported()],,RAM,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.11.3,C-0-1,,android.os.cts.ParcelFileDescriptorTest,getContext(),,/*  *.  */  package android.os.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.content.Context; import android.os.Handler; import android.os.Looper; import android.os.Parcel; import android.os.ParcelFileDescriptor; import android.os.ParcelFileDescriptor.AutoCloseInputStream; import android.os.Parcelable; import android.os.cts.ParcelFileDescriptorPeer.FutureCloseListener; import android.platform.test.annotations.AppModeFull; import android.system.ErrnoException; import android.system.Os; import android.system.OsConstants; import android.test.MoreAsserts;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.google.common.util.concurrent.AbstractFuture;  import junit.framework.ComparisonFailure;  import org.junit.Test; import org.junit.runner.RunWith;  import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.TimeUnit;  @RunWith(AndroidJUnit4.class) public class ParcelFileDescriptorTest {     private static final long DURATION = 100l;      private Context getContext() {         return InstrumentationRegistry.getContext();     }      ,9.11.3/C-0-1,,09110300.670001,getInstance() 9.11.3 android.content.Context C-0-1,Test[None]:[android.os.cts.ParcelFileDescriptorTest:getContext()],,android.content.Context,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.11.3,C-0-2,,android.security.identity.cts.DynamicAuthTest,,,"/*  *.  */  package android.security.identity.cts;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.content.Context;  import android.security.identity.EphemeralPublicKeyNotFoundException; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.NoAuthenticationKeyAvailableException; import android.security.identity.ResultData; import androidx.test.InstrumentationRegistry;  import org.junit.Test;  import java.io.ByteArrayOutputStream; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.KeyPair; import java.security.SignatureException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.LinkedHashMap; import java.util.Map;  import javax.crypto.SecretKey;  import co.nstant.in.cbor.CborBuilder; import co.nstant.in.cbor.CborEncoder; import co.nstant.in.cbor.CborException;  public class DynamicAuthTest {     private static final String TAG = ""DynamicAuthTest"";      ",9.11.3/C-0-2,,09110300.670002,DMA C-0-2 9.11.3 android.security.identity,Test[None]:[android.security.identity.cts.DynamicAuthTest:],,android.security.identity,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.11.3,C-0-3,,android.security.identity.cts.DynamicAuthTest,,,"/*  *.  */  package android.security.identity.cts;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.content.Context;  import android.security.identity.EphemeralPublicKeyNotFoundException; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.NoAuthenticationKeyAvailableException; import android.security.identity.ResultData; import androidx.test.InstrumentationRegistry;  import org.junit.Test;  import java.io.ByteArrayOutputStream; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.KeyPair; import java.security.SignatureException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.LinkedHashMap; import java.util.Map;  import javax.crypto.SecretKey;  import co.nstant.in.cbor.CborBuilder; import co.nstant.in.cbor.CborEncoder; import co.nstant.in.cbor.CborException;  public class DynamicAuthTest {     private static final String TAG = ""DynamicAuthTest"";      ",9.11.3/C-0-3,,09110300.670003,createEphemeralKeyPair() C-0-3 9.11.3 android.security.identity,Test[None]:[android.security.identity.cts.DynamicAuthTest:],,android.security.identity,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.11.3,C-0-4,,android.security.identity.cts.DynamicAuthTest,dynamicAuthTest(),,"     public void dynamicAuthTest() throws Exception {         assumeTrue(""IC HAL is not implemented"", Util.isHalImplemented());          Context appContext = InstrumentationRegistry.getTargetContext();         IdentityCredentialStore store = IdentityCredentialStore.getInstance(appContext);          String credentialName = ""test"";          store.deleteCredentialByName(credentialName);         Collection<X509Certificate> certChain = ProvisioningTest.createCredential(store,                 credentialName);          IdentityCredential credential = store.getCredentialByName(credentialName,                 IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);         assertNotNull(credential);         assertArrayEquals(new int[0], credential.getAuthenticationDataUsageCount());          credential.setAvailableAuthenticationKeys(5, 3);         assertArrayEquals(                 new int[]{0, 0, 0, 0, 0},                 credential.getAuthenticationDataUsageCount());          // Getting data without device authentication should work even in the case where we haven't         // provisioned any authentication keys. Check that.         Map<String, Collection<String>> entriesToRequest = new LinkedHashMap<>();         entriesToRequest.put(""org.iso.18013-5.2019"", Arrays.asList(""First name"", ""Last name""));         ResultData rd = credential.getEntries(                 Util.createItemsRequest(entriesToRequest, null),                 entriesToRequest,                 null, // sessionTranscript null indicates Device Authentication not requested.                 null);         byte[] resultCbor = rd.getAuthenticatedData();         try {             String pretty = Util.cborPrettyPrint(Util.canonicalizeCbor(resultCbor));             assertEquals(""{\n""                             + ""  'org.iso.18013-5.2019' : {\n""                             + ""    'Last name' : 'Turing',\n""                             + ""    'First name' : 'Alan'\n""                             + ""  }\n""                             + ""}"",                     pretty);         } catch (CborException e) {             e.printStackTrace();             assertTrue(false);         }          KeyPair readerEphemeralKeyPair = Util.createEphemeralKeyPair();          credential = store.getCredentialByName(credentialName,                 IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);         KeyPair ephemeralKeyPair = credential.createEphemeralKeyPair();         credential.setReaderEphemeralPublicKey(readerEphemeralKeyPair.getPublic());          byte[] sessionTranscript = Util.buildSessionTranscript(ephemeralKeyPair);         // Then check that getEntries() throw NoAuthenticationKeyAvailableException (_even_ when         // allowing using exhausted keys).         try {             rd = credential.getEntries(                     Util.createItemsRequest(entriesToRequest, null),                     entriesToRequest,                     sessionTranscript,                     null);             assertTrue(false);         } catch (NoAuthenticationKeyAvailableException e) {             // This is the expected path...         } catch (IdentityCredentialException e) {             e.printStackTrace();             assertTrue(false);         }          // Get auth keys needing certification. This should be all of them. Note that         // this forces the creation of the authentication keys in the HAL.         Collection<X509Certificate> certificates = null;         certificates = credential.getAuthKeysNeedingCertification();         assertEquals(5, certificates.size());          // Do it one more time to check that an auth key is still pending even         // when the corresponding key has been created.         Collection<X509Certificate> certificates2 = null;         certificates2 = credential.getAuthKeysNeedingCertification();         assertArrayEquals(certificates.toArray(), certificates2.toArray());          // Now set auth data for the *first* key (this is the act of certifying the key) and check         // that one less key now needs certification.         X509Certificate key0Cert = certificates.iterator().next();          // Check key0Cert is signed by CredentialKey.         try {             key0Cert.verify(certChain.iterator().next().getPublicKey());         } catch (CertificateException                 | InvalidKeyException                 | NoSuchAlgorithmException                 | NoSuchProviderException                 | SignatureException e) {             e.printStackTrace();             assertTrue(false);         }          try {             credential.storeStaticAuthenticationData(key0Cert, new byte[]{42, 43, 44});             certificates = credential.getAuthKeysNeedingCertification();         } catch (IdentityCredentialException e) {             e.printStackTrace();             assertTrue(false);         }         assertEquals(4, certificates.size());          // Now certify the *last* key.         X509Certificate key4Cert = new ArrayList<X509Certificate>(certificates).get(             certificates.size() - 1);         try {             key4Cert.verify(certChain.iterator().next().getPublicKey());         } catch (CertificateException                 | InvalidKeyException                 | NoSuchAlgorithmException                 | NoSuchProviderException                 | SignatureException e) {             e.printStackTrace();             assertTrue(false);         }          try {             credential.storeStaticAuthenticationData(key4Cert, new byte[]{43, 44, 45});             certificates = credential.getAuthKeysNeedingCertification();         } catch (IdentityCredentialException e) {             e.printStackTrace();             assertTrue(false);         }         assertEquals(3, certificates.size());          // Now that we've provisioned authentication keys, presentation will no longer fail with         // NoAuthenticationKeyAvailableException ... So now we can try a sessionTranscript without         // the ephemeral public key that was created in the Secure Area and check it fails with         // EphemeralPublicKeyNotFoundException instead...         ByteArrayOutputStream stBaos = new ByteArrayOutputStream();         try {             new CborEncoder(stBaos).encode(new CborBuilder()                     .addArray()                     .add(new byte[]{0x01, 0x02})  // The device engagement structure, encoded                     .add(new byte[]{0x03, 0x04})  // Reader ephemeral public key, encoded                     .end()                     .build());         } catch (CborException e) {             e.printStackTrace();             assertTrue(false);         }         byte[] wrongSessionTranscript = stBaos.toByteArray();         try {             rd = credential.getEntries(                     Util.createItemsRequest(entriesToRequest, null),                     entriesToRequest,                     wrongSessionTranscript,                     null);             assertTrue(false);         } catch (EphemeralPublicKeyNotFoundException e) {             // This is the expected path...         } catch (IdentityCredentialException e) {             e.printStackTrace();             assertTrue(false);         }          // Now use one of the keys...         entriesToRequest = new LinkedHashMap<>();         entriesToRequest.put(""org.iso.18013-5.2019"",                 Arrays.asList(""First name"",                         ""Last name"",                         ""Home address"",                         ""Birth date"",                         ""Cryptanalyst"",                         ""Portrait image"",                         ""Height""));         credential = store.getCredentialByName(credentialName,                 IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);         ephemeralKeyPair = credential.createEphemeralKeyPair();         credential.setReaderEphemeralPublicKey(readerEphemeralKeyPair.getPublic());         sessionTranscript = Util.buildSessionTranscript(ephemeralKeyPair);         rd = credential.getEntries(                 Util.createItemsRequest(entriesToRequest, null),                 entriesToRequest,                 sessionTranscript,                 null);         resultCbor = rd.getAuthenticatedData();         try {             String pretty = Util.cborPrettyPrint(Util.canonicalizeCbor(resultCbor));             assertEquals(""{\n""                             + ""  'org.iso.18013-5.2019' : {\n""                             + ""    'Height' : 180,\n""                             + ""    'Last name' : 'Turing',\n""                             + ""    'Birth date' : '19120623',\n""                             + ""    'First name' : 'Alan',\n""                             + ""    'Cryptanalyst' : true,\n""                             + ""    'Home address' : 'Maida Vale, London, England',\n""                             + ""    'Portrait image' : [0x01, 0x02]\n""                             + ""  }\n""                             + ""}"",                     pretty);         } catch (CborException e) {             e.printStackTrace();             assertTrue(false);         }          byte[] deviceAuthenticationCbor = Util.buildDeviceAuthenticationCbor(             ""org.iso.18013-5.2019.mdl"",             sessionTranscript,             resultCbor);          // Calculate the MAC by deriving the key using ECDH and HKDF.         SecretKey eMacKey = Util.calcEMacKeyForReader(             key0Cert.getPublicKey(),             readerEphemeralKeyPair.getPrivate(),             sessionTranscript);         byte[] deviceAuthenticationBytes =                 Util.prependSemanticTagForEncodedCbor(deviceAuthenticationCbor);         byte[] expectedMac = Util.coseMac0(eMacKey,                 new byte[0],                 // payload                 deviceAuthenticationBytes);  // detached content          // Then compare it with what the TA produced.         assertArrayEquals(expectedMac, rd.getMessageAuthenticationCode());          // Check that key0's static auth data is returned and that this         // key has an increased use-count.         assertArrayEquals(new byte[]{42, 43, 44}, rd.getStaticAuthenticationData());         assertArrayEquals(new int[]{1, 0, 0, 0, 0}, credential.getAuthenticationDataUsageCount());           // Now do this one more time.... this time key4 should have been used. Check this by         // inspecting use-counts and the static authentication data.         credential = store.getCredentialByName(credentialName,                 IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);         ephemeralKeyPair = credential.createEphemeralKeyPair();         credential.setReaderEphemeralPublicKey(readerEphemeralKeyPair.getPublic());         sessionTranscript = Util.buildSessionTranscript(ephemeralKeyPair);         rd = credential.getEntries(                 Util.createItemsRequest(entriesToRequest, null),                 entriesToRequest,                 sessionTranscript,                 null);         assertArrayEquals(new byte[]{43, 44, 45}, rd.getStaticAuthenticationData());         assertArrayEquals(new int[]{1, 0, 0, 0, 1}, credential.getAuthenticationDataUsageCount());          // Verify MAC was made with key4.         deviceAuthenticationCbor = Util.buildDeviceAuthenticationCbor(             ""org.iso.18013-5.2019.mdl"",             sessionTranscript,             resultCbor);         eMacKey = Util.calcEMacKeyForReader(             key4Cert.getPublicKey(),             readerEphemeralKeyPair.getPrivate(),             sessionTranscript);         deviceAuthenticationBytes =                 Util.prependSemanticTagForEncodedCbor(deviceAuthenticationCbor);         expectedMac = Util.coseMac0(eMacKey,                 new byte[0],                 // payload                 deviceAuthenticationBytes);  // detached content         assertArrayEquals(expectedMac, rd.getMessageAuthenticationCode());          // And again.... this time key0 should have been used. Check it.         credential = store.getCredentialByName(credentialName,                 IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);         ephemeralKeyPair = credential.createEphemeralKeyPair();         credential.setReaderEphemeralPublicKey(readerEphemeralKeyPair.getPublic());         sessionTranscript = Util.buildSessionTranscript(ephemeralKeyPair);         rd = credential.getEntries(                 Util.createItemsRequest(entriesToRequest, null),                 entriesToRequest,                 sessionTranscript,                 null);         assertArrayEquals(new byte[]{42, 43, 44}, rd.getStaticAuthenticationData());         assertArrayEquals(new int[]{2, 0, 0, 0, 1}, credential.getAuthenticationDataUsageCount());          // And again.... this time key4 should have been used. Check it.         credential = store.getCredentialByName(credentialName,                 IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);         ephemeralKeyPair = credential.createEphemeralKeyPair();         credential.setReaderEphemeralPublicKey(readerEphemeralKeyPair.getPublic());         sessionTranscript = Util.buildSessionTranscript(ephemeralKeyPair);         rd = credential.getEntries(                 Util.createItemsRequest(entriesToRequest, null),                 entriesToRequest,                 sessionTranscript,                 null);         assertArrayEquals(new byte[]{43, 44, 45}, rd.getStaticAuthenticationData());         assertArrayEquals(new int[]{2, 0, 0, 0, 2}, credential.getAuthenticationDataUsageCount());          // We configured each key to have three uses only. So we have two more presentations         // to go until we run out... first, check that only three keys need certifications         certificates = credential.getAuthKeysNeedingCertification();         assertEquals(3, certificates.size());          // Then exhaust the two we've already configured.         for (int n = 0; n < 2; n++) {             credential = store.getCredentialByName(credentialName,                 IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);             ephemeralKeyPair = credential.createEphemeralKeyPair();             credential.setReaderEphemeralPublicKey(readerEphemeralKeyPair.getPublic());             sessionTranscript = Util.buildSessionTranscript(ephemeralKeyPair);             rd = credential.getEntries(                     Util.createItemsRequest(entriesToRequest, null),                     entriesToRequest,                     sessionTranscript,                     null);             assertNotNull(rd);         }         assertArrayEquals(new int[]{3, 0, 0, 0, 3}, credential.getAuthenticationDataUsageCount());          // Now we should have five certs needing certification.         certificates = credential.getAuthKeysNeedingCertification();         assertEquals(5, certificates.size());          // We still have the two keys which have been exhausted.         assertArrayEquals(new int[]{3, 0, 0, 0, 3}, credential.getAuthenticationDataUsageCount());          // Check that we fail when running out of presentations (and explicitly don't allow         // exhausting keys).         try {             credential = store.getCredentialByName(credentialName,                 IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);             ephemeralKeyPair = credential.createEphemeralKeyPair();             credential.setReaderEphemeralPublicKey(readerEphemeralKeyPair.getPublic());             sessionTranscript = Util.buildSessionTranscript(ephemeralKeyPair);             credential.setAllowUsingExhaustedKeys(false);             rd = credential.getEntries(                     Util.createItemsRequest(entriesToRequest, null),                     entriesToRequest,                     sessionTranscript,                     null);             assertTrue(false);         } catch (IdentityCredentialException e) {             assertTrue(e instanceof NoAuthenticationKeyAvailableException);         }         assertArrayEquals(new int[]{3, 0, 0, 0, 3}, credential.getAuthenticationDataUsageCount());          // Now try with allowing using auth keys already exhausted... this should work!         try {             credential = store.getCredentialByName(credentialName,                 IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);             ephemeralKeyPair = credential.createEphemeralKeyPair();             credential.setReaderEphemeralPublicKey(readerEphemeralKeyPair.getPublic());             sessionTranscript = Util.buildSessionTranscript(ephemeralKeyPair);             rd = credential.getEntries(                     Util.createItemsRequest(entriesToRequest, null),                     entriesToRequest,                     sessionTranscript,                     null);         } catch (IdentityCredentialException e) {             e.printStackTrace();             assertTrue(false);         }         assertArrayEquals(new int[]{4, 0, 0, 0, 3}, credential.getAuthenticationDataUsageCount());          // Check that replenishing works...         certificates = credential.getAuthKeysNeedingCertification();         assertEquals(5, certificates.size());         X509Certificate keyNewCert = certificates.iterator().next();         try {             credential.storeStaticAuthenticationData(keyNewCert, new byte[]{10, 11, 12});             certificates = credential.getAuthKeysNeedingCertification();         } catch (IdentityCredentialException e) {             e.printStackTrace();             assertTrue(false);         }         assertEquals(4, certificates.size());         assertArrayEquals(new int[]{0, 0, 0, 0, 3}, credential.getAuthenticationDataUsageCount());         credential = store.getCredentialByName(credentialName,                 IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);         ephemeralKeyPair = credential.createEphemeralKeyPair();         credential.setReaderEphemeralPublicKey(readerEphemeralKeyPair.getPublic());         sessionTranscript = Util.buildSessionTranscript(ephemeralKeyPair);         rd = credential.getEntries(                 Util.createItemsRequest(entriesToRequest, null),                 entriesToRequest,                 sessionTranscript,                 null);         assertArrayEquals(new byte[]{10, 11, 12}, rd.getStaticAuthenticationData());         assertArrayEquals(new int[]{1, 0, 0, 0, 3}, credential.getAuthenticationDataUsageCount());          deviceAuthenticationCbor = Util.buildDeviceAuthenticationCbor(             ""org.iso.18013-5.2019.mdl"",             sessionTranscript,             resultCbor);         eMacKey = Util.calcEMacKeyForReader(             keyNewCert.getPublicKey(),             readerEphemeralKeyPair.getPrivate(),             sessionTranscript);         deviceAuthenticationBytes =                 Util.prependSemanticTagForEncodedCbor(deviceAuthenticationCbor);         expectedMac = Util.coseMac0(eMacKey,                 new byte[0],                 // payload                 deviceAuthenticationBytes);  // detached content         assertArrayEquals(expectedMac, rd.getMessageAuthenticationCode());          // ... and we're done. Clean up after ourselves.         store.deleteCredentialByName(credentialName);     }      // TODO: test storeStaticAuthenticationData() throwing UnknownAuthenticationKeyException     // on an unknown auth key } ",9.11.3/C-0-4,,09110300.670004,MAC C-0-4 9.11.3,Test[None]:[android.security.identity.cts.DynamicAuthTest:dynamicAuthTest()],,MAC,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.16,C-1-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",9.16/C-1-1,,09160000.670101,9.16 C-1-1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-1-1,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.16,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.16/C-1-2,,09160000.670102,9.16 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.16,C-1-4,,android.autofillservice.cts.DisableAutofillTest,testDisableActivity(),CtsAutoFillServiceTestCases,"     @AppModeFull(reason = ""testDisableActivity() is enough"")     public void testDisableActivityThenResetServiceToReenableIt() throws Exception {         enableService();         sReplier.addResponse(new CannedFillResponse.Builder()                 .disableAutofill(Long.MAX_VALUE)                 .setFillResponseFlags(FillResponse.FLAG_DISABLE_ACTIVITY_ONLY)                 .build());          // Trigger autofill for the first time.         launchSimpleSaveActivity(PostLaunchAction.ASSERT_DISABLING);         // Launch activity again.         launchSimpleSaveActivity(PostLaunchAction.ASSERT_DISABLED);          // Make sure other app is working.         launchPreSimpleSaveActivity(PostLaunchAction.ASSERT_ENABLED_AND_AUTOFILL);          // Then ""reset"" service to re-enable autofill.         disableService();         enableService();          // Try again on activity that disabled it.         launchSimpleSaveActivity(PostLaunchAction.ASSERT_ENABLED_AND_AUTOFILL);     }      private void assertAutofillEnabled(AbstractAutoFillActivity activity, boolean expected)             throws Exception {         ACTIVITY_RESURRECTION.run(                 ""assertAutofillEnabled("" + activity.getComponentName().flattenToShortString() + "")"",                 () -> {                     return activity.getAutofillManager().isEnabled() == expected                             ? Boolean.TRUE : null;                 });     }      private void sleep(long passedTime, long disableDuration) {         final long napTime = disableDuration - passedTime + 500;         if (napTime <= 0) {             // Throw an exception so ACTIVITY_RESURRECTION is increased             throw new RetryableException(""took longer than expcted to launch activities: ""                             + ""passedTime="" + passedTime + ""ms, disableDuration="" + disableDuration                             + "", ACTIVITY_RESURRECTION="" + ACTIVITY_RESURRECTION                             + "", CALLBACK_NOT_CALLED_TIMEOUT_MS="" + CALLBACK_NOT_CALLED_TIMEOUT_MS);         }         Log.v(TAG, ""Sleeping for "" + napTime + ""ms (duration="" + disableDuration + ""ms, passedTime=""                 + passedTime + "")"");         SystemClock.sleep(napTime);     } } ",9.16/C-1-4,,09160000.670104,9.16 C-1-4 AND,Test[CtsAutoFillServiceTestCases]:[android.autofillservice.cts.DisableAutofillTest:testDisableActivity()],,AND,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
,9.16,C-1-5,,android.graphics.cts.VulkanFeaturesTest,testVulkan1_1Requirements(),,"     public void testVulkan1_1Requirements() throws JSONException {         if (mVulkanHardwareVersion == null || mVulkanHardwareVersion.version < VULKAN_1_1                 || !PropertyUtil.isVendorApiLevelNewerThan(                         API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ)) {             return;         }         assertTrue(""Devices with Vulkan 1.1 must support sampler YCbCr conversion"",                 mBestDevice.getJSONObject(""samplerYcbcrConversionFeatures"")                            .getInt(""samplerYcbcrConversion"") != 0);          if (hasOnlyCpuDevice()) {             return;         }         assertTrue(""Devices with Vulkan 1.1 must support "" +                 VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME +                 "" (version >= "" + VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION +                 "")"",                 hasExtension(mBestDevice,                     VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME,                     VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION));         assertTrue(""Devices with Vulkan 1.1 must support SYNC_FD external semaphores"",                 hasHandleType(mBestDevice.getJSONArray(""externalSemaphoreProperties""),                     VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,                     ""externalSemaphoreFeatures"", 0x3 /* importable + exportable */));         assertTrue(""Devices with Vulkan 1.1 must support SYNC_FD external fences"",                 hasHandleType(mBestDevice.getJSONArray(""externalFenceProperties""),                     VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,                     ""externalFenceFeatures"", 0x3 /* importable + exportable */));     }      @CddTest(requirement = ""7.9.2/C-1-5"")     ",9.16/C-1-5,,09160000.670105,9.16 C-1-5,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkan1_1Requirements()],,C-1-5,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,,
