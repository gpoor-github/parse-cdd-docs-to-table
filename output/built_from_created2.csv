Section,section_id,req_id,Test Availability,class_def,method,module,method_text,full_key,requirement,key_as_number,search_terms,qualified_method,manual_search_terms,matched_terms,file_name,matched_files,methods_string,urls
,7.1.1.1,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.1.1/H-1-1,,07010101.720101,H-1-1 7.1.1.1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-1,,07010406.720101,7.1.4.6 H-1-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-2,,07010406.720102,7.1.4.6 H-1-2,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-2,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-3,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-3,,07010406.720103,7.1.4.6 H-1-3,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-3,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-4,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-4,,07010406.720104,7.1.4.6 H-1-4,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-4,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-1,,03081600.720101,H-1-1 3.8.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-2,,03081600.720102,3.8.16 H-1-2,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-2,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-3,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-3,,03081600.720103,3.8.16 H-1-3,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-3,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-4,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-4,,03081600.720104,3.8.16 H-1-4,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-4,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.2.3.5,C-2-6,,android.packageinstaller.tapjacking.cts.TapjackingTest,testTapsDroppedWhenObscured(),,"     public void testTapsDroppedWhenObscured() throws Exception {         Log.i(LOG_TAG, ""launchPackageInstaller"");         launchPackageInstaller();         UiObject2 installButton = waitForView(SYSTEM_PACKAGE_NAME, INSTALL_BUTTON_ID);         assertNotNull(""Install button not shown"", installButton);         Log.i(LOG_TAG, ""launchOverlayingActivity"");         launchOverlayingActivity();         assertNotNull(""Overlaying activity not started"",                 waitForView(mPackageName, OVERLAY_ACTIVITY_TEXT_VIEW_ID));         installButton = waitForView(SYSTEM_PACKAGE_NAME, INSTALL_BUTTON_ID);         assertNotNull(""Cannot find install button below overlay activity"", installButton);         Log.i(LOG_TAG, ""installButton.click"");         installButton.click();         assertFalse(""Tap on install button succeeded"", mUiDevice.wait(                 Until.gone(By.res(SYSTEM_PACKAGE_NAME, INSTALL_BUTTON_ID)),                 WAIT_FOR_UI_TIMEOUT));         mUiDevice.pressBack();     }      @After     public void tearDown() throws Exception {         mUiDevice.pressHome();     }      private static final class RequiredRule implements TestRule {         boolean mIsWatch;         RequiredRule(boolean isWatch) {             mIsWatch = isWatch;         }         @Override         public Statement apply(Statement base, Description description) {             return new Statement() {                  @Override                 public void evaluate() throws Throwable {                     if (mIsWatch) {                         throw new AssumptionViolatedException(""Install/uninstall feature is not supported on WearOs"");                     }                     base.evaluate();                 }             };         }     } } ",3.2.3.5/C-2-6,,03020305.670206,android.intent.action.VIEW android.intent.action.SENDTO SENDTO VIEW C-2-6 SMS ACTION_SENDTO 3.2.3.5,Test[None]:[android.packageinstaller.tapjacking.cts.TapjackingTest:testTapsDroppedWhenObscured()],,VIEW,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/packageinstaller/tapjacking/src/android/packageinstaller/tapjacking/cts/TapjackingTest.java,,
,3.2.3.5,C-5-2,,android.app.notification.legacy.cts.ConditionProviderServiceTest,testUnboundCPSMaintainsCondition_otherProviderRuleChanges(),,"     public void testUnboundCPSMaintainsCondition_otherProviderRuleChanges() throws Exception {         // make sure both services get bound         pollForConnection(LegacyConditionProviderService.class, true);         pollForConnection(SecondaryConditionProviderService.class, true);          // add rules for both         mModeReceiver.reset();          addRule(LegacyConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, true);         pollForSubscribe(LegacyConditionProviderService.getInstance());          addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_ALARMS, true);         pollForSubscribe(SecondaryConditionProviderService.getInstance());          mModeReceiver.waitFor(2/*Legacy and Secondary*/, 1000/*Limit is 1 second*/);         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // unbind one of the services         SecondaryConditionProviderService.getInstance().requestUnbind();          // verify that DND state doesn't change         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // trigger a change in the bound service's rule         addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, false);          // verify that the unbound service maintains it's DND vote         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());     }      ",3.2.3.5/C-5-2,,03020305.670502,DND REQUEST_DISCOVERABLE C-5-2 android.bluetooth.adapter.action.REQUEST ACTION_REQUEST_DISCOVERABLE 3.2.3.5,Test[None]:[android.app.notification.legacy.cts.ConditionProviderServiceTest:testUnboundCPSMaintainsCondition_otherProviderRuleChanges()],,DND,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/notificationlegacy/notificationlegacy27/src/android/app/notification/legacy/cts/ConditionProviderServiceTest.java,,
,3.2.3.5,C-6-1,,android.app.notification.legacy.cts.ConditionProviderServiceTest,testUnboundCPSMaintainsCondition_otherProviderRuleChanges(),,"     public void testUnboundCPSMaintainsCondition_otherProviderRuleChanges() throws Exception {         // make sure both services get bound         pollForConnection(LegacyConditionProviderService.class, true);         pollForConnection(SecondaryConditionProviderService.class, true);          // add rules for both         mModeReceiver.reset();          addRule(LegacyConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, true);         pollForSubscribe(LegacyConditionProviderService.getInstance());          addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_ALARMS, true);         pollForSubscribe(SecondaryConditionProviderService.getInstance());          mModeReceiver.waitFor(2/*Legacy and Secondary*/, 1000/*Limit is 1 second*/);         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // unbind one of the services         SecondaryConditionProviderService.getInstance().requestUnbind();          // verify that DND state doesn't change         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // trigger a change in the bound service's rule         addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, false);          // verify that the unbound service maintains it's DND vote         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());     }      ",3.2.3.5/C-6-1,,03020305.670601,MODE_TYPE_NORMAL DND C-6-1 ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS 3.2.3.5,Test[None]:[android.app.notification.legacy.cts.ConditionProviderServiceTest:testUnboundCPSMaintainsCondition_otherProviderRuleChanges()],,DND,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/notificationlegacy/notificationlegacy27/src/android/app/notification/legacy/cts/ConditionProviderServiceTest.java,,
,3.2.3.5,C-8-1,,android.accessibilityservice.cts.AccessibilitySettingsTest,testAccessibilitySettingsIntentHandled(),CtsAccessibilityServiceTestCases,"     public void testAccessibilitySettingsIntentHandled() throws Throwable {         PackageManager packageManager = getContext().getPackageManager();         Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);         List<ResolveInfo> resolvedActivities = packageManager.queryIntentActivities(intent,                 PackageManager.MATCH_DEFAULT_ONLY);          // make sure accessibility settings exist         String message = ""Accessibility settings activity must be launched via Intent "" +                 ""Settings.ACTION_ACCESSIBILITY_SETTINGS"";         assertTrue(message, !resolvedActivities.isEmpty());     } }  ",3.2.3.5/C-8-1,,03020305.670801,C-8-1 ACTION_ACCESSIBILITY_SETTINGS android.settings.ACCESSIBILITY ACCESSIBILITY_SETTINGS 3.2.3.5,Test[CtsAccessibilityServiceTestCases]:[android.accessibilityservice.cts.AccessibilitySettingsTest:testAccessibilitySettingsIntentHandled()],,ACCESSIBILITY_SETTINGS,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySettingsTest.java,,
,3.2.3.5,C-11-1,,android.accessibilityservice.cts.AccessibilityGlobalActionsTest,testPerformGlobalActionQuickSettings(),CtsAccessibilityServiceTestCases,     public void testPerformGlobalActionQuickSettings() throws Exception {         // Check whether the action succeeded.         assertTrue(sUiAutomation.performGlobalAction(                 AccessibilityService.GLOBAL_ACTION_QUICK_SETTINGS));          // Sleep a bit so the UI is settled.         waitForIdle();     }      @MediumTest     ,3.2.3.5/C-11-1,,03020305.671101,android.hardware.camera.any C-11-1 ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SET Settings.ACTION TINGS 3.2.3.5,Test[CtsAccessibilityServiceTestCases]:[android.accessibilityservice.cts.AccessibilityGlobalActionsTest:testPerformGlobalActionQuickSettings()],,TINGS,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGlobalActionsTest.java,,
,3.2.3.5,C-13-2,,android.content.cts.ClipboardManagerTest,testPrimaryClipNotAvailableWithoutFocus(),,"     public void testPrimaryClipNotAvailableWithoutFocus() throws Exception {         ClipData textData = ClipData.newPlainText(""TextLabel"", ""Text1"");         assertSetPrimaryClip(textData, ""TextLabel"",                 new String[] {ClipDescription.MIMETYPE_TEXT_PLAIN},                 new ExpectedClipItem(""Text1"", null, null));          // Press the home button to unfocus the app.         mUiDevice.pressHome();         mUiDevice.wait(Until.gone(By.clazz(MockActivity.class)), 5000);          // We should see an empty clipboard now.         assertFalse(mClipboardManager.hasPrimaryClip());         assertFalse(mClipboardManager.hasText());         assertNull(mClipboardManager.getPrimaryClip());         assertNull(mClipboardManager.getPrimaryClipDescription());          // We should be able to set the clipboard but not see the contents.         mClipboardManager.setPrimaryClip(ClipData.newPlainText(""TextLabel"", ""Text2""));         assertFalse(mClipboardManager.hasPrimaryClip());         assertFalse(mClipboardManager.hasText());         assertNull(mClipboardManager.getPrimaryClip());         assertNull(mClipboardManager.getPrimaryClipDescription());          // Launch an activity to get back in focus.         launchActivity(MockActivity.class);           // Verify clipboard access is restored.         assertNotNull(mClipboardManager.getPrimaryClip());         assertNotNull(mClipboardManager.getPrimaryClipDescription());          // Verify we were unable to change the clipboard while out of focus.         assertClipData(mClipboardManager.getPrimaryClip(),                 ""TextLabel"",                 new String[] {ClipDescription.MIMETYPE_TEXT_PLAIN},                 new ExpectedClipItem(""Text2"", null, null));     }      private void launchActivity(Class<? extends Activity> clazz) {         Intent intent = new Intent(Intent.ACTION_MAIN);         intent.setClassName(mContext.getPackageName(), clazz.getName());         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         mContext.startActivity(intent);         mUiDevice.wait(Until.hasObject(By.clazz(clazz)), 5000);     }      private class ExpectedClipItem {         CharSequence mText;         Intent mIntent;         Uri mUri;          ExpectedClipItem(CharSequence text, Intent intent, Uri uri) {             mText = text;             mIntent = intent;             mUri = uri;         }     }      private void assertSetPrimaryClip(ClipData clipData,             String expectedLabel,             String[] expectedMimeTypes,             ExpectedClipItem... expectedClipItems) {         ClipboardManager clipboardManager = mClipboardManager;          clipboardManager.setPrimaryClip(clipData);         assertTrue(clipboardManager.hasPrimaryClip());          if (expectedClipItems != null                 && expectedClipItems.length > 0                 && expectedClipItems[0].mText != null) {             assertTrue(clipboardManager.hasText());         } else {             assertFalse(clipboardManager.hasText());         }          assertNotNull(clipboardManager.getPrimaryClip());         assertNotNull(clipboardManager.getPrimaryClipDescription());          assertClipData(clipboardManager.getPrimaryClip(),                 expectedLabel, expectedMimeTypes, expectedClipItems);          assertClipDescription(clipboardManager.getPrimaryClipDescription(),                 expectedLabel, expectedMimeTypes);     }      private static void assertClipData(ClipData actualData, String expectedLabel,             String[] expectedMimeTypes, ExpectedClipItem... expectedClipItems) {         if (expectedClipItems != null) {             assertEquals(expectedClipItems.length, actualData.getItemCount());             for (int i = 0; i < expectedClipItems.length; i++) {                 assertClipItem(expectedClipItems[i], actualData.getItemAt(i));             }         } else {             throw new IllegalArgumentException(""Should have at least one expectedClipItem..."");         }          assertClipDescription(actualData.getDescription(), expectedLabel, expectedMimeTypes);     }      private static void assertClipDescription(ClipDescription description, String expectedLabel,             String... mimeTypes) {         assertEquals(expectedLabel, description.getLabel());         assertEquals(mimeTypes.length, description.getMimeTypeCount());         int mimeTypeCount = description.getMimeTypeCount();         for (int i = 0; i < mimeTypeCount; i++) {             assertEquals(mimeTypes[i], description.getMimeType(i));         }     }      private static void assertClipItem(ExpectedClipItem expectedItem, Item item) {         assertEquals(expectedItem.mText, item.getText());         if (expectedItem.mIntent != null) {             assertNotNull(item.getIntent());         } else {             assertNull(item.getIntent());         }         if (expectedItem.mUri != null) {             assertEquals(expectedItem.mUri.toString(), item.getUri().toString());         } else {             assertNull(item.getUri());         }     }      private boolean hasAutoFillFeature() {         return mContext.getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_AUTOFILL);     } } ",3.2.3.5/C-13-2,,03020305.671302,GET_PROVISIONING_MODE SET_NEW_PARENT_PROFILE_PASSWORD C-13-2 START_ENCRYPTION android.app.action.GET ACTION_ADMIN_POLICY_COMPLIANCE android.app.action.PROVISIONING android.app.action.PROVISION PROVISION_MANAGED_DEVICE ADMIN_POLICY_COMPLIANCE PROVISIONING_SUCCESSFUL PROVISION_MANAGED_PROFILE FEATURE_AUTOFILL SET_NEW_PASSWORD PackageManager.html 3.2.3.5 ACTION_START_ENCRYPTION android.app.action.START android.app.action.ADMIN android.app.action.SET android.software.autofill,Test[None]:[android.content.cts.ClipboardManagerTest:testPrimaryClipNotAvailableWithoutFocus()],,FEATURE_AUTOFILL,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ClipboardManagerTest.java,,
,3.2.3.5,C-14-1,,android.autofillservice.cts.SettingsIntentTest,testWarningShown_userRejectsByTappingBack(),CtsAutoFillServiceTestCases,"     public void testWarningShown_userRejectsByTappingBack() throws Exception {         disableService();          // Launches Settings.         mActivity.startForResult(newSettingsIntent(), MY_REQUEST_CODE);          // Asserts services are shown.         final UiObject2 object = mUiBot                 .assertShownByText(InstrumentedAutoFillService.sServiceLabel);         object.click();          // TODO(b/79615759): should assert that ""autofill_confirmation_message"" is shown, but that         // string belongs to Settings - we need to move it to frameworks/base first (and/or use         // a resource id, also on framework).         // So, for now, just asserts the service name is showing again (in the popup), and the other         // services are not showing (because the popup hides then).          final UiObject2 msgObj = mUiBot.assertShownById(""android:id/message"");         final String msg = msgObj.getText();         assertWithMessage(""Wrong warning message"").that(msg)                 .contains(InstrumentedAutoFillService.sServiceLabel);          // NOTE: assertion below is fine because it looks for the full text, not a substring         mUiBot.assertNotShowingForSure(InstrumentedAutoFillService.sServiceLabel);         mUiBot.assertNotShowingForSure(InstrumentedAutoFillServiceCompatMode.sServiceLabel);         mUiBot.assertNotShowingForSure(NoOpAutofillService.SERVICE_LABEL);         mUiBot.assertNotShowingForSure(BadAutofillService.SERVICE_LABEL);          // Finishes and asserts result.         mUiBot.pressBack();         mActivity.assertResult(Activity.RESULT_CANCELED);     }      // TODO(b/79615759): add testWarningShown_userRejectsByTappingCancel() and     // testWarningShown_userAccepts() - these tests would require adding the strings and resource     // ids to frameworks/base      private Intent newSettingsIntent() {         return new Intent(Settings.ACTION_REQUEST_SET_AUTOFILL_SERVICE)                 .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)                 .setData(Uri.parse(""package:"" + Helper.MY_PACKAGE));     } } ",3.2.3.5/C-14-1,,03020305.671401,REQUEST_SET_AUTOFILL_SERVICE ACTION_REQUEST_SET_AUTOFILL_SERVICE android.settings.REQUEST Settings.html AutofillService.html C-14-1 AutofillManager.html 3.2.3.5,Test[CtsAutoFillServiceTestCases]:[android.autofillservice.cts.SettingsIntentTest:testWarningShown_userRejectsByTappingBack()],,ACTION_REQUEST_SET_AUTOFILL_SERVICE,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/SettingsIntentTest.java,,
,3.2.3.5,C-15-1,,android.permission.cts.BackgroundPermissionsTest,appOpIsSetIfFineCoarseAndBgLocPermIsGranted(),,"     @AppModeFull(reason = ""Instant apps cannot read properties of other packages which is needed ""             + ""to grant permissions to them. Also instant apps are never updated, hence the test ""             + ""is useless."")     public void appOpIsSetIfFineCoarseAndBgLocPermIsGranted() {         install(APK_LOCATION_BACKGROUND_29);         sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_FINE_LOCATION);         sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_COARSE_LOCATION);         sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_BACKGROUND_LOCATION);          // Wait until the system sets the app-op automatically         eventually(() -> assertThat(getAppOp(APP_PKG, ACCESS_COARSE_LOCATION)).named(                 ""loc app-op"").isEqualTo(MODE_ALLOWED));     } } ",3.2.3.5/C-15-1,,03020305.671501,USAGE android.hardware.audio.output C-15-1 ACTION_USAGE_ACCESS_SETTINGS ACCESS Settings.html android.settings.ACTION ACTION SETTINGS 3.2.3.5,Test[None]:[android.permission.cts.BackgroundPermissionsTest:appOpIsSetIfFineCoarseAndBgLocPermIsGranted()],,ACCESS,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/permission/src/android/permission/cts/BackgroundPermissionsTest.java,,
,3.9.2,C-2-1,,android.server.wm.ReplaceWindowTests,setUp(),,"/*  *.  */  package android.server.wm;  import static android.app.WindowConfiguration.WINDOWING_MODE_SPLIT_SCREEN_PRIMARY; import static android.server.wm.ComponentNameUtils.getWindowName; import static android.server.wm.StateLogger.log; import static android.server.wm.app.Components.NO_RELAUNCH_ACTIVITY; import static android.server.wm.app.Components.SLOW_CREATE_ACTIVITY;  import static org.junit.Assert.assertEquals; import static org.junit.Assume.assumeTrue;  import android.content.ComponentName; import android.os.SystemClock; import android.platform.test.annotations.Presubmit;  import org.junit.Before; import org.junit.Test;  import java.util.List; import java.util.concurrent.TimeUnit;  /**  * Build/Install/Run:  *     atest CtsWindowManagerDeviceTestCases:ReplaceWindowTests  */ @Presubmit public class ReplaceWindowTests extends ActivityManagerTestBase {      @Before     @Override     public void setUp() throws Exception {         super.setUp();          assumeTrue(""Skipping test: no multi-window support"", supportsSplitScreenMultiWindow());     }      ",3.9.2/C-2-1,,03090200.670201,ACTION_SET_NEW_PASSWORD admin.html DPC DevicePolicyManager.html C-2-1 DevicePolicyManager.ACTION 3.9.2 index.html android.content.ComponentName,Test[None]:[android.server.wm.ReplaceWindowTests:setUp()],,android.content.ComponentName,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ReplaceWindowTests.java,,
,6.1,C-0-11,,android.media.cts.AudioTrackTest,testPlayStreamData(),,"     public void testPlayStreamData() throws Exception {         // constants for test         final String TEST_NAME = ""testPlayStreamData"";         final int TEST_FORMAT_ARRAY[] = {  // should hear 40 increasing frequency tones, 3 times                 AudioFormat.ENCODING_PCM_8BIT,                 AudioFormat.ENCODING_PCM_16BIT,                 AudioFormat.ENCODING_PCM_FLOAT,         };         // due to downmixer algorithmic latency, source channels greater than 2 may         // sound shorter in duration at 4kHz sampling rate.         final int TEST_SR_ARRAY[] = {                 4000,                 44100,                 48000,                 96000,                 192000,         };         final int TEST_CONF_ARRAY[] = {                 AudioFormat.CHANNEL_OUT_MONO,    // 1.0                 AudioFormat.CHANNEL_OUT_STEREO,  // 2.0                 AudioFormat.CHANNEL_OUT_STEREO | AudioFormat.CHANNEL_OUT_FRONT_CENTER, // 3.0                 AudioFormat.CHANNEL_OUT_QUAD,    // 4.0                 AudioFormat.CHANNEL_OUT_QUAD | AudioFormat.CHANNEL_OUT_FRONT_CENTER,   // 5.0                 AudioFormat.CHANNEL_OUT_5POINT1, // 5.1                 AudioFormat.CHANNEL_OUT_5POINT1 | AudioFormat.CHANNEL_OUT_BACK_CENTER, // 6.1                 AudioFormat.CHANNEL_OUT_7POINT1_SURROUND, // 7.1         };         final int TEST_MODE = AudioTrack.MODE_STREAM;         final int TEST_STREAM_TYPE = AudioManager.STREAM_MUSIC;         final float TEST_SWEEP = 0; // sine wave only         final boolean TEST_IS_LOW_RAM_DEVICE = isLowRamDevice();          for (int TEST_FORMAT : TEST_FORMAT_ARRAY) {             double frequency = 400; // frequency changes for each test             for (int TEST_SR : TEST_SR_ARRAY) {                 for (int TEST_CONF : TEST_CONF_ARRAY) {                     playOnceStreamData(TEST_NAME, TEST_MODE, TEST_STREAM_TYPE, TEST_SWEEP,                             TEST_IS_LOW_RAM_DEVICE, TEST_FORMAT, frequency, TEST_SR, TEST_CONF,                             WAIT_MSEC);                     frequency += 50; // increment test tone frequency                 }             }         }     }      private void playOnceStreamData(String testName, int testMode, int testStream,             float testSweep, boolean isLowRamDevice, int testFormat, double testFrequency,             int testSr, int testConf, long waitMsec) throws InterruptedException {         final int channelCount = Integer.bitCount(testConf);         if (isLowRamDevice                 && (testSr > 96000 || channelCount > 4)) {             return; // ignore. FIXME: reenable when AF memory allocation is updated.         }         // -------- initialization --------------         final int minBufferSize = AudioTrack.getMinBufferSize(testSr,                 testConf, testFormat); // in bytes         AudioTrack track = new AudioTrack(testStream, testSr,                 testConf, testFormat, minBufferSize, testMode);         assertTrue(testName, track.getState() == AudioTrack.STATE_INITIALIZED);          // compute parameters for the source signal data.         AudioFormat format = track.getFormat();         assertEquals(testName, testSr, format.getSampleRate());         assertEquals(testName, testConf, format.getChannelMask());         assertEquals(testName, channelCount, format.getChannelCount());         assertEquals(testName, testFormat, format.getEncoding());         final int sourceSamples = channelCount                 * AudioHelper.frameCountFromMsec(500,                 format); // duration of test tones         final double frequency = testFrequency / channelCount;          int written = 0;         // For streaming tracks, it's ok to issue the play() command         // before any audio is written.         track.play();         // -------- test --------------          // samplesPerWrite can be any positive value.         // We prefer this to be a multiple of channelCount so write()         // does not return a short count.         // If samplesPerWrite is very large, it is limited to the data length         // and we simply write (blocking) the entire source data and not even loop.         // We choose a value here which simulates double buffer writes.         final int buffers = 2; // double buffering mode         final int samplesPerWrite =                 (track.getBufferSizeInFrames() / buffers) * channelCount;         switch (testFormat) {             case AudioFormat.ENCODING_PCM_8BIT: {                 byte data[] = AudioHelper.createSoundDataInByteArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;             case AudioFormat.ENCODING_PCM_16BIT: {                 short data[] = AudioHelper.createSoundDataInShortArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;             case AudioFormat.ENCODING_PCM_FLOAT: {                 float data[] = AudioHelper.createSoundDataInFloatArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples,                             AudioTrack.WRITE_BLOCKING);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;         }          // For streaming tracks, AudioTrack.stop() doesn't immediately stop playback.         // Rather, it allows the remaining data in the internal buffer to drain.         track.stop();         Thread.sleep(waitMsec); // wait for the data to drain.         // -------- tear down --------------         track.release();         Thread.sleep(waitMsec); // wait for release to complete     }      ",6.1/C-0-11,,06010000.670011,C-0-11 6.1,Test[None]:[android.media.cts.AudioTrackTest:testPlayStreamData()],/home/gpoor/aosp_platform_source/cts/hostsidetests/adbmanager/src/android/adbmanager/cts/AdbManagerHostDeviceTest.java,6.1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/AudioTrackTest.java,,
,6.1,C-3-1,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",6.1/C-3-1,,06010000.670301,C-3-1 6.1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,6.1,C-3-2,,android.media.cts.AudioTrackTest,testPlayStreamData(),,"     public void testPlayStreamData() throws Exception {         // constants for test         final String TEST_NAME = ""testPlayStreamData"";         final int TEST_FORMAT_ARRAY[] = {  // should hear 40 increasing frequency tones, 3 times                 AudioFormat.ENCODING_PCM_8BIT,                 AudioFormat.ENCODING_PCM_16BIT,                 AudioFormat.ENCODING_PCM_FLOAT,         };         // due to downmixer algorithmic latency, source channels greater than 2 may         // sound shorter in duration at 4kHz sampling rate.         final int TEST_SR_ARRAY[] = {                 4000,                 44100,                 48000,                 96000,                 192000,         };         final int TEST_CONF_ARRAY[] = {                 AudioFormat.CHANNEL_OUT_MONO,    // 1.0                 AudioFormat.CHANNEL_OUT_STEREO,  // 2.0                 AudioFormat.CHANNEL_OUT_STEREO | AudioFormat.CHANNEL_OUT_FRONT_CENTER, // 3.0                 AudioFormat.CHANNEL_OUT_QUAD,    // 4.0                 AudioFormat.CHANNEL_OUT_QUAD | AudioFormat.CHANNEL_OUT_FRONT_CENTER,   // 5.0                 AudioFormat.CHANNEL_OUT_5POINT1, // 5.1                 AudioFormat.CHANNEL_OUT_5POINT1 | AudioFormat.CHANNEL_OUT_BACK_CENTER, // 6.1                 AudioFormat.CHANNEL_OUT_7POINT1_SURROUND, // 7.1         };         final int TEST_MODE = AudioTrack.MODE_STREAM;         final int TEST_STREAM_TYPE = AudioManager.STREAM_MUSIC;         final float TEST_SWEEP = 0; // sine wave only         final boolean TEST_IS_LOW_RAM_DEVICE = isLowRamDevice();          for (int TEST_FORMAT : TEST_FORMAT_ARRAY) {             double frequency = 400; // frequency changes for each test             for (int TEST_SR : TEST_SR_ARRAY) {                 for (int TEST_CONF : TEST_CONF_ARRAY) {                     playOnceStreamData(TEST_NAME, TEST_MODE, TEST_STREAM_TYPE, TEST_SWEEP,                             TEST_IS_LOW_RAM_DEVICE, TEST_FORMAT, frequency, TEST_SR, TEST_CONF,                             WAIT_MSEC);                     frequency += 50; // increment test tone frequency                 }             }         }     }      private void playOnceStreamData(String testName, int testMode, int testStream,             float testSweep, boolean isLowRamDevice, int testFormat, double testFrequency,             int testSr, int testConf, long waitMsec) throws InterruptedException {         final int channelCount = Integer.bitCount(testConf);         if (isLowRamDevice                 && (testSr > 96000 || channelCount > 4)) {             return; // ignore. FIXME: reenable when AF memory allocation is updated.         }         // -------- initialization --------------         final int minBufferSize = AudioTrack.getMinBufferSize(testSr,                 testConf, testFormat); // in bytes         AudioTrack track = new AudioTrack(testStream, testSr,                 testConf, testFormat, minBufferSize, testMode);         assertTrue(testName, track.getState() == AudioTrack.STATE_INITIALIZED);          // compute parameters for the source signal data.         AudioFormat format = track.getFormat();         assertEquals(testName, testSr, format.getSampleRate());         assertEquals(testName, testConf, format.getChannelMask());         assertEquals(testName, channelCount, format.getChannelCount());         assertEquals(testName, testFormat, format.getEncoding());         final int sourceSamples = channelCount                 * AudioHelper.frameCountFromMsec(500,                 format); // duration of test tones         final double frequency = testFrequency / channelCount;          int written = 0;         // For streaming tracks, it's ok to issue the play() command         // before any audio is written.         track.play();         // -------- test --------------          // samplesPerWrite can be any positive value.         // We prefer this to be a multiple of channelCount so write()         // does not return a short count.         // If samplesPerWrite is very large, it is limited to the data length         // and we simply write (blocking) the entire source data and not even loop.         // We choose a value here which simulates double buffer writes.         final int buffers = 2; // double buffering mode         final int samplesPerWrite =                 (track.getBufferSizeInFrames() / buffers) * channelCount;         switch (testFormat) {             case AudioFormat.ENCODING_PCM_8BIT: {                 byte data[] = AudioHelper.createSoundDataInByteArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;             case AudioFormat.ENCODING_PCM_16BIT: {                 short data[] = AudioHelper.createSoundDataInShortArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;             case AudioFormat.ENCODING_PCM_FLOAT: {                 float data[] = AudioHelper.createSoundDataInFloatArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples,                             AudioTrack.WRITE_BLOCKING);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;         }          // For streaming tracks, AudioTrack.stop() doesn't immediately stop playback.         // Rather, it allows the remaining data in the internal buffer to drain.         track.stop();         Thread.sleep(waitMsec); // wait for the data to drain.         // -------- tear down --------------         track.release();         Thread.sleep(waitMsec); // wait for release to complete     }      ",6.1/C-3-2,,06010000.670302,C-3-2 6.1,Test[None]:[android.media.cts.AudioTrackTest:testPlayStreamData()],,6.1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/AudioTrackTest.java,,
,6.1,C-4-1,,android.media.cts.AudioTrackTest,testPlayStreamData(),,"     public void testPlayStreamData() throws Exception {         // constants for test         final String TEST_NAME = ""testPlayStreamData"";         final int TEST_FORMAT_ARRAY[] = {  // should hear 40 increasing frequency tones, 3 times                 AudioFormat.ENCODING_PCM_8BIT,                 AudioFormat.ENCODING_PCM_16BIT,                 AudioFormat.ENCODING_PCM_FLOAT,         };         // due to downmixer algorithmic latency, source channels greater than 2 may         // sound shorter in duration at 4kHz sampling rate.         final int TEST_SR_ARRAY[] = {                 4000,                 44100,                 48000,                 96000,                 192000,         };         final int TEST_CONF_ARRAY[] = {                 AudioFormat.CHANNEL_OUT_MONO,    // 1.0                 AudioFormat.CHANNEL_OUT_STEREO,  // 2.0                 AudioFormat.CHANNEL_OUT_STEREO | AudioFormat.CHANNEL_OUT_FRONT_CENTER, // 3.0                 AudioFormat.CHANNEL_OUT_QUAD,    // 4.0                 AudioFormat.CHANNEL_OUT_QUAD | AudioFormat.CHANNEL_OUT_FRONT_CENTER,   // 5.0                 AudioFormat.CHANNEL_OUT_5POINT1, // 5.1                 AudioFormat.CHANNEL_OUT_5POINT1 | AudioFormat.CHANNEL_OUT_BACK_CENTER, // 6.1                 AudioFormat.CHANNEL_OUT_7POINT1_SURROUND, // 7.1         };         final int TEST_MODE = AudioTrack.MODE_STREAM;         final int TEST_STREAM_TYPE = AudioManager.STREAM_MUSIC;         final float TEST_SWEEP = 0; // sine wave only         final boolean TEST_IS_LOW_RAM_DEVICE = isLowRamDevice();          for (int TEST_FORMAT : TEST_FORMAT_ARRAY) {             double frequency = 400; // frequency changes for each test             for (int TEST_SR : TEST_SR_ARRAY) {                 for (int TEST_CONF : TEST_CONF_ARRAY) {                     playOnceStreamData(TEST_NAME, TEST_MODE, TEST_STREAM_TYPE, TEST_SWEEP,                             TEST_IS_LOW_RAM_DEVICE, TEST_FORMAT, frequency, TEST_SR, TEST_CONF,                             WAIT_MSEC);                     frequency += 50; // increment test tone frequency                 }             }         }     }      private void playOnceStreamData(String testName, int testMode, int testStream,             float testSweep, boolean isLowRamDevice, int testFormat, double testFrequency,             int testSr, int testConf, long waitMsec) throws InterruptedException {         final int channelCount = Integer.bitCount(testConf);         if (isLowRamDevice                 && (testSr > 96000 || channelCount > 4)) {             return; // ignore. FIXME: reenable when AF memory allocation is updated.         }         // -------- initialization --------------         final int minBufferSize = AudioTrack.getMinBufferSize(testSr,                 testConf, testFormat); // in bytes         AudioTrack track = new AudioTrack(testStream, testSr,                 testConf, testFormat, minBufferSize, testMode);         assertTrue(testName, track.getState() == AudioTrack.STATE_INITIALIZED);          // compute parameters for the source signal data.         AudioFormat format = track.getFormat();         assertEquals(testName, testSr, format.getSampleRate());         assertEquals(testName, testConf, format.getChannelMask());         assertEquals(testName, channelCount, format.getChannelCount());         assertEquals(testName, testFormat, format.getEncoding());         final int sourceSamples = channelCount                 * AudioHelper.frameCountFromMsec(500,                 format); // duration of test tones         final double frequency = testFrequency / channelCount;          int written = 0;         // For streaming tracks, it's ok to issue the play() command         // before any audio is written.         track.play();         // -------- test --------------          // samplesPerWrite can be any positive value.         // We prefer this to be a multiple of channelCount so write()         // does not return a short count.         // If samplesPerWrite is very large, it is limited to the data length         // and we simply write (blocking) the entire source data and not even loop.         // We choose a value here which simulates double buffer writes.         final int buffers = 2; // double buffering mode         final int samplesPerWrite =                 (track.getBufferSizeInFrames() / buffers) * channelCount;         switch (testFormat) {             case AudioFormat.ENCODING_PCM_8BIT: {                 byte data[] = AudioHelper.createSoundDataInByteArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;             case AudioFormat.ENCODING_PCM_16BIT: {                 short data[] = AudioHelper.createSoundDataInShortArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;             case AudioFormat.ENCODING_PCM_FLOAT: {                 float data[] = AudioHelper.createSoundDataInFloatArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples,                             AudioTrack.WRITE_BLOCKING);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;         }          // For streaming tracks, AudioTrack.stop() doesn't immediately stop playback.         // Rather, it allows the remaining data in the internal buffer to drain.         track.stop();         Thread.sleep(waitMsec); // wait for the data to drain.         // -------- tear down --------------         track.release();         Thread.sleep(waitMsec); // wait for release to complete     }      ",6.1/C-4-1,,06010000.670401,isAdbWifiSupported() C-4-1 6.1,Test[None]:[android.media.cts.AudioTrackTest:testPlayStreamData()],,6.1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/AudioTrackTest.java,,
,6.1,C-5-1,,android.media.cts.AudioTrackTest,testPlayStreamData(),,"     public void testPlayStreamData() throws Exception {         // constants for test         final String TEST_NAME = ""testPlayStreamData"";         final int TEST_FORMAT_ARRAY[] = {  // should hear 40 increasing frequency tones, 3 times                 AudioFormat.ENCODING_PCM_8BIT,                 AudioFormat.ENCODING_PCM_16BIT,                 AudioFormat.ENCODING_PCM_FLOAT,         };         // due to downmixer algorithmic latency, source channels greater than 2 may         // sound shorter in duration at 4kHz sampling rate.         final int TEST_SR_ARRAY[] = {                 4000,                 44100,                 48000,                 96000,                 192000,         };         final int TEST_CONF_ARRAY[] = {                 AudioFormat.CHANNEL_OUT_MONO,    // 1.0                 AudioFormat.CHANNEL_OUT_STEREO,  // 2.0                 AudioFormat.CHANNEL_OUT_STEREO | AudioFormat.CHANNEL_OUT_FRONT_CENTER, // 3.0                 AudioFormat.CHANNEL_OUT_QUAD,    // 4.0                 AudioFormat.CHANNEL_OUT_QUAD | AudioFormat.CHANNEL_OUT_FRONT_CENTER,   // 5.0                 AudioFormat.CHANNEL_OUT_5POINT1, // 5.1                 AudioFormat.CHANNEL_OUT_5POINT1 | AudioFormat.CHANNEL_OUT_BACK_CENTER, // 6.1                 AudioFormat.CHANNEL_OUT_7POINT1_SURROUND, // 7.1         };         final int TEST_MODE = AudioTrack.MODE_STREAM;         final int TEST_STREAM_TYPE = AudioManager.STREAM_MUSIC;         final float TEST_SWEEP = 0; // sine wave only         final boolean TEST_IS_LOW_RAM_DEVICE = isLowRamDevice();          for (int TEST_FORMAT : TEST_FORMAT_ARRAY) {             double frequency = 400; // frequency changes for each test             for (int TEST_SR : TEST_SR_ARRAY) {                 for (int TEST_CONF : TEST_CONF_ARRAY) {                     playOnceStreamData(TEST_NAME, TEST_MODE, TEST_STREAM_TYPE, TEST_SWEEP,                             TEST_IS_LOW_RAM_DEVICE, TEST_FORMAT, frequency, TEST_SR, TEST_CONF,                             WAIT_MSEC);                     frequency += 50; // increment test tone frequency                 }             }         }     }      private void playOnceStreamData(String testName, int testMode, int testStream,             float testSweep, boolean isLowRamDevice, int testFormat, double testFrequency,             int testSr, int testConf, long waitMsec) throws InterruptedException {         final int channelCount = Integer.bitCount(testConf);         if (isLowRamDevice                 && (testSr > 96000 || channelCount > 4)) {             return; // ignore. FIXME: reenable when AF memory allocation is updated.         }         // -------- initialization --------------         final int minBufferSize = AudioTrack.getMinBufferSize(testSr,                 testConf, testFormat); // in bytes         AudioTrack track = new AudioTrack(testStream, testSr,                 testConf, testFormat, minBufferSize, testMode);         assertTrue(testName, track.getState() == AudioTrack.STATE_INITIALIZED);          // compute parameters for the source signal data.         AudioFormat format = track.getFormat();         assertEquals(testName, testSr, format.getSampleRate());         assertEquals(testName, testConf, format.getChannelMask());         assertEquals(testName, channelCount, format.getChannelCount());         assertEquals(testName, testFormat, format.getEncoding());         final int sourceSamples = channelCount                 * AudioHelper.frameCountFromMsec(500,                 format); // duration of test tones         final double frequency = testFrequency / channelCount;          int written = 0;         // For streaming tracks, it's ok to issue the play() command         // before any audio is written.         track.play();         // -------- test --------------          // samplesPerWrite can be any positive value.         // We prefer this to be a multiple of channelCount so write()         // does not return a short count.         // If samplesPerWrite is very large, it is limited to the data length         // and we simply write (blocking) the entire source data and not even loop.         // We choose a value here which simulates double buffer writes.         final int buffers = 2; // double buffering mode         final int samplesPerWrite =                 (track.getBufferSizeInFrames() / buffers) * channelCount;         switch (testFormat) {             case AudioFormat.ENCODING_PCM_8BIT: {                 byte data[] = AudioHelper.createSoundDataInByteArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;             case AudioFormat.ENCODING_PCM_16BIT: {                 short data[] = AudioHelper.createSoundDataInShortArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;             case AudioFormat.ENCODING_PCM_FLOAT: {                 float data[] = AudioHelper.createSoundDataInFloatArray(                         sourceSamples, testSr,                         frequency, testSweep);                 while (written < data.length) {                     int samples = Math.min(data.length - written, samplesPerWrite);                     int ret = track.write(data, written, samples,                             AudioTrack.WRITE_BLOCKING);                     assertEquals(testName, samples, ret);                     written += ret;                 }             }             break;         }          // For streaming tracks, AudioTrack.stop() doesn't immediately stop playback.         // Rather, it allows the remaining data in the internal buffer to drain.         track.stop();         Thread.sleep(waitMsec); // wait for the data to drain.         // -------- tear down --------------         track.release();         Thread.sleep(waitMsec); // wait for release to complete     }      ",6.1/C-5-1,,06010000.670501,C-5-1 6.1 isAdbWifiQrSupported(),Test[None]:[android.media.cts.AudioTrackTest:testPlayStreamData()],,6.1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/AudioTrackTest.java,,
,7.1.1.1,C-2-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",7.1.1.1/C-2-1,,07010101.670201,display(s) 7.1.1.1 cs.android.com C-2-1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-2-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.1.1.1,C-3-1,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.1.1.1/C-3-1,,07010101.670301,7.1.1.1 C-3-1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.1.4.2,C-1-10,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.1.4.2/C-1-10,,07010402.670110,C-1-10 android.software.vulkan.deqp.level EQP 7.1.4.2,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,7.1.4.2,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.2.3,C-3-1,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.2.3/C-3-1,,07020300.670301,C-3-1 KeyEvent.html 7.2.3 KEYCODE_ASSIST,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.2.4,C-3-2,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.4/C-3-2,,07020400.670302,C-3-2 android.hardware.faketouch 7.2.4,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,android.hardware.faketouch,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.2.4,C-3-3,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.4/C-3-3,,07020400.670303,Configuration.touchscreen TOUCHSCREEN_NOTOUCH C-3-3 7.2.4 Configuration.html,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,TOUCHSCREEN_NOTOUCH,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.2.6.1,C-2-1,,android.view.cts.KeyEventTest,testKeyCodeFromString(),,"     public void testKeyCodeFromString() {         assertEquals(KeyEvent.KEYCODE_A, KeyEvent.keyCodeFromString(""KEYCODE_A""));         assertEquals(KeyEvent.KEYCODE_A, KeyEvent.keyCodeFromString(""A""));         assertEquals(KeyEvent.KEYCODE_A,                 KeyEvent.keyCodeFromString(Integer.toString(KeyEvent.KEYCODE_A)));         assertEquals(KeyEvent.KEYCODE_UNKNOWN, KeyEvent.keyCodeFromString(""keycode_a""));         assertEquals(KeyEvent.KEYCODE_UNKNOWN, KeyEvent.keyCodeFromString(""a""));         assertEquals(0, KeyEvent.keyCodeFromString(""0""));         assertEquals(1, KeyEvent.keyCodeFromString(""1""));         assertEquals(KeyEvent.KEYCODE_HOME, KeyEvent.keyCodeFromString(""3""));         assertEquals(KeyEvent.KEYCODE_POWER,                 KeyEvent.keyCodeFromString(Integer.toString(KeyEvent.KEYCODE_POWER)));         assertEquals(KeyEvent.KEYCODE_MENU,                 KeyEvent.keyCodeFromString(Integer.toString(KeyEvent.KEYCODE_MENU)));         assertEquals(KeyEvent.KEYCODE_BACK, KeyEvent.keyCodeFromString(""BACK""));         assertEquals(KeyEvent.KEYCODE_UNKNOWN, KeyEvent.keyCodeFromString(""back""));          assertEquals(KeyEvent.KEYCODE_UNKNOWN,                 KeyEvent.keyCodeFromString(""KEYCODE_NOT_A_REAL_KEYCODE""));         assertEquals(KeyEvent.KEYCODE_UNKNOWN, KeyEvent.keyCodeFromString(""NOT_A_REAL_KEYCODE""));         assertEquals(KeyEvent.KEYCODE_UNKNOWN, KeyEvent.keyCodeFromString(""-1""));         assertEquals(KeyEvent.KEYCODE_UNKNOWN, KeyEvent.keyCodeFromString(""1001""));         assertEquals(KeyEvent.KEYCODE_UNKNOWN, KeyEvent.keyCodeFromString(""KEYCODE_123""));         assertEquals(KeyEvent.KEYCODE_UNKNOWN, KeyEvent.keyCodeFromString(""KEYCODE""));         assertEquals(KeyEvent.KEYCODE_UNKNOWN, KeyEvent.keyCodeFromString(""KEYCODE_""));         assertEquals(KeyEvent.KEYCODE_UNKNOWN, KeyEvent.keyCodeFromString(""""));         assertEquals(KeyEvent.LAST_KEYCODE,                 KeyEvent.keyCodeFromString(Integer.toString(KeyEvent.LAST_KEYCODE)));         assertEquals(KeyEvent.KEYCODE_UNKNOWN,                 KeyEvent.keyCodeFromString(Integer.toString(KeyEvent.LAST_KEYCODE + 1)));     }      // Parcel a KeyEvent, then create a new KeyEvent from this parcel. Return the new KeyEvent     private KeyEvent parcelUnparcel(KeyEvent keyEvent) {         Parcel parcel = Parcel.obtain();         keyEvent.writeToParcel(parcel, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);         parcel.setDataPosition(0);          KeyEvent keyEventFromParcel = KeyEvent.CREATOR.createFromParcel(parcel);         parcel.recycle();         return keyEventFromParcel;     } } ",7.2.6.1/C-2-1,,07020601.670201,KEYCODE_BUTTON_THUMBL KEYCODE_BUTTON_B KEYCODE_BUTTON_R1 KEYCODE_BUTTON_X AXIS_X AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBR android.hardware.gamepad KEYCODE_HOME AXIS_LTRIGGER AXIS_Y C-2-1 AXIS_RZ KEYCODE_BUTTON_A KEYCODE_BUTTON_L1 HID 7.2.6.1 MotionEvent.html AXIS_Z KEYCODE_BUTTON_Y AXIS_HAT_X4 KEYCODE_BACK AXIS_RTRIGGER,Test[None]:[android.view.cts.KeyEventTest:testKeyCodeFromString()],,KEYCODE_BACK,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyEventTest.java,,
,7.3,C-1-6,,android.location.cts.coarse.LocationManagerCoarseTest,testGnssProvidedClock(),,"     public void testGnssProvidedClock() throws Exception {         mManager.addTestProvider(GPS_PROVIDER,                 false,                 true,                 false,                 false,                 true,                 true,                 true,                 Criteria.POWER_MEDIUM,                 Criteria.ACCURACY_COARSE);         mManager.setTestProviderEnabled(GPS_PROVIDER, true);          Location location = new Location(GPS_PROVIDER);         long elapsed = SystemClock.elapsedRealtimeNanos();         location.setLatitude(0);         location.setLongitude(0);         location.setAccuracy(0);         location.setElapsedRealtimeNanos(elapsed);         location.setTime(1);          mManager.setTestProviderLocation(GPS_PROVIDER, location);         Thread.sleep(200);         assertTrue(SystemClock.currentGnssTimeClock().millis() < 1000);          location.setTime(java.lang.System.currentTimeMillis());         location.setElapsedRealtimeNanos(SystemClock.elapsedRealtimeNanos());         mManager.setTestProviderLocation(GPS_PROVIDER, location);         Thread.sleep(200);         long clockms = SystemClock.currentGnssTimeClock().millis();         assertTrue(System.currentTimeMillis() - clockms < 1000);     }      private static Executor directExecutor() {         return Runnable::run;     }      private boolean hasGpsFeature() {         return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION_GPS);     } } ",7.3/C-1-6,,07030000.670106,7.3 Sensor.getResolution getResolution() SystemClock.elapsedRealtimeNano elapsedRealtimeNano() C-1-6 SensorEvent.html,Test[None]:[android.location.cts.coarse.LocationManagerCoarseTest:testGnssProvidedClock()],,SystemClock.elapsedRealtimeNano,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/location/location_coarse/src/android/location/cts/coarse/LocationManagerCoarseTest.java,,
,7.3,C-1-7,,android.location.cts.fine.GnssAntennaInfoTest,,,"/*  *.  */  package android.location.cts.fine;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull;  import android.location.GnssAntennaInfo; import android.location.GnssAntennaInfo.PhaseCenterOffset; import android.location.GnssAntennaInfo.SphericalCorrections; import android.os.Parcel;  import androidx.test.ext.junit.runners.AndroidJUnit4;  import org.junit.Test; import org.junit.runner.RunWith;  /**  * Tests fundamental functionality of GnssAntennaInfo class. This includes writing and reading from  * parcel, and verifying computed values and getters.  */ @RunWith(AndroidJUnit4.class) public class GnssAntennaInfoTest {      private static final double PRECISION = 0.0001;     private static final double[][] PHASE_CENTER_VARIATION_CORRECTIONS = new double[][]{         {5.29, 0.20, 7.15, 10.18, 9.47, 8.05},         {11.93, 3.98, 2.68, 2.66, 8.15, 13.54},         {14.69, 7.63, 13.46, 8.70, 4.36, 1.21},         {4.19, 12.43, 12.40, 0.90, 1.96, 1.99},         {7.30, 0.49, 7.43, 8.71, 3.70, 7.24},         {4.79, 1.88, 13.88, 3.52, 13.40, 11.81}     };     private static final double[][] PHASE_CENTER_VARIATION_CORRECTION_UNCERTAINTIES = new double[][]{             {1.77, 0.81, 0.72, 1.65, 2.35, 1.22},             {0.77, 3.43, 2.77, 0.97, 4.55, 1.38},             {1.51, 2.50, 2.23, 2.43, 1.94, 0.90},             {0.34, 4.72, 4.14, 4.78, 4.57, 1.69},             {4.49, 0.05, 2.78, 1.33, 3.20, 2.75},             {1.09, 0.31, 3.79, 4.32, 0.65, 1.23}     };     private static final double[][] SIGNAL_GAIN_CORRECTIONS = new double[][]{             {0.19, 7.04, 1.65, 14.84, 2.95, 9.21},             {0.45, 6.27, 14.57, 8.95, 3.92, 12.68},             {6.80, 13.04, 7.92, 2.23, 14.22, 7.36},             {4.81, 11.78, 5.04, 5.13, 12.09, 12.85},             {0.88, 4.04, 5.71, 3.72, 12.62, 0.40},             {14.26, 9.50, 4.21, 11.14, 6.54, 14.63}     };     private static final double[][] SIGNAL_GAIN_CORRECTION_UNCERTAINTIES = new double[][]{             {4.74, 1.54, 1.59, 4.05, 1.65, 2.46},             {0.10, 0.33, 0.84, 0.83, 0.57, 2.66},             {2.08, 1.46, 2.10, 3.25, 1.48, 0.65},             {4.02, 2.90, 2.51, 2.13, 1.67, 1.23},             {2.13, 4.30, 1.36, 3.86, 1.02, 2.96},             {3.22, 3.95, 3.75, 1.73, 1.91, 4.93}      };      ",7.3/C-1-7,,07030000.670107,7.3 C-1-7,Test[None]:[android.location.cts.fine.GnssAntennaInfoTest:],,7.3,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/location/location_fine/src/android/location/cts/fine/GnssAntennaInfoTest.java,,
,7.3.6,C-2-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",7.3.6/C-2-1,,07030600.670201,C-2-1 TYPE_AMBIENT_TEMPERATURE 7.3.6 SENSOR_TYPE_AMBIENT_TEMPERATURE,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-2-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.3.10,C-6-2,,android.security.identity.cts.IdentityApiTest,,,"/*  *.  */  package android.security.identity.cts;  import android.content.Context; import android.hardware.biometrics.BiometricPrompt.CryptoObject; import android.security.identity.AccessControlProfileId; import android.security.identity.AlreadyPersonalizedException; import android.security.identity.CipherSuiteNotSupportedException; import android.security.identity.DocTypeNotSupportedException; import android.security.identity.EphemeralPublicKeyNotFoundException; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.InvalidReaderSignatureException; import android.security.identity.InvalidRequestMessageException; import android.security.identity.MessageDecryptionException; import android.security.identity.NoAuthenticationKeyAvailableException; import android.security.identity.SessionTranscriptMismatchException; import android.security.identity.UnknownAuthenticationKeyException;  import androidx.test.InstrumentationRegistry;  import org.junit.Test; import static org.junit.Assert.assertEquals;  public class IdentityApiTest {     private static final String TAG = ""IdentityApiTest"";      ",7.3.10/C-6-2,,07031000.670602,BIOMETRIC_STRONG 7.3.10 BiometricPrompt.CryptoObject C-6-2 BiometricManager.Authenticators,Test[None]:[android.security.identity.cts.IdentityApiTest:],,BiometricPrompt.CryptoObject,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/IdentityApiTest.java,,
,7.3.10,C-3-4,,android.provider.cts.media.MediaStore_Video_ThumbnailsTest,testThumbnailGenerationAndCleanup(),,"     public void testThumbnailGenerationAndCleanup() throws Exception {         if (!MediaStore.VOLUME_EXTERNAL.equals(mVolumeName)) return;          if (!hasCodec()) {             // we don't support video, so no need to run the test             Log.i(TAG, ""SKIPPING testThumbnailGenerationAndCleanup(): codec not supported"");             return;         }          // insert a video         Uri uri = insertVideo();          // request thumbnail creation         ProviderTestUtils.waitForIdle();         assertNotNull(Thumbnails.getThumbnail(mResolver, Long.valueOf(uri.getLastPathSegment()),                 Thumbnails.MINI_KIND, null /* options */));          // delete the source video and check that the thumbnail is gone too         mResolver.delete(uri, null /* where clause */, null /* where args */);         ProviderTestUtils.waitForIdle();         assertNull(Thumbnails.getThumbnail(mResolver, Long.valueOf(uri.getLastPathSegment()),                 Thumbnails.MINI_KIND, null /* options */));          // insert again         uri = insertVideo();          // request thumbnail creation         ProviderTestUtils.waitForIdle();         assertNotNull(Thumbnails.getThumbnail(mResolver, Long.valueOf(uri.getLastPathSegment()),                 Thumbnails.MINI_KIND, null));          // update the media type         ContentValues values = new ContentValues();         values.put(""media_type"", 0);         assertEquals(""unexpected number of updated rows"",                 1, mResolver.update(uri, values, null /* where */, null /* where args */));          // video was marked as regular file in the database, which should have deleted its thumbnail         ProviderTestUtils.waitForIdle();         assertNull(Thumbnails.getThumbnail(mResolver, Long.valueOf(uri.getLastPathSegment()),                 Thumbnails.MINI_KIND, null /* options */));          // check source no longer exists as video         Cursor c = mResolver.query(uri,                 null /* projection */, null /* where */, null /* where args */, null /* sort */);         assertFalse(""source entry should be gone"", c.moveToNext());         c.close();          // check source still exists as file         Uri fileUri = ContentUris.withAppendedId(                 Files.getContentUri(""external""),                 Long.valueOf(uri.getLastPathSegment()));         c = mResolver.query(fileUri,                 null /* projection */, null /* where */, null /* where args */, null /* sort */);         assertTrue(""source entry should be gone"", c.moveToNext());         String sourcePath = c.getString(c.getColumnIndex(""_data""));         c.close();          // clean up         mResolver.delete(fileUri, null /* where */, null /* where args */);         new File(sourcePath).delete();     }      private Uri insertVideo() throws IOException {         File file = new File(ProviderTestUtils.stageDir(MediaStore.VOLUME_EXTERNAL),                 ""testVideo"" + System.nanoTime() + "".3gp"");         // clean up any potential left over entries from a previous aborted run         mResolver.delete(Media.EXTERNAL_CONTENT_URI,                 ""_data=?"", new String[] { file.getAbsolutePath() });         file.delete();          ProviderTestUtils.stageFile(R.raw.testthumbvideo, file);          ContentValues values = new ContentValues();         values.put(VideoColumns.DATA, file.getAbsolutePath());         return mResolver.insert(Media.EXTERNAL_CONTENT_URI, values);     }      ",7.3.10/C-3-4,,07031000.670304,PIN C-3-4 7.3.10,Test[None]:[android.provider.cts.media.MediaStore_Video_ThumbnailsTest:testThumbnailGenerationAndCleanup()],,PIN,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Video_ThumbnailsTest.java,,
,7.3.13,C-1-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",7.3.13/C-1-1,,07031300.670101,STRING_TYPE_HINGE_ANGLE 7.3.13 C-1-1 TYPE_HINGLE_ANGLE,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-1-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.3.13,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.3.13/C-1-2,,07031300.670102,C-1-2 7.3.13,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.4.5.3,C-1-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",7.4.5.3/C-1-1,,07040503.670101,C-1-1 7.4.5.3 ACTION_CAPTIVE_PORTAL_SIGN_IN,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-1-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.4.5.3,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.4.5.3/C-1-2,,07040503.670102,7.4.5.3 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.4.5.3,C-1-3,,android.net.cts.IpSecManagerTest,testAllocSpi(),,"     public void testAllocSpi() throws Exception {         for (InetAddress addr : GOOGLE_DNS_LIST) {             IpSecManager.SecurityParameterIndex randomSpi = null, droidSpi = null;             randomSpi = mISM.allocateSecurityParameterIndex(addr);             assertTrue(                     ""Failed to receive a valid SPI"",                     randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX);              droidSpi = mISM.allocateSecurityParameterIndex(addr, DROID_SPI);             assertTrue(""Failed to allocate specified SPI, "" + DROID_SPI,                     droidSpi.getSpi() == DROID_SPI);              try {                 mISM.allocateSecurityParameterIndex(addr, DROID_SPI);                 fail(""Duplicate SPI was allowed to be created"");             } catch (IpSecManager.SpiUnavailableException expected) {                 // This is a success case because we expect a dupe SPI to throw             }              randomSpi.close();             droidSpi.close();         }     }      /** This function finds an available port */     private static int findUnusedPort() throws Exception {         // Get an available port.         DatagramSocket s = new DatagramSocket();         int port = s.getLocalPort();         s.close();         return port;     }      private static FileDescriptor getBoundUdpSocket(InetAddress address) throws Exception {         FileDescriptor sock =                 Os.socket(getDomain(address), OsConstants.SOCK_DGRAM, OsConstants.IPPROTO_UDP);          for (int i = 0; i < MAX_PORT_BIND_ATTEMPTS; i++) {             try {                 int port = findUnusedPort();                 Os.bind(sock, address, port);                 break;             } catch (ErrnoException e) {                 // Someone claimed the port since we called findUnusedPort.                 if (e.errno == OsConstants.EADDRINUSE) {                     if (i == MAX_PORT_BIND_ATTEMPTS - 1) {                          fail(""Failed "" + MAX_PORT_BIND_ATTEMPTS + "" attempts to bind to a port"");                     }                     continue;                 }                 throw e.rethrowAsIOException();             }         }         return sock;     }      private void checkUnconnectedUdp(IpSecTransform transform, InetAddress local, int sendCount,                                      boolean useJavaSockets) throws Exception {         GenericUdpSocket sockLeft = null, sockRight = null;         if (useJavaSockets) {             SocketPair<JavaUdpSocket> sockets = getJavaUdpSocketPair(local, mISM, transform, false);             sockLeft = sockets.mLeftSock;             sockRight = sockets.mRightSock;         } else {             SocketPair<NativeUdpSocket> sockets =                     getNativeUdpSocketPair(local, mISM, transform, false);             sockLeft = sockets.mLeftSock;             sockRight = sockets.mRightSock;         }          for (int i = 0; i < sendCount; i++) {             byte[] in;              sockLeft.sendTo(TEST_DATA, local, sockRight.getPort());             in = sockRight.receive();             assertArrayEquals(""Left-to-right encrypted data did not match."", TEST_DATA, in);              sockRight.sendTo(TEST_DATA, local, sockLeft.getPort());             in = sockLeft.receive();             assertArrayEquals(""Right-to-left encrypted data did not match."", TEST_DATA, in);         }          sockLeft.close();         sockRight.close();     }      private void checkTcp(IpSecTransform transform, InetAddress local, int sendCount,                           boolean useJavaSockets) throws Exception {         GenericTcpSocket client = null, accepted = null;         if (useJavaSockets) {             SocketPair<JavaTcpSocket> sockets = getJavaTcpSocketPair(local, mISM, transform);             client = sockets.mLeftSock;             accepted = sockets.mRightSock;         } else {             SocketPair<NativeTcpSocket> sockets = getNativeTcpSocketPair(local, mISM, transform);             client = sockets.mLeftSock;             accepted = sockets.mRightSock;         }          // Wait for TCP handshake packets to be counted         StatsChecker.waitForNumPackets(3); // (SYN, SYN+ACK, ACK)          // Reset StatsChecker, to ignore negotiation overhead.         StatsChecker.initStatsChecker();         for (int i = 0; i < sendCount; i++) {             byte[] in;              client.send(TEST_DATA);             in = accepted.receive();             assertArrayEquals(""Client-to-server encrypted data did not match."", TEST_DATA, in);              // Allow for newest data + ack packets to be returned before sending next packet             // Also add the number of expected packets in each of the previous runs (4 per run)             StatsChecker.waitForNumPackets(2 + (4 * i));              accepted.send(TEST_DATA);             in = client.receive();             assertArrayEquals(""Server-to-client encrypted data did not match."", TEST_DATA, in);              // Allow for all data + ack packets to be returned before sending next packet             // Also add the number of expected packets in each of the previous runs (4 per run)             StatsChecker.waitForNumPackets(4 * (i + 1));         }          // Transforms should not be removed from the sockets, otherwise FIN packets will be sent         //     unencrypted.         // This test also unfortunately happens to rely on a nuance of the cleanup order. By         //     keeping the policy on the socket, but removing the SA before lingering FIN packets         //     are sent (at an undetermined later time), the FIN packets are dropped. Without this,         //     we run into all kinds of headaches trying to test data accounting (unsolicited         //     packets mysteriously appearing and messing up our counters)         // The right way to close sockets is to set SO_LINGER to ensure synchronous closure,         //     closing the sockets, and then closing the transforms. See documentation for the         //     Socket or FileDescriptor flavors of applyTransportModeTransform() in IpSecManager         //     for more details.          client.close();         accepted.close();     }      /*      * Alloc outbound SPI      * Alloc inbound SPI      * Create transport mode transform      * open socket      * apply transform to socket      * send data on socket      * release transform      * send data (expect exception)      */     ",7.4.5.3/C-1-3,,07040503.670103,7.4.5.3 DNS C-1-3,Test[None]:[android.net.cts.IpSecManagerTest:testAllocSpi()],,DNS,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java,,
,7.4.5.3,C-1-4,,android.net.cts.IpSecManagerTest,testAllocSpi(),,"     public void testAllocSpi() throws Exception {         for (InetAddress addr : GOOGLE_DNS_LIST) {             IpSecManager.SecurityParameterIndex randomSpi = null, droidSpi = null;             randomSpi = mISM.allocateSecurityParameterIndex(addr);             assertTrue(                     ""Failed to receive a valid SPI"",                     randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX);              droidSpi = mISM.allocateSecurityParameterIndex(addr, DROID_SPI);             assertTrue(""Failed to allocate specified SPI, "" + DROID_SPI,                     droidSpi.getSpi() == DROID_SPI);              try {                 mISM.allocateSecurityParameterIndex(addr, DROID_SPI);                 fail(""Duplicate SPI was allowed to be created"");             } catch (IpSecManager.SpiUnavailableException expected) {                 // This is a success case because we expect a dupe SPI to throw             }              randomSpi.close();             droidSpi.close();         }     }      /** This function finds an available port */     private static int findUnusedPort() throws Exception {         // Get an available port.         DatagramSocket s = new DatagramSocket();         int port = s.getLocalPort();         s.close();         return port;     }      private static FileDescriptor getBoundUdpSocket(InetAddress address) throws Exception {         FileDescriptor sock =                 Os.socket(getDomain(address), OsConstants.SOCK_DGRAM, OsConstants.IPPROTO_UDP);          for (int i = 0; i < MAX_PORT_BIND_ATTEMPTS; i++) {             try {                 int port = findUnusedPort();                 Os.bind(sock, address, port);                 break;             } catch (ErrnoException e) {                 // Someone claimed the port since we called findUnusedPort.                 if (e.errno == OsConstants.EADDRINUSE) {                     if (i == MAX_PORT_BIND_ATTEMPTS - 1) {                          fail(""Failed "" + MAX_PORT_BIND_ATTEMPTS + "" attempts to bind to a port"");                     }                     continue;                 }                 throw e.rethrowAsIOException();             }         }         return sock;     }      private void checkUnconnectedUdp(IpSecTransform transform, InetAddress local, int sendCount,                                      boolean useJavaSockets) throws Exception {         GenericUdpSocket sockLeft = null, sockRight = null;         if (useJavaSockets) {             SocketPair<JavaUdpSocket> sockets = getJavaUdpSocketPair(local, mISM, transform, false);             sockLeft = sockets.mLeftSock;             sockRight = sockets.mRightSock;         } else {             SocketPair<NativeUdpSocket> sockets =                     getNativeUdpSocketPair(local, mISM, transform, false);             sockLeft = sockets.mLeftSock;             sockRight = sockets.mRightSock;         }          for (int i = 0; i < sendCount; i++) {             byte[] in;              sockLeft.sendTo(TEST_DATA, local, sockRight.getPort());             in = sockRight.receive();             assertArrayEquals(""Left-to-right encrypted data did not match."", TEST_DATA, in);              sockRight.sendTo(TEST_DATA, local, sockLeft.getPort());             in = sockLeft.receive();             assertArrayEquals(""Right-to-left encrypted data did not match."", TEST_DATA, in);         }          sockLeft.close();         sockRight.close();     }      private void checkTcp(IpSecTransform transform, InetAddress local, int sendCount,                           boolean useJavaSockets) throws Exception {         GenericTcpSocket client = null, accepted = null;         if (useJavaSockets) {             SocketPair<JavaTcpSocket> sockets = getJavaTcpSocketPair(local, mISM, transform);             client = sockets.mLeftSock;             accepted = sockets.mRightSock;         } else {             SocketPair<NativeTcpSocket> sockets = getNativeTcpSocketPair(local, mISM, transform);             client = sockets.mLeftSock;             accepted = sockets.mRightSock;         }          // Wait for TCP handshake packets to be counted         StatsChecker.waitForNumPackets(3); // (SYN, SYN+ACK, ACK)          // Reset StatsChecker, to ignore negotiation overhead.         StatsChecker.initStatsChecker();         for (int i = 0; i < sendCount; i++) {             byte[] in;              client.send(TEST_DATA);             in = accepted.receive();             assertArrayEquals(""Client-to-server encrypted data did not match."", TEST_DATA, in);              // Allow for newest data + ack packets to be returned before sending next packet             // Also add the number of expected packets in each of the previous runs (4 per run)             StatsChecker.waitForNumPackets(2 + (4 * i));              accepted.send(TEST_DATA);             in = client.receive();             assertArrayEquals(""Server-to-client encrypted data did not match."", TEST_DATA, in);              // Allow for all data + ack packets to be returned before sending next packet             // Also add the number of expected packets in each of the previous runs (4 per run)             StatsChecker.waitForNumPackets(4 * (i + 1));         }          // Transforms should not be removed from the sockets, otherwise FIN packets will be sent         //     unencrypted.         // This test also unfortunately happens to rely on a nuance of the cleanup order. By         //     keeping the policy on the socket, but removing the SA before lingering FIN packets         //     are sent (at an undetermined later time), the FIN packets are dropped. Without this,         //     we run into all kinds of headaches trying to test data accounting (unsolicited         //     packets mysteriously appearing and messing up our counters)         // The right way to close sockets is to set SO_LINGER to ensure synchronous closure,         //     closing the sockets, and then closing the transforms. See documentation for the         //     Socket or FileDescriptor flavors of applyTransportModeTransform() in IpSecManager         //     for more details.          client.close();         accepted.close();     }      /*      * Alloc outbound SPI      * Alloc inbound SPI      * Create transport mode transform      * open socket      * apply transform to socket      * send data on socket      * release transform      * send data (expect exception)      */     ",7.4.5.3/C-1-4,,07040503.670104,7.4.5.3 LinkProperties.html C-1-4 android.net.LinkProperties.getPrivateDnsServerName DNS android.net.LinkProperties.isPrivateDnsActive,Test[None]:[android.net.cts.IpSecManagerTest:testAllocSpi()],,DNS,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java,,
,7.4.5.3,C-1-5,,android.car.cts.CarTest,testConnection(),,"     public void testConnection() throws Exception {         mServiceConnectionListener = new DefaultServiceConnectionListener();         mCar = Car.createCar(mContext, mServiceConnectionListener);         assertThat(mCar.isConnected()).isFalse();         assertThat(mCar.isConnecting()).isFalse();         mCar.connect();         mServiceConnectionListener.waitForConnection(DEFAULT_WAIT_TIMEOUT_MS);         assertThat(mServiceConnectionListener.isConnected()).isTrue();         assertThat(mCar.getCarConnectionType()).isEqualTo(Car.CONNECTION_TYPE_EMBEDDED);         mCar.disconnect();         assertThat(mCar.isConnected()).isFalse();         assertThat(mCar.isConnecting()).isFalse();     }      ",7.4.5.3/C-1-5,,07040503.670105,android.net.ConnectivityManager.NetworkCallback java.net.Socket ConnectivityManager.registerDefaultNetworkCallback 7.4.5.3 C-1-5 ConnectivityManager.getActiveNetwork connect(),Test[None]:[android.car.cts.CarTest:testConnection()],,connect(),/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/car/src/android/car/cts/CarTest.java,,
,7.4.8,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.4.8/C-1-2,,07040800.670102,android.hardware.se.omapi.uicc UICC 7.4.8 android.hardware.se.omapi.ese android.hardware.se.omapi.sd FEATURE_SE_OMAPI_UICC FEATURE_SE_OMAPI_ESE C-1-2 FEATURE_SE_OMAPI_SD,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.5.4,C-0-12,,android.hardware.camera2.cts.FlashlightTest,setUp(),CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import android.hardware.camera2.CameraManager; import android.hardware.camera2.CameraAccessException; import android.hardware.camera2.cts.CameraTestUtils.HandlerExecutor; import android.hardware.camera2.cts.testcases.Camera2AndroidTestCase; import android.hardware.camera2.cts.helpers.StaticMetadata; import android.hardware.camera2.cts.helpers.StaticMetadata.CheckLevel; import android.util.Log; import android.os.SystemClock; import java.util.ArrayList; import java.util.Arrays; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.Executor; import java.util.concurrent.TimeUnit;  import static org.mockito.Mockito.*; import org.junit.runners.Parameterized; import org.junit.runner.RunWith; import org.junit.Test;  import static junit.framework.Assert.*;  /**  * <p>Tests for flashlight API.</p>  */  @RunWith(Parameterized.class) public class FlashlightTest extends Camera2AndroidTestCase {     private static final String TAG = ""FlashlightTest"";     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);     private static final int TORCH_DURATION_MS = 1000;     private static final int TORCH_TIMEOUT_MS = 3000;     private static final int NUM_REGISTERS = 10;      private ArrayList<String> mFlashCameraIdList;      @Override     public void setUp() throws Exception {         //Use all camera ids for system camera testing since we count the number of callbacks here         // and when mAdoptShellPerm == true, all camera ids will get callbacks.         super.setUp(/*useAll*/true);          // initialize the list of cameras that have a flash unit so it won't interfere with         // flash tests.         mFlashCameraIdList = new ArrayList<String>();         for (String id : mCameraIdsUnderTest) {             StaticMetadata info =                     new StaticMetadata(mCameraManager.getCameraCharacteristics(id),                                        CheckLevel.ASSERT, /*collector*/ null);             if (info.hasFlash()) {                 mFlashCameraIdList.add(id);             }         }     }      ",7.5.4/C-0-12,,07050400.670012,android.hardware.Camera 7.5.4 android.hardware.camera C-0-12,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.FlashlightTest:setUp()],,android.hardware.camera,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/FlashlightTest.java,,
,9.1,C-2-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",9.1/C-2-1,,09010000.670201,Settings.html ACTION_MANAGE_OVERLAY_PERMISSION 9.1 C-2-1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-2-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,9.5,C-1-2,,android.location.cts.fine.GnssAntennaInfoTest,,,"/*  *.  */  package android.location.cts.fine;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull;  import android.location.GnssAntennaInfo; import android.location.GnssAntennaInfo.PhaseCenterOffset; import android.location.GnssAntennaInfo.SphericalCorrections; import android.os.Parcel;  import androidx.test.ext.junit.runners.AndroidJUnit4;  import org.junit.Test; import org.junit.runner.RunWith;  /**  * Tests fundamental functionality of GnssAntennaInfo class. This includes writing and reading from  * parcel, and verifying computed values and getters.  */ @RunWith(AndroidJUnit4.class) public class GnssAntennaInfoTest {      private static final double PRECISION = 0.0001;     private static final double[][] PHASE_CENTER_VARIATION_CORRECTIONS = new double[][]{         {5.29, 0.20, 7.15, 10.18, 9.47, 8.05},         {11.93, 3.98, 2.68, 2.66, 8.15, 13.54},         {14.69, 7.63, 13.46, 8.70, 4.36, 1.21},         {4.19, 12.43, 12.40, 0.90, 1.96, 1.99},         {7.30, 0.49, 7.43, 8.71, 3.70, 7.24},         {4.79, 1.88, 13.88, 3.52, 13.40, 11.81}     };     private static final double[][] PHASE_CENTER_VARIATION_CORRECTION_UNCERTAINTIES = new double[][]{             {1.77, 0.81, 0.72, 1.65, 2.35, 1.22},             {0.77, 3.43, 2.77, 0.97, 4.55, 1.38},             {1.51, 2.50, 2.23, 2.43, 1.94, 0.90},             {0.34, 4.72, 4.14, 4.78, 4.57, 1.69},             {4.49, 0.05, 2.78, 1.33, 3.20, 2.75},             {1.09, 0.31, 3.79, 4.32, 0.65, 1.23}     };     private static final double[][] SIGNAL_GAIN_CORRECTIONS = new double[][]{             {0.19, 7.04, 1.65, 14.84, 2.95, 9.21},             {0.45, 6.27, 14.57, 8.95, 3.92, 12.68},             {6.80, 13.04, 7.92, 2.23, 14.22, 7.36},             {4.81, 11.78, 5.04, 5.13, 12.09, 12.85},             {0.88, 4.04, 5.71, 3.72, 12.62, 0.40},             {14.26, 9.50, 4.21, 11.14, 6.54, 14.63}     };     private static final double[][] SIGNAL_GAIN_CORRECTION_UNCERTAINTIES = new double[][]{             {4.74, 1.54, 1.59, 4.05, 1.65, 2.46},             {0.10, 0.33, 0.84, 0.83, 0.57, 2.66},             {2.08, 1.46, 2.10, 3.25, 1.48, 0.65},             {4.02, 2.90, 2.51, 2.13, 1.67, 1.23},             {2.13, 4.30, 1.36, 3.86, 1.02, 2.96},             {3.22, 3.95, 3.75, 1.73, 1.91, 4.93}      };      ",9.5/C-1-2,,09050000.670102,permissions.html C-1-2 9.5,Test[None]:[android.location.cts.fine.GnssAntennaInfoTest:],,9.5,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/location/location_fine/src/android/location/cts/fine/GnssAntennaInfoTest.java,,
,9.8.9,C-0-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testMonochromeCharacteristics(),CtsCameraTestCases,"     public void testMonochromeCharacteristics() {         for (int i = 0; i < mAllCameraIds.length; i++) {             Log.i(TAG, ""testMonochromeCharacteristics: Testing camera ID "" + mAllCameraIds[i]);              CameraCharacteristics c = mCharacteristics.get(i);             int[] capabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);             assertNotNull(""android.request.availableCapabilities must never be null"",                     capabilities);             boolean supportMonochrome = arrayContains(capabilities, MONOCHROME);              if (!supportMonochrome) {                 continue;             }              List<Key<?>> allKeys = c.getKeys();             List<CaptureRequest.Key<?>> requestKeys = c.getAvailableCaptureRequestKeys();             List<CaptureResult.Key<?>> resultKeys = c.getAvailableCaptureResultKeys();              assertTrue(""Monochrome camera must have BACKWARD_COMPATIBLE capability"",                     arrayContains(capabilities, BC));             int colorFilterArrangement = c.get(                     CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT);             assertTrue(""Monochrome camera must have either MONO or NIR color filter pattern"",                     colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO                     || colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR);              assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX1));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT1));             assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX2));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT2));              assertFalse(                     ""Monochrome capture result must not contain SENSOR_NEUTRAL_COLOR_POINT key"",                     resultKeys.contains(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT));             assertFalse(""Monochrome capture result must not contain SENSOR_GREEN_SPLIT key"",                     resultKeys.contains(CaptureResult.SENSOR_GREEN_SPLIT));              // Check that color correction tags are not available for monochrome cameras             assertTrue(""Monochrome camera must not have MANUAL_POST_PROCESSING capability"",                     !arrayContains(capabilities, MANUAL_POSTPROC));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_GAINS));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_GAINS));              // Check that awbSupportedModes only contains AUTO             int[] awbAvailableModes = c.get(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES);             assertTrue(""availableAwbModes must not be null"", awbAvailableModes != null);             assertTrue(""availableAwbModes must contain only AUTO"", awbAvailableModes.length == 1 &&                     awbAvailableModes[0] == CaptureRequest.CONTROL_AWB_MODE_AUTO);         }     }      /**      * Check that all devices available through the legacy API are also      * accessible via Camera2.      */     @CddTest(requirement=""7.5.4/C-0-11"")     ",9.8.9/C-0-1,,09080900.670001,9.8.9 C-0-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testMonochromeCharacteristics()],,C-0-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.8.10,C-1-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",9.8.10/C-1-1,,09081000.670101,9.8.10 C-1-1 BUGREPORT_MODE_TELEPHONY,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-1-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,9.8.10,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.8.10/C-1-2,,09081000.670102,9.8.10 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.8.10,C-1-4,,android.media.cts.MediaDrmTest,testSupportedCryptoSchemes(),,"     public void testSupportedCryptoSchemes() throws Exception {         List<UUID> supportedCryptoSchemes = MediaDrm.getSupportedCryptoSchemes();         if (supportedCryptoSchemes.isEmpty()) {             Log.w(TAG, ""No supported crypto schemes reported"");         }         for (UUID scheme : supportedCryptoSchemes) {             Log.d(TAG, ""supported scheme: "" + scheme.toString());             assertTrue(MediaDrm.isCryptoSchemeSupported(scheme));             testSingleScheme(scheme);         }     }  } ",9.8.10/C-1-4,,09081000.670104,9.8.10 C-1-4 UID,Test[None]:[android.media.cts.MediaDrmTest:testSupportedCryptoSchemes()],,UID,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/MediaDrmTest.java,,
,9.8.11,C-1-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",9.8.11/C-1-1,,09081100.670101,allowPackageAccess() allowSameSignatureAccess() BlobStoreManager.session C-1-1 allowPublicAccess() 9.8.11,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-1-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,9.8.11,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.8.11/C-1-2,,09081100.670102,9.8.11 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.9.4,C-0-1,,android.graphics.cts.InterpolatorTest,testReset1(),,"     public void testReset1() {         final int expected = 100;         Interpolator interpolator = new Interpolator(10);         assertEquals(DEFAULT_KEYFRAME_COUNT, interpolator.getKeyFrameCount());         interpolator.reset(expected);         assertEquals(expected, interpolator.getValueCount());         assertEquals(DEFAULT_KEYFRAME_COUNT, interpolator.getKeyFrameCount());     }      ",9.9.4/C-0-1,,09090400.670001,RAM C-0-1 9.9.4 PIN OTA,Test[None]:[android.graphics.cts.InterpolatorTest:testReset1()],,RAM,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/InterpolatorTest.java,,
,9.11.3,C-0-1,,android.autofillservice.cts.augmented.ClipboardAccessTest,prepareClipboardManager(),CtsAutoFillServiceTestCases,"/*  *.  */  package android.autofillservice.cts.augmented;  import static android.content.Context.CLIPBOARD_SERVICE;  import static com.google.common.truth.Truth.assertWithMessage;  import android.content.ClipData; import android.content.ClipboardManager; import android.platform.test.annotations.AppModeFull;  import org.junit.After; import org.junit.Before; import org.junit.Test;  @AppModeFull(reason = ""AugmentedLoginActivityTest is enough"") public class ClipboardAccessTest extends AugmentedAutofillManualActivityLaunchTestCase {      private ClipboardManager mClipboardManager;      @Before     public void prepareClipboardManager() {         mClipboardManager = (ClipboardManager) sContext.getSystemService(CLIPBOARD_SERVICE);         mClipboardManager.clearPrimaryClip();     }      @After     public void cleanYourself() {         mClipboardManager.clearPrimaryClip();     }      ",9.11.3/C-0-1,,09110300.670001,getInstance() android.content.Context C-0-1 9.11.3,Test[CtsAutoFillServiceTestCases]:[android.autofillservice.cts.augmented.ClipboardAccessTest:prepareClipboardManager()],,android.content.Context,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/augmented/ClipboardAccessTest.java,,
,9.11.3,C-0-2,,android.security.identity.cts.UserAuthTest,DeviceLockSession(),,"/*  *.  */  package android.security.identity.cts;  import static android.security.identity.IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256;  import android.security.identity.AccessControlProfile; import android.security.identity.AccessControlProfileId; import android.security.identity.AlreadyPersonalizedException; import android.security.identity.PersonalizationData; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.WritableIdentityCredential; import android.security.identity.ResultData;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.content.Context; import android.os.SystemClock; import android.util.Log;  import androidx.test.InstrumentationRegistry;  import android.app.KeyguardManager; import android.server.wm.ActivityManagerTestBase;  import org.junit.Test;  import java.io.ByteArrayOutputStream; import java.io.IOException; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.KeyPair; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.Signature; import java.security.SignatureException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.util.Arrays; import java.util.ArrayList; import java.util.Collection; import java.util.LinkedHashMap; import java.util.LinkedList; import java.util.Map;  import co.nstant.in.cbor.CborBuilder; import co.nstant.in.cbor.CborEncoder; import co.nstant.in.cbor.CborException;  import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.PrivateKey; import java.security.UnrecoverableEntryException;  import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.spec.GCMParameterSpec;  import android.security.keystore.KeyGenParameterSpec; import android.security.keystore.KeyProperties; import android.security.keystore.UserNotAuthenticatedException;   public class UserAuthTest {     private static final String TAG = ""UserAuthTest"";      private class DeviceLockSession extends ActivityManagerTestBase implements AutoCloseable {          private LockScreenSession mLockCredential;          public DeviceLockSession() throws Exception {             mLockCredential = new LockScreenSession();             mLockCredential.setLockCredential();         }          public void performDeviceLock() {             mLockCredential.sleepDevice();             Context appContext = InstrumentationRegistry.getTargetContext();             KeyguardManager keyguardManager = (KeyguardManager)appContext.                                               getSystemService(Context.KEYGUARD_SERVICE);             for (int i = 0; i < 25 && !keyguardManager.isDeviceLocked(); i++) {                 SystemClock.sleep(200);             }         }          public void performDeviceUnlock() throws Exception {             mLockCredential.gotoKeyguard();             mLockCredential.enterAndConfirmLockCredential();             launchHomeActivity();         }          @Override         public void close() throws Exception {             mLockCredential.close();         }     }      private boolean checkAuthBoundKey(String alias) {         // Unfortunately there are no APIs to tell if a key needs user authentication to work so         // we check if the key is available by simply trying to encrypt some data.         try {             KeyStore ks = KeyStore.getInstance(""AndroidKeyStore"");             ks.load(null);             KeyStore.Entry entry = ks.getEntry(alias, null);             SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();              Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");             cipher.init(Cipher.ENCRYPT_MODE, secretKey);             byte[] clearText = {0x01, 0x02};             byte[] cipherText = cipher.doFinal(clearText);             return true;         } catch (UserNotAuthenticatedException e) {             return false;         } catch (Exception e) {             throw new RuntimeException(""Failed!"", e);         }     }      void createAuthBoundKey(String alias, int timeoutSeconds) {         try {             KeyGenerator kg = KeyGenerator.getInstance(                 KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");             KeyGenParameterSpec.Builder builder =                     new KeyGenParameterSpec.Builder(                         alias,                         KeyProperties.PURPOSE_ENCRYPT| KeyProperties.PURPOSE_DECRYPT)                             .setBlockModes(KeyProperties.BLOCK_MODE_GCM)                             .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)                             .setUserAuthenticationRequired(true)                             .setUserAuthenticationValidityDurationSeconds(timeoutSeconds)                             .setKeySize(128);             kg.init(builder.build());             kg.generateKey();         } catch (InvalidAlgorithmParameterException                 | NoSuchAlgorithmException                 | NoSuchProviderException e) {             throw new RuntimeException(""Error creating auth-bound key"", e);         }     }      ",9.11.3/C-0-2,,09110300.670002,android.security.identity C-0-2 DMA 9.11.3,Test[None]:[android.security.identity.cts.UserAuthTest:DeviceLockSession()],,android.security.identity,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/UserAuthTest.java,,
,9.11.3,C-0-3,,android.security.identity.cts.UserAuthTest,DeviceLockSession(),,"/*  *.  */  package android.security.identity.cts;  import static android.security.identity.IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256;  import android.security.identity.AccessControlProfile; import android.security.identity.AccessControlProfileId; import android.security.identity.AlreadyPersonalizedException; import android.security.identity.PersonalizationData; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.WritableIdentityCredential; import android.security.identity.ResultData;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.content.Context; import android.os.SystemClock; import android.util.Log;  import androidx.test.InstrumentationRegistry;  import android.app.KeyguardManager; import android.server.wm.ActivityManagerTestBase;  import org.junit.Test;  import java.io.ByteArrayOutputStream; import java.io.IOException; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.KeyPair; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.Signature; import java.security.SignatureException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.util.Arrays; import java.util.ArrayList; import java.util.Collection; import java.util.LinkedHashMap; import java.util.LinkedList; import java.util.Map;  import co.nstant.in.cbor.CborBuilder; import co.nstant.in.cbor.CborEncoder; import co.nstant.in.cbor.CborException;  import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.PrivateKey; import java.security.UnrecoverableEntryException;  import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.spec.GCMParameterSpec;  import android.security.keystore.KeyGenParameterSpec; import android.security.keystore.KeyProperties; import android.security.keystore.UserNotAuthenticatedException;   public class UserAuthTest {     private static final String TAG = ""UserAuthTest"";      private class DeviceLockSession extends ActivityManagerTestBase implements AutoCloseable {          private LockScreenSession mLockCredential;          public DeviceLockSession() throws Exception {             mLockCredential = new LockScreenSession();             mLockCredential.setLockCredential();         }          public void performDeviceLock() {             mLockCredential.sleepDevice();             Context appContext = InstrumentationRegistry.getTargetContext();             KeyguardManager keyguardManager = (KeyguardManager)appContext.                                               getSystemService(Context.KEYGUARD_SERVICE);             for (int i = 0; i < 25 && !keyguardManager.isDeviceLocked(); i++) {                 SystemClock.sleep(200);             }         }          public void performDeviceUnlock() throws Exception {             mLockCredential.gotoKeyguard();             mLockCredential.enterAndConfirmLockCredential();             launchHomeActivity();         }          @Override         public void close() throws Exception {             mLockCredential.close();         }     }      private boolean checkAuthBoundKey(String alias) {         // Unfortunately there are no APIs to tell if a key needs user authentication to work so         // we check if the key is available by simply trying to encrypt some data.         try {             KeyStore ks = KeyStore.getInstance(""AndroidKeyStore"");             ks.load(null);             KeyStore.Entry entry = ks.getEntry(alias, null);             SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();              Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");             cipher.init(Cipher.ENCRYPT_MODE, secretKey);             byte[] clearText = {0x01, 0x02};             byte[] cipherText = cipher.doFinal(clearText);             return true;         } catch (UserNotAuthenticatedException e) {             return false;         } catch (Exception e) {             throw new RuntimeException(""Failed!"", e);         }     }      void createAuthBoundKey(String alias, int timeoutSeconds) {         try {             KeyGenerator kg = KeyGenerator.getInstance(                 KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");             KeyGenParameterSpec.Builder builder =                     new KeyGenParameterSpec.Builder(                         alias,                         KeyProperties.PURPOSE_ENCRYPT| KeyProperties.PURPOSE_DECRYPT)                             .setBlockModes(KeyProperties.BLOCK_MODE_GCM)                             .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)                             .setUserAuthenticationRequired(true)                             .setUserAuthenticationValidityDurationSeconds(timeoutSeconds)                             .setKeySize(128);             kg.init(builder.build());             kg.generateKey();         } catch (InvalidAlgorithmParameterException                 | NoSuchAlgorithmException                 | NoSuchProviderException e) {             throw new RuntimeException(""Error creating auth-bound key"", e);         }     }      ",9.11.3/C-0-3,,09110300.670003,android.security.identity 9.11.3 C-0-3 createEphemeralKeyPair(),Test[None]:[android.security.identity.cts.UserAuthTest:DeviceLockSession()],,android.security.identity,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/UserAuthTest.java,,
,9.11.3,C-0-4,,android.net.cts.IpSecManagerTest,testAuthTcp4UdpEncap(),,"     public void testAuthTcp4UdpEncap() throws Exception {         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA256, getKey(256), 128);         checkTransform(IPPROTO_TCP, IPV4_LOOPBACK, null, auth, null, true, 1, false);         checkTransform(IPPROTO_TCP, IPV4_LOOPBACK, null, auth, null, true, 1, true);     }      ",9.11.3/C-0-4,,09110300.670004,MAC C-0-4 9.11.3,Test[None]:[android.net.cts.IpSecManagerTest:testAuthTcp4UdpEncap()],,MAC,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java,,
,9.16,C-1-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",9.16/C-1-1,,09160000.670101,9.16 C-1-1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-1-1,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,9.16,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.16/C-1-2,,09160000.670102,9.16 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.16,C-1-4,,android.packageinstaller.tapjacking.cts.TapjackingTest,getSimpleName(),,"/*  *.  */ package android.packageinstaller.tapjacking.cts;  import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK; import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull;  import android.content.Context; import android.content.Intent; import android.content.pm.PackageManager; import android.net.Uri; import android.platform.test.annotations.AppModeFull; import android.support.test.uiautomator.By; import android.support.test.uiautomator.BySelector; import android.support.test.uiautomator.UiDevice; import android.support.test.uiautomator.UiObject2; import android.support.test.uiautomator.Until; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.MediumTest; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.junit.AssumptionViolatedException; import org.junit.Rule; import org.junit.rules.TestRule; import org.junit.runner.Description; import org.junit.runners.model.Statement;  import java.io.IOException;  @RunWith(AndroidJUnit4.class) @MediumTest @AppModeFull public class TapjackingTest {      private static final String LOG_TAG = TapjackingTest.class.getSimpleName();     private static final String SYSTEM_PACKAGE_NAME = ""android"";     private static final String INSTALL_BUTTON_ID = ""button1"";     private static final String OVERLAY_ACTIVITY_TEXT_VIEW_ID = ""overlay_description"";     private static final String WM_DISMISS_KEYGUARD_COMMAND = ""wm dismiss-keyguard"";     private static final String TEST_APP_PACKAGE_NAME = ""android.packageinstaller.emptytestapp.cts"";      private static final long WAIT_FOR_UI_TIMEOUT = 5000;      private Context mContext = InstrumentationRegistry.getTargetContext();     private String mPackageName;     private UiDevice mUiDevice;     boolean isWatch = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);      @Rule     public final RequiredRule mRequiredRule = new RequiredRule(isWatch);      @Before     public void setUp() throws Exception {         mPackageName = mContext.getPackageName();         mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());         if (!mUiDevice.isScreenOn()) {             mUiDevice.wakeUp();         }         mUiDevice.executeShellCommand(WM_DISMISS_KEYGUARD_COMMAND);     }      private void launchPackageInstaller() {         Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE);         intent.setData(Uri.parse(""package:"" + TEST_APP_PACKAGE_NAME));         intent.addFlags(FLAG_ACTIVITY_CLEAR_TASK | FLAG_ACTIVITY_NEW_TASK);         mContext.startActivity(intent);     }      private void launchOverlayingActivity() {         Intent intent = new Intent(mContext, OverlayingActivity.class);         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         mContext.startActivity(intent);     }      private UiObject2 waitForView(String packageName, String id) {         final BySelector selector = By.res(packageName, id);         return mUiDevice.wait(Until.findObject(selector), WAIT_FOR_UI_TIMEOUT);     }      ",9.16/C-1-4,,09160000.670104,9.16 C-1-4 AND,Test[None]:[android.packageinstaller.tapjacking.cts.TapjackingTest:getSimpleName()],,AND,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/packageinstaller/tapjacking/src/android/packageinstaller/tapjacking/cts/TapjackingTest.java,,
,9.16,C-1-5,,android.graphics.cts.VulkanFeaturesTest,testVulkan1_1Requirements(),,"     public void testVulkan1_1Requirements() throws JSONException {         if (mVulkanHardwareVersion == null || mVulkanHardwareVersion.version < VULKAN_1_1                 || !PropertyUtil.isVendorApiLevelNewerThan(                         API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ)) {             return;         }         assertTrue(""Devices with Vulkan 1.1 must support sampler YCbCr conversion"",                 mBestDevice.getJSONObject(""samplerYcbcrConversionFeatures"")                            .getInt(""samplerYcbcrConversion"") != 0);          if (hasOnlyCpuDevice()) {             return;         }         assertTrue(""Devices with Vulkan 1.1 must support "" +                 VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME +                 "" (version >= "" + VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION +                 "")"",                 hasExtension(mBestDevice,                     VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME,                     VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION));         assertTrue(""Devices with Vulkan 1.1 must support SYNC_FD external semaphores"",                 hasHandleType(mBestDevice.getJSONArray(""externalSemaphoreProperties""),                     VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,                     ""externalSemaphoreFeatures"", 0x3 /* importable + exportable */));         assertTrue(""Devices with Vulkan 1.1 must support SYNC_FD external fences"",                 hasHandleType(mBestDevice.getJSONArray(""externalFenceProperties""),                     VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,                     ""externalFenceFeatures"", 0x3 /* importable + exportable */));     }      @CddTest(requirement = ""7.9.2/C-1-5"")     ",9.16/C-1-5,,09160000.670105,9.16 C-1-5,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkan1_1Requirements()],,C-1-5,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/NintendoSwitchProTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
