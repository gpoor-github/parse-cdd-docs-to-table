"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.EasyConnectStatusCallbackTest"	"testConfiguratorInitiatorOnFailure"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/EasyConnectStatusCallbackTest.java"	""	"public void testConfiguratorInitiatorOnFailure() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectSupported()) {
            // skip the test if Easy Connect is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            WifiConfiguration config;
            config = new WifiConfiguration();
            config.SSID = TEST_SSID;
            config.preSharedKey = TEST_PASSPHRASE;
            config.setSecurityParams(SECURITY_TYPE_PSK);
            int networkId = mWifiManager.addNetwork(config);
            assertFalse(networkId == -1);
            synchronized (mLock) {
                mWifiManager.startEasyConnectAsConfiguratorInitiator(TEST_DPP_URI, networkId,
                        EASY_CONNECT_NETWORK_ROLE_STA, mExecutor, mEasyConnectStatusCallback);
                // Note: A long delay is necessary because there is no enrollee, and the system
                // tries to discover it. We will wait for a timeout error to occur.
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            mWifiManager.removeNetwork(networkId);
            assertTrue(mOnFailureCallback);
            assertEquals(EASY_CONNECT_EVENT_FAILURE_TIMEOUT, mErrorCode);
            mWifiManager.stopEasyConnectSession();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link android.net.wifi.EasyConnectStatusCallback} class.
     *
     * Since Easy Connect requires 2 devices, start Easy Connect session and expect an error.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.EasyConnectStatusCallbackTest"	"testEnrolleeInitiatorOnFailure"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/EasyConnectStatusCallbackTest.java"	""	"public void testEnrolleeInitiatorOnFailure() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectSupported()) {
            // skip the test if Easy Connect is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            synchronized (mLock) {
                mWifiManager.startEasyConnectAsEnrolleeInitiator(TEST_DPP_URI, mExecutor,
                        mEasyConnectStatusCallback);
                // Note: A long delay is necessary because there is no configurator, and the system
                // tries to discover it. We will wait for a timeout error to occur.
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            assertTrue(mOnFailureCallback);
            assertEquals(EASY_CONNECT_EVENT_FAILURE_TIMEOUT, mErrorCode);
            mWifiManager.stopEasyConnectSession();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link android.net.wifi.EasyConnectStatusCallback#onBootstrapUriGenerated} callback.
     *
     * Since Easy Connect requires 2 devices, start Easy Connect responder session and expect a
     * DPP URI
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.EasyConnectStatusCallbackTest"	"testEnrolleeResponderUriGeneration"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/EasyConnectStatusCallbackTest.java"	""	"public void testEnrolleeResponderUriGeneration() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectEnrolleeResponderModeSupported()) {
            // skip the test if Easy Connect Enrollee responder mode is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            synchronized (mLock) {
                assertTrue(mWifiManager.getEasyConnectMaxAllowedResponderDeviceInfoLength()
                        > TEST_DEVICE_INFO.length());
                mWifiManager.startEasyConnectAsEnrolleeResponder(TEST_DEVICE_INFO,
                        EASY_CONNECT_CRYPTOGRAPHY_CURVE_PRIME256V1, mExecutor,
                        mEasyConnectStatusCallback);
                // Wait for supplicant to generate DPP URI and trigger the callback function to
                // provide the generated URI.
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            assertTrue(mOnBootstrapUriGeneratedCallback);
            mWifiManager.stopEasyConnectSession();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Test that {@link WifiManager#startEasyConnectAsEnrolleeResponder(String, int, Executor,
     * EasyConnectStatusCallback)} throws illegal argument exception on passing a wrong device
     * info.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
    public void
           testStartEasyConnectAsEnrolleeResponderThrowsIllegalArgumentExceptionOnWrongDeviceInfo()
           throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectEnrolleeResponderModeSupported()) {
            // skip the test if Easy Connect Enrollee responder mode is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.startEasyConnectAsEnrolleeResponder(TEST_WRONG_DEVICE_INFO,
                    EASY_CONNECT_CRYPTOGRAPHY_CURVE_PRIME256V1, mExecutor,
                    mEasyConnectStatusCallback);
            fail(""startEasyConnectAsEnrolleeResponder did not throw an IllegalArgumentException""
                    + ""on passing a wrong device info!"");
        } catch (IllegalArgumentException expected) {}
        uiAutomation.dropShellPermissionIdentity();
    }
}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.TestBase"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/TestBase.java"	""	"public void test/*
 *.
 */

package android.net.wifi.rtt.cts;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiManager;
import android.net.wifi.cts.WifiJUnit3TestBase;
import android.net.wifi.rtt.RangingResult;
import android.net.wifi.rtt.RangingResultCallback;
import android.net.wifi.rtt.WifiRttManager;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
 * Base class for Wi-Fi RTT CTS test cases. Provides a uniform configuration and event management
 * facility.
 */
public class TestBase extends WifiJUnit3TestBase {
    protected static final String TAG = ""WifiRttCtsTests"";

    // wait for Wi-Fi RTT to become available
    private static final int WAIT_FOR_RTT_CHANGE_SECS = 10;

    // wait for Wi-Fi scan results to become available
    private static final int WAIT_FOR_SCAN_RESULTS_SECS = 20;

    // wait for network selection and connection finish
    private static final int WAIT_FOR_CONNECTION_FINISH_MS = 30_000;

    // Interval between failure scans
    private static final int INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS = 5_000;

    // 5GHz Frequency band
    private static final int FREQUENCY_OF_5GHZ_BAND_IN_MHZ = 5_000;

    protected WifiRttManager mWifiRttManager;
    protected WifiManager mWifiManager;
    private LocationManager mLocationManager;
    private WifiManager.WifiLock mWifiLock;

    private final HandlerThread mHandlerThread = new HandlerThread(""SingleDeviceTest"");
    protected final Executor mExecutor;
    private Boolean mWasVerboseLoggingEnabled;

    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    /**
     * Returns a flag indicating whether or not Wi-Fi RTT should be tested. Wi-Fi RTT
     * should be tested if the feature is supported on the current device.
     */
    static boolean shouldTestWifiRtt(Context context) {
        final PackageManager pm = context.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_WIFI_RTT);
    }

    /**
     * Returns a flag indicating whether or not Wi-Fi Aware should be tested. Wi-Fi Aware
     * should be tested if the feature is supported on the current device.
     */
    static boolean shouldTestWifiAware(Context context) {
        final PackageManager pm = context.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        if (!shouldTestWifiRtt(getContext())) {
            return;
        }

        mLocationManager = (LocationManager) getContext().getSystemService(
                Context.LOCATION_SERVICE);
        assertTrue(""RTT testing requires Location to be enabled"",
                mLocationManager.isLocationEnabled());

        mWifiRttManager = (WifiRttManager) getContext().getSystemService(
                Context.WIFI_RTT_RANGING_SERVICE);
        assertNotNull(""Wi-Fi RTT Manager"", mWifiRttManager);

        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(""Wi-Fi Manager"", mWifiManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        if (!mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable"");
            // Turn on Wi-Fi may trigger connection. Wait connection state stable.
            scanAps();
            Thread.sleep(WAIT_FOR_CONNECTION_FINISH_MS);
        }
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiRttManager.ACTION_WIFI_RTT_STATE_CHANGED);
        WifiRttBroadcastReceiver receiver = new WifiRttBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);
        if (!mWifiRttManager.isAvailable()) {
            assertTrue(""Timeout waiting for Wi-Fi RTT to change status"",
                    receiver.waitForStateChange());
            assertTrue(""Wi-Fi RTT is not available (should be)"", mWifiRttManager.isAvailable());
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (!shouldTestWifiRtt(getContext())) {
            super.tearDown();
            return;
        }

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));

        super.tearDown();
    }

    class WifiRttBroadcastReceiver extends BroadcastReceiver {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiRttManager.ACTION_WIFI_RTT_STATE_CHANGED.equals(intent.getAction())) {
                mBlocker.countDown();
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_RTT_CHANGE_SECS, TimeUnit.SECONDS);
        }
    }

    class WifiScansBroadcastReceiver extends BroadcastReceiver {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiManager.SCAN_RESULTS_AVAILABLE_ACTION.equals(intent.getAction())) {
                mBlocker.countDown();
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_SCAN_RESULTS_SECS, TimeUnit.SECONDS);
        }
    }

    class ResultCallback extends RangingResultCallback {
        private CountDownLatch mBlocker = new CountDownLatch(1);
        private int mCode; // 0: success, otherwise RangingResultCallback STATUS_CODE_*.
        private List<RangingResult> mResults;

        @Override
        public void onRangingFailure(int code) {
            mCode = code;
            mResults = null; // not necessary since intialized to null - but for completeness
            mBlocker.countDown();
        }

        @Override
        public void onRangingResults(List<RangingResult> results) {
            mCode = 0; // not necessary since initialized to 0 - but for completeness
            mResults = results;
            mBlocker.countDown();
        }

        /**
         * Waits for the listener callback to be called - or an error (timeout, interruption).
         * Returns true on callback called, false on error (timeout, interruption).
         */
        boolean waitForCallback() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_RTT_CHANGE_SECS, TimeUnit.SECONDS);
        }

        /**
         * Returns the code of the callback operation. Will be 0 for success (onRangingResults
         * called), else (if onRangingFailure called) will be one of the STATUS_CODE_* values.
         */
        int getCode() {
            return mCode;
        }

        /**
         * Returns the list of ranging results. In cases of error (getCode() != 0) will return null.
         */
        List<RangingResult> getResults() {
            return mResults;
        }
    }

    /**
     * Start a scan and return a list of observed ScanResults (APs).
     */
    protected List<ScanResult> scanAps() throws InterruptedException {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        WifiScansBroadcastReceiver receiver = new WifiScansBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);

        mWifiManager.startScan();
        receiver.waitForStateChange();
        mContext.unregisterReceiver(receiver);
        return mWifiManager.getScanResults();
    }

    /**
     * Start a scan and return a test AP which supports IEEE 802.11mc and which has the highest
     * RSSI. Will perform N (parameterized) scans and get the best AP across both scans.
     *
     * Returns null if test AP is not found in the specified number of scans.
     *
     * @param numScanRetries Maximum number of scans retries (in addition to first scan).
     */
    protected ScanResult scanForTest11mcCapableAp(int numScanRetries)
            throws InterruptedException {
        int scanCount = 0;
        ScanResult bestTestAp = null;
        while (scanCount <= numScanRetries) {
            for (ScanResult scanResult : scanAps()) {
                if (!scanResult.is80211mcResponder()) {
                    continue;
                }
                if (bestTestAp == null || scanResult.level > bestTestAp.level) {
                    bestTestAp = scanResult;
                }
            }
            if (bestTestAp == null) {
                // Ongoing connection may cause scan failure, wait for a while before next scan.
                Thread.sleep(INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS);
            }
            scanCount++;
        }
        return bestTestAp;
    }

    /**
     * Start a scan and return a test AP which does NOT support IEEE 802.11mc, with a BSS in the
     * 5GHz band, and which has the highest RSSI. Will perform N (parameterized) scans and get
     * the best AP across all scan results.
     *
     * Returns null if test AP is not found in the specified number of scans.
     *
     * @param numScanRetries Maximum number of scans retries (in addition to first scan).
     */
    protected ScanResult scanForTestNon11mcCapableAp(int numScanRetries)
            throws InterruptedException {
        int scanCount = 0;
        ScanResult bestTestAp = null;
        while (scanCount <= numScanRetries) {
            for (ScanResult scanResult : scanAps()) {
                // Ensure using a 5GHz or greater channel
                if (scanResult.is80211mcResponder()
                        || scanResult.centerFreq0 < FREQUENCY_OF_5GHZ_BAND_IN_MHZ) {
                    continue;
                }
                if (bestTestAp == null || scanResult.level > bestTestAp.level) {
                    bestTestAp = scanResult;
                }
            }
            if (bestTestAp == null) {
                // Ongoing connection may cause scan failure, wait for a while before next scan.
                Thread.sleep(INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS);
            }
            scanCount++;
        }
        return bestTestAp;
    }
}"	""	""	"feature flag"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"testWifiInfoProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void testWifiInfoProperties() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected - Please ensure there is a saved network in range of this ""
                        + ""device"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        // this test case should in Wifi environment
        WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

        testWifiInfoPropertiesWhileConnected(wifiInfo);

        setWifiEnabled(false);

        PollingCheck.check(""getNetworkId not -1"", 20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);

        PollingCheck.check(""getWifiState not disabled"", 20000,
                () -> mWifiManager.getWifiState() == WifiManager.WIFI_STATE_DISABLED);
    }

    private void testWifiInfoPropertiesWhileConnected(WifiInfo wifiInfo) {
        assertThat(wifiInfo).isNotNull();
        assertThat(wifiInfo.toString()).isNotNull();
        SupplicantState.isValidState(wifiInfo.getSupplicantState());
        WifiInfo.getDetailedStateOf(SupplicantState.DISCONNECTED);
        String ssid = wifiInfo.getSSID();
        if (!ssid.startsWith(""0x"") && !ssid.equals(WifiManager.UNKNOWN_SSID)) {
            // Non-hex string should be quoted
            assertThat(ssid).startsWith(""\"""");
            assertThat(ssid).endsWith(""\"""");
        }

        assertThat(wifiInfo.getBSSID()).isNotNull();
        assertThat(wifiInfo.getFrequency()).isGreaterThan(0);
        assertThat(wifiInfo.getMacAddress()).isNotNull();

        wifiInfo.getRssi();
        wifiInfo.getIpAddress();
        wifiInfo.getHiddenSSID();
        wifiInfo.getScore();

        // null for saved networks
        assertThat(wifiInfo.getRequestingPackageName()).isNull();
        assertThat(wifiInfo.getPasspointFqdn()).isNull();
        assertThat(wifiInfo.getPasspointProviderFriendlyName()).isNull();

        // false for saved networks
        assertThat(wifiInfo.isEphemeral()).isFalse();
        assertThat(wifiInfo.isOsuAp()).isFalse();
        assertThat(wifiInfo.isPasspointAp()).isFalse();

        assertThat(wifiInfo.getWifiStandard()).isAnyOf(
                ScanResult.WIFI_STANDARD_UNKNOWN,
                ScanResult.WIFI_STANDARD_LEGACY,
                ScanResult.WIFI_STANDARD_11N,
                ScanResult.WIFI_STANDARD_11AC,
                ScanResult.WIFI_STANDARD_11AX
        );

        assertThat(wifiInfo.getLostTxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getRetriedTxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getSuccessfulRxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getSuccessfulTxPacketsPerSecond()).isAtLeast(0.0);

        // Can be -1 if link speed is unknown
        assertThat(wifiInfo.getLinkSpeed()).isAtLeast(-1);
        assertThat(wifiInfo.getTxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getRxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getMaxSupportedTxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getMaxSupportedRxLinkSpeedMbps()).isAtLeast(-1);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            assertThat(wifiInfo.getCurrentSecurityType()).isNotEqualTo(
                    WifiInfo.SECURITY_TYPE_UNKNOWN);
        }
    }

    /**
     * Test that the WifiInfo Builder returns the same values that was set, and that
     * calling build multiple times returns different instances.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.ScanResult;
import android.net.wifi.SupplicantState;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.WifiLock;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.telephony.SubscriptionManager;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.nio.charset.StandardCharsets;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class WifiInfoTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_CHANGED = 2;

    private static final String TEST_SSID = ""Test123"";
    private static final String TEST_BSSID = ""12:12:12:12:12:12"";
    private static final int TEST_RSSI = -60;
    private static final int TEST_NETWORK_ID = 5;
    private static final int TEST_NETWORK_ID2 = 6;

    private static final String TAG = ""WifiInfoTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION = 10000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.expectedState = STATE_WIFI_CHANGED;
                    mMySync.notify();
                }
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertThat(mWifiManager).isNotNull();
        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());

        mMySync.expectedState = STATE_NULL;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        Thread.sleep(DURATION);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_WIFI_CHANGING;
            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }
            long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
            while (System.currentTimeMillis() < timeout
                    && mMySync.expectedState == STATE_WIFI_CHANGING)
                mMySync.wait(WAIT_MSEC);
        }
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.wifibroadcasts.cts.WifiBroadcastsHostJUnit4Test"	"testCleanLogcat"	"CtsWifiBroadcastsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/wifibroadcasts/src/android/wifibroadcasts/cts/WifiBroadcastsHostJUnit4Test.java"	""	"public void testCleanLogcat() throws Exception {
        ITestDevice device = getDevice();
        assertNotNull(""Device not set"", device);
        if (!device.hasFeature(FEATURE_WIFI)) {
            return;
        }
        // Clear activity
        device.executeShellCommand(CLEAR_COMMAND);
        // No mobile data or wifi to start with
        device.executeShellCommand(""svc data disable; svc wifi disable"");
        // Clear logcat.
        device.executeAdbCommand(""logcat"", ""-c"");
        // Ensure the screen is on, so that rssi polling happens
        device.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        // Start the APK
        device.executeShellCommand(START_COMMAND);
        // Bring up wifi
        device.executeShellCommand(""svc wifi enable; sleep 1"");
        // Make sure wifi comes up
        String pingResult = """";
        CommandResult pingCommandResult = null;
        boolean pingSucceeded = false;
        for (int tries = 0; tries < MAXIMUM_PING_TRIES; tries++) {
            if (tries > 0 && tries % MAXIMUM_PING_TRIES_PER_CONNECTION == 0) {
                // if we have been trying for a while, toggle wifi off and then on.
                device.executeShellCommand(""svc wifi disable; sleep 1; svc wifi enable; sleep 3"");
            }
            // We don't require internet connectivity, just a configured address
            pingCommandResult = device.executeShellV2Command(""ping -c 4 -W 2 -t 1 8.8.8.8"");
            pingResult = String.join(""/"", pingCommandResult.getStdout(),
                                          pingCommandResult.getStderr(),
                                          pingCommandResult.getStatus().toString());
            if (pingResult.contains(""4 packets transmitted"")) {
                pingSucceeded = true;
                break;
            }
            Thread.sleep(1000);
        }
        // Stop wifi
        device.executeShellCommand(""svc wifi disable"");

        assertTrue(""Wi-Fi network unavailable - test could not complete "" + pingResult,
                pingSucceeded);

        // Dump logcat.
        String logs = device.executeAdbCommand(""logcat"", ""-v"", ""brief"", ""-d"", CLASS + "":I"", ""*:S"");
        // Search for prohibited string.
        Scanner in = new Scanner(logs);
        try {
            while (in.hasNextLine()) {
                String line = in.nextLine();
                if (line.startsWith(""I/"" + CLASS)) {
                    String payload = line.split("":"")[1].trim();
                    assertFalse(payload, payload.contains(PROHIBITED_STRING));
                }
            }
        } finally {
            in.close();
        }
        //Re-enable Wi-Fi as part of CTS Pre-conditions
        device.executeShellCommand(""svc wifi enable; sleep 1"");
    }
}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testSubscribeDiscoverySuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testSubscribeDiscoverySuccess() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final String serviceName = ""ValidName"";

        WifiAwareSession session = attachAndGetSession();

        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName(
                serviceName).build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        int numOfAllSubscribeSessions = 0;
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            numOfAllSubscribeSessions = mWifiAwareManager
                    .getAvailableAwareResources().getAvailableSubscribeSessionsCount();
        }
        // 1. subscribe
        session.subscribe(subscribeConfig, discoveryCb, mHandler);
        assertTrue(""Subscribe started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED));
        SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession();
        assertNotNull(""Subscribe session"", discoverySession);
        assertFalse(discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SERVICE_DISCOVERED));
        assertFalse(discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_DISCOVERED_LOST));
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(numOfAllSubscribeSessions - 1, mWifiAwareManager
                    .getAvailableAwareResources().getAvailableSubscribeSessionsCount());
        }

        // 2. update-subscribe
        boolean rttSupported = getContext().getPackageManager().hasSystemFeature(
                    PackageManager.FEATURE_WIFI_RTT);
        SubscribeConfig.Builder builder = new SubscribeConfig.Builder().setServiceName(
                    serviceName).setServiceSpecificInfo(""extras"".getBytes());

        if (rttSupported) {
            builder.setMinDistanceMm(MIN_DISTANCE_MM);
        }
        subscribeConfig = builder.build();

        discoverySession.updateSubscribe(subscribeConfig);
        assertTrue(""Subscribe update"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));

        // 3. destroy
        assertFalse(""Subscribe not terminated"", discoveryCb.hasCallbackAlreadyHappened(
                DiscoverySessionCallbackTest.ON_SESSION_TERMINATED));
        discoverySession.close();

        // 4. try update post-destroy: should time-out waiting for cb
        discoverySession.updateSubscribe(subscribeConfig);
        assertFalse(""Subscribe update post destroy"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(numOfAllSubscribeSessions, mWifiAwareManager
                    .getAvailableAwareResources().getAvailableSubscribeSessionsCount());
        }
        session.close();
    }

    /**
     * Validate that subscribe with a Time To Live (TTL) setting expires within the specified
     * time (and validates that the terminate callback is triggered).
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void test/*
 *.
 */

package android.cts.statsdatom.wifi;

import static android.cts.statsdatom.statsd.AtomTestCase.FEATURE_PC;
import static android.cts.statsdatom.statsd.AtomTestCase.FEATURE_WIFI;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;
import android.net.wifi.WifiModeEnum;

import com.android.os.AtomsProto;
import com.android.os.StatsLog;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import com.google.common.collect.Range;
import com.google.protobuf.AbstractMessage;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class WifiStatsTests extends DeviceTestCase implements IBuildReceiver {
    private IBuildInfo mCtsBuild;

    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        super.tearDown();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiLockHighPerf"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiLockHighPerf() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_PC)) return;

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_LOCK_STATE_CHANGED_FIELD_NUMBER, true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiLockHighPerf"");

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        Set<Integer> lockOn = new HashSet<>(
                Collections.singletonList(AtomsProto.WifiLockStateChanged.State.ON_VALUE));
        Set<Integer> lockOff = new HashSet<>(
                Collections.singletonList(AtomsProto.WifiLockStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(lockOn, lockOff);

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_SHORT,
                atom -> atom.getWifiLockStateChanged().getState().getNumber());

        for (StatsLog.EventMetricData event : data) {
            assertThat(event.getAtom().getWifiLockStateChanged().getMode())
                    .isEqualTo(WifiModeEnum.WIFI_MODE_FULL_HIGH_PERF);
        }
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiLockLowLatency"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiLockLowLatency() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_PC)) return;

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_LOCK_STATE_CHANGED_FIELD_NUMBER, true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiLockLowLatency"");

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        Set<Integer> lockOn = new HashSet<>(
                Collections.singletonList(AtomsProto.WifiLockStateChanged.State.ON_VALUE));
        Set<Integer> lockOff = new HashSet<>(
                Collections.singletonList(AtomsProto.WifiLockStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(lockOn, lockOff);

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_SHORT,
                atom -> atom.getWifiLockStateChanged().getState().getNumber());

        for (StatsLog.EventMetricData event : data) {
            assertThat(event.getAtom().getWifiLockStateChanged().getMode())
                    .isEqualTo(WifiModeEnum.WIFI_MODE_FULL_LOW_LATENCY);
        }
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiMulticastLock"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiMulticastLock() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_PC)) return;

        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_MULTICAST_LOCK_STATE_CHANGED_FIELD_NUMBER, true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiMulticastLock"");

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        Set<Integer> lockOn = new HashSet<>(
                Collections.singletonList(AtomsProto.WifiMulticastLockStateChanged.State.ON_VALUE));
        Set<Integer> lockOff = new HashSet<>(
                Collections.singletonList(
                        AtomsProto.WifiMulticastLockStateChanged.State.OFF_VALUE));

        final String EXPECTED_TAG = ""StatsdCTSMulticastLock"";

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(lockOn, lockOff);

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_SHORT,
                atom -> atom.getWifiMulticastLockStateChanged().getState().getNumber());

        for (StatsLog.EventMetricData event : data) {
            String tag = event.getAtom().getWifiMulticastLockStateChanged().getTag();
            assertThat(tag).isEqualTo(EXPECTED_TAG);
        }
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiReconnect"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiReconnect() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;

        ConfigUtils.uploadConfigForPushedAtoms(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                new int[] {
                        AtomsProto.Atom.WIFI_CONNECTION_RESULT_REPORTED_FIELD_NUMBER,
                        AtomsProto.Atom.WIFI_DISCONNECT_REPORTED_FIELD_NUMBER
                });

        // This test on device checks if device is connected, and connects it if it is not;
        // Afterwards, it disconnects from that network and connects back to it.
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiReconnect"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // If device had Wifi connected, we'll see two atoms: disconnect, connect.
        // If it was not connected, we'll see three: connect, disconnect, connect.
        // We're only interested in the disconnect-connect pair.
        assertWithMessage(
                ""Expected disconnected and connected atoms, got: \n"" +
                        data.stream().map(AbstractMessage::toString).reduce((acc, i) -> acc + i)
        ).that(data.size()).isIn(Range.closed(2, 3));

        AtomsProto.WifiDisconnectReported a0 =
                data.get(data.size() - 2).getAtom().getWifiDisconnectReported();
        AtomsProto.WifiConnectionResultReported a1 =
                data.get(data.size() - 1).getAtom().getWifiConnectionResultReported();

        assertThat(a0).isNotNull();
        assertThat(a1).isNotNull();

        assertThat(a0.getConnectedDurationSeconds()).isGreaterThan(0);
        int maxLinkSpeedMbps = 1_000_000; /* 640K ought to be enough for anybody. */
        assertThat(a0.getLastLinkSpeed()).isIn(Range.open(0, maxLinkSpeedMbps));
        assertThat(a0.getLastRssi()).isIn(Range.closed(-127, 0));

        assertThat(a1.getConnectionResult()).isTrue();
        assertThat(a1.getRssi()).isIn(Range.closed(-127, 0));
        assertThat(a1.getConnectionAttemptDurationMillis()).isIn(
                Range.open(0, WIFI_CONNECT_TIMEOUT_MILLIS));
        assertThat(a1.getTrigger()).isEqualTo(
                AtomsProto.WifiConnectionResultReported.Trigger.RECONNECT_SAME_NETWORK);
        assertThat(a1.getNetworkUsed()).isTrue();
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiScanLogsScanAtoms"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiScanLogsScanAtoms() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;

        ConfigUtils.uploadConfigForPushedAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_SCAN_REPORTED_FIELD_NUMBER);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiScan"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data).hasSize(2);

        AtomsProto.WifiScanReported a0 = data.get(0).getAtom().getWifiScanReported();
        AtomsProto.WifiScanReported a1 = data.get(1).getAtom().getWifiScanReported();

        for (AtomsProto.WifiScanReported a : new AtomsProto.WifiScanReported[]{a0, a1}) {
            assertThat(a.getResult()).isEqualTo(AtomsProto.WifiScanReported.Result.RESULT_SUCCESS);
            assertThat(a.getType()).isEqualTo(AtomsProto.WifiScanReported.Type.TYPE_SINGLE);
            assertThat(a.getSource()).isAnyOf(
                    // If this test is run on a device that has a Settings app open that
                    // continuously performs frequent scans, quite often our scans requests
                    // are bundled together and get attributed to the Settings app.
                    AtomsProto.WifiScanReported.Source.SOURCE_SETTINGS_APP,
                    AtomsProto.WifiScanReported.Source.SOURCE_OTHER_APP);
            assertThat(a.getImportance()).isEqualTo(
                    AtomsProto.WifiScanReported.Importance.IMPORTANCE_FOREGROUND_SERVICE);

            assertThat(a.getScanDurationMillis()).isGreaterThan(0);
        }
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiScanLogsStateChangedAtoms"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiScanLogsStateChangedAtoms() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;


        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_SCAN_STATE_CHANGED_FIELD_NUMBER,  true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiScan"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        final int stateOn = AtomsProto.WifiScanStateChanged.State.ON_VALUE;
        final int stateOff = AtomsProto.WifiScanStateChanged.State.OFF_VALUE;
        final int minTimeDiffMillis = 250;
        final int maxTimeDiffMillis = 60_000;

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isIn(Range.closed(2, 4));
        AtomTestUtils.assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMillis,
                maxTimeDiffMillis);
        AtomsProto.WifiScanStateChanged a0 = data.get(0).getAtom().getWifiScanStateChanged();
        AtomsProto.WifiScanStateChanged a1 = data.get(1).getAtom().getWifiScanStateChanged();
        assertThat(a0.getState().getNumber()).isEqualTo(stateOn);
        assertThat(a1.getState().getNumber()).isEqualTo(stateOff);
    }
}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.TestHelper"	"isEmpty"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/TestHelper.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.os.WorkSource;
import android.support.test.uiautomator.UiDevice;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Class to hold helper methods that are repeated across wifi CTS tests.
 */
public class TestHelper {
    private static final String TAG = ""WifiTestHelper"";

    private final Context mContext;
    private final WifiManager mWifiManager;
    private final ConnectivityManager mConnectivityManager;
    private final UiDevice mUiDevice;

    private static final int DURATION_MILLIS = 10_000;
    private static final int DURATION_NETWORK_CONNECTION_MILLIS = 40_000;
    private static final int DURATION_SCREEN_TOGGLE_MILLIS = 2000;
    private static final int DURATION_UI_INTERACTION_MILLIS = 25_000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    public TestHelper(@NonNull Context context, @NonNull UiDevice uiDevice) {
        mContext = context;
        mWifiManager = context.getSystemService(WifiManager.class);
        mConnectivityManager = context.getSystemService(ConnectivityManager.class);
        mUiDevice = uiDevice;
    }

    public void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    public void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    private static class TestScanResultsCallback extends WifiManager.ScanResultsCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;

        TestScanResultsCallback(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onScanResultsAvailable() {
            onAvailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Loops through all the saved networks available in the scan results. Returns a list of
     * WifiConfiguration with the matching bssid filled in {@link WifiConfiguration#BSSID}.
     *
     * Note:
     * a) If there are more than 2 networks with the same SSID, but different credential type, then
     * this matching may pick the wrong one.
     *
     * @param wifiManager WifiManager service
     * @param savedNetworks List of saved networks on the device.
     */
    public static List<WifiConfiguration> findMatchingSavedNetworksWithBssid(
            @NonNull WifiManager wifiManager, @NonNull List<WifiConfiguration> savedNetworks) {
        if (savedNetworks.isEmpty()) return Collections.emptyList();
        List<WifiConfiguration> matchingNetworksWithBssids = new ArrayList<>();
        CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 0; i < SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID; i++) {
            // Trigger a scan to get fresh scan results.
            TestScanResultsCallback scanResultsCallback =
                    new TestScanResultsCallback(countDownLatch);
            try {
                wifiManager.registerScanResultsCallback(
                        Executors.newSingleThreadExecutor(), scanResultsCallback);
                wifiManager.startScan(new WorkSource(myUid()));
                // now wait for callback
                countDownLatch.await(DURATION_MILLIS, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            } finally {
                wifiManager.unregisterScanResultsCallback(scanResultsCallback);
            }
            List<ScanResult> scanResults = wifiManager.getScanResults();
            if (scanResults == null || scanResults.isEmpty()) fail(""No scan results available"");
            for (ScanResult scanResult : scanResults) {
                WifiConfiguration matchingNetwork = savedNetworks.stream()
                        .filter(network -> TextUtils.equals(
                                scanResult.SSID, WifiInfo.sanitizeSsid(network.SSID)))
                        .findAny()
                        .orElse(null);
                if (matchingNetwork != null) {
                    // make a copy in case we have 2 bssid's for the same network.
                    WifiConfiguration matchingNetworkCopy = new WifiConfiguration(matchingNetwork);
                    matchingNetworkCopy.BSSID = scanResult.BSSID;
                    matchingNetworksWithBssids.add(matchingNetworkCopy);
                }
            }
            if (!matchingNetworksWithBssids.isEmpty()) break;
        }
        return matchingNetworksWithBssids;
    }

    /**
     * Convert the provided saved network to a corresponding suggestion builder.
     */
    public static WifiNetworkSuggestion.Builder
            createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        WifiNetworkSuggestion.Builder suggestionBuilder = new WifiNetworkSuggestion.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID))
                .setBssid(MacAddress.fromString(network.BSSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                suggestionBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                suggestionBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            suggestionBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        suggestionBuilder.setIsHiddenSsid(network.hiddenSSID);
        return suggestionBuilder;
    }


    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder createSpecifierBuilderWithCredentialFromSavedNetwork(
            @NonNull WifiConfiguration network) {
        WifiNetworkSpecifier.Builder specifierBuilder = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                specifierBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                specifierBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            specifierBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        specifierBuilder.setIsHiddenSsid(network.hiddenSSID);
        return specifierBuilder;
    }

    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder
            createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        return createSpecifierBuilderWithCredentialFromSavedNetwork(network)
                .setBssid(MacAddress.fromString(network.BSSID));
    }

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;
        public boolean onUnavailableCalled = false;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch, int flags) {
            super(flags);
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onAvailable(Network network) {
            onAvailableCalled = true;
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            this.networkCapabilities = networkCapabilities;
            mCountDownLatch.countDown();
        }

        @Override
        public void onUnavailable() {
            onUnavailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    private static TestNetworkCallback createTestNetworkCallback(
            @NonNull CountDownLatch countDownLatch) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // flags for NetworkCallback only introduced in S.
            return new TestNetworkCallback(countDownLatch, FLAG_INCLUDE_LOCATION_INFO);
        } else {
            return new TestNetworkCallback(countDownLatch);
        }
    }

    @NonNull
    private WifiInfo getWifiInfo(@NonNull NetworkCapabilities networkCapabilities) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // WifiInfo in transport info, only available in S.
            return (WifiInfo) networkCapabilities.getTransportInfo();
        } else {
            return mWifiManager.getConnectionInfo();
        }
    }

    private static void assertConnectionEquals(@NonNull WifiConfiguration network,
            @NonNull WifiInfo wifiInfo) {
        assertThat(network.SSID).isEqualTo(wifiInfo.getSSID());
        assertThat(network.BSSID).isEqualTo(wifiInfo.getBSSID());
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final CountDownLatch mCountDownLatch;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;

        TestActionListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onSuccess() {
            onSuccessCalled = true;
            mCountDownLatch.countDown();
        }

        @Override
        public void onFailure(int reason) {
            onFailedCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * WifiConfiguration, WifiManager.ActionListener)}
     *
     * @param network saved network from the device to use for the connection.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithConnect(
            @NonNull WifiConfiguration network) throws Exception {
        CountDownLatch countDownLatchAl = new CountDownLatch(1);
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestActionListener actionListener = new TestActionListener(countDownLatchAl);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // File a callback for wifi network.
            mConnectivityManager.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            // Needed to ensure that the restricted concurrent connection does not
                            // match this request.
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE)
                            .build(),
                    testNetworkCallback);
            // Trigger the connection.
            mWifiManager.connect(network, actionListener);
            // now wait for action listener callback
            assertThat(countDownLatchAl.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            // check if we got the success callback
            assertThat(actionListener.onSuccessCalled).isTrue();

            // Wait for connection to complete & ensure we are connected to the saved network.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
            final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
            assertConnectionEquals(network, wifiInfo);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // User connections should always be primary.
                assertThat(wifiInfo.isPrimary()).isTrue();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            // Unregister the network callback in case of any failure (since we don't end up
            // returning the network callback to the caller).
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionWithShellIdentity(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        return testConnectionFlowWithSuggestionInternal(
                network, suggestion, executorService, restrictedNetworkCapabilities, true);
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionWithShellIdentity(
                    network, suggestion, executorService, restrictedNetworkCapabilities);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the connection failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFailureFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionInternal(
                    network, suggestion, executorService, restrictedNetworkCapabilities, false);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the entire connection success/failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     * @param expectConnectionSuccess Whether to expect connection success or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    private ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionInternal(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities,
            boolean expectConnectionSuccess) throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);
        try {
            // File a request for restricted (oem paid) wifi network.
            NetworkRequest.Builder nrBuilder = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (restrictedNetworkCapabilities.isEmpty()) {
                // If not a restricted connection, a network callback is sufficient.
                mConnectivityManager.registerNetworkCallback(
                        nrBuilder.build(), testNetworkCallback);
            } else {
                for (Integer restrictedNetworkCapability : restrictedNetworkCapabilities) {
                    nrBuilder.addCapability(restrictedNetworkCapability);
                }
                mConnectivityManager.requestNetwork(nrBuilder.build(), testNetworkCallback);
            }
            // Add wifi network suggestion.
            assertThat(mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)))
                    .isEqualTo(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS);
            // Wait for the request to reach the wifi stack before kick-start periodic scans.
            Thread.sleep(100);
            // Step: Trigger scans periodically to trigger network selection quicker.
            executorService.scheduleAtFixedRate(() -> {
                if (!mWifiManager.startScan()) {
                    Log.w(TAG, ""Failed to trigger scan"");
                }
            }, 0, DURATION_MILLIS, TimeUnit.MILLISECONDS);
            if (expectConnectionSuccess) {
                // now wait for connection to complete and wait for callback
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
                    assertThat(wifiInfo.isTrusted()).isTrue();
                    WifiInfo redact = wifiInfo
                            .makeCopy(NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION);
                    assertThat(wifiInfo.getInformationElements()).isNotNull();
                    assertThat(redact.getInformationElements()).isNull();
                    assertThat(redact.getApplicableRedactions()).isEqualTo(
                            NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION
                            | NetworkCapabilities.REDACT_FOR_LOCAL_MAC_ADDRESS
                            | NetworkCapabilities.REDACT_FOR_NETWORK_SETTINGS);
                }
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for restricted connection is supported, this should not
                    // be the primary connection.
                    if (!restrictedNetworkCapabilities.isEmpty()
                            && mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            } else {
                // now wait for connection to timeout.
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isFalse();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            executorService.shutdown();
        }
        return testNetworkCallback;
    }

    private static class TestNetworkRequestMatchCallback implements
            WifiManager.NetworkRequestMatchCallback {
        private final Object mLock;

        public boolean onRegistrationCalled = false;
        public boolean onAbortCalled = false;
        public boolean onMatchCalled = false;
        public boolean onConnectSuccessCalled = false;
        public boolean onConnectFailureCalled = false;
        public WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback = null;
        public List<ScanResult> matchedScanResults = null;

        TestNetworkRequestMatchCallback(Object lock) {
            mLock = lock;
        }

        @Override
        public void onUserSelectionCallbackRegistration(
                WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback) {
            synchronized (mLock) {
                onRegistrationCalled = true;
                this.userSelectionCallback = userSelectionCallback;
                mLock.notify();
            }
        }

        @Override
        public void onAbort() {
            synchronized (mLock) {
                onAbortCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onMatch(List<ScanResult> scanResults) {
            synchronized (mLock) {
                // This can be invoked multiple times. So, ignore after the first one to avoid
                // disturbing the rest of the test sequence.
                if (onMatchCalled) return;
                onMatchCalled = true;
                matchedScanResults = scanResults;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectSuccess(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectFailure(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectFailureCalled = true;
                mLock.notify();
            }
        }
    }

    private void handleUiInteractions(WifiConfiguration network, boolean shouldUserReject) {
        // can't use CountDownLatch since there are many callbacks expected and CountDownLatch
        // cannot be reset.
        // TODO(b/177591382): Use ArrayBlockingQueue/LinkedBlockingQueue
        Object uiLock = new Object();
        TestNetworkRequestMatchCallback networkRequestMatchCallback =
                new TestNetworkRequestMatchCallback(uiLock);
        try {
            // 1. Wait for registration callback.
            synchronized (uiLock) {
                try {
                    mWifiManager.registerNetworkRequestMatchCallback(
                            Executors.newSingleThreadExecutor(), networkRequestMatchCallback);
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            assertThat(networkRequestMatchCallback.onRegistrationCalled).isTrue();
            assertThat(networkRequestMatchCallback.userSelectionCallback).isNotNull();

            // 2. Wait for matching scan results
            synchronized (uiLock) {
                if (!networkRequestMatchCallback.onMatchCalled) {
                    try {
                        uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                    } catch (InterruptedException e) {
                    }
                }
            }
            assertThat(networkRequestMatchCallback.onMatchCalled).isTrue();
            assertThat(networkRequestMatchCallback.matchedScanResults).isNotNull();
            assertThat(networkRequestMatchCallback.matchedScanResults.size()).isAtLeast(1);

            // 3. Trigger connection to one of the matched networks or reject the request.
            if (shouldUserReject) {
                networkRequestMatchCallback.userSelectionCallback.reject();
            } else {
                networkRequestMatchCallback.userSelectionCallback.select(network);
            }

            // 4. Wait for connection success or abort.
            synchronized (uiLock) {
                try {
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            if (shouldUserReject) {
                assertThat(networkRequestMatchCallback.onAbortCalled).isTrue();
            } else {
                assertThat(networkRequestMatchCallback.onConnectSuccessCalled).isTrue();
            }
        } finally {
            mWifiManager.unregisterNetworkRequestMatchCallback(networkRequestMatchCallback);
        }
    }

    /**
     * Tests the entire connection flow using the provided specifier,
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifierWithShellIdentity(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);

        // Fork a thread to handle the UI interactions.
        Thread uiThread = new Thread(() -> {
            try {
                handleUiInteractions(network, shouldUserReject);
            } catch (Throwable e /* catch assertions & exceptions */) {
                try {
                    mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
                } catch (IllegalArgumentException ie) { }
                throw e;
            }
        });

        try {
            // File a request for wifi network.
            mConnectivityManager.requestNetwork(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            .setNetworkSpecifier(specifier)
                            .build(),
                    testNetworkCallback);
            // Wait for the request to reach the wifi stack before kick-starting the UI
            // interactions.
            Thread.sleep(1_000);
            // Start the UI interactions.
            uiThread.run();
            // now wait for callback
            assertThat(countDownLatch.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            if (shouldUserReject) {
                assertThat(testNetworkCallback.onUnavailableCalled).isTrue();
            } else {
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for local only connection is supported, this should not
                    // be the primary connection.
                    if (mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        }
        try {
            // Ensure that the UI interaction thread has completed.
            uiThread.join(DURATION_UI_INTERACTION_MILLIS);
        } catch (InterruptedException e) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            fail(""UI interaction interrupted"");
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection flow using the provided specifier.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS);
            return testConnectionFlowWithSpecifierWithShellIdentity(
                    network, specifier, shouldUserReject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Returns the number of wifi connections visible at the networking layer.
     */
    public long getNumWifiConnections() {
        Network[] networks = mConnectivityManager.getAllNetworks();
        return Arrays.stream(networks)
                .filter(n ->
                        mConnectivityManager.getNetworkCapabilities(n).hasTransport(TRANSPORT_WIFI))
                .count();
    }

    /**
     * Registers a network callback for internet connectivity via wifi and asserts that a network
     * is available within {@link #DURATION_NETWORK_CONNECTION_MILLIS}.
     *
     * @throws Exception
     */
    public void assertWifiInternetConnectionAvailable() throws Exception {
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        try {
            // File a callback for wifi network.
            NetworkRequest.Builder builder = new NetworkRequest.Builder()
                    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // Needed to ensure that the restricted concurrent connection does not
                // match this request.
                builder.addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                        .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE);
            }
            mConnectivityManager.registerNetworkCallback(builder.build(), testNetworkCallback);
            // Wait for connection to complete & ensure we are connected to some network capable
            // of providing internet access.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
        } finally {
            mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
        }
    }

    public static int getBandFromFrequency(final int freqMHz) {
        if (freqMHz < 1000) {
            return ScanResult.UNSPECIFIED;
        } else if (freqMHz < 4000) { // getFrequency is in WifiInfo.FREQUENCY_UNITS = MHz
            return ScanResult.WIFI_BAND_24_GHZ;
        } else if (freqMHz < 5900) {
            // 5GHz band stops at 5885MHz, 6GHz band starts at 5955. See android.net.wifi.ScanResult
            return ScanResult.WIFI_BAND_5_GHZ;
        } else if (freqMHz < 10_000) {
            return ScanResult.WIFI_BAND_6_GHZ;
        } else if (freqMHz < 71_000) {
            // 60 GHz band stops at 70_200
            return ScanResult.WIFI_BAND_60_GHZ;
        } else {
            return ScanResult.UNSPECIFIED;
        }
    }

}"	""	""	"flag"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.PnoSettingsTest"	"createTestNetworks"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/PnoSettingsTest.java"	""	"/*
 *.
 */

package android.net.wifi.nl80211.cts;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.net.wifi.cts.WifiFeature;
import android.net.wifi.nl80211.PnoNetwork;
import android.net.wifi.nl80211.PnoSettings;
import android.os.Parcel;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Arrays;
import java.util.List;

/** CTS tests for {@link PnoSettings}. */
@SmallTest
@RunWith(AndroidJUnit4.class)
public class PnoSettingsTest {

    private static List<PnoNetwork> createTestNetworks() {
        PnoNetwork network1 = new PnoNetwork();
        network1.setSsid(new byte[] { 's', 's', 'i', 'd' });
        network1.setFrequenciesMhz(new int[] { 2412, 2417, 5035 });
        network1.setHidden(true);

        PnoNetwork network2 = new PnoNetwork();
        network2.setSsid(new byte[] { 'a', 's', 'd', 'f' });
        network2.setFrequenciesMhz(new int[] { 2422, 2427, 5040 });
        network2.setHidden(false);

        return Arrays.asList(network1, network2);
    }

    @Before
    public void setUp() {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip tests if Wifi is not supported
        assumeTrue(WifiFeature.isWifiSupported(context));
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiEnterpriseConfig.Eap.AKA;
import static android.net.wifi.WifiEnterpriseConfig.Eap.WAPI_CERT;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class WifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiNetworkSuggestionTest"";

    private static final String TEST_SSID = ""testSsid"";
    private static final String TEST_BSSID = ""00:df:aa:bc:12:23"";
    private static final String TEST_PASSPHRASE = ""testPassword"";
    private static final int TEST_PRIORITY = 5;
    private static final int TEST_PRIORITY_GROUP = 1;
    private static final int TEST_SUB_ID = 1;

    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private static Context sContext;
    private static WifiManager sWifiManager;
    private static ConnectivityManager sConnectivityManager;
    private static UiDevice sUiDevice;
    private static WifiConfiguration sTestNetwork;
    private static ConnectivityManager.NetworkCallback sNsNetworkCallback;
    private static TestHelper sTestHelper;

    private ScheduledExecutorService mExecutorService;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        sContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(sContext)) return;
        // skip the test if location is not supported
        if (!sContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION)) return;
        // skip if the location is disabled
        if (!sContext.getSystemService(LocationManager.class).isLocationEnabled()) return;

        sWifiManager = sContext.getSystemService(WifiManager.class);
        assertThat(sWifiManager).isNotNull();
        sConnectivityManager = sContext.getSystemService(ConnectivityManager.class);
        sUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        sTestHelper = new TestHelper(sContext, sUiDevice);

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isWifiEnabled());
        if (!sWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> sWifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> sWifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.getPrivilegedConfiguredNetworks());
        if (savedNetworks.isEmpty()) {
            return;
        }
        // Pick any network in range.

        List<WifiConfiguration> networks = TestHelper.findMatchingSavedNetworksWithBssid(
                sWifiManager, savedNetworks);
        if (!networks.isEmpty()) {
            sTestNetwork = networks.get(0);
        }

        // Disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        sWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                });
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if (!WifiFeature.isWifiSupported(sContext)) return;

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setWifiEnabled(sWasWifiEnabled));

        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : sWifiManager.getConfiguredNetworks()) {
                        sWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
    }

    @Before
    public void setUp() throws Exception {
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        // turn screen on
        sTestHelper.turnScreenOn();

        // Disconnect current network if any.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.disconnect());

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> sWifiManager.getConnectionInfo().getNetworkId() == -1);

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> sWifiManager.removeAppState(myUid(), sContext.getPackageName()));
        }
    }

    @After
    public void tearDown() throws Exception {
        // Release the requests after the test.
        if (sNsNetworkCallback != null) {
            sConnectivityManager.unregisterNetworkCallback(sNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> sWifiManager.removeAppState(myUid(), sContext.getPackageName()));
        }
        sTestHelper.turnScreenOff();
    }

    private static final String CA_SUITE_B_RSA3072_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIEnTCCAwWgAwIBAgIUD87Y8fFLzLr1HQ/64aEnjNq2R/4wDQYJKoZIhvcNAQEM\n""
                    + ""BQAwXjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAO\n""
                    + ""BgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0\n""
                    + ""Q0EwHhcNMjAwNzIxMDIxNzU0WhcNMzAwNTMwMDIxNzU0WjBeMQswCQYDVQQGEwJV\n""
                    + ""UzELMAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEO\n""
                    + ""MAwGA1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTCCAaIwDQYJKoZIhvcN\n""
                    + ""AQEBBQADggGPADCCAYoCggGBAMtrsT0otlxh0QS079KpRRbU1PQjCihSoltXnrxF\n""
                    + ""sTWZs2weVEeYVyYU5LaauCDDgISCMtjtfbfylMBeYjpWB5hYzYQOiTzo0anWhMyb\n""
                    + ""Ngb7gpMVZuIl6lwMYRyVRKwHWnTo2EUg1ZzW5rGe5fs/KHj6//hoNFm+3Oju0TQd\n""
                    + ""nraQULpoERPF5B7p85Cssk8uNbviBfZXvtCuJ4N6w7PNceOY/9bbwc1mC+pPZmzV\n""
                    + ""SOAg0vvbIQRzChm63C3jBC3xmxSOOZVrKN4zKDG2s8P0oCNGt0NlgRMrgbPRekzg\n""
                    + ""4avkbA0vTuc2AyriTEYkdea/Mt4EpRg9XuOb43U/GJ/d/vQv2/9fsxhXmsZrn8kr\n""
                    + ""Qo5MMHJFUd96GgHmvYSU3Mf/5r8gF626lvqHioGuTAuHUSnr02ri1WUxZ15LDRgY\n""
                    + ""quMjDCFZfucjJPDAdtiHcFSej/4SLJlN39z8oKKNPn3aL9Gv49oAKs9S8tfDVzMk\n""
                    + ""fDLROQFHFuW715GnnMgEAoOpRwIDAQABo1MwUTAdBgNVHQ4EFgQUeVuGmSVN4ARs\n""
                    + ""mesUMWSJ2qWLbxUwHwYDVR0jBBgwFoAUeVuGmSVN4ARsmesUMWSJ2qWLbxUwDwYD\n""
                    + ""VR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQwFAAOCAYEAit1Lo/hegZpPuT9dlWZJ\n""
                    + ""bC8JvAf95O8lnn6LFb69pgYOHCLgCIlvYXu9rdBUJgZo+V1MzJJljiO6RxWRfKbQ\n""
                    + ""8WBYkoqR1EqriR3Kn8q/SjIZCdFSaznTyU1wQMveBQ6RJWXSUhYVfE9RjyFTp7B4\n""
                    + ""UyH2uCluR/0T06HQNGfH5XpIYQqCk1Zgng5lmEmheLDPoJpa92lKeQFJMC6eYz9g\n""
                    + ""lF1GHxPxkPfbMJ6ZDp5X6Yopu6Q6uEXhVKM/iQVcgzRkx9rid+xTYl+nOKyK/XfC\n""
                    + ""z8P0/TFIoPTW02DLge5wKagdoCpy1B7HdrAXyUjoH4B8MsUkq3kYPFSjPzScuTtV\n""
                    + ""kUuDw5ipCNeXCRnhbYqRDk6PX5GUu2cmN9jtaH3tbgm3fKNOsd/BO1fLIl7qjXlR\n""
                    + ""27HHbC0JXjNvlm2DLp23v4NTxS7WZGYsxyUj5DZrxBxqCsTXu/01w1BrQKWKh9FM\n""
                    + ""aVrlA8omfVODK2CSuw+KhEMHepRv/AUgsLl4L4+RMoa+\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CA_SUITE_B_RSA3072_CERT =
            loadCertificate(CA_SUITE_B_RSA3072_CERT_STRING);

    private static final String CA_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIICTzCCAdSgAwIBAgIUdnLttwNPnQzFufplGOr9bTrGCqMwCgYIKoZIzj0EAwMw\n""
                    + ""XjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNV\n""
                    + ""BAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0Q0Ew\n""
                    + ""HhcNMjAwNzIxMDIyNDA1WhcNMzAwNTMwMDIyNDA1WjBeMQswCQYDVQQGEwJVUzEL\n""
                    + ""MAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEOMAwG\n""
                    + ""A1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTB2MBAGByqGSM49AgEGBSuB\n""
                    + ""BAAiA2IABFmntXwk9icqhDQFUP1xy04WyEpaGW4q6Q+8pujlSl/X3iotPZ++GZfp\n""
                    + ""Mfv3YDHDBl6sELPQ2BEjyPXmpsKjOUdiUe69e88oGEdeqT2xXiQ6uzpTfJD4170i\n""
                    + ""O/TwLrQGKKNTMFEwHQYDVR0OBBYEFCjptsX3g4g5W0L4oEP6N3gfyiZXMB8GA1Ud\n""
                    + ""IwQYMBaAFCjptsX3g4g5W0L4oEP6N3gfyiZXMA8GA1UdEwEB/wQFMAMBAf8wCgYI\n""
                    + ""KoZIzj0EAwMDaQAwZgIxAK61brUYRbLmQKiaEboZgrHtnPAcGo7Yzx3MwHecx3Dm\n""
                    + ""5soIeLVYc8bPYN1pbhXW1gIxALdEe2sh03nBHyQH4adYoZungoCwt8mp/7sJFxou\n""
                    + ""9UnRegyBgGzf74ROWdpZHzh+Pg==\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CA_SUITE_B_ECDSA_CERT =
            loadCertificate(CA_SUITE_B_ECDSA_CERT_STRING);

    private static final String CLIENT_SUITE_B_RSA3072_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIERzCCAq8CFDopjyNgaj+c2TN2k06h7okEWpHJMA0GCSqGSIb3DQEBDAUAMF4x\n""
                    + ""CzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQK\n""
                    + ""DAdBbmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4X\n""
                    + ""DTIwMDcyMTAyMjkxMVoXDTMwMDUzMDAyMjkxMVowYjELMAkGA1UEBhMCVVMxCzAJ\n""
                    + ""BgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNV\n""
                    + ""BAsMBVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MIIBojANBgkqhkiG9w0B\n""
                    + ""AQEFAAOCAY8AMIIBigKCAYEAwSK3C5K5udtCKTnE14e8z2cZvwmB4Xe+a8+7QLud\n""
                    + ""Hooc/lQzClgK4MbVUC0D3FE+U32C78SxKoTaRWtvPmNm+UaFT8KkwyUno/dv+2XD\n""
                    + ""pd/zARQ+3FwAfWopAhEyCVSxwsCa+slQ4juRIMIuUC1Mm0NaptZyM3Tj/ICQEfpk\n""
                    + ""o9qVIbiK6eoJMTkY8EWfAn7RTFdfR1OLuO0mVOjgLW9/+upYv6hZ19nAMAxw4QTJ\n""
                    + ""x7lLwALX7B+tDYNEZHDqYL2zyvQWAj2HClere8QYILxkvktgBg2crEJJe4XbDH7L\n""
                    + ""A3rrXmsiqf1ZbfFFEzK9NFqovL+qGh+zIP+588ShJFO9H/RDnDpiTnAFTWXQdTwg\n""
                    + ""szSS0Vw2PB+JqEABAa9DeMvXT1Oy+NY3ItPHyy63nQZVI2rXANw4NhwS0Z6DF+Qs\n""
                    + ""TNrj+GU7e4SG/EGR8SvldjYfQTWFLg1l/UT1hOOkQZwdsaW1zgKyeuiFB2KdMmbA\n""
                    + ""Sq+Ux1L1KICo0IglwWcB/8nnAgMBAAEwDQYJKoZIhvcNAQEMBQADggGBAMYwJkNw\n""
                    + ""BaCviKFmReDTMwWPRy4AMNViEeqAXgERwDEKwM7efjsaj5gctWfKsxX6UdLzkhgg\n""
                    + ""6S/T6PxVWKzJ6l7SoOuTa6tMQOZp+h3R1mdfEQbw8B5cXBxZ+batzAai6Fiy1FKS\n""
                    + ""/ka3INbcGfYuIYghfTrb4/NJKN06ZaQ1bpPwq0e4gN7800T2nbawvSf7r+8ZLcG3\n""
                    + ""6bGCjRMwDSIipNvOwoj3TG315XC7TccX5difQ4sKOY+d2MkVJ3RiO0Ciw2ZbEW8d\n""
                    + ""1FH5vUQJWnBUfSFznosGzLwH3iWfqlP+27jNE+qB2igEwCRFgVAouURx5ou43xuX\n""
                    + ""qf6JkdI3HTJGLIWxkp7gOeln4dEaYzKjYw+P0VqJvKVqQ0IXiLjHgE0J9p0vgyD6\n""
                    + ""HVVcP7U8RgqrbIjL1QgHU4KBhGi+WSUh/mRplUCNvHgcYdcHi/gHpj/j6ubwqIGV\n""
                    + ""z4iSolAHYTmBWcLyE0NgpzE6ntp+53r2KaUJA99l2iGVzbWTwqPSm0XAVw==\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CLIENT_SUITE_B_RSA3072_CERT =
            loadCertificate(CLIENT_SUITE_B_RSA3072_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_RSA3072_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x82, (byte) 0x06, (byte) 0xfe, (byte) 0x02, (byte) 0x01,
            (byte) 0x00, (byte) 0x30, (byte) 0x0d, (byte) 0x06, (byte) 0x09, (byte) 0x2a,
            (byte) 0x86, (byte) 0x48, (byte) 0x86, (byte) 0xf7, (byte) 0x0d, (byte) 0x01,
            (byte) 0x01, (byte) 0x01, (byte) 0x05, (byte) 0x00, (byte) 0x04, (byte) 0x82,
            (byte) 0x06, (byte) 0xe8, (byte) 0x30, (byte) 0x82, (byte) 0x06, (byte) 0xe4,
            (byte) 0x02, (byte) 0x01, (byte) 0x00, (byte) 0x02, (byte) 0x82, (byte) 0x01,
            (byte) 0x81, (byte) 0x00, (byte) 0xc1, (byte) 0x22, (byte) 0xb7, (byte) 0x0b,
            (byte) 0x92, (byte) 0xb9, (byte) 0xb9, (byte) 0xdb, (byte) 0x42, (byte) 0x29,
            (byte) 0x39, (byte) 0xc4, (byte) 0xd7, (byte) 0x87, (byte) 0xbc, (byte) 0xcf,
            (byte) 0x67, (byte) 0x19, (byte) 0xbf, (byte) 0x09, (byte) 0x81, (byte) 0xe1,
            (byte) 0x77, (byte) 0xbe, (byte) 0x6b, (byte) 0xcf, (byte) 0xbb, (byte) 0x40,
            (byte) 0xbb, (byte) 0x9d, (byte) 0x1e, (byte) 0x8a, (byte) 0x1c, (byte) 0xfe,
            (byte) 0x54, (byte) 0x33, (byte) 0x0a, (byte) 0x58, (byte) 0x0a, (byte) 0xe0,
            (byte) 0xc6, (byte) 0xd5, (byte) 0x50, (byte) 0x2d, (byte) 0x03, (byte) 0xdc,
            (byte) 0x51, (byte) 0x3e, (byte) 0x53, (byte) 0x7d, (byte) 0x82, (byte) 0xef,
            (byte) 0xc4, (byte) 0xb1, (byte) 0x2a, (byte) 0x84, (byte) 0xda, (byte) 0x45,
            (byte) 0x6b, (byte) 0x6f, (byte) 0x3e, (byte) 0x63, (byte) 0x66, (byte) 0xf9,
            (byte) 0x46, (byte) 0x85, (byte) 0x4f, (byte) 0xc2, (byte) 0xa4, (byte) 0xc3,
            (byte) 0x25, (byte) 0x27, (byte) 0xa3, (byte) 0xf7, (byte) 0x6f, (byte) 0xfb,
            (byte) 0x65, (byte) 0xc3, (byte) 0xa5, (byte) 0xdf, (byte) 0xf3, (byte) 0x01,
            (byte) 0x14, (byte) 0x3e, (byte) 0xdc, (byte) 0x5c, (byte) 0x00, (byte) 0x7d,
            (byte) 0x6a, (byte) 0x29, (byte) 0x02, (byte) 0x11, (byte) 0x32, (byte) 0x09,
            (byte) 0x54, (byte) 0xb1, (byte) 0xc2, (byte) 0xc0, (byte) 0x9a, (byte) 0xfa,
            (byte) 0xc9, (byte) 0x50, (byte) 0xe2, (byte) 0x3b, (byte) 0x91, (byte) 0x20,
            (byte) 0xc2, (byte) 0x2e, (byte) 0x50, (byte) 0x2d, (byte) 0x4c, (byte) 0x9b,
            (byte) 0x43, (byte) 0x5a, (byte) 0xa6, (byte) 0xd6, (byte) 0x72, (byte) 0x33,
            (byte) 0x74, (byte) 0xe3, (byte) 0xfc, (byte) 0x80, (byte) 0x90, (byte) 0x11,
            (byte) 0xfa, (byte) 0x64, (byte) 0xa3, (byte) 0xda, (byte) 0x95, (byte) 0x21,
            (byte) 0xb8, (byte) 0x8a, (byte) 0xe9, (byte) 0xea, (byte) 0x09, (byte) 0x31,
            (byte) 0x39, (byte) 0x18, (byte) 0xf0, (byte) 0x45, (byte) 0x9f, (byte) 0x02,
            (byte) 0x7e, (byte) 0xd1, (byte) 0x4c, (byte) 0x57, (byte) 0x5f, (byte) 0x47,
            (byte) 0x53, (byte) 0x8b, (byte) 0xb8, (byte) 0xed, (byte) 0x26, (byte) 0x54,
            (byte) 0xe8, (byte) 0xe0, (byte) 0x2d, (byte) 0x6f, (byte) 0x7f, (byte) 0xfa,
            (byte) 0xea, (byte) 0x58, (byte) 0xbf, (byte) 0xa8, (byte) 0x59, (byte) 0xd7,
            (byte) 0xd9, (byte) 0xc0, (byte) 0x30, (byte) 0x0c, (byte) 0x70, (byte) 0xe1,
            (byte) 0x04, (byte) 0xc9, (byte) 0xc7, (byte) 0xb9, (byte) 0x4b, (byte) 0xc0,
            (byte) 0x02, (byte) 0xd7, (byte) 0xec, (byte) 0x1f, (byte) 0xad, (byte) 0x0d,
            (byte) 0x83, (byte) 0x44, (byte) 0x64, (byte) 0x70, (byte) 0xea, (byte) 0x60,
            (byte) 0xbd, (byte) 0xb3, (byte) 0xca, (byte) 0xf4, (byte) 0x16, (byte) 0x02,
            (byte) 0x3d, (byte) 0x87, (byte) 0x0a, (byte) 0x57, (byte) 0xab, (byte) 0x7b,
            (byte) 0xc4, (byte) 0x18, (byte) 0x20, (byte) 0xbc, (byte) 0x64, (byte) 0xbe,
            (byte) 0x4b, (byte) 0x60, (byte) 0x06, (byte) 0x0d, (byte) 0x9c, (byte) 0xac,
            (byte) 0x42, (byte) 0x49, (byte) 0x7b, (byte) 0x85, (byte) 0xdb, (byte) 0x0c,
            (byte) 0x7e, (byte) 0xcb, (byte) 0x03, (byte) 0x7a, (byte) 0xeb, (byte) 0x5e,
            (byte) 0x6b, (byte) 0x22, (byte) 0xa9, (byte) 0xfd, (byte) 0x59, (byte) 0x6d,
            (byte) 0xf1, (byte) 0x45, (byte) 0x13, (byte) 0x32, (byte) 0xbd, (byte) 0x34,
            (byte) 0x5a, (byte) 0xa8, (byte) 0xbc, (byte) 0xbf, (byte) 0xaa, (byte) 0x1a,
            (byte) 0x1f, (byte) 0xb3, (byte) 0x20, (byte) 0xff, (byte) 0xb9, (byte) 0xf3,
            (byte) 0xc4, (byte) 0xa1, (byte) 0x24, (byte) 0x53, (byte) 0xbd, (byte) 0x1f,
            (byte) 0xf4, (byte) 0x43, (byte) 0x9c, (byte) 0x3a, (byte) 0x62, (byte) 0x4e,
            (byte) 0x70, (byte) 0x05, (byte) 0x4d, (byte) 0x65, (byte) 0xd0, (byte) 0x75,
            (byte) 0x3c, (byte) 0x20, (byte) 0xb3, (byte) 0x34, (byte) 0x92, (byte) 0xd1,
            (byte) 0x5c, (byte) 0x36, (byte) 0x3c, (byte) 0x1f, (byte) 0x89, (byte) 0xa8,
            (byte) 0x40, (byte) 0x01, (byte) 0x01, (byte) 0xaf, (byte) 0x43, (byte) 0x78,
            (byte) 0xcb, (byte) 0xd7, (byte) 0x4f, (byte) 0x53, (byte) 0xb2, (byte) 0xf8,
            (byte) 0xd6, (byte) 0x37, (byte) 0x22, (byte) 0xd3, (byte) 0xc7, (byte) 0xcb,
            (byte) 0x2e, (byte) 0xb7, (byte) 0x9d, (byte) 0x06, (byte) 0x55, (byte) 0x23,
            (byte) 0x6a, (byte) 0xd7, (byte) 0x00, (byte) 0xdc, (byte) 0x38, (byte) 0x36,
            (byte) 0x1c, (byte) 0x12, (byte) 0xd1, (byte) 0x9e, (byte) 0x83, (byte) 0x17,
            (byte) 0xe4, (byte) 0x2c, (byte) 0x4c, (byte) 0xda, (byte) 0xe3, (byte) 0xf8,
            (byte) 0x65, (byte) 0x3b, (byte) 0x7b, (byte) 0x84, (byte) 0x86, (byte) 0xfc,
            (byte) 0x41, (byte) 0x91, (byte) 0xf1, (byte) 0x2b, (byte) 0xe5, (byte) 0x76,
            (byte) 0x36, (byte) 0x1f, (byte) 0x41, (byte) 0x35, (byte) 0x85, (byte) 0x2e,
            (byte) 0x0d, (byte) 0x65, (byte) 0xfd, (byte) 0x44, (byte) 0xf5, (byte) 0x84,
            (byte) 0xe3, (byte) 0xa4, (byte) 0x41, (byte) 0x9c, (byte) 0x1d, (byte) 0xb1,
            (byte) 0xa5, (byte) 0xb5, (byte) 0xce, (byte) 0x02, (byte) 0xb2, (byte) 0x7a,
            (byte) 0xe8, (byte) 0x85, (byte) 0x07, (byte) 0x62, (byte) 0x9d, (byte) 0x32,
            (byte) 0x66, (byte) 0xc0, (byte) 0x4a, (byte) 0xaf, (byte) 0x94, (byte) 0xc7,
            (byte) 0x52, (byte) 0xf5, (byte) 0x28, (byte) 0x80, (byte) 0xa8, (byte) 0xd0,
            (byte) 0x88, (byte) 0x25, (byte) 0xc1, (byte) 0x67, (byte) 0x01, (byte) 0xff,
            (byte) 0xc9, (byte) 0xe7, (byte) 0x02, (byte) 0x03, (byte) 0x01, (byte) 0x00,
            (byte) 0x01, (byte) 0x02, (byte) 0x82, (byte) 0x01, (byte) 0x80, (byte) 0x04,
            (byte) 0xb1, (byte) 0xcc, (byte) 0x53, (byte) 0x3a, (byte) 0xb0, (byte) 0xcb,
            (byte) 0x04, (byte) 0xba, (byte) 0x59, (byte) 0xf8, (byte) 0x2e, (byte) 0x81,
            (byte) 0xb2, (byte) 0xa9, (byte) 0xf3, (byte) 0x3c, (byte) 0xa5, (byte) 0x52,
            (byte) 0x90, (byte) 0x6f, (byte) 0x98, (byte) 0xc4, (byte) 0x69, (byte) 0x5b,
            (byte) 0x83, (byte) 0x84, (byte) 0x20, (byte) 0xb1, (byte) 0xae, (byte) 0xc3,
            (byte) 0x04, (byte) 0x46, (byte) 0x6a, (byte) 0x24, (byte) 0x2f, (byte) 0xcd,
            (byte) 0x6b, (byte) 0x90, (byte) 0x70, (byte) 0x20, (byte) 0x45, (byte) 0x25,
            (byte) 0x1a, (byte) 0xc3, (byte) 0x02, (byte) 0x42, (byte) 0xf3, (byte) 0x49,
            (byte) 0xe2, (byte) 0x3e, (byte) 0x21, (byte) 0x87, (byte) 0xdd, (byte) 0x6a,
            (byte) 0x94, (byte) 0x2a, (byte) 0x1e, (byte) 0x0f, (byte) 0xdb, (byte) 0x77,
            (byte) 0x5f, (byte) 0xc1, (byte) 0x2c, (byte) 0x03, (byte) 0xfb, (byte) 0xcf,
            (byte) 0x91, (byte) 0x82, (byte) 0xa1, (byte) 0xbf, (byte) 0xb0, (byte) 0x73,
            (byte) 0xfa, (byte) 0xda, (byte) 0xbc, (byte) 0xf8, (byte) 0x9f, (byte) 0x45,
            (byte) 0xd3, (byte) 0xe8, (byte) 0xbb, (byte) 0x38, (byte) 0xfb, (byte) 0xc2,
            (byte) 0x2d, (byte) 0x76, (byte) 0x51, (byte) 0x96, (byte) 0x18, (byte) 0x03,
            (byte) 0x15, (byte) 0xd9, (byte) 0xea, (byte) 0x82, (byte) 0x25, (byte) 0x83,
            (byte) 0xff, (byte) 0x5c, (byte) 0x85, (byte) 0x06, (byte) 0x09, (byte) 0xb2,
            (byte) 0x46, (byte) 0x12, (byte) 0x64, (byte) 0x02, (byte) 0x74, (byte) 0x4f,
            (byte) 0xbc, (byte) 0x9a, (byte) 0x25, (byte) 0x18, (byte) 0x01, (byte) 0x07,
            (byte) 0x17, (byte) 0x25, (byte) 0x55, (byte) 0x7c, (byte) 0xdc, (byte) 0xe1,
            (byte) 0xd1, (byte) 0x5a, (byte) 0x2f, (byte) 0x25, (byte) 0xaf, (byte) 0xf6,
            (byte) 0x8f, (byte) 0xa4, (byte) 0x9a, (byte) 0x5a, (byte) 0x3a, (byte) 0xfe,
            (byte) 0x2e, (byte) 0x93, (byte) 0x24, (byte) 0xa0, (byte) 0x27, (byte) 0xac,
            (byte) 0x07, (byte) 0x75, (byte) 0x33, (byte) 0x01, (byte) 0x54, (byte) 0x23,
            (byte) 0x0f, (byte) 0xe8, (byte) 0x9f, (byte) 0xfa, (byte) 0x36, (byte) 0xe6,
            (byte) 0x3a, (byte) 0xd5, (byte) 0x78, (byte) 0xb0, (byte) 0xe4, (byte) 0x6a,
            (byte) 0x16, (byte) 0x50, (byte) 0xbd, (byte) 0x0f, (byte) 0x9f, (byte) 0x32,
            (byte) 0xa1, (byte) 0x6b, (byte) 0xf5, (byte) 0xa4, (byte) 0x34, (byte) 0x58,
            (byte) 0xb6, (byte) 0xa4, (byte) 0xb3, (byte) 0xc3, (byte) 0x83, (byte) 0x08,
            (byte) 0x18, (byte) 0xc7, (byte) 0xef, (byte) 0x95, (byte) 0xe2, (byte) 0x1b,
            (byte) 0xba, (byte) 0x35, (byte) 0x61, (byte) 0xa3, (byte) 0xb4, (byte) 0x30,
            (byte) 0xe0, (byte) 0xd1, (byte) 0xc1, (byte) 0xa2, (byte) 0x3a, (byte) 0xc6,
            (byte) 0xb4, (byte) 0xd2, (byte) 0x80, (byte) 0x5a, (byte) 0xaf, (byte) 0xa4,
            (byte) 0x54, (byte) 0x3c, (byte) 0x66, (byte) 0x5a, (byte) 0x1c, (byte) 0x4d,
            (byte) 0xe1, (byte) 0xd9, (byte) 0x98, (byte) 0x44, (byte) 0x01, (byte) 0x1b,
            (byte) 0x8c, (byte) 0xe9, (byte) 0x80, (byte) 0x54, (byte) 0x83, (byte) 0x3d,
            (byte) 0x96, (byte) 0x25, (byte) 0x41, (byte) 0x1c, (byte) 0xad, (byte) 0xae,
            (byte) 0x3b, (byte) 0x7a, (byte) 0xd7, (byte) 0x9d, (byte) 0x10, (byte) 0x7c,
            (byte) 0xd1, (byte) 0xa7, (byte) 0x96, (byte) 0x39, (byte) 0xa5, (byte) 0x2f,
            (byte) 0xbe, (byte) 0xc3, (byte) 0x2c, (byte) 0x64, (byte) 0x01, (byte) 0xfe,
            (byte) 0xa2, (byte) 0xd1, (byte) 0x6a, (byte) 0xcf, (byte) 0x4c, (byte) 0x76,
            (byte) 0x3b, (byte) 0xc8, (byte) 0x35, (byte) 0x21, (byte) 0xda, (byte) 0x98,
            (byte) 0xcf, (byte) 0xf9, (byte) 0x29, (byte) 0xff, (byte) 0x30, (byte) 0x59,
            (byte) 0x36, (byte) 0x53, (byte) 0x0b, (byte) 0xbb, (byte) 0xfa, (byte) 0xba,
            (byte) 0xc4, (byte) 0x03, (byte) 0x23, (byte) 0xe0, (byte) 0xd3, (byte) 0x33,
            (byte) 0xff, (byte) 0x32, (byte) 0xdb, (byte) 0x30, (byte) 0x64, (byte) 0xc7,
            (byte) 0x56, (byte) 0xca, (byte) 0x55, (byte) 0x14, (byte) 0xee, (byte) 0x58,
            (byte) 0xfe, (byte) 0x96, (byte) 0x7e, (byte) 0x1c, (byte) 0x34, (byte) 0x16,
            (byte) 0xeb, (byte) 0x76, (byte) 0x26, (byte) 0x48, (byte) 0xe2, (byte) 0xe5,
            (byte) 0x5c, (byte) 0xd5, (byte) 0x83, (byte) 0x37, (byte) 0xd9, (byte) 0x09,
            (byte) 0x71, (byte) 0xbc, (byte) 0x54, (byte) 0x25, (byte) 0xca, (byte) 0x2e,
            (byte) 0xdb, (byte) 0x36, (byte) 0x39, (byte) 0xcc, (byte) 0x3a, (byte) 0x81,
            (byte) 0x95, (byte) 0x9e, (byte) 0xf4, (byte) 0x01, (byte) 0xa7, (byte) 0xc0,
            (byte) 0x20, (byte) 0xce, (byte) 0x70, (byte) 0x55, (byte) 0x2c, (byte) 0xe0,
            (byte) 0x93, (byte) 0x72, (byte) 0xa6, (byte) 0x25, (byte) 0xda, (byte) 0x64,
            (byte) 0x19, (byte) 0x18, (byte) 0xd2, (byte) 0x31, (byte) 0xe2, (byte) 0x7c,
            (byte) 0xf2, (byte) 0x30, (byte) 0x9e, (byte) 0x8d, (byte) 0xc6, (byte) 0x14,
            (byte) 0x8a, (byte) 0x38, (byte) 0xf0, (byte) 0x94, (byte) 0xeb, (byte) 0xf4,
            (byte) 0x64, (byte) 0x92, (byte) 0x3d, (byte) 0x67, (byte) 0xa6, (byte) 0x2c,
            (byte) 0x52, (byte) 0xfc, (byte) 0x60, (byte) 0xca, (byte) 0x2a, (byte) 0xcf,
            (byte) 0x24, (byte) 0xd5, (byte) 0x42, (byte) 0x5f, (byte) 0xc7, (byte) 0x9f,
            (byte) 0xf3, (byte) 0xb4, (byte) 0xdf, (byte) 0x76, (byte) 0x6e, (byte) 0x53,
            (byte) 0xa1, (byte) 0x7b, (byte) 0xae, (byte) 0xa5, (byte) 0x84, (byte) 0x1f,
            (byte) 0xfa, (byte) 0xc0, (byte) 0xb4, (byte) 0x6c, (byte) 0xc9, (byte) 0x02,
            (byte) 0x81, (byte) 0xc1, (byte) 0x00, (byte) 0xf3, (byte) 0x17, (byte) 0xd9,
            (byte) 0x48, (byte) 0x17, (byte) 0x87, (byte) 0x84, (byte) 0x16, (byte) 0xea,
            (byte) 0x2d, (byte) 0x31, (byte) 0x1b, (byte) 0xce, (byte) 0xec, (byte) 0xaf,
            (byte) 0xdc, (byte) 0x6b, (byte) 0xaf, (byte) 0xc8, (byte) 0xf1, (byte) 0x40,
            (byte) 0xa7, (byte) 0x4f, (byte) 0xef, (byte) 0x48, (byte) 0x08, (byte) 0x5e,
            (byte) 0x9a, (byte) 0xd1, (byte) 0xc0, (byte) 0xb1, (byte) 0xfe, (byte) 0xe7,
            (byte) 0x03, (byte) 0xd5, (byte) 0x96, (byte) 0x01, (byte) 0xe8, (byte) 0x40,
            (byte) 0xca, (byte) 0x78, (byte) 0xcb, (byte) 0xb3, (byte) 0x28, (byte) 0x1a,
            (byte) 0xf0, (byte) 0xe5, (byte) 0xf6, (byte) 0x46, (byte) 0xef, (byte) 0xcd,
            (byte) 0x1a, (byte) 0x0f, (byte) 0x13, (byte) 0x2d, (byte) 0x38, (byte) 0xf8,
            (byte) 0xf7, (byte) 0x88, (byte) 0x21, (byte) 0x15, (byte) 0xce, (byte) 0x48,
            (byte) 0xf4, (byte) 0x92, (byte) 0x7e, (byte) 0x9b, (byte) 0x2e, (byte) 0x2f,
            (byte) 0x22, (byte) 0x3e, (byte) 0x5c, (byte) 0x67, (byte) 0xd7, (byte) 0x58,
            (byte) 0xf6, (byte) 0xef, (byte) 0x1f, (byte) 0xb4, (byte) 0x04, (byte) 0xc7,
            (byte) 0xfd, (byte) 0x8c, (byte) 0x4e, (byte) 0x27, (byte) 0x9e, (byte) 0xb9,
            (byte) 0xef, (byte) 0x0f, (byte) 0xf7, (byte) 0x4a, (byte) 0xc2, (byte) 0xf4,
            (byte) 0x64, (byte) 0x6b, (byte) 0xe0, (byte) 0xfb, (byte) 0xe3, (byte) 0x45,
            (byte) 0xd5, (byte) 0x37, (byte) 0xa0, (byte) 0x2a, (byte) 0xc6, (byte) 0xf3,
            (byte) 0xf6, (byte) 0xcc, (byte) 0xb5, (byte) 0x94, (byte) 0xbf, (byte) 0x56,
            (byte) 0xa0, (byte) 0x61, (byte) 0x36, (byte) 0x88, (byte) 0x35, (byte) 0xd5,
            (byte) 0xa5, (byte) 0xad, (byte) 0x20, (byte) 0x48, (byte) 0xda, (byte) 0x70,
            (byte) 0x35, (byte) 0xd9, (byte) 0x75, (byte) 0x66, (byte) 0xa5, (byte) 0xac,
            (byte) 0x86, (byte) 0x7a, (byte) 0x75, (byte) 0x49, (byte) 0x88, (byte) 0x40,
            (byte) 0xce, (byte) 0xb0, (byte) 0x6f, (byte) 0x57, (byte) 0x15, (byte) 0x54,
            (byte) 0xd3, (byte) 0x2f, (byte) 0x11, (byte) 0x9b, (byte) 0xe3, (byte) 0x87,
            (byte) 0xc8, (byte) 0x8d, (byte) 0x98, (byte) 0xc6, (byte) 0xe0, (byte) 0xbc,
            (byte) 0x85, (byte) 0xb9, (byte) 0x04, (byte) 0x43, (byte) 0xa9, (byte) 0x41,
            (byte) 0xce, (byte) 0x42, (byte) 0x1a, (byte) 0x57, (byte) 0x10, (byte) 0xd8,
            (byte) 0xe4, (byte) 0x6a, (byte) 0x51, (byte) 0x10, (byte) 0x0a, (byte) 0xec,
            (byte) 0xe4, (byte) 0x57, (byte) 0xc7, (byte) 0xee, (byte) 0xe9, (byte) 0xd6,
            (byte) 0xcb, (byte) 0x3e, (byte) 0xba, (byte) 0xfa, (byte) 0xe9, (byte) 0x0e,
            (byte) 0xed, (byte) 0x87, (byte) 0x04, (byte) 0x9a, (byte) 0x48, (byte) 0xba,
            (byte) 0xaf, (byte) 0x08, (byte) 0xf5, (byte) 0x02, (byte) 0x81, (byte) 0xc1,
            (byte) 0x00, (byte) 0xcb, (byte) 0x63, (byte) 0xd6, (byte) 0x54, (byte) 0xb6,
            (byte) 0xf3, (byte) 0xf3, (byte) 0x8c, (byte) 0xf8, (byte) 0xd0, (byte) 0xd2,
            (byte) 0x84, (byte) 0xc1, (byte) 0xf5, (byte) 0x12, (byte) 0xe0, (byte) 0x02,
            (byte) 0x80, (byte) 0x42, (byte) 0x92, (byte) 0x4e, (byte) 0xa4, (byte) 0x5c,
            (byte) 0xa5, (byte) 0x64, (byte) 0xec, (byte) 0xb7, (byte) 0xdc, (byte) 0xe0,
            (byte) 0x2d, (byte) 0x5d, (byte) 0xac, (byte) 0x0e, (byte) 0x24, (byte) 0x48,
            (byte) 0x13, (byte) 0x05, (byte) 0xe8, (byte) 0xff, (byte) 0x96, (byte) 0x93,
            (byte) 0xba, (byte) 0x3c, (byte) 0x88, (byte) 0xcc, (byte) 0x80, (byte) 0xf9,
            (byte) 0xdb, (byte) 0xa8, (byte) 0x4d, (byte) 0x86, (byte) 0x47, (byte) 0xc8,
            (byte) 0xbf, (byte) 0x34, (byte) 0x2d, (byte) 0xda, (byte) 0xb6, (byte) 0x28,
            (byte) 0xf0, (byte) 0x1e, (byte) 0xd2, (byte) 0x46, (byte) 0x0d, (byte) 0x6f,
            (byte) 0x36, (byte) 0x8e, (byte) 0x84, (byte) 0xd8, (byte) 0xaf, (byte) 0xf7,
            (byte) 0x69, (byte) 0x23, (byte) 0x77, (byte) 0xfb, (byte) 0xc5, (byte) 0x04,
            (byte) 0x08, (byte) 0x18, (byte) 0xac, (byte) 0x85, (byte) 0x80, (byte) 0x87,
            (byte) 0x1c, (byte) 0xfe, (byte) 0x8e, (byte) 0x5d, (byte) 0x00, (byte) 0x7f,
            (byte) 0x5b, (byte) 0x33, (byte) 0xf5, (byte) 0xdf, (byte) 0x70, (byte) 0x81,
            (byte) 0xad, (byte) 0x81, (byte) 0xf4, (byte) 0x5a, (byte) 0x37, (byte) 0x8a,
            (byte) 0x79, (byte) 0x09, (byte) 0xc5, (byte) 0x55, (byte) 0xab, (byte) 0x58,
            (byte) 0x7c, (byte) 0x47, (byte) 0xca, (byte) 0xa5, (byte) 0x80, (byte) 0x49,
            (byte) 0x5f, (byte) 0x71, (byte) 0x83, (byte) 0xfb, (byte) 0x3b, (byte) 0x06,
            (byte) 0xec, (byte) 0x75, (byte) 0x23, (byte) 0xc4, (byte) 0x32, (byte) 0xc7,
            (byte) 0x18, (byte) 0xf6, (byte) 0x82, (byte) 0x95, (byte) 0x98, (byte) 0x39,
            (byte) 0xf7, (byte) 0x92, (byte) 0x31, (byte) 0xc0, (byte) 0x89, (byte) 0xba,
            (byte) 0xd4, (byte) 0xd4, (byte) 0x58, (byte) 0x4e, (byte) 0x38, (byte) 0x35,
            (byte) 0x10, (byte) 0xb9, (byte) 0xf1, (byte) 0x27, (byte) 0xdc, (byte) 0xff,
            (byte) 0xc7, (byte) 0xb2, (byte) 0xba, (byte) 0x1f, (byte) 0x27, (byte) 0xaf,
            (byte) 0x99, (byte) 0xd5, (byte) 0xb0, (byte) 0x39, (byte) 0xe7, (byte) 0x43,
            (byte) 0x88, (byte) 0xd3, (byte) 0xce, (byte) 0x38, (byte) 0xc2, (byte) 0x99,
            (byte) 0x43, (byte) 0xfc, (byte) 0x8a, (byte) 0xe3, (byte) 0x60, (byte) 0x0d,
            (byte) 0x0a, (byte) 0xb8, (byte) 0xc4, (byte) 0x29, (byte) 0xca, (byte) 0x0d,
            (byte) 0x30, (byte) 0xaf, (byte) 0xca, (byte) 0xd0, (byte) 0xaa, (byte) 0x67,
            (byte) 0xb1, (byte) 0xdd, (byte) 0xdb, (byte) 0x7a, (byte) 0x11, (byte) 0xad,
            (byte) 0xeb, (byte) 0x02, (byte) 0x81, (byte) 0xc0, (byte) 0x71, (byte) 0xb8,
            (byte) 0xcf, (byte) 0x72, (byte) 0x35, (byte) 0x67, (byte) 0xb5, (byte) 0x38,
            (byte) 0x8f, (byte) 0x16, (byte) 0xd3, (byte) 0x29, (byte) 0x82, (byte) 0x35,
            (byte) 0x21, (byte) 0xd4, (byte) 0x49, (byte) 0x20, (byte) 0x74, (byte) 0x2d,
            (byte) 0xc0, (byte) 0xa4, (byte) 0x44, (byte) 0xf5, (byte) 0xd8, (byte) 0xc9,
            (byte) 0xe9, (byte) 0x90, (byte) 0x1d, (byte) 0xde, (byte) 0x3a, (byte) 0xa6,
            (byte) 0xd7, (byte) 0xe5, (byte) 0xe8, (byte) 0x4e, (byte) 0x83, (byte) 0xd7,
            (byte) 0xe6, (byte) 0x2f, (byte) 0x92, (byte) 0x31, (byte) 0x21, (byte) 0x3f,
            (byte) 0xfa, (byte) 0xd2, (byte) 0x85, (byte) 0x92, (byte) 0x1f, (byte) 0xff,
            (byte) 0x61, (byte) 0x00, (byte) 0xf6, (byte) 0xda, (byte) 0x6e, (byte) 0xc6,
            (byte) 0x7f, (byte) 0x5a, (byte) 0x35, (byte) 0x79, (byte) 0xdc, (byte) 0xdc,
            (byte) 0xa3, (byte) 0x2e, (byte) 0x9f, (byte) 0x35, (byte) 0xd1, (byte) 0x5c,
            (byte) 0xda, (byte) 0xb9, (byte) 0xf7, (byte) 0x58, (byte) 0x7d, (byte) 0x4f,
            (byte) 0xb6, (byte) 0x13, (byte) 0xd7, (byte) 0x2c, (byte) 0x0a, (byte) 0xa8,
            (byte) 0x4d, (byte) 0xf2, (byte) 0xe4, (byte) 0x67, (byte) 0x4f, (byte) 0x8b,
            (byte) 0xa6, (byte) 0xca, (byte) 0x1a, (byte) 0xbb, (byte) 0x02, (byte) 0x63,
            (byte) 0x8f, (byte) 0xb7, (byte) 0x46, (byte) 0xec, (byte) 0x7a, (byte) 0x8a,
            (byte) 0x09, (byte) 0x0a, (byte) 0x45, (byte) 0x3a, (byte) 0x8d, (byte) 0xa8,
            (byte) 0x83, (byte) 0x4b, (byte) 0x0a, (byte) 0xdb, (byte) 0x4b, (byte) 0x99,
            (byte) 0xf3, (byte) 0x69, (byte) 0x95, (byte) 0xf0, (byte) 0xcf, (byte) 0xe9,
            (byte) 0xf7, (byte) 0x67, (byte) 0xc9, (byte) 0x45, (byte) 0x18, (byte) 0x2f,
            (byte) 0xf0, (byte) 0x5c, (byte) 0x90, (byte) 0xbd, (byte) 0xa6, (byte) 0x66,
            (byte) 0x8c, (byte) 0xfe, (byte) 0x60, (byte) 0x5d, (byte) 0x6c, (byte) 0x27,
            (byte) 0xec, (byte) 0xc1, (byte) 0x84, (byte) 0xb2, (byte) 0xa1, (byte) 0x97,
            (byte) 0x9e, (byte) 0x16, (byte) 0x29, (byte) 0xa7, (byte) 0xe0, (byte) 0x38,
            (byte) 0xa2, (byte) 0x36, (byte) 0x05, (byte) 0x5f, (byte) 0xda, (byte) 0x72,
            (byte) 0x1a, (byte) 0x5f, (byte) 0xa8, (byte) 0x7d, (byte) 0x41, (byte) 0x35,
            (byte) 0xf6, (byte) 0x4e, (byte) 0x0a, (byte) 0x88, (byte) 0x8e, (byte) 0x00,
            (byte) 0x98, (byte) 0xa6, (byte) 0xca, (byte) 0xc1, (byte) 0xdf, (byte) 0x72,
            (byte) 0x6c, (byte) 0xfe, (byte) 0x29, (byte) 0xbe, (byte) 0xa3, (byte) 0x9b,
            (byte) 0x0b, (byte) 0x5c, (byte) 0x0b, (byte) 0x9d, (byte) 0xa7, (byte) 0x71,
            (byte) 0xce, (byte) 0x04, (byte) 0xfa, (byte) 0xac, (byte) 0x01, (byte) 0x8d,
            (byte) 0x52, (byte) 0xa0, (byte) 0x3d, (byte) 0xdd, (byte) 0x02, (byte) 0x81,
            (byte) 0xc1, (byte) 0x00, (byte) 0xc1, (byte) 0xc0, (byte) 0x2e, (byte) 0xa9,
            (byte) 0xee, (byte) 0xca, (byte) 0xff, (byte) 0xe4, (byte) 0xf8, (byte) 0x15,
            (byte) 0xfd, (byte) 0xa5, (byte) 0x68, (byte) 0x1b, (byte) 0x2d, (byte) 0x4a,
            (byte) 0xe6, (byte) 0x37, (byte) 0x06, (byte) 0xb3, (byte) 0xd7, (byte) 0x64,
            (byte) 0xad, (byte) 0xb9, (byte) 0x05, (byte) 0x26, (byte) 0x97, (byte) 0x94,
            (byte) 0x3a, (byte) 0x9e, (byte) 0x1c, (byte) 0xd0, (byte) 0xcd, (byte) 0x7b,
            (byte) 0xf4, (byte) 0x88, (byte) 0xe2, (byte) 0xa5, (byte) 0x6d, (byte) 0xed,
            (byte) 0x24, (byte) 0x77, (byte) 0x52, (byte) 0x39, (byte) 0x43, (byte) 0x0f,
            (byte) 0x4e, (byte) 0x75, (byte) 0xd8, (byte) 0xa3, (byte) 0x59, (byte) 0x5a,
            (byte) 0xc2, (byte) 0xba, (byte) 0x9a, (byte) 0x5b, (byte) 0x60, (byte) 0x31,
            (byte) 0x0d, (byte) 0x58, (byte) 0x89, (byte) 0x13, (byte) 0xe8, (byte) 0x95,
            (byte) 0xdd, (byte) 0xae, (byte) 0xcc, (byte) 0x1f, (byte) 0x73, (byte) 0x48,
            (byte) 0x55, (byte) 0xd8, (byte) 0xfb, (byte) 0x67, (byte) 0xce, (byte) 0x18,
            (byte) 0x85, (byte) 0x59, (byte) 0xad, (byte) 0x1f, (byte) 0x93, (byte) 0xe1,
            (byte) 0xb7, (byte) 0x54, (byte) 0x80, (byte) 0x8e, (byte) 0x5f, (byte) 0xbc,
            (byte) 0x1c, (byte) 0x96, (byte) 0x66, (byte) 0x2e, (byte) 0x40, (byte) 0x17,
            (byte) 0x2e, (byte) 0x01, (byte) 0x7a, (byte) 0x7d, (byte) 0xaa, (byte) 0xff,
            (byte) 0xa3, (byte) 0xd2, (byte) 0xdf, (byte) 0xe2, (byte) 0xf3, (byte) 0x54,
            (byte) 0x51, (byte) 0xeb, (byte) 0xba, (byte) 0x7c, (byte) 0x2a, (byte) 0x22,
            (byte) 0xc6, (byte) 0x42, (byte) 0xbc, (byte) 0xa1, (byte) 0x6c, (byte) 0xcf,
            (byte) 0x73, (byte) 0x2e, (byte) 0x07, (byte) 0xfc, (byte) 0xf5, (byte) 0x67,
            (byte) 0x25, (byte) 0xd0, (byte) 0xfa, (byte) 0xeb, (byte) 0xb4, (byte) 0xd4,
            (byte) 0x19, (byte) 0xcc, (byte) 0x64, (byte) 0xa1, (byte) 0x2e, (byte) 0x78,
            (byte) 0x45, (byte) 0xd9, (byte) 0x7f, (byte) 0x1b, (byte) 0x4c, (byte) 0x10,
            (byte) 0x31, (byte) 0x44, (byte) 0xe8, (byte) 0xcc, (byte) 0xf9, (byte) 0x1b,
            (byte) 0x87, (byte) 0x31, (byte) 0xd6, (byte) 0x69, (byte) 0x85, (byte) 0x4a,
            (byte) 0x49, (byte) 0xf6, (byte) 0xb2, (byte) 0xe0, (byte) 0xb8, (byte) 0x98,
            (byte) 0x3c, (byte) 0xf6, (byte) 0x78, (byte) 0x46, (byte) 0xc8, (byte) 0x3d,
            (byte) 0x60, (byte) 0xc1, (byte) 0xaa, (byte) 0x2f, (byte) 0x28, (byte) 0xa1,
            (byte) 0x14, (byte) 0x6b, (byte) 0x75, (byte) 0x4d, (byte) 0xb1, (byte) 0x3d,
            (byte) 0x80, (byte) 0x49, (byte) 0x33, (byte) 0xfd, (byte) 0x71, (byte) 0xc0,
            (byte) 0x13, (byte) 0x1e, (byte) 0x16, (byte) 0x69, (byte) 0x80, (byte) 0xa4,
            (byte) 0x9c, (byte) 0xd7, (byte) 0x02, (byte) 0x81, (byte) 0xc1, (byte) 0x00,
            (byte) 0x8c, (byte) 0x33, (byte) 0x2d, (byte) 0xd9, (byte) 0xf3, (byte) 0x42,
            (byte) 0x4d, (byte) 0xca, (byte) 0x5e, (byte) 0x60, (byte) 0x14, (byte) 0x10,
            (byte) 0xf6, (byte) 0xf3, (byte) 0x71, (byte) 0x15, (byte) 0x88, (byte) 0x54,
            (byte) 0x84, (byte) 0x21, (byte) 0x04, (byte) 0xb1, (byte) 0xaf, (byte) 0x02,
            (byte) 0x11, (byte) 0x7f, (byte) 0x42, (byte) 0x3e, (byte) 0x86, (byte) 0xcb,
            (byte) 0x6c, (byte) 0xf5, (byte) 0x57, (byte) 0x78, (byte) 0x4a, (byte) 0x03,
            (byte) 0x9b, (byte) 0x80, (byte) 0xc2, (byte) 0x04, (byte) 0x3a, (byte) 0x6b,
            (byte) 0xb3, (byte) 0x30, (byte) 0x31, (byte) 0x7e, (byte) 0xc3, (byte) 0x89,
            (byte) 0x09, (byte) 0x4e, (byte) 0x86, (byte) 0x59, (byte) 0x41, (byte) 0xb5,
            (byte) 0xae, (byte) 0xd5, (byte) 0xc6, (byte) 0x38, (byte) 0xbc, (byte) 0xd7,
            (byte) 0xd7, (byte) 0x8e, (byte) 0xa3, (byte) 0x1a, (byte) 0xde, (byte) 0x32,
            (byte) 0xad, (byte) 0x8d, (byte) 0x15, (byte) 0x81, (byte) 0xfe, (byte) 0xac,
            (byte) 0xbd, (byte) 0xd0, (byte) 0xca, (byte) 0xbc, (byte) 0xd8, (byte) 0x6a,
            (byte) 0xe1, (byte) 0xfe, (byte) 0xda, (byte) 0xc4, (byte) 0xd8, (byte) 0x62,
            (byte) 0x71, (byte) 0x20, (byte) 0xa3, (byte) 0xd3, (byte) 0x06, (byte) 0x11,
            (byte) 0xa9, (byte) 0x53, (byte) 0x7a, (byte) 0x44, (byte) 0x89, (byte) 0x3d,
            (byte) 0x28, (byte) 0x5e, (byte) 0x7d, (byte) 0xf0, (byte) 0x60, (byte) 0xeb,
            (byte) 0xb5, (byte) 0xdf, (byte) 0xed, (byte) 0x4f, (byte) 0x6d, (byte) 0x05,
            (byte) 0x59, (byte) 0x06, (byte) 0xb0, (byte) 0x62, (byte) 0x50, (byte) 0x1c,
            (byte) 0xb7, (byte) 0x2c, (byte) 0x44, (byte) 0xa4, (byte) 0x49, (byte) 0xf8,
            (byte) 0x4f, (byte) 0x4b, (byte) 0xab, (byte) 0x71, (byte) 0x5b, (byte) 0xcb,
            (byte) 0x31, (byte) 0x10, (byte) 0x41, (byte) 0xe0, (byte) 0x1a, (byte) 0x15,
            (byte) 0xdc, (byte) 0x4c, (byte) 0x5d, (byte) 0x4f, (byte) 0x62, (byte) 0x83,
            (byte) 0xa4, (byte) 0x80, (byte) 0x06, (byte) 0x36, (byte) 0xba, (byte) 0xc9,
            (byte) 0xe2, (byte) 0xa4, (byte) 0x11, (byte) 0x98, (byte) 0x6b, (byte) 0x4c,
            (byte) 0xe9, (byte) 0x90, (byte) 0x55, (byte) 0x18, (byte) 0xde, (byte) 0xe1,
            (byte) 0x42, (byte) 0x38, (byte) 0x28, (byte) 0xa3, (byte) 0x54, (byte) 0x56,
            (byte) 0x31, (byte) 0xaf, (byte) 0x5a, (byte) 0xd6, (byte) 0xf0, (byte) 0x26,
            (byte) 0xe0, (byte) 0x7a, (byte) 0xd9, (byte) 0x6c, (byte) 0x64, (byte) 0xca,
            (byte) 0x5d, (byte) 0x6d, (byte) 0x3d, (byte) 0x9a, (byte) 0xfe, (byte) 0x36,
            (byte) 0x93, (byte) 0x9e, (byte) 0x62, (byte) 0x94, (byte) 0xc6, (byte) 0x07,
            (byte) 0x83, (byte) 0x96, (byte) 0xd6, (byte) 0x27, (byte) 0xa6, (byte) 0xd8
    };
    private static final PrivateKey CLIENT_SUITE_B_RSA3072_KEY =
            loadPrivateKey(""RSA"", CLIENT_SUITE_B_RSA3072_KEY_DATA);

    private static final String CLIENT_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIB9zCCAX4CFDpfSZh3AH07BEfGWuMDa7Ynz6y+MAoGCCqGSM49BAMDMF4xCzAJ\n""
                    + ""BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQKDAdB\n""
                    + ""bmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4XDTIw\n""
                    + ""MDcyMTAyMjk1MFoXDTMwMDUzMDAyMjk1MFowYjELMAkGA1UEBhMCVVMxCzAJBgNV\n""
                    + ""BAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsM\n""
                    + ""BVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MHYwEAYHKoZIzj0CAQYFK4EE\n""
                    + ""ACIDYgAEhxhVJ7dcSqrto0X+dgRxtd8BWG8cWmPjBji3MIxDLfpcMDoIB84ae1Ew\n""
                    + ""gJn4YUYHrWsUDiVNihv8j7a/Ol1qcIY2ybH7tbezefLmagqA4vXEUXZXoUyL4ZNC\n""
                    + ""DWcdw6LrMAoGCCqGSM49BAMDA2cAMGQCMH4aP73HrriRUJRguiuRic+X4Cqj/7YQ\n""
                    + ""ueJmP87KF92/thhoQ9OrRo8uJITPmNDswwIwP2Q1AZCSL4BI9dYrqu07Ar+pSkXE\n""
                    + ""R7oOqGdZR+d/MvXcFSrbIaLKEoHXmQamIHLe\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CLIENT_SUITE_B_ECDSA_CERT =
            loadCertificate(CLIENT_SUITE_B_ECDSA_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_ECC_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x81, (byte) 0xb6, (byte) 0x02, (byte) 0x01, (byte) 0x00,
            (byte) 0x30, (byte) 0x10, (byte) 0x06, (byte) 0x07, (byte) 0x2a, (byte) 0x86,
            (byte) 0x48, (byte) 0xce, (byte) 0x3d, (byte) 0x02, (byte) 0x01, (byte) 0x06,
            (byte) 0x05, (byte) 0x2b, (byte) 0x81, (byte) 0x04, (byte) 0x00, (byte) 0x22,
            (byte) 0x04, (byte) 0x81, (byte) 0x9e, (byte) 0x30, (byte) 0x81, (byte) 0x9b,
            (byte) 0x02, (byte) 0x01, (byte) 0x01, (byte) 0x04, (byte) 0x30, (byte) 0xea,
            (byte) 0x6c, (byte) 0x4b, (byte) 0x6d, (byte) 0x43, (byte) 0xf9, (byte) 0x6c,
            (byte) 0x91, (byte) 0xdc, (byte) 0x2d, (byte) 0x6e, (byte) 0x87, (byte) 0x4f,
            (byte) 0x0a, (byte) 0x0b, (byte) 0x97, (byte) 0x25, (byte) 0x1c, (byte) 0x79,
            (byte) 0xa2, (byte) 0x07, (byte) 0xdc, (byte) 0x94, (byte) 0xc2, (byte) 0xee,
            (byte) 0x64, (byte) 0x51, (byte) 0x6d, (byte) 0x4e, (byte) 0x35, (byte) 0x1c,
            (byte) 0x22, (byte) 0x2f, (byte) 0xc0, (byte) 0xea, (byte) 0x09, (byte) 0x47,
            (byte) 0x3e, (byte) 0xb9, (byte) 0xb6, (byte) 0xb8, (byte) 0x83, (byte) 0x9e,
            (byte) 0xed, (byte) 0x59, (byte) 0xe5, (byte) 0xe7, (byte) 0x0f, (byte) 0xa1,
            (byte) 0x64, (byte) 0x03, (byte) 0x62, (byte) 0x00, (byte) 0x04, (byte) 0x87,
            (byte) 0x18, (byte) 0x55, (byte) 0x27, (byte) 0xb7, (byte) 0x5c, (byte) 0x4a,
            (byte) 0xaa, (byte) 0xed, (byte) 0xa3, (byte) 0x45, (byte) 0xfe, (byte) 0x76,
            (byte) 0x04, (byte) 0x71, (byte) 0xb5, (byte) 0xdf, (byte) 0x01, (byte) 0x58,
            (byte) 0x6f, (byte) 0x1c, (byte) 0x5a, (byte) 0x63, (byte) 0xe3, (byte) 0x06,
            (byte) 0x38, (byte) 0xb7, (byte) 0x30, (byte) 0x8c, (byte) 0x43, (byte) 0x2d,
            (byte) 0xfa, (byte) 0x5c, (byte) 0x30, (byte) 0x3a, (byte) 0x08, (byte) 0x07,
            (byte) 0xce, (byte) 0x1a, (byte) 0x7b, (byte) 0x51, (byte) 0x30, (byte) 0x80,
            (byte) 0x99, (byte) 0xf8, (byte) 0x61, (byte) 0x46, (byte) 0x07, (byte) 0xad,
            (byte) 0x6b, (byte) 0x14, (byte) 0x0e, (byte) 0x25, (byte) 0x4d, (byte) 0x8a,
            (byte) 0x1b, (byte) 0xfc, (byte) 0x8f, (byte) 0xb6, (byte) 0xbf, (byte) 0x3a,
            (byte) 0x5d, (byte) 0x6a, (byte) 0x70, (byte) 0x86, (byte) 0x36, (byte) 0xc9,
            (byte) 0xb1, (byte) 0xfb, (byte) 0xb5, (byte) 0xb7, (byte) 0xb3, (byte) 0x79,
            (byte) 0xf2, (byte) 0xe6, (byte) 0x6a, (byte) 0x0a, (byte) 0x80, (byte) 0xe2,
            (byte) 0xf5, (byte) 0xc4, (byte) 0x51, (byte) 0x76, (byte) 0x57, (byte) 0xa1,
            (byte) 0x4c, (byte) 0x8b, (byte) 0xe1, (byte) 0x93, (byte) 0x42, (byte) 0x0d,
            (byte) 0x67, (byte) 0x1d, (byte) 0xc3, (byte) 0xa2, (byte) 0xeb
    };
    private static final PrivateKey CLIENT_SUITE_B_ECC_KEY =
            loadPrivateKey(""EC"", CLIENT_SUITE_B_ECC_KEY_DATA);

    private static X509Certificate loadCertificate(String blob) {
        try {
            final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            InputStream stream = new ByteArrayInputStream(blob.getBytes(StandardCharsets.UTF_8));

            return (X509Certificate) certFactory.generateCertificate(stream);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PrivateKey loadPrivateKey(String algorithm, byte[] fakeKey) {
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            return kf.generatePrivate(new PKCS8EncodedKeySpec(fakeKey));
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            return null;
        }
    }

    private WifiNetworkSuggestion.Builder createBuilderWithCommonParams() {
        return createBuilderWithCommonParams(false);
    }

    private WifiNetworkSuggestion.Builder createBuilderWithCommonParams(boolean isPasspoint) {
        WifiNetworkSuggestion.Builder builder = new WifiNetworkSuggestion.Builder();
        if (!isPasspoint) {
            builder.setSsid(TEST_SSID);
            builder.setBssid(MacAddress.fromString(TEST_BSSID));
            builder.setIsEnhancedOpen(false);
            builder.setIsHiddenSsid(true);
        }
        builder.setPriority(TEST_PRIORITY);
        builder.setIsAppInteractionRequired(true);
        builder.setIsUserInteractionRequired(true);
        builder.setIsMetered(true);
        builder.setCarrierId(TelephonyManager.UNKNOWN_CARRIER_ID);
        builder.setCredentialSharedWithUser(true);
        builder.setIsInitialAutojoinEnabled(true);
        builder.setUntrusted(false);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            builder.setOemPaid(false);
            builder.setOemPrivate(false);
            builder.setSubscriptionId(TEST_SUB_ID);
        }
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            builder.setPriorityGroup(TEST_PRIORITY_GROUP);
        }
        return builder;
    }

    private void validateCommonParams(WifiNetworkSuggestion suggestion) {
        validateCommonParams(suggestion, false);
    }

    private void validateCommonParams(WifiNetworkSuggestion suggestion, boolean isPasspoint) {
        assertNotNull(suggestion);
        assertNotNull(suggestion.getWifiConfiguration());
        if (!isPasspoint) {
            assertEquals(TEST_SSID, suggestion.getSsid());
            assertEquals(TEST_BSSID, suggestion.getBssid().toString());
            assertFalse(suggestion.isEnhancedOpen());
            assertTrue(suggestion.isHiddenSsid());
        }
        assertEquals(TEST_PRIORITY, suggestion.getPriority());
        assertTrue(suggestion.isAppInteractionRequired());
        assertTrue(suggestion.isUserInteractionRequired());
        assertTrue(suggestion.isMetered());
        assertTrue(suggestion.isCredentialSharedWithUser());
        assertTrue(suggestion.isInitialAutojoinEnabled());
        assertFalse(suggestion.isUntrusted());
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertFalse(suggestion.isOemPaid());
            assertFalse(suggestion.isOemPrivate());
            assertEquals(TEST_SUB_ID, suggestion.getSubscriptionId());
        }
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            assertEquals(TEST_PRIORITY_GROUP, suggestion.getPriorityGroup());
            assertEquals(TelephonyManager.UNKNOWN_CARRIER_ID, suggestion.getCarrierId());
        }
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa2Passphrase"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa2Passphrase() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                .setWpa2Passphrase(TEST_PASSPHRASE)
                .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Passphrase"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Passphrase() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3Passphrase(TEST_PASSPHRASE)
                        .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3SaeH2eOnlyMode"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3SaeH2eOnlyMode() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3Passphrase(TEST_PASSPHRASE)
                        .setIsWpa3SaeH2eOnlyModeEnabled(true)
                        .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWapiPassphrase"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWapiPassphrase() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWapiPassphrase(TEST_PASSPHRASE)
                        .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    private static WifiEnterpriseConfig createEnterpriseConfig() {
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();
        config.setEapMethod(AKA);
        return config;
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa2Enterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa2Enterprise() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = createEnterpriseConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa2EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Enterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Enterprise() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = createEnterpriseConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3EnterpriseWithStandardApi"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3EnterpriseWithStandardApi() throws Exception {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiEnterpriseConfig enterpriseConfig = createEnterpriseConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseStandardModeConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3EnterpriseWithSuiteBRsaCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3EnterpriseWithSuiteBRsaCerts() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_RSA3072_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_RSA3072_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_RSA3072_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3EnterpriseWithSuiteBEccCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3EnterpriseWithSuiteBEccCerts() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_ECDSA_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_ECC_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_ECDSA_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Enterprise192bitWithSuiteBRsaCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Enterprise192bitWithSuiteBRsaCerts() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_RSA3072_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_RSA3072_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_RSA3072_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Enterprise192bitWithSuiteBEccCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Enterprise192bitWithSuiteBEccCerts() throws Exception {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_ECDSA_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_ECC_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_ECDSA_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3Enterprise192BitModeConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWapiEnterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWapiEnterprise() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WAPI_CERT);
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWapiEnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Helper function for creating a {@link PasspointConfiguration} for testing.
     *
     * @return {@link PasspointConfiguration}
     */
    private static PasspointConfiguration createPasspointConfig() {
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""fqdn"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[] {0x55, 0x66});
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(null);
        cred.setCertCredential(null);
        cred.setSimCredential(new Credential.SimCredential());
        cred.getSimCredential().setImsi(""1234*"");
        cred.getSimCredential().setEapType(23); // EAP-AKA
        cred.setCaCertificate(null);
        cred.setClientCertificateChain(null);
        cred.setClientPrivateKey(null);
        PasspointConfiguration config = new PasspointConfiguration();
        config.setHomeSp(homeSp);
        config.setCredential(cred);
        return config;
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithPasspointConfig"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithPasspointConfig() throws Exception {
        PasspointConfiguration passpointConfig = createPasspointConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams(true)
                        .setPasspointConfig(passpointConfig)
                        .build();
        validateCommonParams(suggestion, true);
        assertNull(suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertEquals(passpointConfig.getUniqueId(), suggestion.getPasspointConfig().getUniqueId());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testEqualUniqueId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testEqualUniqueId() throws Exception {
        PasspointConfiguration config1 = createConfig();
        PasspointConfiguration config2 = createConfig();

        assertEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is the same for two instances with different
     * HomeSp node but same FQDN
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdSameHomeSpSameFqdn"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdSameHomeSpSameFqdn() throws Exception {
        PasspointConfiguration config1 = createConfig();
        HomeSp homeSp = config1.getHomeSp();
        homeSp.setMatchAnyOis(new long[]{0x1000, 0x2000});

        // Modify config2's RCOIs and friendly name to a different set of values
        PasspointConfiguration config2 = createConfig();
        homeSp = config2.getHomeSp();

        homeSp.setRoamingConsortiumOis(new long[]{0xaa, 0xbb});
        homeSp.setFriendlyName(""Some other name"");
        homeSp.setOtherHomePartnersList(Arrays.asList(""other-provider1"", ""other-provider2""));
        homeSp.setMatchAllOis(new long[]{0x1000, 0x2000});
        config2.setHomeSp(homeSp);

        assertEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with the same
     * HomeSp node but different FQDN
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentHomeSpDifferentFqdn"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentHomeSpDifferentFqdn() throws Exception {
        PasspointConfiguration config1 = createConfig();

        // Modify config2's FQDN to a different value
        PasspointConfiguration config2 = createConfig();
        HomeSp homeSp = config2.getHomeSp();
        homeSp.setFqdn(""fqdn2.com"");
        config2.setHomeSp(homeSp);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * SIM Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentSimCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentSimCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();

        // Modify config2's realm and SIM credential to a different set of values
        PasspointConfiguration config2 = createConfig();
        Credential credential = config2.getCredential();
        credential.setRealm(""realm2.example.com"");
        credential.getSimCredential().setImsi(""350460*"");
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * Realm in the Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentRealm"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentRealm() throws Exception {
        PasspointConfiguration config1 = createConfig();

        // Modify config2's realm to a different set of values
        PasspointConfiguration config2 = createConfig();
        Credential credential = config2.getCredential();
        credential.setRealm(""realm2.example.com"");
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is the same for two instances with different
     * password and same username in the User Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdSameUserInUserCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdSameUserInUserCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();
        Credential credential = createCredentialWithUserCredential(""user"", ""passwd"");
        config1.setCredential(credential);

        // Modify config2's Passpowrd to a different set of values
        PasspointConfiguration config2 = createConfig();
        credential = createCredentialWithUserCredential(""user"", ""newpasswd"");
        config2.setCredential(credential);

        assertEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * username in the User Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentUserCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentUserCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();
        Credential credential = createCredentialWithUserCredential(""user"", ""passwd"");
        config1.setCredential(credential);

        // Modify config2's username to a different value
        PasspointConfiguration config2 = createConfig();
        credential = createCredentialWithUserCredential(""user2"", ""passwd"");
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * Cert Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentCertCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentCertCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();
        Credential credential = createCredentialWithCertificateCredential(true, true);
        config1.setCredential(credential);

        // Modify config2's cert credential to a different set of values
        PasspointConfiguration config2 = createConfig();
        credential = createCredentialWithCertificateCredential(false, false);
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the set and get decorated identity prefix methods work as expected.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testSetGetDecoratedIdentityPrefix"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testSetGetDecoratedIdentityPrefix() throws Exception {
        PasspointConfiguration config = createConfig();
        assertNull(config.getDecoratedIdentityPrefix());
        config.setDecoratedIdentityPrefix(TEST_DECORATED_IDENTITY_PREFIX);
        assertEquals(TEST_DECORATED_IDENTITY_PREFIX, config.getDecoratedIdentityPrefix());

    }

    /**
     * Helper function for generating user credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithUserCredential(String username, String password) {
        Credential.UserCredential userCred = new Credential.UserCredential();
        userCred.setUsername(username);
        userCred.setPassword(password);
        userCred.setEapType(EAP_TTLS);
        userCred.setNonEapInnerMethod(""MS-CHAP"");
        return createCredential(userCred, null, null, null, null, FakeKeys.CA_CERT0);
    }

    /**
     * Helper function for generating Credential for testing.
     *
     * @param userCred               Instance of UserCredential
     * @param certCred               Instance of CertificateCredential
     * @param simCred                Instance of SimCredential
     * @param clientCertificateChain Chain of client certificates
     * @param clientPrivateKey       Client private key
     * @param caCerts                CA certificates
     * @return {@link Credential}
     */
    private static Credential createCredential(Credential.UserCredential userCred,
            Credential.CertificateCredential certCred,
            Credential.SimCredential simCred,
            X509Certificate[] clientCertificateChain, PrivateKey clientPrivateKey,
            X509Certificate... caCerts) {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(userCred);
        cred.setCertCredential(certCred);
        cred.setSimCredential(simCred);
        cred.setCaCertificate(caCerts[0]);
        cred.setClientCertificateChain(clientCertificateChain);
        cred.setClientPrivateKey(clientPrivateKey);
        return cred;
    }

    /**
     * Helper function for generating certificate credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithCertificateCredential(Boolean useCaCert0,
            Boolean useCert0)
            throws NoSuchAlgorithmException, CertificateEncodingException {
        Credential.CertificateCredential certCred = new Credential.CertificateCredential();
        certCred.setCertType(""x509v3"");
        if (useCert0) {
            certCred.setCertSha256Fingerprint(
                    MessageDigest.getInstance(""SHA-256"").digest(FakeKeys.CLIENT_CERT.getEncoded()));
        } else {
            certCred.setCertSha256Fingerprint(MessageDigest.getInstance(""SHA-256"")
                    .digest(FakeKeys.CLIENT_SUITE_B_RSA3072_CERT.getEncoded()));
        }
        return createCredential(null, certCred, null, new X509Certificate[]{FakeKeys.CLIENT_CERT},
                FakeKeys.RSA_KEY1, useCaCert0 ? FakeKeys.CA_CERT0 : FakeKeys.CA_CERT1);
    }

    /**
     * Helper function for creating a {@link PasspointConfiguration} for testing.
     *
     * @return {@link PasspointConfiguration}
     */
    private static PasspointConfiguration createConfig() {
        PasspointConfiguration config = new PasspointConfiguration();
        config.setHomeSp(createHomeSp());
        config.setCredential(createCredential());
        Map<String, byte[]> trustRootCertList = new HashMap<>();
        trustRootCertList.put(""trustRoot.cert1.com"",
                new byte[CERTIFICATE_FINGERPRINT_BYTES]);
        trustRootCertList.put(""trustRoot.cert2.com"",
                new byte[CERTIFICATE_FINGERPRINT_BYTES]);
        return config;
    }

    /**
     * Utility function for creating a {@link android.net.wifi.hotspot2.pps.HomeSp} for testing.
     *
     * @return {@link android.net.wifi.hotspot2.pps.HomeSp}
     */
    private static HomeSp createHomeSp() {
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""fqdn"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        return homeSp;
    }

    /**
     * Utility function for creating a {@link android.net.wifi.hotspot2.pps.Credential} for
     * testing..
     *
     * @return {@link android.net.wifi.hotspot2.pps.Credential}
     */
    private static Credential createCredential() {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(null);
        cred.setCertCredential(null);
        cred.setSimCredential(new Credential.SimCredential());
        cred.getSimCredential().setImsi(""1234*"");
        cred.getSimCredential().setEapType(EAP_SIM);
        cred.setCaCertificate(null);
        cred.setClientCertificateChain(null);
        cred.setClientPrivateKey(null);
        return cred;
    }
}"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.Manifest.permission.READ_WIFI_CREDENTIAL;
import static android.Manifest.permission.WIFI_UPDATE_USABILITY_STATS_SCORE;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiUsabilityStatsEntry.ContentionTimeStats;
import static android.net.wifi.WifiUsabilityStatsEntry.RadioStats;
import static android.net.wifi.WifiUsabilityStatsEntry.RateStats;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_FAILURE;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_NO_PROBE;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_SUCCESS;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_UNKNOWN;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_BE;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_BK;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_VI;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_VO;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.WifiUsabilityStatsEntry;
import android.net.wifi.WifiConnectedSessionInfo;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;

import com.google.common.collect.Range;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Tests for wifi connected network scorer interface and usability stats.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class ConnectedNetworkScorerTest extends WifiJUnit4TestBase {
    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private TestHelper mTestHelper;
    private TelephonyManager mTelephonyManager;

    private boolean mWasVerboseLoggingEnabled;

    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private static final int TIMEOUT = 12_000;
    private static final int WAIT_DURATION = 5_000;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();

        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", TIMEOUT, () -> mWifiManager.isWifiEnabled());

        // turn screen on
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());

        mTestHelper = new TestHelper(mContext, mUiDevice);
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
        mTelephonyManager = mContext.getSystemService(TelephonyManager.class);
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;
        if (!mWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.setWifiEnabled(true));
        }
        mTestHelper.turnScreenOff();
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private static class TestUsabilityStatsListener implements
            WifiManager.OnWifiUsabilityStatsListener {
        private final CountDownLatch mCountDownLatch;
        public int seqNum;
        public boolean isSameBssidAndFre;
        public WifiUsabilityStatsEntry statsEntry;

        TestUsabilityStatsListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onWifiUsabilityStats(int seqNum, boolean isSameBssidAndFreq,
                WifiUsabilityStatsEntry statsEntry) {
            this.seqNum = seqNum;
            this.isSameBssidAndFre = isSameBssidAndFreq;
            this.statsEntry = statsEntry;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiUsabilityStatsEntry} retrieved from
     * {@link WifiManager.OnWifiUsabilityStatsListener}.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WaitForResultActivity"	"isTrue"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WaitForResultActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;

import android.app.Activity;
import android.app.job.JobInfo;
import android.app.job.JobScheduler;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Bundle;
import android.os.Parcel;
import android.os.ResultReceiver;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * An Activity that can start another Activity and wait for its result.
 */
public class WaitForResultActivity extends Activity {
    private final Object mStatusLock = new Object();
    private CountDownLatch mLatch;
    private boolean mStatus = false;

    private static final int REQUEST_CODE_WAIT_FOR_RESULT = 1;
    private static final String WIFI_LOCATION_TEST_APP_LOCATION_STATUS_EXTRA =
            ""android.net.wifi.cts.app.extra.STATUS"";

    public void startActivityToWaitForResult(@NonNull ComponentName componentName) {
        mLatch = new CountDownLatch(1);
        synchronized (mStatusLock) {
            mStatus = false;
        }
        Intent intent = new Intent()
                .addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)
                .setComponent(componentName);
        startActivityForResult(intent, REQUEST_CODE_WAIT_FOR_RESULT);
    }

    @NonNull
    public boolean waitForActivityResult(long timeoutMillis)
            throws InterruptedException {
        assertThat(mLatch.await(timeoutMillis, TimeUnit.MILLISECONDS)).isTrue();
        synchronized (mStatusLock) {
            return mStatus;
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
        if (requestCode == REQUEST_CODE_WAIT_FOR_RESULT) {
            assertThat(resultCode).isEqualTo(RESULT_OK);
            assertThat(data.hasExtra(WIFI_LOCATION_TEST_APP_LOCATION_STATUS_EXTRA)).isTrue();
            synchronized (mStatusLock) {
                mStatus = data.getBooleanExtra(
                        WIFI_LOCATION_TEST_APP_LOCATION_STATUS_EXTRA, false);
            }
            mLatch.countDown();
        } else {
            super.onActivityResult(requestCode, resultCode, data);
        }
    }

    private static final String WIFI_LOCATION_TEST_APP_PACKAGE_NAME =
            ""android.net.wifi.cts.app"";
    private static final String WIFI_LOCATION_TEST_APP_SCHEDULE_JOB_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".ScheduleJobActivity"";
    private static final String RESULT_RECEIVER_EXTRA =
            ""android.net.wifi.cts.app.extra.RESULT_RECEIVER"";
    private static final String SERVICE_COMPONENT_EXTRA =
            ""android.net.wifi.cts.app.extra.SERVICE_COMPONENT"";

    private static ResultReceiver convertToGeneric(ResultReceiver receiver) {
        Parcel parcel = Parcel.obtain();
        receiver.writeToParcel(parcel,0);
        parcel.setDataPosition(0);
        ResultReceiver receiverGeneric = ResultReceiver.CREATOR.createFromParcel(parcel);
        parcel.recycle();
        return receiverGeneric;
    }

    public void startServiceToWaitForResult(@NonNull ComponentName serviceComponent) {
        mLatch = new CountDownLatch(1);
        synchronized (mStatusLock) {
            mStatus = false;
        }
        ResultReceiver resultReceiver = new ResultReceiver(null) {
            @Override
            public void onReceiveResult(int resultCode, Bundle data) {
                synchronized (mStatusLock) {
                    mStatus = resultCode == 1;
                }
                mLatch.countDown();
            }
        };
        Intent intent = new Intent()
                .setComponent(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                        WIFI_LOCATION_TEST_APP_SCHEDULE_JOB_ACTIVITY))
                .putExtra(RESULT_RECEIVER_EXTRA, convertToGeneric(resultReceiver))
                .putExtra(SERVICE_COMPONENT_EXTRA, serviceComponent);
        startActivity(intent);
    }

    @NonNull
    public boolean waitForServiceResult(long timeoutMillis)
            throws InterruptedException {
        assertThat(mLatch.await(timeoutMillis, TimeUnit.MILLISECONDS)).isTrue();
        synchronized (mStatusLock) {
            return mStatus;
        }
    }

}"	""	""	"flag"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.ComponentName;
import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SdkSuppress;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests location sensitive APIs exposed by Wi-Fi.
 * Ensures that permissions on these APIs are properly enforced.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class WifiLocationInfoTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiLocationInfoTest"";

    private static final String WIFI_LOCATION_TEST_APP_APK_PATH =
            ""/data/local/tmp/cts/wifi/CtsWifiLocationTestApp.apk"";
    private static final String WIFI_LOCATION_TEST_APP_PACKAGE_NAME =
            ""android.net.wifi.cts.app"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveTransportInfoAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveTransportInfoAndReturnStatusService"";

    private static final int DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    @Rule
    public final ActivityTestRule<WaitForResultActivity> mActivityRule =
            new ActivityTestRule<>(WaitForResultActivity.class);

    private Context mContext;
    private WifiManager mWifiManager;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        installApp(WIFI_LOCATION_TEST_APP_APK_PATH);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", DURATION_MS, () -> mWifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;

        uninstallApp(WIFI_LOCATION_TEST_APP_PACKAGE_NAME);

        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        // now trigger the change using shell commands.
        SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
    }

    private void turnScreenOn() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(
                ""input keyevent KEYCODE_WAKEUP"");
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(""""
                + ""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(2_000);
    }

    private void turnScreenOff() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(
                ""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(2_000);
    }

    private void installApp(String apk) throws InterruptedException {
        String installResult = SystemUtil.runShellCommand(""pm install -r -d "" + apk);
        Thread.sleep(10_000);
        assertThat(installResult.trim()).isEqualTo(""Success"");
    }

    private void uninstallApp(String pkg) throws InterruptedException {
        String uninstallResult = SystemUtil.runShellCommand(
                ""pm uninstall "" + pkg);
        Thread.sleep(10_000);
        assertThat(uninstallResult.trim()).isEqualTo(""Success"");
    }

    private void startFgActivityAndAssertStatusIs(
            ComponentName componentName, boolean status) throws Exception {
        turnScreenOn();

        WaitForResultActivity activity = mActivityRule.getActivity();
        activity.startActivityToWaitForResult(componentName);
        assertThat(activity.waitForActivityResult(DURATION_MS)).isEqualTo(status);
    }

    private void startBgServiceAndAssertStatusIs(
            ComponentName componentName, boolean status) throws Exception {
        turnScreenOff();

        WaitForResultActivity activity = mActivityRule.getActivity();
        activity.startServiceToWaitForResult(componentName);
        assertThat(activity.waitForServiceResult(DURATION_MS)).isEqualTo(status);
    }

    private void triggerScanFgActivityAndAssertStatusIs(boolean status) throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY), status);
    }

    private void triggerScanBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE), status);
    }

    private void retrieveScanResultsFgActivityAndAssertStatusIs(boolean status) throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY), status);
    }

    private void retrieveScanResultsBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE), status);
    }

    private void retrieveConnectionInfoFgActivityAndAssertStatusIs(boolean status)
            throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY), status);
    }

    private void retrieveConnectionInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE), status);
    }

    private void retrieveTransportInfoFgActivityAndAssertStatusIs(boolean status)
            throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_ACTIVITY), status);
    }

    private void retrieveTransportInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE), status);
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiConfigurationTest"	"testWifiConfiguration"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiConfigurationTest.java"	""	"public void testWifiConfiguration() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        List<WifiConfiguration> wifiConfigurations = mWifiManager.getConfiguredNetworks();
        if (wifiConfigurations != null) {
            for (int i = 0; i < wifiConfigurations.size(); i++) {
                WifiConfiguration wifiConfiguration = wifiConfigurations.get(i);
                assertNotNull(wifiConfiguration);
                assertNotNull(wifiConfiguration.toString());
            }
        }
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultProperties() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // this test case should in Wifi environment
        for (ScanResult scanResult : mWifiManager.getScanResults()) {
            assertThat(scanResult.toString()).isNotNull();

            for (InformationElement ie : scanResult.getInformationElements()) {
                testInformationElementCopyConstructor(ie);
                testInformationElementFields(ie);
            }

            assertThat(scanResult.getWifiStandard()).isAnyOf(
                    ScanResult.WIFI_STANDARD_UNKNOWN,
                    ScanResult.WIFI_STANDARD_LEGACY,
                    ScanResult.WIFI_STANDARD_11N,
                    ScanResult.WIFI_STANDARD_11AC,
                    ScanResult.WIFI_STANDARD_11AX
            );

            scanResult.isPasspointNetwork();
        }
    }

    private void testInformationElementCopyConstructor(InformationElement ie) {
        InformationElement copy = new InformationElement(ie);

        assertThat(copy.getId()).isEqualTo(ie.getId());
        assertThat(copy.getIdExt()).isEqualTo(ie.getIdExt());
        assertThat(copy.getBytes()).isEqualTo(ie.getBytes());
    }

    private void testInformationElementFields(InformationElement ie) {
        // id is 1 octet
        int id = ie.getId();
        assertThat(id).isAtLeast(0);
        assertThat(id).isAtMost(255);

        // idExt is 0 or 1 octet
        int idExt = ie.getIdExt();
        assertThat(idExt).isAtLeast(0);
        assertThat(idExt).isAtMost(255);

        ByteBuffer bytes = ie.getBytes();
        assertThat(bytes).isNotNull();
    }

    /* Multiple scans to ensure bssid is updated */
    private void scanAndWait() throws Exception {
        synchronized (mMySync) {
            for (int retry  = 0; retry < SCAN_MAX_RETRY_COUNT; retry++) {
                mMySync.expectedState = STATE_START_SCAN;
                mWifiManager.startScan();
                if (waitForBroadcast(SCAN_WAIT_MSEC, STATE_SCAN_RESULTS_AVAILABLE)) {
                    break;
                }
            }
        }
   }

    @VirtualDeviceNotSupported"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import java.nio.ByteBuffer;
import java.util.List;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.ScanResult;
import android.net.wifi.ScanResult.InformationElement;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.WifiLock;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class ScanResultTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_CHANGED = 2;
    private static final int STATE_START_SCAN = 3;
    private static final int STATE_SCAN_RESULTS_AVAILABLE = 4;
    private static final int STATE_SCAN_FAILURE = 5;

    private static final String TAG = ""WifiInfoTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int ENABLE_WAIT_MSEC = 10000;
    private static final int SCAN_WAIT_MSEC = 10000;
    private static final int SCAN_MAX_RETRY_COUNT = 6;
    private static final int SCAN_FIND_BSSID_MAX_RETRY_COUNT = 5;
    private static final long SCAN_FIND_BSSID_WAIT_MSEC = 5_000L;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    private static final String TEST_SSID = ""TEST_SSID"";
    public static final String TEST_BSSID = ""04:ac:fe:45:34:10"";
    public static final String TEST_CAPS = ""CCMP"";
    public static final int TEST_LEVEL = -56;
    public static final int TEST_FREQUENCY = 2412;
    public static final long TEST_TIMESTAMP = 4660L;

    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.expectedState = STATE_WIFI_CHANGED;
                    mMySync.notify();
                }
            } else if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {
                synchronized (mMySync) {
                    if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {
                        mMySync.expectedState = STATE_SCAN_RESULTS_AVAILABLE;
                    } else {
                        mMySync.expectedState = STATE_SCAN_FAILURE;
                    }
                    mMySync.notify();
                }
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertThat(mWifiManager).isNotNull();

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", ENABLE_WAIT_MSEC,
                () -> mWifiManager.isWifiEnabled());

        mMySync.expectedState = STATE_NULL;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
        Thread.sleep(ENABLE_WAIT_MSEC);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_WIFI_CHANGING;
            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }
            waitForBroadcast(TIMEOUT_MSEC, STATE_WIFI_CHANGED);
       }
    }

    private boolean waitForBroadcast(long timeout, int expectedState) throws Exception {
        long waitTime = System.currentTimeMillis() + timeout;
        while (System.currentTimeMillis() < waitTime
                && mMySync.expectedState != expectedState)
            mMySync.wait(WAIT_MSEC);
        return mMySync.expectedState == expectedState;
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultTimeStamp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultTimeStamp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        long timestamp = 0;
        String BSSID = null;

        scanAndWait();

        List<ScanResult> scanResults = mWifiManager.getScanResults();
        for (ScanResult result : scanResults) {
            BSSID = result.BSSID;
            timestamp = result.timestamp;
            assertThat(timestamp).isNotEqualTo(0);
            break;
        }

        scanAndWait();

        scanResults = mWifiManager.getScanResults();
        for (ScanResult result : scanResults) {
            if (result.BSSID.equals(BSSID)) {
                long timeDiff = (result.timestamp - timestamp) / 1000;
                assertThat(timeDiff).isGreaterThan(0L);
                assertThat(timeDiff).isLessThan(6L * SCAN_WAIT_MSEC);
            }
        }
    }

    /** Test that the copy constructor copies fields correctly. */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultConstructors"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultConstructors() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.BSSID = TEST_BSSID;
        scanResult.capabilities = TEST_CAPS;
        scanResult.level = TEST_LEVEL;
        scanResult.frequency = TEST_FREQUENCY;
        scanResult.timestamp = TEST_TIMESTAMP;

        ScanResult scanResult2 = new ScanResult(scanResult);
        assertThat(scanResult2.SSID).isEqualTo(TEST_SSID);
        assertThat(scanResult2.BSSID).isEqualTo(TEST_BSSID);
        assertThat(scanResult2.capabilities).isEqualTo(TEST_CAPS);
        assertThat(scanResult2.level).isEqualTo(TEST_LEVEL);
        assertThat(scanResult2.frequency).isEqualTo(TEST_FREQUENCY);
        assertThat(scanResult2.timestamp).isEqualTo(TEST_TIMESTAMP);
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultMatchesWifiInfo"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultMatchesWifiInfo() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        final WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
        assertThat(wifiInfo).isNotNull();

        ScanResult currentNetwork = null;
        for (int i = 0; i < SCAN_FIND_BSSID_MAX_RETRY_COUNT; i++) {
            scanAndWait();
            final List<ScanResult> scanResults = mWifiManager.getScanResults();
            currentNetwork = scanResults.stream().filter(r -> r.BSSID.equals(wifiInfo.getBSSID()))
                    .findAny().orElse(null);

            if (currentNetwork != null) {
                break;
            }
            Thread.sleep(SCAN_FIND_BSSID_WAIT_MSEC);
        }
        assertWithMessage(""Current network not found in scan results"")
                .that(currentNetwork).isNotNull();

        String wifiInfoSsidQuoted = wifiInfo.getSSID();
        String scanResultSsidUnquoted = currentNetwork.SSID;

        assertWithMessage(
                ""SSID mismatch: make sure this isn't a hidden network or an SSID containing ""
                        + ""non-UTF-8 characters - neither is supported by this CTS test."")
                .that(""\"""" + scanResultSsidUnquoted + ""\"""")
                .isEqualTo(wifiInfoSsidQuoted);
        assertThat(currentNetwork.frequency).isEqualTo(wifiInfo.getFrequency());
    }
}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testCanRestoreBackupData"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"public void testCanRestoreBackupData() {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        WifiConfiguration origNetwork = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();

            // Pick a regular saved network to modify (non-enterprise, non-Passpoint)
            origNetwork = mWifiManager.getConfiguredNetworks().stream()
                    .filter(n -> {
                        boolean canOverrideConfig = mContext.checkPermission(
                                android.Manifest.permission.OVERRIDE_WIFI_CONFIG, -1, n.creatorUid)
                                == PERMISSION_GRANTED;
                        return canOverrideConfig && !isEnterprise(n) && !n.isPasspoint();
                    })
                    .findAny()
                    .orElse(null);
            if (origNetwork == null) {
                Log.e(TAG, ""Need a non-enterprise and non-Passpoint network created by an app ""
                        + ""holding OVERRIDE_WIFI_CONFIG permission to fully evaluate the ""
                        + ""functionality"");
            }

            // Retrieve backup data.
            byte[] backupData = mWifiManager.retrieveBackupData();

            if (origNetwork != null) {
                // Modify the metered bit.
                final String origNetworkSsid = origNetwork.SSID;
                WifiConfiguration modNetwork = new WifiConfiguration(origNetwork);
                flipMeteredOverride(modNetwork);
                int networkId = mWifiManager.updateNetwork(modNetwork);
                assertThat(networkId).isEqualTo(origNetwork.networkId);
                assertThat(mWifiManager.getConfiguredNetworks()
                        .stream()
                        .filter(n -> n.SSID.equals(origNetworkSsid))
                        .findAny()
                        .get().meteredOverride)
                        .isNotEqualTo(origNetwork.meteredOverride);
            }

            // Restore the original backup data & ensure that the metered bit is back to orig.
            mWifiManager.restoreBackupData(backupData);

            if (origNetwork != null) {
                final String origNetworkSsid = origNetwork.SSID;
                assertThat(mWifiManager.getConfiguredNetworks()
                        .stream()
                        .filter(n -> n.SSID.equals(origNetworkSsid))
                        .findAny()
                        .get().meteredOverride)
                        .isEqualTo(origNetwork.meteredOverride);
            }
        } finally {
            // Restore the orig network
            if (origNetwork != null) {
                mWifiManager.updateNetwork(origNetwork);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests for {@link WifiManager#retrieveSoftApBackupData()} &
     * {@link WifiManager#restoreSoftApBackupData(byte[])}
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.content.pm.PackageManager.PERMISSION_GRANTED;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_METERED;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NONE;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NOT_METERED;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.app.UiAutomation;
import android.content.Context;
import android.net.IpConfiguration;
import android.net.LinkAddress;
import android.net.ProxyInfo;
import android.net.StaticIpConfiguration;
import android.net.Uri;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Log;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Tests for wifi backup/restore functionality.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class WifiBackupRestoreTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiBackupRestoreTest"";
    private static final String LEGACY_SUPP_CONF_FILE =
            ""assets/BackupLegacyFormatSupplicantConf.txt"";
    private static final String LEGACY_IP_CONF_FILE =
            ""assets/BackupLegacyFormatIpConf.txt"";
    private static final String V1_0_FILE = ""assets/BackupV1.0Format.xml"";
    private static final String V1_1_FILE = ""assets/BackupV1.1Format.xml"";
    private static final String V1_2_FILE = ""assets/BackupV1.2Format.xml"";

    public static final String EXPECTED_LEGACY_STATIC_IP_LINK_ADDRESS = ""192.168.48.2"";
    public static final int EXPECTED_LEGACY_STATIC_IP_LINK_PREFIX_LENGTH = 8;
    public static final String EXPECTED_LEGACY_STATIC_IP_GATEWAY_ADDRESS = ""192.168.48.1"";
    public static final String[] EXPECTED_LEGACY_STATIC_IP_DNS_SERVER_ADDRESSES =
            new String[]{""192.168.48.1"", ""192.168.48.10""};
    public static final String EXPECTED_LEGACY_STATIC_PROXY_HOST = ""192.168.48.1"";
    public static final int EXPECTED_LEGACY_STATIC_PROXY_PORT = 8000;
    public static final String EXPECTED_LEGACY_STATIC_PROXY_EXCLUSION_LIST = """";
    public static final String EXPECTED_LEGACY_PAC_PROXY_LOCATION = ""http://"";

    private Context mContext;
    private WifiManager mWifiManager;
    private UiDevice mUiDevice;
    private boolean mWasVerboseLoggingEnabled;

    private static final int DURATION = 10_000;
    private static final int DURATION_SCREEN_TOGGLE = 2000;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        turnScreenOn();
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());

        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        turnScreenOff();
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        // now trigger the change using shell commands.
        SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
    }

    private void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void flipMeteredOverride(WifiConfiguration network) {
        if (network.meteredOverride == METERED_OVERRIDE_NONE) {
            network.meteredOverride = METERED_OVERRIDE_METERED;
        } else if (network.meteredOverride == METERED_OVERRIDE_METERED) {
            network.meteredOverride = METERED_OVERRIDE_NOT_METERED;
        } else if (network.meteredOverride == METERED_OVERRIDE_NOT_METERED) {
            network.meteredOverride = METERED_OVERRIDE_NONE;
        }
    }

    /** WifiConfiguration#isEnterprise() is @hide, so copy/paste partial implementation here. */
    private static boolean isEnterprise(WifiConfiguration config) {
        WifiEnterpriseConfig enterpriseConfig = config.enterpriseConfig;
        return enterpriseConfig != null
                && enterpriseConfig.getEapMethod() != WifiEnterpriseConfig.Eap.NONE;
    }

    /**
     * Tests for {@link WifiManager#retrieveBackupData()} &
     * {@link WifiManager#restoreBackupData(byte[])}
     * Note: If the network was not created by an app with OVERRIDE_WIFI_CONFIG permission (held
     * by AOSP settings app for example), then the backup data will not contain that network. If
     * the device does not contain any such pre-existing saved network, then this test will be
     * a no-op, will only ensure that the device does not crash when invoking the API's.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.NetworkSpecifier;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.os.PatternMatcher;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Pair;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a
 * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,
 * ConnectivityManager.NetworkCallback)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class WifiNetworkSpecifierTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiNetworkSpecifierTest"";

    private static final String CA_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIICTzCCAdSgAwIBAgIUdnLttwNPnQzFufplGOr9bTrGCqMwCgYIKoZIzj0EAwMw\n""
                    + ""XjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNV\n""
                    + ""BAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0Q0Ew\n""
                    + ""HhcNMjAwNzIxMDIyNDA1WhcNMzAwNTMwMDIyNDA1WjBeMQswCQYDVQQGEwJVUzEL\n""
                    + ""MAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEOMAwG\n""
                    + ""A1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTB2MBAGByqGSM49AgEGBSuB\n""
                    + ""BAAiA2IABFmntXwk9icqhDQFUP1xy04WyEpaGW4q6Q+8pujlSl/X3iotPZ++GZfp\n""
                    + ""Mfv3YDHDBl6sELPQ2BEjyPXmpsKjOUdiUe69e88oGEdeqT2xXiQ6uzpTfJD4170i\n""
                    + ""O/TwLrQGKKNTMFEwHQYDVR0OBBYEFCjptsX3g4g5W0L4oEP6N3gfyiZXMB8GA1Ud\n""
                    + ""IwQYMBaAFCjptsX3g4g5W0L4oEP6N3gfyiZXMA8GA1UdEwEB/wQFMAMBAf8wCgYI\n""
                    + ""KoZIzj0EAwMDaQAwZgIxAK61brUYRbLmQKiaEboZgrHtnPAcGo7Yzx3MwHecx3Dm\n""
                    + ""5soIeLVYc8bPYN1pbhXW1gIxALdEe2sh03nBHyQH4adYoZungoCwt8mp/7sJFxou\n""
                    + ""9UnRegyBgGzf74ROWdpZHzh+Pg==\n""
                    + ""-----END CERTIFICATE-----\n"";
    public static final X509Certificate CA_SUITE_B_ECDSA_CERT =
            loadCertificate(CA_SUITE_B_ECDSA_CERT_STRING);

    private static final String CLIENT_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIB9zCCAX4CFDpfSZh3AH07BEfGWuMDa7Ynz6y+MAoGCCqGSM49BAMDMF4xCzAJ\n""
                    + ""BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQKDAdB\n""
                    + ""bmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4XDTIw\n""
                    + ""MDcyMTAyMjk1MFoXDTMwMDUzMDAyMjk1MFowYjELMAkGA1UEBhMCVVMxCzAJBgNV\n""
                    + ""BAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsM\n""
                    + ""BVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MHYwEAYHKoZIzj0CAQYFK4EE\n""
                    + ""ACIDYgAEhxhVJ7dcSqrto0X+dgRxtd8BWG8cWmPjBji3MIxDLfpcMDoIB84ae1Ew\n""
                    + ""gJn4YUYHrWsUDiVNihv8j7a/Ol1qcIY2ybH7tbezefLmagqA4vXEUXZXoUyL4ZNC\n""
                    + ""DWcdw6LrMAoGCCqGSM49BAMDA2cAMGQCMH4aP73HrriRUJRguiuRic+X4Cqj/7YQ\n""
                    + ""ueJmP87KF92/thhoQ9OrRo8uJITPmNDswwIwP2Q1AZCSL4BI9dYrqu07Ar+pSkXE\n""
                    + ""R7oOqGdZR+d/MvXcFSrbIaLKEoHXmQamIHLe\n""
                    + ""-----END CERTIFICATE-----\n"";
    public static final X509Certificate CLIENT_SUITE_B_ECDSA_CERT =
            loadCertificate(CLIENT_SUITE_B_ECDSA_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_ECC_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x81, (byte) 0xb6, (byte) 0x02, (byte) 0x01, (byte) 0x00,
            (byte) 0x30, (byte) 0x10, (byte) 0x06, (byte) 0x07, (byte) 0x2a, (byte) 0x86,
            (byte) 0x48, (byte) 0xce, (byte) 0x3d, (byte) 0x02, (byte) 0x01, (byte) 0x06,
            (byte) 0x05, (byte) 0x2b, (byte) 0x81, (byte) 0x04, (byte) 0x00, (byte) 0x22,
            (byte) 0x04, (byte) 0x81, (byte) 0x9e, (byte) 0x30, (byte) 0x81, (byte) 0x9b,
            (byte) 0x02, (byte) 0x01, (byte) 0x01, (byte) 0x04, (byte) 0x30, (byte) 0xea,
            (byte) 0x6c, (byte) 0x4b, (byte) 0x6d, (byte) 0x43, (byte) 0xf9, (byte) 0x6c,
            (byte) 0x91, (byte) 0xdc, (byte) 0x2d, (byte) 0x6e, (byte) 0x87, (byte) 0x4f,
            (byte) 0x0a, (byte) 0x0b, (byte) 0x97, (byte) 0x25, (byte) 0x1c, (byte) 0x79,
            (byte) 0xa2, (byte) 0x07, (byte) 0xdc, (byte) 0x94, (byte) 0xc2, (byte) 0xee,
            (byte) 0x64, (byte) 0x51, (byte) 0x6d, (byte) 0x4e, (byte) 0x35, (byte) 0x1c,
            (byte) 0x22, (byte) 0x2f, (byte) 0xc0, (byte) 0xea, (byte) 0x09, (byte) 0x47,
            (byte) 0x3e, (byte) 0xb9, (byte) 0xb6, (byte) 0xb8, (byte) 0x83, (byte) 0x9e,
            (byte) 0xed, (byte) 0x59, (byte) 0xe5, (byte) 0xe7, (byte) 0x0f, (byte) 0xa1,
            (byte) 0x64, (byte) 0x03, (byte) 0x62, (byte) 0x00, (byte) 0x04, (byte) 0x87,
            (byte) 0x18, (byte) 0x55, (byte) 0x27, (byte) 0xb7, (byte) 0x5c, (byte) 0x4a,
            (byte) 0xaa, (byte) 0xed, (byte) 0xa3, (byte) 0x45, (byte) 0xfe, (byte) 0x76,
            (byte) 0x04, (byte) 0x71, (byte) 0xb5, (byte) 0xdf, (byte) 0x01, (byte) 0x58,
            (byte) 0x6f, (byte) 0x1c, (byte) 0x5a, (byte) 0x63, (byte) 0xe3, (byte) 0x06,
            (byte) 0x38, (byte) 0xb7, (byte) 0x30, (byte) 0x8c, (byte) 0x43, (byte) 0x2d,
            (byte) 0xfa, (byte) 0x5c, (byte) 0x30, (byte) 0x3a, (byte) 0x08, (byte) 0x07,
            (byte) 0xce, (byte) 0x1a, (byte) 0x7b, (byte) 0x51, (byte) 0x30, (byte) 0x80,
            (byte) 0x99, (byte) 0xf8, (byte) 0x61, (byte) 0x46, (byte) 0x07, (byte) 0xad,
            (byte) 0x6b, (byte) 0x14, (byte) 0x0e, (byte) 0x25, (byte) 0x4d, (byte) 0x8a,
            (byte) 0x1b, (byte) 0xfc, (byte) 0x8f, (byte) 0xb6, (byte) 0xbf, (byte) 0x3a,
            (byte) 0x5d, (byte) 0x6a, (byte) 0x70, (byte) 0x86, (byte) 0x36, (byte) 0xc9,
            (byte) 0xb1, (byte) 0xfb, (byte) 0xb5, (byte) 0xb7, (byte) 0xb3, (byte) 0x79,
            (byte) 0xf2, (byte) 0xe6, (byte) 0x6a, (byte) 0x0a, (byte) 0x80, (byte) 0xe2,
            (byte) 0xf5, (byte) 0xc4, (byte) 0x51, (byte) 0x76, (byte) 0x57, (byte) 0xa1,
            (byte) 0x4c, (byte) 0x8b, (byte) 0xe1, (byte) 0x93, (byte) 0x42, (byte) 0x0d,
            (byte) 0x67, (byte) 0x1d, (byte) 0xc3, (byte) 0xa2, (byte) 0xeb
    };
    public static final PrivateKey CLIENT_SUITE_B_ECC_KEY =
            loadPrivateKey(""EC"", CLIENT_SUITE_B_ECC_KEY_DATA);

    private static X509Certificate loadCertificate(String blob) {
        try {
            final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            InputStream stream = new ByteArrayInputStream(blob.getBytes(StandardCharsets.UTF_8));

            return (X509Certificate) certFactory.generateCertificate(stream);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PrivateKey loadPrivateKey(String algorithm, byte[] fakeKey) {
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            return kf.generatePrivate(new PKCS8EncodedKeySpec(fakeKey));
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            return null;
        }
    }

    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static WifiConfiguration sTestNetwork;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private ConnectivityManager.NetworkCallback mNrNetworkCallback;
    private TestHelper mTestHelper;

    private static final int DURATION = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> wifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.getPrivilegedConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"")
                .that(savedNetworks.isEmpty()).isFalse();

        // Pick any network in range.
        sTestNetwork = TestHelper.findMatchingSavedNetworksWithBssid(wifiManager, savedNetworks)
                .get(0);
    }

    private static void enableAllSavedNetworks(@NonNull WifiManager wifiManager) {
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : wifiManager.getConfiguredNetworks()) {
                        wifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
    }

    private static void disableAllSavedNetworks(@NonNull WifiManager wifiManager) {
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : wifiManager.getConfiguredNetworks()) {
                        wifiManager.disableNetwork(savedNetwork.networkId);
                    }
                });
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }

        // Re-enable networks.
        enableAllSavedNetworks(wifiManager);

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mTestHelper = new TestHelper(mContext, mUiDevice);

        assumeTrue(WifiFeature.isWifiSupported(mContext));

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.allowAutojoinGlobal(false));
        disableAllSavedNetworks(mWifiManager);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.allowAutojoinGlobal(true));

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // If there is failure, ensure we unregister the previous request.
        if (mNrNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        }
        // Clear any existing app state after each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }
        mTestHelper.turnScreenOff();
    }

    private void testSuccessfulConnectionWithSpecifier(WifiNetworkSpecifier specifier)
            throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                sTestNetwork, specifier, false);
    }

    private void testUserRejectionWithSpecifier(WifiNetworkSpecifier specifier)
            throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                sTestNetwork, specifier, true);
    }

    /**
     * Tests the entire connection flow using a specific SSID in the specifier.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"ProvisioningCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_SAP;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_STA;
import static android.net.wifi.WifiConfiguration.INVALID_NETWORK_ID;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_SOFTAP;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_AWARE;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_DIRECT;
import static android.net.wifi.WifiScanner.WIFI_BAND_24_GHZ;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertNotEquals;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TetheringManager;
import android.net.Uri;
import android.net.wifi.CoexUnsafeChannel;
import android.net.wifi.ScanResult;
import android.net.wifi.SoftApCapability;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.SoftApInfo;
import android.net.wifi.WifiAvailableChannel;
import android.net.wifi.WifiClient;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.SubsystemRestartTrackingCallback;
import android.net.wifi.WifiManager.WifiLock;
import android.net.wifi.WifiNetworkConnectionStatistics;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.ConfigParser;
import android.net.wifi.hotspot2.OsuProvider;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.ProvisioningCallback;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;
import android.os.Process;
import android.os.SystemClock;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;
import android.provider.Settings;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.ArraySet;
import android.util.Log;
import android.util.SparseArray;
import android.util.SparseIntArray;

import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;
import com.android.modules.utils.build.SdkLevel;
import com.android.net.module.util.MacAddressUtils;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class WifiManagerTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private TetheringManager mTetheringManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private List<ScanResult> mScanResults = null;
    private NetworkInfo mNetworkInfo =
            new NetworkInfo(ConnectivityManager.TYPE_WIFI, TelephonyManager.NETWORK_TYPE_UNKNOWN,
                    ""wifi"", ""unknown"");
    private final Object mLock = new Object();
    private UiDevice mUiDevice;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;
    private SoftApConfiguration mOriginalSoftApConfig = null;

    // Please refer to WifiManager
    private static final int MIN_RSSI = -100;
    private static final int MAX_RSSI = -55;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_ENABLED = 2;
    private static final int STATE_WIFI_DISABLED = 3;
    private static final int STATE_SCANNING = 4;
    private static final int STATE_SCAN_DONE = 5;

    private static final String TAG = ""WifiManagerTest"";
    private static final String SSID1 = ""\""WifiManagerTest\"""";
    // A full single scan duration is about 6-7 seconds if country code is set
    // to US. If country code is set to world mode (00), we would expect a scan
    // duration of roughly 8 seconds. So we set scan timeout as 9 seconds here.
    private static final int SCAN_TEST_WAIT_DURATION_MS = 9000;
    private static final int TEST_WAIT_DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int DURATION_SETTINGS_TOGGLE = 1_000;
    private static final int WIFI_SCAN_TEST_CACHE_DELAY_MILLIS = 3 * 60 * 1000;

    private static final int ENFORCED_NUM_NETWORK_SUGGESTIONS_PER_APP = 50;

    private static final String TEST_PAC_URL = ""http://www.example.com/proxy.pac"";
    private static final String MANAGED_PROVISIONING_PACKAGE_NAME
            = ""com.android.managedprovisioning"";

    private static final String TEST_SSID_UNQUOTED = ""testSsid1"";
    private static final String TEST_IP_ADDRESS = ""192.168.5.5"";
    private static final String TEST_MAC_ADDRESS = ""aa:bb:cc:dd:ee:ff"";
    private static final MacAddress TEST_MAC = MacAddress.fromString(TEST_MAC_ADDRESS);
    private static final String TEST_PASSPHRASE = ""passphrase"";
    private static final String PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT =
            ""assets/ValidPasspointProfile.base64"";
    private static final String TYPE_WIFI_CONFIG = ""application/x-wifi-config"";
    private static final String TEST_PSK_CAP = ""[RSN-PSK-CCMP]"";
    private static final String TEST_BSSID = ""00:01:02:03:04:05"";
    private static final String TEST_COUNTRY_CODE = ""JP"";
    private static final String TEST_DOM_SUBJECT_MATCH = ""domSubjectMatch"";
    private static final int TEST_SUB_ID = 2;

    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {

                synchronized (mMySync) {
                    if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {
                        mScanResults = mWifiManager.getScanResults();
                    } else {
                        mScanResults = null;
                    }
                    mMySync.expectedState = STATE_SCAN_DONE;
                    mMySync.notifyAll();
                }
            } else if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                int newState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
                        WifiManager.WIFI_STATE_UNKNOWN);
                synchronized (mMySync) {
                    if (newState == WifiManager.WIFI_STATE_ENABLED) {
                        Log.d(TAG, ""*** New WiFi state is ENABLED ***"");
                        mMySync.expectedState = STATE_WIFI_ENABLED;
                        mMySync.notifyAll();
                    } else if (newState == WifiManager.WIFI_STATE_DISABLED) {
                        Log.d(TAG, ""*** New WiFi state is DISABLED ***"");
                        mMySync.expectedState = STATE_WIFI_DISABLED;
                        mMySync.notifyAll();
                    }
                }
            } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mNetworkInfo =
                            (NetworkInfo) intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
                    if (mNetworkInfo.getState() == NetworkInfo.State.CONNECTED)
                        mMySync.notifyAll();
                }
            }
        }
    };
    // Initialize with an invalid status value (0)
    private int mProvisioningStatus = 0;
    // Initialize with an invalid status value (0)
    private int mProvisioningFailureStatus = 0;
    private boolean mProvisioningComplete = false;
    private ProvisioningCallback mProvisioningCallback = new ProvisioningCallback() {
        @Override
        public void onProvisioningFailure(int status) {
            synchronized (mLock) {
                mProvisioningFailureStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningStatus(int status) {
            synchronized (mLock) {
                mProvisioningStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningComplete() {
            mProvisioningComplete = true;
        }
    };
    private int mSubsystemRestartStatus = 0; // 0: nada, 1: restarting, 2: restarted
    private SubsystemRestartTrackingCallback mSubsystemRestartTrackingCallback =
            new SubsystemRestartTrackingCallback() {
                @Override
                public void onSubsystemRestarting() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 1;
                        mLock.notify();
                    }
                }

                @Override
                public void onSubsystemRestarted() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 2;
                        mLock.notify();
                    }
                }
            };
    private static final String TEST_SSID = ""TEST SSID"";
    private static final String TEST_FRIENDLY_NAME = ""Friendly Name"";
    private static final Map<String, String> TEST_FRIENDLY_NAMES =
            new HashMap<String, String>() {
                {
                    put(""en"", TEST_FRIENDLY_NAME);
                    put(""kr"", TEST_FRIENDLY_NAME + 2);
                    put(""jp"", TEST_FRIENDLY_NAME + 3);
                }
            };
    private static final String TEST_SERVICE_DESCRIPTION = ""Dummy Service"";
    private static final Uri TEST_SERVER_URI = Uri.parse(""https://test.com"");
    private static final String TEST_NAI = ""test.access.com"";
    private static final List<Integer> TEST_METHOD_LIST =
            Arrays.asList(1 /* METHOD_SOAP_XML_SPP */);
    private final HandlerThread mHandlerThread = new HandlerThread(""WifiManagerTest"");
    protected final Executor mExecutor;
    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = getContext().getSystemService(ConnectivityManager.class);
        mTetheringManager = getContext().getSystemService(TetheringManager.class);
        assertNotNull(mWifiManager);
        assertNotNull(mTetheringManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", TEST_WAIT_DURATION_MS,
                () -> mWifiManager.isWifiEnabled());

        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        turnScreenOnNoDelay();

        synchronized (mMySync) {
            mMySync.expectedState = STATE_NULL;
        }

        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        assertFalse(""Need at least one saved network"", savedNetworks.isEmpty());

        // Get original config for restore
        mOriginalSoftApConfig = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getSoftApConfiguration);
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
        // restore original softap config
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setSoftApConfiguration(mOriginalSoftApConfig));
        Thread.sleep(TEST_WAIT_DURATION_MS);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            if (mWifiManager.isWifiEnabled() != enable) {
                // the new state is different, we expect it to change
                mMySync.expectedState = STATE_WIFI_CHANGING;
            } else {
                mMySync.expectedState = (enable ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            }
            // now trigger the change using shell commands.
            SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
            waitForExpectedWifiState(enable);
        }
    }

    private void waitForExpectedWifiState(boolean enabled) throws InterruptedException {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS;
            int expected = (enabled ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            while (System.currentTimeMillis() < timeout
                    && mMySync.expectedState != expected) {
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    // Get the current scan status from sticky broadcast.
    private boolean isScanCurrentlyAvailable() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED);
        Intent intent = mContext.registerReceiver(null, intentFilter);
        assertNotNull(intent);
        if (intent.getAction().equals(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED)) {
            return intent.getBooleanExtra(WifiManager.EXTRA_SCAN_AVAILABLE, false);
        }
        return false;
    }

    private void startScan() throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_SCANNING;
            mScanResults = null;
            assertTrue(mWifiManager.startScan());
            long timeout = System.currentTimeMillis() + SCAN_TEST_WAIT_DURATION_MS;
            while (System.currentTimeMillis() < timeout && mMySync.expectedState == STATE_SCANNING)
                mMySync.wait(WAIT_MSEC);
        }
    }

    private void waitForNetworkInfoState(NetworkInfo.State state, int timeoutMillis)
            throws Exception {
        synchronized (mMySync) {
            if (mNetworkInfo.getState() == state) return;
            long timeout = System.currentTimeMillis() + timeoutMillis;
            while (System.currentTimeMillis() < timeout
                    && mNetworkInfo.getState() != state)
                mMySync.wait(WAIT_MSEC);
            assertEquals(state, mNetworkInfo.getState());
        }
    }

    private void waitForConnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.CONNECTED, WIFI_CONNECT_TIMEOUT_MILLIS);
    }

    private void waitForDisconnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.DISCONNECTED, TEST_WAIT_DURATION_MS);
    }

    private void ensureNotNetworkInfoState(NetworkInfo.State state) throws Exception {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS + WAIT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                assertNotEquals(state, mNetworkInfo.getState());
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    private void ensureNotConnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.CONNECTED);
    }

    private void ensureNotDisconnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.DISCONNECTED);
    }

    private boolean existSSID(String ssid) {
        for (final WifiConfiguration w : mWifiManager.getConfiguredNetworks()) {
            if (w.SSID.equals(ssid))
                return true;
        }
        return false;
    }

    private int findConfiguredNetworks(String SSID, List<WifiConfiguration> networks) {
        for (final WifiConfiguration w : networks) {
            if (w.SSID.equals(SSID))
                return networks.indexOf(w);
        }
        return -1;
    }

    /**
     * Test creation of WifiManager Lock.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotWithNullBssidConfig"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartLocalOnlyHotspotWithNullBssidConfig() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        SoftApConfiguration customConfig = new SoftApConfiguration.Builder()
                .setSsid(TEST_SSID_UNQUOTED)
                .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                .build();
        TestExecutor executor = new TestExecutor();
        TestLocalOnlyHotspotCallback callback = new TestLocalOnlyHotspotCallback(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        boolean wifiEnabled = mWifiManager.isWifiEnabled();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            mWifiManager.startLocalOnlyHotspot(customConfig, executor, callback);
            // now wait for callback
            Thread.sleep(TEST_WAIT_DURATION_MS);

            // Verify callback is run on the supplied executor
            assertFalse(callback.onStartedCalled);
            executor.runAll();
            assertTrue(callback.onStartedCalled);

            assertNotNull(callback.reservation);
            SoftApConfiguration softApConfig = callback.reservation.getSoftApConfiguration();
            assertNotNull(softApConfig);
            assertEquals(TEST_SSID_UNQUOTED, softApConfig.getSsid());
            assertEquals(TEST_PASSPHRASE, softApConfig.getPassphrase());
        } finally {
            // clean up
            stopLocalOnlyHotspot(callback, wifiEnabled);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Read the content of the given resource file into a String.
     *
     * @param filename String name of the file
     * @return String
     * @throws IOException
     */
    private String loadResourceFile(String filename) throws IOException {
        InputStream in = getClass().getClassLoader().getResourceAsStream(filename);
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        StringBuilder builder = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            builder.append(line).append(""\n"");
        }
        return builder.toString();
    }

    /**
     * Verify that changing the mac randomization setting of a Passpoint configuration.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testMacRandomizationSettingPasspoint"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testMacRandomizationSettingPasspoint() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT);
        PasspointConfiguration config =
                ConfigParser.parsePasspointConfig(TYPE_WIFI_CONFIG, configStr.getBytes());
        String fqdn = config.getHomeSp().getFqdn();
        String uniqueId = config.getUniqueId();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            mWifiManager.addOrUpdatePasspointConfiguration(config);
            PasspointConfiguration passpointConfig = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", passpointConfig);
            assertTrue(""Mac randomization should be enabled for passpoint networks by default."",
                    passpointConfig.isMacRandomizationEnabled());

            mWifiManager.setMacRandomizationSettingPasspointEnabled(fqdn, false);
            passpointConfig = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", passpointConfig);
            assertFalse(""Mac randomization should be disabled by the API call."",
                    passpointConfig.isMacRandomizationEnabled());
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(fqdn);
            uiAutomation.dropShellPermissionIdentity();
        }
    }
    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_STACK} permission is never held by
     * any package.
     * <p>
     * No apps should <em>ever</em> attempt to acquire this permission, since it would give those
     * apps extremely broad access to connectivity functionality.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWifiStandardsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWifiStandardsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for WiFi standards support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isLegacySupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_LEGACY);
        boolean is11nSupporedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N);
        boolean is11acSupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC);
        boolean is11axSupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX);

        // Check for WiFi standards support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());

        boolean isLegacySupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_LEGACY);
        boolean is11nSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N);
        boolean is11acSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC);
        boolean is11axSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX);

        if (isLegacySupportedDisabled) {
            assertTrue(isLegacySupportedEnabled);
        }

        if (is11nSupportedDisabled) {
            assertTrue(is11nSupporedEnabled);
        }

        if (is11acSupportedDisabled) {
            assertTrue(is11acSupportedEnabled);
        }

        if (is11axSupportedDisabled) {
            assertTrue(is11axSupportedEnabled);
        }
    }

    private static PasspointConfiguration createPasspointConfiguration() {
        PasspointConfiguration config = new PasspointConfiguration();
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""test.com"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        config.setHomeSp(homeSp);
        Credential.SimCredential simCred = new Credential.SimCredential();
        simCred.setImsi(""123456*"");
        simCred.setEapType(23 /* EAP_AKA */);
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setSimCredential(simCred);
        config.setCredential(cred);

        return config;
    }

    /**
     * Tests {@link WifiManager#addOrUpdatePasspointConfiguration(PasspointConfiguration)}
     * adds a Passpoint configuration correctly by getting it once it is added, and comparing it
     * to the local copy of the configuration.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddOrUpdatePasspointConfiguration"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddOrUpdatePasspointConfiguration() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Create and install a Passpoint configuration
        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);

            // Compare configurations
            List<PasspointConfiguration> configurations = mWifiManager.getPasspointConfigurations();
            assertNotNull(""The installed passpoint profile is missing"", configurations);
            assertEquals(passpointConfiguration, getTargetPasspointConfiguration(configurations,
                    passpointConfiguration.getUniqueId()));
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(passpointConfiguration.getHomeSp().getFqdn());
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setPasspointMeteredOverride(String, int)}
     * adds a Passpoint configuration correctly, check the default metered setting. Use API change
     * metered override, verify Passpoint configuration changes with it.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetPasspointMeteredOverride"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetPasspointMeteredOverride() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Create and install a Passpoint configuration
        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        String fqdn = passpointConfiguration.getHomeSp().getFqdn();
        String uniqueId = passpointConfiguration.getUniqueId();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();

        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);
            PasspointConfiguration saved = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", saved);
            // Verify meter override setting.
            assertEquals(""Metered overrider default should be none"",
                    WifiConfiguration.METERED_OVERRIDE_NONE, saved.getMeteredOverride());
            // Change the meter override setting.
            mWifiManager.setPasspointMeteredOverride(fqdn,
                    WifiConfiguration.METERED_OVERRIDE_METERED);
            // Verify passpoint config change with the new setting.
            saved = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", saved);
            assertEquals(""Metered override should be metered"",
                    WifiConfiguration.METERED_OVERRIDE_METERED, saved.getMeteredOverride());
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(fqdn);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests that
     * {@link WifiManager#startSubscriptionProvisioning(OsuProvider, Executor, ProvisioningCallback)}
     * starts a subscription provisioning, and confirm a status callback invoked once.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartSubscriptionProvisioning"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartSubscriptionProvisioning() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Using Java reflection to construct an OsuProvider instance because its constructor is
        // hidden and not available to apps.
        Class<?> osuProviderClass = Class.forName(""android.net.wifi.hotspot2.OsuProvider"");
        Constructor<?> osuProviderClassConstructor = osuProviderClass.getConstructor(String.class,
                Map.class, String.class, Uri.class, String.class, List.class);

        OsuProvider osuProvider = (OsuProvider) osuProviderClassConstructor.newInstance(TEST_SSID,
                TEST_FRIENDLY_NAMES, TEST_SERVICE_DESCRIPTION, TEST_SERVER_URI, TEST_NAI,
                TEST_METHOD_LIST);

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            synchronized (mLock) {
                // Start a subscription provisioning for a non-existent Passpoint R2 AP
                mWifiManager.startSubscriptionProvisioning(osuProvider, mExecutor,
                        mProvisioningCallback);
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }

        // Expect only a single callback event, connecting. Since AP doesn't exist, it ends here
        assertEquals(ProvisioningCallback.OSU_STATUS_AP_CONNECTING, mProvisioningStatus);
        // No failure callbacks expected
        assertEquals(0, mProvisioningFailureStatus);
        // No completion callback expected
        assertFalse(mProvisioningComplete);
    }

    /**
     * Tests {@link WifiManager#setTdlsEnabled(InetAddress, boolean)} does not crash.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoin"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoin() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, false);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, true);
            }

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Restore auto join state.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.allowAutojoin(network.networkId, network.allowAutojoin);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoinPasspoint(String, boolean)}.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoinPasspoint"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoinPasspoint() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);
            // Turn off auto-join
            mWifiManager.allowAutojoinPasspoint(
                    passpointConfiguration.getHomeSp().getFqdn(), false);
            // Turn on auto-join
            mWifiManager.allowAutojoinPasspoint(
                    passpointConfiguration.getHomeSp().getFqdn(), true);
        } finally {
            mWifiManager.removePasspointConfiguration(passpointConfiguration.getHomeSp().getFqdn());
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoinGlobal(boolean)}.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsMultiStaConcurrencySupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsMultiStaConcurrencySupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // ensure no crash.
        mWifiManager.isStaApConcurrencySupported();
    }

    private PasspointConfiguration getTargetPasspointConfiguration(
            List<PasspointConfiguration> configurationList, String uniqueId) {
        if (configurationList == null || configurationList.isEmpty()) {
            return null;
        }
        for (PasspointConfiguration config : configurationList) {
            if (TextUtils.equals(config.getUniqueId(), uniqueId)) {
                return config;
            }
        }
        return null;
    }

    /**
     * Test that {@link WifiManager#is60GHzBandSupported()} throws UnsupportedOperationException
     * if the release is older than S.
     */
    @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.R)"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testInsecureEnterpriseConfigurationsRejected"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testInsecureEnterpriseConfigurationsRejected() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiConfiguration wifiConfiguration = new WifiConfiguration();
        wifiConfiguration.SSID = SSID1;
        wifiConfiguration.setSecurityParams(WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE);
        wifiConfiguration.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TTLS);
        int networkId = INVALID_NETWORK_ID;

        // These below API's only work with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            // Verify that an insecure network is rejected
            assertEquals(INVALID_NETWORK_ID, mWifiManager.addNetwork(wifiConfiguration));

            // Now configure it correctly with a Root CA cert and domain name
            wifiConfiguration.enterpriseConfig.setCaCertificate(FakeKeys.CA_CERT0);
            wifiConfiguration.enterpriseConfig.setAltSubjectMatch(TEST_DOM_SUBJECT_MATCH);

            // Verify that the network is added
            networkId = mWifiManager.addNetwork(wifiConfiguration);
            assertNotEquals(INVALID_NETWORK_ID, networkId);

            // Verify that the update API accepts configurations configured securely
            wifiConfiguration.networkId = networkId;
            assertEquals(networkId, mWifiManager.updateNetwork(wifiConfiguration));

            // Now clear the security configuration
            wifiConfiguration.enterpriseConfig.setCaCertificate(null);
            wifiConfiguration.enterpriseConfig.setAltSubjectMatch(null);

            // Verify that the update API rejects insecure configurations
            assertEquals(INVALID_NETWORK_ID, mWifiManager.updateNetwork(wifiConfiguration));
        } finally {
            if (networkId != INVALID_NETWORK_ID) {
                // Clean up the previously added network
                mWifiManager.removeNetwork(networkId);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isPasspointTermsAndConditionsSupported)} does not crash.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsPasspointTermsAndConditionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsPasspointTermsAndConditionsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        mWifiManager.isPasspointTermsAndConditionsSupported();
    }

    /**
     * Test that call to {@link WifiManager#setOverrideCountryCode()},
     * {@link WifiManager#clearOverrideCountryCode()} and
     * {@link WifiManager#setDefaultCountryCode()} need privileged permission
     * and the permission is not even given to shell user.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testManageCountryCodeMethodsFailWithoutPermissions"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testManageCountryCodeMethodsFailWithoutPermissions() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            try {
                mWifiManager.setOverrideCountryCode(TEST_COUNTRY_CODE);
                fail(""setOverrideCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }

            try {
                mWifiManager.clearOverrideCountryCode();
                fail(""clearOverrideCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }

            try {
                mWifiManager.setDefaultCountryCode(TEST_COUNTRY_CODE);
                fail(""setDefaultCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }
        });
    }

    /**
     * Tests {@link WifiManager#flushPasspointAnqpCache)} does not crash.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testFlushPasspointAnqpCache"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testFlushPasspointAnqpCache() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.flushPasspointAnqpCache();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isDecoratedIdentitySupported)} does not crash.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetUsableChannels"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetUsableChannels() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            List<WifiAvailableChannel> usableChannels =
                mWifiManager.getUsableChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            //There must be at least one usable channel in 2.4GHz band
            assertFalse(usableChannels.isEmpty());
        } catch (UnsupportedOperationException ex) {
            //expected if the device does not support this API
        } catch (Exception ex) {
            fail(""getUsableChannels unexpected Exception "" + ex);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Validate that the Passpoint feature is enabled on the device.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	Test Available	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testPasspointCapability"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testPasspointCapability() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PackageManager packageManager = mContext.getPackageManager();
        assertTrue(""Passpoint must be supported"",
                packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI_PASSPOINT));
    }

    /**
     * Validate add and remove SuggestionUserApprovalStatusListener. And verify the listener's
     * stickiness.
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerLock"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerLock() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final String TAG = ""Test"";
        assertNotNull(mWifiManager.createWifiLock(TAG));
        assertNotNull(mWifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL, TAG));
    }

    /**
     * Test wifi scanning when Wifi is off and location scanning is turned on.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerScanWhenWifiOffLocationTurnedOn"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerScanWhenWifiOffLocationTurnedOn() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(false);
            Thread.sleep(TEST_WAIT_DURATION_MS);
            startScan();
            if (mWifiManager.isScanAlwaysAvailable() && isScanCurrentlyAvailable()) {
                // Make sure at least one AP is found.
                assertNotNull(""mScanResult should not be null!"", mScanResults);
                assertFalse(""empty scan results!"", mScanResults.isEmpty());
            } else {
                // Make sure no scan results are available.
                assertNull(""mScanResult should be null!"", mScanResults);
            }
            final String TAG = ""Test"";
            assertNotNull(mWifiManager.createWifiLock(TAG));
            assertNotNull(mWifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL, TAG));
        });
    }

    /**
     * Restart WiFi subsystem - verify that privileged call fails.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testRestartWifiSubsystemShouldFailNoPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testRestartWifiSubsystemShouldFailNoPermission() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        try {
            mWifiManager.restartWifiSubsystem();
            fail(""The restartWifiSubsystem should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Restart WiFi subsystem and verify transition through states.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testRestartWifiSubsystem"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testRestartWifiSubsystem() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mSubsystemRestartStatus = 0; // 0: uninitialized
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.registerSubsystemRestartTrackingCallback(mExecutor,
                    mSubsystemRestartTrackingCallback);
            synchronized (mLock) {
                mWifiManager.restartWifiSubsystem();
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            assertEquals(mSubsystemRestartStatus, 1); // 1: restarting
            waitForExpectedWifiState(false);
            assertFalse(mWifiManager.isWifiEnabled());
            synchronized (mLock) {
                mLock.wait(TEST_WAIT_DURATION_MS);
                assertEquals(mSubsystemRestartStatus, 2); // 2: restarted
            }
            waitForExpectedWifiState(true);
            assertTrue(mWifiManager.isWifiEnabled());
        } finally {
            // cleanup
            mWifiManager.unregisterSubsystemRestartTrackingCallback(
                    mSubsystemRestartTrackingCallback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * test point of wifiManager properties:
     * 1.enable properties
     * 2.DhcpInfo properties
     * 3.wifi state
     * 4.ConnectionInfo
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerProperties() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        setWifiEnabled(true);
        assertTrue(mWifiManager.isWifiEnabled());
        assertNotNull(mWifiManager.getDhcpInfo());
        assertEquals(WifiManager.WIFI_STATE_ENABLED, mWifiManager.getWifiState());
        mWifiManager.getConnectionInfo();
        setWifiEnabled(false);
        assertFalse(mWifiManager.isWifiEnabled());
    }

    /**
     * Test WiFi scan timestamp - fails when WiFi scan timestamps are inconsistent with
     * {@link SystemClock#elapsedRealtime()} on device.<p>
     * To run this test in cts-tradefed:
     * run cts --class android.net.wifi.cts.WifiManagerTest --method testWifiScanTimestamp
     */
    @VirtualDeviceNotSupported"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiScanTimestamp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiScanTimestamp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            Log.d(TAG, ""Skipping test as WiFi is not supported"");
            return;
        }
        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        if (!mWifiManager.isWifiEnabled()) {
            setWifiEnabled(true);
        }
        // Make sure the scan timestamps are consistent with the device timestamp within the range
        // of WIFI_SCAN_TEST_CACHE_DELAY_MILLIS.
        startScan();
        // Make sure at least one AP is found.
        assertTrue(""mScanResult should not be null. This may be due to a scan timeout"",
                   mScanResults != null);
        assertFalse(""empty scan results!"", mScanResults.isEmpty());
        long nowMillis = SystemClock.elapsedRealtime();
        // Keep track of how many APs are fresh in one scan.
        int numFreshAps = 0;
        for (ScanResult result : mScanResults) {
            long scanTimeMillis = TimeUnit.MICROSECONDS.toMillis(result.timestamp);
            if (Math.abs(nowMillis - scanTimeMillis)  < WIFI_SCAN_TEST_CACHE_DELAY_MILLIS) {
                numFreshAps++;
            }
        }
        // At least half of the APs in the scan should be fresh.
        int numTotalAps = mScanResults.size();
        String msg = ""Stale AP count: "" + (numTotalAps - numFreshAps) + "", fresh AP count: ""
                + numFreshAps;
        assertTrue(msg, numFreshAps * 2 >= mScanResults.size());
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testConvertBetweenChannelFrequencyMhz"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testConvertBetweenChannelFrequencyMhz() throws Exception {
        int[] testFrequency_2G = {2412, 2437, 2462, 2484};
        int[] testFrequency_5G = {5180, 5220, 5540, 5745};
        int[] testFrequency_6G = {5955, 6435, 6535, 7115};
        int[] testFrequency_60G = {58320, 64800};
        SparseArray<int[]> testData = new SparseArray<>() {{
            put(ScanResult.WIFI_BAND_24_GHZ, testFrequency_2G);
            put(ScanResult.WIFI_BAND_5_GHZ, testFrequency_5G);
            put(ScanResult.WIFI_BAND_6_GHZ, testFrequency_6G);
            put(ScanResult.WIFI_BAND_60_GHZ, testFrequency_60G);
        }};

        for (int i = 0; i < testData.size(); i++) {
            for (int frequency : testData.valueAt(i)) {
                assertEquals(frequency, ScanResult.convertChannelToFrequencyMhzIfSupported(
                      ScanResult.convertFrequencyMhzToChannelIfSupported(frequency), testData.keyAt(i)));
            }
        }
    }

    // Return true if location is enabled.
    private boolean isLocationEnabled() {
        return Settings.Secure.getInt(getContext().getContentResolver(),
                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF) !=
                Settings.Secure.LOCATION_MODE_OFF;
    }

    // Returns true if the device has location feature.
    private boolean hasLocationFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION);
    }

    private boolean hasAutomotiveFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSignal"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSignal() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final int numLevels = 9;
        int expectLevel = 0;
        assertEquals(expectLevel, WifiManager.calculateSignalLevel(MIN_RSSI, numLevels));
        assertEquals(numLevels - 1, WifiManager.calculateSignalLevel(MAX_RSSI, numLevels));
        expectLevel = 4;
        assertEquals(expectLevel, WifiManager.calculateSignalLevel((MIN_RSSI + MAX_RSSI) / 2,
                numLevels));
        int rssiA = 4;
        int rssiB = 5;
        assertTrue(WifiManager.compareSignalLevel(rssiA, rssiB) < 0);
        rssiB = 4;
        assertTrue(WifiManager.compareSignalLevel(rssiA, rssiB) == 0);
        rssiA = 5;
        rssiB = 4;
        assertTrue(WifiManager.compareSignalLevel(rssiA, rssiB) > 0);
    }

    /**
     * Test that {@link WifiManager#calculateSignalLevel(int)} returns a value in the range
     * [0, {@link WifiManager#getMaxSignalLevel()}], and its value is monotonically increasing as
     * the RSSI increases.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testCalculateSignalLevel"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testCalculateSignalLevel() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        int maxSignalLevel = mWifiManager.getMaxSignalLevel();

        int prevSignalLevel = 0;
        for (int rssi = -150; rssi <= 50; rssi++) {
            int signalLevel = mWifiManager.calculateSignalLevel(rssi);

            // between [0, maxSignalLevel]
            assertWithMessage(""For RSSI=%s"", rssi).that(signalLevel).isAtLeast(0);
            assertWithMessage(""For RSSI=%s"", rssi).that(signalLevel).isAtMost(maxSignalLevel);

            // calculateSignalLevel(rssi) <= calculateSignalLevel(rssi + 1)
            assertWithMessage(""For RSSI=%s"", rssi).that(signalLevel).isAtLeast(prevSignalLevel);
            prevSignalLevel = signalLevel;
        }
    }

    public class TestWifiVerboseLoggingStatusChangedListener implements
            WifiManager.WifiVerboseLoggingStatusChangedListener {
        public int numCalls;
        public boolean status;

        @Override
        public void onWifiVerboseLoggingStatusChanged(boolean enabled) {
            numCalls++;
            status = enabled;
        }
    }

    public class TestSoftApCallback implements WifiManager.SoftApCallback {
        Object softApLock;
        int currentState;
        int currentFailureReason;
        List<SoftApInfo> apInfoList = new ArrayList<>();
        SoftApInfo apInfoOnSingleApMode;
        Map<SoftApInfo, List<WifiClient>> apInfoClients = new HashMap<>();
        List<WifiClient> currentClientList;
        SoftApCapability currentSoftApCapability;
        MacAddress lastBlockedClientMacAddress;
        int lastBlockedClientReason;
        boolean onStateChangedCalled = false;
        boolean onSoftApCapabilityChangedCalled = false;
        boolean onConnectedClientCalled = false;
        boolean onConnectedClientChangedWithInfoCalled = false;
        boolean onBlockedClientConnectingCalled = false;
        int onSoftapInfoChangedCalledCount = 0;
        int onSoftapInfoChangedWithListCalledCount = 0;

        TestSoftApCallback(Object lock) {
            softApLock = lock;
        }

        public boolean getOnStateChangedCalled() {
            synchronized(softApLock) {
                return onStateChangedCalled;
            }
        }

        public int getOnSoftapInfoChangedCalledCount() {
            synchronized(softApLock) {
                return onSoftapInfoChangedCalledCount;
            }
        }

        public int getOnSoftApInfoChangedWithListCalledCount() {
            synchronized(softApLock) {
                return onSoftapInfoChangedWithListCalledCount;
            }
        }

        public boolean getOnSoftApCapabilityChangedCalled() {
            synchronized(softApLock) {
                return onSoftApCapabilityChangedCalled;
            }
        }

        public boolean getOnConnectedClientChangedWithInfoCalled() {
            synchronized(softApLock) {
                return onConnectedClientChangedWithInfoCalled;
            }
        }

        public boolean getOnConnectedClientCalled() {
            synchronized(softApLock) {
                return onConnectedClientCalled;
            }
        }

        public boolean getOnBlockedClientConnectingCalled() {
            synchronized(softApLock) {
                return onBlockedClientConnectingCalled;
            }
        }

        public int getCurrentState() {
            synchronized(softApLock) {
                return currentState;
            }
        }

        public int getCurrentStateFailureReason() {
            synchronized(softApLock) {
                return currentFailureReason;
            }
        }

        public List<WifiClient> getCurrentClientList() {
            synchronized(softApLock) {
                return new ArrayList<>(currentClientList);
            }
        }

        public SoftApInfo getCurrentSoftApInfo() {
            synchronized(softApLock) {
                return apInfoOnSingleApMode;
            }
        }

        public List<SoftApInfo> getCurrentSoftApInfoList() {
            synchronized(softApLock) {
                return new ArrayList<>(apInfoList);
            }
        }

        public SoftApCapability getCurrentSoftApCapability() {
            synchronized(softApLock) {
                return currentSoftApCapability;
            }
        }

        public MacAddress getLastBlockedClientMacAddress() {
            synchronized(softApLock) {
                return lastBlockedClientMacAddress;
            }
        }

        public int getLastBlockedClientReason() {
            synchronized(softApLock) {
                return lastBlockedClientReason;
            }
        }

        @Override
        public void onStateChanged(int state, int failureReason) {
            synchronized(softApLock) {
                currentState = state;
                currentFailureReason = failureReason;
                onStateChangedCalled = true;
            }
        }

        @Override
        public void onConnectedClientsChanged(List<WifiClient> clients) {
            synchronized(softApLock) {
                currentClientList = new ArrayList<>(clients);
                onConnectedClientCalled = true;
            }
        }

        @Override
        public void onConnectedClientsChanged(SoftApInfo info, List<WifiClient> clients) {
            synchronized(softApLock) {
                apInfoClients.put(info, clients);
                onConnectedClientChangedWithInfoCalled = true;
            }
        }

        @Override
        public void onInfoChanged(List<SoftApInfo> infoList) {
            synchronized(softApLock) {
                apInfoList = new ArrayList<>(infoList);
                onSoftapInfoChangedWithListCalledCount++;
            }
        }

        @Override
        public void onInfoChanged(SoftApInfo softApInfo) {
            synchronized(softApLock) {
                apInfoOnSingleApMode = softApInfo;
                onSoftapInfoChangedCalledCount++;
            }
        }

        @Override
        public void onCapabilityChanged(SoftApCapability softApCapability) {
            synchronized(softApLock) {
                currentSoftApCapability = softApCapability;
                onSoftApCapabilityChangedCalled = true;
            }
        }

        @Override
        public void onBlockedClientConnecting(WifiClient client, int blockedReason) {
            synchronized(softApLock) {
                lastBlockedClientMacAddress = client.getMacAddress();
                lastBlockedClientReason = blockedReason;
                onBlockedClientConnectingCalled = true;
            }
        }
    }

    private static class TestLocalOnlyHotspotCallback extends WifiManager.LocalOnlyHotspotCallback {
        Object hotspotLock;
        WifiManager.LocalOnlyHotspotReservation reservation = null;
        boolean onStartedCalled = false;
        boolean onStoppedCalled = false;
        boolean onFailedCalled = false;
        int failureReason = -1;

        TestLocalOnlyHotspotCallback(Object lock) {
            hotspotLock = lock;
        }

        @Override
        public void onStarted(WifiManager.LocalOnlyHotspotReservation r) {
            synchronized (hotspotLock) {
                reservation = r;
                onStartedCalled = true;
                hotspotLock.notify();
            }
        }

        @Override
        public void onStopped() {
            synchronized (hotspotLock) {
                onStoppedCalled = true;
                hotspotLock.notify();
            }
        }

        @Override
        public void onFailed(int reason) {
            synchronized (hotspotLock) {
                onFailedCalled = true;
                failureReason = reason;
                hotspotLock.notify();
            }
        }
    }

    private List<Integer> getSupportedSoftApBand(SoftApCapability capability) {
        List<Integer> supportedApBands = new ArrayList<>();
        if (mWifiManager.is24GHzBandSupported() &&
                capability.areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_BAND_24G_SUPPORTED)) {
            supportedApBands.add(SoftApConfiguration.BAND_2GHZ);
        }
        if (mWifiManager.is5GHzBandSupported() &&
                capability.areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_BAND_5G_SUPPORTED)) {
            supportedApBands.add(SoftApConfiguration.BAND_5GHZ);
        }
        if (mWifiManager.is6GHzBandSupported() &&
                capability.areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_BAND_6G_SUPPORTED)) {
            supportedApBands.add(SoftApConfiguration.BAND_6GHZ);
        }
        if (mWifiManager.is60GHzBandSupported() &&
                capability.areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_BAND_60G_SUPPORTED)) {
            supportedApBands.add(SoftApConfiguration.BAND_60GHZ);
        }
        return supportedApBands;
    }

    private TestLocalOnlyHotspotCallback startLocalOnlyHotspot() {
        // Location mode must be enabled for this test
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test"");
        }

        TestExecutor executor = new TestExecutor();
        TestSoftApCallback capabilityCallback = new TestSoftApCallback(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<Integer> supportedSoftApBands = new ArrayList<>();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            verifyRegisterSoftApCallback(executor, capabilityCallback);
            supportedSoftApBands = getSupportedSoftApBand(
                    capabilityCallback.getCurrentSoftApCapability());
        } catch (Exception ex) {
        } finally {
            // clean up
            mWifiManager.unregisterSoftApCallback(capabilityCallback);
            uiAutomation.dropShellPermissionIdentity();
        }
        TestLocalOnlyHotspotCallback callback = new TestLocalOnlyHotspotCallback(mLock);
        synchronized (mLock) {
            try {
                mWifiManager.startLocalOnlyHotspot(callback, null);
                // now wait for callback
                mLock.wait(TEST_WAIT_DURATION_MS);
            } catch (InterruptedException e) {
            }
            // check if we got the callback
            assertTrue(callback.onStartedCalled);

            SoftApConfiguration softApConfig = callback.reservation.getSoftApConfiguration();
            assertNotNull(softApConfig);
            int securityType = softApConfig.getSecurityType();
            if (securityType == SoftApConfiguration.SECURITY_TYPE_OPEN
                    || securityType == SoftApConfiguration.SECURITY_TYPE_WPA2_PSK
                    || securityType == SoftApConfiguration.SECURITY_TYPE_WPA3_SAE_TRANSITION) {
                assertNotNull(softApConfig.toWifiConfiguration());
            } else {
                assertNull(softApConfig.toWifiConfiguration());
            }
            if (!hasAutomotiveFeature()) {
                assertEquals(supportedSoftApBands.size() > 0 ? supportedSoftApBands.get(0)
                        : SoftApConfiguration.BAND_2GHZ,
                        callback.reservation.getSoftApConfiguration().getBand());
            }
            assertFalse(callback.onFailedCalled);
            assertFalse(callback.onStoppedCalled);
        }
        return callback;
    }

    private void stopLocalOnlyHotspot(TestLocalOnlyHotspotCallback callback, boolean wifiEnabled) {
       synchronized (mMySync) {
           // we are expecting a new state
           mMySync.expectedState = STATE_WIFI_CHANGING;

           // now shut down LocalOnlyHotspot
           callback.reservation.close();

           try {
               waitForExpectedWifiState(wifiEnabled);
           } catch (InterruptedException e) {}
        }
    }

    /**
     * Verify that calls to startLocalOnlyHotspot succeed with proper permissions.
     *
     * Note: Location mode must be enabled for this test.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotSuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartLocalOnlyHotspotSuccess() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }

        boolean wifiEnabled = mWifiManager.isWifiEnabled();

        TestLocalOnlyHotspotCallback callback = startLocalOnlyHotspot();

        // add sleep to avoid calling stopLocalOnlyHotspot before TetherController initialization.
        // TODO: remove this sleep as soon as b/124330089 is fixed.
        Log.d(TAG, ""Sleeping for 2 seconds"");
        Thread.sleep(2000);

        stopLocalOnlyHotspot(callback, wifiEnabled);

        // wifi should either stay on, or come back on
        assertEquals(wifiEnabled, mWifiManager.isWifiEnabled());
    }

    /**
     * Verify calls to deprecated API's all fail for non-settings apps targeting >= Q SDK.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testDeprecatedApis"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testDeprecatedApis() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        setWifiEnabled(true);
        waitForConnection(); // ensures that there is at-least 1 saved network on the device.

        WifiConfiguration wifiConfiguration = new WifiConfiguration();
        wifiConfiguration.SSID = SSID1;
        wifiConfiguration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);

        assertEquals(INVALID_NETWORK_ID,
                mWifiManager.addNetwork(wifiConfiguration));
        assertEquals(INVALID_NETWORK_ID,
                mWifiManager.updateNetwork(wifiConfiguration));
        assertFalse(mWifiManager.enableNetwork(0, true));
        assertFalse(mWifiManager.disableNetwork(0));
        assertFalse(mWifiManager.removeNetwork(0));
        assertFalse(mWifiManager.disconnect());
        assertFalse(mWifiManager.reconnect());
        assertFalse(mWifiManager.reassociate());
        assertTrue(mWifiManager.getConfiguredNetworks().isEmpty());

        boolean wifiEnabled = mWifiManager.isWifiEnabled();
        // now we should fail to toggle wifi state.
        assertFalse(mWifiManager.setWifiEnabled(!wifiEnabled));
        Thread.sleep(TEST_WAIT_DURATION_MS);
        assertEquals(wifiEnabled, mWifiManager.isWifiEnabled());
    }

    /**
     * Test the WifiManager APIs that return whether a feature is supported.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetSupportedFeatures"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetSupportedFeatures() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        mWifiManager.isMakeBeforeBreakWifiSwitchingSupported();
        mWifiManager.isStaBridgedApConcurrencySupported();
    }

    /**
     * Verify non DO apps cannot call removeNonCallerConfiguredNetworks.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testRemoveNonCallerConfiguredNetworksNotAllowed"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testRemoveNonCallerConfiguredNetworksNotAllowed() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        try {
            mWifiManager.removeNonCallerConfiguredNetworks();
            fail(""Expected security exception for non DO app"");
        } catch (SecurityException e) {
        }
    }

    /**
     * Test coverage for the constructor of AddNetworkResult.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkResultCreation"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkResultCreation() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        int statusCode = WifiManager.AddNetworkResult.STATUS_NO_PERMISSION;
        int networkId = 5;
        WifiManager.AddNetworkResult result = new WifiManager.AddNetworkResult(
            statusCode, networkId);
        assertEquals(""statusCode should match"", statusCode, result.statusCode);
        assertEquals(""networkId should match"", networkId, result.networkId);
    }

    /**
     * Verify that {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} throws a
     * SecurityException when called by a normal app.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedNotAllowedForNormalApps"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkPrivilegedNotAllowedForNormalApps() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        try {
            WifiConfiguration newOpenNetwork = new WifiConfiguration();
            newOpenNetwork.SSID = ""\"""" + TEST_SSID_UNQUOTED + ""\"""";
            mWifiManager.addNetworkPrivileged(newOpenNetwork);
            fail(""A normal app should not be able to call this API."");
        } catch (SecurityException e) {
        }
    }

    /**
     * Verify {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} throws an exception when
     * null is the input.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedBadInput"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkPrivilegedBadInput() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addNetworkPrivileged(null);
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException e) {
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} returns the proper
     * failure status code when adding an enterprise config with mandatory fields not filled in.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedFailureBadEnterpriseConfig"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkPrivilegedFailureBadEnterpriseConfig() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            WifiConfiguration wifiConfiguration = new WifiConfiguration();
            wifiConfiguration.SSID = SSID1;
            wifiConfiguration.setSecurityParams(WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE);
            wifiConfiguration.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TTLS);
            WifiManager.AddNetworkResult result =
                    mWifiManager.addNetworkPrivileged(wifiConfiguration);
            assertEquals(WifiManager.AddNetworkResult.STATUS_INVALID_CONFIGURATION_ENTERPRISE,
                    result.statusCode);
            assertEquals(-1, result.networkId);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} works properly when the
     * calling app has permissions.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedSuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkPrivilegedSuccess() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        WifiManager.AddNetworkResult result = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            WifiConfiguration newOpenNetwork = new WifiConfiguration();
            newOpenNetwork.SSID = ""\"""" + TEST_SSID_UNQUOTED + ""\"""";
            result = mWifiManager.addNetworkPrivileged(newOpenNetwork);
            assertEquals(WifiManager.AddNetworkResult.STATUS_SUCCESS, result.statusCode);
            assertTrue(result.networkId >= 0);
            List<WifiConfiguration> configuredNetworks = mWifiManager.getConfiguredNetworks();
            boolean found = false;
            for (WifiConfiguration config : configuredNetworks) {
                if (config.networkId == result.networkId
                        && config.SSID.equals(newOpenNetwork.SSID)) {
                    found = true;
                    break;
                }
            }
            assertTrue(""addNetworkPrivileged returns success""
                    + ""but the network is not found in getConfiguredNetworks"", found);

            List<WifiConfiguration> privilegedConfiguredNetworks =
                    mWifiManager.getPrivilegedConfiguredNetworks();
            found = false;
            for (WifiConfiguration config : privilegedConfiguredNetworks) {
                if (config.networkId == result.networkId
                        && config.SSID.equals(newOpenNetwork.SSID)) {
                    found = true;
                    break;
                }
            }
            assertTrue(""addNetworkPrivileged returns success""
                    + ""but the network is not found in getPrivilegedConfiguredNetworks"", found);

            List<WifiConfiguration> callerConfiguredNetworks =
                    mWifiManager.getCallerConfiguredNetworks();
            found = false;
            for (WifiConfiguration config : callerConfiguredNetworks) {
                if (config.networkId == result.networkId
                        && config.SSID.equals(newOpenNetwork.SSID)) {
                    found = true;
                    break;
                }
            }
            assertTrue(""addNetworkPrivileged returns success""
                    + ""but the network is not found in getCallerConfiguredNetworks"", found);
        } finally {
            if (null != result) {
                mWifiManager.removeNetwork(result.networkId);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private WifiConfiguration createConfig(
            String ssid, int type) {
        WifiConfiguration config = new WifiConfiguration();
        config.SSID = ""\"""" + ssid + ""\"""";
        config.setSecurityParams(type);
        // set necessary fields for different types.
        switch (type) {
            case WifiConfiguration.SECURITY_TYPE_OPEN:
            case WifiConfiguration.SECURITY_TYPE_OWE:
                break;
            case WifiConfiguration.SECURITY_TYPE_PSK:
            case WifiConfiguration.SECURITY_TYPE_SAE:
                config.preSharedKey = ""\""1qaz@WSX\"""";
                break;
            case WifiConfiguration.SECURITY_TYPE_EAP:
            case WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE:
            case WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE_192_BIT:
                config.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.SIM);
                break;
        }
        return config;
    }

    private void assertConfigsAreFound(
            List<WifiConfiguration> expectedConfigs,
            List<WifiConfiguration> configs) {
        for (WifiConfiguration expectedConfig: expectedConfigs) {
            boolean found = false;
            for (WifiConfiguration config : configs) {
                if (config.networkId == expectedConfig.networkId
                        && config.getKey().equals(expectedConfig.getKey())) {
                    found = true;
                    break;
                }
            }
            assertTrue(""the network "" + expectedConfig.getKey() + "" is not found"", found);
        }
    }

    /**
     * Verify {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} works
     * with merging types properly when the calling app has permissions.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedMergingTypeSuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddNetworkPrivilegedMergingTypeSuccess() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        List<WifiConfiguration> testConfigs = new ArrayList<>();
        testConfigs.add(createConfig(""test-open-owe-jdur"", WifiConfiguration.SECURITY_TYPE_OPEN));
        testConfigs.add(createConfig(""test-open-owe-jdur"", WifiConfiguration.SECURITY_TYPE_OWE));
        testConfigs.add(createConfig(""test-psk-sae-ijfe"", WifiConfiguration.SECURITY_TYPE_PSK));
        testConfigs.add(createConfig(""test-psk-sae-ijfe"", WifiConfiguration.SECURITY_TYPE_SAE));
        testConfigs.add(createConfig(""test-wpa2e-wpa3e-plki"",
                WifiConfiguration.SECURITY_TYPE_EAP));
        testConfigs.add(createConfig(""test-wpa2e-wpa3e-plki"",
                WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE));
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            final int originalConfiguredNetworksNumber = mWifiManager.getConfiguredNetworks().size();
            final int originalPrivilegedConfiguredNetworksNumber =
                    mWifiManager.getPrivilegedConfiguredNetworks().size();
            final int originalCallerConfiguredNetworksNumber =
                mWifiManager.getCallerConfiguredNetworks().size();
            for (WifiConfiguration c: testConfigs) {
                WifiManager.AddNetworkResult result = mWifiManager.addNetworkPrivileged(c);
                assertEquals(WifiManager.AddNetworkResult.STATUS_SUCCESS, result.statusCode);
                assertTrue(result.networkId >= 0);
                c.networkId = result.networkId;
            }
            List<WifiConfiguration> expectedConfigs = testConfigs;
            if (SdkLevel.isAtLeastS()) {
                // open/owe, psk/sae, and wpa2e/wpa3e should be merged
                // so they should have the same network ID.
                assertEquals(testConfigs.get(0).networkId, testConfigs.get(1).networkId);
                assertEquals(testConfigs.get(2).networkId, testConfigs.get(3).networkId);
                assertEquals(testConfigs.get(4).networkId, testConfigs.get(5).networkId);
            } else {
                // Network IDs for different security types should be unique for R
                assertNotEquals(testConfigs.get(0).networkId, testConfigs.get(1).networkId);
                assertNotEquals(testConfigs.get(2).networkId, testConfigs.get(3).networkId);
                assertNotEquals(testConfigs.get(4).networkId, testConfigs.get(5).networkId);
                // WPA3-Enterprise is omitted when WPA2-Enterprise is present for R
                expectedConfigs = testConfigs.subList(0, 5);
            }
            List<WifiConfiguration> configuredNetworks = mWifiManager.getConfiguredNetworks();
            assertEquals(originalConfiguredNetworksNumber + expectedConfigs.size(),
                    configuredNetworks.size());
            assertConfigsAreFound(expectedConfigs, configuredNetworks);

            List<WifiConfiguration> privilegedConfiguredNetworks =
                    mWifiManager.getPrivilegedConfiguredNetworks();
            assertEquals(originalPrivilegedConfiguredNetworksNumber + expectedConfigs.size(),
                    privilegedConfiguredNetworks.size());
            assertConfigsAreFound(expectedConfigs, privilegedConfiguredNetworks);

            List<WifiConfiguration> callerConfiguredNetworks =
                    mWifiManager.getCallerConfiguredNetworks();
            assertEquals(originalCallerConfiguredNetworksNumber + expectedConfigs.size(),
                    callerConfiguredNetworks.size());
            assertConfigsAreFound(expectedConfigs, callerConfiguredNetworks);

        } finally {
            for (WifiConfiguration c: testConfigs) {
                if (c.networkId >= 0) {
                    mWifiManager.removeNetwork(c.networkId);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify that applications can only have one registered LocalOnlyHotspot request at a time.
     *
     * Note: Location mode must be enabled for this test.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotSingleRequestByApps"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartLocalOnlyHotspotSingleRequestByApps() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }

        boolean caughtException = false;

        boolean wifiEnabled = mWifiManager.isWifiEnabled();

        TestLocalOnlyHotspotCallback callback = startLocalOnlyHotspot();

        // now make a second request - this should fail.
        TestLocalOnlyHotspotCallback callback2 = new TestLocalOnlyHotspotCallback(mLock);
        try {
            mWifiManager.startLocalOnlyHotspot(callback2, null);
        } catch (IllegalStateException e) {
            Log.d(TAG, ""Caught the IllegalStateException we expected: called startLOHS twice"");
            caughtException = true;
        }
        if (!caughtException) {
            // second start did not fail, should clean up the hotspot.

            // add sleep to avoid calling stopLocalOnlyHotspot before TetherController initialization.
            // TODO: remove this sleep as soon as b/124330089 is fixed.
            Log.d(TAG, ""Sleeping for 2 seconds"");
            Thread.sleep(2000);

            stopLocalOnlyHotspot(callback2, wifiEnabled);
        }
        assertTrue(caughtException);

        // add sleep to avoid calling stopLocalOnlyHotspot before TetherController initialization.
        // TODO: remove this sleep as soon as b/124330089 is fixed.
        Log.d(TAG, ""Sleeping for 2 seconds"");
        Thread.sleep(2000);

        stopLocalOnlyHotspot(callback, wifiEnabled);
    }

    private static class TestExecutor implements Executor {
        private ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<>();

        @Override
        public void execute(Runnable task) {
            tasks.add(task);
        }

        private void runAll() {
            Runnable task = tasks.poll();
            while (task != null) {
                task.run();
                task = tasks.poll();
            }
        }
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotWithConfigBssid"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartLocalOnlyHotspotWithConfigBssid() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }

        TestExecutor executor = new TestExecutor();
        TestLocalOnlyHotspotCallback callback = new TestLocalOnlyHotspotCallback(mLock);
        TestSoftApCallback capabilityCallback = new TestSoftApCallback(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        boolean wifiEnabled = mWifiManager.isWifiEnabled();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            verifyRegisterSoftApCallback(executor, capabilityCallback);
            SoftApConfiguration.Builder customConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK);

            boolean isSupportCustomizedMac = capabilityCallback.getCurrentSoftApCapability()
                        .areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);
            if (isSupportCustomizedMac) {
                customConfigBuilder.setBssid(TEST_MAC);
            }
            SoftApConfiguration customConfig = customConfigBuilder.build();

            mWifiManager.startLocalOnlyHotspot(customConfig, executor, callback);
            // now wait for callback
            Thread.sleep(TEST_WAIT_DURATION_MS);

            // Verify callback is run on the supplied executor
            assertFalse(callback.onStartedCalled);
            executor.runAll();
            assertTrue(callback.onStartedCalled);

            assertNotNull(callback.reservation);
            SoftApConfiguration softApConfig = callback.reservation.getSoftApConfiguration();
            assertNotNull(softApConfig);
            if (isSupportCustomizedMac) {
                assertEquals(TEST_MAC, softApConfig.getBssid());
            }
            assertEquals(TEST_SSID_UNQUOTED, softApConfig.getSsid());
            assertEquals(TEST_PASSPHRASE, softApConfig.getPassphrase());
        } finally {
            // clean up
            stopLocalOnlyHotspot(callback, wifiEnabled);
            mWifiManager.unregisterSoftApCallback(capabilityCallback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkStackPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkStackPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_STACK
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : holding) {
            fail(""The NETWORK_STACK permission must not be held by "" + pi.packageName
                    + "" and must be revoked for security reasons"");
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_SETTINGS} permission is
     * never held by any package.
     * <p>
     * Only Settings, SysUi, NetworkStack and shell apps should <em>ever</em> attempt to acquire
     * this permission, since it would give those apps extremely broad access to connectivity
     * functionality.  The permission is intended to be granted to only those apps with direct user
     * access and no others.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSettingsPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final ArraySet<String> allowedPackages = new ArraySet();
        final ArraySet<Integer> allowedUIDs = new ArraySet();
        // explicitly add allowed UIDs
        allowedUIDs.add(Process.SYSTEM_UID);
        allowedUIDs.add(Process.SHELL_UID);
        allowedUIDs.add(Process.PHONE_UID);
        allowedUIDs.add(Process.NETWORK_STACK_UID);
        allowedUIDs.add(Process.NFC_UID);

        // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using
        // this fact to determined allowed package name for sysui. This is a signature permission,
        // so allow any package with this permission.
        final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.BIND_QUICK_SETTINGS_TILE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo info : sysuiPackages) {
            allowedPackages.add(info.packageName);
        }

        // the captive portal flow also currently holds the NETWORK_SETTINGS permission
        final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        if (ri != null) {
            allowedPackages.add(ri.activityInfo.packageName);
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_SETTINGS
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        StringBuilder stringBuilder = new StringBuilder();
        for (PackageInfo pi : holding) {
            String packageName = pi.packageName;

            // this is an explicitly allowed package
            if (allowedPackages.contains(packageName)) continue;

            // now check if the packages are from allowed UIDs
            int uid = -1;
            try {
                uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);
            } catch (PackageManager.NameNotFoundException e) {
                continue;
            }
            if (!allowedUIDs.contains(uid)) {
                stringBuilder.append(""The NETWORK_SETTINGS permission must not be held by ""
                    + packageName + "":"" + uid + "" and must be revoked for security reasons\n"");
            }
        }
        if (stringBuilder.length() > 0) {
            fail(stringBuilder.toString());
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} permission is
     * only held by the device setup wizard application.
     * <p>
     * Only the SetupWizard app should <em>ever</em> attempt to acquire this
     * permission, since it would give those apps extremely broad access to connectivity
     * functionality.  The permission is intended to be granted to only the device setup wizard.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSetupWizardPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSetupWizardPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final ArraySet<String> allowedPackages = new ArraySet();

        final PackageManager pm = getContext().getPackageManager();

        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_SETUP_WIZARD);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String validPkg = """";
        if (ri != null) {
            allowedPackages.add(ri.activityInfo.packageName);
            validPkg = ri.activityInfo.packageName;
        }

        final Intent preIntent = new Intent(""com.android.setupwizard.OEM_PRE_SETUP"");
        preIntent.addCategory(Intent.CATEGORY_DEFAULT);
        final ResolveInfo preRi = pm
            .resolveActivity(preIntent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String prePackageName = """";
        if (null != preRi) {
            prePackageName = preRi.activityInfo.packageName;
        }

        final Intent postIntent = new Intent(""com.android.setupwizard.OEM_POST_SETUP"");
        postIntent.addCategory(Intent.CATEGORY_DEFAULT);
        final ResolveInfo postRi = pm
            .resolveActivity(postIntent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String postPackageName = """";
        if (null != postRi) {
            postPackageName = postRi.activityInfo.packageName;
        }
        if (!TextUtils.isEmpty(prePackageName) && !TextUtils.isEmpty(postPackageName)
            && prePackageName.equals(postPackageName)) {
            allowedPackages.add(prePackageName);
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[]{
            android.Manifest.permission.NETWORK_SETUP_WIZARD
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : holding) {
            if (!allowedPackages.contains(pi.packageName)) {
                fail(""The NETWORK_SETUP_WIZARD permission must not be held by "" + pi.packageName
                    + "" and must be revoked for security reasons ["" + validPkg + ""]"");
            }
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_MANAGED_PROVISIONING} permission
     * is only held by the device managed provisioning application.
     * <p>
     * Only the ManagedProvisioning app should <em>ever</em> attempt to acquire this
     * permission, since it would give those apps extremely broad access to connectivity
     * functionality.  The permission is intended to be granted to only the device managed
     * provisioning.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkManagedProvisioningPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkManagedProvisioningPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        // TODO(b/115980767): Using hardcoded package name. Need a better mechanism to find the
        // managed provisioning app.
        // Ensure that the package exists.
        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.setPackage(MANAGED_PROVISIONING_PACKAGE_NAME);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String validPkg = """";
        if (ri != null) {
            validPkg = ri.activityInfo.packageName;
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_MANAGED_PROVISIONING
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : holding) {
            if (!Objects.equals(pi.packageName, validPkg)) {
                fail(""The NETWORK_MANAGED_PROVISIONING permission must not be held by ""
                        + pi.packageName + "" and must be revoked for security reasons [""
                        + validPkg +""]"");
            }
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#WIFI_SET_DEVICE_MOBILITY_STATE} permission
     * is held by at most one application.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiSetDeviceMobilityStatePermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiSetDeviceMobilityStatePermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.WIFI_SET_DEVICE_MOBILITY_STATE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        List<String> uniquePackageNames = holding
                .stream()
                .map(pi -> pi.packageName)
                .distinct()
                .collect(Collectors.toList());

        if (uniquePackageNames.size() > 1) {
            fail(""The WIFI_SET_DEVICE_MOBILITY_STATE permission must not be held by more than one ""
                    + ""application, but is held by "" + uniquePackageNames.size() + "" applications: ""
                    + String.join("", "", uniquePackageNames));
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_CARRIER_PROVISIONING} permission
     * is held by at most one application.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkCarrierProvisioningPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkCarrierProvisioningPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_CARRIER_PROVISIONING
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        List<String> uniquePackageNames = holding
                .stream()
                .map(pi -> pi.packageName)
                .distinct()
                .collect(Collectors.toList());

        if (uniquePackageNames.size() > 2) {
            fail(""The NETWORK_CARRIER_PROVISIONING permission must not be held by more than two ""
                    + ""applications, but is held by "" + uniquePackageNames.size() + "" applications: ""
                    + String.join("", "", uniquePackageNames));
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#WIFI_UPDATE_USABILITY_STATS_SCORE}
     * permission is held by at most one application.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testUpdateWifiUsabilityStatsScorePermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testUpdateWifiUsabilityStatsScorePermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.WIFI_UPDATE_USABILITY_STATS_SCORE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        Set<String> uniqueNonSystemPackageNames = new HashSet<>();
        for (PackageInfo pi : holding) {
            String packageName = pi.packageName;
            // Shell is allowed to hold this permission for testing.
            int uid = -1;
            try {
                uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);
            } catch (PackageManager.NameNotFoundException e) {
                continue;
            }
            if (uid == Process.SHELL_UID) continue;

            uniqueNonSystemPackageNames.add(packageName);
        }

        if (uniqueNonSystemPackageNames.size() > 1) {
            fail(""The WIFI_UPDATE_USABILITY_STATS_SCORE permission must not be held by more than ""
                + ""one application, but is held by "" + uniqueNonSystemPackageNames.size()
                + "" applications: "" + String.join("", "", uniqueNonSystemPackageNames));
        }
    }

    private void turnScreenOnNoDelay() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
    }

    private void turnScreenOn() throws Exception {
        turnScreenOnNoDelay();
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void turnScreenOffNoDelay() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
    }

    private void turnScreenOff() throws Exception {
        turnScreenOffNoDelay();
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void assertWifiScanningIsOn() {
        if (!mWifiManager.isScanAlwaysAvailable()) {
            fail(""Wi-Fi scanning should be on."");
        }
    }

    private void runWithScanningEnabled(ThrowingRunnable r) throws Exception {
        boolean wasScanEnabledForTest = false;
        if (!mWifiManager.isScanAlwaysAvailable()) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.setScanAlwaysAvailable(true));
            wasScanEnabledForTest = true;
        }
        try {
            r.run();
        } finally {
            if (wasScanEnabledForTest) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.setScanAlwaysAvailable(false));
            }
        }
    }

    /**
     * Verify that Wi-Fi scanning is not turned off when the screen turns off while wifi is disabled
     * but location is on.
     * @throws Exception
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScreenOffDoesNotTurnOffWifiScanningWhenWifiDisabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScreenOffDoesNotTurnOffWifiScanningWhenWifiDisabled() throws Exception {
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive()) {
            // TV and auto do not support the setting options of WIFI scanning and Bluetooth
            // scanning
            return;
        }
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            // skip the test if location is not supported
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(false);
            turnScreenOn();
            assertWifiScanningIsOn();
            // Toggle screen and verify Wi-Fi scanning is still on.
            turnScreenOff();
            assertWifiScanningIsOn();
            turnScreenOn();
            assertWifiScanningIsOn();
        });
    }

    /**
     * Verify that Wi-Fi scanning is not turned off when the screen turns off while wifi is enabled.
     * @throws Exception
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScreenOffDoesNotTurnOffWifiScanningWhenWifiEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScreenOffDoesNotTurnOffWifiScanningWhenWifiEnabled() throws Exception {
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive()) {
            // TV and auto do not support the setting options of WIFI scanning and Bluetooth
            // scanning
            return;
        }
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            // skip the test if location is not supported
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(true);
            turnScreenOn();
            assertWifiScanningIsOn();
            // Toggle screen and verify Wi-Fi scanning is still on.
            turnScreenOff();
            assertWifiScanningIsOn();
            turnScreenOn();
            assertWifiScanningIsOn();
        });
    }

    /**
     * Verify that the platform supports a reasonable number of suggestions per app.
     * @throws Exception
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testMaxNumberOfNetworkSuggestionsPerApp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testMaxNumberOfNetworkSuggestionsPerApp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        assertTrue(mWifiManager.getMaxNumberOfNetworkSuggestionsPerApp()
                > ENFORCED_NUM_NETWORK_SUGGESTIONS_PER_APP);
    }

    private void verifyRegisterSoftApCallback(TestExecutor executor, TestSoftApCallback callback)
            throws Exception {
        // Register callback to get SoftApCapability
        mWifiManager.registerSoftApCallback(executor, callback);
        PollingCheck.check(
                ""SoftAp register failed!"", 5_000,
                () -> {
                    executor.runAll();
                    // Verify callback is run on the supplied executor and called
                    return callback.getOnStateChangedCalled() &&
                            callback.getOnSoftapInfoChangedCalledCount() > 0 &&
                            callback.getOnSoftApCapabilityChangedCalled() &&
                            callback.getOnConnectedClientCalled();
                });
    }

    private void verifySetGetSoftApConfig(SoftApConfiguration targetConfig) {
        mWifiManager.setSoftApConfiguration(targetConfig);
        // Bssid set dodesn't support for tethered hotspot
        SoftApConfiguration currentConfig = mWifiManager.getSoftApConfiguration();
        compareSoftApConfiguration(targetConfig, currentConfig);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertTrue(currentConfig.isUserConfiguration());
        }
    }

    private void compareSoftApConfiguration(SoftApConfiguration currentConfig,
        SoftApConfiguration testSoftApConfig) {
        assertEquals(currentConfig.getSsid(), testSoftApConfig.getSsid());
        assertEquals(currentConfig.getBssid(), testSoftApConfig.getBssid());
        assertEquals(currentConfig.getSecurityType(), testSoftApConfig.getSecurityType());
        assertEquals(currentConfig.getPassphrase(), testSoftApConfig.getPassphrase());
        assertEquals(currentConfig.isHiddenSsid(), testSoftApConfig.isHiddenSsid());
        assertEquals(currentConfig.getBand(), testSoftApConfig.getBand());
        assertEquals(currentConfig.getChannel(), testSoftApConfig.getChannel());
        assertEquals(currentConfig.getMaxNumberOfClients(),
                testSoftApConfig.getMaxNumberOfClients());
        assertEquals(currentConfig.isAutoShutdownEnabled(),
                testSoftApConfig.isAutoShutdownEnabled());
        assertEquals(currentConfig.getShutdownTimeoutMillis(),
                testSoftApConfig.getShutdownTimeoutMillis());
        assertEquals(currentConfig.isClientControlByUserEnabled(),
                testSoftApConfig.isClientControlByUserEnabled());
        assertEquals(currentConfig.getAllowedClientList(),
                testSoftApConfig.getAllowedClientList());
        assertEquals(currentConfig.getBlockedClientList(),
                testSoftApConfig.getBlockedClientList());
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertEquals(currentConfig.getMacRandomizationSetting(),
                    testSoftApConfig.getMacRandomizationSetting());
            assertEquals(currentConfig.getChannels().toString(),
                    testSoftApConfig.getChannels().toString());
            assertEquals(currentConfig.isBridgedModeOpportunisticShutdownEnabled(),
                    testSoftApConfig.isBridgedModeOpportunisticShutdownEnabled());
            assertEquals(currentConfig.isIeee80211axEnabled(),
                    testSoftApConfig.isIeee80211axEnabled());
        }
    }

    private void turnOffWifiAndTetheredHotspotIfEnabled() throws Exception {
        if (mWifiManager.isWifiEnabled()) {
            Log.d(TAG, ""Turn off WiFi"");
            mWifiManager.setWifiEnabled(false);
            PollingCheck.check(
                ""Wifi turn off failed!"", 2_000,
                () -> mWifiManager.isWifiEnabled() == false);
        }
        if (mWifiManager.isWifiApEnabled()) {
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);
            Log.d(TAG, ""Turn off tethered Hotspot"");
            PollingCheck.check(
                ""SoftAp turn off failed!"", 2_000,
                () -> mWifiManager.isWifiApEnabled() == false);
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);
        }
    }

    private void verifyBridgedModeSoftApCallback(TestExecutor executor,
            TestSoftApCallback callback, boolean shouldFallbackSingleApMode, boolean isEnabled)
            throws Exception {
            // Verify state and info callback value as expected
            PollingCheck.check(
                    ""SoftAp state and info on bridged AP mode are mismatch!!!""
                    + "" shouldFallbackSingleApMode = "" + shouldFallbackSingleApMode
                    + "", isEnabled = ""  + isEnabled, 10_000,
                    () -> {
                        executor.runAll();
                        int expectedState = isEnabled ? WifiManager.WIFI_AP_STATE_ENABLED
                                : WifiManager.WIFI_AP_STATE_DISABLED;
                        int expectedInfoSize = isEnabled
                                ? (shouldFallbackSingleApMode ? 1 : 2) : 0;
                        return expectedState == callback.getCurrentState()
                                && callback.getCurrentSoftApInfoList().size() == expectedInfoSize;
                    });
    }

    private boolean shouldFallbackToSingleAp(int[] bands, SoftApCapability capability) {
        for (int band : bands) {
            if (capability.getSupportedChannelList(band).length == 0) {
                return true;
            }
        }
        return false;
    }

    private SparseIntArray getAvailableBandAndChannelForTesting(SoftApCapability capability) {
        final int[] bands = {SoftApConfiguration.BAND_2GHZ, SoftApConfiguration.BAND_5GHZ,
              SoftApConfiguration.BAND_6GHZ, SoftApConfiguration.BAND_60GHZ};
        SparseIntArray testBandsAndChannels = new SparseIntArray();
        if (!ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            testBandsAndChannels.put(SoftApConfiguration.BAND_2GHZ, 1);
            return testBandsAndChannels;
        }
        for (int band : bands) {
            int[] supportedList = capability.getSupportedChannelList(band);
            if (supportedList.length != 0) {
                testBandsAndChannels.put(band, supportedList[0]);
            }
        }
        return testBandsAndChannels;
    }


    /**
     * Test bridged AP enable succeeful when device supports it.
     * Also verify the callback info update correctly.
     * @throws Exception
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetGetSoftApConfigurationAndSoftApCapabilityCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetGetSoftApConfigurationAndSoftApCapabilityCallback() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SoftApConfiguration.Builder softApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setAutoShutdownEnabled(true)
                    .setShutdownTimeoutMillis(100000)
                    .setBand(getAvailableBandAndChannelForTesting(
                            callback.getCurrentSoftApCapability()).keyAt(0))
                    .setHiddenSsid(false);

            // Test SoftApConfiguration set and get
            verifySetGetSoftApConfig(softApConfigBuilder.build());

            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                        .areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            //Test MAC_ADDRESS_CUSTOMIZATION supported config
            if (isSupportCustomizedMac) {
                softApConfigBuilder.setBssid(TEST_MAC)
                        .setMacRandomizationSetting(SoftApConfiguration.RANDOMIZATION_NONE);

                // Test SoftApConfiguration set and get
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test CLIENT_FORCE_DISCONNECT supported config.
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_CLIENT_FORCE_DISCONNECT)) {
                softApConfigBuilder.setMaxNumberOfClients(10);
                softApConfigBuilder.setClientControlByUserEnabled(true);
                softApConfigBuilder.setBlockedClientList(new ArrayList<>());
                softApConfigBuilder.setAllowedClientList(new ArrayList<>());
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test SAE config
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(SoftApCapability.SOFTAP_FEATURE_WPA3_SAE)) {
                softApConfigBuilder
                        .setPassphrase(TEST_PASSPHRASE,
                          SoftApConfiguration.SECURITY_TYPE_WPA3_SAE_TRANSITION);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
                softApConfigBuilder
                        .setPassphrase(TEST_PASSPHRASE,
                        SoftApConfiguration.SECURITY_TYPE_WPA3_SAE);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test 11 AX control config.
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(SoftApCapability.SOFTAP_FEATURE_IEEE80211_AX)) {
                softApConfigBuilder.setIeee80211axEnabled(true);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                softApConfigBuilder.setBridgedModeOpportunisticShutdownEnabled(false);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

        } finally {
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify that startTetheredHotspot with specific channel config.
     * @throws Exception
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback()
            throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // check that tethering is supported by the device
            if (!mTetheringManager.isTetheringSupported()) {
                return;
            }
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SparseIntArray testBandsAndChannels = getAvailableBandAndChannelForTesting(
                    callback.getCurrentSoftApCapability());

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertNotEquals(0, testBandsAndChannels.size());
            }
            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            SoftApConfiguration.Builder testSoftApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setChannel(testBandsAndChannels.valueAt(0), testBandsAndChannels.keyAt(0));

            if (isSupportCustomizedMac) testSoftApConfigBuilder.setBssid(TEST_MAC);

            SoftApConfiguration testSoftApConfig = testSoftApConfigBuilder.build();

            mWifiManager.setSoftApConfiguration(testSoftApConfig);

            // start tethering which used to verify startTetheredHotspot
            mTetheringManager.startTethering(ConnectivityManager.TETHERING_WIFI, executor,
                new TetheringManager.StartTetheringCallback() {
                    @Override
                    public void onTetheringFailed(final int result) {
                    }
                });

            // Verify state and info callback value as expected
            PollingCheck.check(
                    ""SoftAp channel and state mismatch!!!"", 10_000,
                    () -> {
                        executor.runAll();
                        int sapChannel = ScanResult.convertFrequencyMhzToChannelIfSupported(
                                callback.getCurrentSoftApInfo().getFrequency());
                        boolean isInfoCallbackSupported =
                                callback.getOnSoftapInfoChangedCalledCount() > 1;
                        if (isInfoCallbackSupported) {
                            return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState()
                                && testBandsAndChannels.valueAt(0) == sapChannel;
                        }
                        return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState();
                    });
            // After Soft Ap enabled, check SoftAp info if it supported
            if (isSupportCustomizedMac && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), TEST_MAC);
            }
            if (PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S)
                    && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertNotEquals(callback.getCurrentSoftApInfo().getWifiStandard(),
                        ScanResult.WIFI_STANDARD_UNKNOWN);
            }

            if (callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertTrue(callback.getCurrentSoftApInfo().getAutoShutdownTimeoutMillis() > 0);
            }
        } finally {
            // stop tethering which used to verify stopSoftAp
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);

            // Verify clean up
            PollingCheck.check(
                    ""Stop Softap failed"", 3_000,
                    () -> {
                        executor.runAll();
                        return WifiManager.WIFI_AP_STATE_DISABLED == callback.getCurrentState() &&
                                0 == callback.getCurrentSoftApInfo().getBandwidth() &&
                                0 == callback.getCurrentSoftApInfo().getFrequency();
                    });
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), null);
                assertEquals(ScanResult.WIFI_STANDARD_UNKNOWN,
                        callback.getCurrentSoftApInfo().getWifiStandard());
            }
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final Object mLock;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;
        public int failureReason = -1;

        TestActionListener(Object lock) {
            mLock = lock;
        }

        @Override
        public void onSuccess() {
            synchronized (mLock) {
                onSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onFailure(int reason) {
            synchronized (mLock) {
                onFailedCalled = true;
                failureReason = reason;
                mLock.notify();
            }
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * int, WifiManager.ActionListener)} or {@link WifiManager#connect(WifiConfiguration,
     * WifiManager.ActionListener)}
     *
     * @param withNetworkId Use networkId for triggering connection, false for using
     *                      WifiConfiguration.
     * @throws Exception
     */
    private void testConnect(boolean withNetworkId) throws Exception {
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)
            savedNetworks = mWifiManager.getConfiguredNetworks();

            // Disable all the saved networks to trigger disconnect & disable autojoin.
            for (WifiConfiguration network : savedNetworks) {
                assertTrue(mWifiManager.disableNetwork(network.networkId));
            }
            waitForDisconnection();

            // Now trigger connection to the last saved network.
            WifiConfiguration savedNetworkToConnect =
                    savedNetworks.get(savedNetworks.size() - 1);
            synchronized (mLock) {
                try {
                    if (withNetworkId) {
                        mWifiManager.connect(savedNetworkToConnect.networkId, actionListener);
                    } else {
                        mWifiManager.connect(savedNetworkToConnect, actionListener);
                    }
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);
            // Wait for connection to complete & ensure we are connected to the saved network.
            waitForConnection();
            if (SdkLevel.isAtLeastS()) {
                assertEquals(savedNetworkToConnect.networkId,
                        mWifiManager.getConnectionInfo().getNetworkId());
            } else {
                // In R, auto-upgraded network IDs may be different from the original saved network.
                // Since we may end up selecting the auto-upgraded network ID for connection and end
                // up connected to the original saved network with a different network ID, we should
                // instead match by SSID.
                assertEquals(savedNetworkToConnect.SSID,
                        mWifiManager.getConnectionInfo().getSSID());
            }
        } finally {
            // Re-enable all saved networks before exiting.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.enableNetwork(network.networkId, true);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#connect(int, WifiManager.ActionListener)} to an existing saved
     * network.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testConnectWithNetworkId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testConnectWithNetworkId() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        testConnect(true);
    }

    /**
     * Tests {@link WifiManager#connect(WifiConfiguration, WifiManager.ActionListener)} to an
     * existing saved network.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testConnectWithWifiConfiguration"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testConnectWithWifiConfiguration() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        testConnect(false);

    }

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final Object mLock;
        public boolean onAvailableCalled = false;
        public Network network;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(Object lock) {
            mLock = lock;
        }

        @Override
        public void onAvailable(Network network) {
            synchronized (mLock) {
                onAvailableCalled = true;
                this.network = network;
            }
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            synchronized (mLock) {
                this.networkCapabilities = networkCapabilities;
                mLock.notify();
            }
        }
    }

    private void waitForNetworkCallbackAndCheckForMeteredness(boolean expectMetered) {
        TestNetworkCallback networkCallbackListener = new TestNetworkCallback(mLock);
        synchronized (mLock) {
            try {
                NetworkRequest.Builder networkRequestBuilder = new NetworkRequest.Builder()
                        .addTransportType(TRANSPORT_WIFI);
                if (expectMetered) {
                    networkRequestBuilder.removeCapability(NET_CAPABILITY_NOT_METERED);
                } else {
                    networkRequestBuilder.addCapability(NET_CAPABILITY_NOT_METERED);
                }
                // File a request for wifi network.
                mConnectivityManager.registerNetworkCallback(
                        networkRequestBuilder.build(), networkCallbackListener);
                // now wait for callback
                mLock.wait(TEST_WAIT_DURATION_MS);
            } catch (InterruptedException e) {
            }
        }
        assertTrue(networkCallbackListener.onAvailableCalled);
    }

    /**
     * Tests {@link WifiManager#save(WifiConfiguration, WifiManager.ActionListener)} by marking
     * an existing saved network metered.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSave"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSave() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        WifiConfiguration currentConfig = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();

            WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

            // find the current network's WifiConfiguration
            currentConfig = mWifiManager.getConfiguredNetworks()
                    .stream()
                    .filter(config -> config.networkId == wifiInfo.getNetworkId())
                    .findAny()
                    .get();

            // Ensure that the current network is not metered.
            assertNotEquals(""Ensure that the saved network is configured as unmetered"",
                    currentConfig.meteredOverride,
                    WifiConfiguration.METERED_OVERRIDE_METERED);

            // Check the network capabilities to ensure that the network is marked not metered.
            waitForNetworkCallbackAndCheckForMeteredness(false);

            // Now mark the network metered and save.
            synchronized (mLock) {
                try {
                    WifiConfiguration modSavedNetwork = new WifiConfiguration(currentConfig);
                    modSavedNetwork.meteredOverride = WifiConfiguration.METERED_OVERRIDE_METERED;
                    mWifiManager.save(modSavedNetwork, actionListener);
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);
            // Ensure we disconnected on marking the network metered & connect back.
            waitForDisconnection();
            waitForConnection();
            // Check the network capabilities to ensure that the network is marked metered now.
            waitForNetworkCallbackAndCheckForMeteredness(true);

        } finally {
            // Restore original network config (restore the meteredness back);
            if (currentConfig != null) {
                mWifiManager.updateNetwork(currentConfig);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#forget(int, WifiManager.ActionListener)} by adding/removing a new
     * network.
     */
    @AsbSecurityTest(cveBugId = 159373687)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testForget"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testForget() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int newNetworkId = INVALID_NETWORK_ID;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)
            List<WifiConfiguration> savedNetworks = mWifiManager.getConfiguredNetworks();

            WifiConfiguration newOpenNetwork = new WifiConfiguration();
            newOpenNetwork.SSID = ""\"""" + TEST_SSID_UNQUOTED + ""\"""";
            newNetworkId = mWifiManager.addNetwork(newOpenNetwork);
            assertNotEquals(INVALID_NETWORK_ID, newNetworkId);

            // Multi-type configurations might be converted to more than 1 configuration.
            assertThat(savedNetworks.size() < mWifiManager.getConfiguredNetworks().size()).isTrue();

            // Need an effectively-final holder because we need to modify inner Intent in callback.
            class IntentHolder {
                Intent intent;
            }
            IntentHolder intentHolder = new IntentHolder();
            mContext.registerReceiver(new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    Log.i(TAG, ""Received CONFIGURED_NETWORKS_CHANGED_ACTION broadcast: "" + intent);
                    intentHolder.intent = intent;
                }
            }, new IntentFilter(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION));

            // Now remove the network
            synchronized (mLock) {
                try {
                    mWifiManager.forget(newNetworkId, actionListener);
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);

            PollingCheck.check(
                    ""Didn't receive CONFIGURED_NETWORKS_CHANGED_ACTION broadcast!"",
                    TEST_WAIT_DURATION_MS,
                    () -> intentHolder.intent != null);
            Intent intent = intentHolder.intent;
            assertEquals(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION, intent.getAction());
            assertTrue(intent.getBooleanExtra(WifiManager.EXTRA_MULTIPLE_NETWORKS_CHANGED, false));
            assertEquals(WifiManager.CHANGE_REASON_REMOVED,
                    intent.getIntExtra(WifiManager.EXTRA_CHANGE_REASON, -1));
            assertNull(intent.getParcelableExtra(WifiManager.EXTRA_WIFI_CONFIGURATION));

            // Ensure that the new network has been successfully removed.
            assertEquals(savedNetworks.size(), mWifiManager.getConfiguredNetworks().size());
        } finally {
            // For whatever reason, if the forget fails, try removing using the public remove API.
            if (newNetworkId != INVALID_NETWORK_ID) mWifiManager.removeNetwork(newNetworkId);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#getFactoryMacAddresses()} returns at least one valid MAC address.
     */
    @VirtualDeviceNotSupported"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetFactoryMacAddresses"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetFactoryMacAddresses() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int newNetworkId = INVALID_NETWORK_ID;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Obtain the factory MAC address
            String[] macAddresses = mWifiManager.getFactoryMacAddresses();
            assertTrue(""At list one MAC address should be returned."", macAddresses.length > 0);
            try {
                MacAddress mac = MacAddress.fromString(macAddresses[0]);
                assertNotEquals(WifiInfo.DEFAULT_MAC_ADDRESS, mac);
                assertFalse(MacAddressUtils.isMulticastAddress(mac));
            } catch (IllegalArgumentException e) {
                fail(""Factory MAC address is invalid"");
            }
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isApMacRandomizationSupported()} does not crash.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsApMacRandomizationSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsApMacRandomizationSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isApMacRandomizationSupported();
    }

    /**
     * Tests {@link WifiManager#isConnectedMacRandomizationSupported()} does not crash.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsConnectedMacRandomizationSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsConnectedMacRandomizationSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isConnectedMacRandomizationSupported();
    }

    /**
     * Tests {@link WifiManager#isPreferredNetworkOffloadSupported()} does not crash.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsPreferredNetworkOffloadSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsPreferredNetworkOffloadSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isPreferredNetworkOffloadSupported();
    }

    /** Test that PNO scans reconnects us when the device is disconnected and the screen is off. */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testPnoScan"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testPnoScan() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isPreferredNetworkOffloadSupported()) {
            // skip the test if PNO scanning is not supported
            return;
        }

        // make sure we're connected
        waitForConnection();

        WifiInfo currentNetwork = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConnectionInfo);

        // disable all networks that aren't already disabled
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        Set<Integer> disabledNetworkIds = new HashSet<>();
        for (WifiConfiguration config : savedNetworks) {
            if (config.getNetworkSelectionStatus().getNetworkSelectionDisableReason()
                    == WifiConfiguration.NetworkSelectionStatus.DISABLED_NONE) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.disableNetwork(config.networkId));
                disabledNetworkIds.add(config.networkId);
            }
        }

        try {
            // wait for disconnection from current network
            waitForDisconnection();

            // turn screen off
            turnScreenOffNoDelay();

            // re-enable the current network - this will trigger PNO
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.enableNetwork(currentNetwork.getNetworkId(), false));
            disabledNetworkIds.remove(currentNetwork.getNetworkId());

            // PNO should reconnect us back to the network we disconnected from
            waitForConnection();
        } finally {
            // re-enable disabled networks
            for (int disabledNetworkId : disabledNetworkIds) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.enableNetwork(disabledNetworkId, true));
            }
        }
    }

    /**
     * Tests {@link WifiManager#isTdlsSupported()} does not crash.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsTdlsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsTdlsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isTdlsSupported();
    }

    /**
     * Tests {@link WifiManager#isStaApConcurrencySupported().
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsStaApConcurrencySupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsStaApConcurrencySupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        assertTrue(mWifiManager.isWifiEnabled());

        boolean isStaApConcurrencySupported = mWifiManager.isStaApConcurrencySupported();
        // start local only hotspot.
        TestLocalOnlyHotspotCallback callback = startLocalOnlyHotspot();
        try {
            if (isStaApConcurrencySupported) {
                assertTrue(mWifiManager.isWifiEnabled());
            } else {
                // no concurrency, wifi should be disabled.
                assertFalse(mWifiManager.isWifiEnabled());
            }
        } finally {
            // clean up local only hotspot no matter if assertion passed or failed
            stopLocalOnlyHotspot(callback, true);
        }

        assertTrue(mWifiManager.isWifiEnabled());
    }

    /**
     * state is a bitset, where bit 0 indicates whether there was data in, and bit 1 indicates
     * whether there was data out. Only count down on the latch once there was both data in and out.
     */
    private static class TestTrafficStateCallback implements WifiManager.TrafficStateCallback {
        public final CountDownLatch latch = new CountDownLatch(1);
        private int mAccumulator = 0;

        @Override
        public void onStateChanged(int state) {
            mAccumulator |= state;
            if (mAccumulator == DATA_ACTIVITY_INOUT) {
                latch.countDown();
            }
        }
    }

    private void sendTraffic() {
        boolean didAnyConnectionSucceed = false;
        for (int i = 0; i < 10; i++) {
            // Do some network operations
            HttpURLConnection connection = null;
            try {
                URL url = new URL(""http://www.google.com/"");
                connection = (HttpURLConnection) url.openConnection();
                connection.setInstanceFollowRedirects(false);
                connection.setConnectTimeout(TEST_WAIT_DURATION_MS);
                connection.setReadTimeout(TEST_WAIT_DURATION_MS);
                connection.setUseCaches(false);
                InputStream stream = connection.getInputStream();
                byte[] bytes = new byte[100];
                int receivedBytes = stream.read(bytes);
                if (receivedBytes > 0) {
                    didAnyConnectionSucceed = true;
                }
            } catch (Exception e) {
                // ignore
            } finally {
                if (connection != null) connection.disconnect();
            }
        }
        assertTrue(""All connections failed!"", didAnyConnectionSucceed);
    }

    /**
     * Tests {@link WifiManager#registerTrafficStateCallback(Executor,
     * WifiManager.TrafficStateCallback)} by sending some traffic.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testTrafficStateCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testTrafficStateCallback() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestTrafficStateCallback callback = new TestTrafficStateCallback();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();

            // Turn screen on for wifi traffic polling.
            turnScreenOn();
            mWifiManager.registerTrafficStateCallback(
                    Executors.newSingleThreadExecutor(), callback);
            // Send some traffic to trigger the traffic state change callbacks.
            sendTraffic();
            // now wait for callback
            boolean success = callback.latch.await(TEST_WAIT_DURATION_MS, TimeUnit.MILLISECONDS);
            // check if we got the state changed callback with both data in and out
            assertTrue(success);
        } finally {
            turnScreenOff();
            mWifiManager.unregisterTrafficStateCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setScanAlwaysAvailable(boolean)} &
     * {@link WifiManager#isScanAlwaysAvailable()}.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScanAlwaysAvailable"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScanAlwaysAvailable() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isScanAlwaysAvailable();
            boolean newState = !currState;
            mWifiManager.setScanAlwaysAvailable(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isScanAlwaysAvailable() == newState);
            assertEquals(newState, mWifiManager.isScanAlwaysAvailable());
        } finally {
            if (currState != null) mWifiManager.setScanAlwaysAvailable(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setScanThrottleEnabled(boolean)} &
     * {@link WifiManager#isScanThrottleEnabled()}.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScanThrottleEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScanThrottleEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isScanThrottleEnabled();
            boolean newState = !currState;
            mWifiManager.setScanThrottleEnabled(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isScanThrottleEnabled() == newState);
            assertEquals(newState, mWifiManager.isScanThrottleEnabled());
        } finally {
            if (currState != null) mWifiManager.setScanThrottleEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setAutoWakeupEnabled(boolean)} &
     * {@link WifiManager#isAutoWakeupEnabled()}.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAutoWakeUpEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAutoWakeUpEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isAutoWakeupEnabled();
            boolean newState = !currState;
            mWifiManager.setAutoWakeupEnabled(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isAutoWakeupEnabled() == newState);
            assertEquals(newState, mWifiManager.isAutoWakeupEnabled());
        } finally {
            if (currState != null) mWifiManager.setAutoWakeupEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setVerboseLoggingEnabled(boolean)} &
     * {@link WifiManager#isVerboseLoggingEnabled()}.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testVerboseLoggingEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testVerboseLoggingEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        TestWifiVerboseLoggingStatusChangedListener listener =
                WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext) ?
                new TestWifiVerboseLoggingStatusChangedListener() : null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            if (listener != null) {
                mWifiManager.addWifiVerboseLoggingStatusChangedListener(mExecutor, listener);
            }
            currState = mWifiManager.isVerboseLoggingEnabled();
            boolean newState = !currState;
            if (listener != null) {
                assertEquals(0, listener.numCalls);
            }
            mWifiManager.setVerboseLoggingEnabled(newState);
            PollingCheck.check(
                    ""Wifi verbose logging toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isVerboseLoggingEnabled() == newState);
            if (listener != null) {
                PollingCheck.check(
                        ""Verbose logging listener timeout"",
                        DURATION_SETTINGS_TOGGLE,
                        () -> listener.status == newState && listener.numCalls == 1);
            }
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            if (listener != null) {
                mWifiManager.removeWifiVerboseLoggingStatusChangedListener(listener);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setVerboseLoggingLevel(int)}.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetVerboseLogging"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetVerboseLogging() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isVerboseLoggingEnabled();

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED);
            assertTrue(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED,
                    mWifiManager.getVerboseLoggingLevel());

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_DISABLED);
            assertFalse(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_DISABLED,
                    mWifiManager.getVerboseLoggingLevel());
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Test {@link WifiManager#setVerboseLoggingLevel(int)} for show key mode.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetVerboseLoggingShowKeyModeNonUserBuild"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetVerboseLoggingShowKeyModeNonUserBuild() throws Exception {
        if (Build.TYPE.equals(""user"")) return;
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isVerboseLoggingEnabled();

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY);
            assertTrue(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY,
                    mWifiManager.getVerboseLoggingLevel());
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Test {@link WifiManager#setVerboseLoggingLevel(int)} for show key mode.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetVerboseLoggingShowKeyModeUserBuild"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetVerboseLoggingShowKeyModeUserBuild() throws Exception {
        if (!Build.TYPE.equals(""user"")) return;
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isVerboseLoggingEnabled();

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY);
            assertTrue(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY,
                    mWifiManager.getVerboseLoggingLevel());
            fail(""Verbosing logging show key mode should not be allowed for user build."");
        } catch (SecurityException e) {
            // expected
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#factoryReset()} cannot be invoked from a non-privileged app.
     *
     * Note: This intentionally does not test the full reset functionality because it causes
     * the existing saved networks on the device to be lost after the test. If you add the
     * networks back after reset, the ownership of saved networks will change.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testFactoryReset"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testFactoryReset() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        List<WifiConfiguration> beforeSavedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        try {
            mWifiManager.factoryReset();
            fail(""Factory reset should not be allowed for non-privileged apps"");
        } catch (SecurityException e) {
            // expected
        }
        List<WifiConfiguration> afterSavedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        assertEquals(beforeSavedNetworks.size(), afterSavedNetworks.size());
    }

    /**
     * Test {@link WifiNetworkConnectionStatistics} does not crash.
     * TODO(b/150891569): deprecate it in Android S, this API is not used anywhere.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiNetworkConnectionStatistics"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiNetworkConnectionStatistics() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        new WifiNetworkConnectionStatistics();
        WifiNetworkConnectionStatistics stats = new WifiNetworkConnectionStatistics(0, 0);
        new WifiNetworkConnectionStatistics(stats);
    }

    /**
     * Verify that startRestrictingAutoJoinToSubscriptionId disconnects wifi and disables
     * auto-connect to non-carrier-merged networks. Then verify that
     * stopRestrictingAutoJoinToSubscriptionId makes the disabled networks clear to connect
     * again.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartAndStopRestrictingAutoJoinToSubscriptionId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartAndStopRestrictingAutoJoinToSubscriptionId() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        startScan();
        waitForConnection();
        int fakeSubscriptionId = 5;
        ShellIdentityUtils.invokeWithShellPermissions(() ->
                mWifiManager.startRestrictingAutoJoinToSubscriptionId(fakeSubscriptionId));
        startScan();
        ensureNotConnected();
        ShellIdentityUtils.invokeWithShellPermissions(() ->
                mWifiManager.stopRestrictingAutoJoinToSubscriptionId());
        startScan();
        waitForConnection();
    }

    /**
     * Test that the wifi country code is either null, or a length-2 string.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetCountryCode"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetCountryCode() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        String wifiCountryCode = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getCountryCode);

        if (wifiCountryCode == null) {
            return;
        }
        assertEquals(2, wifiCountryCode.length());

        // assert that the country code is all uppercase
        assertEquals(wifiCountryCode.toUpperCase(Locale.US), wifiCountryCode);

        // skip if Telephony is unsupported
        if (!WifiFeature.isTelephonySupported(getContext())) {
            return;
        }

        String telephonyCountryCode = getContext().getSystemService(TelephonyManager.class)
                .getNetworkCountryIso();

        // skip if Telephony country code is unavailable
        if (telephonyCountryCode == null || telephonyCountryCode.isEmpty()) {
            return;
        }

        assertEquals(telephonyCountryCode, wifiCountryCode.toLowerCase(Locale.US));
    }

    /**
     * Test that {@link WifiManager#getCurrentNetwork()} returns a Network obeject consistent
     * with {@link ConnectivityManager#registerNetworkCallback} when connected to a Wifi network,
     * and returns null when not connected.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetCurrentNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetCurrentNetwork() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected - Please ensure there is a saved network in range of this ""
                        + ""device"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        Network wifiCurrentNetwork = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getCurrentNetwork);
        assertNotNull(wifiCurrentNetwork);

        TestNetworkCallback networkCallbackListener = new TestNetworkCallback(mLock);
        synchronized (mLock) {
            try {
                // File a request for wifi network.
                mConnectivityManager.registerNetworkCallback(
                        new NetworkRequest.Builder()
                                .addTransportType(TRANSPORT_WIFI)
                                .build(),
                        networkCallbackListener);
                // now wait for callback
                mLock.wait(TEST_WAIT_DURATION_MS);
            } catch (InterruptedException e) {
            }
        }
        assertTrue(networkCallbackListener.onAvailableCalled);
        Network connectivityCurrentNetwork = networkCallbackListener.network;
        assertEquals(connectivityCurrentNetwork, wifiCurrentNetwork);

        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disconnected!"",
                20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);

        assertNull(ShellIdentityUtils.invokeWithShellPermissions(mWifiManager::getCurrentNetwork));
    }

    /**
     * Tests {@link WifiManager#isWpa3SaeSupported()} does not crash.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWpa3SaeSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWpa3SaeSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWpa3SaeSupported();
    }

    /**
     * Tests {@link WifiManager#isWpa3SuiteBSupported()} does not crash.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWpa3SuiteBSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWpa3SuiteBSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWpa3SuiteBSupported();
    }

    /**
     * Tests {@link WifiManager#isEnhancedOpenSupported()} does not crash.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsEnhancedOpenSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsEnhancedOpenSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isEnhancedOpenSupported();
    }

    /**
     * Test that {@link WifiManager#is5GHzBandSupported()} returns successfully in
     * both WiFi enabled/disabled states.
     * Note that the response depends on device support and hence both true/false
     * are valid responses.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs5GhzBandSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs5GhzBandSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for 5GHz support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isSupportedEnabled = mWifiManager.is5GHzBandSupported();

        // Check for 5GHz support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());
        boolean isSupportedDisabled = mWifiManager.is5GHzBandSupported();

        // If Support is true when WiFi is disable, then it has to be true when it is enabled.
        // Note, the reverse is a valid case.
        if (isSupportedDisabled) {
            assertTrue(isSupportedEnabled);
        }
    }

    /**
     * Test that {@link WifiManager#is6GHzBandSupported()} returns successfully in
     * both Wifi enabled/disabled states.
     * Note that the response depends on device support and hence both true/false
     * are valid responses.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs6GhzBandSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs6GhzBandSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for 6GHz support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isSupportedEnabled = mWifiManager.is6GHzBandSupported();

        // Check for 6GHz support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());
        boolean isSupportedDisabled = mWifiManager.is6GHzBandSupported();

        // If Support is true when WiFi is disable, then it has to be true when it is enabled.
        // Note, the reverse is a valid case.
        if (isSupportedDisabled) {
            assertTrue(isSupportedEnabled);
        }
    }

    /**
     * Test that {@link WifiManager#is60GHzBandSupported()} returns successfully in
     * both Wifi enabled/disabled states.
     * Note that the response depends on device support and hence both true/false
     * are valid responses.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs60GhzBandSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs60GhzBandSupported() throws Exception {
        if (!(WifiFeature.isWifiSupported(getContext())
                && ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S))) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for 60GHz support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isSupportedEnabled = mWifiManager.is60GHzBandSupported();

        // Check for 60GHz support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());
        boolean isSupportedDisabled = mWifiManager.is60GHzBandSupported();

        // If Support is true when WiFi is disable, then it has to be true when it is enabled.
        // Note, the reverse is a valid case.
        if (isSupportedDisabled) {
            assertTrue(isSupportedEnabled);
        }
    }

    /**
     * Test that {@link WifiManager#isWifiStandardSupported()} returns successfully in
     * both Wifi enabled/disabled states. The test is to be performed on
     * {@link WifiAnnotations}'s {@code WIFI_STANDARD_}
     * Note that the response depends on device support and hence both true/false
     * are valid responses.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetTdlsEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetTdlsEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        InetAddress inetAddress = InetAddress.getByName(TEST_IP_ADDRESS);

        mWifiManager.setTdlsEnabled(inetAddress, true);
        Thread.sleep(50);
        mWifiManager.setTdlsEnabled(inetAddress, false);
    }

    /**
     * Tests {@link WifiManager#setTdlsEnabledWithMacAddress(String, boolean)} does not crash.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetTdlsEnabledWithMacAddress"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetTdlsEnabledWithMacAddress() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        mWifiManager.setTdlsEnabledWithMacAddress(TEST_MAC_ADDRESS, true);
        Thread.sleep(50);
        mWifiManager.setTdlsEnabledWithMacAddress(TEST_MAC_ADDRESS, false);
    }

    /**
     * Verify WifiNetworkSuggestion.Builder.setMacRandomizationSetting(WifiNetworkSuggestion
     * .RANDOMIZATION_NON_PERSISTENT) creates a
     * WifiConfiguration with macRandomizationSetting == RANDOMIZATION_NON_PERSISTENT.
     * Then verify by default, a WifiConfiguration created by suggestions should have
     * macRandomizationSetting == RANDOMIZATION_PERSISTENT.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSuggestionBuilderNonPersistentRandomization"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSuggestionBuilderNonPersistentRandomization() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE)
                .setMacRandomizationSetting(WifiNetworkSuggestion.RANDOMIZATION_NON_PERSISTENT)
                .build();
        assertEquals(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS,
                mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)));
        verifySuggestionFoundWithMacRandomizationSetting(TEST_SSID,
                WifiConfiguration.RANDOMIZATION_NON_PERSISTENT);

        suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE)
                .build();
        assertEquals(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS,
                mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)));
        verifySuggestionFoundWithMacRandomizationSetting(TEST_SSID,
                WifiConfiguration.RANDOMIZATION_PERSISTENT);
    }

    private void verifySuggestionFoundWithMacRandomizationSetting(String ssid,
            int macRandomizationSetting) {
        List<WifiNetworkSuggestion> retrievedSuggestions = mWifiManager.getNetworkSuggestions();
        for (WifiNetworkSuggestion entry : retrievedSuggestions) {
            if (entry.getSsid().equals(ssid)) {
                assertEquals(macRandomizationSetting,
                        entry.getWifiConfiguration().macRandomizationSetting);
                return; // pass test after the MAC randomization setting is verified.
            }
        }
        fail(""WifiNetworkSuggestion not found for SSID="" + ssid + "", macRandomizationSetting=""
                + macRandomizationSetting);
    }

    /**
     * Tests {@link WifiManager#getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(List)}
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetAllWifiConfigForMatchedNetworkSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetAllWifiConfigForMatchedNetworkSuggestion() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.capabilities = TEST_PSK_CAP;
        scanResult.BSSID = TEST_BSSID;
        List<ScanResult> testList = Arrays.asList(scanResult);
        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE).build();

        assertEquals(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS,
                mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)));
        List<WifiConfiguration> matchedResult;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            matchedResult = mWifiManager
                    .getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(testList);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        // As suggestion is not approved, will return empty list.
        assertTrue(matchedResult.isEmpty());
    }

    /**
     * Tests {@link WifiManager#getMatchingScanResults(List, List)}
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetMatchingScanResults"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetMatchingScanResults() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Create pair of ScanResult and WifiNetworkSuggestion
        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.capabilities = TEST_PSK_CAP;
        scanResult.BSSID = TEST_BSSID;

        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE).build();

        Map<WifiNetworkSuggestion, List<ScanResult>> matchedResults = mWifiManager
                .getMatchingScanResults(Arrays.asList(suggestion), Arrays.asList(scanResult));
        // Verify result is matched pair of ScanResult and WifiNetworkSuggestion
        assertEquals(scanResult.SSID, matchedResults.get(suggestion).get(0).SSID);

        // Change ScanResult to unmatched should return empty result.
        scanResult.SSID = TEST_SSID_UNQUOTED;
        matchedResults = mWifiManager
                .getMatchingScanResults(Arrays.asList(suggestion), Arrays.asList(scanResult));
        assertTrue(matchedResults.get(suggestion).isEmpty());
    }

    /**
     * Tests {@link WifiManager#disableEphemeralNetwork(String)}.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testDisableEphemeralNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testDisableEphemeralNetwork() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Temporarily disable on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.disableEphemeralNetwork(network.SSID);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
            setWifiEnabled(false);
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoin(int, boolean)}.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoinGlobal"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoinGlobal() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            mWifiManager.allowAutojoinGlobal(false);

            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            mWifiManager.allowAutojoinGlobal(true);

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Re-enable auto join if the test fails for some reason.
            mWifiManager.allowAutojoinGlobal(true);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isWapiSupported()} does not crash.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWapiSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWapiSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWapiSupported();
    }

    /**
     * Tests {@link WifiManager#isWpa3SaePublicKeySupported()} does not crash.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWpa3SaePublicKeySupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWpa3SaePublicKeySupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWpa3SaePublicKeySupported();
    }

    /**
     * Tests {@link WifiManager#isWpa3SaeH2eSupported()} does not crash.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWpa3SaeH2eSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWpa3SaeH2eSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWpa3SaeH2eSupported();
    }

    /**
     * Tests {@link WifiManager#isWifiDisplayR2Supported()} does not crash.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWifiDisplayR2Supported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWifiDisplayR2Supported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isWifiDisplayR2Supported();
    }

    /**
     * Tests {@link WifiManager#isP2pSupported()} returns true
     * if this device supports it, otherwise, ensure no crash.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsP2pSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsP2pSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        if (WifiFeature.isP2pSupported(getContext())) {
            // if this device supports P2P, ensure hw capability is correct.
            assertTrue(mWifiManager.isP2pSupported());
        } else {
            // ensure no crash.
            mWifiManager.isP2pSupported();
        }

    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs60GhzBandSupportedOnROrOlder"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs60GhzBandSupportedOnROrOlder() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // check for 60ghz support with wifi enabled
        try {
            boolean isSupported = mWifiManager.is60GHzBandSupported();
            fail(""Expected UnsupportedOperationException"");
        } catch (UnsupportedOperationException ex) {
        }

    }

    /**
     * Test that {@link WifiManager#is60GHzBandSupported()} returns successfully in
     * both Wifi enabled/disabled states for release newer than R.
     * Note that the response depends on device support and hence both true/false
     * are valid responses.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs60GhzBandSupportedOnSOrNewer"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIs60GhzBandSupportedOnSOrNewer() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // check for 60ghz support with wifi enabled
        boolean isSupportedWhenWifiEnabled = mWifiManager.is60GHzBandSupported();

        // Check for 60GHz support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());
        boolean isSupportedWhenWifiDisabled = mWifiManager.is60GHzBandSupported();

        // If Support is true when WiFi is disable, then it has to be true when it is enabled.
        // Note, the reverse is a valid case.
        if (isSupportedWhenWifiDisabled) {
            assertTrue(isSupportedWhenWifiEnabled);
        }
    }

    public class TestCoexCallback extends WifiManager.CoexCallback {
        private Object mCoexLock;
        private int mOnCoexUnsafeChannelChangedCount;
        private List<CoexUnsafeChannel> mCoexUnsafeChannels;
        private int mCoexRestrictions;

        TestCoexCallback(Object lock) {
            mCoexLock = lock;
        }

        @Override
        public void onCoexUnsafeChannelsChanged(
                    @NonNull List<CoexUnsafeChannel> unsafeChannels, int restrictions) {
            synchronized (mCoexLock) {
                mCoexUnsafeChannels = unsafeChannels;
                mCoexRestrictions = restrictions;
                mOnCoexUnsafeChannelChangedCount++;
                mCoexLock.notify();
            }
        }

        public int getOnCoexUnsafeChannelChangedCount() {
            synchronized (mCoexLock) {
                return mOnCoexUnsafeChannelChangedCount;
            }
        }

        public List<CoexUnsafeChannel> getCoexUnsafeChannels() {
            return mCoexUnsafeChannels;
        }

        public int getCoexRestrictions() {
            return mCoexRestrictions;
        }
    }

    /**
     * Test that coex-related methods fail without the needed privileged permissions
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testCoexMethodsShouldFailNoPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testCoexMethodsShouldFailNoPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        try {
            mWifiManager.setCoexUnsafeChannels(Collections.emptyList(), 0);
            fail(""setCoexUnsafeChannels should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
        final TestCoexCallback callback = new TestCoexCallback(mLock);
        try {
            mWifiManager.registerCoexCallback(mExecutor, callback);
            fail(""registerCoexCallback should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
        try {
            mWifiManager.unregisterCoexCallback(callback);
            fail(""unregisterCoexCallback should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Test that coex-related methods succeed in setting the current unsafe channels and notifying
     * the listener. Since the default coex algorithm may be enabled, no-op is also valid behavior.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testListenOnCoexUnsafeChannels"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testListenOnCoexUnsafeChannels() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // These below API's only work with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<CoexUnsafeChannel> prevUnsafeChannels = null;
        int prevRestrictions = -1;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            final TestCoexCallback callback = new TestCoexCallback(mLock);
            final List<CoexUnsafeChannel> testUnsafeChannels = new ArrayList<>();
            testUnsafeChannels.add(new CoexUnsafeChannel(WIFI_BAND_24_GHZ, 6));
            final int testRestrictions = COEX_RESTRICTION_WIFI_DIRECT
                    | COEX_RESTRICTION_SOFTAP | COEX_RESTRICTION_WIFI_AWARE;
            synchronized (mLock) {
                try {
                    mWifiManager.registerCoexCallback(mExecutor, callback);
                    // Callback should be called after registering
                    mLock.wait(TEST_WAIT_DURATION_MS);
                    assertEquals(1, callback.getOnCoexUnsafeChannelChangedCount());
                    // Store the previous coex channels and set new coex channels
                    prevUnsafeChannels = callback.getCoexUnsafeChannels();
                    prevRestrictions = callback.getCoexRestrictions();
                    mWifiManager.setCoexUnsafeChannels(testUnsafeChannels, testRestrictions);
                    mLock.wait(TEST_WAIT_DURATION_MS);
                    // Unregister callback and try setting again
                    mWifiManager.unregisterCoexCallback(callback);
                    mWifiManager.setCoexUnsafeChannels(testUnsafeChannels, testRestrictions);
                    // Callback should not be called here since it was unregistered.
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                    fail(""Thread interrupted unexpectedly while waiting on mLock"");
                }
            }
            if (callback.getOnCoexUnsafeChannelChangedCount() == 2) {
                // Default algorithm disabled, setter should set the getter values.
                assertEquals(testUnsafeChannels, callback.getCoexUnsafeChannels());
                assertEquals(testRestrictions, callback.getCoexRestrictions());
            } else if (callback.getOnCoexUnsafeChannelChangedCount() != 1) {
                fail(""Coex callback called "" + callback.mOnCoexUnsafeChannelChangedCount
                        + "" times. Expected 0 or 1 calls."" );
            }
        } finally {
            // Reset the previous unsafe channels if we overrode them.
            if (prevRestrictions != -1) {
                mWifiManager.setCoexUnsafeChannels(prevUnsafeChannels, prevRestrictions);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }


    /**
     * Verify that insecure WPA-Enterprise network configurations are rejected.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsDecoratedIdentitySupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsDecoratedIdentitySupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        mWifiManager.isDecoratedIdentitySupported();
    }

    /**
     * Tests {@link WifiManager#setCarrierNetworkOffloadEnabled)} and
     * {@link WifiManager#isCarrierNetworkOffloadEnabled} work as expected.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetCarrierNetworkOffloadEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetCarrierNetworkOffloadEnabled() {
        if (!WifiFeature.isWifiSupported(getContext())
                || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        assertTrue(mWifiManager.isCarrierNetworkOffloadEnabled(TEST_SUB_ID, false));
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.setCarrierNetworkOffloadEnabled(TEST_SUB_ID, false, false);
            assertFalse(mWifiManager.isCarrierNetworkOffloadEnabled(TEST_SUB_ID, false));
        } finally {
            mWifiManager.setCarrierNetworkOffloadEnabled(TEST_SUB_ID, false, true);
            uiAutomation.dropShellPermissionIdentity();
        }
        assertTrue(mWifiManager.isCarrierNetworkOffloadEnabled(TEST_SUB_ID, false));
    }

   /**
     * Test that {@link WifiManager#getUsableChannels(int, int)},
     * {@link WifiManager#getAllowedChannels(int, int)}
     * throws UnsupportedOperationException if the release is older than S.
     */
    @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.R)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetAllowedUsableChannelsOnROrOlder"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetAllowedUsableChannelsOnROrOlder() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        try {
            mWifiManager.getAllowedChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            fail(""getAllowedChannels Expected to fail - UnsupportedOperationException"");
        } catch (UnsupportedOperationException ex) {}

        try {
            mWifiManager.getUsableChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            fail(""getUsableChannels Expected to fail - UnsupportedOperationException"");
        } catch (UnsupportedOperationException ex) {}
    }

    /**
     * Tests {@link WifiManager#getAllowedChannels(int, int))} does not crash
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetAllowedChannels"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetAllowedChannels() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {

            WifiAvailableChannel channel = new WifiAvailableChannel(2412, OP_MODE_SAP);
            assertEquals(channel.getFrequencyMhz(), 2412);
            assertEquals(channel.getOperationalModes(), OP_MODE_SAP);
            final List<Integer> valid24GhzFreqs = Arrays.asList(
                2412, 2417, 2422, 2427, 2432, 2437, 2442,
                2447, 2452, 2457, 2462, 2467, 2472, 2484);
            Set<Integer> supported24GhzFreqs = new HashSet<Integer>();
            uiAutomation.adoptShellPermissionIdentity();
            List<WifiAvailableChannel> allowedChannels =
                mWifiManager.getAllowedChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            assertNotNull(allowedChannels);
            for (WifiAvailableChannel ch : allowedChannels) {
                //Must contain a valid 2.4GHz frequency
                assertTrue(valid24GhzFreqs.contains(ch.getFrequencyMhz()));
                if(ch.getFrequencyMhz() <= 2462) {
                    //Channels 1-11 are supported for STA in all countries
                    assertEquals(ch.getOperationalModes() & OP_MODE_STA, OP_MODE_STA);
                    supported24GhzFreqs.add(ch.getFrequencyMhz());
                }
            }
            //Channels 1-11 are supported for STA in all countries
            assertEquals(supported24GhzFreqs.size(), 11);
        } catch (UnsupportedOperationException ex) {
            //expected if the device does not support this API
        } catch (Exception ex) {
            fail(""getAllowedChannels unexpected Exception "" + ex);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#getUsableChannels(int, int))} does not crash.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddRemoveSuggestionUserApprovalStatusListener"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddRemoveSuggestionUserApprovalStatusListener() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())
                || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }
        CountDownLatch countDownLatch = new CountDownLatch(1);
        TestUserApprovalStatusListener listener = new TestUserApprovalStatusListener(
                countDownLatch);
        try {
            mWifiManager.addSuggestionUserApprovalStatusListener(mExecutor, listener);
            assertTrue(countDownLatch.await(TEST_WAIT_DURATION_MS, TimeUnit.MILLISECONDS));
        } finally {
            mWifiManager.removeSuggestionUserApprovalStatusListener(listener);
        }
    }

    private static class TestUserApprovalStatusListener implements
            WifiManager.SuggestionUserApprovalStatusListener {
        private final CountDownLatch mBlocker;

        public TestUserApprovalStatusListener(CountDownLatch countDownLatch) {
            mBlocker = countDownLatch;
        }
        @Override
        public void onUserApprovalStatusChange(int status) {
            mBlocker.countDown();
        }
    }
}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.BaseTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/BaseTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware;

import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.view.WindowManager;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

/**
 * Base class for Aware tests.
 */
public abstract class BaseTestActivity extends PassFailButtons.Activity implements
        BaseTestCase.Listener {
    /*
     * Handles to GUI elements.
     */
    private TextView mAwareInfo;
    private ProgressBar mAwareProgress;

    /*
     * Test case to be executed
     */
    private BaseTestCase mTestCase;

    private Handler mHandler = new Handler();

    protected abstract BaseTestCase getTestCase(Context context);

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.aware_main);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        // Get UI component.
        mAwareInfo = (TextView) findViewById(R.id.aware_info);
        mAwareProgress = (ProgressBar) findViewById(R.id.aware_progress);

        // Initialize test components.
        mTestCase = getTestCase(this);

        // keep screen on while this activity is front view.
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
    }

    @Override
    protected void onResume() {
        super.onResume();
        mTestCase.start(this);
        mAwareProgress.setVisibility(View.VISIBLE);
    }

    @Override
    protected void onPause() {
        super.onPause();
        mTestCase.stop();
        mAwareProgress.setVisibility(View.GONE);
    }


    @Override
    public void onTestStarted() {
        // nop
    }

    @Override
    public void onTestMsgReceived(String msg) {
        if (msg == null) {
            return;
        }
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                mAwareInfo.append(msg);
                mAwareInfo.append(""\n"");
            }
        });
    }

    @Override
    public void onTestSuccess() {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                getPassButton().setEnabled(true);
                mAwareProgress.setVisibility(View.GONE);
            }
        });
    }

    @Override
    public void onTestFailed(String reason) {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                if (reason != null) {
                    mAwareInfo.append(reason);
                }
                mAwareProgress.setVisibility(View.GONE);
            }
        });
    }
}"	""	""	"flag"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiMigrationTest"	"testWifiMigrationSettingsDataBuilder"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiMigrationTest.java"	""	"public void testWifiMigrationSettingsDataBuilder() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiMigration.SettingsMigrationData migrationData =
                new WifiMigration.SettingsMigrationData.Builder()
                        .setScanAlwaysAvailable(true)
                        .setP2pFactoryResetPending(true)
                        .setScanThrottleEnabled(true)
                        .setSoftApTimeoutEnabled(true)
                        .setWakeUpEnabled(true)
                        .setVerboseLoggingEnabled(true)
                        .setP2pDeviceName(TEST_SSID_UNQUOTED)
                        .build();

        assertNotNull(migrationData);
        assertTrue(migrationData.isScanAlwaysAvailable());
        assertTrue(migrationData.isP2pFactoryResetPending());
        assertTrue(migrationData.isScanThrottleEnabled());
        assertTrue(migrationData.isSoftApTimeoutEnabled());
        assertTrue(migrationData.isWakeUpEnabled());
        assertTrue(migrationData.isVerboseLoggingEnabled());
        assertEquals(TEST_SSID_UNQUOTED, migrationData.getP2pDeviceName());
    }

    /**
     * Tests {@link android.net.wifi.WifiMigration.SettingsMigrationData} class.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLockTest"	"testLowLatencyWifiLock"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLockTest.java"	""	"public void testLowLatencyWifiLock() {
        testWifiLock(WifiManager.WIFI_MODE_FULL_LOW_LATENCY);
    }

    private void testWifiLock(int lockType) {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiManager wm = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        WifiLock wl = wm.createWifiLock(lockType, WIFI_TAG);

        wl.setReferenceCounted(true);
        wl.setWorkSource(new WorkSource());
        assertFalse(wl.isHeld());
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        wl.acquire();
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        assertNotNull(wl.toString());
        try {
            wl.release();
            fail(""should throw out exception because release is called""
                    +"" a greater number of times than acquire"");
        } catch (RuntimeException e) {
            // expected
        }

        wl = wm.createWifiLock(lockType, WIFI_TAG);
        wl.setReferenceCounted(false);
        assertFalse(wl.isHeld());
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        wl.acquire();
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        assertNotNull(wl.toString());
        // releasing again after release: but ignored for non-referenced locks
        wl.release();
    }
}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.PpsMoParserTest"	"getRoamingConsortiumOis"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/PpsMoParserTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.omadm.PpsMoParser;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.test.AndroidTestCase;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * CTS tests for PPS MO (PerProviderSubscription Management Object) XML string parsing API.
 */
public class PpsMoParserTest extends WifiJUnit3TestBase {
    private static final String PPS_MO_XML_FILE = ""assets/PerProviderSubscription.xml"";

    /**
     * Read the content of the given resource file into a String.
     *
     * @param filename String name of the file
     * @return String
     * @throws IOException
     */
    private String loadResourceFile(String filename) throws IOException {
        InputStream in = getClass().getClassLoader().getResourceAsStream(filename);
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        StringBuilder builder = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            builder.append(line).append(""\n"");
        }
        return builder.toString();
    }

    /**
     * Generate a {@link PasspointConfiguration} that matches the configuration specified in the
     * XML file {@link #PPS_MO_XML_FILE}.
     *
     * @return {@link PasspointConfiguration}
     */
    private PasspointConfiguration generateConfigurationFromPPSMOTree() throws Exception {
        DateFormat format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss'Z'"");
        byte[] certFingerprint = new byte[32];
        Arrays.fill(certFingerprint, (byte) 0x1f);

        PasspointConfiguration config = new PasspointConfiguration();

        // HomeSP configuration.
        HomeSp homeSp = new HomeSp();
        homeSp.setFriendlyName(""Century House"");
        assertEquals(""Century House"", homeSp.getFriendlyName());
        homeSp.setFqdn(""mi6.co.uk"");
        assertEquals(""mi6.co.uk"", homeSp.getFqdn());
        homeSp.setRoamingConsortiumOis(new long[] {0x112233L, 0x445566L});
        assertTrue(Arrays.equals(new long[] {0x112233L, 0x445566L},
                homeSp.getRoamingConsortiumOis()));
        config.setHomeSp(homeSp);
        assertEquals(homeSp, config.getHomeSp());

        // Credential configuration.
        Credential credential = new Credential();
        credential.setRealm(""shaken.stirred.com"");
        assertEquals(""shaken.stirred.com"", credential.getRealm());
        Credential.UserCredential userCredential = new Credential.UserCredential();
        userCredential.setUsername(""james"");
        assertEquals(""james"", userCredential.getUsername());
        userCredential.setPassword(""Ym9uZDAwNw=="");
        assertEquals(""Ym9uZDAwNw=="", userCredential.getPassword());
        userCredential.setEapType(21);
        assertEquals(21, userCredential.getEapType());
        userCredential.setNonEapInnerMethod(""MS-CHAP-V2"");
        assertEquals(""MS-CHAP-V2"", userCredential.getNonEapInnerMethod());
        credential.setUserCredential(userCredential);
        assertEquals(userCredential, credential.getUserCredential());
        Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
        certCredential.setCertType(""x509v3"");
        assertEquals(""x509v3"", certCredential.getCertType());
        certCredential.setCertSha256Fingerprint(certFingerprint);
        assertTrue(Arrays.equals(certFingerprint, certCredential.getCertSha256Fingerprint()));
        credential.setCertCredential(certCredential);
        assertEquals(certCredential, credential.getCertCredential());
        Credential.SimCredential simCredential = new Credential.SimCredential();
        simCredential.setImsi(""imsi"");
        assertEquals(""imsi"", simCredential.getImsi());
        simCredential.setEapType(24);
        assertEquals(24, simCredential.getEapType());
        credential.setSimCredential(simCredential);
        assertEquals(simCredential, credential.getSimCredential());
        config.setCredential(credential);
        assertEquals(credential, config.getCredential());
        return config;
    }

    /**
     * Parse and verify all supported fields under PPS MO tree.
     *
     * @throws Exception
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.PpsMoParserTest"	"testParsePPSMOTree"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/PpsMoParserTest.java"	""	"public void testParsePPSMOTree() throws Exception {
        String ppsMoTree = loadResourceFile(PPS_MO_XML_FILE);
        PasspointConfiguration expectedConfig = generateConfigurationFromPPSMOTree();
        PasspointConfiguration actualConfig = PpsMoParser.parseMoText(ppsMoTree);
        assertTrue(actualConfig.equals(expectedConfig));
    }
}"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"ActionListener"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static org.junit.Assert.assertNotEquals;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.wifi.WifiManager;
import android.net.wifi.p2p.WifiP2pDevice;
import android.net.wifi.p2p.WifiP2pGroup;
import android.net.wifi.p2p.WifiP2pGroupList;
import android.net.wifi.p2p.WifiP2pInfo;
import android.net.wifi.p2p.WifiP2pManager;
import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
import android.net.wifi.p2p.nsd.WifiP2pUpnpServiceInfo;
import android.provider.Settings;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class ConcurrencyTest extends WifiJUnit3TestBase {
    private class MySync {
        static final int WIFI_STATE = 0;
        static final int P2P_STATE = 1;
        static final int DISCOVERY_STATE = 2;
        static final int NETWORK_INFO = 3;

        public BitSet pendingSync = new BitSet();

        public int expectedWifiState;
        public int expectedP2pState;
        public int expectedDiscoveryState;
        public NetworkInfo expectedNetworkInfo;
    }

    private class MyResponse {
        public boolean valid = false;

        public boolean success;
        public int failureReason;
        public int p2pState;
        public int discoveryState;
        public NetworkInfo networkInfo;
        public WifiP2pInfo p2pInfo;
        public String deviceName;
        public WifiP2pGroupList persistentGroups;
        public WifiP2pGroup group = new WifiP2pGroup();
    }

    private WifiManager mWifiManager;
    private WifiP2pManager mWifiP2pManager;
    private WifiP2pManager.Channel mWifiP2pChannel;
    private MySync mMySync = new MySync();
    private MyResponse mMyResponse = new MyResponse();
    private boolean mWasVerboseLoggingEnabled;

    private static final String TAG = ""ConcurrencyTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION = 5000;
    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.WIFI_STATE);
                    mMySync.expectedWifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
                            WifiManager.WIFI_STATE_DISABLED);
                    mMySync.notify();
                }
            } else if(action.equals(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.P2P_STATE);
                    mMySync.expectedP2pState = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE,
                            WifiP2pManager.WIFI_P2P_STATE_DISABLED);
                    mMySync.notify();
                }
            } else if (action.equals(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.DISCOVERY_STATE);
                    mMySync.expectedDiscoveryState = intent.getIntExtra(
                            WifiP2pManager.EXTRA_DISCOVERY_STATE,
                            WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED);
                    mMySync.notify();
                }
            } else if (action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.NETWORK_INFO);
                    mMySync.expectedNetworkInfo = (NetworkInfo) intent.getExtra(
                            WifiP2pManager.EXTRA_NETWORK_INFO, null);
                    Log.d(TAG, ""Get WIFI_P2P_CONNECTION_CHANGED_ACTION: ""
                            + mMySync.expectedNetworkInfo);
                    mMySync.notify();
                }
            }
        }
    };

    private WifiP2pManager.ActionListener mActionListener = new WifiP2pManager.ActionListener() {
        @Override
        public void onSuccess() {
            synchronized (mMyResponse) {
                mMyResponse.valid = true;
                mMyResponse.success = true;
                mMyResponse.notify();
            }
        }

        @Override
        public void onFailure(int reason) {
            synchronized (mMyResponse) {
                Log.d(TAG, ""failure reason: "" + reason);
                mMyResponse.valid = true;
                mMyResponse.success = false;
                mMyResponse.failureReason = reason;
                mMyResponse.notify();
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
       super.setUp();
       if (!WifiFeature.isWifiSupported(getContext()) &&
                !WifiFeature.isP2pSupported(getContext())) {
            // skip the test if WiFi && p2p are not supported
            return;
        }

        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(mWifiManager);
        if (mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi disable"");
            Thread.sleep(DURATION);
        }

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        assertTrue(!mWifiManager.isWifiEnabled());
        mMySync.expectedWifiState = WifiManager.WIFI_STATE_DISABLED;
        mMySync.expectedP2pState = WifiP2pManager.WIFI_P2P_STATE_DISABLED;
        mMySync.expectedDiscoveryState = WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED;
        mMySync.expectedNetworkInfo = null;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext()) &&
                !WifiFeature.isP2pSupported(getContext())) {
            // skip the test if WiFi and p2p are not supported
            super.tearDown();
            return;
        }
        if (null != mWifiP2pManager) {
            removeAllPersistentGroups();
        }
        mContext.unregisterReceiver(mReceiver);

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));

        enableWifi();
        super.tearDown();
    }

    private boolean waitForBroadcasts(List<Integer> waitSyncList) {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                List<Integer> handledSyncList = waitSyncList.stream()
                        .filter(w -> mMySync.pendingSync.get(w))
                        .collect(Collectors.toList());
                handledSyncList.forEach(w -> mMySync.pendingSync.clear(w));
                waitSyncList.removeAll(handledSyncList);
                if (waitSyncList.isEmpty()) {
                    break;
                }
                try {
                    mMySync.wait(WAIT_MSEC);
                } catch (InterruptedException e) { }
            }
            if (!waitSyncList.isEmpty()) {
                Log.i(TAG, ""Missing broadcast: "" + waitSyncList);
            }
            return waitSyncList.isEmpty();
        }
    }

    private boolean waitForBroadcasts(int waitSingleSync) {
        return waitForBroadcasts(
                new LinkedList<Integer>(Arrays.asList(waitSingleSync)));
    }

    private boolean waitForServiceResponse(MyResponse waitResponse) {
        synchronized (waitResponse) {
            long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                try {
                    waitResponse.wait(WAIT_MSEC);
                } catch (InterruptedException e) { }

                if (waitResponse.valid) {
                    return true;
                }
            }
            return false;
        }
    }

    // Return true if location is enabled.
    private boolean isLocationEnabled() {
        return Settings.Secure.getInt(getContext().getContentResolver(),
                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF)
                != Settings.Secure.LOCATION_MODE_OFF;
    }

    // Returns true if the device has location feature.
    private boolean hasLocationFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION);
    }

    private void resetResponse(MyResponse responseObj) {
        synchronized (responseObj) {
            responseObj.valid = false;
            responseObj.networkInfo = null;
            responseObj.p2pInfo = null;
            responseObj.deviceName = null;
            responseObj.persistentGroups = null;
            responseObj.group = null;
        }
    }

    /*
     * Enables Wifi and block until connection is established.
     */
    private void enableWifi() throws InterruptedException {
        if (!mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable"");
        }

        ConnectivityManager cm =
            (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkRequest request =
            new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                                        .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                                        .build();
        final CountDownLatch latch = new CountDownLatch(1);
        NetworkCallback networkCallback = new NetworkCallback() {
            @Override
            public void onAvailable(Network network) {
                latch.countDown();
            }
        };
        cm.registerNetworkCallback(request, networkCallback);
        latch.await(DURATION, TimeUnit.MILLISECONDS);

        cm.unregisterNetworkCallback(networkCallback);
    }

    private void removeAllPersistentGroups() {
        WifiP2pGroupList persistentGroups = getPersistentGroups();
        assertNotNull(persistentGroups);
        for (WifiP2pGroup group: persistentGroups.getGroupList()) {
            resetResponse(mMyResponse);
            ShellIdentityUtils.invokeWithShellPermissions(() -> {
                mWifiP2pManager.deletePersistentGroup(mWifiP2pChannel,
                        group.getNetworkId(),
                        mActionListener);
                assertTrue(waitForServiceResponse(mMyResponse));
                assertTrue(mMyResponse.success);
            });
        }
        persistentGroups = getPersistentGroups();
        assertNotNull(persistentGroups);
        assertEquals(0, persistentGroups.getGroupList().size());
    }

    private boolean setupWifiP2p() {
        // Cannot support p2p alone
        if (!WifiFeature.isWifiSupported(getContext())) {
            assertTrue(!WifiFeature.isP2pSupported(getContext()));
            return false;
        }

        if (!WifiFeature.isP2pSupported(getContext())) {
            // skip the test if p2p is not supported
            return false;
        }

        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return false;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since P-release WiFi Direct""
                    + "" needs Location enabled."");
        }

        long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
        while (!mWifiManager.isWifiEnabled() && System.currentTimeMillis() < timeout) {
            try {
                enableWifi();
            } catch (InterruptedException e) { }
        }

        assertTrue(mWifiManager.isWifiEnabled());

        mWifiP2pManager =
                (WifiP2pManager) getContext().getSystemService(Context.WIFI_P2P_SERVICE);
        mWifiP2pChannel = mWifiP2pManager.initialize(
                getContext(), getContext().getMainLooper(), null);

        assertNotNull(mWifiP2pManager);
        assertNotNull(mWifiP2pChannel);

        assertTrue(waitForBroadcasts(
                new LinkedList<Integer>(
                Arrays.asList(MySync.WIFI_STATE, MySync.P2P_STATE))));

        assertEquals(WifiManager.WIFI_STATE_ENABLED, mMySync.expectedWifiState);
        assertEquals(WifiP2pManager.WIFI_P2P_STATE_ENABLED, mMySync.expectedP2pState);
        removeAllPersistentGroups();

        return true;
    }"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MulticastLockTest"	"testMulticastLock"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MulticastLockTest.java"	""	"public void testMulticastLock() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiManager wm = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        MulticastLock mcl = wm.createMulticastLock(WIFI_TAG);

        mcl.setReferenceCounted(true);
        assertFalse(mcl.isHeld());
        mcl.acquire();
        assertTrue(mcl.isHeld());
        mcl.release();
        assertFalse(mcl.isHeld());
        mcl.acquire();
        mcl.acquire();
        assertTrue(mcl.isHeld());
        mcl.release();
        assertTrue(mcl.isHeld());
        mcl.release();
        assertFalse(mcl.isHeld());
        assertNotNull(mcl.toString());
        try {
            mcl.release();
            fail(""should throw out exception because release is called""
                    +"" a greater number of times than acquire"");
        } catch (RuntimeException e) {
            // expected
        }

        mcl = wm.createMulticastLock(WIFI_TAG);
        mcl.setReferenceCounted(false);
        assertFalse(mcl.isHeld());
        mcl.acquire();
        assertTrue(mcl.isHeld());
        mcl.release();
        assertFalse(mcl.isHeld());
        mcl.acquire();
        mcl.acquire();
        assertTrue(mcl.isHeld());
        mcl.release();
        assertFalse(mcl.isHeld());
        assertNotNull(mcl.toString());
        // releasing again after release: but ignored for non-referenced locks
        mcl.release();
    }
}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.SupplicantStateTest"	"testIsValidState"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/SupplicantStateTest.java"	""	"public void testIsValidState() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        assertTrue(SupplicantState.isValidState(SupplicantState.DISCONNECTED));
        assertTrue(SupplicantState.isValidState(SupplicantState.INACTIVE));
        assertTrue(SupplicantState.isValidState(SupplicantState.SCANNING));
        assertTrue(SupplicantState.isValidState(SupplicantState.ASSOCIATING));
        assertTrue(SupplicantState.isValidState(SupplicantState.ASSOCIATED));
        assertTrue(SupplicantState.isValidState(SupplicantState.FOUR_WAY_HANDSHAKE));
        assertTrue(SupplicantState.isValidState(SupplicantState.GROUP_HANDSHAKE));
        assertTrue(SupplicantState.isValidState(SupplicantState.COMPLETED));
        assertTrue(SupplicantState.isValidState(SupplicantState.DORMANT));
        assertFalse(SupplicantState.isValidState(SupplicantState.UNINITIALIZED));
        assertFalse(SupplicantState.isValidState(SupplicantState.INVALID));
    }

}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.TestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/TestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.DataSetObserver;
import android.location.LocationManager;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.provider.Settings;
import android.util.Log;
import android.view.View;
import android.widget.ListView;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter;

/**
 * Activity listing all Wi-Fi Wifi tests.
 */
public class TestListActivity extends PassFailButtons.TestListActivity {
    private static final String TAG = ""TestListActivity"";

    private WifiManager mWifiManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
        if (mWifiManager == null) {
            Log.wtf(TAG,
                    ""Can't get WIFI_SERVICE. Should be gated by 'test_required_features'!?"");
            return;
        }
        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.wifi_test, R.string.wifi_test_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        // Add the sub-test/categories
        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.wifi_test_network_request));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_request_specific,
                NetworkRequestSpecificNetworkSpecifierTestActivity.class.getName(),
                new Intent(this, NetworkRequestSpecificNetworkSpecifierTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_request_pattern,
                NetworkRequestPatternNetworkSpecifierTestActivity.class.getName(),
                new Intent(this, NetworkRequestPatternNetworkSpecifierTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_request_unavailable,
                NetworkRequestUnavailableNetworkSpecifierTestActivity.class.getName(),
                new Intent(this, NetworkRequestUnavailableNetworkSpecifierTestActivity.class),
                null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_request_invalid_credential,
                NetworkRequestInvalidCredentialNetworkSpecifierTestActivity.class.getName(),
                new Intent(this, NetworkRequestInvalidCredentialNetworkSpecifierTestActivity.class),
                null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.wifi_test_network_suggestion));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_suggestion_ssid,
                NetworkSuggestionSsidTestActivity.class.getName(),
                new Intent(this, NetworkSuggestionSsidTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_suggestion_ssid_bssid,
                NetworkSuggestionSsidBssidTestActivity.class.getName(),
                new Intent(this, NetworkSuggestionSsidBssidTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_suggestion_ssid_post_connect,
                NetworkSuggestionSsidPostConnectTestActivity.class.getName(),
                new Intent(this, NetworkSuggestionSsidPostConnectTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_suggestion_connection_failure,
                NetworkSuggestionConnectionFailureTestActivity.class.getName(),
                new Intent(this, NetworkSuggestionConnectionFailureTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.wifi_test_network_suggestion_modification_in_place,
                NetworkSuggestionModificationInPlaceTestActivity.class.getName(),
                new Intent(this, NetworkSuggestionModificationInPlaceTestActivity.class), null));

        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }

            @Override
            public void onInvalidated() {
                updatePassButton();
            }
        });

        setTestListAdapter(adapter);
    }

    @Override
    protected void handleItemClick(ListView listView, View view, int position, long id) {
        LocationManager locationManager =
                (LocationManager) getSystemService(Context.LOCATION_SERVICE);
        if (!mWifiManager.isWifiEnabled() || !locationManager.isLocationEnabled()) {
            showWifiAndLocationEnableDialog();
            return;
        }
        super.handleItemClick(listView, view, position, id);
    }

    /**
     * Show the dialog to jump to system settings in order to enable WiFi & location.
     */
    private void showWifiAndLocationEnableDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setTitle(R.string.wifi_location_not_enabled);
        builder.setMessage(R.string.wifi_location_not_enabled_message);
        builder.setPositiveButton(R.string.wifi_settings,
                new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
                    }
                });
        builder.setPositiveButton(R.string.location_settings,
                new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        startActivity(new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS));
                    }
                });
        builder.create().show();
    }
}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiFrameworkInitializerTest"	"testRegisterServiceWrappers_failsWhenCalledOutsideOfSystemServiceRegistry"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiFrameworkInitializerTest.java"	""	"public void testRegisterServiceWrappers_failsWhenCalledOutsideOfSystemServiceRegistry() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        try {
            WifiFrameworkInitializer.registerServiceWrappers();
            fail(""Expected exception when calling ""
                    + ""WifiFrameworkInitializer.registerServiceWrappers() outside of ""
                    + ""SystemServiceRegistry!"");
        } catch (IllegalStateException expected) {}
    }
}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.BaseTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/BaseTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi;

import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

/**
 * Base class for Wifi tests.
 */
public abstract class BaseTestActivity extends PassFailButtons.Activity implements
        BaseTestCase.Listener {
    private static final String TAG = ""BaseTestActivity"";
    /*
     * Handles to GUI elements.
     */
    private TextView mWifiInfo;
    private ProgressBar mWifiProgress;
    private Button mStartButton;
    private EditText mSsidEditText;
    private EditText mPskEditText;

    /*
     * Test case to be executed
     */
    private BaseTestCase mTestCase;

    private Handler mHandler = new Handler();

    private String mSsidValue;
    private String mPskValue;

    protected abstract BaseTestCase getTestCase(Context context);

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.wifi_main);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        // Get UI component.
        mWifiInfo = (TextView) findViewById(R.id.wifi_info);
        mWifiProgress = (ProgressBar) findViewById(R.id.wifi_progress);
        mStartButton = findViewById(R.id.wifi_start_test_btn);
        mSsidEditText = findViewById(R.id.wifi_ssid);
        mPskEditText = findViewById(R.id.wifi_psk);
        mSsidEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void afterTextChanged(Editable editable) {
                mSsidValue = editable.toString();
                mStartButton.setEnabled(true);
            }
        });
        mPskEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}

            @Override
            public void afterTextChanged(Editable editable) {
                mPskValue = editable.toString();
            }
        });
        mStartButton.setEnabled(false);
        mStartButton.setOnClickListener(view -> {
            mTestCase.start(this, mSsidValue, mPskValue == null ? """" : mPskValue);
            mWifiProgress.setVisibility(View.VISIBLE);
        });

        // Initialize test components.
        mTestCase = getTestCase(this);

        // keep screen on while this activity is front view.
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
    }

    @Override
    protected void onStop() {
        super.onStop();
        mTestCase.stop();
        mWifiProgress.setVisibility(View.GONE);
    }

    @Override
    public void onTestStarted() {
        // nop
    }

    @Override
    public void onTestMsgReceived(String msg) {
        if (msg == null) {
            return;
        }
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                mWifiInfo.append(msg);
                mWifiInfo.append(""\n"");
            }
        });
    }

    @Override
    public void onTestSuccess() {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                getPassButton().setEnabled(true);
                mWifiInfo.append(getString(R.string.wifi_status_test_success));
                mWifiInfo.append(""\n"");
                mWifiProgress.setVisibility(View.GONE);
            }
        });
    }

    @Override
    public void onTestFailed(String reason) {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                if (reason != null) {
                    mWifiInfo.append(reason);
                    mWifiInfo.append(""\n"");
                }
                getPassButton().setEnabled(false);
                mWifiInfo.append(getString(R.string.wifi_status_test_failed));
                mWifiInfo.append(""\n"");
                mWifiProgress.setVisibility(View.GONE);
            }
        });
    }
}"	""	""	"flag"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testGetMeteredOverride"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testGetMeteredOverride() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertEquals(METERED_OVERRIDE_NONE, passpointConfiguration.getMeteredOverride());
    }

    /**
     * Tests {@link PasspointConfiguration#getSubscriptionExpirationTimeMillis()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testGetSubscriptionExpirationTimeMillis"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testGetSubscriptionExpirationTimeMillis() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertEquals(Long.MIN_VALUE,
                passpointConfiguration.getSubscriptionExpirationTimeMillis());
    }

    /**
     * Tests {@link PasspointConfiguration#getUniqueId()} method.
     * <p>
     * Test unique identifier is not null
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testGetUniqueId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testGetUniqueId() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Create a configuration and make sure the unique ID is not null
        PasspointConfiguration passpointConfiguration1 = createConfig(SIM_CREDENTIAL, ""123456*"",
                18 /* EAP_SIM */);
        String uniqueId1 = passpointConfiguration1.getUniqueId();
        assertNotNull(uniqueId1);

        // Create another configuration and make sure the unique ID is not null
        PasspointConfiguration passpointConfiguration2 = createConfig(SIM_CREDENTIAL, ""567890*"",
                23 /* EAP_AKA */);
        String uniqueId2 = passpointConfiguration2.getUniqueId();
        assertNotNull(uniqueId2);

        // Make sure the IDs are not equal
        assertFalse(uniqueId1.equals(uniqueId2));

        passpointConfiguration2 = createConfig(USER_CREDENTIAL);
        assertFalse(uniqueId1.equals(passpointConfiguration2.getUniqueId()));

        passpointConfiguration2 = createConfig(CERT_CREDENTIAL);
        assertFalse(uniqueId1.equals(passpointConfiguration2.getUniqueId()));
    }

    /**
     * Tests {@link PasspointConfiguration#isAutojoinEnabled()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testIsAutojoinEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testIsAutojoinEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertTrue(passpointConfiguration.isAutojoinEnabled());
    }

    /**
     * Tests {@link PasspointConfiguration#isMacRandomizationEnabled()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testIsMacRandomizationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testIsMacRandomizationEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertTrue(passpointConfiguration.isMacRandomizationEnabled());
    }

    /**
     * Tests {@link PasspointConfiguration#isOsuProvisioned()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testIsOsuProvisioned"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testIsOsuProvisioned() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = createConfig(USER_CREDENTIAL);
        assertFalse(passpointConfiguration.isOsuProvisioned());
    }

    /**
     * Tests {@link PasspointConfiguration#PasspointConfiguration(PasspointConfiguration)} method.
     * <p>
     * Test the PasspointConfiguration copy constructor
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testPasspointConfigurationCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testPasspointConfigurationCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = createConfig(USER_CREDENTIAL);
        PasspointConfiguration copyOfPasspointConfiguration =
                new PasspointConfiguration(passpointConfiguration);
        assertEquals(passpointConfiguration, copyOfPasspointConfiguration);
    }

    /**
     * Tests {@link HomeSp#HomeSp(HomeSp)} method.
     * <p>
     * Test the HomeSp copy constructor
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialGetClientPrivateKey"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialGetClientPrivateKey() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = new Credential();
        credential.setClientPrivateKey(FakeKeys.RSA_KEY1);

        assertEquals(FakeKeys.RSA_KEY1, credential.getClientPrivateKey());
    }

    private static PasspointConfiguration createConfig(int type) throws Exception {
        return createConfig(type, ""123456*"", 18 /* EAP_SIM */);
    }

    private static PasspointConfiguration createConfig(int type, String imsi, int eapType)
            throws Exception {
        PasspointConfiguration config = new PasspointConfiguration();
        config.setHomeSp(createHomeSp());
        switch (type) {
            default:
            case SIM_CREDENTIAL:
                config.setCredential(
                        createCredentialWithSimCredential(imsi, eapType));
                break;
            case USER_CREDENTIAL:
                config.setCredential(createCredentialWithUserCredential());
                break;
            case CERT_CREDENTIAL:
                config.setCredential(createCredentialWithCertificateCredential());
                break;
        }

        return config;
    }

    /**
     * Helper function for generating HomeSp for testing.
     *
     * @return {@link HomeSp}
     */
    private static HomeSp createHomeSp() {
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""test.com"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        return homeSp;
    }

    /**
     * Helper function for generating Credential for testing.
     *
     * @param userCred               Instance of UserCredential
     * @param certCred               Instance of CertificateCredential
     * @param simCred                Instance of SimCredential
     * @param clientCertificateChain Chain of client certificates
     * @param clientPrivateKey       Client private key
     * @param caCerts                CA certificates
     * @return {@link Credential}
     */
    private static Credential createCredential(Credential.UserCredential userCred,
            Credential.CertificateCredential certCred,
            Credential.SimCredential simCred,
            X509Certificate[] clientCertificateChain, PrivateKey clientPrivateKey,
            X509Certificate... caCerts) {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(userCred);
        cred.setCertCredential(certCred);
        cred.setSimCredential(simCred);
        return cred;
    }

    /**
     * Helper function for generating certificate credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithCertificateCredential()
            throws NoSuchAlgorithmException, CertificateEncodingException {
        Credential.CertificateCredential certCred = new Credential.CertificateCredential();
        certCred.setCertType(""x509v3"");
        certCred.setCertSha256Fingerprint(
                MessageDigest.getInstance(""SHA-256"").digest(
                        FakeKeys.CLIENT_CERT.getEncoded()));
        return createCredential(null, certCred, null, new X509Certificate[]{
                        FakeKeys.CLIENT_CERT},
                FakeKeys.RSA_KEY1, FakeKeys.CA_CERT0,
                FakeKeys.CA_CERT1);
    }

    /**
     * Helper function for generating SIM credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithSimCredential(String imsi, int eapType) {
        Credential.SimCredential simCred = new Credential.SimCredential();
        simCred.setImsi(imsi);
        simCred.setEapType(eapType);
        return createCredential(null, null, simCred, null, null, (X509Certificate[]) null);
    }

    /**
     * Helper function for generating user credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithUserCredential() {
        Credential.UserCredential userCred = new Credential.UserCredential();
        userCred.setUsername(""username"");
        userCred.setPassword(""password"");
        userCred.setEapType(21 /* EAP_TTLS */);
        userCred.setNonEapInnerMethod(""MS-CHAP"");
        return createCredential(userCred, null, null, null, null,
                FakeKeys.CA_CERT0);
    }

    /**
     * Tests {@link OsuProvider#getFriendlyName()} and {@link OsuProvider#getServerUri()} methods.
     * <p>
     * Test that getting a set friendly name and server URI produces the same value
     */"	""	""	"passpoint feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testHomeSpCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testHomeSpCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        HomeSp homeSp = createHomeSp();
        HomeSp copyOfHomeSp = new HomeSp(homeSp);
        assertEquals(copyOfHomeSp, homeSp);
    }

    /**
     * Tests {@link Credential#Credential(Credential)} method.
     * <p>
     * Test the Credential copy constructor
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = createCredentialWithSimCredential(""123456*"", 18 /* EAP_SIM */);
        Credential copyOfCredential = new Credential(credential);
        assertEquals(copyOfCredential, credential);
    }

    /**
     * Tests {@link Credential.UserCredential#UserCredential(Credential.UserCredential)} method.
     * <p>
     * Test the Credential.UserCredential copy constructor
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testUserCredentialCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testUserCredentialCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential.UserCredential userCredential = new Credential.UserCredential();
        userCredential.setUsername(""username"");
        userCredential.setPassword(""password"");
        userCredential.setEapType(21 /* EAP_TTLS */);
        userCredential.setNonEapInnerMethod(""MS-CHAP"");

        Credential.UserCredential copyOfUserCredential =
                new Credential.UserCredential(userCredential);
        assertEquals(copyOfUserCredential, userCredential);
    }

    /**
     * Tests
     * {@link Credential.CertificateCredential#CertificateCredential(Credential.CertificateCredential)}
     * method.
     * <p>
     * Test the Credential.CertificateCredential copy constructor
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCertCredentialCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCertCredentialCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
        certCredential.setCertType(""x509v3"");

        Credential.CertificateCredential copyOfCertificateCredential =
                new Credential.CertificateCredential(certCredential);
        assertEquals(copyOfCertificateCredential, certCredential);
    }

    /**
     * Tests {@link Credential.SimCredential#SimCredential(Credential.SimCredential)} method.
     * <p>
     * Test the Credential.SimCredential copy constructor
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testSimCredentialCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testSimCredentialCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential.SimCredential simCredential = new Credential.SimCredential();
        simCredential.setImsi(""1234*"");
        simCredential.setEapType(18/* EAP_SIM */);

        Credential.SimCredential copyOfSimCredential = new Credential.SimCredential(simCredential);
        assertEquals(copyOfSimCredential, simCredential);
    }

    /**
     * Tests {@link Credential#getCaCertificate()}  method.
     * <p>
     * Test that getting a set certificate produces the same value
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialGetCertificate"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialGetCertificate() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = new Credential();
        credential.setCaCertificate(FakeKeys.CA_CERT0);

        assertEquals(FakeKeys.CA_CERT0, credential.getCaCertificate());
    }

    /**
     * Tests {@link Credential#getClientCertificateChain()} and {@link
     * Credential#setCaCertificates(X509Certificate[])} methods.
     * <p>
     * Test that getting a set client certificate chain produces the same value
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialClientCertificateChain"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialClientCertificateChain() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = new Credential();
        X509Certificate[] certificates = new X509Certificate[]{FakeKeys.CLIENT_CERT};
        credential.setClientCertificateChain(certificates);

        assertTrue(Arrays.equals(certificates, credential.getClientCertificateChain()));
    }

    /**
     * Tests {@link Credential#getClientPrivateKey()} and
     * {@link Credential#setClientPrivateKey(PrivateKey)}
     * methods.
     * <p>
     * Test that getting a set client private key produces the same value
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialSetGetClientPrivateKey"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialSetGetClientPrivateKey() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = new Credential();
        credential.setClientPrivateKey(FakeKeys.RSA_KEY1);

        assertEquals(FakeKeys.RSA_KEY1, credential.getClientPrivateKey());
    }

    /**
     * Tests {@link Credential#getClientPrivateKey()} and
     * {@link Credential#setClientPrivateKey(PrivateKey)}
     * methods.
     * <p>
     * Test that getting a set client private key produces the same value
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testOsuProviderGetters"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testOsuProviderGetters() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Using Java reflection to construct an OsuProvider instance because its constructor is
        // hidden and not available to apps.
        Class<?> osuProviderClass = Class.forName(""android.net.wifi.hotspot2.OsuProvider"");
        Constructor<?> osuProviderClassConstructor = osuProviderClass.getConstructor(String.class,
                Map.class, String.class, Uri.class, String.class, List.class);

        OsuProvider osuProvider = (OsuProvider) osuProviderClassConstructor.newInstance(TEST_SSID,
                TEST_FRIENDLY_NAMES, TEST_SERVICE_DESCRIPTION, TEST_SERVER_URI, TEST_NAI,
                TEST_METHOD_LIST);
        String lang = Locale.getDefault().getLanguage();
        String friendlyName = TEST_FRIENDLY_NAMES.get(lang);
        if (TextUtils.isEmpty(friendlyName)) {
            friendlyName = TEST_FRIENDLY_NAMES.get(""en"");
        }
        assertEquals(friendlyName, osuProvider.getFriendlyName());
        assertEquals(TEST_SERVER_URI, osuProvider.getServerUri());
    }
}"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConfigParserTest"	"testParseConfigFile"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConfigParserTest.java"	""	"public void testParseConfigFile() throws Exception {
        String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT);
        PasspointConfiguration expectedConfig = generateConfigurationFromProfile();
        PasspointConfiguration actualConfig =
                ConfigParser.parsePasspointConfig(
                        ""application/x-wifi-config"", configStr.getBytes());
        assertTrue(actualConfig.equals(expectedConfig));
    }
}"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyWifiNetworkSpecifierTest"	"isStaConcurrencyForLocalOnlyConnectionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyWifiNetworkSpecifierTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.NetworkRequest;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForLocalOnlyConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a
 * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,
 * ConnectivityManager.NetworkCallback)} along with a concurrent internet connection using
 * {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 *
 * TODO(b/177591382): Refactor some of the utilities to a separate file that are copied over from
 * WifiManagerTest & WifiNetworkSpecifierTest.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyWifiNetworkSpecifierTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyWifiNetworkSpecifierTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForPeerToPeer;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNrNetworkCallback;
    private TestHelper mTestHelper;

    private static final int DURATION = 10_000;
    private static final int DURATION_UI_INTERACTION = 25_000;
    private static final int DURATION_NETWORK_CONNECTION = 60_000;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported. Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"")
                .that(mContext.getSystemService(LocationManager.class).isLocationEnabled())
                .isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"")
                .that(matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForPeerToPeer = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForPeerToPeer.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNrNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        }
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    private void testSuccessfulConnectionWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier) throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                network, specifier, false);
    }

    private void testUserRejectionWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier) throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                network, specifier, true);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using peer to peer API.
     * 3. Verify that both connections are active.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"isStaConcurrencyForRestrictedConnectionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForRestrictedConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSuggestion} which has
 * {@link WifiNetworkSuggestion.Builder#setOemPaid(boolean)} or
 * {@link WifiNetworkSuggestion.Builder#setOemPrivate(boolean)} set along with a concurrent internet
 * connection using {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForRestrictedConnection;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNsNetworkCallback;
    private ScheduledExecutorService mExecutorService;
    private TestHelper mTestHelper;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported or not automotive platform.
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported or not automitve platform.
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"").that(
                mContext.getSystemService(LocationManager.class).isLocationEnabled()).isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"").that(
                matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForRestrictedConnection = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForRestrictedConnection.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNsNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using restricted suggestion API.
     * 3. Verify that both connections are active.
     */"	""	""	"feature"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.RetrieveTransportInfoAndReturnStatusActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/RetrieveTransportInfoAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.ConnectivityManager;
import android.net.LinkProperties;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.TransportInfo;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * An activity that retrieves Transport info and returns status.
 */
public class RetrieveTransportInfoAndReturnStatusActivity extends Activity {
    private static final String TAG = ""RetrieveTransportInfoAndReturnStatusActivity"";
    private static final String STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";
    private static final int DURATION_NETWORK_CONNECTION_MILLIS = 60_000;

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(CountDownLatch countDownLatch) {
            super(ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO);
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onAvailable(Network network) {
            onAvailableCalled = true;
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            if (onAvailableCalled) {
                this.networkCapabilities = networkCapabilities;
                mCountDownLatch.countDown();
            }
        }
    }

    public static boolean canRetrieveSsidFromTransportInfo(
            String logTag, ConnectivityManager connectivityManager) {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        TestNetworkCallback testNetworkCallback = new TestNetworkCallback(countDownLatch);
        try {
            // File a callback for wifi network.
            connectivityManager.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .build(),
                    testNetworkCallback);
            // Wait for callback.
            if (!countDownLatch.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)) {
                Log.e(logTag, ""Timed out waiting for wifi network"");
                return false;
            }
            if (!testNetworkCallback.onAvailableCalled) {
                Log.e(logTag, ""Failed to get wifi network onAvailable"");
                return false;
            }
            TransportInfo transportInfo =
                    testNetworkCallback.networkCapabilities.getTransportInfo();
            if (!(transportInfo instanceof WifiInfo)) {
                Log.e(logTag, ""Failed to retrieve WifiInfo"");
                return false;
            }
            WifiInfo wifiInfo = (WifiInfo) transportInfo;
            boolean succeeded = !Objects.equals(wifiInfo.getSSID(), WifiManager.UNKNOWN_SSID);
            if (succeeded) {
                Log.v(logTag, ""SSID from transport info retrieval succeeded"");
            } else {
                Log.v(logTag, ""Failed to retrieve SSID from transport info"");
            }
            return succeeded;
        } catch (InterruptedException e) {
            return false;
        } finally {
            connectivityManager.unregisterNetworkCallback(testNetworkCallback);
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        ConnectivityManager connectivityManager  = getSystemService(ConnectivityManager.class);
        setResult(RESULT_OK, new Intent().putExtra(
                STATUS_EXTRA, canRetrieveSsidFromTransportInfo(TAG, connectivityManager)));
        finish();
    }
}"	""	""	"flag"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-4"	"7.4.2.4/C-1-4"	"07040204.670104"	"""C-1-4] MUST declare android.hardware.wifi.passpoint feature flag."""	""	""	"passpoint android.hardware.wifi.passpoint feature flag"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.TestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/TestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.DataSetObserver;
import android.net.wifi.aware.WifiAwareManager;
import android.os.Bundle;
import android.provider.Settings;
import android.util.Log;
import android.view.View;
import android.widget.ListView;

import androidx.core.os.BuildCompat;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter;

/**
 * Activity listing all Wi-Fi Aware tests.
 */
public class TestListActivity extends PassFailButtons.TestListActivity {
    private static final String TAG = ""TestListActivity"";

    private WifiAwareManager mWifiAwareManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mWifiAwareManager = (WifiAwareManager) getSystemService(Context.WIFI_AWARE_SERVICE);
        if (mWifiAwareManager == null) {
            Log.wtf(TAG,
                    ""Can't get WIFI_AWARE_SERVICE. Should be gated by 'test_required_features'!?"");
            return;
        }

        boolean isRttSupported = getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_WIFI_RTT);

        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.aware_test, R.string.aware_test_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        // Add the sub-test/categories
        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);

        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_open_unsolicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathOpenUnsolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathOpenUnsolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathOpenPassiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathOpenPassiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_passphrase_unsolicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPassphraseUnsolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPassphraseUnsolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPassphrasePassiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPassphrasePassiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_pmk_unsolicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPmkUnsolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPmkUnsolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPmkPassiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPmkPassiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_open_solicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathOpenSolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathOpenSolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathOpenActiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathOpenActiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_passphrase_solicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPassphraseSolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPassphraseSolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPassphraseActiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPassphraseActiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_pmk_solicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPmkSolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPmkSolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPmkActiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPmkActiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_oob_open));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_responder,
                DataPathOobOpenResponderTestActivity.class.getName(),
                new Intent(this, DataPathOobOpenResponderTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_initiator,
                DataPathOobOpenInitiatorTestActivity.class.getName(),
                new Intent(this, DataPathOobOpenInitiatorTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_oob_passphrase));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_responder,
                DataPathOobPassphraseResponderTestActivity.class.getName(),
                new Intent(this, DataPathOobPassphraseResponderTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_initiator,
                DataPathOobPassphraseInitiatorTestActivity.class.getName(),
                new Intent(this, DataPathOobPassphraseInitiatorTestActivity.class), null));
        if (isRttSupported) {
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_discovery_ranging));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DiscoveryRangingPublishTestActivity.class.getName(),
                    new Intent(this, DiscoveryRangingPublishTestActivity.class), null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DiscoveryRangingSubscribeTestActivity.class.getName(),
                    new Intent(this, DiscoveryRangingSubscribeTestActivity.class), null));
        }

        if (BuildCompat.isAtLeastS()) {
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_open_unsolicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathOpenUnsolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenUnsolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathOpenPassiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenPassiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_passphrase_unsolicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPassphraseUnsolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this,
                            DataPathPassphraseUnsolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPassphrasePassiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPassphrasePassiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_pmk_unsolicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPmkUnsolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkUnsolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPmkPassiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkPassiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_open_solicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathOpenSolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenSolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathOpenActiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenActiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_passphrase_solicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPassphraseSolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPassphraseSolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPassphraseActiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPassphraseActiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_pmk_solicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPmkSolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkSolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPmkActiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkActiveSubscribeAcceptAnyTestActivity.class), null));
        }

        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }

            @Override
            public void onInvalidated() {
                updatePassButton();
            }
        });

        setTestListAdapter(adapter);
    }

    @Override
    protected void handleItemClick(ListView listView, View view, int position, long id) {
        if (!mWifiAwareManager.isAvailable()) {
            showAwareEnableDialog();
            return;
        }

        super.handleItemClick(listView, view, position, id);
    }

    /**
     * Show the dialog to jump to system settings in order to enable
     * WiFi (and by extension WiFi Aware).
     */
    private void showAwareEnableDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setTitle(R.string.aware_not_enabled);
        builder.setMessage(R.string.aware_not_enabled_message);
        builder.setPositiveButton(R.string.aware_settings,
                new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
                    }
                });
        builder.create().show();
    }
}"	""	""	"feature feature"	""	""	""	""	""	""	""	""	""	""
