"Section"	"section_id"	"req_id"	"full_key"	"manual_search_terms"	"requirement"	"Test Availability"	"class_def"	"method"	"module"	"matched_terms"	"methods_string"	"search_terms"	"file_name"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"Test Level"
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk29CanOptOutViaUpdate"	"CtsPermission2TestCases"	"1: tv"	"@AppModeFull
    public void testTargetingSdk29CanOptOutViaUpdate() throws Exception {
        installApp(APK_USES_STORAGE_DEFAULT_29, null);
        installApp(APK_USES_STORAGE_OPT_OUT_29, null);

        assertHasFullStorageAccess();
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk29CanOptOutViaDowngradeTo28"	"CtsPermission2TestCases"	"1: tv"	"@AppModeFull
    public void testTargetingSdk29CanOptOutViaDowngradeTo28() throws Exception {
        installApp(APK_USES_STORAGE_DEFAULT_29, null);
        installApp(APK_USES_STORAGE_DEFAULT_28, null);

        assertHasFullStorageAccess();
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission2.cts.ContactsProviderTest"	"testInsertContacts"	"CtsPermission2TestCases"	"1: tv"	"public void testInsertContacts() {
        try {
            getContext().getContentResolver().insert(ContactsContract.Contacts.CONTENT_URI,
                    new ContentValues());
        } catch (SecurityException e) {
            fail(""insert(ContactsContract.Contacts.CONTENT_URI) threw SecurityException"");
        } catch (UnsupportedOperationException e) {
            // It is okay for this fail in this manner.
        }
    }

    /**
     * Verifies that query(ContactsContract.Profile.CONTENT_URI) only requires
     * permission {@link android.Manifest.permission#READ_CONTACTS}.
     */
    @SmallTest"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission2.cts.ContactsProviderTest"	"testInsertProfile"	"CtsPermission2TestCases"	"1: tv"	"public void testInsertProfile() {
     try {
         getContext().getContentResolver().insert(ContactsContract.Profile.CONTENT_URI,
                new ContentValues(0));
        } catch (SecurityException e) {
            fail(""insert(ContactsContract.Profile.CONTENT_URI) threw SecurityException"");
        } catch (UnsupportedOperationException e) {
            // It is okay for this fail in this manner.
        }
    }

    /**
     * Verifies that update(ContactsContract.Profile.CONTENT_URI) only requires
     * permission {@link android.Manifest.permission#WRITE_CONTACTS}.
     */
    @SmallTest"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission2.cts.ContactsProviderTest"	"testUpdateProfile"	"CtsPermission2TestCases"	"1: tv"	"public void testUpdateProfile() {
        getContext().getContentResolver().update(ContactsContract.Profile.CONTENT_URI,
                new ContentValues(0), null, null);
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission2.cts.PermissionMaxSdkVersionTest"	"testMaxSdkInPast"	"CtsPermission2TestCases"	"1: being"	"public void testMaxSdkInPast() {
        int result = mContext.checkPermission(UNGRANTABLE_PERMISSION,
                Process.myPid(), Process.myUid());
        assertEquals(""Permissions with maxSdkVersion in the past should not be granted"",
                result,
                PackageManager.PERMISSION_DENIED);
    }

    /**
     * Verify that with android:maxSdkVersion set to a future API level,
     * the permission is being granted.
     */
    @SmallTest"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/PermissionMaxSdkVersionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission2.cts.NoWriteSecureSettingsPermissionTest"	"testWriteSecureSettings"	"CtsPermission2TestCases"	"1: tv"	"public void testWriteSecureSettings() {
        try {
            ContentValues values = new ContentValues();
            values.put(Settings.Secure.NAME, Settings.Secure.ACCESSIBILITY_ENABLED);
            values.put(Settings.Secure.VALUE, Boolean.TRUE);
            getContext().getContentResolver().insert(Settings.Secure.CONTENT_URI, values);
            fail(""expected SecurityException requiring ""
                    + Manifest.permission.WRITE_SECURE_SETTINGS);
        } catch (SecurityException expected) {
           /* do nothing */
        }
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/NoWriteSecureSettingsPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission2.cts.NoReceiveSmsPermissionTest"	"testReceiveTextMessage"	"CtsPermission2TestCases"	"1: live"	"public void testReceiveTextMessage() {
        PackageManager packageManager = mContext.getPackageManager();
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        // register our test receiver to receive SMSs. This won't throw a SecurityException,
        // so test needs to wait to determine if it actual receives an SMS
        // admittedly, this is a weak verification
        // this test should be used in conjunction with a test that verifies an SMS can be
        // received successfully using the same logic if all permissions are in place
        IllegalSmsReceiver receiver = new IllegalSmsReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(TELEPHONY_SMS_RECEIVED);
        filter.addAction(MESSAGE_SENT_ACTION);
        filter.addAction(MESSAGE_STATUS_RECEIVED_ACTION);

        getContext().registerReceiver(receiver, filter);
        sendSMSToSelf(""test"");
        synchronized(receiver) {
            try {
                receiver.wait(WAIT_TIME);
            } catch (InterruptedException e) {
                Log.w(LOG_TAG, ""wait for sms interrupted"");
            }
        }

        assertTrue(""[RERUN] Sms not sent successfully. Check signal."",
                receiver.isMessageSent());
        assertFalse(""Sms received without proper permissions"", receiver.isSmsReceived());
    }

    /**
     * Verify that without {@link android.Manifest.permission#RECEIVE_SMS} that an SMS sent
     * containing a nonce from {@link SmsManager#createAppSpecificSmsToken} is delivered
     * to the app.
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/NoReceiveSmsPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission2.cts.NoReceiveSmsPermissionTest"	"testAppSpecificSmsToken"	"CtsPermission2TestCases"	"1: live"	"public void testAppSpecificSmsToken() {
        PackageManager packageManager = mContext.getPackageManager();
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        AppSpecificSmsReceiver receiver = new AppSpecificSmsReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(TELEPHONY_SMS_RECEIVED);
        filter.addAction(MESSAGE_SENT_ACTION);
        filter.addAction(MESSAGE_STATUS_RECEIVED_ACTION);
        filter.addAction(APP_SPECIFIC_SMS_RECEIVED_ACTION);
        getContext().registerReceiver(receiver, filter);

        PendingIntent receivedIntent = PendingIntent.getBroadcast(getContext(), 0,
                new Intent(APP_SPECIFIC_SMS_RECEIVED_ACTION), PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_MUTABLE_UNAUDITED);

        String token = SmsManager.getDefault().createAppSpecificSmsToken(receivedIntent);
        String message = ""test message, token="" + token;
        sendSMSToSelf(message);
        synchronized(receiver) {
            try {
                receiver.wait(WAIT_TIME);
            } catch (InterruptedException e) {
                Log.w(LOG_TAG, ""wait for sms interrupted"");
            }
        }

        assertTrue(""[RERUN] Sms not sent successfully. Check signal."",
                receiver.isMessageSent());
        assertFalse(""Sms received without proper permissions"", receiver.isSmsReceived());
        assertTrue(""App specific SMS intent not triggered"", receiver.isAppSpecificSmsReceived());
    }

    private void sendSMSToSelf(String message) {
        PendingIntent sentIntent = PendingIntent.getBroadcast(getContext(), 0,
                new Intent(MESSAGE_SENT_ACTION), PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_MUTABLE_UNAUDITED);
        PendingIntent deliveryIntent = PendingIntent.getBroadcast(getContext(), 0,
                new Intent(MESSAGE_STATUS_RECEIVED_ACTION), PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_MUTABLE_UNAUDITED);

        TelephonyManager telephony = (TelephonyManager)
                 getContext().getSystemService(Context.TELEPHONY_SERVICE);
        // get current phone number
        String currentNumber = telephony.getLine1Number();
        assertFalse(""[RERUN] SIM card does not provide phone number. Use a suitable SIM Card."",
                TextUtils.isEmpty(currentNumber));

        Log.i(LOG_TAG, String.format(""Sending SMS to self: %s"", currentNumber));
        sendSms(currentNumber, message, sentIntent, deliveryIntent);
    }

    protected void sendSms(String currentNumber, String text, PendingIntent sentIntent,
            PendingIntent deliveryIntent) {
        SmsManager.getDefault().sendTextMessage(currentNumber, null, text, sentIntent,
                deliveryIntent);
    }

    /**
     * A receiver that tracks if message was sent and received
     */
    public class IllegalSmsReceiver extends BroadcastReceiver {

        private boolean mIsSmsReceived = false;
        private boolean mIsMessageSent = false;

        public void onReceive(Context context, Intent intent) {
            if (TELEPHONY_SMS_RECEIVED.equals(intent.getAction())) {
                // this is bad, received sms without having SMS permission
                setSmsReceived();
            } else if (MESSAGE_STATUS_RECEIVED_ACTION.equals(intent.getAction())) {
                handleResultCode(getResultCode(), ""delivery"");
            } else if (MESSAGE_SENT_ACTION.equals(intent.getAction())) {
                handleResultCode(getResultCode(), ""sent"");
            } else {
                Log.w(LOG_TAG, String.format(""unknown intent received: %s"", intent.getAction()));
            }

        }

        public boolean isSmsReceived() {
            return mIsSmsReceived;
        }

        private synchronized void setSmsReceived() {
            mIsSmsReceived = true;
            notify();
        }

        public boolean isMessageSent() {
            return mIsMessageSent;
        }

        private void handleResultCode(int resultCode, String action) {
            if (resultCode == Activity.RESULT_OK) {
                Log.i(LOG_TAG, String.format(""message %1$s successful"", action));
                setMessageSentSuccess();
            } else {
                setMessageSentFailure();
                String reason = getErrorReason(resultCode);
                Log.e(LOG_TAG, String.format(""message %1$s failed: %2$s"", action, reason));
            }
        }

        private synchronized void setMessageSentSuccess() {
            mIsMessageSent = true;
            // set this to true, but don't notify receiver since we don't know if message received
            // yet
        }

        private synchronized void setMessageSentFailure() {
            mIsMessageSent = false;
            // test environment failure, notify observer so it can stop listening
            // TODO: should test retry?
            notify();
        }

        private String getErrorReason(int resultCode) {
            switch (resultCode) {
                case SmsManager.RESULT_ERROR_GENERIC_FAILURE:
                    return ""generic failure"";
                case SmsManager.RESULT_ERROR_NO_SERVICE:
                    return ""no service"";
                case SmsManager.RESULT_ERROR_NULL_PDU:
                    return ""null pdu"";
                case SmsManager.RESULT_ERROR_RADIO_OFF:
                    return ""Radio off"";
            }
            return ""unknown"";
        }
    }

    public class AppSpecificSmsReceiver extends IllegalSmsReceiver {
        private boolean mAppSpecificSmsReceived = false;

        @Override
        public void onReceive(Context context, Intent intent) {
            if (APP_SPECIFIC_SMS_RECEIVED_ACTION.equals(intent.getAction())) {
                mAppSpecificSmsReceived = true;
            } else {
                super.onReceive(context, intent);
            }
        }

        public boolean isAppSpecificSmsReceived() {
            return mAppSpecificSmsReceived;
        }
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/NoReceiveSmsPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission2.cts.IntelligenceRolesPolicyTest"	"testNoInternetPermissionRequested"	"CtsPermission2TestCases"	"1: being"	"public void testNoInternetPermissionRequested() throws Exception {
        assumeTrue(ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S));

        String packageName = sContext.getResources().getString(mConfigKey);
        assumeTrue(!Strings.isNullOrEmpty(packageName));

        List<String> requestedPermissions;

        try {
            requestedPermissions = getRequestedPermissions(sContext, packageName);
        } catch (PackageManager.NameNotFoundException e) {
            // A package is not found, despite overlay config pointing to it. Strictly speaking that
            // means that the policy for being an intelligence role is fulfilled.
            return;
        }

        assertWithMessage(""Package "" + packageName + ""MUST NOT request INTERNET permission. ""
                + ""Instead packages MUST access the internet through well-defined APIs in an open ""
                + ""source project."")
                .that(requestedPermissions)
                .doesNotContain(android.Manifest.permission.INTERNET);
    }

    private static List<String> getRequestedPermissions(Context context, String pkg)
            throws PackageManager.NameNotFoundException {
        PackageInfo packageInfo = context.getPackageManager()
                .getPackageInfo(pkg, PackageManager.GET_PERMISSIONS);

        return Arrays.asList(packageInfo.requestedPermissions);
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/IntelligenceRolesPolicyTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.telephony.cts.telephonypermission.TelephonyManagerReadPhoneStatePermissionTest"	"getVisualVoicemailPackageName"	"CtsTelephonyTestCases"	"1: tv"	"/*
 *.
 */

package android.telephony.cts.telephonypermission;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;

import android.content.Context;
import android.content.pm.PackageManager;
import android.platform.test.annotations.AppModeFull;
import android.telecom.PhoneAccount;
import android.telecom.TelecomManager;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.telephony.cts.TelephonyUtils;
import android.telephony.emergency.EmergencyNumber;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test TelephonyManager APIs with READ_PHONE_STATE Permission.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Cannot grant the runtime permission in instant app mode"")
public class TelephonyManagerReadPhoneStatePermissionTest {

    private boolean mHasTelephony;
    TelephonyManager mTelephonyManager = null;
    TelecomManager mTelecomManager = null;

    @Before
    public void setUp() throws Exception {
        mHasTelephony = getContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_TELEPHONY);
        mTelephonyManager =
                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
        assertNotNull(mTelephonyManager);
        mTelecomManager =
                (TelecomManager) getContext().getSystemService(Context.TELECOM_SERVICE);
        assertNotNull(mTelecomManager);
    }

    @After
    public void tearDown() throws Exception {
        TelephonyUtils.resetCompatCommand(InstrumentationRegistry.getInstrumentation(),
                TelephonyUtils.CTS_APP_PACKAGE,
                TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
    }

    /**
     * Verify that TelephonyManager APIs requiring READ_PHONE_STATE Permission must work.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE}.
     *
     * APIs list:
     * getDeviceSoftwareVersion()
     * getCarrierConfig()
     * getNetworkType()
     * getDataNetworkType()
     * getVoiceNetworkType()
     * getGroupIdLevel1()
     * getLine1AlphaTag()
     * getVoiceMailNumber()
     * getVisualVoicemailPackageName()
     * getVoiceMailAlphaTag()
     * getForbiddenPlmns()
     * isDataRoamingEnabled()
     * getSubscriptionId(@NonNull PhoneAccountHandle phoneAccountHandle)
     * getServiceState()
     * getEmergencyNumberList()
     * getEmergencyNumberList(@EmergencyServiceCategories int categories)
     * getPreferredOpportunisticDataSubscription()
     * isModemEnabledForSlot(int slotIndex)
     * isMultiSimSupported()
     * doesSwitchMultiSimConfigTriggerReboot()
     * getCallState() (when compat fwk enables enforcement)
     * getCallStateForSubscription() (when compat fwk enables enforcement)
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/permissions/src/android/telephony/cts/telephonypermission/TelephonyManagerReadPhoneStatePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.telephony.cts.telephonypermission.TelephonyManagerReadPhoneStatePermissionTest"	"testTelephonyManagersAPIsRequiringReadPhoneStatePermissions"	"CtsTelephonyTestCases"	"1: tv"	"public void testTelephonyManagersAPIsRequiringReadPhoneStatePermissions() throws Exception {
        if (!mHasTelephony) {
            return;
        }

        try {
            // We must ensure that compat fwk enables READ_PHONE_STATE enforcement
            TelephonyUtils.enableCompatCommand(InstrumentationRegistry.getInstrumentation(),
                    TelephonyUtils.CTS_APP_PACKAGE,
                    TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getCallState());
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getCallStateForSubscription());
        } catch (SecurityException e) {
            fail(""TelephonyManager#getCallState and TelephonyManager#getCallStateForSubscription ""
                    + ""must not throw a SecurityException because READ_PHONE_STATE permission is ""
                    + ""granted and TelecomManager#ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION is ""
                    + ""enabled."");
        }

        int subId = mTelephonyManager.getSubscriptionId();

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getNetworkType());
        } catch (SecurityException e) {
            fail(""getNetworkType() must not throw a SecurityException with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getDeviceSoftwareVersion());
        } catch (SecurityException e) {
            fail(""getDeviceSoftwareVersion() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getCarrierConfig());
        } catch (SecurityException e) {
            fail(""getCarrierConfig() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getDataNetworkType());
        } catch (SecurityException e) {
            fail(""getDataNetworkType() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getVoiceNetworkType());
        } catch (SecurityException e) {
            fail(""getVoiceNetworkType() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getGroupIdLevel1());
        } catch (SecurityException e) {
            fail(""getGroupIdLevel1() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getLine1AlphaTag());
        } catch (SecurityException e) {
            fail(""getLine1AlphaTag() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getVoiceMailNumber());
        } catch (SecurityException e) {
            fail(""getVoiceMailNumber() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getVisualVoicemailPackageName());
        } catch (SecurityException e) {
            fail(""getVisualVoicemailPackageName() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getVoiceMailAlphaTag());
        } catch (SecurityException e) {
            fail(""getVoiceMailAlphaTag() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getForbiddenPlmns());
        } catch (SecurityException e) {
            fail(""getForbiddenPlmns() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.isDataRoamingEnabled());
        } catch (SecurityException e) {
            fail(""isDataRoamingEnabled() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getSubscriptionId(
                            mTelecomManager.getDefaultOutgoingPhoneAccount(
                                    PhoneAccount.SCHEME_TEL)));
        } catch (SecurityException e) {
            fail(""getSubscriptionId(phoneAccountHandle) must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getServiceState());
        } catch (SecurityException e) {
            fail(""getServiceState() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getEmergencyNumberList());
        } catch (SecurityException e) {
            fail(""getEmergencyNumberList() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getEmergencyNumberList(
                            EmergencyNumber.EMERGENCY_SERVICE_CATEGORY_POLICE));
        } catch (SecurityException e) {
            fail(""getEmergencyNumberList(EMERGENCY_SERVICE_CATEGORY_POLICE) must""
                    + "" not throw a SecurityException with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getPreferredOpportunisticDataSubscription());
        } catch (SecurityException e) {
            fail(""getPreferredOpportunisticDataSubscription() must not throw""
                    + "" a SecurityException with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.isModemEnabledForSlot(
                            SubscriptionManager.getSlotIndex(subId)));
        } catch (SecurityException e) {
            fail(""isModemEnabledForSlot(slotIndex) must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.isMultiSimSupported());
        } catch (SecurityException e) {
            fail(""isMultiSimSupported() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.doesSwitchMultiSimConfigTriggerReboot());
        } catch (SecurityException e) {
            fail(""doesSwitchMultiSimConfigTriggerReboot() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
    }

    private static Context getContext() {
        return InstrumentationRegistry.getContext();
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/permissions/src/android/telephony/cts/telephonypermission/TelephonyManagerReadPhoneStatePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.car.cts.permissioncarexteriorenvironment.PermissionCarExteriorEnvironmentTest"	"isNotNull"	""	"1: CDD"	"/*
 *.
 */

package android.car.cts.permissioncarexteriorenvironment;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.car.Car;
import android.car.VehiclePropertyIds;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import com.google.common.collect.ImmutableList;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class PermissionCarExteriorEnvironmentTest {
    private static final ImmutableList<Integer> PERMISSION_CAR_EXTERIOR_ENVIRONMENT_PROPERTIES =
            ImmutableList.<Integer>builder().add(
                    VehiclePropertyIds.NIGHT_MODE, VehiclePropertyIds.ENV_OUTSIDE_TEMPERATURE)
                    .build();

    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar(
                        InstrumentationRegistry.getInstrumentation().getContext()).getCarManager(
                        Car.PROPERTY_SERVICE);
        assertThat(mCarPropertyManager).isNotNull();
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarExteriorEnvironment/src/android/car/cts/permissioncarexteriorenvironment/PermissionCarExteriorEnvironmentTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.car.cts.permissioncarexteriorenvironment.PermissionCarExteriorEnvironmentTest"	"testPermissionCarExteriorEnvironmentGranted"	""	"1: CDD"	"public void testPermissionCarExteriorEnvironmentGranted() {
        for (CarPropertyConfig<?> carPropertyConfig : mCarPropertyManager.getPropertyList()) {
            assertWithMessage(""%s"",
                    VehiclePropertyIds.toString(carPropertyConfig.getPropertyId())).that(
                    carPropertyConfig.getPropertyId()).isIn(
                    PERMISSION_CAR_EXTERIOR_ENVIRONMENT_PROPERTIES);
        }
    }

    @CddTest(requirement = ""2.5.1"")"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarExteriorEnvironment/src/android/car/cts/permissioncarexteriorenvironment/PermissionCarExteriorEnvironmentTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.car.cts.permissioncarspeed.PermissionCarSpeedTest"	"isNotNull"	""	"1: CDD"	"/*
 *.
 */

package android.car.cts.permissioncarspeed;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.car.Car;
import android.car.VehiclePropertyIds;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import com.google.common.collect.ImmutableList;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class PermissionCarSpeedTest {
    private static final ImmutableList<Integer> PERMISSION_CAR_SPEED_PROPERTIES =
            ImmutableList.<Integer>builder().add(
                    VehiclePropertyIds.PERF_VEHICLE_SPEED,
                    VehiclePropertyIds.PERF_VEHICLE_SPEED_DISPLAY, VehiclePropertyIds.WHEEL_TICK)
                    .build();

    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar(
                        InstrumentationRegistry.getInstrumentation().getContext()).getCarManager(
                        Car.PROPERTY_SERVICE);
        assertThat(mCarPropertyManager).isNotNull();
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarSpeed/src/android.car.cts.permissioncarspeed/PermissionCarSpeedTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.car.cts.permissioncarspeed.PermissionCarSpeedTest"	"testPermissionCarSpeedGranted"	""	"1: CDD"	"public void testPermissionCarSpeedGranted() {
        for (CarPropertyConfig<?> carPropertyConfig : mCarPropertyManager.getPropertyList()) {
            assertWithMessage(""%s"", VehiclePropertyIds.toString(carPropertyConfig.getPropertyId()))
                    .that(carPropertyConfig.getPropertyId()).isIn(PERMISSION_CAR_SPEED_PROPERTIES);
        }
    }

    @CddTest(requirement = ""2.5.1"")"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarSpeed/src/android.car.cts.permissioncarspeed/PermissionCarSpeedTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.car.cts.permissioncarpowertrain.PermissionCarPowertrainTest"	"isNotNull"	""	"1: CDD"	"/*
 *.
 */

package android.car.cts.permissioncarpowertrain;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.car.Car;
import android.car.VehiclePropertyIds;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import com.google.common.collect.ImmutableList;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class PermissionCarPowertrainTest {
    private static final ImmutableList<Integer> PERMISSION_CAR_POWERTRAIN_PROPERTIES =
            ImmutableList.<Integer>builder().add(
                    VehiclePropertyIds.GEAR_SELECTION, VehiclePropertyIds.CURRENT_GEAR,
                    VehiclePropertyIds.PARKING_BRAKE_ON,
                    VehiclePropertyIds.PARKING_BRAKE_AUTO_APPLY, VehiclePropertyIds.IGNITION_STATE)
                    .build();

    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar(
                        InstrumentationRegistry.getInstrumentation().getContext()).getCarManager(
                        Car.PROPERTY_SERVICE);
        assertThat(mCarPropertyManager).isNotNull();
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarPowertrain/src/android/car/cts/permissioncarpowertrain/PermissionCarPowertrainTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.car.cts.permissioncarpowertrain.PermissionCarPowertrainTest"	"testPermissionCarPowertrainGranted"	""	"1: CDD"	"public void testPermissionCarPowertrainGranted() {
        for (CarPropertyConfig<?> carPropertyConfig : mCarPropertyManager.getPropertyList()) {
            assertWithMessage(""%s"", VehiclePropertyIds.toString(carPropertyConfig.getPropertyId()))
                    .that(carPropertyConfig.getPropertyId()).isIn(
                    PERMISSION_CAR_POWERTRAIN_PROPERTIES);
        }
    }

    @CddTest(requirement = ""2.5.1"")"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarPowertrain/src/android/car/cts/permissioncarpowertrain/PermissionCarPowertrainTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testSetForbiddenPlmns"	"CtsPermissionTestCases"	"1: indicator"	"public void testSetForbiddenPlmns() {
        if (!mHasTelephony) {
            return;
        }

        try {
            mTelephonyManager.setForbiddenPlmns(new ArrayList<String>());
            fail(""SetForbiddenPlmns did not throw a SecurityException"");
        } catch (SecurityException e) {
            // expected
        }
    }

    static final int PHONE_STATE_PERMISSION_MASK =
                PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR
                        | PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR
                        | PhoneStateListener.LISTEN_EMERGENCY_NUMBER_LIST;

    static final int PRECISE_PHONE_STATE_PERMISSION_MASK =
                PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE
                        | PhoneStateListener.LISTEN_CALL_DISCONNECT_CAUSES
                        | PhoneStateListener.LISTEN_IMS_CALL_DISCONNECT_CAUSES
                        | PhoneStateListener.LISTEN_REGISTRATION_FAILURE
                        | PhoneStateListener.LISTEN_BARRING_INFO;

    static final int PHONE_PERMISSIONS_MASK =
            PHONE_STATE_PERMISSION_MASK | PRECISE_PHONE_STATE_PERMISSION_MASK;

    /**
     * Verify the documented permissions for PhoneStateListener.
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testGetSubscriberId"	"CtsPermissionTestCases"	"1: tv"	"public void testGetSubscriberId() {
        if (!mHasTelephony) {
            return;
        }

        try {
            String sid = mTelephonyManager.getSubscriberId();
            fail(""Got subscriber id: "" + sid);
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that TelephonyManager.getVoiceMailNumber requires Permission.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE}.
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testVoiceMailNumber"	"CtsPermissionTestCases"	"1: tv"	"public void testVoiceMailNumber() {
        if (!mHasTelephony) {
            return;
        }

        try {
            String vmnum = mTelephonyManager.getVoiceMailNumber();
            fail(""Got voicemail number: "" + vmnum);
        } catch (SecurityException e) {
            // expected
        }
    }
    /**
     * Verify that AudioManager.setMode requires Permission.
     * <p>
     * Requires Permissions:
     * {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS} and
     * {@link android.Manifest.permission#MODIFY_PHONE_STATE} for
     * {@link AudioManager#MODE_IN_CALL}.
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"isEnabled"	"CtsPermissionTestCases"	"1: CDD"	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.Manifest.permission.BLUETOOTH_CONNECT;
import static android.Manifest.permission.BLUETOOTH_SCAN;
import static android.permission.cts.PermissionUtils.grantPermission;
import static android.permission.cts.PermissionUtils.install;
import static android.permission.cts.PermissionUtils.revokePermission;
import static android.permission.cts.PermissionUtils.uninstallApp;

import static com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.bluetooth.cts.BTAdapterUtils;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SdkSuppress;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests the behavior of the
 * {@link android.Manifest.permission_group#NEARBY_DEVICES} permission group
 * under various permutations of grant states.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S, codeName = ""S"")
public class NearbyDevicesPermissionTest {
    private static final String TEST_APP_PKG = ""android.permission.cts.appthatrequestpermission"";
    private static final String TEST_APP_AUTHORITY = ""appthatrequestpermission"";
    private static final String DISAVOWAL_APP_PKG = ""android.permission.cts.appneverforlocation"";

    private static final String TMP_DIR = ""/data/local/tmp/cts/permissions/"";
    private static final String APK_BLUETOOTH_30 = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermission30.apk"";
    private static final String APK_BLUETOOTH_31 = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermission31.apk"";
    private static final String APK_BLUETOOTH_NEVER_FOR_LOCATION_31 = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermissionNeverForLocation31.apk"";
    private static final String APK_BLUETOOTH_NEVER_FOR_LOCATION_NO_PROVIDER = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermissionNeverForLocationNoProvider.apk"";

    private enum Result {
        UNKNOWN, EXCEPTION, EMPTY, FILTERED, FULL
    }

    private Context mContext = InstrumentationRegistry.getInstrumentation().getContext();
    private BluetoothAdapter mBluetoothAdapter;
    private boolean mBluetoothAdapterWasEnabled;

    @Before
    public void enableBluetooth() {
        assumeTrue(supportsBluetooth());
        mBluetoothAdapter = mContext.getSystemService(BluetoothManager.class).getAdapter();
        mBluetoothAdapterWasEnabled = mBluetoothAdapter.isEnabled();
        assertTrue(BTAdapterUtils.enableAdapter(mBluetoothAdapter, mContext));
        enableTestMode();
    }

    @After
    public void disableBluetooth() {
        assumeTrue(supportsBluetooth());
        disableTestMode();
        if (!mBluetoothAdapterWasEnabled) {
            assertTrue(BTAdapterUtils.disableAdapter(mBluetoothAdapter, mContext));
        }
    }

    @Before
    @After
    public void uninstallTestApp() {
        uninstallApp(TEST_APP_PKG);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission30_Default"	"CtsPermissionTestCases"	"1: CDD"	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission30_Default() throws Throwable {
        install(APK_BLUETOOTH_30);
        assertScanBluetoothResult(Result.EMPTY);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission30_GrantLocation"	"CtsPermissionTestCases"	"1: CDD"	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission30_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_30);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_Default"	"CtsPermissionTestCases"	"1: CDD"	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_Default() throws Throwable {
        install(APK_BLUETOOTH_31);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantNearby"	"CtsPermissionTestCases"	"1: CDD"	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantNearby() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.EMPTY);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantLocation"	"CtsPermissionTestCases"	"1: CDD"	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantNearby_GrantLocation"	"CtsPermissionTestCases"	"1: CDD"	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantNearby_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_Default"	"CtsPermissionTestCases"	"1: CDD"	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_Default() throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantNearby"	"CtsPermissionTestCases"	"1: CDD"	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantNearby() throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.FILTERED);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantLocation"	"CtsPermissionTestCases"	"1: CDD"	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantNearby_GrantLocation"	"CtsPermissionTestCases"	"1: CDD"	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantNearby_GrantLocation()
            throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FILTERED);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.LocationAccessCheckTest"	"getPermissionControllerPackageName"	"CtsPermissionTestCases"	"2: being identifier"	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.app.AppOpsManager.OPSTR_FINE_LOCATION;
import static android.app.AppOpsManager.OP_FLAGS_ALL_TRUSTED;
import static android.app.Notification.EXTRA_TITLE;
import static android.content.Context.BIND_AUTO_CREATE;
import static android.content.Context.BIND_NOT_FOREGROUND;
import static android.content.Intent.ACTION_BOOT_COMPLETED;
import static android.content.Intent.FLAG_RECEIVER_FOREGROUND;
import static android.location.Criteria.ACCURACY_FINE;
import static android.os.Process.myUserHandle;
import static android.provider.Settings.Secure.LOCATION_ACCESS_CHECK_DELAY_MILLIS;
import static android.provider.Settings.Secure.LOCATION_ACCESS_CHECK_INTERVAL_MILLIS;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;
import static com.android.server.job.nano.JobPackageHistoryProto.START_PERIODIC_JOB;
import static com.android.server.job.nano.JobPackageHistoryProto.STOP_JOB;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import static java.lang.Math.max;
import static java.util.concurrent.TimeUnit.MILLISECONDS;

import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.location.Criteria;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Looper;
import android.permission.cts.appthataccesseslocation.IAccessLocationOnCommand;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;
import android.platform.test.annotations.SystemUserOnly;
import android.provider.DeviceConfig;
import android.provider.Settings;
import android.service.notification.NotificationListenerService;
import android.service.notification.StatusBarNotification;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.DeviceConfigStateHelper;
import com.android.compatibility.common.util.ProtoUtils;
import com.android.compatibility.common.util.mainline.MainlineModule;
import com.android.compatibility.common.util.mainline.ModuleDetector;
import com.android.server.job.nano.JobPackageHistoryProto;
import com.android.server.job.nano.JobSchedulerServiceDumpProto;
import com.android.server.job.nano.JobSchedulerServiceDumpProto.RegisteredJob;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

/**
 * Tests the {@code LocationAccessCheck} in permission controller.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Cannot set system settings as instant app. Also we never show a location ""
        + ""access check notification for instant apps."")
public class LocationAccessCheckTest {
    private static final String LOG_TAG = LocationAccessCheckTest.class.getSimpleName();

    private static final String TEST_APP_PKG = ""android.permission.cts.appthataccesseslocation"";
    private static final String TEST_APP_LABEL = ""CtsLocationAccess"";
    private static final String TEST_APP_SERVICE = TEST_APP_PKG + "".AccessLocationOnCommand"";
    private static final String TEST_APP_LOCATION_BG_ACCESS_APK =
            ""/data/local/tmp/cts/permissions/CtsAppThatAccessesLocationOnCommand.apk"";
    private static final String TEST_APP_LOCATION_FG_ACCESS_APK =
            ""/data/local/tmp/cts/permissions/AppThatDoesNotHaveBgLocationAccess.apk"";
    private static final int LOCATION_ACCESS_CHECK_JOB_ID = 0;

    /** Whether to show location access check notifications. */
    private static final String PROPERTY_LOCATION_ACCESS_CHECK_ENABLED =
            ""location_access_check_enabled"";

    private static final long UNEXPECTED_TIMEOUT_MILLIS = 10000;
    private static final long EXPECTED_TIMEOUT_MILLIS = 15000;
    private static final long LOCATION_ACCESS_TIMEOUT_MILLIS = 15000;

    private static final Context sContext = InstrumentationRegistry.getTargetContext();
    private static final ActivityManager sActivityManager =
            sContext.getSystemService(ActivityManager.class);
    private static final PackageManager sPackageManager = sContext.getPackageManager();
    private static final AppOpsManager sAppOpsManager =
            sContext.getSystemService(AppOpsManager.class);
    private static final UiAutomation sUiAutomation = InstrumentationRegistry.getInstrumentation()
            .getUiAutomation();

    private static final String PERMISSION_CONTROLLER_PKG = sContext.getPackageManager()
            .getPermissionControllerPackageName();

    /**
     * The result of {@link #assumeCanGetFineLocation()}, so we don't have to run it over and over
     * again.
     */
    private static Boolean sCanAccessFineLocation = null;

    private static ServiceConnection sConnection;
    private static IAccessLocationOnCommand sLocationAccessor;

    private DeviceConfigStateHelper mPrivacyDeviceConfig =
            new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_PRIVACY);
    private static DeviceConfigStateHelper sJobSchedulerDeviceConfig =
            new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_JOB_SCHEDULER);

    private static void assumeNotPlayManaged() throws Exception {
        assumeFalse(ModuleDetector.moduleIsPlayManaged(
                sContext.getPackageManager(), MainlineModule.PERMISSION_CONTROLLER));
    }

    /**
     * Connected to {@value #TEST_APP_PKG} and make it access the location in the background
     */
    private void accessLocation() throws Throwable {
        if (sConnection == null || sLocationAccessor == null) {
            bindService();
        }

        long beforeAccess = System.currentTimeMillis();
        // Wait a little to avoid raciness in timing between threads
        Thread.sleep(1000);

        // Try again until binder call goes though. It might not go through if the sLocationAccessor
        // is not bound yet
        eventually(() -> {
            assertNotNull(sLocationAccessor);
            sLocationAccessor.accessLocation();
        }, EXPECTED_TIMEOUT_MILLIS);

        // Wait until the access is recorded
        eventually(() -> {
            List<AppOpsManager.PackageOps> ops = runWithShellPermissionIdentity(
                    () -> sAppOpsManager.getOpsForPackage(
                            sPackageManager.getPackageUid(TEST_APP_PKG, 0), TEST_APP_PKG,
                            OPSTR_FINE_LOCATION));

            // Background access must have happened after ""beforeAccess""
            assertTrue(ops.get(0).getOps().get(0).getLastAccessBackgroundTime(OP_FLAGS_ALL_TRUSTED)
                    >= beforeAccess);
        }, EXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * A {@link java.util.concurrent.Callable} that can throw a {@link Throwable}
     */
    private interface ThrowingCallable<T> {
        T call() throws Throwable;
    }

    /**
     * A {@link Runnable} that can throw a {@link Throwable}
     */
    private interface ThrowingRunnable {
        void run() throws Throwable;
    }

    /**
     * Make sure that a {@link ThrowingRunnable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r       The {@link ThrowingRunnable} to run.
     * @param timeout the maximum time to wait
     */
    public static void eventually(@NonNull ThrowingRunnable r, long timeout) throws Throwable {
        eventually(() -> {
            r.run();
            return 0;
        }, timeout);
    }

    /**
     * Make sure that a {@link ThrowingCallable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r       The {@link ThrowingCallable} to run.
     * @param timeout the maximum time to wait
     * @return the return value from the callable
     * @throws NullPointerException If the return value never becomes non-null
     */
    public static <T> T eventually(@NonNull ThrowingCallable<T> r, long timeout) throws Throwable {
        long start = System.currentTimeMillis();

        while (true) {
            try {
                T res = r.call();
                if (res == null) {
                    throw new NullPointerException(""No result"");
                }

                return res;
            } catch (Throwable e) {
                if (System.currentTimeMillis() - start < timeout) {
                    Log.d(LOG_TAG, ""Ignoring exception"", e);

                    Thread.sleep(500);
                } else {
                    throw e;
                }
            }
        }
    }

    /**
     * Get the state of the job scheduler
     */
    public static JobSchedulerServiceDumpProto getJobSchedulerDump() throws Exception {
        return ProtoUtils.getProto(sUiAutomation, JobSchedulerServiceDumpProto.class,
                ProtoUtils.DUMPSYS_JOB_SCHEDULER);
    }

    /**
     * Clear all data of a package including permissions and files.
     *
     * @param pkg The name of the package to be cleared
     */
    private static void clearPackageData(@NonNull String pkg) {
        unbindService();
        runShellCommand(""pm clear --user -2 "" + pkg);
    }

    /**
     * Get the last time the LOCATION_ACCESS_CHECK_JOB_ID job was started/stopped for permission
     * controller.
     *
     * @param event the job event (start/stop)
     *
     * @return the last time the event happened.
     */
    private static long getLastJobTime(int event) throws Exception {
        int permControllerUid = sPackageManager.getPackageUid(PERMISSION_CONTROLLER_PKG, 0);

        long lastTime = -1;

        for (JobPackageHistoryProto.HistoryEvent historyEvent :
                getJobSchedulerDump().history.historyEvent) {
            if (historyEvent.uid == permControllerUid
                    && historyEvent.jobId == LOCATION_ACCESS_CHECK_JOB_ID
                    && historyEvent.event == event) {
                lastTime = max(lastTime,
                        System.currentTimeMillis() - historyEvent.timeSinceEventMs);
            }
        }

        return lastTime;
    }

    /**
     * Force a run of the location check.
     */
    private static void runLocationCheck() throws Throwable {
        // Sleep a little bit to make sure we don't have overlap in timing
        Thread.sleep(1000);

        long beforeJob = System.currentTimeMillis();

        // Sleep a little bit to avoid raciness in time keeping
        Thread.sleep(1000);

        runShellCommand(
                ""cmd jobscheduler run -u "" + android.os.Process.myUserHandle().getIdentifier()
                        + "" -f "" + PERMISSION_CONTROLLER_PKG + "" 0"");

        eventually(() -> {
            long startTime = getLastJobTime(START_PERIODIC_JOB);
            assertTrue(startTime + "" !> "" + beforeJob, startTime > beforeJob);
        }, EXPECTED_TIMEOUT_MILLIS);

        // We can't simply require startTime <= endTime because the time being reported isn't
        // accurate, and sometimes the end time may come before the start time by around 100 ms.
        eventually(() -> {
            long stopTime = getLastJobTime(STOP_JOB);
            assertTrue(stopTime + "" !> "" + beforeJob, stopTime > beforeJob);
        }, EXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * Get a notification thrown by the permission controller that is currently visible.
     *
     * @return The notification or {@code null} if there is none
     */
    private @Nullable StatusBarNotification getPermissionControllerNotification() throws Exception {
        NotificationListenerService notificationService = NotificationListener.getInstance();

        for (StatusBarNotification notification : notificationService.getActiveNotifications()) {
            if (notification.getPackageName().equals(PERMISSION_CONTROLLER_PKG)) {
                return notification;
            }
        }

        return null;
    }

    /**
     * Get a location access notification that is currently visible.
     *
     * @param cancelNotification if {@code true} the notification is canceled inside this method
     * @return The notification or {@code null} if there is none
     */
    private StatusBarNotification getNotification(boolean cancelNotification) throws Throwable {
        NotificationListenerService notificationService = NotificationListener.getInstance();

        StatusBarNotification notification = getPermissionControllerNotification();
        if (notification == null) {
            return null;
        }

        if (notification.getNotification().extras.getString(EXTRA_TITLE, """")
                .contains(TEST_APP_LABEL)) {
            if (cancelNotification) {
                notificationService.cancelNotification(notification.getKey());

                // Wait for notification to get canceled
                eventually(() -> assertFalse(
                        Arrays.asList(notificationService.getActiveNotifications()).contains(
                                notification)), UNEXPECTED_TIMEOUT_MILLIS);
            }

            return notification;
        }

        Log.d(LOG_TAG, ""Bad notification "" + notification);

        return null;
    }

    /**
     * Grant a permission to the {@value #TEST_APP_PKG}.
     *
     * @param permission The permission to grant
     */
    private void grantPermissionToTestApp(@NonNull String permission) {
        sUiAutomation.grantRuntimePermission(TEST_APP_PKG, permission);
    }

    /**
     * Register {@link NotificationListener}.
     */
    @BeforeClass
    public static void allowNotificationAccess() {
        runShellCommand(""cmd notification allow_listener "" + (new ComponentName(sContext,
                NotificationListener.class).flattenToString()));
    }

    /**
     * Change settings so that permission controller can show location access notifications more
     * often.
     */
    @BeforeClass
    public static void reduceDelays() {
        runWithShellPermissionIdentity(() -> {
            ContentResolver cr = sContext.getContentResolver();

            // New settings will be applied in when permission controller is reset
            Settings.Secure.putLong(cr, LOCATION_ACCESS_CHECK_INTERVAL_MILLIS, 100);
            Settings.Secure.putLong(cr, LOCATION_ACCESS_CHECK_DELAY_MILLIS, 50);

            // Disable job scheduler throttling by allowing 300000 jobs per 30 sec
            sJobSchedulerDeviceConfig.set(""qc_max_job_count_per_rate_limiting_window"", ""3000000"");
            sJobSchedulerDeviceConfig.set(""qc_rate_limiting_window_ms"", ""30000"");
        });
    }

    @BeforeClass
    public static void installBackgroundAccessApp() throws Exception {
        installBackgroundAccessApp(false);
    }

    private static void installBackgroundAccessApp(boolean isDowngrade) throws Exception {
        String command = ""pm install -r -g "";
        if (isDowngrade) {
            command = command + ""-d "";
        }
        String output = runShellCommand(command + TEST_APP_LOCATION_BG_ACCESS_APK);
        assertTrue(output.contains(""Success""));
        // Wait for user sensitive to be updated, which is checked by LocationAccessCheck.
        Thread.sleep(5000);
    }

    @AfterClass
    public static void uninstallBackgroundAccessApp() {
        unbindService();
        runShellCommand(""pm uninstall "" + TEST_APP_PKG);
    }

    private static void unbindService() {
        if (sConnection != null) {
            sContext.unbindService(sConnection);
        }
        sConnection = null;
        sLocationAccessor = null;
    }


    private static void installForegroundAccessApp() throws Exception {
        unbindService();
        runShellCommand(""pm install -r -g "" + TEST_APP_LOCATION_FG_ACCESS_APK);
        // Wait for user sensitive to be updated, which is checked by LocationAccessCheck.
        Thread.sleep(5000);
    }

    private static void uninstallForegroundAccessApp() {
        runShellCommand(""pm uninstall "" + TEST_APP_LOCATION_FG_ACCESS_APK);
    }

    /**
     * Skip each test for low ram device
     */
    @Before
    public void assumeIsNotLowRamDevice() {
        assumeFalse(sActivityManager.isLowRamDevice());
    }

    @Before
    public void wakeUpAndDismissKeyguard() {
        runShellCommand(""input keyevent KEYCODE_WAKEUP"");
        runShellCommand(""wm dismiss-keyguard"");
    }

    @Before
    public void bindService() {
        sConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                sLocationAccessor = IAccessLocationOnCommand.Stub.asInterface(service);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                sConnection = null;
                sLocationAccessor = null;
            }
        };

        Intent testAppService = new Intent();
        testAppService.setComponent(new ComponentName(TEST_APP_PKG, TEST_APP_SERVICE));

        sContext.bindService(testAppService, sConnection, BIND_AUTO_CREATE | BIND_NOT_FOREGROUND);
    }

    /**
     * Reset the permission controllers state before each test
     */
    @Before
    public void resetPermissionControllerBeforeEachTest() throws Throwable {
        // Has to be before resetPermissionController to make sure enablement time is the reset time
        // of permission controller
        enableLocationAccessCheck();

        resetPermissionController();

        eventually(() -> assertNull(getNotification(false)), UNEXPECTED_TIMEOUT_MILLIS);

        // Reset job scheduler stats (to allow more jobs to be run)
        runShellCommand(
                ""cmd jobscheduler reset-execution-quota -u "" + myUserHandle().getIdentifier() + "" ""
                        + PERMISSION_CONTROLLER_PKG);
    }

    /**
     * Enable location access check
     */
    public void enableLocationAccessCheck() throws Throwable {
        mPrivacyDeviceConfig.set(PROPERTY_LOCATION_ACCESS_CHECK_ENABLED, ""true"");

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    /**
     * Disable location access check
     */
    private void disableLocationAccessCheck() throws Throwable {
        mPrivacyDeviceConfig.set(PROPERTY_LOCATION_ACCESS_CHECK_ENABLED, ""false"");

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    /**
     * Make sure fine location can be accessed at all.
     */
    @Before
    public void assumeCanGetFineLocation() {
        if (sCanAccessFineLocation == null) {
            Criteria crit = new Criteria();
            crit.setAccuracy(ACCURACY_FINE);

            CountDownLatch locationCounter = new CountDownLatch(1);
            sContext.getSystemService(LocationManager.class).requestSingleUpdate(crit,
                    new LocationListener() {
                        @Override
                        public void onLocationChanged(Location location) {
                            locationCounter.countDown();
                        }

                        @Override
                        public void onStatusChanged(String provider, int status, Bundle extras) {
                        }

                        @Override
                        public void onProviderEnabled(String provider) {
                        }

                        @Override
                        public void onProviderDisabled(String provider) {
                        }
                    }, Looper.getMainLooper());


            try {
                sCanAccessFineLocation = locationCounter.await(LOCATION_ACCESS_TIMEOUT_MILLIS,
                        MILLISECONDS);
            } catch (InterruptedException ignored) {
            }
        }

        assumeTrue(sCanAccessFineLocation);
    }

    /**
     * Reset the permission controllers state.
     */
    private static void resetPermissionController() throws Throwable {
        clearPackageData(PERMISSION_CONTROLLER_PKG);
        int currentUserId = myUserHandle().getIdentifier();

        // Wait until jobs are cleared
        eventually(() -> {
            JobSchedulerServiceDumpProto dump = getJobSchedulerDump();

            for (RegisteredJob job : dump.registeredJobs) {
                if (job.dump.sourceUserId == currentUserId) {
                    assertNotEquals(job.dump.sourcePackageName, PERMISSION_CONTROLLER_PKG);
                }
            }
        }, UNEXPECTED_TIMEOUT_MILLIS);

        // Setup up permission controller again (simulate a reboot)
        Intent permissionControllerSetupIntent = null;
        for (ResolveInfo ri : sContext.getPackageManager().queryBroadcastReceivers(
                new Intent(ACTION_BOOT_COMPLETED), 0)) {
            String pkg = ri.activityInfo.packageName;

            if (pkg.equals(PERMISSION_CONTROLLER_PKG)) {
                permissionControllerSetupIntent = new Intent()
                        .setClassName(pkg, ri.activityInfo.name)
                        .setFlags(FLAG_RECEIVER_FOREGROUND)
                        .setPackage(PERMISSION_CONTROLLER_PKG);

                sContext.sendBroadcast(permissionControllerSetupIntent);
            }
        }

        // Wait until jobs are set up
        eventually(() -> {
            JobSchedulerServiceDumpProto dump = getJobSchedulerDump();

            for (RegisteredJob job : dump.registeredJobs) {
                if (job.dump.sourceUserId == currentUserId
                        && job.dump.sourcePackageName.equals(PERMISSION_CONTROLLER_PKG)
                        && job.dump.jobInfo.service.className.contains(""LocationAccessCheck"")) {
                    return;
                }
            }

            fail(""Permission controller jobs not found"");
        }, UNEXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * Unregister {@link NotificationListener}.
     */
    @AfterClass
    public static void disallowNotificationAccess() {
        runShellCommand(""cmd notification disallow_listener "" + (new ComponentName(sContext,
                NotificationListener.class)).flattenToString());
    }

    /**
     * Reset settings so that permission controller runs normally.
     */
    @AfterClass
    public static void resetDelays() throws Throwable {
        runWithShellPermissionIdentity(() -> {
            ContentResolver cr = sContext.getContentResolver();

            Settings.Secure.resetToDefaults(cr, LOCATION_ACCESS_CHECK_INTERVAL_MILLIS);
            Settings.Secure.resetToDefaults(cr, LOCATION_ACCESS_CHECK_DELAY_MILLIS);

            sJobSchedulerDeviceConfig.restoreOriginalValues();
        });
    }

    /**
     * Reset location access check
     */
    @After
    public void resetPrivacyConfig() throws Throwable {
        mPrivacyDeviceConfig.restoreOriginalValues();

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    @After
    public void locationUnbind() throws Throwable {
        unbindService();
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.FileSystemPermissionTest"	"testAllFilesInSysAreNotWritable"	"CtsPermissionTestCases"	"1: tv"	"public void testAllFilesInSysAreNotWritable() throws Exception {
        Set<File> writable = getAllWritableFilesInDirAndSubDir(new File(""/sys""));
        writable.removeAll(SYS_EXCEPTIONS);
        assertTrue(""Found writable: "" + writable.toString(),
                writable.isEmpty());
    }

    private static Set<File>
    getAllWritableFilesInDirAndSubDir(File dir) throws Exception {
        assertTrue(dir.isDirectory());
        Set<File> retval = new HashSet<File>();

        if (isSymbolicLink(dir)) {
            // don't examine symbolic links.
            return retval;
        }

        File[] subDirectories = dir.listFiles(new FileFilter() {
            @Override public boolean accept(File pathname) {
                return pathname.isDirectory();
            }
        });


        /* recurse into subdirectories */
        if (subDirectories != null) {
            for (File f : subDirectories) {
                retval.addAll(getAllWritableFilesInDirAndSubDir(f));
            }
        }

        File[] filesInThisDirectory = dir.listFiles(new FileFilter() {
            @Override public boolean accept(File pathname) {
                return pathname.isFile();
            }
        });
        if (filesInThisDirectory == null) {
            return retval;
        }

        for (File f: filesInThisDirectory) {
            if (f.canWrite()) {
                retval.add(f.getCanonicalFile());
            }
        }
        return retval;
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.FileSystemPermissionTest"	"testSystemMountedRO"	"CtsPermissionTestCases"	"1: tv"	"public void testSystemMountedRO() throws Exception {
        StructStatVfs vfs = Os.statvfs(""/system"");
        assertTrue(""/system is not mounted read-only"", (vfs.f_flag & OsConstants.ST_RDONLY) != 0);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.FileSystemPermissionTest"	"testRootMountedRO"	"CtsPermissionTestCases"	"1: tv"	"public void testRootMountedRO() throws Exception {
        StructStatVfs vfs = Os.statvfs(""/"");
        assertTrue(""rootfs is not mounted read-only"", (vfs.f_flag & OsConstants.ST_RDONLY) != 0);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.FileSystemPermissionTest"	"testVendorMountedRO"	"CtsPermissionTestCases"	"1: tv"	"public void testVendorMountedRO() throws Exception {
        StructStatVfs vfs = Os.statvfs(""/vendor"");
        assertTrue(""/vendor is not mounted read-only"", (vfs.f_flag & OsConstants.ST_RDONLY) != 0);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.FileSystemPermissionTest"	"testOdmMountedRO"	"CtsPermissionTestCases"	"1: tv"	"public void testOdmMountedRO() throws Exception {
        StructStatVfs vfs = Os.statvfs(""/odm"");
        assertTrue(""/odm is not mounted read-only"", (vfs.f_flag & OsConstants.ST_RDONLY) != 0);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.FileSystemPermissionTest"	"testOemMountedRO"	"CtsPermissionTestCases"	"1: tv"	"public void testOemMountedRO() throws Exception {
        StructStatVfs vfs = Os.statvfs(""/oem"");
        assertTrue(""/oem is not mounted read-only"", (vfs.f_flag & OsConstants.ST_RDONLY) != 0);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.FileSystemPermissionTest"	"testDataMountedNoSuidNoDev"	"CtsPermissionTestCases"	"1: tv"	"public void testDataMountedNoSuidNoDev() throws Exception {
        StructStatVfs vfs = Os.statvfs(getContext().getFilesDir().getAbsolutePath());
        assertTrue(""/data is not mounted NOSUID"", (vfs.f_flag & OsConstants.ST_NOSUID) != 0);
        assertTrue(""/data is not mounted NODEV"", (vfs.f_flag & OsConstants.ST_NODEV) != 0);
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.FileSystemPermissionTest"	"testRunAsHasCorrectCapabilities"	"CtsPermissionTestCases"	"1: tv"	"public void testRunAsHasCorrectCapabilities() throws Exception {
        // ensure file is user and group read/executable
        String filename = ""/system/bin/run-as"";
        FileUtils.FileStatus status = new FileUtils.FileStatus();
        assertTrue(FileUtils.getFileStatus(filename, status, false));
        assertTrue(status.hasModeFlag(FileUtils.S_IRUSR | FileUtils.S_IXUSR));
        assertTrue(status.hasModeFlag(FileUtils.S_IRGRP | FileUtils.S_IXGRP));

        // ensure file owner/group is set correctly
        File f = new File(filename);
        assertFileOwnedBy(f, ""root"");
        assertFileOwnedByGroup(f, ""shell"");

        // ensure file has setuid/setgid enabled
        assertTrue(FileUtils.hasSetUidCapability(filename));
        assertTrue(FileUtils.hasSetGidCapability(filename));

        // ensure file has *only* setuid/setgid attributes enabled
        assertTrue(new FileUtils.CapabilitySet()
                .add(OsConstants.CAP_SETUID)
                .add(OsConstants.CAP_SETGID)
                .fileHasOnly(""/system/bin/run-as""));
    }

    private static Set<File>
    getAllInsecureDevicesInDirAndSubdir(File dir, int type) throws Exception {
        assertTrue(dir.isDirectory());
        Set<File> retval = new HashSet<File>();

        if (isSymbolicLink(dir)) {
            // don't examine symbolic links.
            return retval;
        }

        File[] subDirectories = dir.listFiles(new FileFilter() {
            @Override public boolean accept(File pathname) {
                return pathname.isDirectory();
            }
        });


        /* recurse into subdirectories */
        if (subDirectories != null) {
            for (File f : subDirectories) {
                retval.addAll(getAllInsecureDevicesInDirAndSubdir(f, type));
            }
        }

        File[] filesInThisDirectory = dir.listFiles();
        if (filesInThisDirectory == null) {
            return retval;
        }

        for (File f: filesInThisDirectory) {
            FileUtils.FileStatus status = new FileUtils.FileStatus();
            FileUtils.getFileStatus(f.getAbsolutePath(), status, false);
            if (status.isOfType(type)) {
                if (f.canRead() || f.canWrite() || f.canExecute()) {
                    retval.add(f);
                }
                if (status.uid == 2000) {
                    // The shell user should not own any devices
                    retval.add(f);
                }

                // Don't allow devices owned by GIDs
                // accessible to non-privileged applications.
                if ((status.gid == 1007)           // AID_LOG
                          || (status.gid == 1015)  // AID_SDCARD_RW
                          || (status.gid == 1023)  // AID_MEDIA_RW
                          || (status.gid == 1028)  // AID_SDCARD_R
                          || (status.gid == 2000)) // AID_SHELL
                {
                    if (status.hasModeFlag(FileUtils.S_IRGRP)
                            || status.hasModeFlag(FileUtils.S_IWGRP)
                            || status.hasModeFlag(FileUtils.S_IXGRP))
                    {
                        retval.add(f);
                    }
                }
            }
        }
        return retval;
    }

    private Set<File> getWritableDirectoriesAndSubdirectoriesOf(File dir) throws Exception {
        Set<File> retval = new HashSet<File>();
        if (!dir.isDirectory()) {
            return retval;
        }

        if (isSymbolicLink(dir)) {
            // don't examine symbolic links.
            return retval;
        }

        String myHome = getContext().getApplicationInfo().dataDir;
        String thisDir = dir.getCanonicalPath();
        if (thisDir.startsWith(myHome)) {
            // Don't examine directories within our home directory.
            // We expect these directories to be writable.
            return retval;
        }

        if (isDirectoryWritable(dir)) {
            retval.add(dir);
        }

        File[] subFiles = dir.listFiles();
        if (subFiles == null) {
            return retval;
        }

        for (File f : subFiles) {
            retval.addAll(getWritableDirectoriesAndSubdirectoriesOf(f));
        }

        return retval;
    }

    private static boolean isSymbolicLink(File f) throws IOException {
        return !f.getAbsolutePath().equals(f.getCanonicalPath());
    }

}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.CameraPermissionTest"	"testCamera"	"CtsPermissionTestCases"	"1: camera"	"public void testCamera() {
        try {
            (Camera.open()).takePicture(new ShutterCallback(),
                                        new RawPictureCallback(),
                                        new JpegPictureCallback());
            fail(""Was able to take a picture with the camera with no permission"");
        }
        catch (SecurityException e) {
            // expected
        } catch (RuntimeException e) {
            // expected
            // The JNI layer isn't translating the EPERM error status into
            // a SecurityException.
        }
    }

}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/CameraPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.ContactsProviderTest"	"testInsertContacts"	"CtsPermissionTestCases"	"1: tv"	"public void testInsertContacts() {
        try {
            getContext().getContentResolver().insert(ContactsContract.Contacts.CONTENT_URI,
                    new ContentValues());
            fail(""insert(ContactsContract.Contacts.CONTENT_URI) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that query(ContactsContract.Profile.CONTENT_URI) requires
     * Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#READ_CONTACTS}.
     */
    @SmallTest"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.ContactsProviderTest"	"testInsertProfile"	"CtsPermissionTestCases"	"1: tv"	"public void testInsertProfile() {
        try {
            getContext().getContentResolver().insert(ContactsContract.Profile.CONTENT_URI,
                    new ContentValues(0));
            fail(""insert(ContactsContract.Profile.CONTENT_URI) did not throw SecurityException ""
                    + ""as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that update(ContactsContract.Profile.CONTENT_URI) requires
     * Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#WRITE_CONTACTS}.
     */
    @SmallTest"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.ContactsProviderTest"	"testUpdateProfile"	"CtsPermissionTestCases"	"1: tv"	"public void testUpdateProfile() {
        try {
            getContext().getContentResolver().update(ContactsContract.Profile.CONTENT_URI,
                    new ContentValues(0), null, null);
            fail(""update(ContactsContract.Profile.CONTENT_URI) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
    * Verifies that query(ContactsContract.CommonDataKinds.Phone.ENTERPRISE_CONTENT_URI) requires
    * Permission.
    * <p>
    * Requires Permission: {@link android.Manifest.permission#INTERACT_ACROSS_USERS}.
    */
    @SmallTest"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.ProviderPermissionTest"	"testWriteCallLogInstant"	"CtsPermissionTestCases"	"1: tv"	"public void testWriteCallLogInstant() {
        try {
            getContext().getContentResolver().insert(CallLog.CONTENT_URI, new ContentValues());
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException expected) {
        }
    }

    /**
     * Verify that reading already received SMS messages requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#READ_SMS}
     *
     * <p>Note: The WRITE_SMS permission has been removed.
     */
    @AppModeFull"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.ProviderPermissionTest"	"testWriteSettings"	"CtsPermissionTestCases"	"1: tv"	"public void testWriteSettings() {
        final String permission = android.Manifest.permission.WRITE_SETTINGS;
        ContentValues value = new ContentValues();
        value.put(Settings.System.NAME, ""name"");
        value.put(Settings.System.VALUE, ""value_insert"");

        try {
            getContext().getContentResolver().insert(Settings.System.CONTENT_URI, value);
            fail(""expected SecurityException requiring "" + permission);
        } catch (SecurityException expected) {
            assertNotNull(""security exception's error message."", expected.getMessage());
            assertTrue(""error message should contain \"""" + permission + ""\"". Got: \""""
                    + expected.getMessage() + ""\""."",
                    expected.getMessage().contains(permission));
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#MANAGE_DOCUMENTS}
     * permission is only held by up to one package: whoever handles the
     * {@link android.content.Intent#ACTION_OPEN_DOCUMENT} intent, if any.
     * <p>
     * No other apps should <em>ever</em> attempt to acquire this permission,
     * since it would give those apps extremely broad access to all storage
     * providers on the device without user involvement in the arbitration
     * process. Apps should instead always rely on Uri permission grants for
     * access, using
     * {@link android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION} and related
     * APIs.
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.ProviderPermissionTest"	"testManageDocuments"	"CtsPermissionTestCases"	"1: CDD"	"public void testManageDocuments() {
        final PackageManager pm = getContext().getPackageManager();

        final Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(""*/*"");
        final ResolveInfo ri = pm.resolveActivity(intent, 0);

        if (ri != null) {
            final String validPkg = ri.activityInfo.packageName;

            final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                    android.Manifest.permission.MANAGE_DOCUMENTS
                    }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
            for (PackageInfo pi : holding) {
                if (!Objects.equals(pi.packageName, validPkg)) {
                    fail(""Exactly one package (must be "" + validPkg
                            + "") can request the MANAGE_DOCUMENTS permission; found package ""
                            + pi.packageName + "" which must be revoked for security reasons"");
                }
            }
        }
    }

    /**
     * The {@link android.Manifest.permission#WRITE_MEDIA_STORAGE} permission is
     * a very powerful permission that grants raw storage access to all devices,
     * and as such it's only appropriate to be granted to the media stack.
     * <p>
     * CDD now requires that all apps requesting this permission also hold the
     * ""Storage"" runtime permission, to give users visibility into the
     * capabilities of each app, and control over those capabilities.
     * <p>
     * If the end user revokes the ""Storage"" permission from an app, but that
     * app still has raw access to storage via {@code WRITE_MEDIA_STORAGE}, that
     * would be a CDD violation and a privacy incident.
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokePermissionNotRequested"	"CtsPermissionTestCases"	"1: camera"	"@AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokePermissionNotRequested() {
        testRevoke(
                packageName = APP_PKG_NAME,
                permission = CAMERA,
                throwableType = SecurityException::class.java,
                throwableMessage = ""has not requested permission"")
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokePermissionNotRequestedWithReason"	"CtsPermissionTestCases"	"1: camera"	"@AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokePermissionNotRequestedWithReason() {
        testRevoke(
                packageName = APP_PKG_NAME,
                permission = CAMERA,
                reason = ""test reason"",
                throwableType = SecurityException::class.java,
                throwableMessage = ""has not requested permission"")
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.UndefinedGroupPermissionTest.kt"	"testOtherGroupPermissionsNotGranted_1"	"CtsPermissionTestCases"	"1: camera"	"fun testOtherGroupPermissionsNotGranted_1() {
        testOtherGroupPermissionsNotGranted(CAMERA, RECORD_AUDIO)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/UndefinedGroupPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.UndefinedGroupPermissionTest.kt"	"testOtherGroupPermissionsNotGranted_3"	"CtsPermissionTestCases"	"1: camera"	"fun testOtherGroupPermissionsNotGranted_3() {
        testOtherGroupPermissionsNotGranted(CAMERA, TEST)
    }

    /**
     * When the custom permission is granted nothing else gets granted as a byproduct.
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/UndefinedGroupPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.UndefinedGroupPermissionTest.kt"	"testCustomPermissionGrantedAlone"	"CtsPermissionTestCases"	"1: camera"	"fun testCustomPermissionGrantedAlone() {
        Assert.assertEquals(mPm!!.checkPermission(CAMERA, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
        Assert.assertEquals(mPm!!.checkPermission(RECORD_AUDIO, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
        Assert.assertEquals(mPm!!.checkPermission(TEST, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
        eventually {
            startRequestActivity(arrayOf(TEST))
            mUiDevice!!.waitForIdle()
            findAllowButton().click()
        }
        eventually {
            Assert.assertEquals(mPm!!.checkPermission(CAMERA, APP_PKG_NAME),
                    PackageManager.PERMISSION_DENIED)
            Assert.assertEquals(mPm!!.checkPermission(RECORD_AUDIO, APP_PKG_NAME),
                    PackageManager.PERMISSION_DENIED)
            Assert.assertEquals(mPm!!.checkPermission(TEST, APP_PKG_NAME),
                    PackageManager.PERMISSION_GRANTED)
        }
    }

    @After
    fun uninstall() {
        SystemUtil.runShellCommand(""pm uninstall $APP_PKG_NAME"")
    }

    fun findAllowButton(): UiObject2 {
        return if (mContext?.packageManager
                        ?.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE) == true) {
            waitFindObject(By.text(mAllowButtonText), 100)
        } else {
            waitFindObject(By.res(
                    ""com.android.permissioncontroller:id/permission_allow_button""),
                    100)
        }
    }

    /**
     * If app has one permission granted, then it can't grant itself another permission for free.
     */
    fun testOtherGroupPermissionsNotGranted(grantedPerm: String, targetPermission: String) {
        // Grant the permission in the background
        SystemUtil.runWithShellPermissionIdentity {
            mPm!!.grantRuntimePermission(
                    APP_PKG_NAME, grantedPerm, Process.myUserHandle())
        }
        Assert.assertEquals(""$grantedPerm not granted."", mPm!!.checkPermission(grantedPerm,
                APP_PKG_NAME), PackageManager.PERMISSION_GRANTED)

        // If the dialog shows, success. If not then either the UI is broken or the permission was
        // granted in the background.
        eventually {
            startRequestActivity(arrayOf(targetPermission))
            mUiDevice!!.waitForIdle()
            try {
                if (mContext?.packageManager
                                ?.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE) == true) {
                    waitFindObject(By.text(mDenyButtonText), 100)
                } else {
                    waitFindObject(By.res(""com.android.permissioncontroller:id/grant_dialog""), 100)
                }
            } catch (e: UiObjectNotFoundException) {
                Assert.assertEquals(""grant dialog never showed."",
                        mPm!!.checkPermission(targetPermission,
                                APP_PKG_NAME), PackageManager.PERMISSION_GRANTED)
            }
        }
        Assert.assertEquals(mPm!!.checkPermission(targetPermission, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
    }

    private fun startRequestActivity(permissions: Array<String>) {
        mContext!!.startActivity(Intent()
                .setComponent(
                        ComponentName(APP_PKG_NAME, ""$APP_PKG_NAME.RequestPermissions""))
                .putExtra(EXTRA_PERMISSIONS, permissions)
                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK))
    }

    companion object {
        private const val TEST_APP_DEFINES_UNDEFINED_PERMISSION_GROUP_ELEMENT_APK =
                ""/data/local/tmp/cts/permissions/AppThatDefinesUndefinedPermissionGroupElement.apk""
        private const val APP_PKG_NAME = ""android.permission.cts.appthatrequestpermission""
        private const val EXTRA_PERMISSIONS =
                ""android.permission.cts.appthatrequestpermission.extra.PERMISSIONS""
        const val TEST = ""android.permission.cts.appthatrequestpermission.TEST""
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/UndefinedGroupPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.TvPermissionTest"	"testInsertChannels"	"CtsPermissionTestCases"	"1: tv"	"public void testInsertChannels() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyInsert(TvContract.Channels.CONTENT_URI, ""channels"");
    }

    @AppModeFull"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.TvPermissionTest"	"testUpdateChannels"	"CtsPermissionTestCases"	"1: tv"	"public void testUpdateChannels() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyUpdate(TvContract.Channels.CONTENT_URI, ""channels"");
    }

    @AppModeFull"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.TvPermissionTest"	"testDeleteChannels"	"CtsPermissionTestCases"	"1: tv"	"public void testDeleteChannels() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyDelete(TvContract.Channels.CONTENT_URI, ""channels"");
    }

    @AppModeFull"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.TvPermissionTest"	"testInsertPrograms"	"CtsPermissionTestCases"	"1: tv"	"public void testInsertPrograms() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyInsert(TvContract.Programs.CONTENT_URI, ""programs"");
    }

    @AppModeFull"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.TvPermissionTest"	"testUpdatePrograms"	"CtsPermissionTestCases"	"1: tv"	"public void testUpdatePrograms() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyUpdate(TvContract.Programs.CONTENT_URI, ""programs"");
    }

    @AppModeFull"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.TvPermissionTest"	"testDeletePrograms"	"CtsPermissionTestCases"	"1: tv"	"public void testDeletePrograms() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyDelete(TvContract.Programs.CONTENT_URI, ""programs"");
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.NoSystemFunctionPermissionTest"	"testVibrator"	"CtsPermissionTestCases"	"1: tv"	"public void testVibrator() {
        Vibrator vibrator = (Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);

        try {
            vibrator.cancel();
            fail(""Vibrator.cancel() did not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }

        try {
            vibrator.vibrate(1);
            fail(""Vibrator.vibrate(long) did not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }

        long[] testPattern = {1, 1, 1, 1, 1};

        try {
            vibrator.vibrate(testPattern, 1);
            fail(""Vibrator.vibrate(long[], int) not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that sending sms requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#SMS}.
     */
    @SmallTest"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoSystemFunctionPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.Camera2PermissionTest"	"getCameraIdList"	"CtsPermissionTestCases"	"1: camera"	"public void test/*
 *.
 */

package android.permission.cts;

import static com.android.ex.camera2.blocking.BlockingStateCallback.*;

import android.content.Context;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraCharacteristics.Key;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.os.Handler;
import android.os.HandlerThread;
import android.platform.test.annotations.Presubmit;
import android.test.AndroidTestCase;
import android.util.Log;

import com.android.ex.camera2.blocking.BlockingCameraManager;
import com.android.ex.camera2.blocking.BlockingStateCallback;

import java.util.ArrayList;
import java.util.List;

/**
 * Tests for Camera2 API related Permissions. Currently, this means
 * android.permission.CAMERA.
 */
public class Camera2PermissionTest extends AndroidTestCase {
    private static final String TAG = ""Camera2PermissionTest"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    private static final int CAMERA_CLOSE_TIMEOUT_MS = 2000;

    private CameraManager mCameraManager;
    private CameraDevice mCamera;
    private BlockingStateCallback mCameraListener;
    private String[] mCameraIds;
    protected Handler mHandler;
    protected HandlerThread mHandlerThread;

    @Override
    public void setContext(Context context) {
        super.setContext(context);
        mCameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
        assertNotNull(""Can't connect to camera manager!"", mCameraManager);
    }

    /**
     * Set up the camera2 test case required environments, including CameraManager,
     * HandlerThread, Camera IDs, and CameraStateCallback etc.
     */
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mCameraIds = mCameraManager.getCameraIdList();
        assertNotNull(""Camera ids shouldn't be null"", mCameraIds);
        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
        mCameraListener = new BlockingStateCallback();
    }

    @Override
    protected void tearDown() throws Exception {
        mHandlerThread.quitSafely();
        mHandler = null;

        super.tearDown();
    }

    /**
     * Attempt to open camera. Requires Permission:
     * {@link android.Manifest.permission#CAMERA}.
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.Camera2PermissionTest"	"testCameraOpen"	"CtsPermissionTestCases"	"1: camera"	"public void testCameraOpen() throws Exception {
        for (String id : mCameraIds) {
            try {
                openCamera(id);
                fail(""Was able to open camera "" + id + "" with no permission"");
            }
            catch (SecurityException e) {
                // expected
            } finally {
                closeCamera();
            }
        }
    }

    /**
     * Check that no system cameras can be discovered without
     * {@link android.Manifest.permission#CAMERA} and android.permission.SYSTEM_CAMERA
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.Camera2PermissionTest"	"testSystemCameraDiscovery"	"CtsPermissionTestCases"	"1: camera"	"public void testSystemCameraDiscovery() throws Exception {
        for (String id : mCameraIds) {
            Log.i(TAG, ""testSystemCameraDiscovery for camera id "" +  id);
            CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(id);
            assertNotNull(""Camera characteristics shouldn't be null"", characteristics);
            int[] availableCapabilities =
                    characteristics.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);
            assertTrue(""Camera capabilities shouldn't be null"", availableCapabilities != null);
            List<Integer> capList = toList(availableCapabilities);
            assertFalse(""System camera device "" + id + "" should not be public"",
                    capList.contains(
                            CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_SYSTEM_CAMERA));
        }
    }

    /**
     * Check the absence of camera characteristics keys that require Permission:
     * {@link android.Manifest.permission#CAMERA}.
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.Camera2PermissionTest"	"testCameraCharacteristicsNeedingPermission"	"CtsPermissionTestCases"	"1: camera"	"public void testCameraCharacteristicsNeedingPermission() throws Exception {
        for (String id : mCameraIds) {
            CameraCharacteristics capabilities = mCameraManager.getCameraCharacteristics(id);
            assertNotNull(""Camera characteristics shouldn't be null"", capabilities);
            List<Key<?>> keysNeedingPermission = capabilities.getKeysNeedingPermission();
            if (keysNeedingPermission == null) {
                continue;
            }
            List<Key<?>> keys = capabilities.getKeys();
            assertNotNull(""Camera characteristics key list shouldn't be null"", keys);
            for (Key<?> key : keysNeedingPermission) {
                assertEquals(""Key "" + key.getName() + "" needing permission is part of the"" +
                        "" available characteristics keys"", -1, keys.indexOf(key));
                assertNull(""Key "" + key.getName() + "" needing permission must not present"" +
                        "" in camera characteristics"", capabilities.get(key));
            }
        }
    }

    /**
     * Add and remove availability listeners should work without permission.
     */
    @Presubmit"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.Camera2PermissionTest"	"testAvailabilityCallback"	"CtsPermissionTestCases"	"1: camera"	"public void testAvailabilityCallback() throws Exception {
        DummyCameraListener availabilityListener = new DummyCameraListener();
        // Remove a not-registered listener is a no-op.
        mCameraManager.unregisterAvailabilityCallback(availabilityListener);
        mCameraManager.registerAvailabilityCallback(availabilityListener, mHandler);
        mCameraManager.unregisterAvailabilityCallback(availabilityListener);
        mCameraManager.registerAvailabilityCallback(availabilityListener, mHandler);
        mCameraManager.registerAvailabilityCallback(availabilityListener, mHandler);
        mCameraManager.unregisterAvailabilityCallback(availabilityListener);
        // Remove a previously-added listener second time is a no-op.
        mCameraManager.unregisterAvailabilityCallback(availabilityListener);
    }

    private class DummyCameraListener extends CameraManager.AvailabilityCallback {
        @Override
        public void onCameraAvailable(String cameraId) {
        }

        @Override
        public void onCameraUnavailable(String cameraId) {
        }
    }

    private void openCamera(String cameraId) throws Exception {
        mCamera = (new BlockingCameraManager(mCameraManager)).openCamera(
                cameraId, mCameraListener, mHandler);
    }

    private static List<Integer> toList(int[] array) {
        List<Integer> list = new ArrayList<Integer>();
        for (int i  : array) {
            list.add(i);
        }
        return list;
    }

    private void closeCamera() {
        if (mCamera != null) {
            mCamera.close();
            mCameraListener.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
            mCamera = null;
        }
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.PackageManagerRequiringPermissionsTest"	"testVerifyPendingInstall"	"CtsPermissionTestCases"	"1: tv"	"public void testVerifyPendingInstall() {
        try {
            mPackageManager.verifyPendingInstall(1, 1);
            fail(""PackageManager.verifyPendingInstall did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that PackageManager.extendVerificationTimeout requires permission.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#PACKAGE_VERIFICATION_AGENT}.
     */"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PackageManagerRequiringPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.OneTimePermissionTest"	"testStickyServiceMaintainsPermissionOnRestart"	"CtsPermissionTestCases"	"1: live"	"public void testStickyServiceMaintainsPermissionOnRestart() throws Throwable {
        startApp();

        clickOneTimeButton();

        startAppForegroundService(2 * ONE_TIME_TIMEOUT_MILLIS, true);

        exitApp();

        assertGranted(5000);
        mUiDevice.waitForIdle();
        Thread.sleep(ONE_TIME_TIMEOUT_MILLIS);

        runShellCommand(""am crash "" + APP_PKG_NAME);

        eventually(() -> runWithShellPermissionIdentity(() -> {
            if (mActivityManager.getPackageImportance(APP_PKG_NAME) <= IMPORTANCE_CACHED) {
                throw new AssertionError(""App was never killed"");
            }
        }));

        eventually(() -> runWithShellPermissionIdentity(() -> {
            if (mActivityManager.getPackageImportance(APP_PKG_NAME)
                    > IMPORTANCE_FOREGROUND_SERVICE) {
                throw new AssertionError(""Foreground service never resumed"");
            }
            Assert.assertEquals(""Service resumed without permission"",
                    PackageManager.PERMISSION_GRANTED, mContext.getPackageManager()
                            .checkPermission(ACCESS_FINE_LOCATION, APP_PKG_NAME));
        }));
    }

    private void assertGrantedState(String s, int permissionGranted, long timeoutMillis) {
        eventually(() -> Assert.assertEquals(s,
                permissionGranted, mContext.getPackageManager()
                        .checkPermission(ACCESS_FINE_LOCATION, APP_PKG_NAME)), timeoutMillis);
    }

    private void assertGranted(long timeoutMillis) {
        assertGrantedState(""Permission was never granted"", PackageManager.PERMISSION_GRANTED,
                timeoutMillis);
    }

    private void assertDenied(long timeoutMillis) {
        assertGrantedState(""Permission was never revoked"", PackageManager.PERMISSION_DENIED,
                timeoutMillis);
    }

    private void assertExpectedLifespan(CompletableFuture<Long> exitTime, long expectedLifespan)
            throws InterruptedException, java.util.concurrent.ExecutionException,
            java.util.concurrent.TimeoutException {
        long grantedLength = System.currentTimeMillis() - exitTime.get(0, TimeUnit.MILLISECONDS);
        if (grantedLength + ONE_TIME_TIMER_LOWER_GRACE_PERIOD < expectedLifespan) {
            throw new AssertionError(
                    ""The one time permission lived shorter than expected. expected: ""
                            + expectedLifespan + ""ms but was: "" + grantedLength + ""ms"");
        }
    }

    private void exitApp() {
        boolean[] hasExited = {false};
        try {
            new Thread(() -> {
                while (!hasExited[0]) {
                    mUiDevice.pressHome();
                    mUiDevice.pressBack();
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                    }
                }
            }).start();
            eventually(() -> {
                runWithShellPermissionIdentity(() -> {
                    if (mActivityManager.getPackageImportance(APP_PKG_NAME)
                            <= IMPORTANCE_FOREGROUND) {
                        throw new AssertionError(""Unable to exit application"");
                    }
                });
            });
        } finally {
            hasExited[0] = true;
        }
    }

    private void clickOneTimeButton() throws Throwable {
        final UiObject2 uiObject = UiAutomatorUtils.waitFindObject(By.res(
                ""com.android.permissioncontroller:id/permission_allow_one_time_button""), 10000);
        Thread.sleep(500);
        uiObject.click();
    }

    /**
     * Start the app. The app will request the permissions.
     */
    private void startApp() {
        Intent startApp = new Intent();
        startApp.setComponent(new ComponentName(APP_PKG_NAME, APP_PKG_NAME + "".RequestPermission""));
        startApp.setFlags(FLAG_ACTIVITY_NEW_TASK);

        mContext.startActivity(startApp);
    }

    private void startAppForegroundService(long lifespanMillis, boolean sticky) {
        Intent intent = new Intent()
                .setComponent(new ComponentName(
                APP_PKG_NAME, APP_PKG_NAME + "".KeepAliveForegroundService""))
                .putExtra(EXTRA_FOREGROUND_SERVICE_LIFESPAN, lifespanMillis)
                .putExtra(EXTRA_FOREGROUND_SERVICE_STICKY, sticky);
        mContext.startService(intent);
    }

    private CompletableFuture<Long> registerAppExitListener() {
        CompletableFuture<Long> exitTimeCallback = new CompletableFuture<>();
        try {
            int uid = mContext.getPackageManager().getPackageUid(APP_PKG_NAME, 0);
            runWithShellPermissionIdentity(() ->
                    mActivityManager.addOnUidImportanceListener(new SingleAppExitListener(
                            uid, IMPORTANCE_FOREGROUND, exitTimeCallback), IMPORTANCE_FOREGROUND));
        } catch (PackageManager.NameNotFoundException e) {
            throw new AssertionError(""Package not found."", e);
        }
        return exitTimeCallback;
    }

    private class SingleAppExitListener implements ActivityManager.OnUidImportanceListener {

        private final int mUid;
        private final int mImportance;
        private final CompletableFuture<Long> mCallback;

        SingleAppExitListener(int uid, int importance, CompletableFuture<Long> callback) {
            mUid = uid;
            mImportance = importance;
            mCallback = callback;
        }

        @Override
        public void onUidImportance(int uid, int importance) {
            if (uid == mUid && importance > mImportance) {
                mCallback.complete(System.currentTimeMillis());
                mActivityManager.removeOnUidImportanceListener(this);
            }
        }
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/OneTimePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission.cts.BackgroundPermissionButtonLabelTest"	"testBackgroundPermissionButtonLabel"	"CtsPermissionTestCases"	"1: identifier"	"public void testBackgroundPermissionButtonLabel() {
        try {
            Context permissionControllerContext =
                    mContext.createPackageContext(mPermissionController, 0);
            int stringId = permissionControllerContext.getResources().getIdentifier(
                    APP_PERMISSION_BUTTON_ALLOW_ALWAYS, ""string"",
                    ""com.android.permissioncontroller"");

            Assert.assertEquals(mContext.getPackageManager().getBackgroundPermissionOptionLabel(),
                    permissionControllerContext.getString(stringId));
        } catch (PackageManager.NameNotFoundException e) {
            throw new RuntimeException(e);
        }

    }

}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/BackgroundPermissionButtonLabelTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionUpgradeTest.kt"	"testUpgradeKeepsPermissions"	"CtsPermission3TestCases"	"1: camera"	"fun testUpgradeKeepsPermissions() {
        Assume.assumeFalse(packageManager.arePermissionsIndividuallyControlled())

        installPackage(APP_APK_PATH_22)

        approvePermissionReview()

        assertAllPermissionsGrantedByDefault()

        installPackage(APP_APK_PATH_23, reinstall = true)

        assertAllPermissionsGrantedOnUpgrade()
    }

    private fun assertAllPermissionsGrantedByDefault() {
        arrayOf(
            android.Manifest.permission.SEND_SMS,
            android.Manifest.permission.RECEIVE_SMS,
            // The APK does not request READ_CONTACTS because of other tests
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_CALENDAR,
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.RECEIVE_WAP_PUSH,
            android.Manifest.permission.RECEIVE_MMS,
            ""android.permission.READ_CELL_BROADCASTS"",
            android.Manifest.permission.READ_EXTERNAL_STORAGE,
            android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
            android.Manifest.permission.ACCESS_FINE_LOCATION,
            android.Manifest.permission.ACCESS_COARSE_LOCATION,
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.READ_CALL_LOG,
            android.Manifest.permission.WRITE_CALL_LOG,
            android.Manifest.permission.ADD_VOICEMAIL,
            android.Manifest.permission.USE_SIP,
            android.Manifest.permission.PROCESS_OUTGOING_CALLS,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.BODY_SENSORS,
            // Split permissions
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION
        ).forEach {
            assertAppHasPermission(it, true)
        }
    }

    private fun assertAllPermissionsGrantedOnUpgrade() {
        assertAppHasAllOrNoPermissions(true)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUpgradeTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionUpgradeTest.kt"	"testRevokePropagatedOnUpgradeNewToNewModel"	"CtsPermission3TestCases"	"1: camera"	"fun testRevokePropagatedOnUpgradeNewToNewModel() {
        installPackage(APP_APK_PATH_23)

        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, false)
        assertAppHasPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE, false)

        // Request the permission and allow it
        // Make sure the permission is granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.READ_CALENDAR to true) {
            clickPermissionRequestAllowButton()
        }

        installPackage(APP_APK_PATH_23, reinstall = true)

        // Make sure the permission is still granted after the upgrade
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, true)
        // Also make sure one of the not granted permissions is still not granted
        assertAppHasPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE, false)
    }

    private fun assertAppHasAllOrNoPermissions(expectPermissions: Boolean) {
        arrayOf(
            android.Manifest.permission.SEND_SMS,
            android.Manifest.permission.RECEIVE_SMS,
            android.Manifest.permission.RECEIVE_WAP_PUSH,
            android.Manifest.permission.RECEIVE_MMS,
            android.Manifest.permission.READ_CALENDAR,
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.READ_CALL_LOG,
            android.Manifest.permission.WRITE_CALL_LOG,
            android.Manifest.permission.ADD_VOICEMAIL,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.USE_SIP,
            android.Manifest.permission.PROCESS_OUTGOING_CALLS,
            android.Manifest.permission.RECORD_AUDIO,
            android.Manifest.permission.ACCESS_FINE_LOCATION,
            android.Manifest.permission.ACCESS_COARSE_LOCATION,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.BODY_SENSORS,
            android.Manifest.permission.READ_CELL_BROADCASTS,
            // Split permissions
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION,
            // Storage permissions
            android.Manifest.permission.READ_EXTERNAL_STORAGE,
            android.Manifest.permission.WRITE_EXTERNAL_STORAGE
        ).forEach {
            assertAppHasPermission(it, expectPermissions)
        }
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUpgradeTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionHistoryTest.kt"	"testCameraTimelineWithMultipleApps"	"CtsPermission3TestCases"	"1: camera"	"fun testCameraTimelineWithMultipleApps() {
        openMicrophoneApp(INTENT_ACTION_1)
        waitFindObject(By.textContains(APP_LABEL_1))

        openMicrophoneApp(INTENT_ACTION_2)
        waitFindObject(By.textContains(APP_LABEL_2))

        openMicrophoneTimeline()
        waitFindObject(By.descContains(micLabel))
        waitFindObject(By.textContains(APP_LABEL_1))
        waitFindObject(By.textContains(APP_LABEL_2))
    }

    private fun openMicrophoneApp(intentAction: String) {
        context.startActivity(Intent(intentAction).apply {
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        })
    }

    private fun openMicrophoneTimeline() {
        SystemUtil.runWithShellPermissionIdentity {
            context.startActivity(Intent(Intent.ACTION_REVIEW_PERMISSION_HISTORY).apply {
                putExtra(Intent.EXTRA_PERMISSION_GROUP_NAME, Manifest.permission_group.MICROPHONE)
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            })
        }
    }

    companion object {
        const val APP_APK_PATH = ""$APK_DIRECTORY/CtsAccessMicrophoneApp.apk""
        const val APP_PACKAGE_NAME = ""android.permission3.cts.accessmicrophoneapp""
        const val APP2_APK_PATH = ""$APK_DIRECTORY/CtsAccessMicrophoneApp2.apk""
        const val APP2_PACKAGE_NAME = ""android.permission3.cts.accessmicrophoneapp2""
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionHistoryTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionTest23.kt"	"testGrantPreviouslyRevokedWithPrejudiceShowsPrompt"	"CtsPermission3TestCases"	"1: camera"	"fun testGrantPreviouslyRevokedWithPrejudiceShowsPrompt() {
        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.CAMERA, false)

        // Request the permission and deny it
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.CAMERA to false) {
            clickPermissionRequestDenyButton()
        }

        // Request the permission and choose don't ask again
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.CAMERA to false) {
            denyPermissionRequestWithPrejudice()
        }

        // Clear the denial with prejudice
        grantAppPermissions(android.Manifest.permission.CAMERA)
        revokeAppPermissions(android.Manifest.permission.CAMERA)

        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.CAMERA, false)

        // Request the permission and allow it
        // Make sure the permission is granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.CAMERA to true) {
            if (SdkLevel.isAtLeastS()) {
                clickPermissionRequestAllowForegroundButton()
            } else {
                clickPermissionRequestAllowButton()
            }
        }
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionTest23.kt"	"testNoResidualPermissionsOnUninstall"	"CtsPermission3TestCases"	"1: camera"	"(timeout = 120000)
    @FlakyTest
    fun testNoResidualPermissionsOnUninstall() {
        Assume.assumeFalse(packageManager.arePermissionsIndividuallyControlled())

        // Grant all permissions
        grantAppPermissions(
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.RECORD_AUDIO,
            android.Manifest.permission.BODY_SENSORS,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.READ_EXTERNAL_STORAGE, targetSdk = 23
        )
        // Don't use UI for granting location permission as this shows another dialog
        uiAutomation.grantRuntimePermission(
            APP_PACKAGE_NAME, android.Manifest.permission.ACCESS_FINE_LOCATION
        )
        uiAutomation.grantRuntimePermission(
            APP_PACKAGE_NAME, android.Manifest.permission.ACCESS_COARSE_LOCATION
        )
        uiAutomation.grantRuntimePermission(
            APP_PACKAGE_NAME, android.Manifest.permission.ACCESS_BACKGROUND_LOCATION
        )

        uninstallPackage(APP_PACKAGE_NAME)
        installPackage(APP_APK_PATH_23)

        // Make no permissions are granted after uninstalling and installing the app
        assertAppHasAllOrNoPermissions(false)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionTest23.kt"	"testInvalidPermission"	"CtsPermission3TestCases"	"2: camera tv"	"fun testInvalidPermission() {
        // Request the permission and allow it
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(INVALID_PERMISSION to false) {}
    }

    private fun denyPermissionRequestWithPrejudice() {
        if (isTv || isWatch) {
            clickPermissionRequestDontAskAgainButton()
        } else {
            clickPermissionRequestDenyAndDontAskAgainButton()
        }
    }

    private fun assertAppHasAllOrNoPermissions(expectPermissions: Boolean) {
        arrayOf(
            android.Manifest.permission.SEND_SMS,
            android.Manifest.permission.RECEIVE_SMS,
            android.Manifest.permission.RECEIVE_WAP_PUSH,
            android.Manifest.permission.RECEIVE_MMS,
            android.Manifest.permission.READ_CALENDAR,
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.READ_CALL_LOG,
            android.Manifest.permission.WRITE_CALL_LOG,
            android.Manifest.permission.ADD_VOICEMAIL,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.USE_SIP,
            android.Manifest.permission.PROCESS_OUTGOING_CALLS,
            android.Manifest.permission.RECORD_AUDIO,
            android.Manifest.permission.ACCESS_FINE_LOCATION,
            android.Manifest.permission.ACCESS_COARSE_LOCATION,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.BODY_SENSORS,
            android.Manifest.permission.READ_CELL_BROADCASTS,
            // Split permissions
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION,
            // Storage permissions
            android.Manifest.permission.READ_EXTERNAL_STORAGE,
            android.Manifest.permission.WRITE_EXTERNAL_STORAGE
        ).forEach {
            assertAppHasPermission(it, expectPermissions)
        }
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionUsageInfoTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: tv"	"/*
 *.
 */

package android.permission3.cts

import android.content.Intent
import android.support.test.uiautomator.By
import com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test

/**
 * Tests permission usage info action.
 */
class PermissionUsageInfoTest : BaseUsePermissionTest() {
    @Before
    fun assumeHandheld() {
        assumeFalse(isAutomotive)
        assumeFalse(isTv)
        assumeFalse(isWatch)
    }

    @Before
    fun installApp() {
        installPackage(APP_APK_PATH_LATEST)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUsageInfoTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionSplitTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: tv"	"/*
 *.
 */

package android.permission3.cts

import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test

/**
 * Runtime permission behavior tests for permission splits.
 */
class PermissionSplitTest : BaseUsePermissionTest() {
    @Before
    fun assumeNotTv() {
        assumeFalse(isTv)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionSplitTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionTapjackingTest.kt"	"testTapjackGrantDialog_fullOverlay"	"CtsPermission3TestCases"	"2: tv television"	"fun testTapjackGrantDialog_fullOverlay() {
        // PermissionController for television uses a floating window.
        assumeFalse(isTv)

        assertAppHasPermission(ACCESS_FINE_LOCATION, false)
        requestAppPermissionsForNoResult(ACCESS_FINE_LOCATION) {}

        val buttonCenter = waitFindObject(By.text(
                getPermissionControllerString(ALLOW_FOREGROUND_BUTTON_TEXT))).visibleCenter

        // Wait for overlay to hide the dialog
        context.sendBroadcast(Intent(ACTION_SHOW_OVERLAY)
                .putExtra(EXTRA_FULL_OVERLAY, true))
        waitFindObject(By.res(""android.permission3.cts.usepermission:id/overlay""))

        tryClicking(buttonCenter)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTapjackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionTapjackingTest.kt"	"testTapjackGrantDialog_partialOverlay"	"CtsPermission3TestCases"	"2: tv television"	"fun testTapjackGrantDialog_partialOverlay() {
        // PermissionController for television uses a floating window.
        assumeFalse(isTv)
        // Automotive doesn't support detecting partial overlays yet: b/192088266
        assumeFalse(isAutomotive)

        assertAppHasPermission(ACCESS_FINE_LOCATION, false)
        requestAppPermissionsForNoResult(ACCESS_FINE_LOCATION) {}

        val buttonCenter = waitFindObject(By.text(
                getPermissionControllerString(ALLOW_FOREGROUND_BUTTON_TEXT))).visibleCenter
        val dialogBounds = waitFindObject(By.res(
                ""com.android.permissioncontroller"", ""grant_dialog"")).visibleBounds
        val messageBottom = waitFindObject(By.res(
                ""com.android.permissioncontroller"", ""permission_message"")).visibleBounds.bottom

        // Wait for overlay to hide the dialog
        context.sendBroadcast(Intent(ACTION_SHOW_OVERLAY)
                .putExtra(EXTRA_FULL_OVERLAY, false)
                .putExtra(DIALOG_LEFT, dialogBounds.left)
                .putExtra(DIALOG_TOP, dialogBounds.top)
                .putExtra(DIALOG_RIGHT, dialogBounds.right)
                .putExtra(MESSAGE_BOTTOM, messageBottom))
        waitFindObject(By.res(""android.permission3.cts.usepermission:id/overlay""))

        tryClicking(buttonCenter)
    }

    private fun tryClicking(buttonCenter: Point) {
        try {
            // Try to grant the permission, this should fail
            SystemUtil.eventually({
                if (packageManager.checkPermission(ACCESS_FINE_LOCATION, APP_PACKAGE_NAME) ==
                        PackageManager.PERMISSION_DENIED) {
                    uiDevice.click(buttonCenter.x, buttonCenter.y)
                    Thread.sleep(100)
                }
                assertAppHasPermission(ACCESS_FINE_LOCATION, true)
            }, 10000)
        } catch (e: RuntimeException) {
            // expected
        }
        // Permission should not be granted
        assertAppHasPermission(ACCESS_FINE_LOCATION, false)

        // On Automotive the dialog gets closed by the tapjacking activity popping up
        if (!isAutomotive) {
            // Verify that clicking the dialog without the overlay still works
            context.sendBroadcast(Intent(ACTION_HIDE_OVERLAY))
            SystemUtil.eventually({
                if (packageManager.checkPermission(ACCESS_FINE_LOCATION, APP_PACKAGE_NAME) ==
                        PackageManager.PERMISSION_DENIED) {
                    uiDevice.click(buttonCenter.x, buttonCenter.y)
                    Thread.sleep(100)
                }
                assertAppHasPermission(ACCESS_FINE_LOCATION, true)
            }, 10000)
        }
    }

    companion object {
        const val ACTION_SHOW_OVERLAY = ""android.permission3.cts.usepermission.ACTION_SHOW_OVERLAY""
        const val ACTION_HIDE_OVERLAY = ""android.permission3.cts.usepermission.ACTION_HIDE_OVERLAY""

        const val EXTRA_FULL_OVERLAY = ""android.permission3.cts.usepermission.extra.FULL_OVERLAY""

        const val DIALOG_LEFT = ""android.permission3.cts.usepermission.extra.DIALOG_LEFT""
        const val DIALOG_TOP = ""android.permission3.cts.usepermission.extra.DIALOG_TOP""
        const val DIALOG_RIGHT = ""android.permission3.cts.usepermission.extra.DIALOG_RIGHT""
        const val MESSAGE_BOTTOM = ""android.permission3.cts.usepermission.extra.MESSAGE_BOTTOM""
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTapjackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission3.cts.PermissionTest29.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: tv"	"/*
 *.
 */

package android.permission3.cts

import android.support.test.uiautomator.By
import androidx.test.filters.FlakyTest
import com.android.compatibility.common.util.SystemUtil.eventually
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test

/**
 * Runtime permission behavior tests for apps targeting API 29.
 */
class PermissionTest29 : BaseUsePermissionTest() {
    @Before
    fun assumeNotTv() {
        assumeFalse(isTv)
    }

    @Before
    fun installApp29() {
        installPackage(APP_APK_PATH_29)
    }

    @Before
    fun assertAppHasNoPermissions() {
        assertAppHasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, false)
        assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest29.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission4.cts.CameraMicIndicatorsPermissionTest.kt"	"DisableAnimationRule"	"CtsPermission4TestCases"	"3: indicator camera tv"	"/*
 *.
 */
package android.permission4.cts

import android.Manifest
import android.app.Instrumentation
import android.app.UiAutomation
import android.app.compat.CompatChanges
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.hardware.camera2.CameraManager
import android.os.Process
import android.provider.DeviceConfig
import android.provider.Settings
import android.server.wm.WindowManagerStateHelper
import android.support.test.uiautomator.By
import android.support.test.uiautomator.UiDevice
import android.support.test.uiautomator.UiSelector
import androidx.test.platform.app.InstrumentationRegistry
import com.android.compatibility.common.util.DisableAnimationRule
import com.android.compatibility.common.util.SystemUtil.*
import org.junit.After
import org.junit.Assert.*
import org.junit.Assume.assumeFalse
import org.junit.Assume.assumeTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test

private const val APP_LABEL = ""CtsCameraMicAccess""
private const val USE_CAMERA = ""use_camera""
private const val USE_MICROPHONE = ""use_microphone""
private const val USE_HOTWORD = ""use_hotword""
private const val INTENT_ACTION = ""test.action.USE_CAMERA_OR_MIC""
private const val PRIVACY_CHIP_ID = ""com.android.systemui:id/privacy_chip""
private const val INDICATORS_FLAG = ""camera_mic_icons_enabled""
private const val PERMISSION_INDICATORS_NOT_PRESENT = 162547999L
private const val IDLE_TIMEOUT_MILLIS: Long = 1000
private const val UNEXPECTED_TIMEOUT_MILLIS = 1000
private const val TIMEOUT_MILLIS: Long = 20000
private const val TV_MIC_INDICATOR_WINDOW_TITLE = ""MicrophoneCaptureIndicator""

class CameraMicIndicatorsPermissionTest {
    private val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
    private val context: Context = instrumentation.context
    private val uiAutomation: UiAutomation = instrumentation.uiAutomation
    private val uiDevice: UiDevice = UiDevice.getInstance(instrumentation)
    private val packageManager: PackageManager = context.packageManager

    private var wasEnabled = false
    private val micLabel = packageManager.getPermissionGroupInfo(
        Manifest.permission_group.MICROPHONE, 0).loadLabel(packageManager).toString()
    private val cameraLabel = packageManager.getPermissionGroupInfo(
        Manifest.permission_group.CAMERA, 0).loadLabel(packageManager).toString()

    private var screenTimeoutBeforeTest: Long = 0L

    @get:Rule
    val disableAnimationRule = DisableAnimationRule()

    @Before
    fun setUp() {
        runWithShellPermissionIdentity {
            screenTimeoutBeforeTest = Settings.System.getLong(
                context.contentResolver, Settings.System.SCREEN_OFF_TIMEOUT
            )
            Settings.System.putLong(
                context.contentResolver, Settings.System.SCREEN_OFF_TIMEOUT, 1800000L
            )
        }

        uiDevice.wakeUp()
        runShellCommand(instrumentation, ""wm dismiss-keyguard"")

        uiDevice.findObject(By.text(""Close""))?.click()
        wasEnabled = setIndicatorsEnabledStateIfNeeded(true)
        // If the change Id is not present, then isChangeEnabled will return true. To bypass this,
        // the change is set to ""false"" if present.
        assumeFalse(""feature not present on this device"", callWithShellPermissionIdentity {
            CompatChanges.isChangeEnabled(PERMISSION_INDICATORS_NOT_PRESENT, Process.SYSTEM_UID)
        })
    }

    private fun setIndicatorsEnabledStateIfNeeded(shouldBeEnabled: Boolean): Boolean {
        var currentlyEnabled = false
        runWithShellPermissionIdentity {
            currentlyEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_PRIVACY,
                INDICATORS_FLAG, true)
            if (currentlyEnabled != shouldBeEnabled) {
                DeviceConfig.setProperty(DeviceConfig.NAMESPACE_PRIVACY, INDICATORS_FLAG,
                    shouldBeEnabled.toString(), false)
            }
        }
        return currentlyEnabled
    }

    @After
    fun tearDown() {
        if (!wasEnabled) {
            setIndicatorsEnabledStateIfNeeded(false)
        }
        runWithShellPermissionIdentity {
            Settings.System.putLong(
                context.contentResolver, Settings.System.SCREEN_OFF_TIMEOUT,
                screenTimeoutBeforeTest
            )
        }

        pressBack()
        pressBack()
        pressHome()
        pressHome()
        Thread.sleep(3000)
    }

    private fun openApp(useMic: Boolean, useCamera: Boolean, useHotword: Boolean) {
        context.startActivity(Intent(INTENT_ACTION).apply {
            putExtra(USE_CAMERA, useCamera)
            putExtra(USE_MICROPHONE, useMic)
            putExtra(USE_HOTWORD, useHotword)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        })
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission4/src/android/permission4/cts/CameraMicIndicatorsPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission4.cts.CameraMicIndicatorsPermissionTest.kt"	"testCameraIndicator"	"CtsPermission4TestCases"	"2: indicator camera"	"fun testCameraIndicator() {
        val manager = context.getSystemService(CameraManager::class.java)!!
        assumeTrue(manager.cameraIdList.isNotEmpty())
        testCameraAndMicIndicator(useMic = false, useCamera = true)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission4/src/android/permission4/cts/CameraMicIndicatorsPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission4.cts.CameraMicIndicatorsPermissionTest.kt"	"testMicIndicator"	"CtsPermission4TestCases"	"2: indicator camera"	"fun testMicIndicator() {
        testCameraAndMicIndicator(useMic = true, useCamera = false)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission4/src/android/permission4/cts/CameraMicIndicatorsPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission4.cts.CameraMicIndicatorsPermissionTest.kt"	"testHotwordIndicatorBehavior"	"CtsPermission4TestCases"	"3: indicator camera tv"	"fun testHotwordIndicatorBehavior() {
        testCameraAndMicIndicator(useMic = false, useCamera = false, useHotword = true)
    }

    private fun testCameraAndMicIndicator(
        useMic: Boolean,
        useCamera: Boolean,
        useHotword: Boolean = false
    ) {
        openApp(useMic, useCamera, useHotword)
        eventually {
            val appView = uiDevice.findObject(UiSelector().textContains(APP_LABEL))
            assertTrue(""View with text $APP_LABEL not found"", appView.exists())
        }

        if (packageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
            assertTvIndicatorsShown(useMic, useCamera, useHotword)
        } else if (packageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            assertCarIndicatorsShown(useMic, useCamera)
        } else {
            uiDevice.openQuickSettings()
            assertPrivacyChipAndIndicatorsPresent(useMic, useCamera)
        }
    }

    private fun assertTvIndicatorsShown(useMic: Boolean, useCamera: Boolean, useHotword: Boolean) {
        if (useMic || useHotword) {
            val found = WindowManagerStateHelper()
                .waitFor(""Waiting for the mic indicator window to come up"") {
                    it.containsWindow(TV_MIC_INDICATOR_WINDOW_TITLE) &&
                    it.isWindowVisible(TV_MIC_INDICATOR_WINDOW_TITLE)
                }
            if (useMic) {
                assertTrue(""Did not find chip"", found)
            } else {
                assertFalse(""Found chip, but did not expect to"", found)
            }
        }
        if (useCamera) {
            // There is no camera indicator on TVs.
        }
    }

    private fun assertCarIndicatorsShown(useMic: Boolean, useCamera: Boolean) {
        // Ensure the privacy chip is present (or not)
        val chipFound = isChipPresent()
        if (useMic || useCamera) {
            assertTrue(""Did not find chip"", chipFound)
        } else {
            assertFalse(""Found chip, but did not expect to"", chipFound)
            return
        }

        eventually {
            if (useMic) {
                val appView = uiDevice.findObject(UiSelector().textContains(micLabel))
                assertTrue(""View with text $APP_LABEL not found"", appView.exists())
            }
            if (useCamera) {
                // There is no camera indicator in Cars.
            }
            val appView = uiDevice.findObject(UiSelector().textContains(APP_LABEL))
            assertTrue(""View with text $APP_LABEL not found"", appView.exists())
        }
    }

    private fun assertPrivacyChipAndIndicatorsPresent(useMic: Boolean, useCamera: Boolean) {
        // Ensure the privacy chip is present (or not)
        val chipFound = isChipPresent()
        if (useMic || useCamera) {
            assertTrue(""Did not find chip"", chipFound)
        } else {
            assertFalse(""Found chip, but did not expect to"", chipFound)
            return
        }

        eventually {
            if (useMic) {
                val iconView = uiDevice.findObject(UiSelector().descriptionContains(micLabel))
                assertTrue(""View with description $micLabel not found"", iconView.exists())
            }
            if (useCamera) {
                val iconView = uiDevice.findObject(UiSelector().descriptionContains(cameraLabel))
                assertTrue(""View with text $APP_LABEL not found"", iconView.exists())
            }
            val appView = uiDevice.findObject(UiSelector().textContains(APP_LABEL))
            assertTrue(""View with text $APP_LABEL not found"", appView.exists())
        }
    }

    private fun isChipPresent(): Boolean {
        var chipFound = false
        try {
            eventually {
                val privacyChip = uiDevice.findObject(By.res(PRIVACY_CHIP_ID))
                assertNotNull(""view with id $PRIVACY_CHIP_ID not found"", privacyChip)
                privacyChip.click()
                chipFound = true
            }
        } catch (e: Exception) {
            // Handle more gracefully after
        }
        return chipFound
    }

    private fun pressBack() {
        uiDevice.pressBack()
        waitForIdle()
    }

    private fun pressHome() {
        uiDevice.pressHome()
        waitForIdle()
    }

    private fun waitForIdle() =
        uiAutomation.waitForIdle(IDLE_TIMEOUT_MILLIS, TIMEOUT_MILLIS)
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission4/src/android/permission4/cts/CameraMicIndicatorsPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"setUpTest"	"CtsPermission5TestCases"	"1: tv"	"/*
 *.
 */
package android.permission5.cts

import android.Manifest
import android.app.AppOpsManager
import android.app.Instrumentation
import android.content.AttributionSource
import android.content.ComponentName
import android.content.ContentValues
import android.content.Context
import android.content.ContextParams
import android.content.Intent
import android.content.pm.PackageManager.FEATURE_LEANBACK
import android.net.Uri
import android.os.Bundle
import android.os.Process
import android.os.RemoteCallback
import android.os.SystemClock
import android.os.UserHandle
import android.permission.PermissionManager
import android.platform.test.annotations.AppModeFull
import android.provider.CalendarContract
import android.provider.CallLog
import android.provider.ContactsContract
import android.provider.Telephony
import android.speech.RecognitionListener
import android.speech.SpeechRecognizer
import androidx.test.platform.app.InstrumentationRegistry
import com.android.compatibility.common.util.SystemUtil
import com.google.common.truth.Truth.assertThat
import org.junit.After
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test
import org.mockito.ArgumentMatcher
import org.mockito.Mockito.eq
import org.mockito.Mockito.inOrder
import org.mockito.Mockito.intThat
import org.mockito.Mockito.isNull
import org.mockito.Mockito.mock
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicReference
import java.util.concurrent.locks.ReentrantLock
import java.util.function.Consumer

@AppModeFull(reason = ""Instant apps cannot hold READ_CONTACTS/READ_CALENDAR/READ_SMS/READ_CALL_LOG"")
class RuntimePermissionsAppOpTrackingTest {

    @Before
    fun setUpTest() {
        val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
        SystemUtil.runWithShellPermissionIdentity {
            appOpsManager.clearHistory()
            appOpsManager.setHistoryParameters(
                    AppOpsManager.HISTORICAL_MODE_ENABLED_ACTIVE,
                    SNAPSHOT_INTERVAL_MILLIS,
                    INTERVAL_COMPRESSION_MULTIPLIER)

            appOpsManager.resetPackageOpsNoHistory(context.packageName)
            appOpsManager.resetPackageOpsNoHistory(SHELL_PACKAGE_NAME)
            appOpsManager.resetPackageOpsNoHistory(RECEIVER_PACKAGE_NAME)
            appOpsManager.resetPackageOpsNoHistory(RECEIVER2_PACKAGE_NAME)
        }
    }

    @After
    fun tearDownTest() {
        val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
        SystemUtil.runWithShellPermissionIdentity {
            appOpsManager.clearHistory()
            appOpsManager.resetHistoryParameters()
        }
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfSmsAccess"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testSelfSmsAccess() {
        assumeNotTv()
        testSelfAccess(Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfCallLogWrite"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testSelfCallLogWrite() {
        testSelfWrite(CallLog.Calls.CONTENT_URI,
                Manifest.permission.WRITE_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testSelfWrite(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG, null, null)
        val beginEndMillis = System.currentTimeMillis()
        context.contentResolver.insert(uri, ContentValues())
        val endTimeMillis = System.currentTimeMillis()

        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, context.attributionSource,
                /*accessorForeground*/ true, /*receiverForeground*/ false,
                /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 0, /*checkAccessor*/ true,
                /*fromDatasource*/ false)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedSmsAccessAttributeToAnother"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testUntrustedSmsAccessAttributeToAnother() {
        assumeNotTv()
        testUntrustedAccessAttributeToAnother(Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedSmsAccessAttributeToAnotherThroughIntermediary"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testUntrustedSmsAccessAttributeToAnotherThroughIntermediary() {
        assumeNotTv()
        testUntrustedAccessAttributeToAnotherThroughIntermediary(
                Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testTrustedAccessSmsAttributeToAnother"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testTrustedAccessSmsAttributeToAnother() {
        assumeNotTv()
        testTrustedAccessAttributeToAnother(Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testMicRecognitionMicRecoWithAttribution"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testMicRecognitionMicRecoWithAttribution() {
        runWithAuxiliaryApps {
            startBlamedAppActivity()

            val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                    RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)

            val listener = mock(AppOpsManager.OnOpActiveChangedListener::class.java)
            val appopsManager = context.getSystemService(AppOpsManager::class.java)
            SystemUtil.runWithShellPermissionIdentity<Unit> {
                appopsManager!!.startWatchingActive(arrayOf(AppOpsManager.OPSTR_RECORD_AUDIO),
                        context.mainExecutor, listener)
            }

            val speechStartTime = System.currentTimeMillis()
            val recognizerRef = AtomicReference<SpeechRecognizer>()
            var currentOperationComplete = CountDownLatch(1)

            instrumentation.runOnMainSync {
                val recognizer = SpeechRecognizer.createSpeechRecognizer(context,
                        ComponentName(RECEIVER2_PACKAGE_NAME, RECOGNITION_SERVICE))

                recognizer.setRecognitionListener(object : RecognitionListener {
                    override fun onReadyForSpeech(params: Bundle?) {}
                    override fun onRmsChanged(rmsdB: Float) {}
                    override fun onBufferReceived(buffer: ByteArray?) {
                        currentOperationComplete.countDown()
                    }
                    override fun onPartialResults(partialResults: Bundle?) {}
                    override fun onEvent(eventType: Int, params: Bundle?) {}
                    override fun onError(error: Int) {}
                    override fun onResults(results: Bundle?) {}
                    override fun onBeginningOfSpeech() {}
                    override fun onEndOfSpeech() {}
                })

                val recoIntent = Intent()
                recoIntent.putExtra(OPERATION, OPERATION_MIC_RECO_WITH_ATTRIBUTION)
                recognizer.startListening(recoIntent)

                recognizerRef.set(recognizer)
            }

            try {
                currentOperationComplete.await(ASYNC_OPERATION_TIMEOUT_MILLIS,
                        TimeUnit.MILLISECONDS)

                val op = AppOpsManager.permissionToOp(Manifest.permission.RECORD_AUDIO)!!

                assertRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        AttributionSource(context.packageManager.getPackageUid(
                                RECEIVER2_PACKAGE_NAME, 0), RECEIVER2_PACKAGE_NAME,
                                /*attributionTag*/ null, null, context.attributionSource),
                        /*accessorForeground*/ true, /*receiverForeground*/ true,
                        /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                        /*receiverAccessCount*/ 1, /*checkAccessor*/ true,
                        /*fromDatasource*/ true)

                assertRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        context.attributionSource, /*accessorForeground*/ true,
                        /*receiverForeground*/ true, /*accessorTrusted*/ true,
                        /*accessorAccessCount*/ 0, /*receiverAccessCount*/ 1,
                        /*checkAccessor*/ false, /*fromDatasource*/ true)

                // Finish recon and check if all ops are finished
                currentOperationComplete = CountDownLatch(1)
                instrumentation.runOnMainSync { recognizerRef.get().cancel() }
                currentOperationComplete.await(ASYNC_OPERATION_TIMEOUT_MILLIS,
                        TimeUnit.MILLISECONDS)

                val recognizerUid = context.packageManager.getPackageUid(
                        RECEIVER2_PACKAGE_NAME, 0)

                assertNotRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        AttributionSource(recognizerUid, RECEIVER2_PACKAGE_NAME,
                                /*attributionTag*/ null, null, context.attributionSource),
                        /*accessorForeground*/ true, /*receiverForeground*/ true,
                        /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                        /*receiverAccessCount*/ 1, /*checkAccessor*/ true,
                        /*fromDatasource*/ true)

                assertNotRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        context.attributionSource, /*accessorForeground*/ true,
                        /*receiverForeground*/ true, /*accessorTrusted*/ true,
                        /*accessorAccessCount*/ 0, /*receiverAccessCount*/ 1,
                        /*checkAccessor*/ false, /*fromDatasource*/ true)

                var attributionChainId: Int? = null
                val inOrder = inOrder(listener)
                val attributionChainIdMatcher = ArgumentMatcher<Int> {
                    if (attributionChainId == null) {
                        attributionChainId = it
                        return@ArgumentMatcher true
                    } else {
                        return@ArgumentMatcher (attributionChainId == it)
                    }
                }
                val receiverUid = context.packageManager.getPackageUid(
                        RECEIVER_PACKAGE_NAME, 0)

                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(recognizerUid), eq(RECEIVER2_PACKAGE_NAME), isNull(), eq(true),
                        eq(AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR or ATTRIBUTION_FLAG_TRUSTED),
                        intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(Process.myUid()), eq(context.packageName), eq(ACCESSOR_ATTRIBUTION_TAG),
                        eq(true), eq(AppOpsManager.ATTRIBUTION_FLAG_INTERMEDIARY or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(receiverUid), eq(RECEIVER_PACKAGE_NAME), eq(RECEIVER_ATTRIBUTION_TAG),
                        eq(true), eq(AppOpsManager.ATTRIBUTION_FLAG_RECEIVER or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))

                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(recognizerUid), eq(RECEIVER2_PACKAGE_NAME), isNull(), eq(false),
                        eq(AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR or ATTRIBUTION_FLAG_TRUSTED),
                        intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(Process.myUid()), eq(context.packageName), eq(ACCESSOR_ATTRIBUTION_TAG),
                        eq(false), eq(AppOpsManager.ATTRIBUTION_FLAG_INTERMEDIARY or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(receiverUid), eq(RECEIVER_PACKAGE_NAME), eq(RECEIVER_ATTRIBUTION_TAG),
                        eq(false), eq(AppOpsManager.ATTRIBUTION_FLAG_RECEIVER or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))
            } finally {
                // Take down the recognition service
                instrumentation.runOnMainSync { recognizerRef.get().destroy() }
            }
        }
    }

    fun runWithAuxiliaryApps(worker: () -> Unit) {
        ensureAuxiliaryAppsNotRunningAndNoResidualProcessState()
        try {
            worker.invoke()
        } finally {
            ensureAuxiliaryAppsNotRunningAndNoResidualProcessState()
        }
    }

    companion object {
        private const val ASYNC_OPERATION_TIMEOUT_MILLIS: Long = 5000 // 5 sec
        private const val INTERVAL_COMPRESSION_MULTIPLIER = 10
        private const val SNAPSHOT_INTERVAL_MILLIS: Long = 1000

        val SHELL_PACKAGE_NAME = ""com.android.shell""
        val RECEIVER_PACKAGE_NAME = ""android.permission5.cts.blamed""
        val BRING_TO_FOREGROUND_ACTIVITY =
                ""android.permission5.cts.blamed.BringToForegroundActivity""
        val RECOGNITION_SERVICE = ""android.permission5.cts.blamed2.MyRecognitionService""
        val REMOTE_CALLBACK = ""remote_callback""
        val ATTRIBUTION_SOURCE = ""attribution_source""
        val ACCESSOR_ATTRIBUTION_TAG = ""accessor_attribution_tag""
        val RECEIVER2_PACKAGE_NAME = ""android.permission5.cts.blamed2""
        val RECEIVER_ATTRIBUTION_TAG = ""receiver_attribution_tag""
        val RECEIVER2_ATTRIBUTION_TAG = ""receiver2_attribution_tag""

        val OPERATION = ""operation""
        val OPERATION_MIC_RECO_WITH_ATTRIBUTION = ""operation:mic_reco_with_attribution""
        val OPERATION_INJECT_RECO_WITHOUT_ATTRIBUTION = ""operation:inject_reco_without_attribution""

        val ATTRIBUTION_FLAG_TRUSTED = 0x8

        private val context: Context
            get() = InstrumentationRegistry.getInstrumentation().getContext()

        private val instrumentation: Instrumentation
            get() = InstrumentationRegistry.getInstrumentation()

        private val isTv = context.packageManager.hasSystemFeature(FEATURE_LEANBACK)

        fun ensureAuxiliaryAppsNotRunningAndNoResidualProcessState() {
            SystemUtil.runShellCommand(""am force-stop $RECEIVER_PACKAGE_NAME"")
            SystemUtil.runShellCommand(""am force-stop $RECEIVER2_PACKAGE_NAME"")
            SystemClock.sleep(ASYNC_OPERATION_TIMEOUT_MILLIS)
        }

        @Throws(Exception::class)
        private fun assertRunningOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            assertOpAccess(op, beginEndMillis, endTimeMillis, attributionSource,
                    accessorForeground, receiverForeground, accessorTrusted,
                    /*assertRunning*/ true, accessorAccessCount, receiverAccessCount,
                    checkAccessor, fromDatasource)
        }

        @Throws(Exception::class)
        private fun assertNotRunningOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            assertOpAccess(op, beginEndMillis, endTimeMillis, attributionSource,
                    accessorForeground, receiverForeground, accessorTrusted,
                    /*assertRunning*/ false, accessorAccessCount, receiverAccessCount,
                    checkAccessor, fromDatasource)
        }

        @Throws(Exception::class)
        private fun assertOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            assertLastOpAccess(op, beginEndMillis, endTimeMillis, attributionSource,
                    accessorForeground, receiverForeground, accessorTrusted, assertRunning,
                    checkAccessor, fromDatasource)
            assertHistoricalOpAccess(op, attributionSource, accessorForeground,
                    receiverForeground, accessorTrusted, accessorAccessCount, receiverAccessCount,
                    checkAccessor, fromDatasource)
        }

        private fun assertLastOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
            val allPackagesOps: MutableList<AppOpsManager.PackageOps?> = ArrayList()
            SystemUtil.runWithShellPermissionIdentity<Boolean> {
                allPackagesOps.addAll(appOpsManager.getPackagesForOps(arrayOf(op)))
            }
            if (checkAccessor) {
                assertLastAccessorOps(op, beginEndMillis, endTimeMillis, attributionSource,
                        accessorForeground, accessorTrusted, assertRunning, fromDatasource,
                        allPackagesOps)
            } else {
                assertNotLastAccessorOps(op, attributionSource, allPackagesOps)
            }
            if (attributionSource.next != null) {
                assertLastReceiverOps(op, beginEndMillis, endTimeMillis, attributionSource,
                        receiverForeground, accessorTrusted, assertRunning, allPackagesOps)
            }
        }

        @Throws(Exception::class)
        private fun assertHistoricalOpAccess(
            op: String,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
            val request = AppOpsManager.HistoricalOpsRequest.Builder(0, Long.MAX_VALUE)
                    .setOpNames(listOf(op))
                    .build()
            val historicalOpsRef = AtomicReference<AppOpsManager.HistoricalOps>()
            val lock = ReentrantLock()
            val condition = lock.newCondition()
            SystemUtil.runWithShellPermissionIdentity {
                appOpsManager.getHistoricalOps(request, context.mainExecutor,
                        Consumer { historicalOps: AppOpsManager.HistoricalOps ->
                            historicalOpsRef.set(historicalOps)
                            lock.lock()
                            try {
                                condition.signalAll()
                            } finally {
                                lock.unlock()
                            }
                        })
            }
            lock.lock()
            try {
                condition.await(ASYNC_OPERATION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
            } finally {
                lock.unlock()
            }

            val historicalOps = historicalOpsRef.get()
            if (checkAccessor) {
                assertHistoricalAccessorOps(op, attributionSource, accessorForeground,
                        accessorTrusted, fromDatasource, accessorAccessCount, historicalOps)
            } else {
                assertNoHistoricalAccessorOps(op, attributionSource, historicalOps)
            }
            if (attributionSource.next != null) {
                assertHistoricalReceiverOps(op, attributionSource, receiverForeground,
                        accessorTrusted, receiverAccessCount, historicalOps)
            }
        }

        private fun assertLastAccessorOps(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            fromDatasource: Boolean,
            allPackagesOps: List<AppOpsManager.PackageOps?>
        ) {
            val accessorPackageOps = findPackageOps(attributionSource.uid,
                    attributionSource.packageName!!, allPackagesOps)
            for (opEntry in accessorPackageOps!!.ops) {
                if (!op.equals(opEntry.opStr)) {
                    continue
                }
                val attributedOpEntry = opEntry.attributedOpEntries[
                        attributionSource.attributionTag]
                if (attributionSource.next == null) {
                    // Access for ourselves
                    assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_SELF, accessorForeground, assertRunning)
                } else if (accessorTrusted) {
                    // Access for others and we are trusted. If we got the data from a datasource
                    // the latter is the proxy and we proxied, otherwise we are the proxy.
                    if (fromDatasource) {
                        assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                                AppOpsManager.OP_FLAG_TRUSTED_PROXIED, accessorForeground,
                                assertRunning)
                    } else {
                        assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                                AppOpsManager.OP_FLAG_TRUSTED_PROXY, accessorForeground,
                                assertRunning)
                    }
                } else {
                    // Access for others and we are not trusted.
                    assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_UNTRUSTED_PROXY, accessorForeground,
                            assertRunning)
                }
            }
        }

        private fun assertNotLastAccessorOps(
            op: String,
            attributionSource: AttributionSource,
            allPackagesOps: List<AppOpsManager.PackageOps?>
        ) {
            val accessorPackageOps = findPackageOps(attributionSource.uid,
                    attributionSource.packageName!!, allPackagesOps) ?: return
            for (opEntry in accessorPackageOps.ops) {
                if (!op.equals(opEntry.opStr)) {
                    continue
                }
                val attributedOpEntry = opEntry.attributedOpEntries[
                        attributionSource.attributionTag]
                if (attributedOpEntry != null) {
                    assertThat(attributedOpEntry.getLastAccessBackgroundTime(
                            AppOpsManager.OP_FLAG_SELF
                            or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                            or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(-1)
                    assertThat(attributedOpEntry.getLastAccessBackgroundTime(
                            AppOpsManager.OP_FLAG_SELF
                            or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                            or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(-1)
                }
            }
        }

        private fun assertHistoricalAccessorOps(
            op: String,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            accessorTrusted: Boolean,
            fromDatasource: Boolean,
            assertedAccessCount: Int,
            historicalOps: AppOpsManager.HistoricalOps
        ) {
            val accessorPackageOps = findPackageOps(
                    attributionSource.uid, attributionSource.packageName!!,
                    historicalOps)
            val attributedPackageOps = accessorPackageOps?.getAttributedOps(
                    attributionSource.attributionTag)

            val attributedPackageOp = attributedPackageOps!!.getOp(op)
            if (attributionSource.next == null) {
                // Access for ourselves
                assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_SELF,
                        accessorForeground, assertedAccessCount)
            } else if (accessorTrusted) {
                // Access for others and we are trusted. If we got the data from a datasource it
                // would blame the accessor in a trusted way
                if (fromDatasource) {
                    assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                            accessorForeground, assertedAccessCount)
                } else {
                    assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_TRUSTED_PROXY,
                            accessorForeground, assertedAccessCount)
                }
            } else {
                // Access for others and we are not trusted
                assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_UNTRUSTED_PROXY,
                        accessorForeground, assertedAccessCount)
            }
        }

        private fun assertNoHistoricalAccessorOps(
            op: String,
            attributionSource: AttributionSource,
            historicalOps: AppOpsManager.HistoricalOps
        ) {
            val accessorPackageOps = findPackageOps(
                    attributionSource.uid, attributionSource.packageName!!,
                    historicalOps)
            val attributedPackageOps = accessorPackageOps?.getAttributedOps(
                    attributionSource.attributionTag) ?: return
            val attributedPackageOp = attributedPackageOps.getOp(op)
            if (attributedPackageOp != null) {
                assertThat(attributedPackageOp.getBackgroundAccessCount(
                        AppOpsManager.OP_FLAG_SELF
                                or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                                or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(0)
                assertThat(attributedPackageOp.getBackgroundAccessCount(
                        AppOpsManager.OP_FLAG_SELF
                                or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                                or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(0)
            }
        }

        private fun assertLastReceiverOps(
            op: String,
            beginTimeMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            allPackagesOps: List<AppOpsManager.PackageOps?>
        ) {
            val receiverPackageOps = findPackageOps(
                    attributionSource.next!!.uid,
                    attributionSource.next!!.packageName!!,
                    allPackagesOps)
            for (opEntry in receiverPackageOps!!.ops) {
                if (op != opEntry.opStr) {
                    continue
                }
                val attributedOpEntry = opEntry.attributedOpEntries[
                        attributionSource.next!!.attributionTag]
                val opProxyInfo: AppOpsManager.OpEventProxyInfo?
                opProxyInfo = if (accessorTrusted) {
                    // Received from a trusted accessor. If we got the data from a datasource it
                    // would blame the accessor in a trusted way
                    assertLastAccessInRange(attributedOpEntry!!, beginTimeMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_TRUSTED_PROXIED, receiverForeground,
                            assertRunning)
                    attributedOpEntry.getLastProxyInfo(AppOpsManager.OP_FLAG_TRUSTED_PROXIED)
                } else {
                    // Received from an untrusted accessor
                    assertLastAccessInRange(attributedOpEntry!!, beginTimeMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED, receiverForeground,
                            assertRunning)
                    attributedOpEntry.getLastProxyInfo(
                            AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED)
                }
                assertThat(opProxyInfo!!.uid).isEqualTo(attributionSource.uid)
                assertThat(opProxyInfo.packageName).isEqualTo(attributionSource.packageName)
                assertThat(opProxyInfo.attributionTag).isEqualTo(attributionSource.attributionTag)
            }
        }

        private fun assertHistoricalReceiverOps(
            op: String,
            attributionSource: AttributionSource,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertedAccessCount: Int,
            historicalOps: AppOpsManager.HistoricalOps
        ) {
            val accessorPackageOps = findPackageOps(
                    attributionSource.next!!.uid,
                    attributionSource.next!!.packageName!!,
                    historicalOps)
            val attributedPackageOps = accessorPackageOps?.getAttributedOps(
                    attributionSource.next!!.attributionTag!!)
            val attributedPackageOp = attributedPackageOps!!.getOp(op)
            if (accessorTrusted) {
                // Received from a trusted accessor.
                    assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                            receiverForeground, assertedAccessCount)
            } else {
                // Received from an untrusted accessor
                assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED,
                        receiverForeground, assertedAccessCount)
            }
        }

        private fun assertLastAccessInRange(
            opEntry: AppOpsManager.AttributedOpEntry,
            beginTimeMillis: Long,
            endTimeMillis: Long,
            assertedFlag: Int,
            assertForeground: Boolean,
            assertRunning: Boolean
        ) {
            assertThat(opEntry.isRunning).isEqualTo(assertRunning)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_SELF,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_TRUSTED_PROXY,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_UNTRUSTED_PROXY,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED,
                    assertForeground, beginTimeMillis, endTimeMillis)
            if (assertForeground) {
                assertThat(opEntry.getLastAccessBackgroundTime(AppOpsManager.OP_FLAGS_ALL))
                        .isEqualTo(-1)
            } else {
                assertThat(opEntry.getLastAccessForegroundTime(AppOpsManager.OP_FLAGS_ALL))
                        .isEqualTo(-1)
            }
        }

        private fun assertTimeInRangeIfRequired(
            opEntry: AppOpsManager.AttributedOpEntry,
            assertedFlag: Int,
            accessedFlag: Int,
            assertForeground: Boolean,
            beginTimeMillis: Long,
            endTimeMillis: Long
        ) {
            if (assertedFlag != accessedFlag) {
                return
            }
            val accessTime: Long
            accessTime = if (assertForeground) {
                opEntry.getLastAccessForegroundTime(accessedFlag)
            } else {
                opEntry.getLastAccessBackgroundTime(accessedFlag)
            }
            assertThat(accessTime).isAtLeast(beginTimeMillis)
            assertThat(accessTime).isAtMost(endTimeMillis)
        }

        private fun assertAccessCount(
            historicalOp: AppOpsManager.HistoricalOp,
            assertedFlag: Int,
            assertForeground: Boolean,
            assertedAccessCount: Int
        ) {
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_SELF,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_TRUSTED_PROXY,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_UNTRUSTED_PROXY,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED,
                    assertedFlag, assertForeground, assertedAccessCount)
            if (assertForeground) {
                assertThat(historicalOp.getBackgroundAccessCount(
                        AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            } else {
                assertThat(historicalOp.getForegroundAccessCount(
                        AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            }
        }

        private fun assertAccessCountIfRequired(
            historicalOp: AppOpsManager.HistoricalOp,
            assertedFlag: Int,
            accessedFlag: Int,
            assertForeground: Boolean,
            assertedAccessCount: Int
        ) {
            if (assertedFlag != accessedFlag) {
                return
            }
            val accessCount: Long
            accessCount = if (assertForeground) {
                historicalOp.getForegroundAccessCount(accessedFlag)
            } else {
                historicalOp.getBackgroundAccessCount(accessedFlag)
            }
            assertThat(accessCount).isEqualTo(assertedAccessCount)
        }

        private fun findPackageOps(
            uid: Int,
            packageName: String,
            searchedList: List<AppOpsManager.PackageOps?>
        ): AppOpsManager.PackageOps? {
            return searchedList.stream()
                    .filter { packageOps: AppOpsManager.PackageOps? ->
                        packageOps!!.uid == uid && packageOps.packageName == packageName
                    }
                    .findAny()
                    .orElse(null)
        }

        private fun findPackageOps(
            uid: Int,
            packageName: String,
            historicalOps: AppOpsManager.HistoricalOps
        ): AppOpsManager.HistoricalPackageOps? {
            val uidOps = historicalOps.getUidOps(uid)
            return uidOps?.getPackageOps(packageName)
        }

        fun createAttributionContext(
            attributionTag: String?,
            receiverPackageName: String?,
            receiverAttributionTag: String?
        ): Context {
            val attributionParamsBuilder = ContextParams.Builder()
            if (attributionTag != null) {
                attributionParamsBuilder.setAttributionTag(attributionTag)
            }
            if (receiverPackageName != null) {
                val attributionSourceBuilder = AttributionSource.Builder(
                        context.packageManager.getPackageUid(receiverPackageName, 0))
                attributionSourceBuilder.setPackageName(receiverPackageName)
                if (receiverAttributionTag != null) {
                    attributionSourceBuilder.setAttributionTag(receiverAttributionTag)
                }
                var receiverAttributionSource = attributionSourceBuilder.build()
                SystemUtil.runWithShellPermissionIdentity {
                    receiverAttributionSource = context.getSystemService(
                            PermissionManager::class.java)!!.registerAttributionSource(
                            receiverAttributionSource)
                }
                attributionParamsBuilder.setNextAttributionSource(receiverAttributionSource)
            }
            return context.createContext(attributionParamsBuilder.build())
        }

        fun startBlamedAppActivity(): AttributionSource {
            val activityStatedLatch = CountDownLatch(1)
            val attributionSourceRef = AtomicReference<AttributionSource>()
            val intent = Intent()
            intent.setClassName(RECEIVER_PACKAGE_NAME, BRING_TO_FOREGROUND_ACTIVITY)
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_SINGLE_TOP)
            intent.putExtra(REMOTE_CALLBACK, RemoteCallback {
                attributionSourceRef.set(it?.getParcelable(ATTRIBUTION_SOURCE))
                activityStatedLatch.countDown()
            })
            context.startActivity(intent)
            activityStatedLatch.await(ASYNC_OPERATION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
            return attributionSourceRef.get()
        }

        private fun assumeNotTv() = assumeFalse(isTv)
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testTrustedAccessCallLogAttributeToAnother"	"CtsPermission5TestCases"	"1: identifier"	"@Throws(Exception::class)
    fun testTrustedAccessCallLogAttributeToAnother() {
        testTrustedAccessAttributeToAnother(CallLog.Calls.CONTENT_URI,
                Manifest.permission.READ_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testTrustedAccessAttributeToAnother(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)
        val beginEndMillis = System.currentTimeMillis()
        SystemUtil.runWithShellPermissionIdentity {
            context.contentResolver.query(uri, null, null, null)!!.close()
        }
        val endTimeMillis = System.currentTimeMillis()

        // Calculate the shellUid to account for running this from a secondary user.
        val shellUid = UserHandle.getUid(Process.myUserHandle().identifier,
            UserHandle.getAppId(Process.SHELL_UID))
        // Since we use adopt the shell permission identity we need to adjust
        // the permission identity to have the shell as the accessor.
        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, AttributionSource(shellUid,
                SHELL_PACKAGE_NAME, context.attributionTag, null,
                context.attributionSource.next),
                /*accessorForeground*/ false, /*receiverForeground*/ false,
                /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 1, /*checkAccessor*/ false,
                /*fromDatasource*/ false)
    }"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-1"	"9.8.2/T-5-1"	"tv television"	"""[9.8.2/T-5-1] MUST display the camera indicator when an app is accessing live camera data, but not when the camera is only being accessed by app(s) holding the roles called out in Section 9.1 Permissions with CDD identifier [C-3-X]. ["""	""	"android.permission5.cts.RenouncedPermissionsTest.kt"	"testCannotRequestRenouncePermissions"	"CtsPermission5TestCases"	"1: identifier identifier"	"(expected = IllegalArgumentException::class)
    fun testCannotRequestRenouncePermissions() {
        val renouncedPermissions = ArraySet<String>()
        renouncedPermissions.add(Manifest.permission.READ_CONTACTS);
        val activity = createActivityWithAttributionSource(AttributionSource(Process.myUid(),
                context.packageName, null, renouncedPermissions, null))

        // Requesting renounced permissions throws
        activity.requestPermissions(arrayOf(Manifest.permission.READ_CONTACTS), 1)
    }

    fun createActivityWithAttributionContext(receiverAttributionSource: AttributionSource?,
            renouncedPermissions: Set<String>? = null) : Activity {
        val contextParams = ContextParams.Builder()
                .setRenouncedPermissions(renouncedPermissions)
                .setNextAttributionSource(receiverAttributionSource)
                .build()
        return createActivityWithContextParams(contextParams)
    }

    fun createActivityWithAttributionSource(attributionSource: AttributionSource) : Activity {
        val mockActivity = Mockito.mock(Activity::class.java)
        `when`(mockActivity.getAttributionSource()).thenReturn(attributionSource)
        return mockActivity
    }

    fun createActivityWithContextParams(contextParams: ContextParams) : Activity {
        val activityReference = AtomicReference<NoOpActivity>()
        instrumentation.runOnMainSync {
            activityReference.set(NoOpActivity())
        }
        val activity = activityReference.get()
        activity.attachBaseContext(context.createContext(contextParams))
        return activity
    }

    companion object {
        private val context: Context
            get () = InstrumentationRegistry.getInstrumentation().getContext()

        private val instrumentation: Instrumentation
            get () = InstrumentationRegistry.getInstrumentation()

        fun getShellAttributionSourceWithRenouncedPermissions() : AttributionSource {
            // Let's cook up an attribution source for the shell with its cooperation
            val renouncedPermissionsSet = ArraySet<String>();
            renouncedPermissionsSet.add(Manifest.permission.READ_CONTACTS)
            renouncedPermissionsSet.add(Manifest.permission.READ_CALENDAR)

            // Calculate the shellUid to account for running this from a secondary user.
            val shellUid = UserHandle.getUid(Process.myUserHandle().identifier,
                UserHandle.getAppId(Process.SHELL_UID))
            var shellAttributionSource = AttributionSource.Builder(shellUid)
                    .setPackageName(""com.android.shell"")
                    .setRenouncedPermissions(renouncedPermissionsSet)
                    .build()

            SystemUtil.runWithShellPermissionIdentity {
                val permissionManager = context.getSystemService(PermissionManager::class.java)!!
                shellAttributionSource = permissionManager.registerAttributionSource(
                        shellAttributionSource)
            }

            return shellAttributionSource
        }
    }
}"	"being indicator roles live camera C-3-X tv CDD identifier television 2/T-5-1 app(s)"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RenouncedPermissionsTest.kt"	""	""	""
