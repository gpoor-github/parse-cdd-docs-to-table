"Section"	"section_id"	"req_id"	"Test Availability"	"class_def"	"method"	"module"	"method_text"	"full_key"	"requirement"	"key_as_number"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"matched_terms"	"search_roots"	"qualified_method"	"max_matches"	"file_name"	"matched_files"	"methods_string"	"urls"	"protected"	"Area"	"Shortened"	"Test Level"
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.media.cts.SurfaceEncodeTimestampTest"	"testMaxFps"	"CtsMediaTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/SurfaceEncodeTimestampTest.java"	""	"public void testMaxFps() throws Throwable {         long[] inputPts = {16667, 33333, 50000, 66667, 83333};         long[] expectedOutputPts = {16667, 50000, 83333};         doTest(inputPts, expectedOutputPts, (format) -> {             format.setFloat(MediaFormat.KEY_MAX_FPS_TO_ENCODER, 30.0f);         });     }      /*      * Test KEY_CAPTURE_RATE      *      * Input frames are timestamped at various capture fps to simulate slow-motion      * or timelapse recording scenarios. The key is supposed to adjust (stretch or      * compress) the output timestamp so that the output fps becomes that specified      * by  KEY_FRAME_RATE.      */     @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.media.cts.MediaCasTest"	"adoptShellPermissionIdentity"	"CtsMediaTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/MediaCasTest.java"	""	"public void test/*  *.  */  package android.media.cts;  import android.media.MediaCas; import android.media.MediaCas.PluginDescriptor; import android.media.MediaCas.Session; import android.media.MediaCasException; import android.media.MediaCasException.UnsupportedCasException; import android.media.MediaCasStateException; import android.media.MediaCodec; import android.media.MediaDescrambler; import android.media.cts.R; import android.os.Build; import android.os.Handler; import android.os.HandlerThread; import android.platform.test.annotations.AppModeFull; import android.platform.test.annotations.Presubmit; import android.platform.test.annotations.RequiresDevice; import android.test.AndroidTestCase; import android.util.Log;  import androidx.test.filters.SmallTest; import androidx.test.InstrumentationRegistry;  import com.android.compatibility.common.util.ApiLevelUtil; import com.android.compatibility.common.util.MediaUtils; import com.android.compatibility.common.util.PropertyUtil;  import java.lang.ArrayIndexOutOfBoundsException; import java.nio.ByteBuffer; import java.util.Arrays; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.regex.Matcher; import java.util.regex.Pattern;  @Presubmit @SmallTest @RequiresDevice @AppModeFull(reason = ""TODO: evaluate and port to instant"") public class MediaCasTest extends AndroidTestCase {     private static final String TAG = ""MediaCasTest"";      // CA System Ids used for testing     private static final int sInvalidSystemId = 0;     private static final int sClearKeySystemId = 0xF6D8;     private static final int API_LEVEL_BEFORE_CAS_SESSION = 28;     private boolean mIsAtLeastR = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.R);      // ClearKey CAS/Descrambler test vectors     private static final String sProvisionStr =             ""{                                                   "" +             ""  \""id\"": 21140844,                                 "" +             ""  \""name\"": \""Test Title\"",                         "" +             ""  \""lowercase_organization_name\"": \""Android\"",     "" +             ""  \""asset_key\"": {                                  "" +             ""  \""encryption_key\"": \""nezAr3CHFrmBR9R8Tedotw==\""  "" +             ""  },                                                "" +             ""  \""cas_type\"": 1,                                  "" +             ""  \""track_types\"": [ ]                              "" +             ""}                                                   "" ;      private static final String sEcmBufferStr =             ""00 00 01 f0 00 50 00 01  00 00 00 01 00 46 00 00"" +             ""00 02 00 00 00 00 00 01  00 00 27 10 02 00 01 77"" +             ""01 42 95 6c 0e e3 91 bc  fd 05 b1 60 4f 17 82 a4"" +             ""86 9b 23 56 00 01 00 00  00 01 00 00 27 10 02 00"" +             ""01 77 01 42 95 6c d7 43  62 f8 1c 62 19 05 c7 3a"" +             ""42 cd fd d9 13 48                               "" ;      private static final String sInputBufferStr =             ""00 00 00 01 09 f0 00 00  00 01 67 42 c0 1e db 01"" +             ""40 16 ec 04 40 00 00 03  00 40 00 00 0f 03 c5 8b"" +             ""b8 00 00 00 01 68 ca 8c  b2 00 00 01 06 05 ff ff"" +             ""70 dc 45 e9 bd e6 d9 48  b7 96 2c d8 20 d9 23 ee"" +             ""ef 78 32 36 34 20 2d 20  63 6f 72 65 20 31 34 32"" +             ""20 2d 20 48 2e 32 36 34  2f 4d 50 45 47 2d 34 20"" +             ""41 56 43 20 63 6f 64 65  63 20 2d 20 43 6f 70 79"" +             ""6c 65 66 74 20 32 30 30  33 2d 32 30 31 34 20 2d"" +             ""20 68 74 74 70 3a 2f 2f  77 77 77 2e 76 69 64 65"" +             ""6f 6c 61 6e 2e 6f 72 67  2f 78 32 36 34 2e 68 74"" +             ""6d 6c 6e 45 21 82 38 f0  9d 7d 96 e6 94 ae e2 87"" +             ""8f 04 49 e5 f6 8c 8b 9a  10 18 ba 94 e9 22 31 04"" +             ""7e 60 5b c4 24 00 90 62  0d dc 85 74 75 78 d0 14"" +             ""08 cb 02 1d 7d 9d 34 e8  81 b9 f7 09 28 79 29 8d"" +             ""e3 14 ed 5f ca af f4 1c  49 15 e1 80 29 61 76 80"" +             ""43 f8 58 53 40 d7 31 6d  61 81 41 e9 77 9f 9c e1"" +             ""6d f2 ee d9 c8 67 d2 5f  48 73 e3 5c cd a7 45 58"" +             ""bb dd 28 1d 68 fc b4 c6  f6 92 f6 30 03 aa e4 32"" +             ""f6 34 51 4b 0f 8c f9 ac  98 22 fb 49 c8 bf ca 8c"" +             ""80 86 5d d7 a4 52 b1 d9  a6 04 4e b3 2d 1f b8 35"" +             ""cc 45 6d 9c 20 a7 a4 34  59 72 e3 ae ba 49 de d1"" +             ""aa ee 3d 77 fc 5d c6 1f  9d ac c2 15 66 b8 e1 54"" +             ""4e 74 93 db 9a 24 15 6e  20 a3 67 3e 5a 24 41 5e"" +             ""b0 e6 35 87 1b c8 7a f9  77 65 e0 01 f2 4c e4 2b"" +             ""a9 64 96 96 0b 46 ca ea  79 0e 78 a3 5f 43 fc 47"" +             ""6a 12 fa c4 33 0e 88 1c  19 3a 00 c3 4e b5 d8 fa"" +             ""8e f1 bc 3d b2 7e 50 8d  67 c3 6b ed e2 ea a6 1f"" +             ""25 24 7c 94 74 50 49 e3  c6 58 2e fd 28 b4 c6 73"" +             ""b1 53 74 27 94 5c df 69  b7 a1 d7 f5 d3 8a 2c 2d"" +             ""b4 5e 8a 16 14 54 64 6e  00 6b 11 59 8a 63 38 80"" +             ""76 c3 d5 59 f7 3f d2 fa  a5 ca 82 ff 4a 62 f0 e3"" +             ""42 f9 3b 38 27 8a 89 aa  50 55 4b 29 f1 46 7c 75"" +             ""ef 65 af 9b 0d 6d da 25  94 14 c1 1b f0 c5 4c 24"" +             ""0e 65                                           "" ;      private static final String sExpectedOutputBufferStr =             ""00 00 00 01 09 f0 00 00  00 01 67 42 c0 1e db 01"" +             ""40 16 ec 04 40 00 00 03  00 40 00 00 0f 03 c5 8b"" +             ""b8 00 00 00 01 68 ca 8c  b2 00 00 01 06 05 ff ff"" +             ""70 dc 45 e9 bd e6 d9 48  b7 96 2c d8 20 d9 23 ee"" +             ""ef 78 32 36 34 20 2d 20  63 6f 72 65 20 31 34 32"" +             ""20 2d 20 48 2e 32 36 34  2f 4d 50 45 47 2d 34 20"" +             ""41 56 43 20 63 6f 64 65  63 20 2d 20 43 6f 70 79"" +             ""6c 65 66 74 20 32 30 30  33 2d 32 30 31 34 20 2d"" +             ""20 68 74 74 70 3a 2f 2f  77 77 77 2e 76 69 64 65"" +             ""6f 6c 61 6e 2e 6f 72 67  2f 78 32 36 34 2e 68 74"" +             ""6d 6c 20 2d 20 6f 70 74  69 6f 6e 73 3a 20 63 61"" +             ""62 61 63 3d 30 20 72 65  66 3d 32 20 64 65 62 6c"" +             ""6f 63 6b 3d 31 3a 30 3a  30 20 61 6e 61 6c 79 73"" +             ""65 3d 30 78 31 3a 30 78  31 31 31 20 6d 65 3d 68"" +             ""65 78 20 73 75 62 6d 65  3d 37 20 70 73 79 3d 31"" +             ""20 70 73 79 5f 72 64 3d  31 2e 30 30 3a 30 2e 30"" +             ""30 20 6d 69 78 65 64 5f  72 65 66 3d 31 20 6d 65"" +             ""5f 72 61 6e 67 65 3d 31  36 20 63 68 72 6f 6d 61"" +             ""5f 6d 65 3d 31 20 74 72  65 6c 6c 69 73 3d 31 20"" +             ""38 78 38 64 63 74 3d 30  20 63 71 6d 3d 30 20 64"" +             ""65 61 64 7a 6f 6e 65 3d  32 31 2c 31 31 20 66 61"" +             ""73 74 5f 70 73 6b 69 70  3d 31 20 63 68 72 6f 6d"" +             ""61 5f 71 70 5f 6f 66 66  73 65 74 3d 2d 32 20 74"" +             ""68 72 65 61 64 73 3d 36  30 20 6c 6f 6f 6b 61 68"" +             ""65 61 64 5f 74 68 72 65  61 64 73 3d 35 20 73 6c"" +             ""69 63 65 64 5f 74 68 72  65 61 64 73 3d 30 20 6e"" +             ""72 3d 30 20 64 65 63 69  6d 61 74 65 3d 31 20 69"" +             ""6e 74 65 72 6c 61 63 65  64 3d 30 20 62 6c 75 72"" +             ""61 79 5f 63 6f 6d 70 61  74 3d 30 20 63 6f 6e 73"" +             ""74 72 61 69 6e 65 64 5f  69 6e 74 72 61 3d 30 20"" +             ""62 66 72 61 6d 65 73 3d  30 20 77 65 69 67 68 74"" +             ""70 3d 30 20 6b 65 79 69  6e 74 3d 32 35 30 20 6b"" +             ""65 79 69 6e 74 5f 6d 69  6e 3d 32 35 20 73 63 65"" +             ""6e 65                                           "" ;      @Override     public void setUp() throws Exception {         super.setUp();         // Need MANAGE_USERS or CREATE_USERS permission to access ActivityManager#getCurrentUser in         // MediaCas. It is used by all tests, then adopt it from shell in setup         InstrumentationRegistry             .getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();     }      @Override     protected void tearDown() throws Exception {         InstrumentationRegistry             .getInstrumentation().getUiAutomation().dropShellPermissionIdentity();         super.tearDown();     }     /**      * Test that all enumerated CA systems can be instantiated.      *      * Due to the vendor-proprietary nature of CAS, we cannot verify all operations      * of an arbitrary plugin. We can only verify that isSystemIdSupported() is      * consistent with the enumeration results, and all enumerated CA system ids can      * be instantiated.      */"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.location.cts.privileged.GnssMeasurementRegistrationTest"	"testGnssMeasurementRegistration_enableFullTracking"	"CtsLocationPrivilegedTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/location/location_privileged/src/android/location/cts/privileged/GnssMeasurementRegistrationTest.java"	""	"public void testGnssMeasurementRegistration_enableFullTracking() throws Exception {         // Checks if GPS hardware feature is present, skips test (pass) if not,         // and hard asserts that Location/GPS (Provider) is turned on if is Cts Verifier.         if (!TestMeasurementUtil.canTestRunOnCurrentDevice(Build.VERSION_CODES.R,                 mTestLocationManager,                 TAG)) {             return;         }          if (TestMeasurementUtil.isAutomotiveDevice(getContext())) {             Log.i(TAG, ""Test is being skipped because the system has the AUTOMOTIVE feature."");             return;         }          // Register for GPS measurements.         mMeasurementListener = new TestGnssMeasurementListener(TAG, GPS_EVENTS_COUNT);         mTestLocationManager.registerGnssMeasurementCallback(mMeasurementListener,                 new GnssRequest.Builder().setFullTracking(true).build());          mMeasurementListener.await();         if (!mMeasurementListener.verifyStatus()) {             // If test is strict verifyStatus will assert conditions are good for further testing.             // Else this returns false and, we arrive here, and then return from here (pass.)             return;         }          List<GnssMeasurementsEvent> events = mMeasurementListener.getEvents();         Log.i(TAG, ""Number of GnssMeasurement events received = "" + events.size());          if (!events.isEmpty()) {             // Test passes if we get at least 1 pseudorange.             Log.i(TAG, ""Received GPS measurements. Test Pass."");             return;         }          SoftAssert.failAsWarning(                 TAG,                 ""GPS measurements were not received without registering for location updates. ""                         + ""Trying again with Location request."");          // Register for location updates.         mLocationListener = new TestLocationListener(EVENTS_COUNT);         mTestLocationManager.requestLocationUpdates(mLocationListener);          // Wait for location updates         mLocationListener.await();         Log.i(TAG, ""Location received = "" + mLocationListener.isLocationReceived());          events = mMeasurementListener.getEvents();         Log.i(TAG, ""Number of GnssMeasurement events received = "" + events.size());          SoftAssert softAssert = new SoftAssert(TAG);         softAssert.assertTrue(                 ""Did not receive any GnssMeasurement events.  Retry outdoors?"",                 !events.isEmpty());         softAssert.assertAll();     } }"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.media.cts.HeifWriterTest"	"exists"	"CtsMediaTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/HeifWriterTest.java"	""	"public void test/*  *.  */  package android.media.cts;  import static androidx.heifwriter.HeifWriter.INPUT_MODE_BITMAP; import static androidx.heifwriter.HeifWriter.INPUT_MODE_BUFFER; import static androidx.heifwriter.HeifWriter.INPUT_MODE_SURFACE;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue;  import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Color; import android.graphics.ImageFormat; import android.graphics.Rect; import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaCodecList; import android.media.MediaExtractor; import android.media.MediaFormat; import android.media.MediaMetadataRetriever; import android.opengl.GLES20; import android.os.Build; import android.os.Environment; import android.os.Handler; import android.os.HandlerThread; import android.os.Process; import android.platform.test.annotations.AppModeFull; import android.platform.test.annotations.Presubmit; import android.platform.test.annotations.RequiresDevice; import android.system.ErrnoException; import android.system.Os; import android.system.OsConstants; import android.test.AndroidTestCase; import android.util.Log;  import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.heifwriter.HeifWriter; import androidx.test.filters.SmallTest;  import com.android.compatibility.common.util.ApiLevelUtil; import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.MediaUtils;  import java.io.Closeable; import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.io.RandomAccessFile; import java.util.Arrays;  @Presubmit @SmallTest @RequiresDevice @AppModeFull(reason = ""Instant apps cannot access the SD card"") public class HeifWriterTest extends AndroidTestCase {     private static final String TAG = HeifWriterTest.class.getSimpleName();     private static final boolean DEBUG = false;     private static final boolean DUMP_OUTPUT = false;     private static final boolean DUMP_YUV_INPUT = false;     private static final int GRID_WIDTH = 512;     private static final int GRID_HEIGHT = 512;     private static final boolean IS_BEFORE_R = ApiLevelUtil.isBefore(Build.VERSION_CODES.R);      private static byte[][] TEST_YUV_COLORS = {             {(byte) 255, (byte) 0, (byte) 0},             {(byte) 255, (byte) 0, (byte) 255},             {(byte) 255, (byte) 255, (byte) 255},             {(byte) 255, (byte) 255, (byte) 0},     };     private static Color COLOR_BLOCK =             Color.valueOf(1.0f, 1.0f, 1.0f);     private static Color[] COLOR_BARS = {             Color.valueOf(0.0f, 0.0f, 0.0f),             Color.valueOf(0.0f, 0.0f, 0.64f),             Color.valueOf(0.0f, 0.64f, 0.0f),             Color.valueOf(0.0f, 0.64f, 0.64f),             Color.valueOf(0.64f, 0.0f, 0.0f),             Color.valueOf(0.64f, 0.0f, 0.64f),             Color.valueOf(0.64f, 0.64f, 0.0f),     };     private static int BORDER_WIDTH = 16;      private static final String HEIFWRITER_INPUT = ""heifwriter_input.heic"";     private static final int[] IMAGE_RESOURCES = new int[] {             R.raw.heifwriter_input     };     private static final String[] IMAGE_FILENAMES = new String[] {             HEIFWRITER_INPUT     };     private static final String OUTPUT_FILENAME = ""output.heic"";      private InputSurface mInputEglSurface;     private Handler mHandler;     private int mInputIndex;      @Override     public void setUp() throws Exception {         for (int i = 0; i < IMAGE_RESOURCES.length; ++i) {             String outputPath = new File(Environment.getExternalStorageDirectory(),                     IMAGE_FILENAMES[i]).getAbsolutePath();              InputStream inputStream = null;             FileOutputStream outputStream = null;             try {                 inputStream = getContext().getResources().openRawResource(IMAGE_RESOURCES[i]);                 outputStream = new FileOutputStream(outputPath);                 copy(inputStream, outputStream);             } finally {                 closeQuietly(inputStream);                 closeQuietly(outputStream);             }         }          HandlerThread handlerThread = new HandlerThread(                 ""HeifEncoderThread"", Process.THREAD_PRIORITY_FOREGROUND);         handlerThread.start();         mHandler = new Handler(handlerThread.getLooper());     }      @Override     public void tearDown() throws Exception {         for (int i = 0; i < IMAGE_RESOURCES.length; ++i) {             String imageFilePath =                     new File(Environment.getExternalStorageDirectory(), IMAGE_FILENAMES[i])                             .getAbsolutePath();             File imageFile = new File(imageFilePath);             if (imageFile.exists()) {                 imageFile.delete();             }         }     }"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.os.ext.cts.SdkExtensionsTest"	"testBadArgument"	""	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/sdkextensions/src/android/os/ext/cts/SdkExtensionsTest.java"	""	"public void testBadArgument() throws Exception {         // R is the first SDK version with extensions.         for (int sdk = -1_000_000; sdk < Build.VERSION_CODES.R; sdk++) {             try {                 SdkExtensions.getExtensionVersion(sdk);                 fail(""expected IllegalArgumentException"");             } catch (IllegalArgumentException expected) { }         }     }      /** Verifies that getExtensionVersion only return existing versions */"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.os.ext.cts.SdkExtensionsTest"	"testValidValues"	""	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/sdkextensions/src/android/os/ext/cts/SdkExtensionsTest.java"	""	"public void testValidValues() throws Exception {         for (int sdk = Build.VERSION_CODES.R; sdk <= 1_000_000; sdk++) {             // No extension SDKs versions yet.             assertEquals(0, SdkExtensions.getExtensionVersion(sdk));         }     } }"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.provider.cts.media.MediaStoreTest"	"testLegacy"	"CtsProviderTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStoreTest.java"	""	"public void testLegacy() throws Exception {         final ProviderInfo legacy = getContext().getPackageManager()                 .resolveContentProvider(MediaStore.AUTHORITY_LEGACY, 0);         if (legacy == null) {             if (Build.VERSION.FIRST_SDK_INT >= Build.VERSION_CODES.R) {                 // If we're a brand new device, we don't require a legacy                 // provider, since there's nothing to upgrade                 return;             } else {                 fail(""Upgrading devices must have a legacy MediaProvider at ""                         + ""MediaStore.AUTHORITY_LEGACY to upgrade user data from"");             }         }          // Verify that legacy provider is protected         assertEquals(""Legacy provider at MediaStore.AUTHORITY_LEGACY must protect its data"",                 android.Manifest.permission.WRITE_MEDIA_STORAGE, legacy.readPermission);         assertEquals(""Legacy provider at MediaStore.AUTHORITY_LEGACY must protect its data"",                 android.Manifest.permission.WRITE_MEDIA_STORAGE, legacy.writePermission);          // And finally verify that legacy provider is headless         final PackageInfo legacyPackage = getContext().getPackageManager().getPackageInfo(                 legacy.packageName, PackageManager.GET_ACTIVITIES | PackageManager.GET_PROVIDERS                         | PackageManager.GET_RECEIVERS | PackageManager.GET_SERVICES);         assertEmpty(""Headless legacy MediaProvider must have no activities"",                 legacyPackage.activities);         assertEquals(""Headless legacy MediaProvider must have exactly one provider"",                 1, legacyPackage.providers.length);         assertEmpty(""Headless legacy MediaProvider must have no receivers"",                 legacyPackage.receivers);         assertEmpty(""Headless legacy MediaProvider must have no services"",                 legacyPackage.services);     }      private static <T> void assertEmpty(String message, T[] array) {         if (array != null && array.length > 0) {             fail(message);         }     } }"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.media.cts.DecoderTest"	"testVrHighPerformanceVP9"	"CtsMediaTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testVrHighPerformanceVP9() throws Exception {         if (!supportsVrHighPerformance()) {             MediaUtils.skipTest(TAG, ""FEATURE_VR_MODE_HIGH_PERFORMANCE not present"");             return;         }          // Test minimum mandatory requirements.         assertTrue(doesMimeTypeHaveMinimumSpecVrReadyCodec(MediaFormat.MIMETYPE_VIDEO_VP9));          boolean vp9IsReady = doesMimeTypeHaveVrReadyCodec(MediaFormat.MIMETYPE_VIDEO_VP9);         if (!vp9IsReady) {             Log.d(TAG, ""VP9 isn't required to be VR ready"");             return;         }     }      private boolean supportsVrHighPerformance() {         PackageManager pm = mContext.getPackageManager();         return pm.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);     }      @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.media.cts.DecoderTest"	"testLowLatencyVp9At1280x720"	"CtsMediaTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testLowLatencyVp9At1280x720() throws Exception {         testLowLatencyVideo(                 R.raw.video_1280x720_webm_vp9_csd_309kbps_25fps_vorbis_stereo_128kbps_48000hz, 300,                 false /* useNdk */);         testLowLatencyVideo(                 R.raw.video_1280x720_webm_vp9_csd_309kbps_25fps_vorbis_stereo_128kbps_48000hz, 300,                 true /* useNdk */);     }      @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.media.cts.DecoderTest"	"testLowLatencyVp9At1920x1080"	"CtsMediaTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testLowLatencyVp9At1920x1080() throws Exception {         testLowLatencyVideo(                 R.raw.bbb_s2_1920x1080_webm_vp9_0p41_10mbps_60fps_vorbis_6ch_384kbps_22050hz, 300,                 false /* useNdk */);         testLowLatencyVideo(                 R.raw.bbb_s2_1920x1080_webm_vp9_0p41_10mbps_60fps_vorbis_6ch_384kbps_22050hz, 300,                 true /* useNdk */);     }      @SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.jni.cts.JniStaticTest"	"test_dlopenPublicLibraries"	"CtsJniTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/jni/src/android/jni/cts/JniStaticTest.java"	""	"public void test_dlopenPublicLibraries() {         if (PropertyUtil.isVendorApiLevelAtLeast(Build.VERSION_CODES.R)) {             String error = LinkerNamespacesHelper.runDlopenPublicLibraries();             if (error != null) {                 fail(error);             }         }     }      /**      * If ICU4C native libraries, i.e. libicuuc.so and libicui18n.so, have been moved into APEX,      * app with targetSdkVersion < Q can still dlopen the /system/{LIB}/libicuuc.so even though      * the file does not exist in the file system. It's done by a redirect in linker.      * http://b/121248172      *      * This test ensures that dlopen fail with a target version SDK of Q or above.      */"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.media.cts.MediaRecorderTest"	"MediaRecorderTest"	"CtsMediaTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/MediaRecorderTest.java"	""	"public void test/*  *.  */ package android.media.cts;  import static android.media.MediaCodecInfo.CodecProfileLevel.*;  import android.content.pm.PackageManager; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.hardware.Camera; import android.media.AudioFormat; import android.media.AudioRecordingConfiguration; import android.media.CamcorderProfile; import android.media.EncoderCapabilities; import android.media.EncoderCapabilities.VideoEncoderCap; import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaCodecInfo.CodecCapabilities; import android.media.MediaCodecList; import android.media.MediaExtractor; import android.media.MediaFormat; import android.media.MediaMetadataRetriever; import android.media.MediaRecorder; import android.media.MediaRecorder.OnErrorListener; import android.media.MediaRecorder.OnInfoListener; import android.media.MicrophoneDirection; import android.media.MicrophoneInfo; import android.media.cts.AudioRecordingConfigurationTest.MyAudioRecordingCallback; import android.opengl.GLES20; import android.os.Build; import android.os.ConditionVariable; import android.os.Environment; import android.os.ParcelFileDescriptor; import android.os.PersistableBundle; import android.platform.test.annotations.AppModeFull; import android.platform.test.annotations.RequiresDevice; import android.test.ActivityInstrumentationTestCase2; import android.test.UiThreadTest; import android.util.Log; import android.view.Surface;  import androidx.test.filters.SmallTest;  import com.android.compatibility.common.util.ApiLevelUtil; import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.MediaUtils;  import java.io.File; import java.io.FileDescriptor; import java.io.FileOutputStream; import java.io.IOException; import java.io.RandomAccessFile; import java.lang.Runnable; import java.util.ArrayList; import java.util.List; import java.util.Set; import java.util.concurrent.CountDownLatch; import java.util.concurrent.Executor; import java.util.concurrent.TimeUnit;  @SmallTest @RequiresDevice @AppModeFull(reason = ""TODO: evaluate and port to instant"") public class MediaRecorderTest extends ActivityInstrumentationTestCase2<MediaStubActivity> {     private final String TAG = ""MediaRecorderTest"";     private final String OUTPUT_PATH;     private final String OUTPUT_PATH2;     private static final float TOLERANCE = 0.0002f;     private static final int RECORD_TIME_MS = 3000;     private static final int RECORD_TIME_LAPSE_MS = 6000;     private static final int RECORD_TIME_LONG_MS = 20000;     private static final int RECORDED_DUR_TOLERANCE_MS = 1000;     private static final int TEST_TIMING_TOLERANCE_MS = 70;     // Tolerate 4 frames off at maximum     private static final float RECORDED_DUR_TOLERANCE_FRAMES = 4f;     private static final int VIDEO_WIDTH = 176;     private static final int VIDEO_HEIGHT = 144;     private static int mVideoWidth = VIDEO_WIDTH;     private static int mVideoHeight = VIDEO_HEIGHT;     private static final int VIDEO_BIT_RATE_IN_BPS = 128000;     private static final double VIDEO_TIMELAPSE_CAPTURE_RATE_FPS = 1.0;     private static final int AUDIO_BIT_RATE_IN_BPS = 12200;     private static final int AUDIO_NUM_CHANNELS = 1;     private static final int AUDIO_SAMPLE_RATE_HZ = 8000;     private static final long MAX_FILE_SIZE = 5000;     private static final int MAX_FILE_SIZE_TIMEOUT_MS = 5 * 60 * 1000;     private static final int MAX_DURATION_MSEC = 2000;     private static final float LATITUDE = 0.0000f;     private static final float LONGITUDE  = -180.0f;     private static final int NORMAL_FPS = 30;     private static final int TIME_LAPSE_FPS = 5;     private static final int SLOW_MOTION_FPS = 120;     private static final List<VideoEncoderCap> mVideoEncoders =             EncoderCapabilities.getVideoEncoders();      private boolean mOnInfoCalled;     private boolean mOnErrorCalled;     private File mOutFile;     private File mOutFile2;     private Camera mCamera;     private MediaStubActivity mActivity = null;     private int mFileIndex;      private MediaRecorder mMediaRecorder;     private ConditionVariable mMaxDurationCond;     private ConditionVariable mMaxFileSizeCond;     private ConditionVariable mMaxFileSizeApproachingCond;     private ConditionVariable mNextOutputFileStartedCond;     private boolean mExpectMaxFileCond;      // movie length, in frames     private static final int NUM_FRAMES = 120;      private static final int TEST_R0 = 0;                   // RGB equivalent of {0,0,0} (BT.601)     private static final int TEST_G0 = 136;     private static final int TEST_B0 = 0;     private static final int TEST_R1 = 236;                 // RGB equivalent of {120,160,200} (BT.601)     private static final int TEST_G1 = 50;     private static final int TEST_B1 = 186;      private final static String AVC = MediaFormat.MIMETYPE_VIDEO_AVC;      private boolean mIsAtLeastR = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.R);      public MediaRecorderTest() {         super(""android.media.cts"", MediaStubActivity.class);         OUTPUT_PATH = new File(Environment.getExternalStorageDirectory(),                 ""record.out"").getAbsolutePath();         OUTPUT_PATH2 = new File(Environment.getExternalStorageDirectory(),                 ""record2.out"").getAbsolutePath();     }      private void completeOnUiThread(final Runnable runnable) {         final CountDownLatch latch = new CountDownLatch(1);         getActivity().runOnUiThread(new Runnable() {             @Override             public void run() {                 runnable.run();                 latch.countDown();             }         });         try {             // if UI thread does not run, things will fail anyway             assertTrue(latch.await(10, TimeUnit.SECONDS));         } catch (java.lang.InterruptedException e) {             fail(""should not be interrupted"");         }     }      @Override     protected void setUp() throws Exception {         mActivity = getActivity();         completeOnUiThread(new Runnable() {             @Override             public void run() {                 mMediaRecorder = new MediaRecorder();                 mOutFile = new File(OUTPUT_PATH);                 mOutFile2 = new File(OUTPUT_PATH2);                 mFileIndex = 0;                  mMaxDurationCond = new ConditionVariable();                 mMaxFileSizeCond = new ConditionVariable();                 mMaxFileSizeApproachingCond = new ConditionVariable();                 mNextOutputFileStartedCond = new ConditionVariable();                 mExpectMaxFileCond = true;                  mMediaRecorder.setOutputFile(OUTPUT_PATH);                 mMediaRecorder.setOnInfoListener(new OnInfoListener() {                     public void onInfo(MediaRecorder mr, int what, int extra) {                         mOnInfoCalled = true;                         if (what ==                             MediaRecorder.MEDIA_RECORDER_INFO_MAX_DURATION_REACHED) {                             Log.v(TAG, ""max duration reached"");                             mMaxDurationCond.open();                         } else if (what ==                             MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED) {                             Log.v(TAG, ""max file size reached"");                             mMaxFileSizeCond.open();                         }                     }                 });                 mMediaRecorder.setOnErrorListener(new OnErrorListener() {                     public void onError(MediaRecorder mr, int what, int extra) {                         mOnErrorCalled = true;                     }                 });             }         });         super.setUp();     }      @Override     protected void tearDown() throws Exception {         if (mMediaRecorder != null) {             mMediaRecorder.release();             mMediaRecorder = null;         }         if (mOutFile != null && mOutFile.exists()) {             mOutFile.delete();         }         if (mOutFile2 != null && mOutFile2.exists()) {             mOutFile2.delete();         }         if (mCamera != null)  {             mCamera.release();             mCamera = null;         }         mMaxDurationCond.close();         mMaxDurationCond = null;         mMaxFileSizeCond.close();         mMaxFileSizeCond = null;         mMaxFileSizeApproachingCond.close();         mMaxFileSizeApproachingCond = null;         mNextOutputFileStartedCond.close();         mNextOutputFileStartedCond = null;         mActivity = null;         super.tearDown();     }"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.media.cts.MediaMetadataRetrieverTest"	"exists"	"CtsMediaTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/MediaMetadataRetrieverTest.java"	""	"public void test/*  *.  */  package android.media.cts;  import static android.media.MediaMetadataRetriever.OPTION_CLOSEST; import static android.media.MediaMetadataRetriever.OPTION_CLOSEST_SYNC; import static android.media.MediaMetadataRetriever.OPTION_NEXT_SYNC; import static android.media.MediaMetadataRetriever.OPTION_PREVIOUS_SYNC;  import android.content.Context; import android.content.pm.PackageManager; import android.content.res.AssetFileDescriptor; import android.content.res.Resources; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Color; import android.graphics.Rect; import android.hardware.display.DisplayManager; import android.media.MediaDataSource; import android.media.MediaExtractor; import android.media.MediaFormat; import android.media.MediaMetadataRetriever; import android.media.MediaRecorder; import android.media.cts.R; import android.net.Uri; import android.os.Build; import android.os.Environment; import android.platform.test.annotations.AppModeFull; import android.platform.test.annotations.Presubmit; import android.platform.test.annotations.RequiresDevice; import android.test.AndroidTestCase; import android.util.Log; import android.view.Display;  import androidx.test.filters.SmallTest;  import com.android.compatibility.common.util.ApiLevelUtil; import com.android.compatibility.common.util.MediaUtils;  import java.io.Closeable; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.function.Function;  @Presubmit @SmallTest @RequiresDevice @AppModeFull(reason = ""No interaction with system server"") public class MediaMetadataRetrieverTest extends AndroidTestCase {     private static final String TAG = ""MediaMetadataRetrieverTest"";     private static final boolean SAVE_BITMAP_OUTPUT = false;     private static final String TEST_MEDIA_FILE = ""retriever_test.3gp"";      protected Resources mResources;     protected MediaMetadataRetriever mRetriever;     private PackageManager mPackageManager;      protected static final int SLEEP_TIME = 1000;     private static int BORDER_WIDTH = 16;     private static Color COLOR_BLOCK =             Color.valueOf(1.0f, 1.0f, 1.0f);     private static Color[] COLOR_BARS = {             Color.valueOf(0.0f, 0.0f, 0.0f),             Color.valueOf(0.0f, 0.0f, 0.64f),             Color.valueOf(0.0f, 0.64f, 0.0f),             Color.valueOf(0.0f, 0.64f, 0.64f),             Color.valueOf(0.64f, 0.0f, 0.0f),             Color.valueOf(0.64f, 0.0f, 0.64f),             Color.valueOf(0.64f, 0.64f, 0.0f),     };     private boolean mIsAtLeastR = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.R);      @Override     protected void setUp() throws Exception {         super.setUp();         mResources = getContext().getResources();         mRetriever = new MediaMetadataRetriever();         mPackageManager = getContext().getPackageManager();     }      @Override     protected void tearDown() throws Exception {         super.tearDown();         mRetriever.release();         File file = new File(Environment.getExternalStorageDirectory(), TEST_MEDIA_FILE);         if (file.exists()) {             file.delete();         }     }      protected void setDataSourceFd(int resid) {         try {             AssetFileDescriptor afd = mResources.openRawResourceFd(resid);             mRetriever.setDataSource(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength());             afd.close();         } catch (Exception e) {             fail(""Unable to open file"");         }     }      protected TestMediaDataSource setDataSourceCallback(int resid) {         TestMediaDataSource ds = null;         try {             AssetFileDescriptor afd = mResources.openRawResourceFd(resid);             ds = TestMediaDataSource.fromAssetFd(afd);             mRetriever.setDataSource(ds);         } catch (Exception e) {             fail(""Unable to open file"");         }         return ds;     }      protected TestMediaDataSource getFaultyDataSource(int resid, boolean throwing) {         TestMediaDataSource ds = null;         try {             AssetFileDescriptor afd = mResources.openRawResourceFd(resid);             ds = TestMediaDataSource.fromAssetFd(afd);             if (throwing) {                 ds.throwFromReadAt();             } else {                 ds.returnFromReadAt(-2);             }         } catch (Exception e) {             fail(""Unable to open file"");         }         return ds;     }"	""	""	""	""	""
"168:530476) 7.2.3  . Navigation Keys"	"7.2.3"	"C-3-1"	""	"android.media.cts.DecoderTestXheAac"	"isAlias"	"CtsMediaTestCases"	""	"7.2.3/C-3-1"	"""C-3-1] MUST make the Menu function available to applications when targetSdkVersion is less than 10, either by a physical button, a software key, or gestures. This Menu function should be accessible unless hidden together with other navigation functions. If device implementations provide the Assist function, they: """	""	"Build.VERSION_CODES.R"	""	""	""	"Build.VERSION_CODES.R"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/DecoderTestXheAac.java"	""	"/*  *.  */  package android.media.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.app.Instrumentation; import android.content.res.AssetFileDescriptor; import android.content.res.Resources; import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaCodecList; import android.media.MediaExtractor; import android.media.MediaFormat; import android.media.cts.DecoderTest.AudioParameter; import android.media.cts.DecoderTestAacDrc.DrcParams; import android.media.cts.R; import android.os.Build; import android.util.Log; import android.os.Bundle;  import androidx.test.InstrumentationRegistry;  import com.android.compatibility.common.util.ApiLevelUtil; import com.android.compatibility.common.util.MediaUtils;  import org.junit.Before; import org.junit.Test;  import java.io.IOException; import java.nio.ByteBuffer; import java.util.ArrayList; import java.util.Arrays; import java.util.List;  public class DecoderTestXheAac {     private static final String TAG = ""DecoderTestXheAac"";      private static final boolean sIsAndroidRAndAbove =             ApiLevelUtil.isAtLeast(Build.VERSION_CODES.R);      private Resources mResources;      // list of all AAC decoders as enumerated through the MediaCodecList     // lazy initialization in setUp()     private static ArrayList<String> sAacDecoderNames;      @Before     public void setUp() throws Exception {         final Instrumentation inst = InstrumentationRegistry.getInstrumentation();         assertNotNull(inst);         mResources = inst.getContext().getResources();         // build a list of all AAC decoders on which to run the test         if (sAacDecoderNames == null) {             sAacDecoderNames = initAacDecoderNames();         }     }      protected static ArrayList<String> initAacDecoderNames() {         // at least 1 AAC decoder expected         ArrayList<String> aacDecoderNames = new ArrayList<String>(1);         final MediaCodecList mediaCodecList = new MediaCodecList(MediaCodecList.REGULAR_CODECS);         final MediaCodecInfo[] mediaCodecInfos = mediaCodecList.getCodecInfos();         for (MediaCodecInfo mediaCodecInfo : mediaCodecInfos) {             if (mediaCodecInfo.isAlias()) {                 continue;             }             if (mediaCodecInfo.isEncoder()) {                 continue;             }             final String[] mimeTypes = mediaCodecInfo.getSupportedTypes();             for (String mimeType : mimeTypes) {                 if (MediaFormat.MIMETYPE_AUDIO_AAC.equalsIgnoreCase(mimeType)) {                     aacDecoderNames.add(mediaCodecInfo.getName());                     break;                 }             }         }         return aacDecoderNames;     }      /**      * Verify the correct decoding of USAC bitstreams with different MPEG-D DRC effect types.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.hardware.input.cts.tests.SonyDualshock4ProBluetoothTest"	"SonyDualshock4ProBluetoothTest"	"CtsHardwareTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/SonyDualshock4ProBluetoothTest.java"	""	"/*  *.  */  package android.hardware.input.cts.tests;  import static org.junit.Assume.assumeTrue;  import android.hardware.cts.R; import android.os.Build; import android.os.VintfRuntimeInfo; import android.text.TextUtils; import android.util.Pair;  import androidx.test.ext.junit.runners.AndroidJUnit4; import androidx.test.filters.SmallTest;  import java.util.regex.Matcher; import java.util.regex.Pattern;  import org.junit.Test; import org.junit.runner.RunWith;  @SmallTest @RunWith(AndroidJUnit4.class) public class SonyDualshock4ProBluetoothTest extends InputTestCase {      // Simulates the behavior of PlayStation DualShock4 Pro gamepad (model CUH-ZCT2U)     public SonyDualshock4ProBluetoothTest() {         super(R.raw.sony_dualshock4pro_bluetooth_register);     }      // Copied from cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java     private static Pair<Integer, Integer> getVersionFromString(String version) {         // Only gets major and minor number of the version string.         final Pattern versionPattern = Pattern.compile(""^(\\d+)(\\.(\\d+))?.*"");         final Matcher m = versionPattern.matcher(version);         if (m.matches()) {             final int major = Integer.parseInt(m.group(1));             final int minor = TextUtils.isEmpty(m.group(3)) ? 0 : Integer.parseInt(m.group(3));             return new Pair<>(major, minor);         } else {             return new Pair<>(0, 0);         }     }      // Copied from cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java     public static int compareMajorMinorVersion(final String s1, final String s2) {         final Pair<Integer, Integer> v1 = getVersionFromString(s1);         final Pair<Integer, Integer> v2 = getVersionFromString(s2);          if (v1.first == v2.first) {             return Integer.compare(v1.second, v2.second);         } else {             return Integer.compare(v1.first, v2.first);         }     }      // This test requires updates to hid-sony.c that are only available for     // kernels 3.18+. Skip this test for kernels older than 3.18 because it is     // too difficult to backport these changes to those older kernels.     private static boolean isDualshock4DriverSupportedByKernel() {         final String kVersionString = VintfRuntimeInfo.getKernelVersion();         return compareMajorMinorVersion(kVersionString, ""3.18"") >= 0;     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.SimpleSaveActivityTest"	"testTapHomeWhileDatasetPickerUiIsShowing"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/SimpleSaveActivityTest.java"	""	"public void testTapHomeWhileDatasetPickerUiIsShowing() throws Exception {         startActivity();         enableService();         final MyAutofillCallback callback = mActivity.registerCallback();          // Set expectations.         sReplier.addResponse(new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_INPUT, ""id"")                         .setField(ID_PASSWORD, ""pass"")                         .setPresentation(createPresentation(""YO""))                         .build())                 .build());          // Trigger autofill.         mUiBot.assertShownByRelativeId(ID_INPUT).click();         sReplier.getNextFillRequest();         mUiBot.assertDatasets(""YO"");         callback.assertUiShownEvent(mActivity.mInput);          // Go home, you are drunk!         mUiBot.pressHome();         mUiBot.assertNoDatasets();         callback.assertUiHiddenEvent(mActivity.mInput);          // Set expectations.         sReplier.addResponse(new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_INPUT, ""id"")                         .setField(ID_PASSWORD, ""pass"")                         .setPresentation(createPresentation(""YO2""))                         .build())                 .build());          // Switch back to the activity.         restartActivity();         mUiBot.assertShownByText(TEXT_LABEL, Timeouts.ACTIVITY_RESURRECTION);         sReplier.getNextFillRequest();         final UiObject2 datasetPicker = mUiBot.assertDatasets(""YO2"");         callback.assertUiShownEvent(mActivity.mInput);          // Now autofill it.         final FillExpectation autofillExpecation = mActivity.expectAutoFill(""id"", ""pass"");         mUiBot.selectDataset(datasetPicker, ""YO2"");         autofillExpecation.assertAutoFilled();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.SimpleSaveActivityTest"	"testTapUrlSpanOnSuccinctDescription_tapBackWithoutFinish"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/SimpleSaveActivityTest.java"	""	"@AppModeFull(reason = ""No real use case for instant mode af service"")     public void testTapUrlSpanOnSuccinctDescription_tapBackWithoutFinish() throws Exception {         saveUiRestoredAfterTappingSpanTest(DescriptionType.SUCCINCT,                 ViewActionActivity.ActivityCustomAction.TAP_BACK_WITHOUT_FINISH);     }      private void saveUiRestoredAfterTappingSpanTest(             DescriptionType type, ViewActionActivity.ActivityCustomAction action) throws Exception {         startActivity();         // Set service.         enableService();          switch (type) {             case SUCCINCT:                 // Set expectations with custom description.                 sReplier.addResponse(new CannedFillResponse.Builder()                         .setRequiredSavableIds(SAVE_DATA_TYPE_GENERIC, ID_INPUT)                         .setSaveDescription(newDescriptionWithUrlSpan(action.toString()))                         .build());                 break;             case CUSTOM:                 // Set expectations with custom description.                 sReplier.addResponse(new CannedFillResponse.Builder()                         .setRequiredSavableIds(SAVE_DATA_TYPE_GENERIC, ID_INPUT)                         .setSaveInfoVisitor((contexts, builder) -> builder                                 .setCustomDescription(                                         newCustomDescriptionWithUrlSpan(action.toString())))                         .build());                 break;             default:                 throw new IllegalArgumentException(""invalid type: "" + type);         }          // Trigger autofill.         mActivity.syncRunOnUiThread(() -> mActivity.mInput.requestFocus());         sReplier.getNextFillRequest();          // Trigger save.         mActivity.syncRunOnUiThread(() -> {             mActivity.mInput.setText(""108"");             mActivity.mCommit.performClick();         });         // Waits for the commit be processed         mUiBot.waitForIdle();          mUiBot.assertSaveShowing(SAVE_DATA_TYPE_GENERIC);          // Tapping URLSpan.         final URLSpan span = mUiBot.findFirstUrlSpanWithText(""Here is URLSpan"");         mActivity.syncRunOnUiThread(() -> span.onClick(/* unused= */ null));         // Waits for the save UI hided         mUiBot.waitForIdle();          mUiBot.assertSaveNotShowing(SAVE_DATA_TYPE_GENERIC);          // .. check activity show up as expected         switch (action) {             case FAST_FORWARD_ANOTHER_ACTIVITY:                 // Show up second activity.                 SecondActivity.assertShowingDefaultMessage(mUiBot);                 break;             case NORMAL_ACTIVITY:             case TAP_BACK_WITHOUT_FINISH:                 // Show up view action handle activity.                 ViewActionActivity.assertShowingDefaultMessage(mUiBot);                 break;             default:                 throw new IllegalArgumentException(""invalid action: "" + action);         }          // ..then go back and save it.         mUiBot.pressBack();         // Waits for all UI processes to complete         mUiBot.waitForIdle();          // Make sure previous activity is back...         mUiBot.assertShownByRelativeId(ID_INPUT);          // ... and tap save.         final UiObject2 newSaveUi = mUiBot.assertSaveShowing(SAVE_DATA_TYPE_GENERIC);         mUiBot.saveForAutofill(newSaveUi, /* yesDoIt= */ true);          final SaveRequest saveRequest = sReplier.getNextSaveRequest();         assertTextAndValue(findNodeByResourceId(saveRequest.structure, ID_INPUT), ""108"");          SecondActivity.finishIt();         ViewActionActivity.finishIt();     }      private CustomDescription newCustomDescriptionWithUrlSpan(String action) {         final RemoteViews presentation = newTemplate();         presentation.setTextViewText(R.id.custom_text, newDescriptionWithUrlSpan(action));         return new CustomDescription.Builder(presentation).build();     }      private CharSequence newDescriptionWithUrlSpan(String action) {         final String url = ""autofillcts:"" + action;         final SpannableString ss = new SpannableString(""Here is URLSpan"");         ss.setSpan(new URLSpan(url),                 /* start= */ 8,  /* end= */ 15, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);         return ss;     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSig"	"CtsContentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallWithIdSig() throws Exception {         installPackage(TEST_APK);         assertTrue(isAppInstalled(TEST_APP_PACKAGE));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSigAndSplit"	"CtsContentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallWithIdSigAndSplit() throws Exception {         File apkfile = new File(createApkPath(TEST_APK));         File splitfile = new File(createApkPath(TEST_APK_SPLIT));         File[] files = new File[]{apkfile, splitfile};         String param = Arrays.stream(files).map(                 file -> file.getName() + "":"" + file.length()).collect(Collectors.joining("" ""));         assertEquals(""Success\n"", executeShellCommand(                 String.format(""pm install-incremental -t -g -S %s %s"",                         (apkfile.length() + splitfile.length()), param),                 files));         assertTrue(isAppInstalled(TEST_APP_PACKAGE));         assertEquals(""base, config.hdpi"", getSplits(TEST_APP_PACKAGE));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSigInvalidLength"	"CtsContentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallWithIdSigInvalidLength() throws Exception {         File file = new File(createApkPath(TEST_APK));         assertTrue(                 executeShellCommand(""pm install-incremental -t -g -S "" + (file.length() - 1),                         new File[]{file}).contains(                         ""Failure""));         assertFalse(isAppInstalled(TEST_APP_PACKAGE));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSigStreamIncompleteData"	"CtsContentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallWithIdSigStreamIncompleteData() throws Exception {         File file = new File(createApkPath(TEST_APK));         long length = file.length();         // Streaming happens in blocks of 1024 bytes, new length will not stream the last block.         long newLength = length - (length % 1024 == 0 ? 1024 : length % 1024);         assertTrue(                 executeShellCommand(""pm install-incremental -t -g -S "" + length,                         new File[]{file}, new long[]{newLength}).contains(                         ""Failure""));         assertFalse(isAppInstalled(TEST_APP_PACKAGE));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSigStreamIncompleteDataForSplit"	"CtsContentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	"public void testInstallWithIdSigStreamIncompleteDataForSplit() throws Exception {         File apkfile = new File(createApkPath(TEST_APK));         File splitfile = new File(createApkPath(TEST_APK_SPLIT));         long splitLength = splitfile.length();         // Don't fully stream the split.         long newSplitLength = splitLength - (splitLength % 1024 == 0 ? 1024 : splitLength % 1024);         File[] files = new File[]{apkfile, splitfile};         String param = Arrays.stream(files).map(                 file -> file.getName() + "":"" + file.length()).collect(Collectors.joining("" ""));         assertTrue(executeShellCommand(                 String.format(""pm install-incremental -t -g -S %s %s"",                         (apkfile.length() + splitfile.length()), param),                 files, new long[]{apkfile.length(), newSplitLength}).contains(                 ""Failure""));         assertFalse(isAppInstalled(TEST_APP_PACKAGE));     }      static class TestDataLoaderService extends DataLoaderService {     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.LoginActivityTest"	"testDatasetPickerPosition"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/LoginActivityTest.java"	""	"public void testDatasetPickerPosition() throws Exception {         final boolean pickerAndViewBoundsMatches = !isAutofillWindowFullScreen(mContext);          // Set service.         enableService();         final MyAutofillCallback callback = mActivity.registerCallback();         final View username = mActivity.getUsername();         final View password = mActivity.getPassword();          // Set expectations.         final CannedFillResponse.Builder builder = new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""dude"", createPresentation(""DUDE""))                         .setField(ID_PASSWORD, ""sweet"", createPresentation(""SWEET""))                         .build());         sReplier.addResponse(builder.build());          // Trigger autofill on username         final Rect usernameBoundaries1 = mUiBot.selectByRelativeId(ID_USERNAME).getVisibleBounds();         sReplier.getNextFillRequest();         callback.assertUiShownEvent(username);         final Rect usernamePickerBoundaries1 = mUiBot.assertDatasets(""DUDE"").getVisibleBounds();         Log.v(TAG,                 ""Username1 at "" + usernameBoundaries1 + ""; picker at "" + usernamePickerBoundaries1);         // TODO(b/37566627): assertions below might be too aggressive - use range instead?         if (pickerAndViewBoundsMatches) {             if (usernamePickerBoundaries1.top < usernameBoundaries1.bottom) {                 assertThat(usernamePickerBoundaries1.bottom).isEqualTo(usernameBoundaries1.top);             } else {                 assertThat(usernamePickerBoundaries1.top).isEqualTo(usernameBoundaries1.bottom);             }              assertThat(usernamePickerBoundaries1.left).isEqualTo(usernameBoundaries1.left);         }          // Move to password         final Rect passwordBoundaries1 = mUiBot.selectByRelativeId(ID_PASSWORD).getVisibleBounds();         callback.assertUiHiddenEvent(username);         callback.assertUiShownEvent(password);         final Rect passwordPickerBoundaries1 = mUiBot.assertDatasets(""SWEET"").getVisibleBounds();         Log.v(TAG,                 ""Password1 at "" + passwordBoundaries1 + ""; picker at "" + passwordPickerBoundaries1);         // TODO(b/37566627): assertions below might be too aggressive - use range instead?         if (pickerAndViewBoundsMatches) {             if (passwordPickerBoundaries1.top < passwordBoundaries1.bottom) {                 assertThat(passwordPickerBoundaries1.bottom).isEqualTo(passwordBoundaries1.top);             } else {                 assertThat(passwordPickerBoundaries1.top).isEqualTo(passwordBoundaries1.bottom);             }             assertThat(passwordPickerBoundaries1.left).isEqualTo(passwordBoundaries1.left);         }          // Then back to username         final Rect usernameBoundaries2 = mUiBot.selectByRelativeId(ID_USERNAME).getVisibleBounds();         callback.assertUiHiddenEvent(password);         callback.assertUiShownEvent(username);         final Rect usernamePickerBoundaries2 = mUiBot.assertDatasets(""DUDE"").getVisibleBounds();         Log.v(TAG,                 ""Username2 at "" + usernameBoundaries2 + ""; picker at "" + usernamePickerBoundaries2);          // And back to the password again..         final Rect passwordBoundaries2 = mUiBot.selectByRelativeId(ID_PASSWORD).getVisibleBounds();         callback.assertUiHiddenEvent(username);         callback.assertUiShownEvent(password);         final Rect passwordPickerBoundaries2 = mUiBot.assertDatasets(""SWEET"").getVisibleBounds();         Log.v(TAG,                 ""Password2 at "" + passwordBoundaries2 + ""; picker at "" + passwordPickerBoundaries2);          // Assert final state matches initial...         // ... for username         assertWithMessage(""Username2 at %s; Username1 at %s"", usernameBoundaries2,                 usernamePickerBoundaries1).that(usernameBoundaries2).isEqualTo(usernameBoundaries1);         assertWithMessage(""Username2 picker at %s; Username1 picker at %s"",                 usernamePickerBoundaries2, usernamePickerBoundaries1).that(                 usernamePickerBoundaries2).isEqualTo(usernamePickerBoundaries1);          // ... for password         assertWithMessage(""Password2 at %s; Password1 at %s"", passwordBoundaries2,                 passwordBoundaries1).that(passwordBoundaries2).isEqualTo(passwordBoundaries1);         assertWithMessage(""Password2 picker at %s; Password1 picker at %s"",                 passwordPickerBoundaries2, passwordPickerBoundaries1).that(                 passwordPickerBoundaries2).isEqualTo(passwordPickerBoundaries1);          // Final sanity check         callback.assertNumberUnhandledEvents(0);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.LoginActivityTest"	"testAutofillTapOutside"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/LoginActivityTest.java"	""	"public void testAutofillTapOutside() throws Exception {         // Set service.         enableService();         final MyAutofillCallback callback = mActivity.registerCallback();          // Set expectations.         sReplier.addResponse(new CannedDataset.Builder()                 .setField(ID_USERNAME, ""dude"")                 .setField(ID_PASSWORD, ""sweet"")                 .setPresentation(createPresentation(""The Dude""))                 .build());         mActivity.expectAutoFill(""dude"", ""sweet"");          // Trigger autofill.         requestFocusOnUsername();         sReplier.getNextFillRequest();         final View username = mActivity.getUsername();          callback.assertUiShownEvent(username);         mUiBot.assertDatasets(""The Dude"");          // tapping outside autofill window should close it and raise ui hidden event         mUiBot.waitForWindowChange(() -> tap(mActivity.getUsernameLabel()));         callback.assertUiHiddenEvent(username);          mUiBot.assertNoDatasets();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.LoginActivityTest"	"testAutofillCallbacks"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/LoginActivityTest.java"	""	"public void testAutofillCallbacks() throws Exception {         // Set service.         enableService();         final MyAutofillCallback callback = mActivity.registerCallback();          // Set expectations.         sReplier.addResponse(new CannedDataset.Builder()                 .setField(ID_USERNAME, ""dude"")                 .setField(ID_PASSWORD, ""sweet"")                 .setPresentation(createPresentation(""The Dude""))                 .build());         mActivity.expectAutoFill(""dude"", ""sweet"");          // Trigger autofill.         requestFocusOnUsername();         sReplier.getNextFillRequest();         final View username = mActivity.getUsername();         final View password = mActivity.getPassword();          callback.assertUiShownEvent(username);          requestFocusOnPassword();         callback.assertUiHiddenEvent(username);         callback.assertUiShownEvent(password);          // Unregister callback to make sure no more events are received         mActivity.unregisterCallback();         requestFocusOnUsername();         // Blindly sleep - we cannot wait on any event as none should have been sent         SystemClock.sleep(MyAutofillCallback.MY_TIMEOUT.ms());         callback.assertNumberUnhandledEvents(0);          // Autofill it.         mUiBot.selectDataset(""The Dude"");          // Check the results.         mActivity.assertAutoFilled();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.LoginActivityTest"	"testAutoFillOneDatasetAndSaveHidingOverlays"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/LoginActivityTest.java"	""	"public void testAutoFillOneDatasetAndSaveHidingOverlays() throws Exception {         // Set service.         enableService();          // Set expectations.         final Bundle extras = new Bundle();         extras.putString(""numbers"", ""4815162342"");          sReplier.addResponse(new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""dude"")                         .setField(ID_PASSWORD, ""sweet"")                         .setPresentation(createPresentation(""The Dude""))                         .build())                 .setRequiredSavableIds(SAVE_DATA_TYPE_PASSWORD, ID_USERNAME, ID_PASSWORD)                 .setExtras(extras)                 .build());         mActivity.expectAutoFill(""dude"", ""sweet"");          // Trigger auto-fill.         requestFocusOnUsername();          // Since this is a Presubmit test, wait for connection to avoid flakiness.         waitUntilConnected();          sReplier.getNextFillRequest();          // Add an overlay on top of the whole screen         final View[] overlay = new View[1];         try {             // Allow ourselves to add overlays             allowOverlays();              // Make sure the fill UI is shown.             mUiBot.assertDatasets(""The Dude"");              final CountDownLatch latch = new CountDownLatch(1);              mActivity.runOnUiThread(() -> {                 // This overlay is focusable, full-screen, which should block interaction                 // with the fill UI unless the platform successfully hides overlays.                 final WindowManager.LayoutParams params = new WindowManager.LayoutParams();                 params.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;                 params.flags = WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;                 params.width = ViewGroup.LayoutParams.MATCH_PARENT;                 params.height = ViewGroup.LayoutParams.MATCH_PARENT;                  final View view = new View(mContext) {                     @Override                     protected void onAttachedToWindow() {                         super.onAttachedToWindow();                         latch.countDown();                     }                 };                 view.setBackgroundColor(Color.RED);                 WindowManager windowManager = mContext.getSystemService(WindowManager.class);                 windowManager.addView(view, params);                 overlay[0] = view;             });              // Wait for the window being added.             assertThat(latch.await(5, TimeUnit.SECONDS)).isTrue();              // Auto-fill it.             mUiBot.selectDataset(""The Dude"");              // Check the results.             mActivity.assertAutoFilled();              // Try to login, it will fail.             final String loginMessage = mActivity.tapLogin();              assertWithMessage(""Wrong login msg"").that(loginMessage).isEqualTo(                     AUTHENTICATION_MESSAGE);              // Set right password...             mActivity.onPassword((v) -> v.setText(""dude""));              // ... and try again             final String expectedMessage = getWelcomeMessage(""dude"");             final String actualMessage = mActivity.tapLogin();             assertWithMessage(""Wrong welcome msg"").that(actualMessage).isEqualTo(expectedMessage);              // Assert the snack bar is shown and tap ""Save"".             mUiBot.updateForAutofill(true, SAVE_DATA_TYPE_PASSWORD);              final SaveRequest saveRequest = sReplier.getNextSaveRequest();              // Assert value of expected fields - should not be sanitized.             final ViewNode username = findNodeByResourceId(saveRequest.structure, ID_USERNAME);             assertTextAndValue(username, ""dude"");             final ViewNode password = findNodeByResourceId(saveRequest.structure, ID_PASSWORD);             assertTextAndValue(password, ""dude"");              // Make sure extras were passed back on onSave()             assertThat(saveRequest.data).isNotNull();             final String extraValue = saveRequest.data.getString(""numbers"");             assertWithMessage(""extras not passed on save"").that(extraValue).isEqualTo(""4815162342"");         } finally {             try {                 // Make sure we can no longer add overlays                 disallowOverlays();                 // Make sure the overlay is removed                 mActivity.runOnUiThread(() -> {                     WindowManager windowManager = mContext.getSystemService(WindowManager.class);                     windowManager.removeView(overlay[0]);                 });             } catch (Exception e) {                 mSafeCleanerRule.add(e);             }         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.LoginActivityTest"	"testCommitMultipleTimes"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/LoginActivityTest.java"	""	"public void testCommitMultipleTimes() throws Throwable {         // Set service.         enableService();          final CannedFillResponse response = new CannedFillResponse.Builder()                 .setRequiredSavableIds(SAVE_DATA_TYPE_PASSWORD, ID_USERNAME, ID_PASSWORD)                 .build();          for (int i = 1; i <= 10; i++) {             Log.i(TAG, ""testCommitMultipleTimes(): step "" + i);             final String username = ""user-"" + i;             final String password = ""pass-"" + i;             try {                 // Set expectations.                 sReplier.addResponse(response);                  Timeouts.IDLE_UNBIND_TIMEOUT.run(""wait for session created"", () -> {                     // Trigger auto-fill.                     mActivity.onUsername(View::clearFocus);                     mActivity.onUsername(View::requestFocus);                      return isConnected() ? ""not_used"" : null;                 });                  sReplier.getNextFillRequest();                  // Sanity check.                 mUiBot.assertNoDatasetsEver();                  // Set credentials...                 mActivity.onUsername((v) -> v.setText(username));                 mActivity.onPassword((v) -> v.setText(password));                  // Change focus to prepare for next step - must do it before session is gone                 mActivity.onPassword(View::requestFocus);                  // ...and save them                 mActivity.tapSave();                  // Assert the snack bar is shown and tap ""Save"".                 mUiBot.saveForAutofill(true, SAVE_DATA_TYPE_PASSWORD);                  final SaveRequest saveRequest = sReplier.getNextSaveRequest();                  // Assert value of expected fields - should not be sanitized.                 final ViewNode usernameNode = findNodeByResourceId(saveRequest.structure,                         ID_USERNAME);                 assertTextAndValue(usernameNode, username);                 final ViewNode passwordNode = findNodeByResourceId(saveRequest.structure,                         ID_PASSWORD);                 assertTextAndValue(passwordNode, password);                  waitUntilDisconnected();                  // Wait and check if the save window is correctly hidden.                 mUiBot.assertSaveNotShowing(SAVE_DATA_TYPE_PASSWORD);             } catch (RetryableException e) {                 throw new RetryableException(e, ""on step %d"", i);             } catch (Throwable t) {                 throw new Throwable(""Error on step "" + i, t);             }         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.net.wifi.nl80211.cts.PnoNetworkTest"	"testGetters"	"CtsWifiTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/PnoNetworkTest.java"	""	"public void testGetters() {         PnoNetwork network = new PnoNetwork();         network.setSsid(TEST_SSID);         network.setFrequenciesMhz(TEST_FREQUENCIES);         network.setHidden(true);          assertThat(network.getSsid()).isEqualTo(TEST_SSID);         assertThat(network.getFrequenciesMhz()).isEqualTo(TEST_FREQUENCIES);         assertThat(network.isHidden()).isTrue();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.net.wifi.nl80211.cts.PnoNetworkTest"	"isHidden"	"CtsWifiTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/PnoNetworkTest.java"	""	"public void canSerializeAndDeserialize() {         PnoNetwork network = new PnoNetwork();         network.setSsid(TEST_SSID);         network.setFrequenciesMhz(TEST_FREQUENCIES);         network.setHidden(true);          Parcel parcel = Parcel.obtain();         network.writeToParcel(parcel, 0);         // Rewind the pointer to the head of the parcel.         parcel.setDataPosition(0);         PnoNetwork networkDeserialized = PnoNetwork.CREATOR.createFromParcel(parcel);          assertThat(networkDeserialized.getSsid()).isEqualTo(TEST_SSID);         assertThat(networkDeserialized.getFrequenciesMhz()).isEqualTo(TEST_FREQUENCIES);         assertThat(networkDeserialized.isHidden()).isTrue();         assertThat(networkDeserialized).isEqualTo(network);         assertThat(networkDeserialized.hashCode()).isEqualTo(network.hashCode());     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.net.wifi.nl80211.cts.PnoNetworkTest"	"testEquals"	"CtsWifiTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/PnoNetworkTest.java"	""	"public void testEquals() {         PnoNetwork network = new PnoNetwork();         network.setSsid(TEST_SSID);         network.setFrequenciesMhz(TEST_FREQUENCIES);         network.setHidden(true);          PnoNetwork network2 = new PnoNetwork();         network.setSsid(new byte[] { 'a', 's', 'd', 'f'});         network.setFrequenciesMhz(new int[] { 1, 2, 3 });         network.setHidden(false);          assertThat(network2).isNotEqualTo(network);     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.provider.cts.contacts.ContactsContract_AllUriTest"	"testNoHiddenColumns"	"CtsContactsProviderTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/contactsprovider/src/android/provider/cts/contacts/ContactsContract_AllUriTest.java"	""	"public void testNoHiddenColumns() {         for (String[] path : URIs) {             if (!supportsQuery(path)) continue;             final Uri uri = getUri(path);              for (String column : getColumns(uri)) {                 if (column.toLowerCase().startsWith(ContactsContract.HIDDEN_COLUMN_PREFIX)) {                     addFailure(""Uri "" + uri + "" returned hidden column "" + column, null);                 }             }         }         failIfFailed();     }  // Temporarily disabled due to taking too much time. //    /** //     * Make sure all URLs are accessible with a projection. //     */ //"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.os.cts.EnvironmentTest"	"testNoAtime"	"CtsOsHostTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/EnvironmentTest.java"	""	"public void testNoAtime() throws Exception {         try (BufferedReader br = new BufferedReader(new FileReader(""/proc/mounts""))) {             String line;             while ((line = br.readLine()) != null) {                 final String[] fields = line.split("" "");                 final String source = fields[0];                 final String options = fields[3];                  if (source.startsWith(""/dev/block/"") && !options.startsWith(""ro,"")                         && !options.contains(""noatime"")) {                     fail(""Found device mounted at "" + source + "" without 'noatime' option, ""                             + ""which can cause unnecessary flash churn; please update your fstab."");                 }             }         }     }      /**      * verify hidepid=2 on /proc      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.os.cts.EnvironmentTest"	"testHidePid2"	"CtsOsHostTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/EnvironmentTest.java"	""	"public void testHidePid2() throws Exception {         try (BufferedReader br = new BufferedReader(new FileReader(""/proc/mounts""))) {             String line;             while ((line = br.readLine()) != null) {                 final String[] fields = line.split("" "");                 final String source = fields[0];                 final String options = fields[3];                  if (source.equals(""proc"") && !options.contains(""hidepid=2"")) {                     fail(""proc filesystem mounted without hidepid=2"");                 }             }         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.os.cts.EnvironmentTest"	"testHidePid2_direct"	"CtsOsHostTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/EnvironmentTest.java"	""	"public void testHidePid2_direct() throws Exception {         assertFalse(new File(""/proc/1"").exists());     }      /**      * Verify that all writable block filesystems are mounted with ""resgid"" to      * mitigate disk-full trouble.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.mediav2.cts.MuxerUnitTest"	"TestName"	"CtsMediaTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/media/src/android/mediav2/cts/MuxerUnitTest.java"	""	"/*  *.  */  package android.mediav2.cts;  import android.media.MediaCodec; import android.media.MediaFormat; import android.media.MediaMuxer;  import androidx.test.filters.SmallTest;  import org.junit.After; import org.junit.Before; import org.junit.Ignore; import org.junit.Rule; import org.junit.Test; import org.junit.experimental.runners.Enclosed; import org.junit.rules.TestName; import org.junit.runner.RunWith;  import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.nio.ByteBuffer; import java.nio.charset.StandardCharsets;  import static android.system.Os.pipe; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  /**  * Tests MediaMuxer API that are independent of MediaMuxer.OutputFormat. Constructors,  * addTrack, start, writeSampleData, stop, release are independent of OutputFormat selected.  * Legality of these APIs are tested in this class.  */ @RunWith(Enclosed.class) public class MuxerUnitTest {     // duplicate definitions of hide fields of MediaMuxer.OutputFormat.     private static final int MUXER_OUTPUT_LAST = MediaMuxer.OutputFormat.MUXER_OUTPUT_OGG;      @SmallTest     public static class TestApi {         @Rule         public TestName testName = new TestName();          @Before         public void prologue() throws IOException {             mOutMedia = File.createTempFile(testName.getMethodName(), "".out"");             mOutLoc = mOutMedia.getAbsolutePath();         }          @After         public void epilogue() {             new File(mOutLoc).delete();         }          private File mOutMedia;         private String mOutLoc;          // Insert one frame SubRip         static private void insertPerFrameSubtitles(MediaMuxer muxer, long presentationTimeUs,                 int trackID) {             byte[] greeting = ""hello world"".getBytes(StandardCharsets.UTF_8);             ByteBuffer metaBuff = ByteBuffer.allocate(greeting.length);             metaBuff.put(greeting);             MediaCodec.BufferInfo metaInfo = new MediaCodec.BufferInfo();             metaInfo.offset = 0;             metaInfo.size = greeting.length;             metaInfo.presentationTimeUs = presentationTimeUs;             metaInfo.flags = 0;             muxer.writeSampleData(trackID, metaBuff, metaInfo);         }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ZoomControlsTest"	"testShowAndHide"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ZoomControlsTest.java"	""	"public void testShowAndHide() {         final ZoomControls zoomControls = new ZoomControls(mContext);         assertEquals(View.VISIBLE, zoomControls.getVisibility());          zoomControls.hide();         assertEquals(View.GONE, zoomControls.getVisibility());          zoomControls.show();         assertEquals(View.VISIBLE, zoomControls.getVisibility());     }      @UiThreadTest"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.SystemFeaturesTest"	"testTouchScreenFeatures"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"faketouch"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.SystemFeaturesTest"	"testFakeTouchFeatures"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"faketouch"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.SystemFeaturesTest"	"testTouchScreenFeatures"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"android.hardware.faketouch"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.SystemFeaturesTest"	"testFakeTouchFeatures"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"android.hardware.faketouch"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.NotificationManagerTest"	"testShouldHideSilentStatusIcons"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	"public void testShouldHideSilentStatusIcons() throws Exception {         try {             mNotificationManager.shouldHideSilentStatusBarIcons();             fail(""Non-privileged apps should not get this information"");         } catch (SecurityException e) {             // pass         }          toggleListenerAccess(TestNotificationListener.getId(),                 InstrumentationRegistry.getInstrumentation(), true);         // no exception this time         mNotificationManager.shouldHideSilentStatusBarIcons();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerSpoofingTest"	"testSpoofingPublisher"	"CtsShortcutManagerTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerSpoofingTest.java"	""	"public void testSpoofingPublisher() {         runWithCaller(mPackageContext1, () -> {             ShortcutInfo s1 = makeShortcut(""s1"", ""title1"");             getManager().setDynamicShortcuts(list(s1));         });         runWithCaller(mPackageContext2, () -> {             ShortcutInfo s1 = makeShortcut(""s1"", ""title2"");             getManager().setDynamicShortcuts(list(s1));         });         runWithCaller(mPackageContext3, () -> {             ShortcutInfo s1 = makeShortcut(""s1"", ""title3"");             getManager().setDynamicShortcuts(list(s1));         });          runWithCaller(mPackageContext1, () -> {             assertWith(getManager().getDynamicShortcuts())                     .haveIds(""s1"")                     .forShortcutWithId(""s1"", s -> {                         assertEquals(""title1"", s.getShortLabel());                     });         });         runWithCaller(mPackageContext2, () -> {             assertWith(getManager().getDynamicShortcuts())                     .haveIds(""s1"")                     .forShortcutWithId(""s1"", s -> {                         assertEquals(""title2"", s.getShortLabel());                     });         });         runWithCaller(mPackageContext3, () -> {             assertWith(getManager().getDynamicShortcuts())                     .haveIds(""s1"")                     .forShortcutWithId(""s1"", s -> {                         assertEquals(""title3"", s.getShortLabel());                     });         });     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"beforeAllTests"	"CtsTelephonyTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"/*  *.  */  package android.telephony.ims.cts;  import static junit.framework.TestCase.assertEquals;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.database.ContentObserver; import android.net.Uri; import android.os.Handler; import android.os.Looper; import android.os.PersistableBundle; import android.telephony.AccessNetworkConstants; import android.telephony.CarrierConfigManager; import android.telephony.SubscriptionManager; import android.telephony.ims.ImsException; import android.telephony.ims.ImsManager; import android.telephony.ims.ImsMmTelManager; import android.telephony.ims.feature.MmTelFeature;  import androidx.test.ext.junit.runners.AndroidJUnit4; import androidx.test.platform.app.InstrumentationRegistry;  import com.android.compatibility.common.util.ShellIdentityUtils;  import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.concurrent.CountDownLatch; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.TimeUnit;  @RunWith(AndroidJUnit4.class) public class ImsMmTelManagerTest {      // Copied from CarrierConfigManager, since these keys is inappropriately marked as @hide     private static final String KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL =             ""carrier_volte_override_wfc_provisioning_bool"";     private static final String KEY_EDITABLE_WFC_MODE_BOOL = ""editable_wfc_mode_bool"";     private static final String KEY_USE_WFC_HOME_NETWORK_MODE_IN_ROAMING_NETWORK_BOOL =             ""use_wfc_home_network_mode_in_roaming_network_bool"";     private static final String KEY_EDITABLE_WFC_ROAMING_MODE_BOOL =             ""editable_wfc_roaming_mode_bool"";      private static int sTestSub = SubscriptionManager.INVALID_SUBSCRIPTION_ID;     private static Handler sHandler;     private static CarrierConfigReceiver sReceiver;      private static class CarrierConfigReceiver extends BroadcastReceiver {         private CountDownLatch mLatch = new CountDownLatch(1);         private final int mSubId;          CarrierConfigReceiver(int subId) {             mSubId = subId;         }          @Override         public void onReceive(Context context, Intent intent) {             if (CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(intent.getAction())) {                 int subId = intent.getIntExtra(CarrierConfigManager.EXTRA_SUBSCRIPTION_INDEX, -1);                 if (mSubId == subId) {                     mLatch.countDown();                 }             }         }          void clearQueue() {             mLatch = new CountDownLatch(1);         }          void waitForCarrierConfigChanged() throws Exception {             mLatch.await(5000, TimeUnit.MILLISECONDS);         }     }      @BeforeClass     public static void beforeAllTests() {         // assumeTrue() in @BeforeClass is not supported by our test runner.         // Resort to the early exit.         if (!ImsUtils.shouldTestImsService()) {             return;         }          sTestSub = ImsUtils.getPreferredActiveSubId();          if (Looper.getMainLooper() == null) {             Looper.prepareMainLooper();         }         sHandler = new Handler(Looper.getMainLooper());          sReceiver = new CarrierConfigReceiver(sTestSub);         IntentFilter filter = new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);         // ACTION_CARRIER_CONFIG_CHANGED is sticky, so we will get a callback right away.         getContext().registerReceiver(sReceiver, filter);     }      @AfterClass     public static void afterAllTests() {         // assumeTrue() in @AfterClass is not supported by our test runner.         // Resort to the early exit.         if (!ImsUtils.shouldTestImsService()) {             return;         }          if (sReceiver != null) {             getContext().unregisterReceiver(sReceiver);             sReceiver = null;         }     }      @Before     public void beforeTest() {         assumeTrue(ImsUtils.shouldTestImsService());          if (!SubscriptionManager.isValidSubscriptionId(sTestSub)) {             fail(""This test requires that there is a SIM in the device!"");         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testGetVoWiFiSetting_noPermission"	"CtsTelephonyTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testGetVoWiFiSetting_noPermission() {         try {             ImsManager imsManager = getContext().getSystemService(ImsManager.class);             ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);             boolean isEnabled = mMmTelManager.isVoWiFiSettingEnabled();             fail(""Expected SecurityException for missing permissions"");         } catch (SecurityException ex) {             /* Expected */         }     }      /**      * Given the advanced calling setting is editable and not hidden      * (see {@link CarrierConfigManager#KEY_EDITABLE_ENHANCED_4G_LTE_BOOL}, and      * {@link CarrierConfigManager#KEY_HIDE_ENHANCED_4G_LTE_BOOL}), set the advanced      * calling setting and ensure the correct calling setting is returned. Also ensure the      * ContentObserver is triggered properly.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testAdvancedCallingSetting"	"CtsTelephonyTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	"public void testAdvancedCallingSetting() throws Exception {         // Ensure advanced calling setting is editable.         PersistableBundle bundle = new PersistableBundle();         bundle.putBoolean(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL, true);         bundle.putBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL, false);         overrideCarrierConfig(bundle);         // Register Observer         Uri callingUri = Uri.withAppendedPath(                 SubscriptionManager.ADVANCED_CALLING_ENABLED_CONTENT_URI, """" + sTestSub);         CountDownLatch contentObservedLatch = new CountDownLatch(1);         ContentObserver observer = createObserver(callingUri, contentObservedLatch);          ImsManager imsManager = getContext().getSystemService(ImsManager.class);         ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);         boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,                 ImsMmTelManager::isAdvancedCallingSettingEnabled);         ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,                 (m) -> m.setAdvancedCallingSettingEnabled(!isEnabled));          waitForLatch(contentObservedLatch, observer);         boolean isEnabledResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,                 ImsMmTelManager::isAdvancedCallingSettingEnabled);         assertEquals(""isAdvancedCallingSettingEnabled does not reflect the new value set by ""                         + ""setAdvancedCallingSettingEnabled"", !isEnabled, isEnabledResult);          // Set back to default         ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,                 (m) -> m.setAdvancedCallingSettingEnabled(isEnabled));         // restore original carrier config.         overrideCarrierConfig(null);     }      /**      * Set the VT setting and ensure it is queried successfully. Also ensure the ContentObserver      * is triggered properly.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.documentclient.ScopedDirectoryAccessClientTest"	"testInvalidPath"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/test-apps/DocumentClient/src/com/android/cts/documentclient/ScopedDirectoryAccessClientTest.java"	""	"public void testInvalidPath() {         if (!supportedHardwareForScopedDirectoryAccess()) return;          for (StorageVolume volume : getVolumes()) {             openExternalDirectoryInvalidPath(volume, """");             openExternalDirectoryInvalidPath(volume, ""/dev/null"");             openExternalDirectoryInvalidPath(volume, ""/../"");             openExternalDirectoryInvalidPath(volume, ""/HiddenStuff"");         }         openExternalDirectoryInvalidPath(getPrimaryVolume(), DIRECTORY_ROOT);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.lifecycle.ActivityLifecycleTests"	"testOnNewIntentFromHidden"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleTests.java"	""	"public void testOnNewIntentFromHidden() throws Exception {         // Launch a singleTop activity         final Activity singleTopActivity = launchActivityAndWait(SingleTopActivity.class);         LifecycleVerifier.assertLaunchSequence(SingleTopActivity.class, getLifecycleLog());          // Launch something on top         final Activity secondActivity = new Launcher(SecondActivity.class)                 .setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK)                 .setOptions(getLaunchOptionsForFullscreen())                 .launch();          waitAndAssertActivityStates(state(singleTopActivity, ON_STOP));          // Try to launch again         getLifecycleLog().clear();         new Launcher(SingleTopActivity.class)                 .setFlags(FLAG_ACTIVITY_NEW_TASK)                 .setNoInstance()                 .launch();          // Verify that the first activity was restarted, new intent was delivered and resumed again         final List<LifecycleLog.ActivityCallback> expectedSequence;         if (isTranslucent(singleTopActivity)) {             expectedSequence = Arrays.asList(ON_NEW_INTENT, ON_RESUME, ON_TOP_POSITION_GAINED);         } else {             expectedSequence = Arrays.asList(ON_RESTART, ON_START, ON_NEW_INTENT, ON_RESUME,                     ON_TOP_POSITION_GAINED);         }         LifecycleVerifier.assertSequence(SingleTopActivity.class, getLifecycleLog(),                 expectedSequence, ""newIntent"");     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.admin.cts.DevicePolicyManagerTest"	"testSetApplicationHidden_failIfNotDeviceOrProfileOwner"	"CtsAdminTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testSetApplicationHidden_failIfNotDeviceOrProfileOwner() {         if (!mDeviceAdmin) {             Log.w(TAG, ""Skipping testSetApplicationHidden_failIfNotDeviceOrProfileOwner"");             return;         }         try {             mDevicePolicyManager.setApplicationHidden(mComponent, ""com.google.anything"", true);             fail(""did not throw expected SecurityException"");         } catch (SecurityException e) {             assertProfileOwnerMessage(e.getMessage());         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.admin.cts.DevicePolicyManagerTest"	"testIsApplicationHidden_failIfNotDeviceOrProfileOwner"	"CtsAdminTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testIsApplicationHidden_failIfNotDeviceOrProfileOwner() {         if (!mDeviceAdmin) {             Log.w(TAG, ""Skipping testIsApplicationHidden_failIfNotDeviceOrProfileOwner"");             return;         }         try {             mDevicePolicyManager.isApplicationHidden(mComponent, ""com.google.anything"");             fail(""did not throw expected SecurityException"");         } catch (SecurityException e) {             assertProfileOwnerMessage(e.getMessage());         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.delegate.PackageAccessDelegateTest"	"testCannotAccessApis"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/PackageAccessDelegateTest.java"	""	"public void testCannotAccessApis() throws NameNotFoundException {         assertFalse(""DelegateApp should not be a package access delegate"",             amIPackageAccessDelegate());          // Exercise isApplicationHidden.         assertExpectException(SecurityException.class,                 ""Caller with uid \\d+ is not a delegate of scope"", () -> {                     mDpm.isApplicationHidden(null, TEST_APP_PKG);                 });          // Exercise setApplicationHidden.         assertExpectException(SecurityException.class,                 ""Caller with uid \\d+ is not a delegate of scope"", () -> {                     mDpm.setApplicationHidden(null, TEST_APP_PKG, true /* hide */);                 });          // Exercise isPackageSuspended.         assertExpectException(SecurityException.class,                 ""Caller with uid \\d+ is not a delegate of scope"", () -> {                     mDpm.isPackageSuspended(null, TEST_APP_PKG);                 });          // Exercise setPackagesSuspended.         assertExpectException(SecurityException.class,                 ""Caller with uid \\d+ is not a delegate of scope"", () -> {                     mDpm.setPackagesSuspended(null, new String[] {TEST_APP_PKG}, true /* suspend */);                 });     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.delegate.PackageAccessDelegateTest"	"testCanAccessApis"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/PackageAccessDelegateTest.java"	""	"public void testCanAccessApis() throws NameNotFoundException {         assertTrue(""DelegateApp is not a package access delegate"", amIPackageAccessDelegate());          // Exercise isApplicationHidden.         assertFalse(""Package should not be hidden"", mDpm.isApplicationHidden(null, TEST_APP_PKG));          // Exercise setApplicationHidden.         assertTrue(""Package not hidden successfully"",                 mDpm.setApplicationHidden(null, TEST_APP_PKG, true /* hide */));         assertTrue(""Package should be hidden"", mDpm.isApplicationHidden(null, TEST_APP_PKG));          // Exercise isPackageSuspended.         assertFalse(""Package should not be suspended"", mDpm.isPackageSuspended(null, TEST_APP_PKG));          // Exercise setPackagesSuspended.         String[] suspended = mDpm.setPackagesSuspended(null, new String[] {TEST_APP_PKG},                 true /* suspend */);         assertTrue(""Package not suspended successfully"", suspended.length == 0);         assertTrue(""Package should be suspended"", mDpm.isPackageSuspended(null, TEST_APP_PKG));     }      private boolean amIPackageAccessDelegate() {         final String packageName = getInstrumentation().getContext().getPackageName();         final List<String> scopes = mDpm.getDelegatedScopes(null, packageName);         return scopes.contains(DELEGATION_PACKAGE_ACCESS);     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.cts.ViewConfigurationTest"	"testStaticValues"	"CtsViewTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/ViewConfigurationTest.java"	""	"public void testStaticValues() {         ViewConfiguration.getScrollBarSize();         ViewConfiguration.getFadingEdgeLength();         ViewConfiguration.getPressedStateDuration();         ViewConfiguration.getLongPressTimeout();         ViewConfiguration.getTapTimeout();         ViewConfiguration.getJumpTapTimeout();         ViewConfiguration.getEdgeSlop();         ViewConfiguration.getTouchSlop();         ViewConfiguration.getWindowTouchSlop();         ViewConfiguration.getMinimumFlingVelocity();         ViewConfiguration.getMaximumFlingVelocity();         ViewConfiguration.getMaximumDrawingCacheSize();         ViewConfiguration.getZoomControlsTimeout();         ViewConfiguration.getGlobalActionKeyTimeout();         ViewConfiguration.getScrollFriction();         ViewConfiguration.getScrollBarFadeDuration();         ViewConfiguration.getScrollDefaultDelay();         ViewConfiguration.getDoubleTapTimeout();         ViewConfiguration.getKeyRepeatTimeout();         ViewConfiguration.getKeyRepeatDelay();         ViewConfiguration.getDefaultActionModeHideDuration();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.DialogTest"	"testShow"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	"public void testShow() throws Throwable {         startDialogActivity(DialogStubActivity.TEST_DIALOG_WITHOUT_THEME);         final Dialog d = mActivity.getDialog();         final View decor = d.getWindow().getDecorView();          mScenario.onActivity(activity -> {             d.hide();         });         mInstrumentation.waitForIdleSync();          assertEquals(View.GONE, decor.getVisibility());         assertFalse(d.isShowing());          mScenario.onActivity(activity -> {                 d.show();         });         mInstrumentation.waitForIdleSync();          assertEquals(View.VISIBLE, decor.getVisibility());         assertTrue(d.isShowing());         dialogDismiss(d);         assertFalse(d.isShowing());     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.inline.InlineAuthenticationTest"	"testDatasetAuthFilteringUsingRegex"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/InlineAuthenticationTest.java"	""	"public void testDatasetAuthFilteringUsingRegex() throws Exception {         // Set service.         enableService();          // Create the authentication intents         final CannedDataset unlockedDataset = new CannedDataset.Builder()                 .setField(ID_USERNAME, ""dude"")                 .setField(ID_PASSWORD, ""sweet"")                 .build();         final IntentSender authentication = AuthenticationActivity.createSender(mContext, 1,                 unlockedDataset);         final Pattern min2Chars = Pattern.compile("".{2,}"");         sReplier.addResponse(new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, UNUSED_AUTOFILL_VALUE, min2Chars)                         .setField(ID_PASSWORD, UNUSED_AUTOFILL_VALUE)                         .setPresentation(createPresentation(""auth""))                         .setInlinePresentation(createInlinePresentation(""auth""))                         .setAuthentication(authentication)                         .build())                 .build());         // Set expectation for the activity         mActivity.expectAutoFill(""dude"", ""sweet"");          // Trigger auto-fill, make sure it's showing initially.         assertSuggestionShownBySelectViewId(ID_USERNAME, ""auth"");         sReplier.getNextFillRequest();          // ...then type something to hide it.         mActivity.onUsername((v) -> v.setText(""a""));         // Suggestion strip was not shown.         mUiBot.assertNoDatasetsEver();         mUiBot.waitForIdle();          // ...now type something again to show it, as the input will have 2 chars.         mActivity.onUsername((v) -> v.setText(""aa""));         mUiBot.waitForIdle();         mUiBot.assertDatasets(""auth"");          // ...and select it         mUiBot.selectDataset(""auth"");         mUiBot.waitForIdle();         mUiBot.assertNoDatasets();          // Check the results.         mActivity.assertAutoFilled();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.PartitionedActivityTest"	"testSaveOneSaveInfoOnFirstPartitionWithIdsOnSecond"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/PartitionedActivityTest.java"	""	"public void testSaveOneSaveInfoOnFirstPartitionWithIdsOnSecond() throws Exception {         // Set service.         enableService();          // Trigger 1st partition.         final CannedFillResponse response1 = new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_L1C1, ""l1c1"", createPresentation(""l1c1""))                         .setField(ID_L1C2, ""l1c2"", createPresentation(""l1c2""))                         .build())                 .build();         sReplier.addResponse(response1);         focusCell(1, 1);         sReplier.getNextFillRequest();          // Trigger 2nd partition.         final CannedFillResponse response2 = new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_L2C1, ""l2c1"", createPresentation(""l2c1""))                         .setField(ID_L2C2, ""l2c2"", createPresentation(""l2c2""))                         .build())                 .setRequiredSavableIds(SAVE_DATA_TYPE_PASSWORD, ID_L2C1)                 .build();         sReplier.addResponse(response2);         focusCell(2, 1);         sReplier.getNextFillRequest();          // Trigger save         mActivity.setText(2, 1, ""L2C1"");         mActivity.save();          mUiBot.saveForAutofill(true, SAVE_DATA_TYPE_PASSWORD);         final SaveRequest saveRequest = sReplier.getNextSaveRequest();         assertValue(saveRequest.structure, ID_L2C1, ""L2C1"");     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.PartitionedActivityTest"	"testSaveOneSaveInfoOnSecondPartitionWithIdsOnFirst"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/PartitionedActivityTest.java"	""	"public void testSaveOneSaveInfoOnSecondPartitionWithIdsOnFirst() throws Exception {         // Set service.         enableService();          // Trigger 1st partition.         final CannedFillResponse response1 = new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_L1C1, ""l1c1"", createPresentation(""l1c1""))                         .setField(ID_L1C2, ""l1c2"", createPresentation(""l1c2""))                         .build())                 .build();         sReplier.addResponse(response1);         focusCell(1, 1);         sReplier.getNextFillRequest();          // Trigger 2nd partition.         final CannedFillResponse response2 = new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_L2C1, ""l2c1"", createPresentation(""l2c1""))                         .setField(ID_L2C2, ""l2c2"", createPresentation(""l2c2""))                         .build())                 .setRequiredSavableIds(SAVE_DATA_TYPE_PASSWORD, ID_L1C1)                 .build();         sReplier.addResponse(response2);         focusCell(2, 1);         sReplier.getNextFillRequest();          // Trigger save         mActivity.setText(1, 1, ""L1C1"");         mActivity.save();          mUiBot.saveForAutofill(true, SAVE_DATA_TYPE_PASSWORD);         final SaveRequest saveRequest = sReplier.getNextSaveRequest();         assertValue(saveRequest.structure, ID_L1C1, ""L1C1"");     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testOnNotificationVisibilityChanged"	"CtsLegacyNotification29TestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	"public void testOnNotificationVisibilityChanged() throws Exception {         if (isTelevision()) {             return;         }         assumeFalse(""Status bar service not supported"", isWatch());         setUpListeners();         turnScreenOn();         mUi.adoptShellPermissionIdentity(""android.permission.EXPAND_STATUS_BAR"");          mNotificationAssistantService.resetNotificationVisibilityCounts();          // Initialize as closed         mStatusBarManager.collapsePanels();          sendNotification(1, ICON_ID);         assertEquals(0, mNotificationAssistantService.notificationVisibleCount);         assertEquals(0, mNotificationAssistantService.notificationHiddenCount);          mStatusBarManager.expandNotificationsPanel();         Thread.sleep(SLEEP_TIME * 2);         assertTrue(mNotificationAssistantService.notificationVisibleCount > 0);         assertEquals(0, mNotificationAssistantService.notificationHiddenCount);          mStatusBarManager.collapsePanels();         Thread.sleep(SLEEP_TIME * 2);         assertTrue(mNotificationAssistantService.notificationVisibleCount > 0);         assertTrue(mNotificationAssistantService.notificationHiddenCount > 0);          mUi.dropShellPermissionIdentity();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testOnPanelRevealedAndHidden"	"CtsLegacyNotification29TestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	"public void testOnPanelRevealedAndHidden() throws Exception {         if (isTelevision()) {             return;         }         assumeFalse(""Status bar service not supported"", isWatch());         setUpListeners();         turnScreenOn();         mUi.adoptShellPermissionIdentity(""android.permission.EXPAND_STATUS_BAR"");          // Initialize as closed         mStatusBarManager.collapsePanels();         assertFalse(mNotificationAssistantService.isPanelOpen);          mStatusBarManager.expandNotificationsPanel();         Thread.sleep(SLEEP_TIME * 2);         assertTrue(mNotificationAssistantService.isPanelOpen);          mStatusBarManager.collapsePanels();         Thread.sleep(SLEEP_TIME * 2);         assertFalse(mNotificationAssistantService.isPanelOpen);          mUi.dropShellPermissionIdentity();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testApplicationHiddenParent"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testApplicationHiddenParent() throws Exception {         if (!mHasFeature) {             return;         }          runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".ApplicationHiddenParentTest"", mUserId);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testApplicationHidden"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testApplicationHidden() throws Exception {         if (!mHasFeature) {             return;         }         installAppPermissionAppAsUser();         executeDeviceTestClass("".ApplicationHiddenTest"");         if (isStatsdEnabled(getDevice())) {             installAppAsUser(PERMISSIONS_APP_APK, mUserId);             assertMetricsLogged(getDevice(), () -> {                 executeDeviceTestMethod("".ApplicationHiddenTest"",                         ""testSetApplicationHidden"");             }, new DevicePolicyEventWrapper.Builder(EventId.SET_APPLICATION_HIDDEN_VALUE)                     .setAdminPackageName(DEVICE_ADMIN_PKG)                     .setBoolean(false)                     .setStrings(PERMISSIONS_APP_PKG, ""hidden"", NOT_CALLED_FROM_PARENT)                     .build(),             new DevicePolicyEventWrapper.Builder(EventId.SET_APPLICATION_HIDDEN_VALUE)                     .setAdminPackageName(DEVICE_ADMIN_PKG)                     .setBoolean(false)                     .setStrings(PERMISSIONS_APP_PKG, ""not_hidden"", NOT_CALLED_FROM_PARENT)                     .build());         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testNoHiddenActivityFoundTest"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"public void testNoHiddenActivityFoundTest() throws Exception {         if (!mHasFeature) {             return;         }         try {             // Install app to primary user             installAppAsUser(BaseLauncherAppsTest.LAUNCHER_TESTS_APK, mPrimaryUserId);             installAppAsUser(BaseLauncherAppsTest.LAUNCHER_TESTS_SUPPORT_APK, mPrimaryUserId);             installAppAsUser(LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK, mPrimaryUserId);              // Run test to check if launcher api shows hidden app             String mSerialNumber = Integer.toString(getUserSerialNumber(USER_SYSTEM));             runDeviceTestsAsUser(BaseLauncherAppsTest.LAUNCHER_TESTS_PKG,                     BaseLauncherAppsTest.LAUNCHER_TESTS_CLASS,                     ""testDoPoNoTestAppInjectedActivityFound"",                     mPrimaryUserId, Collections.singletonMap(BaseLauncherAppsTest.PARAM_TEST_USER,                             mSerialNumber));         } finally {             getDevice().uninstallPackage(LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK);             getDevice().uninstallPackage(BaseLauncherAppsTest.LAUNCHER_TESTS_SUPPORT_APK);             getDevice().uninstallPackage(BaseLauncherAppsTest.LAUNCHER_TESTS_APK);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.pm.cts.shortcut.multiuser.ShortcutManagerManagedUserTest"	"test04_getAndLaunch_primary"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/shortcuts/deviceside/multiuser/src/android/content/pm/cts/shortcut/multiuser/ShortcutManagerManagedUserTest.java"	""	"public void test04_getAndLaunch_primary() {         Launcher.setAsDefaultLauncher(getInstrumentation(), getContext());          final UserHandle userCurrent = android.os.Process.myUserHandle();         final UserHandle userOther = getOtherUser();          final ShortcutQuery q = new ShortcutQuery()                 .setQueryFlags(ShortcutQuery.FLAG_MATCH_DYNAMIC)                 .setPackage(getContext().getPackageName())                 .setShortcutIds(list(""s1""));         assertWith(getLauncherApps().getShortcuts(q, userCurrent))                 .haveIds(""s1"")                 .areAllDynamic()                 .forShortcutWithId(""s1"", si -> {                     assertEquals(""label1"", si.getShortLabel());                     assertEquals(userCurrent, si.getUserHandle());                 });         assertWith(getLauncherApps().getShortcuts(q, userOther))                 .haveIds(""s1"")                 .areAllDynamic()                 .forShortcutWithId(""s1"", si -> {                     assertEquals(""label2"", si.getShortLabel());                     assertEquals(userOther, si.getUserHandle());                 });          // Just call start and make sure they don't throw.         getLauncherApps().startShortcut(getContext().getPackageName(), ""s1"", null, null,                 userCurrent);          // TODO Make sure the activity actually starts.         getLauncherApps().startShortcut(getContext().getPackageName(), ""s1"", null, null,                 userOther);     }      @Suppress // Having a launcher on managed profile is not supported, so don't run."	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.pm.cts.shortcut.multiuser.ShortcutManagerManagedUserTest"	"test05_getAndLaunch_managed"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/shortcuts/deviceside/multiuser/src/android/content/pm/cts/shortcut/multiuser/ShortcutManagerManagedUserTest.java"	""	"public void test05_getAndLaunch_managed() {         Launcher.setAsDefaultLauncher(getInstrumentation(), getContext());          final UserHandle userCurrent = android.os.Process.myUserHandle();         final UserHandle userOther = getOtherUser();          final ShortcutQuery q = new ShortcutQuery()                 .setQueryFlags(ShortcutQuery.FLAG_MATCH_DYNAMIC)                 .setPackage(getContext().getPackageName())                 .setShortcutIds(list(""s1""));          assertWith(getLauncherApps().getShortcuts(q, userCurrent))                 .haveIds(""s1"")                 .areAllDynamic()                 .forShortcutWithId(""s1"", si -> {                     assertEquals(""label2"", si.getShortLabel());                     assertEquals(userCurrent, si.getUserHandle());                 });          // Accessing the main profile from the managed profile, which will not throw, but will         // return an empty result.         assertWith(getLauncherApps().getShortcuts(q, userOther)).isEmpty();          // TODO Make sure the activity actually starts.         getLauncherApps().startShortcut(getContext().getPackageName(), ""s1"", null, null,                 userCurrent);          try {             // This won't throw SecurityException either.             getLauncherApps().startShortcut(getContext().getPackageName(), ""s1"", null, null,                     userOther);             fail(""Didn't throw ActivityNotFoundException"");         } catch (ActivityNotFoundException e) {             // okay         }     }      private UserHandle getOtherUser() {         for (UserHandle user : getContext().getSystemService(UserManager.class).getUserProfiles()) {             if (user.equals(android.os.Process.myUserHandle())) {                 continue;             }             return user;         }         fail(""Other user not found"");         return null;     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.MediaControllerTest"	"testShow"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/MediaControllerTest.java"	""	"public void testShow() throws Throwable {         WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),                 () -> mMediaController = new MediaController(mActivity, true));         assertFalse(mMediaController.isShowing());          final MockMediaPlayerControl mediaPlayerControl = new MockMediaPlayerControl();         mMediaController.setMediaPlayer(mediaPlayerControl);          final VideoView videoView =                 (VideoView) mActivity.findViewById(R.id.mediacontroller_videoview);         mMediaController.setAnchorView(videoView);          WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),                 mMediaController::show);         assertTrue(mMediaController.isShowing());          WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),                 mMediaController::hide);         assertFalse(mMediaController.isShowing());          final int timeout = 2000;         WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),                 () -> mMediaController.show(timeout));         assertTrue(mMediaController.isShowing());          // isShowing() should return false, but MediaController still shows, this may be a bug.         PollingCheck.waitFor(500, mMediaController::isShowing);     }      private String prepareSampleVideo() {         final String VIDEO_NAME   = ""testvideo.3gp"";          try (InputStream source = mActivity.getResources().openRawResource(R.raw.testvideo);              OutputStream target = mActivity.openFileOutput(VIDEO_NAME, Context.MODE_PRIVATE)) {              final byte[] buffer = new byte[1024];             for (int len = source.read(buffer); len > 0; len = source.read(buffer)) {                 target.write(buffer, 0, len);             }         } catch (final IOException e) {             fail(e.getMessage());         }          return mActivity.getFileStreamPath(VIDEO_NAME).getAbsolutePath();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.hardware.camera2.cts.CaptureRequestTest"	"testExtendedSceneModes"	"CtsCameraTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/CaptureRequestTest.java"	""	"public void testExtendedSceneModes() throws Exception {         for (String id : mCameraIdsUnderTest) {             try {                 if (!mAllStaticInfo.get(id).isColorOutputSupported()) {                     Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");                     continue;                 }                 openDevice(id);                 List<Range<Integer>> fpsRanges = getTargetFpsRangesUpTo30(mStaticInfo);                 extendedSceneModeTestByCamera(fpsRanges);             } finally {                 closeDevice();             }         }     }      // TODO: add 3A state machine test.      /**      * Per camera dynamic black and white level test.      */     private void dynamicBlackWhiteLevelTestByCamera() throws Exception {         SimpleCaptureCallback resultListener = new SimpleCaptureCallback();         SimpleImageReaderListener imageListener = null;         CaptureRequest.Builder previewBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         CaptureRequest.Builder rawBuilder = null;         Size previewSize =                 getMaxPreviewSize(mCamera.getId(), mCameraManager,                 getPreviewSizeBound(mWindowManager, PREVIEW_SIZE_BOUND));         Size rawSize = null;         boolean canCaptureBlackRaw =                 mStaticInfo.isCapabilitySupported(                         CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW) &&                 mStaticInfo.isOpticalBlackRegionSupported();         if (canCaptureBlackRaw) {             // Capture Raw16, then calculate the optical black, and use it to check with the dynamic             // black level.             rawBuilder =                     mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);             rawSize = mStaticInfo.getRawDimensChecked();             imageListener = new SimpleImageReaderListener();             prepareRawCaptureAndStartPreview(previewBuilder, rawBuilder, previewSize, rawSize,                     resultListener, imageListener);         } else {             startPreview(previewBuilder, previewSize, resultListener);         }          // Capture a sequence of frames with different sensitivities and validate the black/white         // level values         int[] sensitivities = getSensitivityTestValues();         float[][] dynamicBlackLevels = new float[sensitivities.length][];         int[] dynamicWhiteLevels = new int[sensitivities.length];         float[][] opticalBlackLevels = new float[sensitivities.length][];         for (int i = 0; i < sensitivities.length; i++) {             CaptureResult result = null;             if (canCaptureBlackRaw) {                 changeExposure(rawBuilder, DEFAULT_EXP_TIME_NS, sensitivities[i]);                 CaptureRequest rawRequest = rawBuilder.build();                 mSession.capture(rawRequest, resultListener, mHandler);                 result = resultListener.getCaptureResultForRequest(rawRequest,                         NUM_RESULTS_WAIT_TIMEOUT);                 Image rawImage = imageListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);                  // Get max (area-wise) optical black region                 Rect[] opticalBlackRegions = mStaticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_OPTICAL_BLACK_REGIONS);                 Rect maxRegion = opticalBlackRegions[0];                 for (Rect region : opticalBlackRegions) {                     if (region.width() * region.height() > maxRegion.width() * maxRegion.height()) {                         maxRegion = region;                     }                 }                  // Get average black pixel values in the region (region is multiple of 2x2)                 Image.Plane rawPlane = rawImage.getPlanes()[0];                 ByteBuffer rawBuffer = rawPlane.getBuffer();                 float[] avgBlackLevels = {0, 0, 0, 0};                 final int rowSize = rawPlane.getRowStride();                 final int bytePerPixel = rawPlane.getPixelStride();                 if (VERBOSE) {                     Log.v(TAG, ""maxRegion: "" + maxRegion + "", Row stride: "" +                             rawPlane.getRowStride());                 }                 for (int row = maxRegion.top; row < maxRegion.bottom; row += 2) {                     for (int col = maxRegion.left; col < maxRegion.right; col += 2) {                         int startOffset = row * rowSize + col * bytePerPixel;                         avgBlackLevels[0] += rawBuffer.getShort(startOffset);                         avgBlackLevels[1] += rawBuffer.getShort(startOffset + bytePerPixel);                         startOffset += rowSize;                         avgBlackLevels[2] += rawBuffer.getShort(startOffset);                         avgBlackLevels[3] += rawBuffer.getShort(startOffset + bytePerPixel);                     }                 }                 int numBlackBlocks = maxRegion.width() * maxRegion.height() / (2 * 2);                 for (int m = 0; m < avgBlackLevels.length; m++) {                     avgBlackLevels[m] /= numBlackBlocks;                 }                 opticalBlackLevels[i] = avgBlackLevels;                  if (VERBOSE) {                     Log.v(TAG, String.format(""Optical black level results for sensitivity (%d): %s"",                             sensitivities[i], Arrays.toString(avgBlackLevels)));                 }                  rawImage.close();             } else {                 changeExposure(previewBuilder, DEFAULT_EXP_TIME_NS, sensitivities[i]);                 CaptureRequest previewRequest = previewBuilder.build();                 mSession.capture(previewRequest, resultListener, mHandler);                 result = resultListener.getCaptureResultForRequest(previewRequest,                         NUM_RESULTS_WAIT_TIMEOUT);             }              dynamicBlackLevels[i] = getValueNotNull(result,                     CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL);             dynamicWhiteLevels[i] = getValueNotNull(result,                     CaptureResult.SENSOR_DYNAMIC_WHITE_LEVEL);         }          if (VERBOSE) {             Log.v(TAG, ""Different sensitivities tested: "" + Arrays.toString(sensitivities));             Log.v(TAG, ""Dynamic black level results: "" + Arrays.deepToString(dynamicBlackLevels));             Log.v(TAG, ""Dynamic white level results: "" + Arrays.toString(dynamicWhiteLevels));             if (canCaptureBlackRaw) {                 Log.v(TAG, ""Optical black level results "" +                         Arrays.deepToString(opticalBlackLevels));             }         }          // check the dynamic black level against global black level.         // Implicit guarantee: if the dynamic black level is supported, fixed black level must be         // supported as well (tested in ExtendedCameraCharacteristicsTest#testOpticalBlackRegions).         BlackLevelPattern blackPattern = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SENSOR_BLACK_LEVEL_PATTERN);         int[] fixedBlackLevels = new int[4];         int fixedWhiteLevel = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SENSOR_INFO_WHITE_LEVEL);         blackPattern.copyTo(fixedBlackLevels, 0);         float maxBlackDeviation = 0;         int maxWhiteDeviation = 0;         for (int i = 0; i < dynamicBlackLevels.length; i++) {             for (int j = 0; j < dynamicBlackLevels[i].length; j++) {                 if (maxBlackDeviation < Math.abs(fixedBlackLevels[j] - dynamicBlackLevels[i][j])) {                     maxBlackDeviation = Math.abs(fixedBlackLevels[j] - dynamicBlackLevels[i][j]);                 }             }             if (maxWhiteDeviation < Math.abs(dynamicWhiteLevels[i] - fixedWhiteLevel)) {                 maxWhiteDeviation = Math.abs(dynamicWhiteLevels[i] - fixedWhiteLevel);             }         }         mCollector.expectLessOrEqual(""Max deviation of the dynamic black level vs fixed black level""                 + "" exceed threshold.""                 + "" Dynamic black level results: "" + Arrays.deepToString(dynamicBlackLevels),                 fixedBlackLevels[0] * DYNAMIC_VS_FIXED_BLK_WH_LVL_ERROR_MARGIN, maxBlackDeviation);         mCollector.expectLessOrEqual(""Max deviation of the dynamic white level exceed threshold.""                 + "" Dynamic white level results: "" + Arrays.toString(dynamicWhiteLevels),                 fixedWhiteLevel * DYNAMIC_VS_FIXED_BLK_WH_LVL_ERROR_MARGIN,                 (float)maxWhiteDeviation);          // Validate against optical black levels if it is available         if (canCaptureBlackRaw) {             maxBlackDeviation = 0;             for (int i = 0; i < dynamicBlackLevels.length; i++) {                 for (int j = 0; j < dynamicBlackLevels[i].length; j++) {                     if (maxBlackDeviation <                             Math.abs(opticalBlackLevels[i][j] - dynamicBlackLevels[i][j])) {                         maxBlackDeviation =                                 Math.abs(opticalBlackLevels[i][j] - dynamicBlackLevels[i][j]);                     }                 }             }              mCollector.expectLessOrEqual(""Max deviation of the dynamic black level vs optical black""                     + "" exceed threshold.""                     + "" Dynamic black level results: "" + Arrays.deepToString(dynamicBlackLevels)                     + "" Optical black level results: "" + Arrays.deepToString(opticalBlackLevels),                     fixedBlackLevels[0] * DYNAMIC_VS_OPTICAL_BLK_LVL_ERROR_MARGIN,                     maxBlackDeviation);         }     }      private void noiseReductionModeTestByCamera(List<Range<Integer>> fpsRanges) throws Exception {         Size maxPrevSize = mOrderedPreviewSizes.get(0);         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         int[] availableModes = mStaticInfo.getAvailableNoiseReductionModesChecked();          for (int mode : availableModes) {             requestBuilder.set(CaptureRequest.NOISE_REDUCTION_MODE, mode);              // Test that OFF and FAST mode should not slow down the frame rate.             if (mode == CaptureRequest.NOISE_REDUCTION_MODE_OFF ||                     mode == CaptureRequest.NOISE_REDUCTION_MODE_FAST) {                 verifyFpsNotSlowDown(requestBuilder, NUM_FRAMES_VERIFIED, fpsRanges);             }              SimpleCaptureCallback resultListener = new SimpleCaptureCallback();             startPreview(requestBuilder, maxPrevSize, resultListener);             mSession.setRepeatingRequest(requestBuilder.build(), resultListener, mHandler);             waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);              verifyCaptureResultForKey(CaptureResult.NOISE_REDUCTION_MODE, mode,                     resultListener, NUM_FRAMES_VERIFIED);         }          stopPreview();     }      private void focusDistanceTestByCamera() throws Exception {         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         requestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_OFF);         int calibrationStatus = mStaticInfo.getFocusDistanceCalibrationChecked();         float errorMargin = FOCUS_DISTANCE_ERROR_PERCENT_UNCALIBRATED;         if (calibrationStatus ==                 CameraMetadata.LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED) {             errorMargin = FOCUS_DISTANCE_ERROR_PERCENT_CALIBRATED;         } else if (calibrationStatus ==                 CameraMetadata.LENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE) {             errorMargin = FOCUS_DISTANCE_ERROR_PERCENT_APPROXIMATE;         }          // Test changing focus distance with repeating request         focusDistanceTestRepeating(requestBuilder, errorMargin);          if (calibrationStatus ==                 CameraMetadata.LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED)  {             // Test changing focus distance with burst request             focusDistanceTestBurst(requestBuilder, errorMargin);         }     }      private void focusDistanceTestRepeating(CaptureRequest.Builder requestBuilder,             float errorMargin) throws Exception {         CaptureRequest request;         float[] testDistances = getFocusDistanceTestValuesInOrder(0, 0);         Size maxPrevSize = mOrderedPreviewSizes.get(0);         SimpleCaptureCallback resultListener = new SimpleCaptureCallback();         startPreview(requestBuilder, maxPrevSize, resultListener);          float[] resultDistances = new float[testDistances.length];         int[] resultLensStates = new int[testDistances.length];          // Collect results         for (int i = 0; i < testDistances.length; i++) {             requestBuilder.set(CaptureRequest.LENS_FOCUS_DISTANCE, testDistances[i]);             request = requestBuilder.build();             resultListener = new SimpleCaptureCallback();             mSession.setRepeatingRequest(request, resultListener, mHandler);             waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);             waitForResultValue(resultListener, CaptureResult.LENS_STATE,                     CaptureResult.LENS_STATE_STATIONARY, NUM_RESULTS_WAIT_TIMEOUT);             CaptureResult result = resultListener.getCaptureResultForRequest(request,                     NUM_RESULTS_WAIT_TIMEOUT);              resultDistances[i] = getValueNotNull(result, CaptureResult.LENS_FOCUS_DISTANCE);             resultLensStates[i] = getValueNotNull(result, CaptureResult.LENS_STATE);              if (VERBOSE) {                 Log.v(TAG, ""Capture repeating request focus distance: "" + testDistances[i]                         + "" result: "" + resultDistances[i] + "" lens state "" + resultLensStates[i]);             }         }          verifyFocusDistance(testDistances, resultDistances, resultLensStates,                 /*ascendingOrder*/true, /*noOvershoot*/false, /*repeatStart*/0, /*repeatEnd*/0,                 errorMargin);          if (mStaticInfo.areKeysAvailable(CameraCharacteristics.LENS_INFO_HYPERFOCAL_DISTANCE)) {              // Test hyperfocal distance optionally             float hyperFocalDistance = mStaticInfo.getHyperfocalDistanceChecked();             if (hyperFocalDistance > 0) {                 requestBuilder.set(CaptureRequest.LENS_FOCUS_DISTANCE, hyperFocalDistance);                 request = requestBuilder.build();                 resultListener = new SimpleCaptureCallback();                 mSession.setRepeatingRequest(request, resultListener, mHandler);                 waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);                  // Then wait for the lens.state to be stationary.                 waitForResultValue(resultListener, CaptureResult.LENS_STATE,                         CaptureResult.LENS_STATE_STATIONARY, NUM_RESULTS_WAIT_TIMEOUT);                 CaptureResult result = resultListener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);                 Float focusDistance = getValueNotNull(result, CaptureResult.LENS_FOCUS_DISTANCE);                 mCollector.expectInRange(""Focus distance for hyper focal should be close enough to"" +                         "" requested value"", focusDistance,                         hyperFocalDistance * (1.0f - errorMargin),                         hyperFocalDistance * (1.0f + errorMargin));             }         }     }      private void focusDistanceTestBurst(CaptureRequest.Builder requestBuilder,             float errorMargin) throws Exception {          Size maxPrevSize = mOrderedPreviewSizes.get(0);         float[] testDistances = getFocusDistanceTestValuesInOrder(NUM_FOCUS_DISTANCES_REPEAT,                 NUM_FOCUS_DISTANCES_REPEAT);         SimpleCaptureCallback resultListener = new SimpleCaptureCallback();         startPreview(requestBuilder, maxPrevSize, resultListener);          float[] resultDistances = new float[testDistances.length];         int[] resultLensStates = new int[testDistances.length];          final int maxPipelineDepth = mStaticInfo.getCharacteristics().get(             CameraCharacteristics.REQUEST_PIPELINE_MAX_DEPTH);          // Move lens to starting position, and wait for the lens.state to be stationary.         CaptureRequest request;         requestBuilder.set(CaptureRequest.LENS_FOCUS_DISTANCE, testDistances[0]);         request = requestBuilder.build();         mSession.setRepeatingRequest(request, resultListener, mHandler);         waitForResultValue(resultListener, CaptureResult.LENS_STATE,                 CaptureResult.LENS_STATE_STATIONARY, NUM_RESULTS_WAIT_TIMEOUT);          // Submit burst of requests with different focus distances         List<CaptureRequest> burst = new ArrayList<>();         for (int i = 0; i < testDistances.length; i ++) {             requestBuilder.set(CaptureRequest.LENS_FOCUS_DISTANCE, testDistances[i]);             burst.add(requestBuilder.build());         }         mSession.captureBurst(burst, resultListener, mHandler);          for (int i = 0; i < testDistances.length; i++) {             CaptureResult result = resultListener.getCaptureResultForRequest(                     burst.get(i), maxPipelineDepth+1);              resultDistances[i] = getValueNotNull(result, CaptureResult.LENS_FOCUS_DISTANCE);             resultLensStates[i] = getValueNotNull(result, CaptureResult.LENS_STATE);              if (VERBOSE) {                 Log.v(TAG, ""Capture burst request focus distance: "" + testDistances[i]                         + "" result: "" + resultDistances[i] + "" lens state "" + resultLensStates[i]);             }         }          verifyFocusDistance(testDistances, resultDistances, resultLensStates,                 /*ascendingOrder*/true, /*noOvershoot*/true,                 /*repeatStart*/NUM_FOCUS_DISTANCES_REPEAT, /*repeatEnd*/NUM_FOCUS_DISTANCES_REPEAT,                 errorMargin);      }      /**      * Verify focus distance control.      *      * Assumption:      * - First repeatStart+1 elements of requestedDistances share the same value      * - Last repeatEnd+1 elements of requestedDistances share the same value      * - All elements in between are monotonically increasing/decreasing depending on ascendingOrder.      * - Focuser is at requestedDistances[0] at the beginning of the test.      *      * @param requestedDistances The requested focus distances      * @param resultDistances The result focus distances      * @param lensStates The result lens states      * @param ascendingOrder The order of the expected focus distance request/output      * @param noOvershoot Assert that focus control doesn't overshoot the requested value      * @param repeatStart The number of times the starting focus distance is repeated      * @param repeatEnd The number of times the ending focus distance is repeated      * @param errorMargin The error margin between request and result      */     private void verifyFocusDistance(float[] requestedDistances, float[] resultDistances,             int[] lensStates, boolean ascendingOrder, boolean noOvershoot, int repeatStart,             int repeatEnd, float errorMargin) {          float minValue = 0;         float maxValue = mStaticInfo.getMinimumFocusDistanceChecked();         float hyperfocalDistance = 0;         if (mStaticInfo.areKeysAvailable(CameraCharacteristics.LENS_INFO_HYPERFOCAL_DISTANCE)) {             hyperfocalDistance = mStaticInfo.getHyperfocalDistanceChecked();         }          // Verify lens and focus distance do not change for first repeatStart         // results.         for (int i = 0; i < repeatStart; i ++) {             float marginMin = requestedDistances[i] * (1.0f - errorMargin);             // HAL may choose to use hyperfocal distance for all distances between [0, hyperfocal].             float marginMax =                     Math.max(requestedDistances[i], hyperfocalDistance) * (1.0f + errorMargin);              mCollector.expectEquals(""Lens moves even though focus_distance didn't change"",                     lensStates[i], CaptureResult.LENS_STATE_STATIONARY);             if (noOvershoot) {                 mCollector.expectInRange(""Focus distance in result should be close enough to "" +                         ""requested value"", resultDistances[i], marginMin, marginMax);             }             mCollector.expectInRange(""Result focus distance is out of range"",                     resultDistances[i], minValue, maxValue);         }          for (int i = repeatStart; i < resultDistances.length-1; i ++) {             float marginMin = requestedDistances[i] * (1.0f - errorMargin);             // HAL may choose to use hyperfocal distance for all distances between [0, hyperfocal].             float marginMax =                     Math.max(requestedDistances[i], hyperfocalDistance) * (1.0f + errorMargin);             if (noOvershoot) {                 // Result focus distance shouldn't overshoot the request                 boolean condition;                 if (ascendingOrder) {                     condition = resultDistances[i] <= marginMax;                } else {                     condition = resultDistances[i] >= marginMin;                 }                 mCollector.expectTrue(String.format(                       ""Lens shouldn't move past request focus distance. result "" +                       resultDistances[i] + "" vs target of "" +                       (ascendingOrder ? marginMax : marginMin)), condition);             }              // Verify monotonically increased focus distance setting             boolean condition;             float compareDistance = resultDistances[i+1] - resultDistances[i];             if (i < resultDistances.length-1-repeatEnd) {                 condition = (ascendingOrder ? compareDistance > 0 : compareDistance < 0);             } else {                 condition = (ascendingOrder ? compareDistance >= 0 : compareDistance <= 0);             }             mCollector.expectTrue(String.format(""Adjacent [resultDistances, lens_state] results [""                   + resultDistances[i] + "","" + lensStates[i] + ""], ["" + resultDistances[i+1] + "",""                   + lensStates[i+1] + ""] monotonicity is broken""), condition);         }          mCollector.expectTrue(String.format(""All values of this array are equal: "" +                 resultDistances[0] + "" "" + resultDistances[resultDistances.length-1]),                 resultDistances[0] != resultDistances[resultDistances.length-1]);          // Verify lens moved to destination location.         mCollector.expectInRange(""Focus distance "" + resultDistances[resultDistances.length-1] +                 "" for minFocusDistance should be closed enough to requested value "" +                 requestedDistances[requestedDistances.length-1],                 resultDistances[resultDistances.length-1],                 requestedDistances[requestedDistances.length-1] * (1.0f - errorMargin),                 requestedDistances[requestedDistances.length-1] * (1.0f + errorMargin));     }      /**      * Verify edge mode control results for fpsRanges      */     private void edgeModesTestByCamera(List<Range<Integer>> fpsRanges) throws Exception {         Size maxPrevSize = mOrderedPreviewSizes.get(0);         int[] edgeModes = mStaticInfo.getAvailableEdgeModesChecked();         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);          for (int mode : edgeModes) {             requestBuilder.set(CaptureRequest.EDGE_MODE, mode);              // Test that OFF and FAST mode should not slow down the frame rate.             if (mode == CaptureRequest.EDGE_MODE_OFF ||                     mode == CaptureRequest.EDGE_MODE_FAST) {                 verifyFpsNotSlowDown(requestBuilder, NUM_FRAMES_VERIFIED, fpsRanges);             }              SimpleCaptureCallback resultListener = new SimpleCaptureCallback();             startPreview(requestBuilder, maxPrevSize, resultListener);             mSession.setRepeatingRequest(requestBuilder.build(), resultListener, mHandler);             waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);              verifyCaptureResultForKey(CaptureResult.EDGE_MODE, mode, resultListener,                     NUM_FRAMES_VERIFIED);        }          stopPreview();     }      /**      * Test color correction controls.      *      * <p>Test different color correction modes. For TRANSFORM_MATRIX, only test      * the unit gain and identity transform.</p>      */     private void colorCorrectionTestByCamera() throws Exception {         CaptureRequest request;         CaptureResult result;         Size maxPreviewSz = mOrderedPreviewSizes.get(0); // Max preview size.         updatePreviewSurface(maxPreviewSz);         CaptureRequest.Builder manualRequestBuilder = createRequestForPreview();         CaptureRequest.Builder previewRequestBuilder = createRequestForPreview();         SimpleCaptureCallback listener = new SimpleCaptureCallback();          startPreview(previewRequestBuilder, maxPreviewSz, listener);          // Default preview result should give valid color correction metadata.         result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);         validateColorCorrectionResult(result,                 previewRequestBuilder.get(CaptureRequest.COLOR_CORRECTION_MODE));         int colorCorrectionMode = CaptureRequest.COLOR_CORRECTION_MODE_TRANSFORM_MATRIX;         // TRANSFORM_MATRIX mode         // Only test unit gain and identity transform         List<Integer> availableControlModes = Arrays.asList(                 CameraTestUtils.toObject(mStaticInfo.getAvailableControlModesChecked()));         List<Integer> availableAwbModes = Arrays.asList(                 CameraTestUtils.toObject(mStaticInfo.getAwbAvailableModesChecked()));         boolean isManualCCSupported =                 availableControlModes.contains(CaptureRequest.CONTROL_MODE_OFF) ||                 availableAwbModes.contains(CaptureRequest.CONTROL_AWB_MODE_OFF);         if (isManualCCSupported) {             if (!availableControlModes.contains(CaptureRequest.CONTROL_MODE_OFF)) {                 // Only manual AWB mode is supported                 manualRequestBuilder.set(CaptureRequest.CONTROL_MODE,                         CaptureRequest.CONTROL_MODE_AUTO);                 manualRequestBuilder.set(CaptureRequest.CONTROL_AWB_MODE,                         CaptureRequest.CONTROL_AWB_MODE_OFF);             } else {                 // All 3A manual controls are supported, it doesn't matter what we set for AWB mode.                 manualRequestBuilder.set(CaptureRequest.CONTROL_MODE,                         CaptureRequest.CONTROL_MODE_OFF);             }              RggbChannelVector UNIT_GAIN = new RggbChannelVector(1.0f, 1.0f, 1.0f, 1.0f);              ColorSpaceTransform IDENTITY_TRANSFORM = new ColorSpaceTransform(                 new Rational[] {                     ONE_R, ZERO_R, ZERO_R,                     ZERO_R, ONE_R, ZERO_R,                     ZERO_R, ZERO_R, ONE_R                 });              manualRequestBuilder.set(CaptureRequest.COLOR_CORRECTION_MODE, colorCorrectionMode);             manualRequestBuilder.set(CaptureRequest.COLOR_CORRECTION_GAINS, UNIT_GAIN);             manualRequestBuilder.set(CaptureRequest.COLOR_CORRECTION_TRANSFORM, IDENTITY_TRANSFORM);             request = manualRequestBuilder.build();             mSession.capture(request, listener, mHandler);             result = listener.getCaptureResultForRequest(request, NUM_RESULTS_WAIT_TIMEOUT);             RggbChannelVector gains = result.get(CaptureResult.COLOR_CORRECTION_GAINS);             ColorSpaceTransform transform = result.get(CaptureResult.COLOR_CORRECTION_TRANSFORM);             validateColorCorrectionResult(result, colorCorrectionMode);             mCollector.expectEquals(""control mode result/request mismatch"",                     CaptureResult.CONTROL_MODE_OFF, result.get(CaptureResult.CONTROL_MODE));             mCollector.expectEquals(""Color correction gain result/request mismatch"",                     UNIT_GAIN, gains);             mCollector.expectEquals(""Color correction gain result/request mismatch"",                     IDENTITY_TRANSFORM, transform);          }          // FAST mode         colorCorrectionMode = CaptureRequest.COLOR_CORRECTION_MODE_FAST;         manualRequestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);         manualRequestBuilder.set(CaptureRequest.COLOR_CORRECTION_MODE, colorCorrectionMode);         request = manualRequestBuilder.build();         mSession.capture(request, listener, mHandler);         result = listener.getCaptureResultForRequest(request, NUM_RESULTS_WAIT_TIMEOUT);         validateColorCorrectionResult(result, colorCorrectionMode);         mCollector.expectEquals(""control mode result/request mismatch"",                 CaptureResult.CONTROL_MODE_AUTO, result.get(CaptureResult.CONTROL_MODE));          // HIGH_QUALITY mode         colorCorrectionMode = CaptureRequest.COLOR_CORRECTION_MODE_HIGH_QUALITY;         manualRequestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);         manualRequestBuilder.set(CaptureRequest.COLOR_CORRECTION_MODE, colorCorrectionMode);         request = manualRequestBuilder.build();         mSession.capture(request, listener, mHandler);         result = listener.getCaptureResultForRequest(request, NUM_RESULTS_WAIT_TIMEOUT);         validateColorCorrectionResult(result, colorCorrectionMode);         mCollector.expectEquals(""control mode result/request mismatch"",                 CaptureResult.CONTROL_MODE_AUTO, result.get(CaptureResult.CONTROL_MODE));     }      private void validateColorCorrectionResult(CaptureResult result, int colorCorrectionMode) {         final RggbChannelVector ZERO_GAINS = new RggbChannelVector(0, 0, 0, 0);         final int TRANSFORM_SIZE = 9;         Rational[] zeroTransform = new Rational[TRANSFORM_SIZE];         Arrays.fill(zeroTransform, ZERO_R);         final ColorSpaceTransform ZERO_TRANSFORM = new ColorSpaceTransform(zeroTransform);          RggbChannelVector resultGain;         if ((resultGain = mCollector.expectKeyValueNotNull(result,                 CaptureResult.COLOR_CORRECTION_GAINS)) != null) {             mCollector.expectKeyValueNotEquals(result,                     CaptureResult.COLOR_CORRECTION_GAINS, ZERO_GAINS);         }          ColorSpaceTransform resultTransform;         if ((resultTransform = mCollector.expectKeyValueNotNull(result,                 CaptureResult.COLOR_CORRECTION_TRANSFORM)) != null) {             mCollector.expectKeyValueNotEquals(result,                     CaptureResult.COLOR_CORRECTION_TRANSFORM, ZERO_TRANSFORM);         }          mCollector.expectEquals(""color correction mode result/request mismatch"",                 colorCorrectionMode, result.get(CaptureResult.COLOR_CORRECTION_MODE));     }      /**      * Test that flash can be turned off successfully with a given initial and final AE_CONTROL      * states.      *      * This function expects that initialAeControl and flashOffAeControl will not be either      * CaptureRequest.CONTROL_AE_MODE_ON or CaptureRequest.CONTROL_AE_MODE_OFF      *      * @param listener The Capture listener that is used to wait for capture result      * @param initialAeControl The initial AE_CONTROL mode to start repeating requests with.      * @param flashOffAeControl The final AE_CONTROL mode which is expected to turn flash off for      *        TEMPLATE_PREVIEW repeating requests.      */     private void flashTurnOffTest(SimpleCaptureCallback listener, boolean isLegacy,             int initialAeControl, int flashOffAeControl) throws Exception {         CaptureResult result;         final int NUM_FLASH_REQUESTS_TESTED = 10;         CaptureRequest.Builder requestBuilder = createRequestForPreview();         requestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);         requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, initialAeControl);          mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);         waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);          // Turn on torch using FLASH_MODE_TORCH         requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON);         requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_TORCH);         CaptureRequest torchOnRequest = requestBuilder.build();         mSession.setRepeatingRequest(torchOnRequest, listener, mHandler);         waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_TORCH);         result = listener.getCaptureResultForRequest(torchOnRequest, NUM_RESULTS_WAIT_TIMEOUT);         // Test that the flash actually turned on continuously.         mCollector.expectEquals(""Flash state result must be FIRED"", CaptureResult.FLASH_STATE_FIRED,                 result.get(CaptureResult.FLASH_STATE));         mSession.stopRepeating();         // Turn off the torch         requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, flashOffAeControl);         // TODO: jchowdhary@, b/130323585, this line can be removed.         requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_OFF);         int numAllowedTransitionStates = NUM_PARTIAL_FRAMES_NPFC;         if (mStaticInfo.isPerFrameControlSupported()) {            numAllowedTransitionStates = NUM_PARTIAL_FRAMES_PFC;          }         // We submit 2 * numAllowedTransitionStates + 1 requests since we have two torch mode         // transitions. The additional request is to check for at least 1 expected (FIRED / READY)         // state.         int numTorchTestSamples =  2 * numAllowedTransitionStates  + 1;         CaptureRequest flashOffRequest = requestBuilder.build();         int flashModeOffRequests = captureRequestsSynchronizedBurst(flashOffRequest,                 numTorchTestSamples, listener, mHandler);         // Turn it on again.         requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_TORCH);         // We need to have CONTROL_AE_MODE be either CONTROL_AE_MODE_ON or CONTROL_AE_MODE_OFF to         // turn the torch on again.         requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON);         CaptureRequest flashModeTorchRequest = requestBuilder.build();         int flashModeTorchRequests = captureRequestsSynchronizedBurst(flashModeTorchRequest,                 numTorchTestSamples, listener, mHandler);          CaptureResult[] torchStateResults =                 new CaptureResult[flashModeTorchRequests + flashModeOffRequests];         Arrays.fill(torchStateResults, null);         int i = 0;         for (; i < flashModeOffRequests; i++) {             torchStateResults[i] =                     listener.getCaptureResultForRequest(flashOffRequest, NUM_RESULTS_WAIT_TIMEOUT);             mCollector.expectNotEquals(""Result for flashModeOff request null"",                     torchStateResults[i], null);         }         for (int j = i; j < torchStateResults.length; j++) {             torchStateResults[j] =                     listener.getCaptureResultForRequest(flashModeTorchRequest,                             NUM_RESULTS_WAIT_TIMEOUT);             mCollector.expectNotEquals(""Result for flashModeTorch request null"",                     torchStateResults[j], null);         }         if (isLegacy) {             // For LEGACY devices, flash state is null for all situations except:             // android.control.aeMode == ON_ALWAYS_FLASH, where flash.state will be FIRED             // android.flash.mode == TORCH, where flash.state will be FIRED             testLegacyTorchStates(torchStateResults, 0, flashModeOffRequests - 1, flashOffRequest);             testLegacyTorchStates(torchStateResults, flashModeOffRequests,                     torchStateResults.length -1,                     flashModeTorchRequest);         } else {             checkTorchStates(torchStateResults, numAllowedTransitionStates, flashModeOffRequests,                     flashModeTorchRequests);         }     }      private void testLegacyTorchStates(CaptureResult []torchStateResults, int beg, int end,             CaptureRequest request) {         for (int i = beg; i <= end; i++) {             Integer requestControlAeMode = request.get(CaptureRequest.CONTROL_AE_MODE);             Integer requestFlashMode = request.get(CaptureRequest.FLASH_MODE);             Integer resultFlashState = torchStateResults[i].get(CaptureResult.FLASH_STATE);             if (requestControlAeMode == CaptureRequest.CONTROL_AE_MODE_ON_ALWAYS_FLASH ||                     requestFlashMode == CaptureRequest.FLASH_MODE_TORCH) {                 mCollector.expectEquals(""For LEGACY devices, flash state must be FIRED when"" +                         ""CONTROL_AE_MODE == CONTROL_AE_MODE_ON_ALWAYS_FLASH or FLASH_MODE == "" +                         ""TORCH, CONTROL_AE_MODE = "" + requestControlAeMode + "" FLASH_MODE = "" +                         requestFlashMode, CaptureResult.FLASH_STATE_FIRED, resultFlashState);                 continue;             }             mCollector.expectTrue(""For LEGACY devices, flash state must be null when"" +                         ""CONTROL_AE_MODE != CONTROL_AE_MODE_ON_ALWAYS_FLASH or FLASH_MODE != "" +                         ""TORCH, CONTROL_AE_MODE = "" + requestControlAeMode + "" FLASH_MODE = "" +                         requestFlashMode,  resultFlashState == null);         }     }     // We check that torch states appear in the order expected. We don't necessarily know how many     // times each state might appear, however we make sure that the states do not appear out of     // order.     private void checkTorchTransitionStates(CaptureResult []torchStateResults, int beg, int end,             List<Integer> stateOrder, boolean isTurningOff) {         Integer flashState;         Integer curIndex = 0;         for (int i = beg; i <= end; i++) {             flashState = torchStateResults[i].get(CaptureResult.FLASH_STATE);             int index = stateOrder.indexOf(flashState);             mCollector.expectNotEquals(""Invalid state "" + flashState + "" not in expected list"" +                     stateOrder, index, -1);             mCollector.expectGreaterOrEqual(""state "" + flashState  + "" index "" + index +                     "" is expected to be >= "" + curIndex,                     curIndex, index);             curIndex = index;         }     }      private void checkTorchStates(CaptureResult []torchResults, int numAllowedTransitionStates,             int numTorchOffSamples, int numTorchOnSamples) {         // We test for flash states from request:         // Request:       O(0) O(1) O(2) O(n)....O(nOFF) T(0) T(1) T(2) ....T(n) .... T(nON)         // Valid Result : P/R  P/R  P/R  R R R...P/R P/R   P/F  P/F  P/F      F         F         // For the FLASH_STATE_OFF requests, once FLASH_STATE READY has been seen, for the         // transition states while switching the torch off, it must not transition to         // FLASH_STATE_PARTIAL again till the next transition period which turns the torch on.         // P - FLASH_STATE_PARTIAL         // R - FLASH_STATE_READY         // F - FLASH_STATE_FIRED         // O(k) - kth FLASH_MODE_OFF request         // T(k) - kth FLASH_MODE_TORCH request         // nOFF - number of torch off samples         // nON - number of torch on samples         Integer flashState;         // Check on -> off transition states         List<Integer> onToOffStateOrderList = new ArrayList<Integer>();         onToOffStateOrderList.add(CaptureRequest.FLASH_STATE_PARTIAL);         onToOffStateOrderList.add(CaptureRequest.FLASH_STATE_READY);         checkTorchTransitionStates(torchResults, 0, numAllowedTransitionStates,                 onToOffStateOrderList, true);         // The next frames (before transition) must have its flash state as FLASH_STATE_READY         for (int i = numAllowedTransitionStates + 1;                 i < numTorchOffSamples - numAllowedTransitionStates; i++) {             flashState = torchResults[numAllowedTransitionStates].get(CaptureResult.FLASH_STATE);             mCollector.expectEquals(""flash state result must be READY"",                     CaptureResult.FLASH_STATE_READY, flashState);         }         // check off -> on transition states, before the FLASH_MODE_TORCH request was sent         List<Integer> offToOnPreStateOrderList = new ArrayList<Integer>();         offToOnPreStateOrderList.add(CaptureRequest.FLASH_STATE_READY);         offToOnPreStateOrderList.add(CaptureRequest.FLASH_STATE_PARTIAL);         checkTorchTransitionStates(torchResults,                 numTorchOffSamples - numAllowedTransitionStates, numTorchOffSamples - 1,                 offToOnPreStateOrderList, false);         // check off -> on transition states         List<Integer> offToOnPostStateOrderList = new ArrayList<Integer>();         offToOnPostStateOrderList.add(CaptureRequest.FLASH_STATE_PARTIAL);         offToOnPostStateOrderList.add(CaptureRequest.FLASH_STATE_FIRED);         checkTorchTransitionStates(torchResults,                 numTorchOffSamples, numTorchOffSamples + numAllowedTransitionStates,                 offToOnPostStateOrderList, false);         // check on states after off -> on transition         // The next frames must have its flash state as FLASH_STATE_FIRED         for (int i = numTorchOffSamples + numAllowedTransitionStates + 1;                 i < torchResults.length - 1; i++) {             flashState = torchResults[i].get(CaptureResult.FLASH_STATE);             mCollector.expectEquals(""flash state result must be FIRED for frame "" + i,                     CaptureRequest.FLASH_STATE_FIRED, flashState);         }     }      /**      * Test flash mode control by AE mode.      * <p>      * Only allow AE mode ON or OFF, because other AE mode could run into conflict with      * flash manual control. This function expects the camera to already have an active      * repeating request and be sending results to the listener.      * </p>      *      * @param listener The Capture listener that is used to wait for capture result      * @param aeMode The AE mode for flash to test with      */     private void flashTestByAeMode(SimpleCaptureCallback listener, int aeMode) throws Exception {         CaptureResult result;         final int NUM_FLASH_REQUESTS_TESTED = 10;         CaptureRequest.Builder requestBuilder = createRequestForPreview();          if (aeMode == CaptureRequest.CONTROL_AE_MODE_ON) {             requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, aeMode);         } else if (aeMode == CaptureRequest.CONTROL_AE_MODE_OFF) {             changeExposure(requestBuilder, DEFAULT_EXP_TIME_NS, DEFAULT_SENSITIVITY);         } else {             throw new IllegalArgumentException(""This test only works when AE mode is ON or OFF"");         }          mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);         waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);          // For camera that doesn't have flash unit, flash state should always be UNAVAILABLE.         if (mStaticInfo.getFlashInfoChecked() == false) {             for (int i = 0; i < NUM_FLASH_REQUESTS_TESTED; i++) {                 result = listener.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);                 mCollector.expectEquals(""No flash unit available, flash state must be UNAVAILABLE""                         + ""for AE mode "" + aeMode, CaptureResult.FLASH_STATE_UNAVAILABLE,                         result.get(CaptureResult.FLASH_STATE));             }              return;         }          // Test flash SINGLE mode control. Wait for flash state to be READY first.         if (mStaticInfo.isHardwareLevelAtLeastLimited()) {             waitForResultValue(listener, CaptureResult.FLASH_STATE, CaptureResult.FLASH_STATE_READY,                     NUM_RESULTS_WAIT_TIMEOUT);         } // else the settings were already waited on earlier          requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_SINGLE);         CaptureRequest flashSinglerequest = requestBuilder.build();          int flashModeSingleRequests = captureRequestsSynchronized(                 flashSinglerequest, listener, mHandler);         waitForNumResults(listener, flashModeSingleRequests - 1);         result = listener.getCaptureResultForRequest(flashSinglerequest, NUM_RESULTS_WAIT_TIMEOUT);         // Result mode must be SINGLE, state must be FIRED.         mCollector.expectEquals(""Flash mode result must be SINGLE"",                 CaptureResult.FLASH_MODE_SINGLE, result.get(CaptureResult.FLASH_MODE));         mCollector.expectEquals(""Flash state result must be FIRED"",                 CaptureResult.FLASH_STATE_FIRED, result.get(CaptureResult.FLASH_STATE));          // Test flash TORCH mode control.         requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_TORCH);         CaptureRequest torchRequest = requestBuilder.build();          int flashModeTorchRequests = captureRequestsSynchronized(torchRequest,                 NUM_FLASH_REQUESTS_TESTED, listener, mHandler);         waitForNumResults(listener, flashModeTorchRequests - NUM_FLASH_REQUESTS_TESTED);          // Verify the results         TorchSeqState state = TorchSeqState.RAMPING_UP;         for (int i = 0; i < NUM_FLASH_REQUESTS_TESTED; i++) {             result = listener.getCaptureResultForRequest(torchRequest,                     NUM_RESULTS_WAIT_TIMEOUT);             int flashMode = result.get(CaptureResult.FLASH_MODE);             int flashState = result.get(CaptureResult.FLASH_STATE);             // Result mode must be TORCH             mCollector.expectEquals(""Flash mode result "" + i + "" must be TORCH"",                     CaptureResult.FLASH_MODE_TORCH, result.get(CaptureResult.FLASH_MODE));             if (state == TorchSeqState.RAMPING_UP &&                     flashState == CaptureResult.FLASH_STATE_FIRED) {                 state = TorchSeqState.FIRED;             } else if (state == TorchSeqState.FIRED &&                     flashState == CaptureResult.FLASH_STATE_PARTIAL) {                 state = TorchSeqState.RAMPING_DOWN;             }              if (i == 0 && mStaticInfo.isPerFrameControlSupported()) {                 mCollector.expectTrue(                         ""Per frame control device must enter FIRED state on first torch request"",                         state == TorchSeqState.FIRED);             }              if (state == TorchSeqState.FIRED) {                 mCollector.expectEquals(""Flash state result "" + i + "" must be FIRED"",                         CaptureResult.FLASH_STATE_FIRED, result.get(CaptureResult.FLASH_STATE));             } else {                 mCollector.expectEquals(""Flash state result "" + i + "" must be PARTIAL"",                         CaptureResult.FLASH_STATE_PARTIAL, result.get(CaptureResult.FLASH_STATE));             }         }         mCollector.expectTrue(""Torch state FIRED never seen"",                 state == TorchSeqState.FIRED || state == TorchSeqState.RAMPING_DOWN);          // Test flash OFF mode control         requestBuilder.set(CaptureRequest.FLASH_MODE, CaptureRequest.FLASH_MODE_OFF);         CaptureRequest flashOffrequest = requestBuilder.build();          int flashModeOffRequests = captureRequestsSynchronized(flashOffrequest, listener, mHandler);         waitForNumResults(listener, flashModeOffRequests - 1);         result = listener.getCaptureResultForRequest(flashOffrequest, NUM_RESULTS_WAIT_TIMEOUT);         mCollector.expectEquals(""Flash mode result must be OFF"", CaptureResult.FLASH_MODE_OFF,                 result.get(CaptureResult.FLASH_MODE));     }      private void verifyAntiBandingMode(SimpleCaptureCallback listener, int numFramesVerified,             int mode, boolean isAeManual, long requestExpTime) throws Exception {         // Skip the first a couple of frames as antibanding may not be fully up yet.         final int NUM_FRAMES_SKIPPED = 5;         for (int i = 0; i < NUM_FRAMES_SKIPPED; i++) {             listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);         }          for (int i = 0; i < numFramesVerified; i++) {             CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);             Long resultExpTime = result.get(CaptureResult.SENSOR_EXPOSURE_TIME);             assertNotNull(""Exposure time shouldn't be null"", resultExpTime);             Integer flicker = result.get(CaptureResult.STATISTICS_SCENE_FLICKER);             // Scene flicker result should be always available.             assertNotNull(""Scene flicker must not be null"", flicker);             assertTrue(""Scene flicker is invalid"", flicker >= STATISTICS_SCENE_FLICKER_NONE &&                     flicker <= STATISTICS_SCENE_FLICKER_60HZ);              Integer antiBandMode = result.get(CaptureResult.CONTROL_AE_ANTIBANDING_MODE);             assertNotNull(""antiBanding mode shouldn't be null"", antiBandMode);             assertTrue(""antiBanding Mode invalid, should be == "" + mode + "", is: "" + antiBandMode,                     antiBandMode == mode);             if (isAeManual) {                 // First, round down not up, second, need close enough.                 validateExposureTime(requestExpTime, resultExpTime);                 return;             }              long expectedExpTime = resultExpTime; // Default, no exposure adjustment.             if (mode == CONTROL_AE_ANTIBANDING_MODE_50HZ) {                 // result exposure time must be adjusted by 50Hz illuminant source.                 expectedExpTime =                         getAntiFlickeringExposureTime(ANTI_FLICKERING_50HZ, resultExpTime);             } else if (mode == CONTROL_AE_ANTIBANDING_MODE_60HZ) {                 // result exposure time must be adjusted by 60Hz illuminant source.                 expectedExpTime =                         getAntiFlickeringExposureTime(ANTI_FLICKERING_60HZ, resultExpTime);             } else if (mode == CONTROL_AE_ANTIBANDING_MODE_AUTO){                 /**                  * Use STATISTICS_SCENE_FLICKER to tell the illuminant source                  * and do the exposure adjustment.                  */                 expectedExpTime = resultExpTime;                 if (flicker == STATISTICS_SCENE_FLICKER_60HZ) {                     expectedExpTime =                             getAntiFlickeringExposureTime(ANTI_FLICKERING_60HZ, resultExpTime);                 } else if (flicker == STATISTICS_SCENE_FLICKER_50HZ) {                     expectedExpTime =                             getAntiFlickeringExposureTime(ANTI_FLICKERING_50HZ, resultExpTime);                 }             }              if (Math.abs(resultExpTime - expectedExpTime) > EXPOSURE_TIME_ERROR_MARGIN_NS) {                 mCollector.addMessage(String.format(""Result exposure time %dns diverges too much""                         + "" from expected exposure time %dns for mode %d when AE is auto"",                         resultExpTime, expectedExpTime, mode));             }         }     }      private void antiBandingTestByMode(Size size, int mode)             throws Exception {         if(VERBOSE) {             Log.v(TAG, ""Anti-banding test for mode "" + mode + "" for camera "" + mCamera.getId());         }         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);          requestBuilder.set(CaptureRequest.CONTROL_AE_ANTIBANDING_MODE, mode);          // Test auto AE mode anti-banding behavior         SimpleCaptureCallback resultListener = new SimpleCaptureCallback();         startPreview(requestBuilder, size, resultListener);         waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);         verifyAntiBandingMode(resultListener, NUM_FRAMES_VERIFIED, mode, /*isAeManual*/false,                 IGNORE_REQUESTED_EXPOSURE_TIME_CHECK);          // Test manual AE mode anti-banding behavior         // 65ms, must be supported by full capability devices.         final long TEST_MANUAL_EXP_TIME_NS = 65000000L;         long manualExpTime = mStaticInfo.getExposureClampToRange(TEST_MANUAL_EXP_TIME_NS);         changeExposure(requestBuilder, manualExpTime);         resultListener = new SimpleCaptureCallback();         startPreview(requestBuilder, size, resultListener);         waitForSettingsApplied(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);         verifyAntiBandingMode(resultListener, NUM_FRAMES_VERIFIED, mode, /*isAeManual*/true,                 manualExpTime);          stopPreview();     }      /**      * Test the all available AE modes and AE lock.      * <p>      * For manual AE mode, test iterates through different sensitivities and      * exposure times, validate the result exposure time correctness. For      * CONTROL_AE_MODE_ON_ALWAYS_FLASH mode, the AE lock and flash are tested.      * For the rest of the AUTO mode, AE lock is tested.      * </p>      *      * @param mode      */     private void aeModeAndLockTestByMode(int mode)             throws Exception {         switch (mode) {             case CONTROL_AE_MODE_OFF:                 if (mStaticInfo.isCapabilitySupported(                         CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {                     // Test manual exposure control.                     aeManualControlTest();                 } else {                     Log.w(TAG,                             ""aeModeAndLockTestByMode - can't test AE mode OFF without "" +                             ""manual sensor control"");                 }                 break;             case CONTROL_AE_MODE_ON:             case CONTROL_AE_MODE_ON_AUTO_FLASH:             case CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE:             case CONTROL_AE_MODE_ON_ALWAYS_FLASH:             case CONTROL_AE_MODE_ON_EXTERNAL_FLASH:                 // Test AE lock for above AUTO modes.                 aeAutoModeTestLock(mode);                 break;             default:                 throw new UnsupportedOperationException(""Unhandled AE mode "" + mode);         }     }      /**      * Test AE auto modes.      * <p>      * Use single request rather than repeating request to test AE lock per frame control.      * </p>      */     private void aeAutoModeTestLock(int mode) throws Exception {         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         if (mStaticInfo.isAeLockSupported()) {             requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, false);         }         requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, mode);         configurePreviewOutput(requestBuilder);          final int MAX_NUM_CAPTURES_DURING_LOCK = 5;         for (int i = 1; i <= MAX_NUM_CAPTURES_DURING_LOCK; i++) {             autoAeMultipleCapturesThenTestLock(requestBuilder, mode, i);         }     }      /**      * Issue multiple auto AE captures, then lock AE, validate the AE lock vs.      * the first capture result after the AE lock. The right AE lock behavior is:      * When it is locked, it locks to the current exposure value, and all subsequent      * request with lock ON will have the same exposure value locked.      */     private void autoAeMultipleCapturesThenTestLock(             CaptureRequest.Builder requestBuilder, int aeMode, int numCapturesDuringLock)             throws Exception {         if (numCapturesDuringLock < 1) {             throw new IllegalArgumentException(""numCapturesBeforeLock must be no less than 1"");         }         if (VERBOSE) {             Log.v(TAG, ""Camera "" + mCamera.getId() + "": Testing auto AE mode and lock for mode ""                     + aeMode + "" with "" + numCapturesDuringLock + "" captures before lock"");         }          final int NUM_CAPTURES_BEFORE_LOCK = 2;         SimpleCaptureCallback listener =  new SimpleCaptureCallback();          CaptureResult[] resultsDuringLock = new CaptureResult[numCapturesDuringLock];         boolean canSetAeLock = mStaticInfo.isAeLockSupported();          // Reset the AE lock to OFF, since we are reusing this builder many times         if (canSetAeLock) {             requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, false);         }          // Just send several captures with auto AE, lock off.         CaptureRequest request = requestBuilder.build();         for (int i = 0; i < NUM_CAPTURES_BEFORE_LOCK; i++) {             mSession.capture(request, listener, mHandler);         }         waitForNumResults(listener, NUM_CAPTURES_BEFORE_LOCK);          if (!canSetAeLock) {             // Without AE lock, the remaining tests items won't work             return;         }          // Then fire several capture to lock the AE.         requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);          int requestCount = captureRequestsSynchronized(                 requestBuilder.build(), numCapturesDuringLock, listener, mHandler);          int[] sensitivities = new int[numCapturesDuringLock];         long[] expTimes = new long[numCapturesDuringLock];         Arrays.fill(sensitivities, -1);         Arrays.fill(expTimes, -1L);          // Get the AE lock on result and validate the exposure values.         waitForNumResults(listener, requestCount - numCapturesDuringLock);         for (int i = 0; i < resultsDuringLock.length; i++) {             resultsDuringLock[i] = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);         }          for (int i = 0; i < numCapturesDuringLock; i++) {             mCollector.expectKeyValueEquals(                     resultsDuringLock[i], CaptureResult.CONTROL_AE_LOCK, true);         }          // Can't read manual sensor/exposure settings without manual sensor         if (mStaticInfo.isCapabilitySupported(                 CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS)) {             int sensitivityLocked =                     getValueNotNull(resultsDuringLock[0], CaptureResult.SENSOR_SENSITIVITY);             long expTimeLocked =                     getValueNotNull(resultsDuringLock[0], CaptureResult.SENSOR_EXPOSURE_TIME);             for (int i = 1; i < resultsDuringLock.length; i++) {                 mCollector.expectKeyValueEquals(                         resultsDuringLock[i], CaptureResult.SENSOR_EXPOSURE_TIME, expTimeLocked);                 mCollector.expectKeyValueEquals(                         resultsDuringLock[i], CaptureResult.SENSOR_SENSITIVITY, sensitivityLocked);             }         }     }      /**      * Iterate through exposure times and sensitivities for manual AE control.      * <p>      * Use single request rather than repeating request to test manual exposure      * value change per frame control.      * </p>      */     private void aeManualControlTest()             throws Exception {         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         configurePreviewOutput(requestBuilder);          // Warm up pipeline for more accurate timing         SimpleCaptureCallback warmupListener =  new SimpleCaptureCallback();         mSession.setRepeatingRequest(requestBuilder.build(), warmupListener, mHandler);         warmupListener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);          // Do manual captures         requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CONTROL_AE_MODE_OFF);         SimpleCaptureCallback listener =  new SimpleCaptureCallback();          long[] expTimesNs = getExposureTimeTestValues();         int[] sensitivities = getSensitivityTestValues();         // Submit single request at a time, then verify the result.         for (int i = 0; i < expTimesNs.length; i++) {             for (int j = 0; j < sensitivities.length; j++) {                 if (VERBOSE) {                     Log.v(TAG, ""Camera "" + mCamera.getId() + "": Testing sensitivity ""                             + sensitivities[j] + "", exposure time "" + expTimesNs[i] + ""ns"");                 }                  changeExposure(requestBuilder, expTimesNs[i], sensitivities[j]);                 mSession.capture(requestBuilder.build(), listener, mHandler);                  // make sure timeout is long enough for long exposure time - add a 2x safety margin                 // to exposure time                 long timeoutMs = WAIT_FOR_RESULT_TIMEOUT_MS + 2 * expTimesNs[i] / 1000000;                 CaptureResult result = listener.getCaptureResult(timeoutMs);                 long resultExpTimeNs = getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);                 int resultSensitivity = getValueNotNull(result, CaptureResult.SENSOR_SENSITIVITY);                 validateExposureTime(expTimesNs[i], resultExpTimeNs);                 validateSensitivity(sensitivities[j], resultSensitivity);                 validateFrameDurationForCapture(result);             }         }         mSession.stopRepeating();          // TODO: Add another case to test where we can submit all requests, then wait for         // results, which will hide the pipeline latency. this is not only faster, but also         // test high speed per frame control and synchronization.     }       /**      * Verify black level lock control.      */     private void verifyBlackLevelLockResults(SimpleCaptureCallback listener, int numFramesVerified,             int maxLockOffCnt) throws Exception {         int noLockCnt = 0;         for (int i = 0; i < numFramesVerified; i++) {             CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);             Boolean blackLevelLock = result.get(CaptureResult.BLACK_LEVEL_LOCK);             assertNotNull(""Black level lock result shouldn't be null"", blackLevelLock);              // Count the lock == false result, which could possibly occur at most once.             if (blackLevelLock == false) {                 noLockCnt++;             }              if(VERBOSE) {                 Log.v(TAG, ""Black level lock result: "" + blackLevelLock);             }         }         assertTrue(""Black level lock OFF occurs "" + noLockCnt + "" times,  expect at most ""                 + maxLockOffCnt + "" for camera "" + mCamera.getId(), noLockCnt <= maxLockOffCnt);     }      /**      * Verify shading map for different shading modes.      */     private void verifyShadingMap(SimpleCaptureCallback listener, int numFramesVerified,             int shadingMode) throws Exception {          for (int i = 0; i < numFramesVerified; i++) {             CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);             mCollector.expectEquals(""Shading mode result doesn't match request"",                     shadingMode, result.get(CaptureResult.SHADING_MODE));             LensShadingMap mapObj = result.get(                     CaptureResult.STATISTICS_LENS_SHADING_CORRECTION_MAP);             assertNotNull(""Map object must not be null"", mapObj);             int numElementsInMap = mapObj.getGainFactorCount();             float[] map = new float[numElementsInMap];             mapObj.copyGainFactors(map, /*offset*/0);             assertNotNull(""Map must not be null"", map);             assertFalse(String.format(                     ""Map size %d should be less than %d"", numElementsInMap, MAX_SHADING_MAP_SIZE),                     numElementsInMap >= MAX_SHADING_MAP_SIZE);             assertFalse(String.format(""Map size %d should be no less than %d"", numElementsInMap,                     MIN_SHADING_MAP_SIZE), numElementsInMap < MIN_SHADING_MAP_SIZE);              if (shadingMode == CaptureRequest.SHADING_MODE_FAST ||                     shadingMode == CaptureRequest.SHADING_MODE_HIGH_QUALITY) {                 // shading mode is FAST or HIGH_QUALITY, expect to receive a map with all                 // elements >= 1.0f                  int badValueCnt = 0;                 // Detect the bad values of the map data.                 for (int j = 0; j < numElementsInMap; j++) {                     if (Float.isNaN(map[j]) || map[j] < 1.0f) {                         badValueCnt++;                     }                 }                 assertEquals(""Number of value in the map is "" + badValueCnt + "" out of ""                         + numElementsInMap, /*expected*/0, /*actual*/badValueCnt);             } else if (shadingMode == CaptureRequest.SHADING_MODE_OFF) {                 float[] unityMap = new float[numElementsInMap];                 Arrays.fill(unityMap, 1.0f);                 // shading mode is OFF, expect to receive a unity map.                 assertTrue(""Result map "" + Arrays.toString(map) + "" must be an unity map"",                         Arrays.equals(unityMap, map));             }         }     }      /**      * Test face detection for a camera.      */     private void faceDetectionTestByCamera() throws Exception {         int[] faceDetectModes = mStaticInfo.getAvailableFaceDetectModesChecked();          SimpleCaptureCallback listener;         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);          Size maxPreviewSz = mOrderedPreviewSizes.get(0); // Max preview size.         for (int mode : faceDetectModes) {             requestBuilder.set(CaptureRequest.STATISTICS_FACE_DETECT_MODE, mode);             if (VERBOSE) {                 Log.v(TAG, ""Start testing face detection mode "" + mode);             }              // Create a new listener for each run to avoid the results from one run spill             // into another run.             listener = new SimpleCaptureCallback();             startPreview(requestBuilder, maxPreviewSz, listener);             waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);             verifyFaceDetectionResults(listener, NUM_FACE_DETECTION_FRAMES_VERIFIED, mode);         }          stopPreview();     }      /**      * Verify face detection results for different face detection modes.      *      * @param listener The listener to get capture result      * @param numFramesVerified Number of results to be verified      * @param faceDetectionMode Face detection mode to be verified against      */     private void verifyFaceDetectionResults(SimpleCaptureCallback listener, int numFramesVerified,             int faceDetectionMode) {         for (int i = 0; i < numFramesVerified; i++) {             CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);             mCollector.expectEquals(""Result face detection mode should match the request"",                     faceDetectionMode, result.get(CaptureResult.STATISTICS_FACE_DETECT_MODE));              Face[] faces = result.get(CaptureResult.STATISTICS_FACES);             List<Integer> faceIds = new ArrayList<Integer>(faces.length);             List<Integer> faceScores = new ArrayList<Integer>(faces.length);             if (faceDetectionMode == CaptureResult.STATISTICS_FACE_DETECT_MODE_OFF) {                 mCollector.expectEquals(""Number of detection faces should always 0 for OFF mode"",                         0, faces.length);             } else if (faceDetectionMode == CaptureResult.STATISTICS_FACE_DETECT_MODE_SIMPLE) {                 for (Face face : faces) {                     mCollector.expectNotNull(""Face rectangle shouldn't be null"", face.getBounds());                     faceScores.add(face.getScore());                     mCollector.expectTrue(""Face id is expected to be -1 for SIMPLE mode"",                             face.getId() == Face.ID_UNSUPPORTED);                 }             } else if (faceDetectionMode == CaptureResult.STATISTICS_FACE_DETECT_MODE_FULL) {                 if (VERBOSE) {                     Log.v(TAG, ""Number of faces detected: "" + faces.length);                 }                  for (Face face : faces) {                     Rect faceBound;                     boolean faceRectAvailable =  mCollector.expectTrue(""Face rectangle ""                             + ""shouldn't be null"", face.getBounds() != null);                     if (!faceRectAvailable) {                         continue;                     }                     faceBound = face.getBounds();                      faceScores.add(face.getScore());                     faceIds.add(face.getId());                      mCollector.expectTrue(""Face id is shouldn't be -1 for FULL mode"",                             face.getId() != Face.ID_UNSUPPORTED);                     boolean leftEyeAvailable =                             mCollector.expectTrue(""Left eye position shouldn't be null"",                                     face.getLeftEyePosition() != null);                     boolean rightEyeAvailable =                             mCollector.expectTrue(""Right eye position shouldn't be null"",                                     face.getRightEyePosition() != null);                     boolean mouthAvailable =                             mCollector.expectTrue(""Mouth position shouldn't be null"",                             face.getMouthPosition() != null);                     // Eyes/mouth position should be inside of the face rect.                     if (leftEyeAvailable) {                         Point leftEye = face.getLeftEyePosition();                         mCollector.expectTrue(""Left eye "" + leftEye + ""should be""                                 + ""inside of face rect "" + faceBound,                                 faceBound.contains(leftEye.x, leftEye.y));                     }                     if (rightEyeAvailable) {                         Point rightEye = face.getRightEyePosition();                         mCollector.expectTrue(""Right eye "" + rightEye + ""should be""                                 + ""inside of face rect "" + faceBound,                                 faceBound.contains(rightEye.x, rightEye.y));                     }                     if (mouthAvailable) {                         Point mouth = face.getMouthPosition();                         mCollector.expectTrue(""Mouth "" + mouth +  "" should be inside of""                                 + "" face rect "" + faceBound,                                 faceBound.contains(mouth.x, mouth.y));                     }                 }             }             mCollector.expectValuesInRange(""Face scores are invalid"", faceScores,                     Face.SCORE_MIN, Face.SCORE_MAX);             mCollector.expectValuesUnique(""Face ids are invalid"", faceIds);         }     }      /**      * Test tone map mode and result by camera      */     private void toneMapTestByCamera() throws Exception {         if (!mStaticInfo.isManualToneMapSupported()) {             return;         }          CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         int[] toneMapModes = mStaticInfo.getAvailableToneMapModesChecked();         // Test AUTO modes first. Note that FAST/HQ must both present or not present         for (int i = 0; i < toneMapModes.length; i++) {             if (toneMapModes[i] == CaptureRequest.TONEMAP_MODE_FAST && i > 0) {                 int tmpMode = toneMapModes[0];                 toneMapModes[0] = CaptureRequest.TONEMAP_MODE_FAST;                 toneMapModes[i] = tmpMode;             }             if (toneMapModes[i] == CaptureRequest.TONEMAP_MODE_HIGH_QUALITY && i > 1) {                 int tmpMode = toneMapModes[1];                 toneMapModes[1] = CaptureRequest.TONEMAP_MODE_HIGH_QUALITY;                 toneMapModes[i] = tmpMode;             }         }         for (int mode : toneMapModes) {             if (VERBOSE) {                 Log.v(TAG, ""Testing tonemap mode "" + mode);             }              requestBuilder.set(CaptureRequest.TONEMAP_MODE, mode);             switch (mode) {                 case CaptureRequest.TONEMAP_MODE_CONTRAST_CURVE:                     TonemapCurve toneCurve = new TonemapCurve(TONEMAP_CURVE_LINEAR,                             TONEMAP_CURVE_LINEAR, TONEMAP_CURVE_LINEAR);                     requestBuilder.set(CaptureRequest.TONEMAP_CURVE, toneCurve);                     testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);                      toneCurve = new TonemapCurve(TONEMAP_CURVE_SRGB,                             TONEMAP_CURVE_SRGB, TONEMAP_CURVE_SRGB);                     requestBuilder.set(CaptureRequest.TONEMAP_CURVE, toneCurve);                     testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);                     break;                 case CaptureRequest.TONEMAP_MODE_GAMMA_VALUE:                     requestBuilder.set(CaptureRequest.TONEMAP_GAMMA, 1.0f);                     testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);                     requestBuilder.set(CaptureRequest.TONEMAP_GAMMA, 2.2f);                     testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);                     requestBuilder.set(CaptureRequest.TONEMAP_GAMMA, 5.0f);                     testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);                     break;                 case CaptureRequest.TONEMAP_MODE_PRESET_CURVE:                     requestBuilder.set(CaptureRequest.TONEMAP_PRESET_CURVE,                             CaptureRequest.TONEMAP_PRESET_CURVE_REC709);                     testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);                     requestBuilder.set(CaptureRequest.TONEMAP_PRESET_CURVE,                             CaptureRequest.TONEMAP_PRESET_CURVE_SRGB);                     testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);                     break;                 default:                     testToneMapMode(NUM_FRAMES_VERIFIED, requestBuilder);                     break;             }         }       }      /**      * Test tonemap mode with speficied request settings      *      * @param numFramesVerified Number of results to be verified      * @param requestBuilder the request builder of settings to be tested      */     private void testToneMapMode (int numFramesVerified,             CaptureRequest.Builder requestBuilder)  throws Exception  {         final int MIN_TONEMAP_CURVE_POINTS = 2;         final Float ZERO = new Float(0);         final Float ONE = new Float(1.0f);          SimpleCaptureCallback listener = new SimpleCaptureCallback();         int tonemapMode = requestBuilder.get(CaptureRequest.TONEMAP_MODE);         Size maxPreviewSz = mOrderedPreviewSizes.get(0); // Max preview size.         startPreview(requestBuilder, maxPreviewSz, listener);         waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);          int maxCurvePoints = mStaticInfo.getMaxTonemapCurvePointChecked();         for (int i = 0; i < numFramesVerified; i++) {             CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);             mCollector.expectEquals(""Capture result tonemap mode should match request"", tonemapMode,                     result.get(CaptureResult.TONEMAP_MODE));             TonemapCurve tc = getValueNotNull(result, CaptureResult.TONEMAP_CURVE);             int pointCount = tc.getPointCount(TonemapCurve.CHANNEL_RED);             float[] mapRed = new float[pointCount * TonemapCurve.POINT_SIZE];             pointCount = tc.getPointCount(TonemapCurve.CHANNEL_GREEN);             float[] mapGreen = new float[pointCount * TonemapCurve.POINT_SIZE];             pointCount = tc.getPointCount(TonemapCurve.CHANNEL_BLUE);             float[] mapBlue = new float[pointCount * TonemapCurve.POINT_SIZE];             tc.copyColorCurve(TonemapCurve.CHANNEL_RED, mapRed, 0);             tc.copyColorCurve(TonemapCurve.CHANNEL_GREEN, mapGreen, 0);             tc.copyColorCurve(TonemapCurve.CHANNEL_BLUE, mapBlue, 0);             if (tonemapMode == CaptureResult.TONEMAP_MODE_CONTRAST_CURVE) {                 /**                  * TODO: need figure out a good way to measure the difference                  * between request and result, as they may have different array                  * size.                  */             } else if (tonemapMode == CaptureResult.TONEMAP_MODE_GAMMA_VALUE) {                 mCollector.expectEquals(""Capture result gamma value should match request"",                         requestBuilder.get(CaptureRequest.TONEMAP_GAMMA),                         result.get(CaptureResult.TONEMAP_GAMMA));             } else if (tonemapMode == CaptureResult.TONEMAP_MODE_PRESET_CURVE) {                 mCollector.expectEquals(""Capture result preset curve should match request"",                         requestBuilder.get(CaptureRequest.TONEMAP_PRESET_CURVE),                         result.get(CaptureResult.TONEMAP_PRESET_CURVE));             }              // Tonemap curve result availability and basic validity check for all modes.             mCollector.expectValuesInRange(""Tonemap curve red values are out of range"",                     CameraTestUtils.toObject(mapRed), /*min*/ZERO, /*max*/ONE);             mCollector.expectInRange(""Tonemap curve red length is out of range"",                     mapRed.length, MIN_TONEMAP_CURVE_POINTS, maxCurvePoints * 2);             mCollector.expectValuesInRange(""Tonemap curve green values are out of range"",                     CameraTestUtils.toObject(mapGreen), /*min*/ZERO, /*max*/ONE);             mCollector.expectInRange(""Tonemap curve green length is out of range"",                     mapGreen.length, MIN_TONEMAP_CURVE_POINTS, maxCurvePoints * 2);             mCollector.expectValuesInRange(""Tonemap curve blue values are out of range"",                     CameraTestUtils.toObject(mapBlue), /*min*/ZERO, /*max*/ONE);             mCollector.expectInRange(""Tonemap curve blue length is out of range"",                     mapBlue.length, MIN_TONEMAP_CURVE_POINTS, maxCurvePoints * 2);              // Make sure capture result tonemap has identical channels.             if (mStaticInfo.isMonochromeCamera()) {                 mCollector.expectEquals(""Capture result tonemap of monochrome camera should "" +                         ""have same dimension for all channels"", mapRed.length, mapGreen.length);                 mCollector.expectEquals(""Capture result tonemap of monochrome camera should "" +                         ""have same dimension for all channels"", mapRed.length, mapBlue.length);                  if (mapRed.length == mapGreen.length && mapRed.length == mapBlue.length) {                     boolean isIdentical = true;                     for (int j = 0; j < mapRed.length; j++) {                         isIdentical = (mapRed[j] == mapGreen[j] && mapRed[j] == mapBlue[j]);                         if (!isIdentical)                             break;                     }                     mCollector.expectTrue(""Capture result tonemap of monochrome camera should "" +                             ""be identical between all channels"", isIdentical);                 }             }         }         stopPreview();     }      /**      * Test awb mode control.      * <p>      * Test each supported AWB mode, verify the AWB mode in capture result      * matches request. When AWB is locked, the color correction gains and      * transform should remain unchanged.      * </p>      */     private void awbModeAndLockTestByCamera() throws Exception {         int[] awbModes = mStaticInfo.getAwbAvailableModesChecked();         Size maxPreviewSize = mOrderedPreviewSizes.get(0);         boolean canSetAwbLock = mStaticInfo.isAwbLockSupported();         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         startPreview(requestBuilder, maxPreviewSize, /*listener*/null);          for (int mode : awbModes) {             SimpleCaptureCallback listener;             requestBuilder.set(CaptureRequest.CONTROL_AWB_MODE, mode);             listener = new SimpleCaptureCallback();             mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);             waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);              // Verify AWB mode in capture result.             verifyCaptureResultForKey(CaptureResult.CONTROL_AWB_MODE, mode, listener,                     NUM_FRAMES_VERIFIED);              if (mode == CameraMetadata.CONTROL_AWB_MODE_AUTO && canSetAwbLock) {                 // Verify color correction transform and gains stay unchanged after a lock.                 requestBuilder.set(CaptureRequest.CONTROL_AWB_LOCK, true);                 listener = new SimpleCaptureCallback();                 mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);                 waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);                  if (mStaticInfo.areKeysAvailable(CaptureResult.CONTROL_AWB_STATE)) {                     waitForResultValue(listener, CaptureResult.CONTROL_AWB_STATE,                             CaptureResult.CONTROL_AWB_STATE_LOCKED, NUM_RESULTS_WAIT_TIMEOUT);                 }              }             // Don't verify auto mode result if AWB lock is not supported             if (mode != CameraMetadata.CONTROL_AWB_MODE_AUTO || canSetAwbLock) {                 verifyAwbCaptureResultUnchanged(listener, NUM_FRAMES_VERIFIED);             }         }     }      private void verifyAwbCaptureResultUnchanged(SimpleCaptureCallback listener,             int numFramesVerified) {         // Skip check if cc gains/transform/mode are not available         if (!mStaticInfo.areKeysAvailable(                 CaptureResult.COLOR_CORRECTION_GAINS,                 CaptureResult.COLOR_CORRECTION_TRANSFORM,                 CaptureResult.COLOR_CORRECTION_MODE)) {             return;         }          CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);         RggbChannelVector lockedGains =                 getValueNotNull(result, CaptureResult.COLOR_CORRECTION_GAINS);         ColorSpaceTransform lockedTransform =                 getValueNotNull(result, CaptureResult.COLOR_CORRECTION_TRANSFORM);          for (int i = 0; i < numFramesVerified; i++) {             result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);             // Color correction mode check is skipped here, as it is checked in colorCorrectionTest.             validateColorCorrectionResult(result, result.get(CaptureResult.COLOR_CORRECTION_MODE));              RggbChannelVector gains = getValueNotNull(result, CaptureResult.COLOR_CORRECTION_GAINS);             ColorSpaceTransform transform =                     getValueNotNull(result, CaptureResult.COLOR_CORRECTION_TRANSFORM);             mCollector.expectEquals(""Color correction gains should remain unchanged after awb lock"",                     lockedGains, gains);             mCollector.expectEquals(""Color correction transform should remain unchanged after""                     + "" awb lock"", lockedTransform, transform);         }     }      /**      * Test AF mode control.      * <p>      * Test all supported AF modes, verify the AF mode in capture result matches      * request. When AF mode is one of the CONTROL_AF_MODE_CONTINUOUS_* mode,      * verify if the AF can converge to PASSIVE_FOCUSED or PASSIVE_UNFOCUSED      * state within certain amount of frames.      * </p>      */     private void afModeTestByCamera() throws Exception {         int[] afModes = mStaticInfo.getAfAvailableModesChecked();         Size maxPreviewSize = mOrderedPreviewSizes.get(0);         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         startPreview(requestBuilder, maxPreviewSize, /*listener*/null);          for (int mode : afModes) {             SimpleCaptureCallback listener;             requestBuilder.set(CaptureRequest.CONTROL_AF_MODE, mode);             listener = new SimpleCaptureCallback();             mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);             waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);              // Verify AF mode in capture result.             verifyCaptureResultForKey(CaptureResult.CONTROL_AF_MODE, mode, listener,                     NUM_FRAMES_VERIFIED);              // Verify AF can finish a scan for CONTROL_AF_MODE_CONTINUOUS_* modes.             // In LEGACY mode, a transition to one of the continuous AF modes does not necessarily             // result in a passive AF call if the camera has already been focused, and the scene has             // not changed enough to trigger an AF pass.  Skip this constraint for LEGACY.             if (mStaticInfo.isHardwareLevelAtLeastLimited() &&                     (mode == CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE ||                     mode == CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO)) {                 List<Integer> afStateList = new ArrayList<Integer>();                 afStateList.add(CaptureResult.CONTROL_AF_STATE_PASSIVE_FOCUSED);                 afStateList.add(CaptureResult.CONTROL_AF_STATE_PASSIVE_UNFOCUSED);                 waitForAnyResultValue(listener, CaptureResult.CONTROL_AF_STATE, afStateList,                         NUM_RESULTS_WAIT_TIMEOUT);             }         }     }      /**      * Test video and optical stabilizations if they are supported by a given camera.      */     private void stabilizationTestByCamera() throws Exception {         // video stabilization test.         List<Key<?>> keys = mStaticInfo.getCharacteristics().getKeys();          Integer[] videoStabModes = (keys.contains(CameraCharacteristics.                 CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES)) ?                 CameraTestUtils.toObject(mStaticInfo.getAvailableVideoStabilizationModesChecked()) :                     new Integer[0];         int[] opticalStabModes = (keys.contains(                 CameraCharacteristics.LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION)) ?                 mStaticInfo.getAvailableOpticalStabilizationChecked() : new int[0];          Size maxPreviewSize = mOrderedPreviewSizes.get(0);         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         SimpleCaptureCallback listener = new SimpleCaptureCallback();         startPreview(requestBuilder, maxPreviewSize, listener);          for (Integer mode : videoStabModes) {             listener = new SimpleCaptureCallback();             requestBuilder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE, mode);             mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);             waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);             // Video stabilization could return any modes.             verifyAnyCaptureResultForKey(CaptureResult.CONTROL_VIDEO_STABILIZATION_MODE,                     videoStabModes, listener, NUM_FRAMES_VERIFIED);         }          for (int mode : opticalStabModes) {             listener = new SimpleCaptureCallback();             requestBuilder.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE, mode);             mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);             waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);             verifyCaptureResultForKey(CaptureResult.LENS_OPTICAL_STABILIZATION_MODE, mode,                     listener, NUM_FRAMES_VERIFIED);         }          stopPreview();     }      private void digitalZoomTestByCamera(Size previewSize) throws Exception {         final int ZOOM_STEPS = 15;         final PointF[] TEST_ZOOM_CENTERS;         final float maxZoom = mStaticInfo.getAvailableMaxDigitalZoomChecked();         final float ZOOM_ERROR_MARGIN = 0.01f;         if (Math.abs(maxZoom - 1.0f) < ZOOM_ERROR_MARGIN) {             // It doesn't make much sense to test the zoom if the device effectively supports             // no zoom.             return;         }          final int croppingType = mStaticInfo.getScalerCroppingTypeChecked();         if (croppingType == CameraCharacteristics.SCALER_CROPPING_TYPE_FREEFORM) {             // Set the four corners in a way that the minimally allowed zoom factor is 2x.             float normalizedLeft = 0.25f;             float normalizedTop = 0.25f;             float normalizedRight = 0.75f;             float normalizedBottom = 0.75f;             // If the max supported zoom is too small, make sure we at least test the max             // Zoom is tested for the four corners.             if (maxZoom < 2.0f) {                 normalizedLeft = 0.5f / maxZoom;                 normalizedTop = 0.5f / maxZoom;                 normalizedRight = 1.0f - normalizedLeft;                 normalizedBottom = 1.0f - normalizedTop;             }             TEST_ZOOM_CENTERS = new PointF[] {                 new PointF(0.5f, 0.5f),   // Center point                 new PointF(normalizedLeft, normalizedTop),     // top left corner zoom                 new PointF(normalizedRight, normalizedTop),    // top right corner zoom                 new PointF(normalizedLeft, normalizedBottom),  // bottom left corner zoom                 new PointF(normalizedRight, normalizedBottom), // bottom right corner zoom             };              if (VERBOSE) {                 Log.v(TAG, ""Testing zoom with CROPPING_TYPE = FREEFORM"");             }         } else {             // CENTER_ONLY             TEST_ZOOM_CENTERS = new PointF[] {                     new PointF(0.5f, 0.5f),   // Center point             };              if (VERBOSE) {                 Log.v(TAG, ""Testing zoom with CROPPING_TYPE = CENTER_ONLY"");             }         }          final Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();         final Rect defaultCropRegion = new Rect(0, 0,                 activeArraySize.width(), activeArraySize.height());         Rect[] cropRegions = new Rect[ZOOM_STEPS];         MeteringRectangle[][] expectRegions = new MeteringRectangle[ZOOM_STEPS][];         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         SimpleCaptureCallback listener = new SimpleCaptureCallback();          updatePreviewSurface(previewSize);         configurePreviewOutput(requestBuilder);          CaptureRequest[] requests = new CaptureRequest[ZOOM_STEPS];          // Set algorithm regions         final int METERING_RECT_RATIO = 10;         final MeteringRectangle[][] defaultMeteringRects = new MeteringRectangle[][] {                 {                     new MeteringRectangle (                         /*x*/0, /*y*/0, activeArraySize.width(), activeArraySize.height(),                         /*meteringWeight*/1), /* full active region */                 },                 {                     new MeteringRectangle (                         /*x*/0, /*y*/0, activeArraySize.width()/METERING_RECT_RATIO,                         activeArraySize.height()/METERING_RECT_RATIO,                         /*meteringWeight*/1),                 },                 {                     new MeteringRectangle (                         /*x*/(int)(activeArraySize.width() * (0.5f - 0.5f/METERING_RECT_RATIO)),                         /*y*/(int)(activeArraySize.height() * (0.5f - 0.5f/METERING_RECT_RATIO)),                         activeArraySize.width()/METERING_RECT_RATIO,                         activeArraySize.height()/METERING_RECT_RATIO,                         /*meteringWeight*/1),                 },         };          final int CAPTURE_SUBMIT_REPEAT;         {             int maxLatency = mStaticInfo.getSyncMaxLatency();             if (maxLatency == CameraMetadata.SYNC_MAX_LATENCY_UNKNOWN) {                 CAPTURE_SUBMIT_REPEAT = NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY + 1;             } else {                 CAPTURE_SUBMIT_REPEAT = maxLatency + 1;             }         }          if (VERBOSE) {             Log.v(TAG, ""Testing zoom with CAPTURE_SUBMIT_REPEAT = "" + CAPTURE_SUBMIT_REPEAT);         }          for (MeteringRectangle[] meteringRect : defaultMeteringRects) {             for (int algo = 0; algo < NUM_ALGORITHMS; algo++) {                 update3aRegion(requestBuilder, algo,  meteringRect);             }              for (PointF center : TEST_ZOOM_CENTERS) {                 Rect previousCrop = null;                  for (int i = 0; i < ZOOM_STEPS; i++) {                     /*                      * Submit capture request                      */                     float zoomFactor = (float) (1.0f + (maxZoom - 1.0) * i / ZOOM_STEPS);                     cropRegions[i] = getCropRegionForZoom(zoomFactor, center,                             maxZoom, defaultCropRegion);                     if (VERBOSE) {                         Log.v(TAG, ""Testing Zoom for factor "" + zoomFactor + "" and center "" +                                 center + "" The cropRegion is "" + cropRegions[i] +                                 "" Preview size is "" + previewSize);                     }                     requestBuilder.set(CaptureRequest.SCALER_CROP_REGION, cropRegions[i]);                     requests[i] = requestBuilder.build();                     for (int j = 0; j < CAPTURE_SUBMIT_REPEAT; ++j) {                         if (VERBOSE) {                             Log.v(TAG, ""submit crop region "" + cropRegions[i]);                         }                         mSession.capture(requests[i], listener, mHandler);                     }                      /*                      * Validate capture result                      */                     waitForNumResults(listener, CAPTURE_SUBMIT_REPEAT - 1); // Drop first few frames                     CaptureResult result = listener.getCaptureResultForRequest(                             requests[i], NUM_RESULTS_WAIT_TIMEOUT);                     Rect cropRegion = getValueNotNull(result, CaptureResult.SCALER_CROP_REGION);                      /*                      * Validate resulting crop regions                      */                     if (previousCrop != null) {                         Rect currentCrop = cropRegion;                         mCollector.expectTrue(String.format(                                 ""Crop region should shrink or stay the same "" +                                         ""(previous = %s, current = %s)"",                                         previousCrop, currentCrop),                                 previousCrop.equals(currentCrop) ||                                     (previousCrop.width() > currentCrop.width() &&                                      previousCrop.height() > currentCrop.height()));                     }                      if (mStaticInfo.isHardwareLevelAtLeastLimited()) {                         mCollector.expectRectsAreSimilar(                                 ""Request and result crop region should be similar"",                                 cropRegions[i], cropRegion, CROP_REGION_ERROR_PERCENT_DELTA);                     }                      if (croppingType == SCALER_CROPPING_TYPE_CENTER_ONLY) {                         mCollector.expectRectCentered(                                 ""Result crop region should be centered inside the active array"",                                 new Size(activeArraySize.width(), activeArraySize.height()),                                 cropRegion, CROP_REGION_ERROR_PERCENT_CENTERED);                     }                      /*                      * Validate resulting metering regions                      */                      // Use the actual reported crop region to calculate the resulting metering region                     expectRegions[i] = getExpectedOutputRegion(                             /*requestRegion*/meteringRect,                             /*cropRect*/     cropRegion);                      // Verify Output 3A region is intersection of input 3A region and crop region                     for (int algo = 0; algo < NUM_ALGORITHMS; algo++) {                         validate3aRegion(result, algo, expectRegions[i], false/*scaleByZoomRatio*/);                     }                      previousCrop = cropRegion;                 }                  if (maxZoom > 1.0f) {                     mCollector.expectTrue(                             String.format(""Most zoomed-in crop region should be smaller"" +                                             ""than active array w/h"" +                                             ""(last crop = %s, active array = %s)"",                                             previousCrop, activeArraySize),                                 (previousCrop.width() < activeArraySize.width() &&                                  previousCrop.height() < activeArraySize.height()));                 }             }         }     }      private void zoomRatioTestByCamera(Size previewSize) throws Exception {         final int ZOOM_STEPS = 15;         final Range<Float> zoomRatioRange = mStaticInfo.getZoomRatioRangeChecked();         // The error margin is derive from a VGA size camera zoomed all the way to 10x, in which         // case the cropping error can be as large as 480/46 - 480/48 = 0.435.         final float ZOOM_ERROR_MARGIN = 0.05f;          final Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();         final Rect defaultCropRegion =                 new Rect(0, 0, activeArraySize.width(), activeArraySize.height());         MeteringRectangle[][] expectRegions = new MeteringRectangle[ZOOM_STEPS][];         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         requestBuilder.set(CaptureRequest.SCALER_CROP_REGION, defaultCropRegion);         SimpleCaptureCallback listener = new SimpleCaptureCallback();          updatePreviewSurface(previewSize);         configurePreviewOutput(requestBuilder);          // Set algorithm regions to full active region         final MeteringRectangle[] defaultMeteringRect = new MeteringRectangle[] {                 new MeteringRectangle (                         /*x*/0, /*y*/0, activeArraySize.width(), activeArraySize.height(),                         /*meteringWeight*/1)         };          for (int algo = 0; algo < NUM_ALGORITHMS; algo++) {             update3aRegion(requestBuilder, algo,  defaultMeteringRect);         }          final int captureSubmitRepeat;         {             int maxLatency = mStaticInfo.getSyncMaxLatency();             if (maxLatency == CameraMetadata.SYNC_MAX_LATENCY_UNKNOWN) {                 captureSubmitRepeat = NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY + 1;             } else {                 captureSubmitRepeat = maxLatency + 1;             }         }          float previousRatio = zoomRatioRange.getLower();         for (int i = 0; i < ZOOM_STEPS; i++) {             /*              * Submit capture request              */             float zoomFactor = zoomRatioRange.getLower() + (zoomRatioRange.getUpper() -                     zoomRatioRange.getLower()) * i / ZOOM_STEPS;             if (VERBOSE) {                 Log.v(TAG, ""Testing Zoom ratio "" + zoomFactor + "" Preview size is "" + previewSize);             }             requestBuilder.set(CaptureRequest.CONTROL_ZOOM_RATIO, zoomFactor);             CaptureRequest request = requestBuilder.build();             for (int j = 0; j < captureSubmitRepeat; ++j) {                 mSession.capture(request, listener, mHandler);             }              /*              * Validate capture result              */             waitForNumResults(listener, captureSubmitRepeat - 1); // Drop first few frames             CaptureResult result = listener.getCaptureResultForRequest(                     request, NUM_RESULTS_WAIT_TIMEOUT);             float resultZoomRatio = getValueNotNull(result, CaptureResult.CONTROL_ZOOM_RATIO);             Rect cropRegion = getValueNotNull(result, CaptureResult.SCALER_CROP_REGION);              /*              * Validate resulting crop regions and zoom ratio              */             mCollector.expectTrue(String.format(                     ""Zoom ratio should increase or stay the same "" +                             ""(previous = %f, current = %f)"",                             previousRatio, resultZoomRatio),                     Math.abs(previousRatio - resultZoomRatio) < ZOOM_ERROR_MARGIN ||                         (previousRatio < resultZoomRatio));              mCollector.expectTrue(String.format(                     ""Request and result zoom ratio should be similar "" +                     ""(requested = %f, result = %f"", zoomFactor, resultZoomRatio),                     Math.abs(zoomFactor - resultZoomRatio)/zoomFactor <= ZOOM_ERROR_MARGIN);              //In case zoom ratio is converted to crop region at HAL, due to error magnification             //when converting to post-zoom crop region, scale the error threshold for crop region             //check.             float errorMultiplier = Math.max(1.0f, zoomFactor);             if (mStaticInfo.isHardwareLevelAtLeastLimited()) {                 mCollector.expectRectsAreSimilar(                         ""Request and result crop region should be similar"",                         defaultCropRegion, cropRegion,                         CROP_REGION_ERROR_PERCENT_DELTA * errorMultiplier);             }              mCollector.expectRectCentered(                     ""Result crop region should be centered inside the active array"",                     new Size(activeArraySize.width(), activeArraySize.height()),                     cropRegion, CROP_REGION_ERROR_PERCENT_CENTERED * errorMultiplier);              /*              * Validate resulting metering regions              */             // Use the actual reported crop region to calculate the resulting metering region             expectRegions[i] = getExpectedOutputRegion(                     /*requestRegion*/defaultMeteringRect,                     /*cropRect*/     cropRegion);              // Verify Output 3A region is intersection of input 3A region and crop region             boolean scaleByZoomRatio = zoomFactor > 1.0f;             for (int algo = 0; algo < NUM_ALGORITHMS; algo++) {                 validate3aRegion(result, algo, expectRegions[i], scaleByZoomRatio);             }              previousRatio = resultZoomRatio;         }     }      private void digitalZoomPreviewCombinationTestByCamera() throws Exception {         final double ASPECT_RATIO_THRESHOLD = 0.001;         List<Double> aspectRatiosTested = new ArrayList<Double>();         Size maxPreviewSize = mOrderedPreviewSizes.get(0);         aspectRatiosTested.add((double)(maxPreviewSize.getWidth()) / maxPreviewSize.getHeight());          for (Size size : mOrderedPreviewSizes) {             // Max preview size was already tested in testDigitalZoom test. skip it.             if (size.equals(maxPreviewSize)) {                 continue;             }              // Only test the largest size for each aspect ratio.             double aspectRatio = (double)(size.getWidth()) / size.getHeight();             if (isAspectRatioContained(aspectRatiosTested, aspectRatio, ASPECT_RATIO_THRESHOLD)) {                 continue;             }              if (VERBOSE) {                 Log.v(TAG, ""Test preview size "" + size.toString() + "" digital zoom"");             }              aspectRatiosTested.add(aspectRatio);             digitalZoomTestByCamera(size);         }     }      private static boolean isAspectRatioContained(List<Double> aspectRatioList,             double aspectRatio, double delta) {         for (Double ratio : aspectRatioList) {             if (Math.abs(ratio - aspectRatio) < delta) {                 return true;             }         }          return false;     }      private void sceneModeTestByCamera() throws Exception {         int[] sceneModes = mStaticInfo.getAvailableSceneModesChecked();         Size maxPreviewSize = mOrderedPreviewSizes.get(0);         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         SimpleCaptureCallback listener = new SimpleCaptureCallback();         requestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_USE_SCENE_MODE);         startPreview(requestBuilder, maxPreviewSize, listener);          for(int mode : sceneModes) {             requestBuilder.set(CaptureRequest.CONTROL_SCENE_MODE, mode);             listener = new SimpleCaptureCallback();             mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);             waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);              verifyCaptureResultForKey(CaptureResult.CONTROL_SCENE_MODE,                     mode, listener, NUM_FRAMES_VERIFIED);             // This also serves as purpose of showing preview for NUM_FRAMES_VERIFIED             verifyCaptureResultForKey(CaptureResult.CONTROL_MODE,                     CaptureRequest.CONTROL_MODE_USE_SCENE_MODE, listener, NUM_FRAMES_VERIFIED);         }     }      private void effectModeTestByCamera() throws Exception {         int[] effectModes = mStaticInfo.getAvailableEffectModesChecked();         Size maxPreviewSize = mOrderedPreviewSizes.get(0);         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         requestBuilder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO);         SimpleCaptureCallback listener = new SimpleCaptureCallback();         startPreview(requestBuilder, maxPreviewSize, listener);          for(int mode : effectModes) {             requestBuilder.set(CaptureRequest.CONTROL_EFFECT_MODE, mode);             listener = new SimpleCaptureCallback();             mSession.setRepeatingRequest(requestBuilder.build(), listener, mHandler);             waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);              verifyCaptureResultForKey(CaptureResult.CONTROL_EFFECT_MODE,                     mode, listener, NUM_FRAMES_VERIFIED);             // This also serves as purpose of showing preview for NUM_FRAMES_VERIFIED             verifyCaptureResultForKey(CaptureResult.CONTROL_MODE,                     CaptureRequest.CONTROL_MODE_AUTO, listener, NUM_FRAMES_VERIFIED);         }     }      private void extendedSceneModeTestByCamera(List<Range<Integer>> fpsRanges) throws Exception {         Capability[] extendedSceneModeCaps = mStaticInfo.getAvailableExtendedSceneModeCapsChecked();         if (extendedSceneModeCaps.length == 0) {             return;         }          Size maxPreviewSize = mOrderedPreviewSizes.get(0);         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);          for (Capability cap : extendedSceneModeCaps) {             int mode = cap.getMode();             requestBuilder.set(CaptureRequest.CONTROL_EXTENDED_SCENE_MODE, mode);              // Test that DISABLED and BOKEH_CONTINUOUS mode doesn't slow down the frame rate             if (mode == CaptureRequest.CONTROL_EXTENDED_SCENE_MODE_DISABLED ||                     mode == CaptureRequest.CONTROL_EXTENDED_SCENE_MODE_BOKEH_CONTINUOUS) {                 verifyFpsNotSlowDown(requestBuilder, NUM_FRAMES_VERIFIED, fpsRanges);             }              Range<Float> zoomRange = cap.getZoomRatioRange();             float[] zoomRatios = new float[]{zoomRange.getLower(), zoomRange.getUpper()};             for (float ratio : zoomRatios) {                 SimpleCaptureCallback listener = new SimpleCaptureCallback();                 requestBuilder.set(CaptureRequest.CONTROL_ZOOM_RATIO, ratio);                 startPreview(requestBuilder, maxPreviewSize, listener);                 waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);                  verifyCaptureResultForKey(CaptureResult.CONTROL_EXTENDED_SCENE_MODE,                         mode, listener, NUM_FRAMES_VERIFIED);                 verifyCaptureResultForKey(CaptureResult.CONTROL_ZOOM_RATIO,                         ratio, listener, NUM_FRAMES_VERIFIED);             }         }     }      //----------------------------------------------------------------     //---------Below are common functions for all tests.--------------     //----------------------------------------------------------------      /**      * Enable exposure manual control and change exposure and sensitivity and      * clamp the value into the supported range.      */     private void changeExposure(CaptureRequest.Builder requestBuilder,             long expTime, int sensitivity) {         // Check if the max analog sensitivity is available and no larger than max sensitivity.  The         // max analog sensitivity is not actually used here. This is only an extra correctness         // check.         mStaticInfo.getMaxAnalogSensitivityChecked();          expTime = mStaticInfo.getExposureClampToRange(expTime);         sensitivity = mStaticInfo.getSensitivityClampToRange(sensitivity);          requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CONTROL_AE_MODE_OFF);         requestBuilder.set(CaptureRequest.SENSOR_EXPOSURE_TIME, expTime);         requestBuilder.set(CaptureRequest.SENSOR_SENSITIVITY, sensitivity);     }     /**      * Enable exposure manual control and change exposure time and      * clamp the value into the supported range.      *      * <p>The sensitivity is set to default value.</p>      */     private void changeExposure(CaptureRequest.Builder requestBuilder, long expTime) {         changeExposure(requestBuilder, expTime, DEFAULT_SENSITIVITY);     }      /**      * Get the exposure time array that contains multiple exposure time steps in      * the exposure time range, in nanoseconds.      */     private long[] getExposureTimeTestValues() {         long[] testValues = new long[DEFAULT_NUM_EXPOSURE_TIME_STEPS + 1];         long maxExpTime = mStaticInfo.getExposureMaximumOrDefault(DEFAULT_EXP_TIME_NS);         long minExpTime = mStaticInfo.getExposureMinimumOrDefault(DEFAULT_EXP_TIME_NS);          long range = maxExpTime - minExpTime;         double stepSize = range / (double)DEFAULT_NUM_EXPOSURE_TIME_STEPS;         for (int i = 0; i < testValues.length; i++) {             testValues[i] = maxExpTime - (long)(stepSize * i);             testValues[i] = mStaticInfo.getExposureClampToRange(testValues[i]);         }          return testValues;     }      /**      * Generate test focus distances in range of [0, minFocusDistance] in increasing order.      *      * @param repeatMin number of times minValue will be repeated.      * @param repeatMax number of times maxValue will be repeated.      */     private float[] getFocusDistanceTestValuesInOrder(int repeatMin, int repeatMax) {         int totalCount = NUM_TEST_FOCUS_DISTANCES + 1 + repeatMin + repeatMax;         float[] testValues = new float[totalCount];         float minValue = 0;         float maxValue = mStaticInfo.getMinimumFocusDistanceChecked();          float range = maxValue - minValue;         float stepSize = range / NUM_TEST_FOCUS_DISTANCES;          for (int i = 0; i < repeatMin; i++) {             testValues[i] = minValue;         }         for (int i = 0; i <= NUM_TEST_FOCUS_DISTANCES; i++) {             testValues[repeatMin+i] = minValue + stepSize * i;         }         for (int i = 0; i < repeatMax; i++) {             testValues[repeatMin+NUM_TEST_FOCUS_DISTANCES+1+i] =                     maxValue;         }          return testValues;     }      /**      * Get the sensitivity array that contains multiple sensitivity steps in the      * sensitivity range.      * <p>      * Sensitivity number of test values is determined by      * {@value #DEFAULT_SENSITIVITY_STEP_SIZE} and sensitivity range, and      * bounded by {@value #DEFAULT_NUM_SENSITIVITY_STEPS}.      * </p>      */     private int[] getSensitivityTestValues() {         int maxSensitivity = mStaticInfo.getSensitivityMaximumOrDefault(                 DEFAULT_SENSITIVITY);         int minSensitivity = mStaticInfo.getSensitivityMinimumOrDefault(                 DEFAULT_SENSITIVITY);          int range = maxSensitivity - minSensitivity;         int stepSize = DEFAULT_SENSITIVITY_STEP_SIZE;         int numSteps = range / stepSize;         // Bound the test steps to avoid supper long test.         if (numSteps > DEFAULT_NUM_SENSITIVITY_STEPS) {             numSteps = DEFAULT_NUM_SENSITIVITY_STEPS;             stepSize = range / numSteps;         }         int[] testValues = new int[numSteps + 1];         for (int i = 0; i < testValues.length; i++) {             testValues[i] = maxSensitivity - stepSize * i;             testValues[i] = mStaticInfo.getSensitivityClampToRange(testValues[i]);         }          return testValues;     }      /**      * Validate the AE manual control exposure time.      *      * <p>Exposure should be close enough, and only round down if they are not equal.</p>      *      * @param request Request exposure time      * @param result Result exposure time      */     private void validateExposureTime(long request, long result) {         long expTimeDelta = request - result;         long expTimeErrorMargin = (long)(Math.max(EXPOSURE_TIME_ERROR_MARGIN_NS, request                 * EXPOSURE_TIME_ERROR_MARGIN_RATE));         // First, round down not up, second, need close enough.         mCollector.expectTrue(""Exposture time is invalid for AE manaul control test, request: ""                 + request + "" result: "" + result,                 expTimeDelta < expTimeErrorMargin && expTimeDelta >= 0);     }      /**      * Validate AE manual control sensitivity.      *      * @param request Request sensitivity      * @param result Result sensitivity      */     private void validateSensitivity(int request, int result) {         float sensitivityDelta = request - result;         float sensitivityErrorMargin = request * SENSITIVITY_ERROR_MARGIN_RATE;         // First, round down not up, second, need close enough.         mCollector.expectTrue(""Sensitivity is invalid for AE manaul control test, request: ""                 + request + "" result: "" + result,                 sensitivityDelta < sensitivityErrorMargin && sensitivityDelta >= 0);     }      /**      * Validate frame duration for a given capture.      *      * <p>Frame duration should be longer than exposure time.</p>      *      * @param result The capture result for a given capture      */     private void validateFrameDurationForCapture(CaptureResult result) {         long expTime = getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);         long frameDuration = getValueNotNull(result, CaptureResult.SENSOR_FRAME_DURATION);         if (VERBOSE) {             Log.v(TAG, ""frame duration: "" + frameDuration + "" Exposure time: "" + expTime);         }          mCollector.expectTrue(String.format(""Frame duration (%d) should be longer than exposure""                 + "" time (%d) for a given capture"", frameDuration, expTime),                 frameDuration >= expTime);          validatePipelineDepth(result);     }      /**      * Basic verification for the control mode capture result.      *      * @param key The capture result key to be verified against      * @param requestMode The request mode for this result      * @param listener The capture listener to get capture results      * @param numFramesVerified The number of capture results to be verified      */     private <T> void verifyCaptureResultForKey(CaptureResult.Key<T> key, T requestMode,             SimpleCaptureCallback listener, int numFramesVerified) {         for (int i = 0; i < numFramesVerified; i++) {             CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);             validatePipelineDepth(result);             T resultMode = getValueNotNull(result, key);             if (VERBOSE) {                 Log.v(TAG, ""Expect value: "" + requestMode.toString() + "" result value: ""                         + resultMode.toString());             }             mCollector.expectEquals(""Key "" + key.getName() + "" result should match request"",                     requestMode, resultMode);         }     }      /**      * Basic verification that the value of a capture result key should be one of the expected      * values.      *      * @param key The capture result key to be verified against      * @param expectedModes The list of any possible expected modes for this result      * @param listener The capture listener to get capture results      * @param numFramesVerified The number of capture results to be verified      */     private <T> void verifyAnyCaptureResultForKey(CaptureResult.Key<T> key, T[] expectedModes,             SimpleCaptureCallback listener, int numFramesVerified) {         for (int i = 0; i < numFramesVerified; i++) {             CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);             validatePipelineDepth(result);             T resultMode = getValueNotNull(result, key);             if (VERBOSE) {                 Log.v(TAG, ""Expect values: "" + Arrays.toString(expectedModes) + "" result value: ""                         + resultMode.toString());             }             // Capture result should be one of the expected values.             mCollector.expectContains(expectedModes, resultMode);         }     }      /**      * Verify if the fps is slow down for given input request with certain      * controls inside.      * <p>      * This method selects a max preview size for each fps range, and then      * configure the preview stream. Preview is started with the max preview      * size, and then verify if the result frame duration is in the frame      * duration range.      * </p>      *      * @param requestBuilder The request builder that contains post-processing      *            controls that could impact the output frame rate, such as      *            {@link CaptureRequest.NOISE_REDUCTION_MODE}. The value of      *            these controls must be set to some values such that the frame      *            rate is not slow down.      * @param numFramesVerified The number of frames to be verified      * @param fpsRanges The fps ranges to be verified      */     private void verifyFpsNotSlowDown(CaptureRequest.Builder requestBuilder,             int numFramesVerified, List<Range<Integer>> fpsRanges )  throws Exception {         boolean frameDurationAvailable = true;         // Allow a few frames for AE to settle on target FPS range         final int NUM_FRAME_TO_SKIP = 6;         float frameDurationErrorMargin = FRAME_DURATION_ERROR_MARGIN;         if (!mStaticInfo.areKeysAvailable(CaptureResult.SENSOR_FRAME_DURATION)) {             frameDurationAvailable = false;             // Allow a larger error margin (1.5%) for timestamps             frameDurationErrorMargin = 0.015f;         }         if (mStaticInfo.isExternalCamera()) {             // Allow a even larger error margin (15%) for external camera timestamps             frameDurationErrorMargin = 0.15f;         }          boolean antiBandingOffIsSupported = mStaticInfo.isAntiBandingOffModeSupported();         Range<Integer> fpsRange;         SimpleCaptureCallback resultListener;          for (int i = 0; i < fpsRanges.size(); i += 1) {             fpsRange = fpsRanges.get(i);             Size previewSz = getMaxPreviewSizeForFpsRange(fpsRange);             // If unable to find a preview size, then log the failure, and skip this run.             if (previewSz == null) {                 if (mStaticInfo.isCapabilitySupported(                         CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {                     mCollector.addMessage(String.format(                             ""Unable to find a preview size supporting given fps range %s"",                             fpsRange));                 }                 continue;             }              if (VERBOSE) {                 Log.v(TAG, String.format(""Test fps range %s for preview size %s"",                         fpsRange, previewSz.toString()));             }             requestBuilder.set(CaptureReques"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.net.cts.NetworkStatsBinderTest"	"testAccessUidStatsFromBinder"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/NetworkStatsBinderTest.java"	""	"public void testAccessUidStatsFromBinder() throws Exception {         final int myUid = Process.myUid();         final List<Integer> testUidList = new ArrayList<>();          // Prepare uid list for testing.         testUidList.add(INVALID_UID);         testUidList.add(Process.ROOT_UID);         testUidList.add(Process.SYSTEM_UID);         testUidList.add(myUid);         testUidList.add(Process.LAST_APPLICATION_UID);         testUidList.add(Process.LAST_APPLICATION_UID + 1);         // If available, pick another existing uid for testing that is not already contained         // in the list above.         final int notMyUid = getFirstAppUidThat(uid -> uid >= 0 && !testUidList.contains(uid));         if (notMyUid != INVALID_UID) testUidList.add(notMyUid);          for (final int uid : testUidList) {             for (int i = 0; i < mUidStatsQueryOpArray.size(); i++) {                 final int type = mUidStatsQueryOpArray.keyAt(i);                 try {                     final long uidStatsFromBinder = getUidStatsFromBinder(uid, type);                     final long uidTrafficStats = mUidStatsQueryOpArray.get(type).apply(uid);                      // Verify that UNSUPPORTED is returned if the uid is not current app uid.                     if (uid != myUid) {                         assertEquals(uidStatsFromBinder, TrafficStats.UNSUPPORTED);                     }                     // Verify that returned result is the same with the result get from                     // TrafficStats.                     // TODO: If the test is flaky then it should instead assert that the values                     //  are approximately similar.                     assertEquals(""uidStats is not matched for query type "" + type                                     + "", uid="" + uid + "", myUid="" + myUid, uidTrafficStats,                             uidStatsFromBinder);                 } catch (IllegalAccessException e) {                     /* Java language access prevents exploitation. */                     return;                 } catch (InvocationTargetException e) {                     /* Underlying method has been changed. */                     return;                 } catch (ClassNotFoundException e) {                     /* not vulnerable if hidden API no longer available */                     return;                 } catch (NoSuchMethodException e) {                     /* not vulnerable if hidden API no longer available */                     return;                 } catch (RemoteException e) {                     return;                 }             }         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest"	"testAvailableStreamConfigs"	"CtsCameraTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java"	""	"public void testAvailableStreamConfigs() throws Exception {         boolean firstBackFacingCamera = true;         for (int i = 0; i < mAllCameraIds.length; i++) {             CameraCharacteristics c = mCharacteristics.get(i);             StreamConfigurationMap config =                     c.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(String.format(""No stream configuration map found for: ID %s"",                     mAllCameraIds[i]), config);             int[] outputFormats = config.getOutputFormats();              int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);             assertNotNull(""android.request.availableCapabilities must never be null"",                     actualCapabilities);              // Check required formats exist (JPEG, and YUV_420_888).             if (!arrayContains(actualCapabilities, BC)) {                 Log.i(TAG, ""Camera "" + mAllCameraIds[i] +                     "": BACKWARD_COMPATIBLE capability not supported, skipping test"");                 continue;             }              boolean isMonochromeWithY8 = arrayContains(actualCapabilities, MONOCHROME)                     && arrayContains(outputFormats, ImageFormat.Y8);             boolean isHiddenPhysicalCamera = !arrayContains(mCameraIdsUnderTest, mAllCameraIds[i]);             boolean supportHeic = arrayContains(outputFormats, ImageFormat.HEIC);              assertArrayContains(                     String.format(""No valid YUV_420_888 preview formats found for: ID %s"",                             mAllCameraIds[i]), outputFormats, ImageFormat.YUV_420_888);             if (isMonochromeWithY8) {                 assertArrayContains(                         String.format(""No valid Y8 preview formats found for: ID %s"",                                 mAllCameraIds[i]), outputFormats, ImageFormat.Y8);             }             assertArrayContains(String.format(""No JPEG image format for: ID %s"",                     mAllCameraIds[i]), outputFormats, ImageFormat.JPEG);              Size[] yuvSizes = config.getOutputSizes(ImageFormat.YUV_420_888);             Size[] y8Sizes = config.getOutputSizes(ImageFormat.Y8);             Size[] jpegSizes = config.getOutputSizes(ImageFormat.JPEG);             Size[] heicSizes = config.getOutputSizes(ImageFormat.HEIC);             Size[] privateSizes = config.getOutputSizes(ImageFormat.PRIVATE);              CameraTestUtils.assertArrayNotEmpty(yuvSizes,                     String.format(""No sizes for preview format %x for: ID %s"",                             ImageFormat.YUV_420_888, mAllCameraIds[i]));             if (isMonochromeWithY8) {                 CameraTestUtils.assertArrayNotEmpty(y8Sizes,                     String.format(""No sizes for preview format %x for: ID %s"",                             ImageFormat.Y8, mAllCameraIds[i]));             }              Rect activeRect = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);              int activeArrayHeight = activeRect.height();             int activeArrayWidth = activeRect.width();             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth() ;             Integer lensFacing = c.get(CameraCharacteristics.LENS_FACING);             assertNotNull(""Can't get lens facing info for camera id: "" + mAllCameraIds[i],                     lensFacing);              // Check that the sensor sizes are atleast what the CDD specifies             switch(lensFacing) {                 case CameraCharacteristics.LENS_FACING_FRONT:                     assertTrue(""Front Sensor resolution should be at least "" +                             MIN_FRONT_SENSOR_RESOLUTION + "" pixels, is ""+ sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_RESOLUTION);                     break;                 case CameraCharacteristics.LENS_FACING_BACK:                     if (firstBackFacingCamera) {                         assertTrue(""Back Sensor resolution should be at least ""                                 + MIN_BACK_SENSOR_RESOLUTION +                                 "" pixels, is ""+ sensorResolution,                                 sensorResolution >= MIN_BACK_SENSOR_RESOLUTION);                         firstBackFacingCamera = false;                     }                     break;                 default:                     break;             }              Integer hwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);              if (activeArrayWidth >= FULLHD.getWidth() &&                     activeArrayHeight >= FULLHD.getHeight()) {                 assertArrayContainsAnyOf(String.format(                         ""Required FULLHD size not found for format %x for: ID %s"",                         ImageFormat.JPEG, mAllCameraIds[i]), jpegSizes,                         new Size[] {FULLHD, FULLHD_ALT});                 if (supportHeic) {                     assertArrayContainsAnyOf(String.format(                             ""Required FULLHD size not found for format %x for: ID %s"",                             ImageFormat.HEIC, mAllCameraIds[i]), heicSizes,                             new Size[] {FULLHD, FULLHD_ALT});                 }             }              if (activeArrayWidth >= HD.getWidth() &&                     activeArrayHeight >= HD.getHeight()) {                 assertArrayContains(String.format(                         ""Required HD size not found for format %x for: ID %s"",                         ImageFormat.JPEG, mAllCameraIds[i]), jpegSizes, HD);                 if (supportHeic) {                     assertArrayContains(String.format(                             ""Required HD size not found for format %x for: ID %s"",                             ImageFormat.HEIC, mAllCameraIds[i]), heicSizes, HD);                 }             }              if (activeArrayWidth >= VGA.getWidth() &&                     activeArrayHeight >= VGA.getHeight()) {                 assertArrayContains(String.format(                         ""Required VGA size not found for format %x for: ID %s"",                         ImageFormat.JPEG, mAllCameraIds[i]), jpegSizes, VGA);                 if (supportHeic) {                     assertArrayContains(String.format(                             ""Required VGA size not found for format %x for: ID %s"",                             ImageFormat.HEIC, mAllCameraIds[i]), heicSizes, VGA);                 }             }              if (activeArrayWidth >= QVGA.getWidth() &&                     activeArrayHeight >= QVGA.getHeight()) {                 assertArrayContains(String.format(                         ""Required QVGA size not found for format %x for: ID %s"",                         ImageFormat.JPEG, mAllCameraIds[i]), jpegSizes, QVGA);                 if (supportHeic) {                     assertArrayContains(String.format(                             ""Required QVGA size not found for format %x for: ID %s"",                             ImageFormat.HEIC, mAllCameraIds[i]), heicSizes, QVGA);                 }              }             if (activeArrayWidth >= HD.getWidth() &&                     activeArrayHeight >= HD.getHeight()) {                 assertArrayContains(String.format(                         ""Required HD size not found for format %x for: ID %s"",                         ImageFormat.JPEG, mAllCameraIds[i]), jpegSizes, HD);                 if (supportHeic) {                     assertArrayContains(String.format(                             ""Required HD size not found for format %x for: ID %s"",                             ImageFormat.HEIC, mAllCameraIds[i]), heicSizes, HD);                 }             }              if (activeArrayWidth >= VGA.getWidth() &&                     activeArrayHeight >= VGA.getHeight()) {                 assertArrayContains(String.format(                         ""Required VGA size not found for format %x for: ID %s"",                         ImageFormat.JPEG, mAllCameraIds[i]), jpegSizes, VGA);                 if (supportHeic) {                     assertArrayContains(String.format(                             ""Required VGA size not found for format %x for: ID %s"",                             ImageFormat.HEIC, mAllCameraIds[i]), heicSizes, VGA);                 }             }              if (activeArrayWidth >= QVGA.getWidth() &&                     activeArrayHeight >= QVGA.getHeight()) {                 assertArrayContains(String.format(                         ""Required QVGA size not found for format %x for: ID %s"",                         ImageFormat.JPEG, mAllCameraIds[i]), jpegSizes, QVGA);                 if (supportHeic) {                     assertArrayContains(String.format(                             ""Required QVGA size not found for format %x for: ID %s"",                             ImageFormat.HEIC, mAllCameraIds[i]), heicSizes, QVGA);                 }             }              ArrayList<Size> jpegSizesList = new ArrayList<>(Arrays.asList(jpegSizes));             ArrayList<Size> yuvSizesList = new ArrayList<>(Arrays.asList(yuvSizes));             ArrayList<Size> privateSizesList = new ArrayList<>(Arrays.asList(privateSizes));             boolean isExternalCamera = (hwLevel ==                     CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL);             Size maxVideoSize = null;             if (isExternalCamera || isHiddenPhysicalCamera) {                 // TODO: for now, use FULLHD 30 as largest possible video size for external camera.                 // For hidden physical camera, since we don't require CamcorderProfile to be                 // available, use FULLHD 30 as maximum video size as well.                 List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(                         mAllCameraIds[i], mCameraManager, FULLHD);                 for (Size sz : videoSizes) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, sz);                     // Give some margin for rounding error                     if (minFrameDuration < (1e9 / 29.9)) {                         maxVideoSize = sz;                         break;                     }                 }             } else {                 int cameraId = Integer.valueOf(mAllCameraIds[i]);                 CamcorderProfile maxVideoProfile = CamcorderProfile.get(                         cameraId, CamcorderProfile.QUALITY_HIGH);                 maxVideoSize = new Size(                         maxVideoProfile.videoFrameWidth, maxVideoProfile.videoFrameHeight);             }             if (maxVideoSize == null) {                 fail(""Camera "" + mAllCameraIds[i] + "" does not support any 30fps video output"");             }              // Handle FullHD special case first             if (jpegSizesList.contains(FULLHD)) {                 if (compareHardwareLevel(hwLevel, LEVEL_3) >= 0 || hwLevel == FULL ||                         (hwLevel == LIMITED &&                         maxVideoSize.getWidth() >= FULLHD.getWidth() &&                         maxVideoSize.getHeight() >= FULLHD.getHeight())) {                     boolean yuvSupportFullHD = yuvSizesList.contains(FULLHD) ||                             yuvSizesList.contains(FULLHD_ALT);                     boolean privateSupportFullHD = privateSizesList.contains(FULLHD) ||                             privateSizesList.contains(FULLHD_ALT);                     assertTrue(""Full device FullHD YUV size not found"", yuvSupportFullHD);                     assertTrue(""Full device FullHD PRIVATE size not found"", privateSupportFullHD);                      if (isMonochromeWithY8) {                         ArrayList<Size> y8SizesList = new ArrayList<>(Arrays.asList(y8Sizes));                         boolean y8SupportFullHD = y8SizesList.contains(FULLHD) ||                                 y8SizesList.contains(FULLHD_ALT);                         assertTrue(""Full device FullHD Y8 size not found"", y8SupportFullHD);                     }                 }                 // remove all FullHD or FullHD_Alt sizes for the remaining of the test                 jpegSizesList.remove(FULLHD);                 jpegSizesList.remove(FULLHD_ALT);             }              // Check all sizes other than FullHD             if (hwLevel == LIMITED) {                 // Remove all jpeg sizes larger than max video size                 ArrayList<Size> toBeRemoved = new ArrayList<>();                 for (Size size : jpegSizesList) {                     if (size.getWidth() >= maxVideoSize.getWidth() &&                             size.getHeight() >= maxVideoSize.getHeight()) {                         toBeRemoved.add(size);                     }                 }                 jpegSizesList.removeAll(toBeRemoved);             }              if (compareHardwareLevel(hwLevel, LEVEL_3) >= 0 || hwLevel == FULL ||                     hwLevel == LIMITED) {                 if (!yuvSizesList.containsAll(jpegSizesList)) {                     for (Size s : jpegSizesList) {                         if (!yuvSizesList.contains(s)) {                             fail(""Size "" + s + "" not found in YUV format"");                         }                     }                 }                  if (isMonochromeWithY8) {                     ArrayList<Size> y8SizesList = new ArrayList<>(Arrays.asList(y8Sizes));                     if (!y8SizesList.containsAll(jpegSizesList)) {                         for (Size s : jpegSizesList) {                             if (!y8SizesList.contains(s)) {                                 fail(""Size "" + s + "" not found in Y8 format"");                             }                         }                     }                 }             }              if (!privateSizesList.containsAll(yuvSizesList)) {                 for (Size s : yuvSizesList) {                     if (!privateSizesList.contains(s)) {                         fail(""Size "" + s + "" not found in PRIVATE format"");                     }                 }             }         }     }      private void verifyCommonRecommendedConfiguration(String id, CameraCharacteristics c,             RecommendedStreamConfigurationMap config, boolean checkNoInput,             boolean checkNoHighRes, boolean checkNoHighSpeed, boolean checkNoPrivate,             boolean checkNoDepth) {         StreamConfigurationMap fullConfig = c.get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         assertNotNull(String.format(""No stream configuration map found for ID: %s!"", id),                 fullConfig);          Set<Integer> recommendedOutputFormats = config.getOutputFormats();          if (checkNoInput) {             Set<Integer> inputFormats = config.getInputFormats();             assertTrue(String.format(""Recommended configuration must not include any input "" +                     ""streams for ID: %s"", id),                     ((inputFormats == null) || (inputFormats.size() == 0)));         }          if (checkNoHighRes) {             for (int format : recommendedOutputFormats) {                 Set<Size> highResSizes = config.getHighResolutionOutputSizes(format);                 assertTrue(String.format(""Recommended configuration should not include any "" +                         ""high resolution sizes, which cannot operate at full "" +                         ""BURST_CAPTURE rate for ID: %s"", id),                         ((highResSizes == null) || (highResSizes.size() == 0)));             }         }          if (checkNoHighSpeed) {             Set<Size> highSpeedSizes = config.getHighSpeedVideoSizes();             assertTrue(String.format(""Recommended configuration must not include any high "" +                     ""speed configurations for ID: %s"", id),                     ((highSpeedSizes == null) || (highSpeedSizes.size() == 0)));         }          int[] exhaustiveOutputFormats = fullConfig.getOutputFormats();         for (Integer formatInteger : recommendedOutputFormats) {             int format = formatInteger.intValue();             assertArrayContains(String.format(""Unsupported recommended output format: %d for "" +                     ""ID: %s "", format, id), exhaustiveOutputFormats, format);             Set<Size> recommendedSizes = config.getOutputSizes(format);              switch (format) {                 case ImageFormat.PRIVATE:                     if (checkNoPrivate) {                         fail(String.format(""Recommended configuration must not include "" +                                 ""PRIVATE format entries for ID: %s"", id));                     }                      Set<Size> classOutputSizes = config.getOutputSizes(ImageReader.class);                     assertCollectionContainsAnyOf(String.format(""Recommended output sizes for "" +                             ""ImageReader class don't match the output sizes for the "" +                             ""corresponding format for ID: %s"", id), classOutputSizes,                             recommendedSizes);                     break;                 case ImageFormat.DEPTH16:                 case ImageFormat.DEPTH_POINT_CLOUD:                     if (checkNoDepth) {                         fail(String.format(""Recommended configuration must not include any DEPTH "" +                                 ""formats for ID: %s"", id));                     }                     break;                 default:             }             Size [] exhaustiveSizes = fullConfig.getOutputSizes(format);             for (Size sz : recommendedSizes) {                 assertArrayContains(String.format(""Unsupported recommended size %s for "" +                         ""format: %d for ID: %s"", sz.toString(), format, id),                         exhaustiveSizes, sz);                  long recommendedMinDuration = config.getOutputMinFrameDuration(format, sz);                 long availableMinDuration = fullConfig.getOutputMinFrameDuration(format, sz);                 assertTrue(String.format(""Recommended minimum frame duration %d for size "" +                         ""%s format: %d doesn't match with currently available minimum"" +                         "" frame duration of %d for ID: %s"", recommendedMinDuration,                         sz.toString(), format, availableMinDuration, id),                         (recommendedMinDuration == availableMinDuration));                 long recommendedStallDuration = config.getOutputStallDuration(format, sz);                 long availableStallDuration = fullConfig.getOutputStallDuration(format, sz);                 assertTrue(String.format(""Recommended stall duration %d for size %s"" +                         "" format: %d doesn't match with currently available stall "" +                         ""duration of %d for ID: %s"", recommendedStallDuration,                         sz.toString(), format, availableStallDuration, id),                         (recommendedStallDuration == availableStallDuration));                  ImageReader reader = ImageReader.newInstance(sz.getWidth(), sz.getHeight(), format,                         /*maxImages*/1);                 Surface readerSurface = reader.getSurface();                 assertTrue(String.format(""ImageReader surface using format %d and size %s is not"" +                         "" supported for ID: %s"", format, sz.toString(), id),                         config.isOutputSupportedFor(readerSurface));                 if (format == ImageFormat.PRIVATE) {                     long classMinDuration = config.getOutputMinFrameDuration(ImageReader.class, sz);                     assertTrue(String.format(""Recommended minimum frame duration %d for size "" +                             ""%s format: %d doesn't match with the duration %d for "" +                             ""ImageReader class of the same size"", recommendedMinDuration,                             sz.toString(), format, classMinDuration),                             classMinDuration == recommendedMinDuration);                     long classStallDuration = config.getOutputStallDuration(ImageReader.class, sz);                     assertTrue(String.format(""Recommended stall duration %d for size "" +                             ""%s format: %d doesn't match with the stall duration %d for "" +                             ""ImageReader class of the same size"", recommendedStallDuration,                             sz.toString(), format, classStallDuration),                             classStallDuration == recommendedStallDuration);                 }             }         }     }      private void verifyRecommendedPreviewConfiguration(String cameraId, CameraCharacteristics c,             RecommendedStreamConfigurationMap previewConfig) {         verifyCommonRecommendedConfiguration(cameraId, c, previewConfig, /*checkNoInput*/ true,                 /*checkNoHighRes*/ true, /*checkNoHighSpeed*/ true, /*checkNoPrivate*/ false,                 /*checkNoDepth*/ true);          Set<Integer> outputFormats = previewConfig.getOutputFormats();         assertTrue(String.format(""No valid YUV_420_888 and PRIVATE preview "" +                 ""formats found in recommended preview configuration for ID: %s"", cameraId),                 outputFormats.containsAll(Arrays.asList(new Integer(ImageFormat.YUV_420_888),                         new Integer(ImageFormat.PRIVATE))));     }      private void verifyRecommendedVideoConfiguration(String cameraId, CameraCharacteristics c,             RecommendedStreamConfigurationMap videoConfig) {         verifyCommonRecommendedConfiguration(cameraId, c, videoConfig, /*checkNoInput*/ true,                 /*checkNoHighRes*/ true, /*checkNoHighSpeed*/ false, /*checkNoPrivate*/false,                 /*checkNoDepth*/ true);          Set<Size> highSpeedSizes = videoConfig.getHighSpeedVideoSizes();         StreamConfigurationMap fullConfig = c.get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         assertNotNull(""No stream configuration map found!"", fullConfig);         Size [] availableHighSpeedSizes = fullConfig.getHighSpeedVideoSizes();         if ((highSpeedSizes != null) && (highSpeedSizes.size() > 0)) {             for (Size sz : highSpeedSizes) {                 assertArrayContains(String.format(""Recommended video configuration includes "" +                         ""unsupported high speed configuration with size %s for ID: %s"",                         sz.toString(), cameraId), availableHighSpeedSizes, sz);                 Set<Range<Integer>>  highSpeedFpsRanges =                     videoConfig.getHighSpeedVideoFpsRangesFor(sz);                 Range<Integer> [] availableHighSpeedFpsRanges =                     fullConfig.getHighSpeedVideoFpsRangesFor(sz);                 for (Range<Integer> fpsRange : highSpeedFpsRanges) {                     assertArrayContains(String.format(""Recommended video configuration includes "" +                             ""unsupported high speed fps range [%d %d] for ID: %s"",                             fpsRange.getLower().intValue(), fpsRange.getUpper().intValue(),                             cameraId), availableHighSpeedFpsRanges, fpsRange);                 }             }         }          final int[] profileList = {             CamcorderProfile.QUALITY_2160P,             CamcorderProfile.QUALITY_1080P,             CamcorderProfile.QUALITY_480P,             CamcorderProfile.QUALITY_720P,             CamcorderProfile.QUALITY_CIF,             CamcorderProfile.QUALITY_HIGH,             CamcorderProfile.QUALITY_LOW,             CamcorderProfile.QUALITY_QCIF,             CamcorderProfile.QUALITY_QVGA,         };         Set<Size> privateSizeSet = videoConfig.getOutputSizes(ImageFormat.PRIVATE);         for (int profile : profileList) {             int idx = Integer.valueOf(cameraId);             if (CamcorderProfile.hasProfile(idx, profile)) {                 CamcorderProfile videoProfile = CamcorderProfile.get(idx, profile);                 Size profileSize  = new Size(videoProfile.videoFrameWidth,                         videoProfile.videoFrameHeight);                 assertCollectionContainsAnyOf(String.format(""Recommended video configuration "" +                         ""doesn't include supported video profile size %s with Private format "" +                         ""for ID: %s"", profileSize.toString(), cameraId), privateSizeSet,                         Arrays.asList(profileSize));             }         }     }      private Pair<Boolean, Size> isSizeWithinSensorMargin(Size sz, Size sensorSize) {         final float SIZE_ERROR_MARGIN = 0.03f;         float croppedWidth = (float)sensorSize.getWidth();         float croppedHeight = (float)sensorSize.getHeight();         float sensorAspectRatio = (float)sensorSize.getWidth() / (float)sensorSize.getHeight();         float maxAspectRatio = (float)sz.getWidth() / (float)sz.getHeight();         if (sensorAspectRatio < maxAspectRatio) {             croppedHeight = (float)sensorSize.getWidth() / maxAspectRatio;         } else if (sensorAspectRatio > maxAspectRatio) {             croppedWidth = (float)sensorSize.getHeight() * maxAspectRatio;         }         Size croppedSensorSize = new Size((int)croppedWidth, (int)croppedHeight);          Boolean match = new Boolean(             (sz.getWidth() <= croppedSensorSize.getWidth() * (1.0 + SIZE_ERROR_MARGIN) &&              sz.getWidth() >= croppedSensorSize.getWidth() * (1.0 - SIZE_ERROR_MARGIN) &&              sz.getHeight() <= croppedSensorSize.getHeight() * (1.0 + SIZE_ERROR_MARGIN) &&              sz.getHeight() >= croppedSensorSize.getHeight() * (1.0 - SIZE_ERROR_MARGIN)));          return Pair.create(match, croppedSensorSize);     }      private void verifyRecommendedSnapshotConfiguration(String cameraId, CameraCharacteristics c,             RecommendedStreamConfigurationMap snapshotConfig) {         verifyCommonRecommendedConfiguration(cameraId, c, snapshotConfig, /*checkNoInput*/ true,                 /*checkNoHighRes*/ false, /*checkNoHighSpeed*/ true, /*checkNoPrivate*/false,                 /*checkNoDepth*/ false);         Rect activeRect = CameraTestUtils.getValueNotNull(                 c, CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);         Size arraySize = new Size(activeRect.width(), activeRect.height());           ArraySet<Size> snapshotSizeSet = new ArraySet<>(snapshotConfig.getOutputSizes(                     ImageFormat.JPEG));         Set<Size> highResSnapshotSizeSet = snapshotConfig.getHighResolutionOutputSizes(                 ImageFormat.JPEG);         if (highResSnapshotSizeSet != null) {             snapshotSizeSet.addAll(highResSnapshotSizeSet);         }         Size[] snapshotSizes = new Size[snapshotSizeSet.size()];         snapshotSizes = snapshotSizeSet.toArray(snapshotSizes);         Size maxJpegSize = CameraTestUtils.getMaxSize(snapshotSizes);         assertTrue(String.format(""Maximum recommended Jpeg size %s should be within 3 percent "" +                 ""of the area of the advertised array size %s for ID: %s"",                 maxJpegSize.toString(), arraySize.toString(), cameraId),                 isSizeWithinSensorMargin(maxJpegSize, arraySize).first.booleanValue());     }      private void verifyRecommendedVideoSnapshotConfiguration(String cameraId,             CameraCharacteristics c,             RecommendedStreamConfigurationMap videoSnapshotConfig,             RecommendedStreamConfigurationMap videoConfig) {         verifyCommonRecommendedConfiguration(cameraId, c, videoSnapshotConfig,                 /*checkNoInput*/ true, /*checkNoHighRes*/ false, /*checkNoHighSpeed*/ true,                 /*checkNoPrivate*/ true, /*checkNoDepth*/ true);          Set<Integer> outputFormats = videoSnapshotConfig.getOutputFormats();         assertCollectionContainsAnyOf(String.format(""No valid JPEG format found "" +                 ""in recommended video snapshot configuration for ID: %s"", cameraId),                 outputFormats, Arrays.asList(new Integer(ImageFormat.JPEG)));         assertTrue(String.format(""Recommended video snapshot configuration must only advertise "" +                 ""JPEG format for ID: %s"", cameraId), outputFormats.size() == 1);          Set<Size> privateVideoSizeSet = videoConfig.getOutputSizes(ImageFormat.PRIVATE);         Size[] privateVideoSizes = new Size[privateVideoSizeSet.size()];         privateVideoSizes = privateVideoSizeSet.toArray(privateVideoSizes);         Size maxVideoSize = CameraTestUtils.getMaxSize(privateVideoSizes);         Set<Size> outputSizes = videoSnapshotConfig.getOutputSizes(ImageFormat.JPEG);         assertCollectionContainsAnyOf(String.format(""The maximum recommended video size %s "" +                 ""should be present in the recommended video snapshot configurations for ID: %s"",                 maxVideoSize.toString(), cameraId), outputSizes, Arrays.asList(maxVideoSize));     }      private void verifyRecommendedRawConfiguration(String cameraId,             CameraCharacteristics c, RecommendedStreamConfigurationMap rawConfig) {         verifyCommonRecommendedConfiguration(cameraId, c, rawConfig, /*checkNoInput*/ true,                 /*checkNoHighRes*/ false, /*checkNoHighSpeed*/ true, /*checkNoPrivate*/ true,                 /*checkNoDepth*/ true);          Set<Integer> outputFormats = rawConfig.getOutputFormats();         for (Integer outputFormatInteger : outputFormats) {             int outputFormat = outputFormatInteger.intValue();             switch (outputFormat) {                 case ImageFormat.RAW10:                 case ImageFormat.RAW12:                 case ImageFormat.RAW_PRIVATE:                 case ImageFormat.RAW_SENSOR:                     break;                 default:                     fail(String.format(""Recommended raw configuration map must not contain "" +                             "" non-RAW formats like: %d for ID: %s"", outputFormat, cameraId));              }         }     }      private void verifyRecommendedZSLConfiguration(String cameraId, CameraCharacteristics c,             RecommendedStreamConfigurationMap zslConfig) {         verifyCommonRecommendedConfiguration(cameraId, c, zslConfig, /*checkNoInput*/ false,                 /*checkNoHighRes*/ false, /*checkNoHighSpeed*/ true, /*checkNoPrivate*/ false,                 /*checkNoDepth*/ false);          StreamConfigurationMap fullConfig =             c.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         assertNotNull(String.format(""No stream configuration map found for ID: %s!"", cameraId),                 fullConfig);         Set<Integer> inputFormats = zslConfig.getInputFormats();         int [] availableInputFormats = fullConfig.getInputFormats();         for (Integer inputFormatInteger : inputFormats) {             int inputFormat = inputFormatInteger.intValue();             assertArrayContains(String.format(""Recommended ZSL configuration includes "" +                     ""unsupported input format %d for ID: %s"", inputFormat, cameraId),                     availableInputFormats, inputFormat);              Set<Size> inputSizes = zslConfig.getInputSizes(inputFormat);             Size [] availableInputSizes = fullConfig.getInputSizes(inputFormat);             assertTrue(String.format(""Recommended ZSL configuration input format %d includes "" +                     ""invalid input sizes for ID: %s"", inputFormat, cameraId),                     ((inputSizes != null) && (inputSizes.size() > 0)));             for (Size inputSize : inputSizes) {                 assertArrayContains(String.format(""Recommended ZSL configuration includes "" +                         ""unsupported input format %d with size %s ID: %s"", inputFormat,                         inputSize.toString(), cameraId), availableInputSizes, inputSize);             }             Set<Integer> validOutputFormats = zslConfig.getValidOutputFormatsForInput(inputFormat);             int [] availableValidOutputFormats = fullConfig.getValidOutputFormatsForInput(                     inputFormat);             for (Integer outputFormatInteger : validOutputFormats) {                 int outputFormat = outputFormatInteger.intValue();                 assertArrayContains(String.format(""Recommended ZSL configuration includes "" +                         ""unsupported output format %d for input %s ID: %s"", outputFormat,                         inputFormat, cameraId), availableValidOutputFormats, outputFormat);             }         }     }      private void checkFormatLatency(int format, long latencyThresholdMs,             RecommendedStreamConfigurationMap configMap) throws Exception {         Set<Size> availableSizes = configMap.getOutputSizes(format);         assertNotNull(String.format(""No available sizes for output format: %d"", format),                 availableSizes);          ImageReader previewReader = null;         long threshold = (long) (latencyThresholdMs * LATENCY_TOLERANCE_FACTOR);         // for each resolution, check that the end-to-end latency doesn't exceed the given threshold         for (Size sz : availableSizes) {             try {                 // Create ImageReaders, capture session and requests                 final ImageReader.OnImageAvailableListener mockListener = mock(                         ImageReader.OnImageAvailableListener.class);                 createDefaultImageReader(sz, format, MAX_NUM_IMAGES, mockListener);                 Size previewSize = mOrderedPreviewSizes.get(0);                 previewReader = createImageReader(previewSize, ImageFormat.YUV_420_888,                         MAX_NUM_IMAGES, new CameraTestUtils.ImageDropperListener());                 Surface previewSurface = previewReader.getSurface();                 List<Surface> surfaces = new ArrayList<Surface>();                 surfaces.add(previewSurface);                 surfaces.add(mReaderSurface);                 createSession(surfaces);                 CaptureRequest.Builder captureBuilder =                     mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);                 captureBuilder.addTarget(previewSurface);                 CaptureRequest request = captureBuilder.build();                  // Let preview run for a while                 startCapture(request, /*repeating*/ true, new SimpleCaptureCallback(), mHandler);                 Thread.sleep(PREVIEW_RUN_MS);                  // Start capture.                 captureBuilder = mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);                 captureBuilder.addTarget(mReaderSurface);                 request = captureBuilder.build();                  for (int i = 0; i < MAX_NUM_IMAGES; i++) {                     startCapture(request, /*repeating*/ false, new SimpleCaptureCallback(),                             mHandler);                     verify(mockListener, timeout(threshold).times(1)).onImageAvailable(                             any(ImageReader.class));                     reset(mockListener);                 }                  // stop capture.                 stopCapture(/*fast*/ false);             } finally {                 closeDefaultImageReader();                  if (previewReader != null) {                     previewReader.close();                     previewReader = null;                 }             }          }     }      private void verifyRecommendedLowLatencyConfiguration(String cameraId, CameraCharacteristics c,             RecommendedStreamConfigurationMap lowLatencyConfig) throws Exception {         verifyCommonRecommendedConfiguration(cameraId, c, lowLatencyConfig, /*checkNoInput*/ true,                 /*checkNoHighRes*/ false, /*checkNoHighSpeed*/ true, /*checkNoPrivate*/ false,                 /*checkNoDepth*/ true);          try {             openDevice(cameraId);              Set<Integer> formats = lowLatencyConfig.getOutputFormats();             for (Integer format : formats) {                 checkFormatLatency(format.intValue(), LOW_LATENCY_THRESHOLD_MS, lowLatencyConfig);             }         } finally {             closeDevice(cameraId);         }      }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest"	"testKeys"	"CtsCameraTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java"	""	"public void testKeys() {         for (int i = 0; i < mAllCameraIds.length; i++) {             CameraCharacteristics c = mCharacteristics.get(i);             mCollector.setCameraId(mAllCameraIds[i]);              if (VERBOSE) {                 Log.v(TAG, ""testKeys - testing characteristics for camera "" + mAllCameraIds[i]);             }              List<CameraCharacteristics.Key<?>> allKeys = c.getKeys();             assertNotNull(""Camera characteristics keys must not be null"", allKeys);             assertFalse(""Camera characteristics keys must have at least 1 key"",                     allKeys.isEmpty());              for (CameraCharacteristics.Key<?> key : allKeys) {                 assertKeyPrefixValid(key.getName());                  // All characteristics keys listed must never be null                 mCollector.expectKeyValueNotNull(c, key);                  // TODO: add a check that key must not be @hide             }              /*              * List of keys that must be present in camera characteristics (not null).              *              * Keys for LIMITED, FULL devices might be available despite lacking either              * the hardware level or the capability. This is *OK*. This only lists the              * *minimal* requirements for a key to be listed.              *              * LEGACY devices are a bit special since they map to api1 devices, so we know              * for a fact most keys are going to be illegal there so they should never be              * available.              *              * For LIMITED-level keys, if the level is >= LIMITED, then the capabilities are used to              * do the actual checking.              */             {                 //                                           (Key Name)                                     (HW Level)  (Capabilities <Var-Arg>)                 expectKeyAvailable(c, CameraCharacteristics.COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES     , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AVAILABLE_MODES                         , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AE_AVAILABLE_ANTIBANDING_MODES          , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AE_AVAILABLE_MODES                      , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES          , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AE_COMPENSATION_RANGE                   , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AE_COMPENSATION_STEP                    , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AE_LOCK_AVAILABLE                       , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES                      , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AVAILABLE_EFFECTS                       , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AVAILABLE_SCENE_MODES                   , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES     , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES                     , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_AWB_LOCK_AVAILABLE                      , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_MAX_REGIONS_AE                          , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_MAX_REGIONS_AF                          , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.CONTROL_MAX_REGIONS_AWB                         , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.EDGE_AVAILABLE_EDGE_MODES                       , FULL     ,   NONE                 );                 expectKeyAvailable(c, CameraCharacteristics.FLASH_INFO_AVAILABLE                            , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES             , OPT      ,   RAW                  );                 expectKeyAvailable(c, CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL                   , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.INFO_VERSION                                    , OPT      ,   NONE                 );                 expectKeyAvailable(c, CameraCharacteristics.JPEG_AVAILABLE_THUMBNAIL_SIZES                  , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.LENS_FACING                                     , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.LENS_INFO_AVAILABLE_APERTURES                   , FULL     ,   MANUAL_SENSOR        );                 expectKeyAvailable(c, CameraCharacteristics.LENS_INFO_AVAILABLE_FILTER_DENSITIES            , FULL     ,   MANUAL_SENSOR        );                 expectKeyAvailable(c, CameraCharacteristics.LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION       , LIMITED  ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.LENS_INFO_FOCUS_DISTANCE_CALIBRATION            , LIMITED  ,   MANUAL_SENSOR        );                 expectKeyAvailable(c, CameraCharacteristics.LENS_INFO_HYPERFOCAL_DISTANCE                   , LIMITED  ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE                , LIMITED  ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES                  , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.REQUEST_MAX_NUM_INPUT_STREAMS                   , OPT      ,   YUV_REPROCESS, OPAQUE_REPROCESS);                 expectKeyAvailable(c, CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP                 , OPT      ,   CONSTRAINED_HIGH_SPEED);                 expectKeyAvailable(c, CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_PROC                     , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_PROC_STALLING            , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.REQUEST_MAX_NUM_OUTPUT_RAW                      , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.REQUEST_PARTIAL_RESULT_COUNT                    , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.REQUEST_PIPELINE_MAX_DEPTH                      , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM               , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP                 , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.SCALER_CROPPING_TYPE                            , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_BLACK_LEVEL_PATTERN                      , FULL     ,   RAW                  );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE                   , OPT      ,   BC, RAW              );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT            , FULL     ,   RAW                  );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_INFO_EXPOSURE_TIME_RANGE                 , FULL     ,   MANUAL_SENSOR        );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_INFO_MAX_FRAME_DURATION                  , FULL     ,   MANUAL_SENSOR        );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE                    , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_INFO_SENSITIVITY_RANGE                   , FULL     ,   MANUAL_SENSOR        );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_INFO_WHITE_LEVEL                         , OPT      ,   RAW                  );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE                    , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_MAX_ANALOG_SENSITIVITY                   , FULL     ,   MANUAL_SENSOR        );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_ORIENTATION                              , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.SHADING_AVAILABLE_MODES                         , LIMITED  ,   MANUAL_POSTPROC, RAW );                 expectKeyAvailable(c, CameraCharacteristics.STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES     , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES   , OPT      ,   RAW                  );                 expectKeyAvailable(c, CameraCharacteristics.STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES, LIMITED  ,   RAW                  );                 expectKeyAvailable(c, CameraCharacteristics.STATISTICS_INFO_MAX_FACE_COUNT                  , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.SYNC_MAX_LATENCY                                , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.TONEMAP_AVAILABLE_TONE_MAP_MODES                , FULL     ,   MANUAL_POSTPROC      );                 expectKeyAvailable(c, CameraCharacteristics.TONEMAP_MAX_CURVE_POINTS                        , FULL     ,   MANUAL_POSTPROC      );                  // Future: Use column editors for modifying above, ignore line length to keep 1 key per line                  // TODO: check that no other 'android' keys are listed in #getKeys if they aren't in the above list             }              int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);             assertNotNull(""android.request.availableCapabilities must never be null"",                     actualCapabilities);             boolean isMonochrome = arrayContains(actualCapabilities,                     CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME);             if (!isMonochrome) {                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM1                   , OPT      ,   RAW                  );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_COLOR_TRANSFORM1                         , OPT      ,   RAW                  );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_FORWARD_MATRIX1                          , OPT      ,   RAW                  );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT1                    , OPT      ,   RAW                  );                   // Only check for these if the second reference illuminant is included                 if (allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT2)) {                     expectKeyAvailable(c, CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT2                    , OPT      ,   RAW                  );                     expectKeyAvailable(c, CameraCharacteristics.SENSOR_COLOR_TRANSFORM2                         , OPT      ,   RAW                  );                     expectKeyAvailable(c, CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM2                   , OPT      ,   RAW                  );                     expectKeyAvailable(c, CameraCharacteristics.SENSOR_FORWARD_MATRIX2                          , OPT      ,   RAW                  );                 }             }              // Required key if any of RAW format output is supported             StreamConfigurationMap config =                     c.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(String.format(""No stream configuration map found for: ID %s"",                     mAllCameraIds[i]), config);             if (config.isOutputSupportedFor(ImageFormat.RAW_SENSOR) ||                     config.isOutputSupportedFor(ImageFormat.RAW10)  ||                     config.isOutputSupportedFor(ImageFormat.RAW12)  ||                     config.isOutputSupportedFor(ImageFormat.RAW_PRIVATE)) {                 expectKeyAvailable(c,                         CameraCharacteristics.CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE, OPT, BC);             }              // External Camera exceptional keys             Integer hwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);             boolean isExternalCamera = (hwLevel ==                     CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL);             if (!isExternalCamera) {                 expectKeyAvailable(c, CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS               , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_AVAILABLE_TEST_PATTERN_MODES             , OPT      ,   BC                   );                 expectKeyAvailable(c, CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE                       , OPT      ,   BC                   );             }               // Verify version is a short text string.             if (allKeys.contains(CameraCharacteristics.INFO_VERSION)) {                 final String TEXT_REGEX = ""[\\p{Alnum}\\p{Punct}\\p{Space}]*"";                 final int MAX_VERSION_LENGTH = 256;                  String version = c.get(CameraCharacteristics.INFO_VERSION);                 mCollector.expectTrue(""Version contains non-text characters: "" + version,                         version.matches(TEXT_REGEX));                 mCollector.expectLessOrEqual(""Version too long: "" + version, MAX_VERSION_LENGTH,                         version.length());             }         }     }      /**      * Test values for static metadata used by the RAW capability.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.animation.cts.AnimatorSetTest"	"testManipulateChildOutsideOfSet"	"CtsAnimationTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/animation/src/android/animation/cts/AnimatorSetTest.java"	""	"public void testManipulateChildOutsideOfSet() throws Throwable {         final ValueAnimator fadeIn = ObjectAnimator.ofFloat(mActivity.view, View.ALPHA, 0f, 1f);         fadeIn.setDuration(200);         final ValueAnimator fadeOut = ObjectAnimator.ofFloat(mActivity.view, View.ALPHA, 1f, 0f);         fadeOut.setDuration(200);          ValueAnimator.AnimatorUpdateListener listener = mock(                 ValueAnimator.AnimatorUpdateListener.class);         fadeIn.addUpdateListener(listener);          AnimatorSet show = new AnimatorSet();         show.play(fadeIn);          AnimatorSet hideNShow = new AnimatorSet();         hideNShow.play(fadeIn).after(fadeOut);          mActivityRule.runOnUiThread(() ->                 show.start()         );          verify(listener, timeout(100).atLeast(2)).onAnimationUpdate(fadeIn);          AnimatorListenerAdapter adapter = mock(AnimatorListenerAdapter.class);         hideNShow.addListener(adapter);         // Start hideNShow after fadeIn is started for 100ms         mActivityRule.runOnUiThread(() ->                 hideNShow.start()         );          verify(adapter, timeout(800)).onAnimationEnd(hideNShow, false);         // Now that the hideNShow finished we need to check whether the fadeIn animation ran again.         assertEquals(1f, mActivity.view.getAlpha(), 0);      }      /**      *      * This test verifies that custom ValueAnimators will be start()'ed in a set.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.ServiceTest"	"testBindIsolatedServiceOnBackgroundThread"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/ServiceTest.java"	""	"public void testBindIsolatedServiceOnBackgroundThread() throws Exception {         setupBackgroundThread();         IsolatedConnection conn = new IsolatedConnection();         mContext.bindIsolatedService(mIsolatedService, Context.BIND_AUTO_CREATE,             ""background_instance"", mBackgroundThreadExecutor, conn);         conn.waitForService(DELAY);         assertEquals(mBackgroundThread, conn.getOnServiceConnectedThread());         mContext.unbindService(conn);     }      static final int BINDING_WEAK = 0;     static final int BINDING_STRONG = 1;     static final int BINDING_ANY = -1;      final class IsolatedConnectionInfo {         final int mStrong;         final String mInstanceName;         final String mLabel;         int mGroup;         int mImportance;         IsolatedConnection mConnection;          IsolatedConnectionInfo(int group, int importance, int strong) {             mGroup = group;             mImportance = importance;             mStrong = strong;             mInstanceName = group + ""_"" + importance;             StringBuilder b = new StringBuilder(mInstanceName);             b.append('_');             if (strong == BINDING_WEAK) {                 b.append('W');             } else if (strong == BINDING_STRONG) {                 b.append('S');             } else {                 b.append(strong);             }             mLabel = b.toString();         }          void setGroup(int group) {             mGroup = group;         }          void setImportance(int importance) {             mImportance = importance;         }          boolean match(int group, int strong) {             return (group < 0 || mGroup == group)                     && (strong == BINDING_ANY || mStrong == strong);         }          boolean bind(Context context) {             if (mConnection != null) {                 return true;             }             Log.i(""XXXXXXX"", ""Binding "" + mLabel + "": conn="" + mConnection                     + "" context="" + context);             mConnection = new IsolatedConnection();             boolean result = context.bindIsolatedService(                     mIsolatedService,                     Context.BIND_AUTO_CREATE | Context.BIND_DEBUG_UNBIND                             | (mStrong == BINDING_STRONG ? 0 : Context.BIND_ALLOW_OOM_MANAGEMENT),                     mInstanceName, mContextMainExecutor, mConnection);             if (!result) {                 mConnection = null;             }             return result;         }          IsolatedConnection getConnection() {             return mConnection;         }          void unbind(Context context) {             if (mConnection != null) {                 Log.i(""XXXXXXX"", ""Unbinding "" + mLabel + "": conn="" + mConnection                         + "" context="" + context);                 context.unbindService(mConnection);                 mConnection = null;             }         }     }      final class LruOrderItem {         static final int FLAG_SKIP_UNKNOWN = 1<<0;          final IsolatedConnectionInfo mInfo;         final int mUid;         final int mFlags;          LruOrderItem(IsolatedConnectionInfo info, int flags) {             mInfo = info;             mUid = -1;             mFlags = flags;         }          LruOrderItem(int uid, int flags) {             mInfo = null;             mUid = uid;             mFlags = flags;         }          IsolatedConnectionInfo getInfo() {             return mInfo;         }          int getUid() {             return mInfo != null ? mInfo.getConnection().getUid() : mUid;         }          int getUserId() {             return UserHandle.getUserHandleForUid(getUid()).getIdentifier();         }          int getAppId() {             return UserHandle.getAppId(getUid());         }          boolean isEquivalentTo(ProcessRecordProto proc) {             int procAppId = proc.isolatedAppId != 0 ? proc.isolatedAppId : UserHandle.getAppId(                     proc.uid);              // Compare appid and userid separately because UserHandle.getUid is @hide.             return procAppId == getAppId() && proc.userId == getUserId();         }          int getFlags() {             return mFlags;         }     }      private void doBind(Context context, IsolatedConnectionInfo[] connections, int group,             int strong) {         for (IsolatedConnectionInfo ci : connections) {             if (ci.match(group, strong)) {                 ci.bind(context);             }         }     }      private void doBind(Context context, IsolatedConnectionInfo[] connections, int[] selected) {         for (int i : selected) {             boolean result = connections[i].bind(context);             if (!result) {                 fail(""Unable to bind connection "" + connections[i].mLabel);             }         }     }      private void doWaitForService(IsolatedConnectionInfo[] connections, int group,             int strong) {         for (IsolatedConnectionInfo ci : connections) {             if (ci.match(group, strong)) {                 ci.mConnection.waitForService(DELAY);             }         }     }      private void doUpdateServiceGroup(Context context, IsolatedConnectionInfo[] connections,             int group, int strong) {         for (IsolatedConnectionInfo ci : connections) {             if (ci.match(group, strong)) {                 context.updateServiceGroup(ci.mConnection, ci.mGroup, ci.mImportance);             }         }     }      private void doUnbind(Context context, IsolatedConnectionInfo[] connections, int group,             int strong) {         for (IsolatedConnectionInfo ci : connections) {             if (ci.match(group, strong)) {                 ci.unbind(context);             }         }     }      private void doUnbind(Context context, IsolatedConnectionInfo[] connections, int[] selected) {         for (int i : selected) {             connections[i].unbind(context);         }     }      List<ProcessRecordProto> getLruProcesses() {         ActivityManagerServiceDumpProcessesProto dump = getActivityManagerProcesses();         SparseArray<ProcessRecordProto> procs = new SparseArray<>();         ProcessRecordProto[] procsList = dump.procs;         for (ProcessRecordProto proc : procsList) {             procs.put(proc.lruIndex, proc);         }         ArrayList<ProcessRecordProto> lruProcs = new ArrayList<>();         for (int i = 0; i < procs.size(); i++) {             lruProcs.add(procs.valueAt(i));         }         return lruProcs;     }      String printProc(int i, ProcessRecordProto proc) {         return ""#"" + i + "": "" + proc.processName                 + "" pid="" + proc.pid + "" uid="" + proc.uid                 + (proc.isolatedAppId != 0 ? "" isolated="" + proc.isolatedAppId : """");     }      private void logProc(int i, ProcessRecordProto proc) {         Log.i(""XXXXXXXX"", printProc(i, proc));     }      private void verifyLruOrder(LruOrderItem[] orderItems) {         List<ProcessRecordProto> procs = getLruProcesses();         Log.i(""XXXXXXXX"", ""Processes:"");         int orderI = 0;         for (int i = procs.size() - 1; i >= 0; i--) {             ProcessRecordProto proc = procs.get(i);             logProc(i, proc);             final LruOrderItem lru = orderItems[orderI];             Log.i(""XXXXXXXX"", ""Expecting uid: "" + lru.getUid());             if (!lru.isEquivalentTo(proc)) {                 if ((lru.getFlags() & LruOrderItem.FLAG_SKIP_UNKNOWN) != 0) {                     while (i > 0) {                         i--;                         proc = procs.get(i);                         logProc(i, proc);                         if (lru.isEquivalentTo(proc)) {                             break;                         }                     }                 }                 if (!lru.isEquivalentTo(proc)) {                     if ((lru.getFlags() & LruOrderItem.FLAG_SKIP_UNKNOWN) != 0) {                         fail(""Didn't find expected LRU proc uid="" + lru.getUid());                     }                     fail(""Expected proc uid="" + lru.getUid() + "" at found proc ""                             + printProc(i, proc));                 }             }             orderI++;             if (orderI >= orderItems.length) {                 return;             }         }     }      @MediumTest"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"getTestMarker"	"CtsInputMethodTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	"/*  *.  */  package android.view.inputmethod.cts;  import static android.view.WindowInsets.Type.ime; import static android.view.WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS; import static android.view.inputmethod.cts.util.InputMethodVisibilityVerifier.expectImeInvisible; import static android.view.inputmethod.cts.util.InputMethodVisibilityVerifier.expectImeVisible; import static android.view.inputmethod.cts.util.TestUtils.getOnMainSync; import static android.view.inputmethod.cts.util.TestUtils.runOnMainSync;  import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEvent; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEventWithKeyValue; import static com.android.cts.mockime.ImeEventStreamTestUtils.notExpectEvent;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.app.AlertDialog; import android.app.Instrumentation; import android.content.pm.PackageManager; import android.graphics.Color; import android.os.SystemClock; import android.support.test.uiautomator.UiObject2; import android.text.TextUtils; import android.util.Pair; import android.view.KeyEvent; import android.view.View; import android.view.WindowInsetsController; import android.view.inputmethod.EditorInfo; import android.view.inputmethod.InputMethod; import android.view.inputmethod.InputMethodManager; import android.view.inputmethod.cts.util.EndToEndImeTestBase; import android.view.inputmethod.cts.util.TestActivity; import android.view.inputmethod.cts.util.TestUtils; import android.view.inputmethod.cts.util.TestWebView; import android.view.inputmethod.cts.util.UnlockScreenRule; import android.widget.EditText; import android.widget.LinearLayout;  import androidx.annotation.ColorInt; import androidx.annotation.NonNull; import androidx.test.filters.MediumTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.cts.mockime.ImeEvent; import com.android.cts.mockime.ImeEventStream; import com.android.cts.mockime.ImeSettings; import com.android.cts.mockime.MockImeSession;  import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference; import java.util.function.Predicate;  @MediumTest @RunWith(AndroidJUnit4.class) public class KeyboardVisibilityControlTest extends EndToEndImeTestBase {     private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);      @Rule     public final UnlockScreenRule mUnlockScreenRule = new UnlockScreenRule();      private static final String TEST_MARKER_PREFIX =             ""android.view.inputmethod.cts.KeyboardVisibilityControlTest"";      private static String getTestMarker() {         return TEST_MARKER_PREFIX + ""/""  + SystemClock.elapsedRealtimeNanos();     }      private static Predicate<ImeEvent> editorMatcher(             @NonNull String eventName, @NonNull String marker) {         return event -> {             if (!TextUtils.equals(eventName, event.getEventName())) {                 return false;             }             final EditorInfo editorInfo = event.getArguments().getParcelable(""editorInfo"");             return TextUtils.equals(marker, editorInfo.privateImeOptions);         };     }      private static Predicate<ImeEvent> showSoftInputMatcher(int requiredFlags) {         return event -> {             if (!TextUtils.equals(""showSoftInput"", event.getEventName())) {                 return false;             }             final int flags = event.getArguments().getInt(""flags"");             return (flags & requiredFlags) == requiredFlags;         };     }      private static Predicate<ImeEvent> hideSoftInputMatcher() {         return event -> TextUtils.equals(""hideSoftInput"", event.getEventName());     }      private static Predicate<ImeEvent> onFinishInputViewMatcher(boolean expectedFinishingInput) {         return event -> {             if (!TextUtils.equals(""onFinishInputView"", event.getEventName())) {                 return false;             }             final boolean finishingInput = event.getArguments().getBoolean(""finishingInput"");             return finishingInput == expectedFinishingInput;         };     }      private Pair<EditText, EditText> launchTestActivity(@NonNull String focusedMarker,             @NonNull String nonFocusedMarker) {         final AtomicReference<EditText> focusedEditTextRef = new AtomicReference<>();         final AtomicReference<EditText> nonFocusedEditTextRef = new AtomicReference<>();         TestActivity.startSync(activity -> {             final LinearLayout layout = new LinearLayout(activity);             layout.setOrientation(LinearLayout.VERTICAL);              final EditText focusedEditText = new EditText(activity);             focusedEditText.setHint(""focused editText"");             focusedEditText.setPrivateImeOptions(focusedMarker);             focusedEditText.requestFocus();             focusedEditTextRef.set(focusedEditText);             layout.addView(focusedEditText);              final EditText nonFocusedEditText = new EditText(activity);             nonFocusedEditText.setPrivateImeOptions(nonFocusedMarker);             nonFocusedEditText.setHint(""target editText"");             nonFocusedEditTextRef.set(nonFocusedEditText);             layout.addView(nonFocusedEditText);             return layout;         });         return new Pair<>(focusedEditTextRef.get(), nonFocusedEditTextRef.get());     }      private EditText launchTestActivity(@NonNull String marker) {         return launchTestActivity(marker, getTestMarker()).first;     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"testBasicShowHideSoftInput"	"CtsInputMethodTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	"public void testBasicShowHideSoftInput() throws Exception {         final InputMethodManager imm = InstrumentationRegistry.getInstrumentation()                 .getTargetContext().getSystemService(InputMethodManager.class);          try (MockImeSession imeSession = MockImeSession.create(                 InstrumentationRegistry.getInstrumentation().getContext(),                 InstrumentationRegistry.getInstrumentation().getUiAutomation(),                 new ImeSettings.Builder())) {             final ImeEventStream stream = imeSession.openEventStream();              final String marker = getTestMarker();             final EditText editText = launchTestActivity(marker);              expectEvent(stream, editorMatcher(""onStartInput"", marker), TIMEOUT);             notExpectEvent(stream, editorMatcher(""onStartInputView"", marker), TIMEOUT);             expectImeInvisible(TIMEOUT);              assertTrue(""isActive() must return true if the View has IME focus"",                     getOnMainSync(() -> imm.isActive(editText)));              // Test showSoftInput() flow             assertTrue(""showSoftInput must success if the View has IME focus"",                     getOnMainSync(() -> imm.showSoftInput(editText, 0)));              expectEvent(stream, showSoftInputMatcher(InputMethod.SHOW_EXPLICIT), TIMEOUT);             expectEvent(stream, editorMatcher(""onStartInputView"", marker), TIMEOUT);             expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",                     View.VISIBLE, TIMEOUT);             expectImeVisible(TIMEOUT);              // Test hideSoftInputFromWindow() flow             assertTrue(""hideSoftInputFromWindow must success if the View has IME focus"",                     getOnMainSync(() -> imm.hideSoftInputFromWindow(editText.getWindowToken(), 0)));              expectEvent(stream, hideSoftInputMatcher(), TIMEOUT);             expectEvent(stream, onFinishInputViewMatcher(false), TIMEOUT);             expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",                     View.GONE, TIMEOUT);             expectImeInvisible(TIMEOUT);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"testShowHideSoftInputShouldBeIgnoredOnNonFocusedView"	"CtsInputMethodTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	"public void testShowHideSoftInputShouldBeIgnoredOnNonFocusedView() throws Exception {         final InputMethodManager imm = InstrumentationRegistry.getInstrumentation()                 .getTargetContext().getSystemService(InputMethodManager.class);          try (MockImeSession imeSession = MockImeSession.create(                 InstrumentationRegistry.getInstrumentation().getContext(),                 InstrumentationRegistry.getInstrumentation().getUiAutomation(),                 new ImeSettings.Builder())) {             final ImeEventStream stream = imeSession.openEventStream();              final String focusedMarker = getTestMarker();             final String nonFocusedMarker = getTestMarker();             final Pair<EditText, EditText> editTextPair =                     launchTestActivity(focusedMarker, nonFocusedMarker);             final EditText nonFocusedEditText = editTextPair.second;              expectEvent(stream, editorMatcher(""onStartInput"", focusedMarker), TIMEOUT);              expectImeInvisible(TIMEOUT);             assertFalse(""isActive() must return false if the View does not have IME focus"",                     getOnMainSync(() -> imm.isActive(nonFocusedEditText)));             assertFalse(""showSoftInput must fail if the View does not have IME focus"",                     getOnMainSync(() -> imm.showSoftInput(nonFocusedEditText, 0)));             notExpectEvent(stream, showSoftInputMatcher(InputMethod.SHOW_EXPLICIT), TIMEOUT);              assertFalse(""hideSoftInputFromWindow must fail if the View does not have IME focus"",                     getOnMainSync(() -> imm.hideSoftInputFromWindow(                             nonFocusedEditText.getWindowToken(), 0)));             notExpectEvent(stream, hideSoftInputMatcher(), TIMEOUT);             expectImeInvisible(TIMEOUT);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"testToggleSoftInput"	"CtsInputMethodTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	"public void testToggleSoftInput() throws Exception {         final InputMethodManager imm = InstrumentationRegistry.getInstrumentation()                 .getTargetContext().getSystemService(InputMethodManager.class);          try (MockImeSession imeSession = MockImeSession.create(                 InstrumentationRegistry.getInstrumentation().getContext(),                 InstrumentationRegistry.getInstrumentation().getUiAutomation(),                 new ImeSettings.Builder())) {             final ImeEventStream stream = imeSession.openEventStream();              final String marker = getTestMarker();             final EditText editText = launchTestActivity(marker);              expectEvent(stream, editorMatcher(""onStartInput"", marker), TIMEOUT);             notExpectEvent(stream, editorMatcher(""onStartInputView"", marker), TIMEOUT);             expectImeInvisible(TIMEOUT);              // Test toggleSoftInputFromWindow() flow             runOnMainSync(() -> imm.toggleSoftInputFromWindow(editText.getWindowToken(), 0, 0));              expectEvent(stream.copy(), showSoftInputMatcher(InputMethod.SHOW_EXPLICIT), TIMEOUT);             expectEvent(stream.copy(), editorMatcher(""onStartInputView"", marker), TIMEOUT);             expectImeVisible(TIMEOUT);              // Calling toggleSoftInputFromWindow() must hide the IME.             runOnMainSync(() -> imm.toggleSoftInputFromWindow(editText.getWindowToken(), 0, 0));              expectEvent(stream, hideSoftInputMatcher(), TIMEOUT);             expectEvent(stream, onFinishInputViewMatcher(false), TIMEOUT);             expectImeInvisible(TIMEOUT);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"testShowHideKeyboardOnWebView"	"CtsInputMethodTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	"public void testShowHideKeyboardOnWebView() throws Exception {         final PackageManager pm =                 InstrumentationRegistry.getInstrumentation().getContext().getPackageManager();         assumeTrue(pm.hasSystemFeature(""android.software.webview""));          try (MockImeSession imeSession = MockImeSession.create(                 InstrumentationRegistry.getInstrumentation().getContext(),                 InstrumentationRegistry.getInstrumentation().getUiAutomation(),                 new ImeSettings.Builder())) {             final ImeEventStream stream = imeSession.openEventStream();              final UiObject2 inputTextField = TestWebView.launchTestWebViewActivity(                     TimeUnit.SECONDS.toMillis(5));             assertNotNull(""Editor must exists on WebView"", inputTextField);              expectEvent(stream, event -> ""onStartInput"".equals(event.getEventName()), TIMEOUT);             notExpectEvent(stream, event -> ""onStartInputView"".equals(event.getEventName()),                     TIMEOUT);             expectImeInvisible(TIMEOUT);              inputTextField.click();             expectEvent(stream.copy(), showSoftInputMatcher(InputMethod.SHOW_EXPLICIT), TIMEOUT);             expectEvent(stream.copy(), event -> ""onStartInputView"".equals(event.getEventName()),                     TIMEOUT);             expectImeVisible(TIMEOUT);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"testFloatingImeHideKeyboardAfterBackPressed"	"CtsInputMethodTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	"public void testFloatingImeHideKeyboardAfterBackPressed() throws Exception {         final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();         final InputMethodManager imm = instrumentation.getTargetContext().getSystemService(                 InputMethodManager.class);          // Initial MockIme with floating IME settings.         try (MockImeSession imeSession = MockImeSession.create(                 instrumentation.getContext(), instrumentation.getUiAutomation(),                 getFloatingImeSettings(Color.BLACK))) {             final ImeEventStream stream = imeSession.openEventStream();             final String marker = getTestMarker();             final EditText editText = launchTestActivity(marker);              expectEvent(stream, editorMatcher(""onStartInput"", marker), TIMEOUT);             notExpectEvent(stream, editorMatcher(""onStartInputView"", marker), TIMEOUT);             expectImeInvisible(TIMEOUT);              assertTrue(""isActive() must return true if the View has IME focus"",                     getOnMainSync(() -> imm.isActive(editText)));              // Test showSoftInput() flow             assertTrue(""showSoftInput must success if the View has IME focus"",                     getOnMainSync(() -> imm.showSoftInput(editText, 0)));              expectEvent(stream, showSoftInputMatcher(InputMethod.SHOW_EXPLICIT), TIMEOUT);             expectEvent(stream, editorMatcher(""onStartInputView"", marker), TIMEOUT);             expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",                     View.VISIBLE, TIMEOUT);             expectImeVisible(TIMEOUT);              // Pressing back key, expect soft-keyboard will become invisible.             instrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_BACK);             expectEvent(stream, hideSoftInputMatcher(), TIMEOUT);             expectEvent(stream, onFinishInputViewMatcher(false), TIMEOUT);             expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",                     View.GONE, TIMEOUT);             expectImeInvisible(TIMEOUT);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"testImeVisibilityWhenDismisingDialogWithImeFocused"	"CtsInputMethodTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	"public void testImeVisibilityWhenDismisingDialogWithImeFocused() throws Exception {         final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();         final InputMethodManager imm = instrumentation.getTargetContext().getSystemService(                 InputMethodManager.class);         try (MockImeSession imeSession = MockImeSession.create(                 InstrumentationRegistry.getInstrumentation().getContext(),                 InstrumentationRegistry.getInstrumentation().getUiAutomation(),                 new ImeSettings.Builder())) {             final ImeEventStream stream = imeSession.openEventStream();              // Launch a simple test activity             final TestActivity testActivity = TestActivity.startSync(activity -> {                 final LinearLayout layout = new LinearLayout(activity);                 return layout;             });              // Launch a dialog             final String marker = getTestMarker();             final AtomicReference<EditText> editTextRef = new AtomicReference<>();             final AtomicReference<AlertDialog> dialogRef = new AtomicReference<>();             TestUtils.runOnMainSync(() -> {                 final EditText editText = new EditText(testActivity);                 editText.setHint(""focused editText"");                 editText.setPrivateImeOptions(marker);                 editText.requestFocus();                 final AlertDialog dialog = new AlertDialog.Builder(testActivity)                         .setView(editText)                         .create();                 final WindowInsetsController.OnControllableInsetsChangedListener listener =                         new WindowInsetsController.OnControllableInsetsChangedListener() {                             @Override                             public void onControllableInsetsChanged(                                     @NonNull WindowInsetsController controller, int typeMask) {                                 if ((typeMask & ime()) != 0) {                                     editText.getWindowInsetsController()                                             .removeOnControllableInsetsChangedListener(this);                                     editText.getWindowInsetsController().show(ime());                                 }                             }                         };                 dialog.show();                 editText.getWindowInsetsController().addOnControllableInsetsChangedListener(                         listener);                 editTextRef.set(editText);                 dialogRef.set(dialog);             });             TestUtils.waitOnMainUntil(() -> dialogRef.get().isShowing()                     && editTextRef.get().hasFocus(), TIMEOUT);             expectEvent(stream, editorMatcher(""onStartInput"", marker), TIMEOUT);             expectEvent(stream, event -> ""showSoftInput"".equals(event.getEventName()), TIMEOUT);             expectEvent(stream, editorMatcher(""onStartInputView"", marker), TIMEOUT);             expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",                     View.VISIBLE, TIMEOUT);             expectImeVisible(TIMEOUT);              // Hide keyboard and dismiss dialog.             TestUtils.runOnMainSync(() -> {                 editTextRef.get().getWindowInsetsController().hide(ime());                 dialogRef.get().dismiss();             });              // Expect onFinishInput called and keyboard should hide successfully.             expectEvent(stream, hideSoftInputMatcher(), TIMEOUT);             expectEvent(stream, onFinishInputViewMatcher(false), TIMEOUT);             expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",                     View.GONE, TIMEOUT);             expectImeInvisible(TIMEOUT);              // Expect fake input connection started and keyboard invisible after activity focused.             final ImeEvent onStart = expectEvent(stream,                     event -> ""onStartInput"".equals(event.getEventName()), TIMEOUT);             assertTrue(onStart.getEnterState().hasDummyInputConnection());             TestUtils.waitOnMainUntil(() -> testActivity.hasWindowFocus(), TIMEOUT);             expectEventWithKeyValue(stream, ""onWindowVisibilityChanged"", ""visible"",                     View.GONE, TIMEOUT);             expectImeInvisible(TIMEOUT);         }     }      private static ImeSettings.Builder getFloatingImeSettings(@ColorInt int navigationBarColor) {         final ImeSettings.Builder builder = new ImeSettings.Builder();         builder.setWindowFlags(0, FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);         // As documented, Window#setNavigationBarColor() is actually ignored when the IME window         // does not have FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS.  We are calling setNavigationBarColor()         // to ensure it.         builder.setNavigationBarColor(navigationBarColor);         return builder;     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.hardware.camera2.cts.CaptureResultTest"	"testResultTimestamps"	"CtsCameraTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/CaptureResultTest.java"	""	"public void testResultTimestamps() throws Exception {         for (String id : mCameraIdsUnderTest) {             ImageReader previewReader = null;             ImageReader jpegReader = null;              CaptureResult resultForNdk = null;              SimpleImageReaderListener jpegListener = new SimpleImageReaderListener();             SimpleImageReaderListener prevListener = new SimpleImageReaderListener();             try {                 if (!mAllStaticInfo.get(id).isColorOutputSupported()) {                     Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");                     continue;                 }                  openDevice(id);                 CaptureRequest.Builder previewBuilder =                         mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);                 CaptureRequest.Builder multiBuilder =                         mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);                  // Create image reader and surface.                 Size previewSize = mOrderedPreviewSizes.get(0);                 Size jpegSize = mOrderedStillSizes.get(0);                  // Create ImageReaders.                 previewReader = makeImageReader(previewSize, ImageFormat.YUV_420_888,                         MAX_NUM_IMAGES, prevListener, mHandler);                 jpegReader = makeImageReader(jpegSize, ImageFormat.JPEG,                         MAX_NUM_IMAGES, jpegListener, mHandler);                  // Configure output streams with preview and jpeg streams.                 List<Surface> outputSurfaces = new ArrayList<>(Arrays.asList(                         previewReader.getSurface(), jpegReader.getSurface()));                  SessionListener mockSessionListener = getMockSessionListener();                  CameraCaptureSession session = configureAndVerifySession(mockSessionListener,                         mCamera, outputSurfaces, mHandler);                  // Configure the requests.                 previewBuilder.addTarget(previewReader.getSurface());                 multiBuilder.addTarget(previewReader.getSurface());                 multiBuilder.addTarget(jpegReader.getSurface());                  if (mStaticInfo.isEnableZslSupported()) {                     // Turn off ZSL to ensure timestamps are increasing                     previewBuilder.set(CaptureRequest.CONTROL_ENABLE_ZSL, false);                     multiBuilder.set(CaptureRequest.CONTROL_ENABLE_ZSL, false);                 }                  CaptureCallback mockCaptureCallback = getMockCaptureListener();                  // Capture targeting only preview                 Pair<TotalCaptureResult, Long> result = captureAndVerifyResult(mockCaptureCallback,                         session, previewBuilder.build(), mHandler);                  // Check if all timestamps are the same                 Image prevImage = prevListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);                 validateTimestamps(""Result 1"", result.first,                         prevImage, result.second);                 prevImage.close();                  // Capture targeting both jpeg and preview                 Pair<TotalCaptureResult, Long> result2 = captureAndVerifyResult(mockCaptureCallback,                         session, multiBuilder.build(), mHandler);                  // Check if all timestamps are the same                 prevImage = prevListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);                 Image jpegImage = jpegListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);                 validateTimestamps(""Result 2 Preview"", result2.first,                         prevImage, result2.second);                 validateTimestamps(""Result 2 Jpeg"", result2.first,                         jpegImage, result2.second);                 prevImage.close();                 jpegImage.close();                  // Check if timestamps are increasing                 mCollector.expectGreater(""Timestamps must be increasing."", result.second,                         result2.second);                  // Capture two preview frames                 long startTime = SystemClock.elapsedRealtimeNanos();                 Pair<TotalCaptureResult, Long> result3 = captureAndVerifyResult(mockCaptureCallback,                         session, previewBuilder.build(), mHandler);                 Pair<TotalCaptureResult, Long> result4 = captureAndVerifyResult(mockCaptureCallback,                         session, previewBuilder.build(), mHandler);                 long clockDiff = SystemClock.elapsedRealtimeNanos() - startTime;                 long resultDiff = result4.second - result3.second;                  // Check if all timestamps are the same                 prevImage = prevListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);                 validateTimestamps(""Result 3"", result3.first,                         prevImage, result3.second);                 prevImage.close();                 prevImage = prevListener.getImage(CAPTURE_IMAGE_TIMEOUT_MS);                 validateTimestamps(""Result 4"", result4.first,                         prevImage, result4.second);                 prevImage.close();                  // Check that the timestamps monotonically increase at a reasonable rate                 mCollector.expectGreaterOrEqual(""Timestamps increase faster than system clock."",                         resultDiff, clockDiff);                 mCollector.expectGreater(""Timestamps must be increasing."", result3.second,                         result4.second);                  resultForNdk = result.first;             } finally {                 closeDevice(id);                 closeImageReader(previewReader);                 closeImageReader(jpegReader);             }              mCollector.expectTrue(                 ""validateACameraMetadataFromCameraMetadataCriticalTagsNative failed"",                 validateACameraMetadataFromCameraMetadataCriticalTagsNative(resultForNdk,                         resultForNdk.get(CaptureResult.SENSOR_TIMESTAMP)));              long timestamp = resultForNdk.get(CaptureResult.SENSOR_TIMESTAMP);             mCollector.expectTrue(                 ""stashACameraMetadataFromCameraMetadataNative failed"",                 stashACameraMetadataFromCameraMetadataNative(resultForNdk));              // Try to drop the Java side object here             resultForNdk = null;             int[] block = null;             final int count = 9;             for (int i = 0; i < count + 1; i++) {                 block = new int[1000000];                 block[1000 + i] = i;                  Runtime.getRuntime().gc();                 Runtime.getRuntime().runFinalization();                  mCollector.expectTrue(""This should never fail"", block[1000 + i] == i);             }             mCollector.expectTrue(                 ""validateStashedACameraMetadataFromCameraMetadataNative failed"",                 validateStashedACameraMetadataFromCameraMetadataNative(timestamp));             mCollector.expectTrue(""This should never fail"", block[1000 + count] == count);         }     }      private void validateTimestamps(String msg, TotalCaptureResult result, Image resultImage,                                     long captureTime) {         mCollector.expectKeyValueEquals(result, CaptureResult.SENSOR_TIMESTAMP, captureTime);         mCollector.expectEquals(msg + "": Capture timestamp must be same as resultImage timestamp"",                 resultImage.getTimestamp(), captureTime);     }      public static void validateCaptureResult(CameraErrorCollector errorCollector,             SimpleCaptureCallback captureListener, StaticMetadata staticInfo,             Map<String, StaticMetadata> allStaticInfo, List<String> requestedPhysicalIds,             CaptureRequest.Builder requestBuilder, int numFramesVerified) throws Exception {         // List that includes all public keys from CaptureResult         List<CaptureResult.Key<?>> allKeys = getAllCaptureResultKeys();         // Get the waived keys for current camera device         List<CaptureResult.Key<?>> waiverKeys = getWaiverKeysForCamera(staticInfo);         if (requestedPhysicalIds == null) {             requestedPhysicalIds = new ArrayList<String>();         }          HashMap<String, List<CaptureResult.Key<?>>> physicalWaiverKeys = new HashMap<>();         for (String physicalId : requestedPhysicalIds) {             StaticMetadata physicalStaticInfo = allStaticInfo.get(physicalId);             physicalWaiverKeys.put(physicalId, getWaiverKeysForCamera(physicalStaticInfo));         }          TotalCaptureResult result = null;         // List of (frameNumber, physical camera Id) pairs         ArrayList<Pair<Long, String>> droppedPhysicalResults = new ArrayList<>();         for (int i = 0; i < numFramesVerified; i++) {             result = captureListener.getTotalCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);              Map<String, CaptureResult> physicalCaptureResults = result.getPhysicalCameraResults();             ArrayList<String> droppedIds = new ArrayList<String>(requestedPhysicalIds);             droppedIds.removeAll(physicalCaptureResults.keySet());             for (String droppedId : droppedIds) {                 droppedPhysicalResults.add(                         new Pair<Long, String>(result.getFrameNumber(), droppedId));             }              validateOneCaptureResult(errorCollector, staticInfo, waiverKeys, allKeys,                     requestBuilder, result, null/*cameraId*/, i);             for (String physicalId : physicalCaptureResults.keySet()) {                 StaticMetadata physicalStaticInfo = allStaticInfo.get(physicalId);                 validateOneCaptureResult(errorCollector, physicalStaticInfo,                         physicalWaiverKeys.get(physicalId),                         allKeys, null/*requestBuilder*/, physicalCaptureResults.get(physicalId),                         physicalId, i);             }         }          // Verify that all dropped physical camera results are notified via capture failure.         while (captureListener.hasMoreFailures()) {             ArrayList<CaptureFailure> failures =                     captureListener.getCaptureFailures(/*maxNumFailures*/ 1);             for (CaptureFailure failure : failures) {                 String failedPhysicalId = failure.getPhysicalCameraId();                 Long failedFrameNumber = failure.getFrameNumber();                 if (failedPhysicalId != null) {                     droppedPhysicalResults.removeIf(                             n -> n.equals(                             new Pair<Long, String>(failedFrameNumber, failedPhysicalId)));                 }             }         }         errorCollector.expectTrue(""Not all dropped results for physical cameras are notified"",                 droppedPhysicalResults.isEmpty());     }      private static void validateOneCaptureResult(CameraErrorCollector errorCollector,             StaticMetadata staticInfo, List<CaptureResult.Key<?>> skippedKeys,             List<CaptureResult.Key<?>> allKeys,             CaptureRequest.Builder requestBuilder, CaptureResult result, String cameraId,             int resultCount) throws Exception {         String failMsg = ""Failed capture result "" + resultCount + "" test"";         String cameraIdString = "" "";         if (cameraId != null) {             cameraIdString += ""for physical camera "" + cameraId;         }         boolean verifyMatchRequest = (requestBuilder != null);         for (CaptureResult.Key<?> key : allKeys) {             if (!skippedKeys.contains(key)) {                 /**                  * Check the critical tags here.                  * TODO: Can use the same key for request and result when request/result                  * becomes symmetric (b/14059883). Then below check can be wrapped into                  * a generic function.                  */                 String msg = failMsg + cameraIdString + ""for key "" + key.getName();                 if (verifyMatchRequest) {                     if (key.equals(CaptureResult.CONTROL_AE_MODE)) {                         errorCollector.expectEquals(msg,                                 requestBuilder.get(CaptureRequest.CONTROL_AE_MODE),                                 result.get(CaptureResult.CONTROL_AE_MODE));                     } else if (key.equals(CaptureResult.CONTROL_AF_MODE)) {                         errorCollector.expectEquals(msg,                                 requestBuilder.get(CaptureRequest.CONTROL_AF_MODE),                                 result.get(CaptureResult.CONTROL_AF_MODE));                     } else if (key.equals(CaptureResult.CONTROL_AWB_MODE)) {                         errorCollector.expectEquals(msg,                                 requestBuilder.get(CaptureRequest.CONTROL_AWB_MODE),                                 result.get(CaptureResult.CONTROL_AWB_MODE));                     } else if (key.equals(CaptureResult.CONTROL_MODE)) {                         errorCollector.expectEquals(msg,                                 requestBuilder.get(CaptureRequest.CONTROL_MODE),                                 result.get(CaptureResult.CONTROL_MODE));                     } else if (key.equals(CaptureResult.STATISTICS_FACE_DETECT_MODE)) {                         errorCollector.expectEquals(msg,                                 requestBuilder.get(CaptureRequest.STATISTICS_FACE_DETECT_MODE),                                 result.get(CaptureResult.STATISTICS_FACE_DETECT_MODE));                     } else if (key.equals(CaptureResult.NOISE_REDUCTION_MODE)) {                         errorCollector.expectEquals(msg,                                 requestBuilder.get(CaptureRequest.NOISE_REDUCTION_MODE),                                 result.get(CaptureResult.NOISE_REDUCTION_MODE));                     } else if (key.equals(CaptureResult.NOISE_REDUCTION_MODE)) {                         errorCollector.expectEquals(msg,                                 requestBuilder.get(CaptureRequest.NOISE_REDUCTION_MODE),                                 result.get(CaptureResult.NOISE_REDUCTION_MODE));                     } else if (key.equals(CaptureResult.REQUEST_PIPELINE_DEPTH)) {                      } else if (key.equals(CaptureResult.STATISTICS_OIS_DATA_MODE)) {                         errorCollector.expectEquals(msg,                                 requestBuilder.get(CaptureRequest.STATISTICS_OIS_DATA_MODE),                                 result.get(CaptureResult.STATISTICS_OIS_DATA_MODE));                     } else if (key.equals(CaptureResult.DISTORTION_CORRECTION_MODE)) {                         errorCollector.expectEquals(msg,                                 requestBuilder.get(CaptureRequest.DISTORTION_CORRECTION_MODE),                                 result.get(CaptureResult.DISTORTION_CORRECTION_MODE));                     } else if (key.equals(CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL)) {                         float[] blackLevel = errorCollector.expectKeyValueNotNull(                                 result, CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL);                         if (blackLevel != null && staticInfo.isMonochromeCamera()) {                             errorCollector.expectEquals(                                     ""Monochrome camera dynamic blacklevel must be 2x2"",                                     blackLevel.length, 4);                             for (int index = 1; index < blackLevel.length; index++) {                                 errorCollector.expectEquals(                                     ""Monochrome camera 2x2 channels blacklevel value must be the same."",                                     blackLevel[index], blackLevel[0]);                             }                         }                     } else {                         // Only do non-null check for the rest of keys.                         errorCollector.expectKeyValueNotNull(failMsg, result, key);                     }                 } else {                     // Only do non-null check for the rest of keys.                     errorCollector.expectKeyValueNotNull(failMsg, result, key);                 }             } else {                 // These keys should always be null                 if (key.equals(CaptureResult.CONTROL_AE_REGIONS)) {                     errorCollector.expectNull(                             ""Capture result contains AE regions but aeMaxRegions is 0""                             + cameraIdString,                             result.get(CaptureResult.CONTROL_AE_REGIONS));                 } else if (key.equals(CaptureResult.CONTROL_AWB_REGIONS)) {                     errorCollector.expectNull(                             ""Capture result contains AWB regions but awbMaxRegions is 0""                             + cameraIdString,                             result.get(CaptureResult.CONTROL_AWB_REGIONS));                 } else if (key.equals(CaptureResult.CONTROL_AF_REGIONS)) {                     errorCollector.expectNull(                             ""Capture result contains AF regions but afMaxRegions is 0""                             + cameraIdString,                             result.get(CaptureResult.CONTROL_AF_REGIONS));                 }             }         }     }      /*      * Add waiver keys per camera device hardware level and capability.      *      * Must be called after camera device is opened.      */     private static List<CaptureResult.Key<?>> getWaiverKeysForCamera(StaticMetadata staticInfo) {         List<CaptureResult.Key<?>> waiverKeys = new ArrayList<>();          // Global waiver keys         waiverKeys.add(CaptureResult.JPEG_GPS_LOCATION);         waiverKeys.add(CaptureResult.JPEG_ORIENTATION);         waiverKeys.add(CaptureResult.JPEG_QUALITY);         waiverKeys.add(CaptureResult.JPEG_THUMBNAIL_QUALITY);         waiverKeys.add(CaptureResult.JPEG_THUMBNAIL_SIZE);          // Keys only present when corresponding control is on are being         // verified in its own functional test         // Only present in certain tonemap mode. Test in CaptureRequestTest.         waiverKeys.add(CaptureResult.TONEMAP_CURVE);         waiverKeys.add(CaptureResult.TONEMAP_GAMMA);         waiverKeys.add(CaptureResult.TONEMAP_PRESET_CURVE);         // Only present when test pattern mode is SOLID_COLOR.         // TODO: verify this key in test pattern test later         waiverKeys.add(CaptureResult.SENSOR_TEST_PATTERN_DATA);         // Only present when STATISTICS_LENS_SHADING_MAP_MODE is ON         waiverKeys.add(CaptureResult.STATISTICS_LENS_SHADING_CORRECTION_MAP);         // Only present when STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES is ON         waiverKeys.add(CaptureResult.STATISTICS_HOT_PIXEL_MAP);         // Only present when face detection is on         waiverKeys.add(CaptureResult.STATISTICS_FACES);         // Only present in reprocessing capture result.         waiverKeys.add(CaptureResult.REPROCESS_EFFECTIVE_EXPOSURE_FACTOR);          // LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID not required if key is not supported.         if (!staticInfo.isLogicalMultiCamera() ||                 !staticInfo.isActivePhysicalCameraIdSupported()) {             waiverKeys.add(CaptureResult.LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID);         }          //Keys not required if RAW is not supported         if (!staticInfo.isCapabilitySupported(                 CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW)) {             waiverKeys.add(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT);             waiverKeys.add(CaptureResult.SENSOR_GREEN_SPLIT);             waiverKeys.add(CaptureResult.SENSOR_NOISE_PROFILE);         } else if (staticInfo.isMonochromeCamera()) {             waiverKeys.add(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT);             waiverKeys.add(CaptureResult.SENSOR_GREEN_SPLIT);         }          boolean calibrationReported = staticInfo.areKeysAvailable(                 CameraCharacteristics.LENS_POSE_ROTATION,                 CameraCharacteristics.LENS_POSE_TRANSLATION,                 CameraCharacteristics.LENS_INTRINSIC_CALIBRATION);          // If any of distortion coefficients is reported in CameraCharacteristics, HAL must         // also report (one of) them in CaptureResult         boolean distortionReported =                  staticInfo.areKeysAvailable(                         CameraCharacteristics.LENS_RADIAL_DISTORTION) ||                  staticInfo.areKeysAvailable(                         CameraCharacteristics.LENS_DISTORTION);          //Keys for lens distortion correction         boolean distortionCorrectionSupported = staticInfo.isDistortionCorrectionSupported();         if (!distortionCorrectionSupported) {             waiverKeys.add(CaptureResult.DISTORTION_CORRECTION_MODE);         }          boolean mustReportDistortion = true;         // These keys must present on either DEPTH or distortion correction devices         if (!staticInfo.isCapabilitySupported(                 CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT) &&                 !distortionCorrectionSupported &&                 !distortionReported) {             mustReportDistortion = false;             waiverKeys.add(CaptureResult.LENS_RADIAL_DISTORTION);             waiverKeys.add(CaptureResult.LENS_DISTORTION);         } else {             // Radial distortion doesn't need to be present for new devices, or old devices that             // opt in the new lens distortion tag.             CameraCharacteristics c = staticInfo.getCharacteristics();             if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 ||                     c.get(CameraCharacteristics.LENS_DISTORTION) != null) {                 waiverKeys.add(CaptureResult.LENS_RADIAL_DISTORTION);             }         }          // Calibration keys must exist for         //   - DEPTH capable devices         //   - Devices that reports calibration keys in static metadata         //   - Devices that reports lens distortion keys in static metadata         if (!staticInfo.isCapabilitySupported(                 CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT) &&                 !calibrationReported && !mustReportDistortion) {             waiverKeys.add(CaptureResult.LENS_POSE_ROTATION);             waiverKeys.add(CaptureResult.LENS_POSE_TRANSLATION);             waiverKeys.add(CaptureResult.LENS_INTRINSIC_CALIBRATION);         }          // Waived if RAW output is not supported         int[] outputFormats = staticInfo.getAvailableFormats(                 StaticMetadata.StreamDirection.Output);         boolean supportRaw = false;         for (int format : outputFormats) {             if (format == ImageFormat.RAW_SENSOR || format == ImageFormat.RAW10 ||                     format == ImageFormat.RAW12 || format == ImageFormat.RAW_PRIVATE) {                 supportRaw = true;                 break;             }         }         if (!supportRaw) {             waiverKeys.add(CaptureResult.CONTROL_POST_RAW_SENSITIVITY_BOOST);         }          // Waived if MONOCHROME capability         if (staticInfo.isMonochromeCamera()) {             waiverKeys.add(CaptureResult.COLOR_CORRECTION_MODE);             waiverKeys.add(CaptureResult.COLOR_CORRECTION_TRANSFORM);             waiverKeys.add(CaptureResult.COLOR_CORRECTION_GAINS);         }          if (staticInfo.getAeMaxRegionsChecked() == 0) {             waiverKeys.add(CaptureResult.CONTROL_AE_REGIONS);         }         if (staticInfo.getAwbMaxRegionsChecked() == 0) {             waiverKeys.add(CaptureResult.CONTROL_AWB_REGIONS);         }         if (staticInfo.getAfMaxRegionsChecked() == 0) {             waiverKeys.add(CaptureResult.CONTROL_AF_REGIONS);         }          // Keys for dynamic black/white levels         if (!staticInfo.isOpticalBlackRegionSupported()) {             waiverKeys.add(CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL);             waiverKeys.add(CaptureResult.SENSOR_DYNAMIC_WHITE_LEVEL);         }          if (!staticInfo.isEnableZslSupported()) {             waiverKeys.add(CaptureResult.CONTROL_ENABLE_ZSL);         }          if (!staticInfo.isAfSceneChangeSupported()) {             waiverKeys.add(CaptureResult.CONTROL_AF_SCENE_CHANGE);         }          if (!staticInfo.isOisDataModeSupported()) {             waiverKeys.add(CaptureResult.STATISTICS_OIS_DATA_MODE);             waiverKeys.add(CaptureResult.STATISTICS_OIS_SAMPLES);         }          if (staticInfo.getAvailableExtendedSceneModeCapsChecked().length == 0) {             waiverKeys.add(CaptureResult.CONTROL_EXTENDED_SCENE_MODE);         }          if (staticInfo.isHardwareLevelAtLeastFull()) {             return waiverKeys;         }          /*          * Hardware Level = LIMITED or LEGACY          */         // Key not present if certain control is not supported         if (!staticInfo.isColorCorrectionSupported()) {             waiverKeys.add(CaptureResult.COLOR_CORRECTION_GAINS);             waiverKeys.add(CaptureResult.COLOR_CORRECTION_MODE);             waiverKeys.add(CaptureResult.COLOR_CORRECTION_TRANSFORM);         }          if (!staticInfo.isManualColorAberrationControlSupported()) {             waiverKeys.add(CaptureResult.COLOR_CORRECTION_ABERRATION_MODE);         }          if (!staticInfo.isManualToneMapSupported()) {             waiverKeys.add(CaptureResult.TONEMAP_MODE);         }          if (!staticInfo.isEdgeModeControlSupported()) {             waiverKeys.add(CaptureResult.EDGE_MODE);         }          if (!staticInfo.isHotPixelMapModeControlSupported()) {             waiverKeys.add(CaptureResult.HOT_PIXEL_MODE);         }          if (!staticInfo.isNoiseReductionModeControlSupported()) {             waiverKeys.add(CaptureResult.NOISE_REDUCTION_MODE);         }          if (!staticInfo.isManualLensShadingMapSupported()) {             waiverKeys.add(CaptureResult.SHADING_MODE);         }          //Keys not required if neither MANUAL_SENSOR nor READ_SENSOR_SETTINGS is supported         if (!staticInfo.isCapabilitySupported(                 CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR) &&             !staticInfo.isCapabilitySupported(                 CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS)) {             waiverKeys.add(CaptureResult.SENSOR_EXPOSURE_TIME);             waiverKeys.add(CaptureResult.SENSOR_SENSITIVITY);             waiverKeys.add(CaptureResult.LENS_FOCUS_DISTANCE);             waiverKeys.add(CaptureResult.LENS_APERTURE);         }          if (!staticInfo.isCapabilitySupported(                 CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {             waiverKeys.add(CaptureResult.SENSOR_FRAME_DURATION);             waiverKeys.add(CaptureResult.BLACK_LEVEL_LOCK);             waiverKeys.add(CaptureResult.LENS_FOCUS_RANGE);             waiverKeys.add(CaptureResult.LENS_STATE);             waiverKeys.add(CaptureResult.LENS_FILTER_DENSITY);         }          if (staticInfo.isHardwareLevelLimited() && staticInfo.isColorOutputSupported()) {             return waiverKeys;         }          /*          * Hardware Level = EXTERNAL          */         if (staticInfo.isExternalCamera()) {             waiverKeys.add(CaptureResult.LENS_FOCAL_LENGTH);             waiverKeys.add(CaptureResult.SENSOR_TEST_PATTERN_MODE);             waiverKeys.add(CaptureResult.SENSOR_ROLLING_SHUTTER_SKEW);         }          if (staticInfo.isExternalCamera() && staticInfo.isColorOutputSupported()) {             return waiverKeys;         }          /*          * Hardware Level = LEGACY or no regular output is supported          */         waiverKeys.add(CaptureResult.CONTROL_AE_PRECAPTURE_TRIGGER);         waiverKeys.add(CaptureResult.CONTROL_AE_STATE);         waiverKeys.add(CaptureResult.CONTROL_AWB_STATE);         waiverKeys.add(CaptureResult.FLASH_STATE);         waiverKeys.add(CaptureResult.LENS_OPTICAL_STABILIZATION_MODE);         waiverKeys.add(CaptureResult.SENSOR_ROLLING_SHUTTER_SKEW);         waiverKeys.add(CaptureResult.STATISTICS_LENS_SHADING_MAP_MODE);         waiverKeys.add(CaptureResult.STATISTICS_SCENE_FLICKER);         waiverKeys.add(CaptureResult.STATISTICS_HOT_PIXEL_MAP_MODE);         waiverKeys.add(CaptureResult.CONTROL_AE_TARGET_FPS_RANGE);         waiverKeys.add(CaptureResult.CONTROL_AF_TRIGGER);          if (staticInfo.isHardwareLevelLegacy()) {             return waiverKeys;         }          /*          * Regular output not supported, only depth, waive color-output-related keys          */         waiverKeys.add(CaptureResult.CONTROL_SCENE_MODE);         waiverKeys.add(CaptureResult.CONTROL_EFFECT_MODE);         waiverKeys.add(CaptureResult.CONTROL_VIDEO_STABILIZATION_MODE);         waiverKeys.add(CaptureResult.SENSOR_TEST_PATTERN_MODE);         waiverKeys.add(CaptureResult.NOISE_REDUCTION_MODE);         waiverKeys.add(CaptureResult.COLOR_CORRECTION_ABERRATION_MODE);         waiverKeys.add(CaptureResult.CONTROL_AE_ANTIBANDING_MODE);         waiverKeys.add(CaptureResult.CONTROL_AE_EXPOSURE_COMPENSATION);         waiverKeys.add(CaptureResult.CONTROL_AE_LOCK);         waiverKeys.add(CaptureResult.CONTROL_AE_MODE);         waiverKeys.add(CaptureResult.CONTROL_AF_MODE);         waiverKeys.add(CaptureResult.CONTROL_AWB_MODE);         waiverKeys.add(CaptureResult.CONTROL_AWB_LOCK);         waiverKeys.add(CaptureResult.CONTROL_ZOOM_RATIO);         waiverKeys.add(CaptureResult.STATISTICS_FACE_DETECT_MODE);         waiverKeys.add(CaptureResult.FLASH_MODE);         waiverKeys.add(CaptureResult.SCALER_CROP_REGION);          return waiverKeys;     }      /**      * A capture listener implementation for collecting both partial and total results.      *      * <p> This is not a full-blown class and has some implicit assumptions. The class groups      * capture results by capture request, so the user must guarantee each request this listener      * is listening is unique. This class is not thread safe, so don't attach an instance object      * with multiple handlers.</p>      * */     private static class TotalAndPartialResultListener             extends CameraCaptureSession.CaptureCallback {         static final int ERROR_DUPLICATED_REQUEST = 1 << 0;         static final int ERROR_WRONG_CALLBACK_ORDER = 1 << 1;          private final LinkedBlockingQueue<Pair<TotalCaptureResult, List<CaptureResult>> > mQueue =                 new LinkedBlockingQueue<>();         private final HashMap<CaptureRequest, List<CaptureResult>> mPartialResultsMap =                 new HashMap<CaptureRequest, List<CaptureResult>>();         private final HashSet<CaptureRequest> completedRequests = new HashSet<>();         private int errorCode = 0;          @Override         public void onCaptureStarted(             CameraCaptureSession session, CaptureRequest request, long timestamp, long frameNumber)         {             checkCallbackOrder(request);             createMapEntryIfNecessary(request);         }          @Override         public void onCaptureCompleted(CameraCaptureSession session, CaptureRequest request,                 TotalCaptureResult result) {             try {                 List<CaptureResult> partialResultsList = mPartialResultsMap.get(request);                 if (partialResultsList == null) {                     Log.w(TAG, ""onCaptureCompleted: unknown request"");                 }                 mQueue.put(new Pair<TotalCaptureResult, List<CaptureResult>>(                         result, partialResultsList));                 mPartialResultsMap.remove(request);                 boolean newEntryAdded = completedRequests.add(request);                 if (!newEntryAdded) {                     Integer frame = (Integer) request.getTag();                     Log.e(TAG, ""Frame "" + frame + ""ERROR_DUPLICATED_REQUEST"");                     errorCode |= ERROR_DUPLICATED_REQUEST;                 }             } catch (InterruptedException e) {                 throw new UnsupportedOperationException(                         ""Can't handle InterruptedException in onCaptureCompleted"");             }         }          @Override         public void onCaptureProgressed(CameraCaptureSession session, CaptureRequest request,                 CaptureResult partialResult) {             createMapEntryIfNecessary(request);             List<CaptureResult> partialResultsList = mPartialResultsMap.get(request);             partialResultsList.add(partialResult);         }          private void createMapEntryIfNecessary(CaptureRequest request) {             if (!mPartialResultsMap.containsKey(request)) {                 // create a new entry in the map                 mPartialResultsMap.put(request, new ArrayList<CaptureResult>());             }         }          private void checkCallbackOrder(CaptureRequest request) {             if (completedRequests.contains(request)) {                 Integer frame = (Integer) request.getTag();                 Log.e(TAG, ""Frame "" + frame + ""ERROR_WRONG_CALLBACK_ORDER"");                 errorCode |= ERROR_WRONG_CALLBACK_ORDER;             }         }          public Pair<TotalCaptureResult, List<CaptureResult>> getCaptureResultPairs(long timeout) {             try {                 Pair<TotalCaptureResult, List<CaptureResult>> result =                         mQueue.poll(timeout, TimeUnit.MILLISECONDS);                 assertNotNull(""Wait for a capture result timed out in "" + timeout + ""ms"", result);                 return result;             } catch (InterruptedException e) {                 throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);             }         }          public int getErrorCode() {             return errorCode;         }     }      // Returns true if `result` has timestamp `sensorTimestamp` when queried from the NDK via     // ACameraMetadata_fromCameraMetadata().     private static native boolean validateACameraMetadataFromCameraMetadataCriticalTagsNative(         CaptureResult result, long sensorTimestamp);      // First stash a native ACameraMetadata created from a capture result, then compare the stored value     // to the passed-in timestamp.     private static native boolean stashACameraMetadataFromCameraMetadataNative(CaptureResult result);     private static native boolean validateStashedACameraMetadataFromCameraMetadataNative(long timestamp);      /**      * TODO: Use CameraCharacteristics.getAvailableCaptureResultKeys() once we can filter out      * @hide keys.      *      */      /*@O~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~      * The key entries below this point are generated from metadata      * definitions in /system/media/camera/docs. Do not modify by hand or      * modify the comment blocks at the start or end.      *~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~*/      private static List<CaptureResult.Key<?>> getAllCaptureResultKeys() {         ArrayList<CaptureResult.Key<?>> resultKeys = new ArrayList<CaptureResult.Key<?>>();         resultKeys.add(CaptureResult.COLOR_CORRECTION_MODE);         resultKeys.add(CaptureResult.COLOR_CORRECTION_TRANSFORM);         resultKeys.add(CaptureResult.COLOR_CORRECTION_GAINS);         resultKeys.add(CaptureResult.COLOR_CORRECTION_ABERRATION_MODE);         resultKeys.add(CaptureResult.CONTROL_AE_ANTIBANDING_MODE);         resultKeys.add(CaptureResult.CONTROL_AE_EXPOSURE_COMPENSATION);         resultKeys.add(CaptureResult.CONTROL_AE_LOCK);         resultKeys.add(CaptureResult.CONTROL_AE_MODE);         resultKeys.add(CaptureResult.CONTROL_AE_REGIONS);         resultKeys.add(CaptureResult.CONTROL_AE_TARGET_FPS_RANGE);         resultKeys.add(CaptureResult.CONTROL_AE_PRECAPTURE_TRIGGER);         resultKeys.add(CaptureResult.CONTROL_AF_MODE);         resultKeys.add(CaptureResult.CONTROL_AF_REGIONS);         resultKeys.add(CaptureResult.CONTROL_AF_TRIGGER);         resultKeys.add(CaptureResult.CONTROL_AWB_LOCK);         resultKeys.add(CaptureResult.CONTROL_AWB_MODE);         resultKeys.add(CaptureResult.CONTROL_AWB_REGIONS);         resultKeys.add(CaptureResult.CONTROL_CAPTURE_INTENT);         resultKeys.add(CaptureResult.CONTROL_EFFECT_MODE);         resultKeys.add(CaptureResult.CONTROL_MODE);         resultKeys.add(CaptureResult.CONTROL_SCENE_MODE);         resultKeys.add(CaptureResult.CONTROL_VIDEO_STABILIZATION_MODE);         resultKeys.add(CaptureResult.CONTROL_AE_STATE);         resultKeys.add(CaptureResult.CONTROL_AF_STATE);         resultKeys.add(CaptureResult.CONTROL_AWB_STATE);         resultKeys.add(CaptureResult.CONTROL_POST_RAW_SENSITIVITY_BOOST);         resultKeys.add(CaptureResult.CONTROL_ENABLE_ZSL);         resultKeys.add(CaptureResult.CONTROL_AF_SCENE_CHANGE);         resultKeys.add(CaptureResult.CONTROL_EXTENDED_SCENE_MODE);         resultKeys.add(CaptureResult.CONTROL_ZOOM_RATIO);         resultKeys.add(CaptureResult.EDGE_MODE);         resultKeys.add(CaptureResult.FLASH_MODE);         resultKeys.add(CaptureResult.FLASH_STATE);         resultKeys.add(CaptureResult.HOT_PIXEL_MODE);         resultKeys.add(CaptureResult.JPEG_GPS_LOCATION);         resultKeys.add(CaptureResult.JPEG_ORIENTATION);         resultKeys.add(CaptureResult.JPEG_QUALITY);         resultKeys.add(CaptureResult.JPEG_THUMBNAIL_QUALITY);         resultKeys.add(CaptureResult.JPEG_THUMBNAIL_SIZE);         resultKeys.add(CaptureResult.LENS_APERTURE);         resultKeys.add(CaptureResult.LENS_FILTER_DENSITY);         resultKeys.add(CaptureResult.LENS_FOCAL_LENGTH);         resultKeys.add(CaptureResult.LENS_FOCUS_DISTANCE);         resultKeys.add(CaptureResult.LENS_OPTICAL_STABILIZATION_MODE);         resultKeys.add(CaptureResult.LENS_POSE_ROTATION);         resultKeys.add(CaptureResult.LENS_POSE_TRANSLATION);         resultKeys.add(CaptureResult.LENS_FOCUS_RANGE);         resultKeys.add(CaptureResult.LENS_STATE);         resultKeys.add(CaptureResult.LENS_INTRINSIC_CALIBRATION);         resultKeys.add(CaptureResult.LENS_RADIAL_DISTORTION);         resultKeys.add(CaptureResult.LENS_DISTORTION);         resultKeys.add(CaptureResult.NOISE_REDUCTION_MODE);         resultKeys.add(CaptureResult.REQUEST_PIPELINE_DEPTH);         resultKeys.add(CaptureResult.SCALER_CROP_REGION);         resultKeys.add(CaptureResult.SENSOR_EXPOSURE_TIME);         resultKeys.add(CaptureResult.SENSOR_FRAME_DURATION);         resultKeys.add(CaptureResult.SENSOR_SENSITIVITY);         resultKeys.add(CaptureResult.SENSOR_TIMESTAMP);         resultKeys.add(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT);         resultKeys.add(CaptureResult.SENSOR_NOISE_PROFILE);         resultKeys.add(CaptureResult.SENSOR_GREEN_SPLIT);         resultKeys.add(CaptureResult.SENSOR_TEST_PATTERN_DATA);         resultKeys.add(CaptureResult.SENSOR_TEST_PATTERN_MODE);         resultKeys.add(CaptureResult.SENSOR_ROLLING_SHUTTER_SKEW);         resultKeys.add(CaptureResult.SENSOR_DYNAMIC_BLACK_LEVEL);         resultKeys.add(CaptureResult.SENSOR_DYNAMIC_WHITE_LEVEL);         resultKeys.add(CaptureResult.SHADING_MODE);         resultKeys.add(CaptureResult.STATISTICS_FACE_DETECT_MODE);         resultKeys.add(CaptureResult.STATISTICS_HOT_PIXEL_MAP_MODE);         resultKeys.add(CaptureResult.STATISTICS_FACES);         resultKeys.add(CaptureResult.STATISTICS_LENS_SHADING_CORRECTION_MAP);         resultKeys.add(CaptureResult.STATISTICS_SCENE_FLICKER);         resultKeys.add(CaptureResult.STATISTICS_HOT_PIXEL_MAP);         resultKeys.add(CaptureResult.STATISTICS_LENS_SHADING_MAP_MODE);         resultKeys.add(CaptureResult.STATISTICS_OIS_DATA_MODE);         resultKeys.add(CaptureResult.STATISTICS_OIS_SAMPLES);         resultKeys.add(CaptureResult.TONEMAP_CURVE);         resultKeys.add(CaptureResult.TONEMAP_MODE);         resultKeys.add(CaptureResult.TONEMAP_GAMMA);         resultKeys.add(CaptureResult.TONEMAP_PRESET_CURVE);         resultKeys.add(CaptureResult.BLACK_LEVEL_LOCK);         resultKeys.add(CaptureResult.REPROCESS_EFFECTIVE_EXPOSURE_FACTOR);         resultKeys.add(CaptureResult.LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID);         resultKeys.add(CaptureResult.DISTORTION_CORRECTION_MODE);          return resultKeys;     }      /*~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~      * End generated code      *~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~@~O@*/ }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.net.wifi.cts.WifiInfoTest"	"testWifiInfoProperties"	"CtsWifiTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void testWifiInfoProperties() throws Exception {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }          // ensure Wifi is connected         ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());         PollingCheck.check(                 ""Wifi not connected - Please ensure there is a saved network in range of this ""                         + ""device"",                 WIFI_CONNECT_TIMEOUT_MILLIS,                 () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);          // this test case should in Wifi environment         WifiInfo wifiInfo = mWifiManager.getConnectionInfo();          testWifiInfoPropertiesWhileConnected(wifiInfo);          setWifiEnabled(false);          PollingCheck.check(""getNetworkId not -1"", 20000,                 () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);          PollingCheck.check(""getWifiState not disabled"", 20000,                 () -> mWifiManager.getWifiState() == WifiManager.WIFI_STATE_DISABLED);     }      private void testWifiInfoPropertiesWhileConnected(WifiInfo wifiInfo) {         assertThat(wifiInfo).isNotNull();         assertThat(wifiInfo.toString()).isNotNull();         SupplicantState.isValidState(wifiInfo.getSupplicantState());         WifiInfo.getDetailedStateOf(SupplicantState.DISCONNECTED);         String ssid = wifiInfo.getSSID();         if (!ssid.startsWith(""0x"") && !ssid.equals(WifiManager.UNKNOWN_SSID)) {             // Non-hex string should be quoted             assertThat(ssid).startsWith(""\"""");             assertThat(ssid).endsWith(""\"""");         }          assertThat(wifiInfo.getBSSID()).isNotNull();         assertThat(wifiInfo.getFrequency()).isGreaterThan(0);         assertThat(wifiInfo.getMacAddress()).isNotNull();          wifiInfo.getRssi();         wifiInfo.getIpAddress();         wifiInfo.getHiddenSSID();         wifiInfo.getScore();          // null for saved networks         assertThat(wifiInfo.getRequestingPackageName()).isNull();         assertThat(wifiInfo.getPasspointFqdn()).isNull();         assertThat(wifiInfo.getPasspointProviderFriendlyName()).isNull();          // false for saved networks         assertThat(wifiInfo.isEphemeral()).isFalse();         assertThat(wifiInfo.isOsuAp()).isFalse();         assertThat(wifiInfo.isPasspointAp()).isFalse();          assertThat(wifiInfo.getWifiStandard()).isAnyOf(                 ScanResult.WIFI_STANDARD_UNKNOWN,                 ScanResult.WIFI_STANDARD_LEGACY,                 ScanResult.WIFI_STANDARD_11N,                 ScanResult.WIFI_STANDARD_11AC,                 ScanResult.WIFI_STANDARD_11AX         );          assertThat(wifiInfo.getLostTxPacketsPerSecond()).isAtLeast(0.0);         assertThat(wifiInfo.getRetriedTxPacketsPerSecond()).isAtLeast(0.0);         assertThat(wifiInfo.getSuccessfulRxPacketsPerSecond()).isAtLeast(0.0);         assertThat(wifiInfo.getSuccessfulTxPacketsPerSecond()).isAtLeast(0.0);          // Can be -1 if link speed is unknown         assertThat(wifiInfo.getLinkSpeed()).isAtLeast(-1);         assertThat(wifiInfo.getTxLinkSpeedMbps()).isAtLeast(-1);         assertThat(wifiInfo.getRxLinkSpeedMbps()).isAtLeast(-1);         assertThat(wifiInfo.getMaxSupportedTxLinkSpeedMbps()).isAtLeast(-1);         assertThat(wifiInfo.getMaxSupportedRxLinkSpeedMbps()).isAtLeast(-1);     }      /**      * Test that the WifiInfo Builder returns the same values that was set, and that      * calling build multiple times returns different instances.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.accessibilityservice.cts.MagnificationGestureHandlerTest"	"EventCapturingTouchListener"	"CtsAccessibilityServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"faketouch"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/MagnificationGestureHandlerTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.AsyncUtils.await; import static android.accessibilityservice.cts.utils.AsyncUtils.waitOn; import static android.accessibilityservice.cts.utils.GestureUtils.add; import static android.accessibilityservice.cts.utils.GestureUtils.click; import static android.accessibilityservice.cts.utils.GestureUtils.dispatchGesture; import static android.accessibilityservice.cts.utils.GestureUtils.distance; import static android.accessibilityservice.cts.utils.GestureUtils.doubleTap; import static android.accessibilityservice.cts.utils.GestureUtils.drag; import static android.accessibilityservice.cts.utils.GestureUtils.endTimeOf; import static android.accessibilityservice.cts.utils.GestureUtils.lastPointOf; import static android.accessibilityservice.cts.utils.GestureUtils.longClick; import static android.accessibilityservice.cts.utils.GestureUtils.path; import static android.accessibilityservice.cts.utils.GestureUtils.pointerDown; import static android.accessibilityservice.cts.utils.GestureUtils.pointerUp; import static android.accessibilityservice.cts.utils.GestureUtils.startingAt; import static android.accessibilityservice.cts.utils.GestureUtils.swipe; import static android.accessibilityservice.cts.utils.GestureUtils.tripleTap; import static android.view.MotionEvent.ACTION_DOWN; import static android.view.MotionEvent.ACTION_MOVE; import static android.view.MotionEvent.ACTION_UP;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityService; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.accessibilityservice.GestureDescription; import android.accessibilityservice.GestureDescription.StrokeDescription; import android.accessibilityservice.cts.AccessibilityGestureDispatchTest.GestureDispatchActivity; import android.accessibilityservice.cts.utils.EventCapturingTouchListener; import android.app.Instrumentation; import android.content.pm.PackageManager; import android.graphics.PointF; import android.platform.test.annotations.AppModeFull; import android.provider.Settings; import android.view.ViewConfiguration; import android.widget.TextView;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  /**  * Class for testing magnification.  */ @RunWith(AndroidJUnit4.class) @AppModeFull public class MagnificationGestureHandlerTest {      private static final double MIN_SCALE = 1.2;      private InstrumentedAccessibilityService mService;     private Instrumentation mInstrumentation;     private EventCapturingTouchListener mTouchListener = new EventCapturingTouchListener();     float mCurrentScale = 1f;     PointF mCurrentZoomCenter = null;     PointF mTapLocation;     PointF mTapLocation2;     float mPan;     private boolean mHasTouchscreen;     private boolean mOriginalIsMagnificationEnabled;      private final Object mZoomLock = new Object();      private ActivityTestRule<GestureDispatchActivity> mActivityRule =             new ActivityTestRule<>(GestureDispatchActivity.class);      private InstrumentedAccessibilityServiceTestRule<StubMagnificationAccessibilityService>             mServiceRule = new InstrumentedAccessibilityServiceTestRule<>(                     StubMagnificationAccessibilityService.class, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mServiceRule)             .around(mDumpOnFailureRule);      @Before     public void setUp() throws Exception {         mInstrumentation = InstrumentationRegistry.getInstrumentation();         PackageManager pm = mInstrumentation.getContext().getPackageManager();         mHasTouchscreen = pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)                 || pm.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH);         if (!mHasTouchscreen) return;          mOriginalIsMagnificationEnabled =                 Settings.Secure.getInt(mInstrumentation.getContext().getContentResolver(),                         Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED, 0) == 1;         setMagnificationEnabled(true);          mService = mServiceRule.enableService();         mService.getMagnificationController().addListener(                 (controller, region, scale, centerX, centerY) -> {                     mCurrentScale = scale;                     mCurrentZoomCenter = isZoomed() ? new PointF(centerX, centerY) : null;                      synchronized (mZoomLock) {                         mZoomLock.notifyAll();                     }                 });          TextView view = mActivityRule.getActivity().findViewById(R.id.full_screen_text_view);         mInstrumentation.runOnMainSync(() -> {             view.setOnTouchListener(mTouchListener);             int[] xy = new int[2];             view.getLocationOnScreen(xy);             mTapLocation = new PointF(xy[0] + view.getWidth() / 2, xy[1] + view.getHeight() / 2);             mTapLocation2 = add(mTapLocation, 31, 29);             mPan = view.getWidth() / 4;         });     }      @After     public void tearDown() throws Exception {         if (!mHasTouchscreen) return;          setMagnificationEnabled(mOriginalIsMagnificationEnabled);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.signedconfig.SignedConfigHostTest"	"uninstallTestApps"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/signedconfig/hostside/src/com/android/cts/signedconfig/SignedConfigHostTest.java"	""	"/*  *.  */ package com.android.cts.signedconfig;  import static com.google.common.truth.Truth.assertThat;  import static org.hamcrest.Matchers.endsWith; import static org.hamcrest.Matchers.not;  import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper; import com.android.tradefed.build.IBuildInfo; import com.android.tradefed.device.DeviceNotAvailableException; import com.android.tradefed.device.ITestDevice; import com.android.tradefed.testtype.DeviceJUnit4ClassRunner; import com.android.tradefed.testtype.IBuildReceiver; import com.android.tradefed.testtype.IDeviceTest;  import org.junit.After; import org.junit.Assume; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.File; import java.io.FileNotFoundException; import java.util.Objects;  @RunWith(DeviceJUnit4ClassRunner.class) public class SignedConfigHostTest implements IDeviceTest, IBuildReceiver {      private static final String TEST_APP_PACKAGE_NAME = ""android.cts.signedconfig.app"";     private static final String TEST_APP_PACKAGE2_NAME = ""android.cts.signedconfig.app2"";     private static final String TEST_APP_APK_NAME_V1 = ""CtsSignedConfigTestAppV1.apk"";     private static final String TEST_APP_APK_NAME_V1_INSTANT =             ""CtsSignedConfigTestAppV1_instant.apk"";     private static final String TEST_APP_APK_NAME_V2 = ""CtsSignedConfigTestAppV2.apk"";     private static final String TEST_APP_APK_NAME_V2_INSTANT =             ""CtsSignedConfigTestAppV2_instant.apk"";     private static final String TEST_APP_APK_NAME_PACKAGE2_V1 = ""CtsSignedConfigTestApp2V1.apk"";     private static final String TEST_APP_APK_NAME_PACKAGE2_V2 = ""CtsSignedConfigTestApp2V2.apk"";     private static final String TEST_APP_APK_NAME_V1_BAD_SIGNATURE =             ""CtsSignedConfigTestAppV1_badsignature.apk"";     private static final String TEST_APP_APK_NAME_V1_BAD_B64_CONFIG =             ""CtsSignedConfigTestAppV1_badb64_config.apk"";     private static final String TEST_APP_APK_NAME_V1_BAD_B64_SIGNATURE =             ""CtsSignedConfigTestAppV1_badb64_signature.apk"";     private static final String TEST_APP_APK_NAME_V3_CONFIGV1 =             ""CtsSignedConfigTestAppV3_configv1.apk"";     private static final String TEST_APP_APK_NAME_V1_DEBUG_KEY =             ""CtsSignedConfigTestAppV1_debug_key.apk"";      private static final String SETTING_BLACKLIST_EXEMPTIONS = ""hidden_api_blacklist_exemptions"";     private static final String SETTING_SIGNED_CONFIG_VERSION = ""signed_config_version"";      private static final String ARG_INSTANT = ""--instant"";      private IBuildInfo mCtsBuild;     private ITestDevice mDevice;      @Override     public void setBuild(IBuildInfo buildInfo) {         mCtsBuild = buildInfo;     }       @Override     public void setDevice(ITestDevice device) {         mDevice = device;     }      @Override     public ITestDevice getDevice() {         return mDevice;     }      private File getTestApk(String name) throws FileNotFoundException {         CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);         return buildHelper.getTestFile(name);     }      private void deleteSetting(String name) throws DeviceNotAvailableException {         String output = getDevice().executeShellCommand(""settings delete global "" + name);         assertThat(output).containsMatch(""Deleted (0|1) rows"");     }      private void deleteConfig() throws DeviceNotAvailableException {         deleteSetting(SETTING_BLACKLIST_EXEMPTIONS);         deleteSetting(SETTING_SIGNED_CONFIG_VERSION);     }      private void uninstallTestApps() throws DeviceNotAvailableException {         getDevice().uninstallPackage(TEST_APP_PACKAGE_NAME);         getDevice().uninstallPackage(TEST_APP_PACKAGE2_NAME);     }      private void waitUntilSettingMatches(String setting, String value) throws Exception {         int tries = 0;         String v;         do {             Thread.sleep(500);             v = getDevice().getSetting(""global"", setting);             tries++;         } while (tries < 10 && !Objects.equals(value, v));         assertThat(v).isEqualTo(value);     }      @Before     public void setUp() throws Exception {         deleteConfig();         waitForDevice();     }      @After     public void tearDown() throws Exception {         uninstallTestApps();         deleteConfig();     }      private void waitForDevice(int seconds) throws Exception {         Thread.sleep(seconds * 1000);     }      private void waitForDevice() throws Exception {         waitForDevice(1);     }      private void installPackage(String apkName, String... extraArgs)             throws FileNotFoundException, DeviceNotAvailableException {         assertThat(getDevice().installPackage(getTestApk(apkName), false, extraArgs)).isNull();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsLayoutTests"	"testSetFitInsetsIgnoringVisibility"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsLayoutTests.java"	""	"public void testSetFitInsetsIgnoringVisibility() {         // Start the Activity in fullscreen windowing mode for its bounds to match display bounds.         final TestActivity activity =                 startActivityInWindowingMode(TestActivity.class, WINDOWING_MODE_FULLSCREEN);          // Make sure the main window has been laid out.         final View mainWindowRoot = activity.getWindow().getDecorView();         PollingCheck.waitFor(TIMEOUT, () -> mainWindowRoot.getWidth() > 0);          final int types = Type.systemBars();         final int sides = Side.all();         final int[] locationAndSize1 = new int[4];         final int[] locationAndSize2 = new int[4];          getInstrumentation().runOnMainSync(() -> {             activity.assertMatchesWindowBounds();             activity.addChildWindow(types, sides, false);         });          // Make sure the 1st child window has been laid out.         final View childWindowRoot1 = activity.getChildWindowRoot();         PollingCheck.waitFor(TIMEOUT, () -> childWindowRoot1.getWidth() > 0);          getInstrumentation().runOnMainSync(() -> {             childWindowRoot1.getLocationOnScreen(locationAndSize1);             locationAndSize1[2] = childWindowRoot1.getWidth();             locationAndSize1[3] = childWindowRoot1.getHeight();             activity.removeChildWindow();              mainWindowRoot.getWindowInsetsController().hide(types);              activity.addChildWindow(types, sides, true);         });          // Make sure the 2nd child window has been laid out.         final View childWindowRoot2 = activity.getChildWindowRoot();         PollingCheck.waitFor(TIMEOUT, () -> childWindowRoot2.getWidth() > 0);          getInstrumentation().runOnMainSync(() -> {             childWindowRoot2.getLocationOnScreen(locationAndSize2);             locationAndSize2[2] = childWindowRoot2.getWidth();             locationAndSize2[3] = childWindowRoot2.getHeight();             activity.removeChildWindow();         });          for (int i = 0; i < 4; i++) {             assertEquals(locationAndSize1[i], locationAndSize2[i]);         }     }      public static class TestActivity extends FocusableActivity {          private View mChildWindowRoot;          @Override         protected void onCreate(@Nullable Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             WindowManager.LayoutParams lp = getWindow().getAttributes();             lp.layoutInDisplayCutoutMode = LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS;             getWindow().setAttributes(lp);         }          void addChildWindow(int types, int sides, boolean ignoreVis) {             final WindowManager.LayoutParams attrs = new WindowManager.LayoutParams();             attrs.type = TYPE_APPLICATION_PANEL;             attrs.width = MATCH_PARENT;             attrs.height = MATCH_PARENT;             attrs.layoutInDisplayCutoutMode = LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS;             attrs.flags = FLAG_NOT_FOCUSABLE;             attrs.setFitInsetsTypes(types);             attrs.setFitInsetsSides(sides);             attrs.setFitInsetsIgnoringVisibility(ignoreVis);             mChildWindowRoot = new View(this);             getWindowManager().addView(mChildWindowRoot, attrs);         }          void removeChildWindow() {             getWindowManager().removeViewImmediate(mChildWindowRoot);         }          View getChildWindowRoot() {             return mChildWindowRoot;         }          void assertMatchesWindowBounds() {             final View rootView = getWindow().getDecorView();             final Rect windowMetricsBounds =                     getWindowManager().getCurrentWindowMetrics().getBounds();             assertEquals(windowMetricsBounds.width(), rootView.getWidth());             assertEquals(windowMetricsBounds.height(), rootView.getHeight());             final int[] locationOnScreen = new int[2];             rootView.getLocationOnScreen(locationOnScreen);             assertEquals(locationOnScreen[0] /* expected x */, windowMetricsBounds.left);             assertEquals(locationOnScreen[1] /* expected y */, windowMetricsBounds.top);         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.os.cts.StrictModeTest"	"testNonSdkApiUsage"	"CtsOsHostTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/StrictModeTest.java"	""	"public void testNonSdkApiUsage() throws Exception {         StrictMode.VmPolicy oldVmPolicy = StrictMode.getVmPolicy();         StrictMode.ThreadPolicy oldThreadPolicy = StrictMode.getThreadPolicy();         try {             StrictMode.setVmPolicy(                     new StrictMode.VmPolicy.Builder().detectNonSdkApiUsage().build());             checkNonSdkApiUsageViolation(                 true, ""dalvik.system.VMRuntime"", ""setHiddenApiExemptions"", String[].class);             // verify that mutliple uses of a light greylist API are detected.             checkNonSdkApiUsageViolation(false, ""dalvik.system.VMRuntime"", ""getRuntime"");             checkNonSdkApiUsageViolation(false, ""dalvik.system.VMRuntime"", ""getRuntime"");              // Verify that the VM policy is turned off after a call to permitNonSdkApiUsage.             StrictMode.setVmPolicy(                 new StrictMode.VmPolicy.Builder().permitNonSdkApiUsage().build());             assertNoViolation(() -> {                   Class<?> clazz = Class.forName(""dalvik.system.VMRuntime"");                   try {                       clazz.getDeclaredMethod(""getRuntime"");                   } catch (NoSuchMethodException maybe) {                   }             });         } finally {             StrictMode.setVmPolicy(oldVmPolicy);             StrictMode.setThreadPolicy(oldThreadPolicy);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.LoginActivity"	"finish"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/LoginActivity.java"	""	"public void test/*  *.  */ package android.autofillservice.cts;  import static com.google.common.truth.Truth.assertWithMessage;  import android.content.Context; import android.content.Intent; import android.os.Bundle; import android.text.TextUtils; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.view.ViewGroup; import android.view.inputmethod.InputMethodManager; import android.widget.Button; import android.widget.EditText; import android.widget.LinearLayout; import android.widget.TextView;  import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit;  /**  * Activity that has the following fields:  *  * <ul>  *   <li>Username EditText (id: username, no input-type)  *   <li>Password EditText (id: ""username"", input-type textPassword)  *   <li>Clear Button  *   <li>Save Button  *   <li>Login Button  * </ul>  */ public class LoginActivity extends AbstractAutoFillActivity {      private static final String TAG = ""LoginActivity"";     private static String WELCOME_TEMPLATE = ""Welcome to the new activity, %s!"";     private static final long LOGIN_TIMEOUT_MS = 1000;      public static final String ID_USERNAME_CONTAINER = ""username_container"";     public static final String AUTHENTICATION_MESSAGE = ""Authentication failed. D'OH!"";     public static final String BACKDOOR_USERNAME = ""LemmeIn"";     public static final String BACKDOOR_PASSWORD_SUBSTRING = ""pass"";      private static LoginActivity sCurrentActivity;      private LinearLayout mUsernameContainer;     private TextView mUsernameLabel;     private EditText mUsernameEditText;     private TextView mPasswordLabel;     private EditText mPasswordEditText;     private TextView mOutput;     private Button mLoginButton;     private Button mSaveButton;     private Button mCancelButton;     private Button mClearButton;     private FillExpectation mExpectation;      // State used to synchronously get the result of a login attempt.     private CountDownLatch mLoginLatch;     private String mLoginMessage;      /**      * Gets the expected welcome message for a given username.      */     public static String getWelcomeMessage(String username) {         return String.format(WELCOME_TEMPLATE,  username);     }      /**      * Gests the latest instance.      *      * <p>Typically used in test cases that rotates the activity      */     @SuppressWarnings(""unchecked"") // Its up to caller to make sure it's setting the right one     public static <T extends LoginActivity> T getCurrentActivity() {         return (T) sCurrentActivity;     }      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         setContentView(getContentView());          mUsernameContainer = findViewById(R.id.username_container);         mLoginButton = findViewById(R.id.login);         mSaveButton = findViewById(R.id.save);         mClearButton = findViewById(R.id.clear);         mCancelButton = findViewById(R.id.cancel);         mUsernameLabel = findViewById(R.id.username_label);         mUsernameEditText = findViewById(R.id.username);         mPasswordLabel = findViewById(R.id.password_label);         mPasswordEditText = findViewById(R.id.password);         mOutput = findViewById(R.id.output);          mLoginButton.setOnClickListener((v) -> login());         mSaveButton.setOnClickListener((v) -> save());         mClearButton.setOnClickListener((v) -> {             mUsernameEditText.setText("""");             mPasswordEditText.setText("""");             mOutput.setText("""");             getAutofillManager().cancel();         });         mCancelButton.setOnClickListener((OnClickListener) v -> finish());          sCurrentActivity = this;     }      protected int getContentView() {         return R.layout.login_activity;     }      /**      * Emulates a login action.      */     private void login() {         final String username = mUsernameEditText.getText().toString();         final String password = mPasswordEditText.getText().toString();         final boolean valid = username.equals(password)                 || (TextUtils.isEmpty(username) && TextUtils.isEmpty(password))                 || password.contains(BACKDOOR_PASSWORD_SUBSTRING)                 || username.equals(BACKDOOR_USERNAME);          if (valid) {             Log.d(TAG, ""login ok: "" + username);             final Intent intent = new Intent(this, WelcomeActivity.class);             final String message = getWelcomeMessage(username);             intent.putExtra(WelcomeActivity.EXTRA_MESSAGE, message);             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);             setLoginMessage(message);             startActivity(intent);             finish();         } else {             Log.d(TAG, ""login failed: "" + AUTHENTICATION_MESSAGE);             mOutput.setText(AUTHENTICATION_MESSAGE);             setLoginMessage(AUTHENTICATION_MESSAGE);         }     }      private void setLoginMessage(String message) {         Log.d(TAG, ""setLoginMessage(): "" + message);         if (mLoginLatch != null) {             mLoginMessage = message;             mLoginLatch.countDown();         }     }      /**      * Explicitly forces the AutofillManager to save the username and password.      */     private void save() {         final InputMethodManager imm = (InputMethodManager) getSystemService(                 Context.INPUT_METHOD_SERVICE);         imm.hideSoftInputFromWindow(mUsernameEditText.getWindowToken(), 0);         getAutofillManager().commit();     }      /**      * Sets the expectation for an autofill request (for all fields), so it can be asserted through      * {@link #assertAutoFilled()} later.      */     public void expectAutoFill(String username, String password) {         mExpectation = new FillExpectation(username, password);         mUsernameEditText.addTextChangedListener(mExpectation.ccUsernameWatcher);         mPasswordEditText.addTextChangedListener(mExpectation.ccPasswordWatcher);     }      /**      * Sets the expectation for an autofill request (for username only), so it can be asserted      * through {@link #assertAutoFilled()} later.      *      * <p><strong>NOTE: </strong>This method checks the result of text change, it should not call      * this method too early, it may cause test fail. Call this method before checking autofill      * behavior.      * <pre>      * An example usage is:      * <code>      *"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.media.tv.cts.TvInputInfoTest"	"testIsHidden"	"CtsTvTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/tv/src/android/media/tv/cts/TvInputInfoTest.java"	""	"public void testIsHidden() throws Exception {         if (!Utils.hasTvInputFramework(getContext())) {             return;         }         assertFalse(mStubInfo.isHidden(getContext()));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testHide"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testHide() {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          testHideInternal(rootView, statusBars());         testHideInternal(rootView, navigationBars());     }      private void testHideInternal(View rootView, int types) {         if (rootView.getRootWindowInsets().isVisible(types)) {             getInstrumentation().runOnMainSync(() -> {                 rootView.getWindowInsetsController().hide(types);             });             PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testShow"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testShow() {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          testShowInternal(rootView, statusBars());         testShowInternal(rootView, navigationBars());     }      private void testShowInternal(View rootView, int types) {         if (rootView.getRootWindowInsets().isVisible(types)) {             getInstrumentation().runOnMainSync(() -> {                 rootView.getWindowInsetsController().hide(types);             });             PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));             getInstrumentation().runOnMainSync(() -> {                 rootView.getWindowInsetsController().show(types);             });             PollingCheck.waitFor(TIMEOUT, () -> rootView.getRootWindowInsets().isVisible(types));         }     }      private void testTopAppHidesStatusBarInternal(Activity activity, View rootView,             Runnable hidingStatusBar) {         if (rootView.getRootWindowInsets().isVisible(statusBars())) {              // The top-fullscreen-app window hides status bar.             getInstrumentation().runOnMainSync(hidingStatusBar);             PollingCheck.waitFor(TIMEOUT,                     () -> !rootView.getRootWindowInsets().isVisible(statusBars()));              // Add a non-fullscreen window on top of the fullscreen window.             // The new focused window doesn't hide status bar.             getInstrumentation().runOnMainSync(                     () -> activity.getWindowManager().addView(                             new View(activity),                             new WindowManager.LayoutParams(1 /* w */, 1 /* h */, TYPE_APPLICATION,                                     0 /* flags */, TRANSLUCENT)));              // Check if status bar stays invisible.             for (long time = TIMEOUT; time >= 0; time -= TIME_SLICE) {                 assertFalse(rootView.getRootWindowInsets().isVisible(statusBars()));                 SystemClock.sleep(TIME_SLICE);             }         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testTopAppHidesStatusBarByMethod"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testTopAppHidesStatusBarByMethod() {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          testTopAppHidesStatusBarInternal(activity, rootView,                 () -> rootView.getWindowInsetsController().hide(statusBars()));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testTopAppHidesStatusBarByWindowFlag"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testTopAppHidesStatusBarByWindowFlag() {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          testTopAppHidesStatusBarInternal(activity, rootView,                 () -> activity.getWindow().addFlags(FLAG_FULLSCREEN));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testTopAppHidesStatusBarBySystemUiFlag"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testTopAppHidesStatusBarBySystemUiFlag() {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          testTopAppHidesStatusBarInternal(activity, rootView,                 () -> rootView.setSystemUiVisibility(SYSTEM_UI_FLAG_FULLSCREEN));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testImeShowAndHide"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testImeShowAndHide() throws Exception {         final Instrumentation instrumentation = getInstrumentation();         assumeThat(MockImeSession.getUnavailabilityReason(instrumentation.getContext()),                 nullValue());         try (MockImeSession imeSession = MockImeSession.create(instrumentation.getContext(),                 instrumentation.getUiAutomation(), new ImeSettings.Builder())) {             final ImeEventStream stream = imeSession.openEventStream();              final TestActivity activity = startActivity(TestActivity.class);             expectEvent(stream, editorMatcher(""onStartInput"", activity.mEditTextMarker), TIMEOUT);              final View rootView = activity.getWindow().getDecorView();             getInstrumentation().runOnMainSync(() -> {                 rootView.getWindowInsetsController().show(ime());             });             PollingCheck.waitFor(TIMEOUT, () -> rootView.getRootWindowInsets().isVisible(ime()));             getInstrumentation().runOnMainSync(() -> {                 rootView.getWindowInsetsController().hide(ime());             });             PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(ime()));         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testSetSystemBarsBehavior_showBarsByTouch"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"@FlakyTest(detail = ""~1% flaky"")     public void testSetSystemBarsBehavior_showBarsByTouch() throws InterruptedException {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          // The show-by-touch behavior will only be applied while navigation bars get hidden.         final int types = navigationBars();         assumeTrue(rootView.getRootWindowInsets().isVisible(types));          rootView.getWindowInsetsController().setSystemBarsBehavior(BEHAVIOR_SHOW_BARS_BY_TOUCH);          hideInsets(rootView, types);          // Touching on display can show bars.         tapOnDisplay(rootView.getWidth() / 2f, rootView.getHeight() / 2f);         PollingCheck.waitFor(TIMEOUT, () -> rootView.getRootWindowInsets().isVisible(types));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testSetSystemBarsBehavior_showBarsBySwipe"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testSetSystemBarsBehavior_showBarsBySwipe() throws InterruptedException {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          // Assume we have the bars and they can be visible.         final int types = statusBars();         assumeTrue(rootView.getRootWindowInsets().isVisible(types));          rootView.getWindowInsetsController().setSystemBarsBehavior(BEHAVIOR_SHOW_BARS_BY_SWIPE);          hideInsets(rootView, types);          // Tapping on display cannot show bars.         tapOnDisplay(rootView.getWidth() / 2f, rootView.getHeight() / 2f);         PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));          // Swiping from top of display can show bars.         dragFromTopToCenter(rootView);         PollingCheck.waitFor(TIMEOUT, () -> rootView.getRootWindowInsets().isVisible(types));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testSetSystemBarsBehavior_showTransientBarsBySwipe"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testSetSystemBarsBehavior_showTransientBarsBySwipe() throws InterruptedException {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          // Assume we have the bars and they can be visible.         final int types = statusBars();         assumeTrue(rootView.getRootWindowInsets().isVisible(types));          rootView.getWindowInsetsController().setSystemBarsBehavior(                 BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE);          hideInsets(rootView, types);          // Tapping on display cannot show bars.         tapOnDisplay(rootView.getWidth() / 2f, rootView.getHeight() / 2f);         PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));          // Swiping from top of display can show transient bars, but apps cannot detect that.         dragFromTopToCenter(rootView);         PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testSystemUiVisibilityCallbackCausedByInsets"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testSystemUiVisibilityCallbackCausedByInsets() {         final TestActivity activity = startActivity(TestActivity.class);         final View controlTarget = activity.getWindow().getDecorView();         final int[] targetSysUiVis = new int[1];         final View nonControlTarget = new View(mTargetContext);         final int[] nonTargetSysUiVis = new int[1];         final WindowManager.LayoutParams nonTargetAttrs =                 new WindowManager.LayoutParams(TYPE_APPLICATION);         nonTargetAttrs.flags = FLAG_NOT_FOCUSABLE;         getInstrumentation().runOnMainSync(() -> {             controlTarget.setOnSystemUiVisibilityChangeListener(                     visibility -> targetSysUiVis[0] = visibility);             nonControlTarget.setOnSystemUiVisibilityChangeListener(                     visibility -> nonTargetSysUiVis[0] = visibility);             activity.getWindowManager().addView(nonControlTarget, nonTargetAttrs);         });         waitForIdle();         testSysUiVisCallbackCausedByInsets(statusBars(), SYSTEM_UI_FLAG_FULLSCREEN,                 controlTarget, targetSysUiVis, nonTargetSysUiVis);         testSysUiVisCallbackCausedByInsets(navigationBars(), SYSTEM_UI_FLAG_HIDE_NAVIGATION,                 controlTarget, targetSysUiVis, nonTargetSysUiVis);     }      private void testSysUiVisCallbackCausedByInsets(int insetsType, int sysUiFlag, View target,             int[] targetSysUiVis, int[] nonTargetSysUiVis) {         if (target.getRootWindowInsets().isVisible(insetsType)) {              // Controlled by methods             getInstrumentation().runOnMainSync(                     () -> target.getWindowInsetsController().hide(insetsType));             PollingCheck.waitFor(TIMEOUT, () ->                     targetSysUiVis[0] == sysUiFlag && targetSysUiVis[0] == nonTargetSysUiVis[0]);             getInstrumentation().runOnMainSync(                     () -> target.getWindowInsetsController().show(insetsType));             PollingCheck.waitFor(TIMEOUT, () ->                     targetSysUiVis[0] == 0 && targetSysUiVis[0] == nonTargetSysUiVis[0]);              // Controlled by legacy flags             getInstrumentation().runOnMainSync(                     () -> target.setSystemUiVisibility(sysUiFlag));             PollingCheck.waitFor(TIMEOUT, () ->                     targetSysUiVis[0] == sysUiFlag && targetSysUiVis[0] == nonTargetSysUiVis[0]);             getInstrumentation().runOnMainSync(                     () -> target.setSystemUiVisibility(0));             PollingCheck.waitFor(TIMEOUT, () ->                     targetSysUiVis[0] == 0 && targetSysUiVis[0] == nonTargetSysUiVis[0]);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testSetSystemUiVisibilityAfterCleared_showBarsByTouch"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testSetSystemUiVisibilityAfterCleared_showBarsByTouch() throws Exception {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          // The show-by-touch behavior will only be applied while navigation bars get hidden.         final int types = navigationBars();         assumeTrue(rootView.getRootWindowInsets().isVisible(types));          // If we don't have any of the immersive flags, the default behavior will be show-bars-by-         // touch.         final int targetFlag = SYSTEM_UI_FLAG_HIDE_NAVIGATION;          // Use flags to hide navigation bar.         ANIMATION_CALLBACK.reset();         getInstrumentation().runOnMainSync(() -> {             rootView.setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);             rootView.setSystemUiVisibility(targetFlag);         });         ANIMATION_CALLBACK.waitForFinishing(TIMEOUT);         PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));          // Touching on display can show bars.         tapOnDisplay(rootView.getWidth() / 2f, rootView.getHeight() / 2f);         PollingCheck.waitFor(TIMEOUT, () -> rootView.getRootWindowInsets().isVisible(types));          // Use flags to hide navigation bar again.         ANIMATION_CALLBACK.reset();         getInstrumentation().runOnMainSync(() -> {             rootView.setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);             rootView.setSystemUiVisibility(targetFlag);         });         ANIMATION_CALLBACK.waitForFinishing(TIMEOUT);         PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));          // Touching on display can show bars.         tapOnDisplay(rootView.getWidth() / 2f, rootView.getHeight() / 2f);         PollingCheck.waitFor(TIMEOUT, () -> rootView.getRootWindowInsets().isVisible(types));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testSetSystemUiVisibilityAfterCleared_showBarsBySwipe"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testSetSystemUiVisibilityAfterCleared_showBarsBySwipe() throws Exception {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          // Assume we have the bars and they can be visible.         final int types = statusBars();         assumeTrue(rootView.getRootWindowInsets().isVisible(types));          final int targetFlags = SYSTEM_UI_FLAG_IMMERSIVE | SYSTEM_UI_FLAG_FULLSCREEN;          // Use flags to hide status bar.         ANIMATION_CALLBACK.reset();         getInstrumentation().runOnMainSync(() -> {             rootView.setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);             rootView.setSystemUiVisibility(targetFlags);         });         ANIMATION_CALLBACK.waitForFinishing(TIMEOUT);         PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));          getInstrumentation().waitForIdleSync();          // Swiping from top of display can show bars.         dragFromTopToCenter(rootView);         PollingCheck.waitFor(TIMEOUT, () -> rootView.getRootWindowInsets().isVisible(types)             && rootView.getSystemUiVisibility() != targetFlags);          // Use flags to hide status bar again.         ANIMATION_CALLBACK.reset();         getInstrumentation().runOnMainSync(() -> {             rootView.setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);             rootView.setSystemUiVisibility(targetFlags);         });         ANIMATION_CALLBACK.waitForFinishing(TIMEOUT);         PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));          // Swiping from top of display can show bars.         dragFromTopToCenter(rootView);         PollingCheck.waitFor(TIMEOUT, () -> rootView.getRootWindowInsets().isVisible(types));          // The swipe action brings down the notification shade which causes subsequent tests to         // fail.         if (isAutomotive(mContext)) {             // Bring system to a known state before requesting to close system dialogs.             launchHomeActivity();             broadcastCloseSystemDialogs();         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testSetSystemUiVisibilityAfterCleared_showBarsByApp"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testSetSystemUiVisibilityAfterCleared_showBarsByApp() throws Exception {         final TestActivity activity = startActivity(TestActivity.class);         final View rootView = activity.getWindow().getDecorView();          // Assume we have the bars and they can be visible.         final int types = statusBars();         assumeTrue(rootView.getRootWindowInsets().isVisible(types));          // Use the flag to hide status bar.         ANIMATION_CALLBACK.reset();         getInstrumentation().runOnMainSync(() -> {             rootView.setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);             rootView.setSystemUiVisibility(SYSTEM_UI_FLAG_FULLSCREEN);         });         ANIMATION_CALLBACK.waitForFinishing(TIMEOUT);         PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));          // Clearing the flag can show status bar.         getInstrumentation().runOnMainSync(() -> {             rootView.setSystemUiVisibility(0);         });         PollingCheck.waitFor(TIMEOUT, () -> rootView.getRootWindowInsets().isVisible(types));          // Use the flag to hide status bar again.         ANIMATION_CALLBACK.reset();         getInstrumentation().runOnMainSync(() -> {             rootView.setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);             rootView.setSystemUiVisibility(SYSTEM_UI_FLAG_FULLSCREEN);         });         ANIMATION_CALLBACK.waitForFinishing(TIMEOUT);         PollingCheck.waitFor(TIMEOUT, () -> !rootView.getRootWindowInsets().isVisible(types));          // Clearing the flag can show status bar.         getInstrumentation().runOnMainSync(() -> {             rootView.setSystemUiVisibility(0);         });         PollingCheck.waitFor(TIMEOUT, () -> rootView.getRootWindowInsets().isVisible(types));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testHideOnCreate"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testHideOnCreate() throws Exception {         final TestHideOnCreateActivity activity = startActivity(TestHideOnCreateActivity.class);         final View rootView = activity.getWindow().getDecorView();         ANIMATION_CALLBACK.waitForFinishing(TIMEOUT);         PollingCheck.waitFor(TIMEOUT,                 () -> !rootView.getRootWindowInsets().isVisible(statusBars())                         && !rootView.getRootWindowInsets().isVisible(navigationBars()));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testInsetsDispatch"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testInsetsDispatch() throws Exception {         // Start an activity which hides system bars.         final TestHideOnCreateActivity activity = startActivity(TestHideOnCreateActivity.class);         final View rootView = activity.getWindow().getDecorView();         ANIMATION_CALLBACK.waitForFinishing(TIMEOUT);         PollingCheck.waitFor(TIMEOUT,                 () -> !rootView.getRootWindowInsets().isVisible(statusBars())                         && !rootView.getRootWindowInsets().isVisible(navigationBars()));          // Add a dialog which hides system bars before the dialog is added to the system while the         // system bar was hidden previously, and collect the window insets that the dialog receives.         final ArrayList<WindowInsets> windowInsetsList = new ArrayList<>();         getInstrumentation().runOnMainSync(() -> {             final AlertDialog dialog = new AlertDialog.Builder(activity).create();             final Window dialogWindow = dialog.getWindow();             dialogWindow.getDecorView().setOnApplyWindowInsetsListener((view, insets) -> {                 windowInsetsList.add(insets);                 return view.onApplyWindowInsets(insets);             });             dialogWindow.getInsetsController().hide(statusBars() | navigationBars());             dialog.show();         });         getInstrumentation().waitForIdleSync();          // The dialog must never receive any of visible insets of system bars.         for (WindowInsets windowInsets : windowInsetsList) {             assertFalse(windowInsets.isVisible(statusBars()));             assertFalse(windowInsets.isVisible(navigationBars()));         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsControllerTests"	"testWindowInsetsController_availableAfterAddView"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	"public void testWindowInsetsController_availableAfterAddView() throws Exception {         final TestHideOnCreateActivity activity = startActivity(TestHideOnCreateActivity.class);         final View rootView = activity.getWindow().getDecorView();         ANIMATION_CALLBACK.waitForFinishing(TIMEOUT);         PollingCheck.waitFor(TIMEOUT,                 () -> !rootView.getRootWindowInsets().isVisible(statusBars())                         && !rootView.getRootWindowInsets().isVisible(navigationBars()));          final View childWindow = new View(activity);         getInstrumentation().runOnMainSync(() -> {             activity.getWindowManager().addView(childWindow,                     new WindowManager.LayoutParams(TYPE_APPLICATION));             mErrorCollector.checkThat(childWindow.getWindowInsetsController(), is(notNullValue()));         });         getInstrumentation().waitForIdleSync();         getInstrumentation().runOnMainSync(() -> {             activity.getWindowManager().removeView(childWindow);         });      }      private static void broadcastCloseSystemDialogs() {         executeShellCommand(AM_BROADCAST_CLOSE_SYSTEM_DIALOGS);     }      private static boolean isAutomotive(Context context) {         return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);     }      private static void hideInsets(View view, int types) throws InterruptedException {         ANIMATION_CALLBACK.reset();         getInstrumentation().runOnMainSync(() -> {             view.setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);             view.getWindowInsetsController().hide(types);         });         ANIMATION_CALLBACK.waitForFinishing(TIMEOUT);         PollingCheck.waitFor(TIMEOUT, () -> !view.getRootWindowInsets().isVisible(types));     }      private void tapOnDisplay(float x, float y) {         dragOnDisplay(x, y, x, y);     }      private void dragFromTopToCenter(View view) {         dragOnDisplay(view.getWidth() / 2f, 0 /* downY */,                 view.getWidth() / 2f, view.getHeight() / 2f);     }      private void dragOnDisplay(float downX, float downY, float upX, float upY) {         final long downTime = SystemClock.elapsedRealtime();          // down event         MotionEvent event = MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_DOWN,                 downX, downY, 0 /* metaState */);         sendPointerSync(event);         event.recycle();          // move event         event = MotionEvent.obtain(downTime, downTime + 1, MotionEvent.ACTION_MOVE,                 (downX + upX) / 2f, (downY + upY) / 2f, 0 /* metaState */);         sendPointerSync(event);         event.recycle();          // up event         event = MotionEvent.obtain(downTime, downTime + 2, MotionEvent.ACTION_UP,                 upX, upY, 0 /* metaState */);         sendPointerSync(event);         event.recycle();     }      private void sendPointerSync(MotionEvent event) {         SystemUtil.runWithShellPermissionIdentity(                 () -> getInstrumentation().sendPointerSync(event));     }      private static class AnimationCallback extends WindowInsetsAnimation.Callback {          private boolean mFinished = false;          AnimationCallback() {             super(DISPATCH_MODE_CONTINUE_ON_SUBTREE);         }          @Override         public WindowInsets onProgress(WindowInsets insets,                 List<WindowInsetsAnimation> runningAnimations) {             return insets;         }          @Override         public void onEnd(WindowInsetsAnimation animation) {             synchronized (this) {                 mFinished = true;                 notify();             }         }          void waitForFinishing(long timeout) throws InterruptedException {             synchronized (this) {                 if (!mFinished) {                     wait(timeout);                 }             }         }          void reset() {             synchronized (this) {                 mFinished = false;             }         }     }      private static View setViews(Activity activity, @Nullable String privateImeOptions) {         LinearLayout layout = new LinearLayout(activity);         View text = new TextView(activity);         EditText editor = new EditText(activity);         editor.setPrivateImeOptions(privateImeOptions);         layout.addView(text);         layout.addView(editor);         activity.setContentView(layout);         editor.requestFocus();         return layout;     }      public static class TestActivity extends FocusableActivity {         final String mEditTextMarker =                 getClass().getName() + ""/"" + SystemClock.elapsedRealtimeNanos();          @Override         protected void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             setViews(this, mEditTextMarker);             getWindow().setSoftInputMode(SOFT_INPUT_STATE_HIDDEN);         }     }      public static class TestHideOnCreateActivity extends FocusableActivity {          @Override         protected void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             View layout = setViews(this, null /* privateImeOptions */);             ANIMATION_CALLBACK.reset();             getWindow().getDecorView().setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);             getWindow().getInsetsController().hide(statusBars());             layout.getWindowInsetsController().hide(navigationBars());         }     }      public static class TestShowOnCreateActivity extends FocusableActivity {         @Override         protected void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             setViews(this, null /* privateImeOptions */);             ANIMATION_CALLBACK.reset();             getWindow().getDecorView().setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);             getWindow().getInsetsController().show(ime());         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.res.cts.ConfigurationTest"	"testCompareTo"	"CtsContentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigurationTest.java"	""	"public void testCompareTo() {         final Configuration cfg1 = new Configuration();         final Configuration cfg2 = new Configuration();         assertEquals(0, cfg1.compareTo(cfg2));          cfg1.colorMode = 2;         cfg2.colorMode = 3;         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.colorMode = 3;         cfg2.colorMode = 2;         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.orientation = 2;         cfg2.orientation = 3;         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.orientation = 3;         cfg2.orientation = 2;         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.navigation = 2;         cfg2.navigation = 3;         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.navigation = 3;         cfg2.navigation = 2;         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.keyboardHidden = 2;         cfg2.keyboardHidden = 3;         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.keyboardHidden = 3;         cfg2.keyboardHidden = 2;         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.keyboard = 2;         cfg2.keyboard = 3;         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.keyboard = 3;         cfg2.keyboard = 2;         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.touchscreen = 2;         cfg2.touchscreen = 3;         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.touchscreen = 3;         cfg2.touchscreen = 2;         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.setLocales(LocaleList.forLanguageTags(""fr""));         cfg2.setLocales(LocaleList.forLanguageTags(""fr,en""));         assertTrue(cfg1.compareTo(cfg2) < 0);         cfg1.setLocales(LocaleList.forLanguageTags(""fr,en""));         cfg2.setLocales(LocaleList.forLanguageTags(""fr""));         assertTrue(cfg1.compareTo(cfg2) > 0);          cfg1.setLocales(LocaleList.forLanguageTags(""fr,en""));         cfg2.setLocales(LocaleList.forLanguageTags(""fr,en-US""));         assertTrue(cfg1.compareTo(cfg2) < 0);         cfg1.setLocales(LocaleList.forLanguageTags(""fr,en-US""));         cfg2.setLocales(LocaleList.forLanguageTags(""fr,en""));         assertTrue(cfg1.compareTo(cfg2) > 0);          cfg1.locale = Locale.forLanguageTag(""en"");         cfg2.locale = Locale.forLanguageTag(""en-Shaw"");         assertTrue(cfg1.compareTo(cfg2) < 0);         cfg1.locale = Locale.forLanguageTag(""en-Shaw"");         cfg2.locale = Locale.forLanguageTag(""en"");         assertTrue(cfg1.compareTo(cfg2) > 0);          cfg1.locale = new Locale("""", """", ""2"");         cfg2.locale = new Locale("""", """", ""3"");         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.locale = new Locale("""", """", ""3"");         cfg2.locale = new Locale("""", """", ""2"");         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.locale = new Locale("""", ""2"", """");         cfg2.locale = new Locale("""", ""3"", """");         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.locale = new Locale("""", ""3"", """");         cfg2.locale = new Locale("""", ""2"", """");         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.locale = new Locale(""2"", """", """");         cfg2.locale = new Locale(""3"", """", """");         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.locale = new Locale(""3"", """", """");         cfg2.locale = new Locale(""2"", """", """");         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.locale = new Locale("""");         cfg2.locale = null;         assertTrue(cfg1.compareTo(cfg2) < 0);         cfg1.locale = null;         cfg2.locale = new Locale("""");         assertTrue(cfg1.compareTo(cfg2) > 0);          cfg1.mnc = 2;         cfg2.mnc = 3;         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.mnc = 3;         cfg2.mnc = 2;         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.mcc = 2;         cfg2.mcc = 3;         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.mcc = 3;         cfg2.mcc = 2;         assertEquals(1, cfg1.compareTo(cfg2));          cfg1.fontScale = 2;         cfg2.fontScale = 3;         assertEquals(-1, cfg1.compareTo(cfg2));         cfg1.fontScale = 3;         cfg2.fontScale = 2;         assertEquals(1, cfg1.compareTo(cfg2));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.res.cts.ConfigurationTest"	"testDiff"	"CtsContentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigurationTest.java"	""	"public void testDiff() {         Configuration config = new Configuration();         config.mcc = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC, mConfigDefault, config);         config.mnc = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC, mConfigDefault, config);         config.locale = Locale.getDefault();         config.setLayoutDirection(config.locale);         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION, mConfigDefault, config);         config.setLocales(LocaleList.forLanguageTags(""fr,en""));         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION, mConfigDefault, config);         config.screenLayout = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT, mConfigDefault, config);         config.touchscreen = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT                 | ActivityInfo.CONFIG_TOUCHSCREEN, mConfigDefault, config);         config.keyboard = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT                 | ActivityInfo.CONFIG_TOUCHSCREEN                 | ActivityInfo.CONFIG_KEYBOARD, mConfigDefault, config);         config.keyboardHidden = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT                 | ActivityInfo.CONFIG_TOUCHSCREEN                 | ActivityInfo.CONFIG_KEYBOARD                 | ActivityInfo.CONFIG_KEYBOARD_HIDDEN, mConfigDefault, config);         config.keyboardHidden = 0;         config.hardKeyboardHidden = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT                 | ActivityInfo.CONFIG_TOUCHSCREEN                 | ActivityInfo.CONFIG_KEYBOARD                 | ActivityInfo.CONFIG_KEYBOARD_HIDDEN, mConfigDefault, config);         config.hardKeyboardHidden = 0;         config.navigationHidden = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT                 | ActivityInfo.CONFIG_TOUCHSCREEN                 | ActivityInfo.CONFIG_KEYBOARD                 | ActivityInfo.CONFIG_KEYBOARD_HIDDEN, mConfigDefault, config);         config.navigation = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT                 | ActivityInfo.CONFIG_TOUCHSCREEN                 | ActivityInfo.CONFIG_KEYBOARD                 | ActivityInfo.CONFIG_KEYBOARD_HIDDEN                 | ActivityInfo.CONFIG_NAVIGATION, mConfigDefault, config);         config.orientation = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT                 | ActivityInfo.CONFIG_TOUCHSCREEN                 | ActivityInfo.CONFIG_KEYBOARD                 | ActivityInfo.CONFIG_KEYBOARD_HIDDEN                 | ActivityInfo.CONFIG_NAVIGATION                 | ActivityInfo.CONFIG_ORIENTATION, mConfigDefault, config);         config.uiMode = 1;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT                 | ActivityInfo.CONFIG_TOUCHSCREEN                 | ActivityInfo.CONFIG_KEYBOARD                 | ActivityInfo.CONFIG_KEYBOARD_HIDDEN                 | ActivityInfo.CONFIG_NAVIGATION                 | ActivityInfo.CONFIG_ORIENTATION                 | ActivityInfo.CONFIG_UI_MODE, mConfigDefault, config);         config.fontScale = 2;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT                 | ActivityInfo.CONFIG_TOUCHSCREEN                 | ActivityInfo.CONFIG_KEYBOARD                 | ActivityInfo.CONFIG_KEYBOARD_HIDDEN                 | ActivityInfo.CONFIG_NAVIGATION                 | ActivityInfo.CONFIG_ORIENTATION                 | ActivityInfo.CONFIG_UI_MODE                 | ActivityInfo.CONFIG_FONT_SCALE, mConfigDefault, config);         config.colorMode = 2;         doConfigCompare(ActivityInfo.CONFIG_MCC                 | ActivityInfo.CONFIG_MNC                 | ActivityInfo.CONFIG_LOCALE                 | ActivityInfo.CONFIG_LAYOUT_DIRECTION                 | ActivityInfo.CONFIG_SCREEN_LAYOUT                 | ActivityInfo.CONFIG_TOUCHSCREEN                 | ActivityInfo.CONFIG_KEYBOARD                 | ActivityInfo.CONFIG_KEYBOARD_HIDDEN                 | ActivityInfo.CONFIG_NAVIGATION                 | ActivityInfo.CONFIG_ORIENTATION                 | ActivityInfo.CONFIG_UI_MODE                 | ActivityInfo.CONFIG_FONT_SCALE                 | ActivityInfo.CONFIG_COLOR_MODE, mConfigDefault, config);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.res.cts.ConfigurationTest"	"testSetToDefaults"	"CtsContentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigurationTest.java"	""	"public void testSetToDefaults() {         final Configuration config = new Configuration(mConfig);         assertFalse(config.equals(mConfigDefault));          config.setToDefaults();         assertTrue(config.equals(mConfigDefault));          assertEquals(1.0f, config.fontScale);         assertEquals(0, config.mcc);         assertEquals(0, config.mnc);         assertTrue(config.getLocales().isEmpty());         assertEquals(null, config.locale);         assertFalse(config.userSetLocale);         assertEquals(Configuration.TOUCHSCREEN_UNDEFINED, config.touchscreen);         assertEquals(Configuration.KEYBOARD_UNDEFINED, config.keyboard);         assertEquals(Configuration.KEYBOARDHIDDEN_UNDEFINED, config.keyboardHidden);         assertEquals(Configuration.HARDKEYBOARDHIDDEN_UNDEFINED, config.hardKeyboardHidden);         assertEquals(Configuration.NAVIGATION_UNDEFINED, config.navigation);         assertEquals(Configuration.NAVIGATIONHIDDEN_UNDEFINED, config.navigationHidden);         assertEquals(Configuration.ORIENTATION_UNDEFINED, config.orientation);         assertEquals(Configuration.SCREENLAYOUT_UNDEFINED, config.screenLayout);         assertEquals(Configuration.UI_MODE_TYPE_UNDEFINED, config.uiMode);         assertEquals(Configuration.SCREEN_WIDTH_DP_UNDEFINED, config.screenWidthDp);         assertEquals(Configuration.SCREEN_WIDTH_DP_UNDEFINED, config.compatScreenWidthDp);         assertEquals(Configuration.SCREEN_HEIGHT_DP_UNDEFINED, config.screenHeightDp);         assertEquals(Configuration.SCREEN_HEIGHT_DP_UNDEFINED, config.compatScreenHeightDp);         assertEquals(Configuration.SMALLEST_SCREEN_WIDTH_DP_UNDEFINED,                 config.smallestScreenWidthDp);         assertEquals(Configuration.DENSITY_DPI_UNDEFINED, config.densityDpi);         assertEquals(Configuration.COLOR_MODE_UNDEFINED, config.colorMode);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.res.cts.ConfigurationTest"	"testUnset"	"CtsContentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigurationTest.java"	""	"public void testUnset() {         Configuration config = new Configuration();         assertEquals(0.0f, config.fontScale);         assertEquals(0, config.mcc);         assertEquals(0, config.mnc);         assertTrue(config.getLocales().isEmpty());         assertEquals(null, config.locale);         assertFalse(config.userSetLocale);         assertEquals(Configuration.TOUCHSCREEN_UNDEFINED, config.touchscreen);         assertEquals(Configuration.KEYBOARD_UNDEFINED, config.keyboard);         assertEquals(Configuration.KEYBOARDHIDDEN_UNDEFINED, config.keyboardHidden);         assertEquals(Configuration.HARDKEYBOARDHIDDEN_UNDEFINED, config.hardKeyboardHidden);         assertEquals(Configuration.NAVIGATION_UNDEFINED, config.navigation);         assertEquals(Configuration.NAVIGATIONHIDDEN_UNDEFINED, config.navigationHidden);         assertEquals(Configuration.ORIENTATION_UNDEFINED, config.orientation);         assertEquals(Configuration.SCREENLAYOUT_UNDEFINED, config.screenLayout);         assertEquals(Configuration.UI_MODE_TYPE_UNDEFINED, config.uiMode);         assertEquals(Configuration.SCREEN_WIDTH_DP_UNDEFINED, config.screenWidthDp);         assertEquals(Configuration.SCREEN_WIDTH_DP_UNDEFINED, config.compatScreenWidthDp);         assertEquals(Configuration.SCREEN_HEIGHT_DP_UNDEFINED, config.screenHeightDp);         assertEquals(Configuration.SCREEN_HEIGHT_DP_UNDEFINED, config.compatScreenHeightDp);         assertEquals(Configuration.SMALLEST_SCREEN_WIDTH_DP_UNDEFINED,                 config.smallestScreenWidthDp);         assertEquals(Configuration.DENSITY_DPI_UNDEFINED, config.densityDpi);         assertEquals(Configuration.COLOR_MODE_UNDEFINED, config.colorMode);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.content.res.cts.ConfigurationTest"	"testSetLocale_overridesSetLocales"	"CtsContentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigurationTest.java"	""	"public void testSetLocale_overridesSetLocales() {         Configuration config = new Configuration();         config.setLocales(LocaleList.forLanguageTags(""az-Arab,en""));         config.setLocale(Locale.ENGLISH);          assertEquals(Locale.ENGLISH, config.locale);         assertEquals(new LocaleList(Locale.ENGLISH), config.getLocales());         assertEquals(View.LAYOUT_DIRECTION_LTR, config.getLayoutDirection());     }      private Configuration createConfig(LocaleList list) {         Configuration config = createConfig();         config.setLocales(list);         return config;     }      private Configuration createConfig(Locale locale) {         Configuration config = createConfig();         config.locale = locale;         return config;     }      private Configuration createConfig() {         Configuration config = new Configuration();         config.fontScale = 13.37f;         config.mcc = 0;         config.mnc = 1;         config.touchscreen = Configuration.TOUCHSCREEN_STYLUS;         config.keyboard = Configuration.KEYBOARD_UNDEFINED;         config.keyboardHidden = Configuration.KEYBOARDHIDDEN_YES;         config.hardKeyboardHidden = Configuration.KEYBOARDHIDDEN_UNDEFINED;         config.navigation = Configuration.NAVIGATION_DPAD;         config.navigationHidden = Configuration.NAVIGATIONHIDDEN_UNDEFINED;         config.orientation = Configuration.ORIENTATION_PORTRAIT;         config.screenLayout = Configuration.SCREENLAYOUT_LONG_UNDEFINED;         return config;     }      private void assertWriteToParcel(Configuration config) {         final Parcel parcel = Parcel.obtain();         try {             config.writeToParcel(parcel, 0);             parcel.setDataPosition(0);             Configuration readConf = new Configuration();             readConf.readFromParcel(parcel);             assertEquals(config, readConf);         } finally {             parcel.recycle();         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.preference.cts.PreferenceWithHeadersTest"	"testOnIsHidingHeaders"	"CtsPreferenceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/preference/src/android/preference/cts/PreferenceWithHeadersTest.java"	""	"public void testOnIsHidingHeaders() {         assertFalse(mActivity.onIsHidingHeaders());     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.dumpsys.cts.BatteryStatsDumpsysTest"	"testBatterystatsOutput"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/dumpsys/src/android/dumpsys/cts/BatteryStatsDumpsysTest.java"	""	"public void testBatterystatsOutput() throws Exception {         String batterystats = mDevice.executeShellCommand(""dumpsys batterystats --checkin"");         assertNotNull(batterystats);         assertTrue(batterystats.length() > 0);          Set<String> seenTags = new HashSet<>();          try (BufferedReader reader = new BufferedReader(                 new StringReader(batterystats))) {              String line;             while ((line = reader.readLine()) != null) {                 if (line.isEmpty()) {                     continue;                 }                   try {                     // With a default limit of 0, empty strings at the end are discarded.                     // We still consider the empty string as a valid value in some cases.                     // Using any negative number for the limit will preserve a trailing empty string.                     // @see String#split(String, int)                     String[] parts = line.split("","", -1);                     assertInteger(parts[0]); // old version                     assertInteger(parts[1]); // UID                     switch (parts[2]) { // aggregation type                         case ""i"":                         case ""l"":                         case ""c"":                         case ""u"":                             break;                         default:                             fail(""malformed stat: "" + parts[2]);                     }                     assertNotNull(parts[3]);                     seenTags.add(parts[3]);                      // Note the time fields are measured in milliseconds by default.                     switch (parts[3]) {                         case ""vers"":                             checkVersion(parts);                             break;                         case ""uid"":                             checkUid(parts);                             break;                         case ""apk"":                             checkApk(parts);                             break;                         case ""pr"":                             checkProcess(parts);                             break;                         case ""sr"":                             checkSensor(parts);                             break;                         case ""vib"":                             checkVibrator(parts);                             break;                         case ""fg"":                             checkForegroundActivity(parts);                             break;                         case ""fgs"":                             checkForegroundService(parts);                             break;                         case ""st"":                             checkStateTime(parts);                             break;                         case ""wl"":                             checkWakelock(parts);                             break;                         case ""awl"":                             checkAggregatedWakelock(parts);                             break;                         case ""sy"":                             checkSync(parts);                             break;                         case ""jb"":                             checkJob(parts);                             break;                         case ""jbc"":                             checkJobCompletion(parts);                             break;                         case ""jbd"":                             checkJobsDeferred(parts);                             break;                         case ""kwl"":                             checkKernelWakelock(parts);                             break;                         case ""wr"":                             checkWakeupReason(parts);                             break;                         case ""nt"":                             checkNetwork(parts);                             break;                         case ""ua"":                             checkUserActivity(parts);                             break;                         case ""bt"":                             checkBattery(parts);                             break;                         case ""dc"":                             checkBatteryDischarge(parts);                             break;                         case ""lv"":                             checkBatteryLevel(parts);                             break;                         case ""wfl"":                             checkWifi(parts);                             break;                         case ""m"":                             checkMisc(parts);                             break;                         case ""gn"":                             checkGlobalNetwork(parts);                             break;                         case ""br"":                             checkScreenBrightness(parts);                             break;                         case ""sgt"":                         case ""sgc"":                             checkSignalStrength(parts);                             break;                         case ""sst"":                             checkSignalScanningTime(parts);                             break;                         case ""dct"":                         case ""dcc"":                             checkDataConnection(parts);                             break;                         case ""wst"":                         case ""wsc"":                             checkWifiState(parts);                             break;                         case ""wsst"":                         case ""wssc"":                             checkWifiSupplState(parts);                             break;                         case ""wsgt"":                         case ""wsgc"":                             checkWifiSignalStrength(parts);                             break;                         case ""bst"":                         case ""bsc"":                             checkBluetoothState(parts);                             break;                         case ""blem"":                             checkBluetoothMisc(parts);                             break;                         case ""pws"":                             checkPowerUseSummary(parts);                             break;                         case ""pwi"":                             checkPowerUseItem(parts);                             break;                         case ""dsd"":                         case ""csd"":                             checkChargeDischargeStep(parts);                             break;                         case ""dtr"":                             checkDischargeTimeRemain(parts);                             break;                         case ""ctr"":                             checkChargeTimeRemain(parts);                             break;                         case ""cpu"":                             checkUidCpuUsage(parts);                             break;                         default:                             break;                     }                 } catch (AssertionError e) {                     CLog.e(""Assert fail for line <"" + line + "">"");                     throw e;                 }             }         }          // spot check a few tags         assertSeenTag(seenTags, ""vers"");         assertSeenTag(seenTags, ""bt"");         assertSeenTag(seenTags, ""dc"");         assertSeenTag(seenTags, ""m"");     }      private void checkVersion(String[] parts) {         assertEquals(8, parts.length);         assertInteger(parts[4]); // checkinVersion         assertInteger(parts[5]); // parcelVersion         assertNotNull(parts[6]); // startPlatformVersion         assertNotNull(parts[7]); // endPlatformVersion     }      private void checkUid(String[] parts) {         assertEquals(6, parts.length);         assertInteger(parts[4]); // uid         assertNotNull(parts[5]); // pkgName     }      private void checkApk(String[] parts) {         assertEquals(10, parts.length);         long wakeup_count = assertInteger(parts[4]); // wakeups         assertNotNull(parts[5]); // apk         assertNotNull(parts[6]); // service         assertInteger(parts[7]); // startTime         assertInteger(parts[8]); // starts         assertInteger(parts[9]); // launches          // Sanity check.         assertTrue(""wakeup count must be >= 0"", wakeup_count >= 0);     }      private void checkProcess(String[] parts) {         assertTrue(parts.length >= 9);         assertNotNull(parts[4]); // process         assertInteger(parts[5]); // userMillis         assertInteger(parts[6]); // systemMillis         assertInteger(parts[7]); // foregroundMillis         assertInteger(parts[8]); // starts     }      private void checkSensor(String[] parts) {         assertEquals(10, parts.length);         assertInteger(parts[4]); // sensorNumber         assertInteger(parts[5]); // totalTime         assertInteger(parts[6]); // count         assertInteger(parts[7]); // backgroundCount         assertInteger(parts[8]); // actualTime         assertInteger(parts[9]); // backgroundActualTime     }      private void checkVibrator(String[] parts) {         assertEquals(6, parts.length);         assertInteger(parts[4]); // totalTime         assertInteger(parts[5]); // count     }      private void checkForegroundActivity(String[] parts) {         assertEquals(6, parts.length);         assertInteger(parts[4]); // totalTime         assertInteger(parts[5]); // count     }      private void checkForegroundService(String[] parts) {         assertEquals(6, parts.length);         assertInteger(parts[4]); // totalTime         assertInteger(parts[5]); // count     }      private void checkStateTime(String[] parts) {         assertEquals(11, parts.length);         assertInteger(parts[4]);  // top         assertInteger(parts[5]);  // foreground_service         assertInteger(parts[6]);  // foreground         assertInteger(parts[7]);  // background         assertInteger(parts[8]);  // top_sleeping         assertInteger(parts[9]);  // heavy_weight         assertInteger(parts[10]); // cached     }      private void checkWakelock(String[] parts) {         assertEquals(29, parts.length);         assertNotNull(parts[4]);      // wakelock          assertInteger(parts[5]);      // full totalTime         assertEquals(""f"", parts[6]);  // full         long full_count = assertInteger(parts[7]);      // full count         assertInteger(parts[8]);      // current duration         assertInteger(parts[9]);      // max duration         assertInteger(parts[10]);     // total duration          assertInteger(parts[11]);      // partial totalTime         assertEquals(""p"", parts[12]);  // partial         long partial_count = assertInteger(parts[13]);     // partial count         assertInteger(parts[14]);      // current duration         assertInteger(parts[15]);      // max duration         assertInteger(parts[16]);      // total duration          assertInteger(parts[17]);      // background partial totalTime         assertEquals(""bp"", parts[18]); // background partial         long bg_partial_count = assertInteger(parts[19]);     // background partial count         assertInteger(parts[20]);      // current duration         assertInteger(parts[21]);      // max duration         assertInteger(parts[22]);      // total duration          assertInteger(parts[23]);      // window totalTime         assertEquals(""w"", parts[24]);  // window         long window_count = assertInteger(parts[25]);     // window count         assertInteger(parts[26]);      // current duration         assertInteger(parts[27]);      // max duration         assertInteger(parts[28]);      // total duration          // Sanity checks.         assertTrue(""full wakelock count must be >= 0"", full_count >= 0);         assertTrue(""partial wakelock count must be >= 0"", partial_count >= 0);         assertTrue(""background partial wakelock count must be >= 0"", bg_partial_count >= 0);         assertTrue(""window wakelock count must be >= 0"", window_count >= 0);     }      private void checkAggregatedWakelock(String[] parts) {         assertEquals(6, parts.length);         assertInteger(parts[4]); // total time         assertInteger(parts[5]); // background time     }      private void checkSync(String[] parts) {         assertEquals(9, parts.length);         assertNotNull(parts[4]); // sync         assertInteger(parts[5]); // totalTime         assertInteger(parts[6]); // count         assertInteger(parts[7]); // bgTime         assertInteger(parts[8]); // bgCount     }      private void checkJob(String[] parts) {         assertEquals(9, parts.length);         assertNotNull(parts[4]); // job         assertInteger(parts[5]); // totalTime         assertInteger(parts[6]); // count         assertInteger(parts[7]); // bgTime         assertInteger(parts[8]); // bgCount     }      private void checkJobCompletion(String[] parts) {         // This line contains a number for each job cancel reason.         // (See JobParameters.JOB_STOP_REASON_CODES), and future mainline updates may introudce         // more codes, so we have no upper bound for the number of columns.         assertThat(parts.length).isAtLeast(11);         assertNotNull(parts[4]); // job          // Values for each of JOB_STOP_REASON_CODES.         for (int i = 5; i < parts.length; i++) {             assertInteger(parts[i]);         }     }      private void checkJobsDeferred(String[] parts) {         assertEquals(12, parts.length);         assertInteger(parts[4]); // jobsDeferredEventCount         assertInteger(parts[5]); // jobsDeferredCount         assertInteger(parts[6]); // totalLatencyMillis         assertInteger(parts[7]); // count at latency < 1 hr         assertInteger(parts[8]); // count at latency 1-2 hrs         assertInteger(parts[9]); // count at latency 2-4 hrs         assertInteger(parts[10]); // count at latency 4-8 hrs         assertInteger(parts[11]); // count at latency 8+ hrs     }      private void checkKernelWakelock(String[] parts) {         assertTrue(parts.length >= 7);  assertNotNull(parts[4]); // Kernel wakelock  assertInteger(parts[parts.length-2]); // totalTime         assertInteger(parts[parts.length-1]); // count     }      private void checkWakeupReason(String[] parts) {         assertTrue(parts.length >= 7);         for (int i = 4; i < parts.length-2; i++) {             assertNotNull(parts[i]); // part of wakeup         }         assertInteger(parts[parts.length-2]); // totalTime         assertInteger(parts[parts.length-1]); // count     }      private void checkNetwork(String[] parts) {         assertEquals(26, parts.length);         long mbRx = assertInteger(parts[4]);  // mobileBytesRx         long mbTx = assertInteger(parts[5]);  // mobileBytesTx         long wbRx = assertInteger(parts[6]);  // wifiBytesRx         long wbTx = assertInteger(parts[7]);  // wifiBytesTx         long mpRx = assertInteger(parts[8]);  // mobilePacketsRx         long mpTx = assertInteger(parts[9]);  // mobilePacketsTx         long wpRx = assertInteger(parts[10]); // wifiPacketsRx         long wpTx = assertInteger(parts[11]); // wifiPacketsTx         assertInteger(parts[12]); // mobileActiveTime (usec)         assertInteger(parts[13]); // mobileActiveCount         assertInteger(parts[14]); // btBytesRx         assertInteger(parts[15]); // btBytesTx         assertInteger(parts[16]); // mobileWakeup         assertInteger(parts[17]); // wifiWakeup         long mbBgRx = assertInteger(parts[18]);  // mobileBytesRx         long mbBgTx = assertInteger(parts[19]);  // mobileBytesTx         long wbBgRx = assertInteger(parts[20]);  // wifiBytesRx         long wbBgTx = assertInteger(parts[21]);  // wifiBytesTx         long mpBgRx = assertInteger(parts[22]);  // mobilePacketsRx         long mpBgTx = assertInteger(parts[23]);  // mobilePacketsTx         long wpBgRx = assertInteger(parts[24]); // wifiPacketsRx         long wpBgTx = assertInteger(parts[25]); // wifiPacketsTx          // Assuming each packet contains some bytes, bytes >= packets >= 0.         assertTrue(""mobileBytesRx must be >= mobilePacketsRx"", mbRx >= mpRx);         assertTrue(""mobilePacketsRx must be >= 0"", mpRx >= 0);         assertTrue(""mobileBytesTx must be >= mobilePacketsTx"", mbTx >= mpTx);         assertTrue(""mobilePacketsTx must be >= 0"", mpTx >= 0);         assertTrue(""wifiBytesRx must be >= wifiPacketsRx"", wbRx >= wpRx);         assertTrue(""wifiPacketsRx must be >= 0"", wpRx >= 0);         assertTrue(""wifiBytesTx must be >= wifiPacketsTx"", wbTx >= wpTx);         assertTrue(""wifiPacketsTx must be >= 0"", wpTx >= 0);         // Totals should be greater than or equal to background data numbers         assertTrue(""mobileBytesRx must be >= mobileBytesBgRx"", mbRx >= mbBgRx);         assertTrue(""mobilePacketsRx must be >= mobilePacketsBgRx"", mpRx >= mpBgRx);         assertTrue(""mobileBytesTx must be >= mobileBytesBgTx"", mbTx >= mbBgTx);         assertTrue(""mobilePacketsTx must be >= mobilePacketsBgTx"", mpTx >= mpBgTx);         assertTrue(""wifiBytesRx must be >= wifiBytesBgRx"", wbRx >= wbBgRx);         assertTrue(""wifiPacketsRx must be >= wifiPacketsBgRx"", wpRx >= wpBgRx);         assertTrue(""wifiBytesTx must be >= wifiBytesBgTx"", wbTx >= wbBgTx);         assertTrue(""wifiPacketsTx must be >= wifiPacketsBgTx"", wpTx >= wpBgTx);     }      private void checkUserActivity(String[] parts) {         assertEquals(9, parts.length);         assertInteger(parts[4]); // other         assertInteger(parts[5]); // button         assertInteger(parts[6]); // touch         assertInteger(parts[7]); // accessibility         assertInteger(parts[8]); // attention     }      private void checkBattery(String[] parts) {         assertEquals(16, parts.length);         if (!parts[4].equals(""N/A"")) {             assertInteger(parts[4]);  // startCount         }         long bReal = assertInteger(parts[5]);  // batteryRealtime         long bUp = assertInteger(parts[6]);  // batteryUptime         long tReal = assertInteger(parts[7]);  // totalRealtime         long tUp = assertInteger(parts[8]);  // totalUptime         assertInteger(parts[9]);  // startClockTime         long bOffReal = assertInteger(parts[10]); // batteryScreenOffRealtime         long bOffUp = assertInteger(parts[11]); // batteryScreenOffUptime         long bEstCap = assertInteger(parts[12]); // batteryEstimatedCapacity         assertInteger(parts[13]); // minLearnedBatteryCapacity         assertInteger(parts[14]); // maxLearnedBatteryCapacity         long bDoze = assertInteger(parts[15]); // screenDozeTime          // The device cannot be up more than there are real-world seconds.         assertTrue(""batteryRealtime must be >= batteryUptime"", bReal >= bUp);         assertTrue(""totalRealtime must be >= totalUptime"", tReal >= tUp);         assertTrue(""batteryScreenOffRealtime must be >= batteryScreenOffUptime"",                 bOffReal >= bOffUp);          // total >= battery >= battery screen-off >= 0         assertTrue(""totalRealtime must be >= batteryRealtime"", tReal >= bReal);         assertTrue(""batteryRealtime must be >= batteryScreenOffRealtime"", bReal >= bOffReal);         assertTrue(""batteryScreenOffRealtime must be >= 0"", bOffReal >= 0);         assertTrue(""totalUptime must be >= batteryUptime"", tUp >= bUp);         assertTrue(""batteryUptime must be >= batteryScreenOffUptime"", bUp >= bOffUp);         assertTrue(""batteryScreenOffUptime must be >= 0"", bOffUp >= 0);         assertTrue(""batteryEstimatedCapacity must be >= 0"", bEstCap >= 0);         assertTrue(""screenDozeTime must be >= 0"", bDoze >= 0);         assertTrue(""screenDozeTime must be <= batteryScreenOffRealtime"", bDoze <= bOffReal);     }      private void checkBatteryDischarge(String[] parts) {         assertEquals(14, parts.length);         assertInteger(parts[4]); // low         assertInteger(parts[5]); // high         assertInteger(parts[6]); // screenOn         assertInteger(parts[7]); // screenOff         assertInteger(parts[8]); // dischargeMah         assertInteger(parts[9]); // dischargeScreenOffMah         assertInteger(parts[10]); // dischargeDozeCount         assertInteger(parts[11]); // dischargeDozeMah         assertInteger(parts[12]); // dischargeLightDozeMah         assertInteger(parts[13]); // dischargeDeepDozeMah     }      private void checkBatteryLevel(String[] parts) {         assertEquals(6, parts.length);         assertInteger(parts[4]); // startLevel         assertInteger(parts[5]); // currentLevel     }      private void checkWifi(String[] parts) {         assertEquals(14, parts.length);         assertInteger(parts[4]); // fullWifiLockOnTime (usec)         assertInteger(parts[5]); // wifiScanTime (usec)         assertInteger(parts[6]); // uidWifiRunningTime (usec)         assertInteger(parts[7]); // wifiScanCount         // Fields for parts[8 and 9 and 10] are deprecated.         assertInteger(parts[11]); // wifiScanCountBg         assertInteger(parts[12]); // wifiScanActualTimeMs (msec)         assertInteger(parts[13]); // wifiScanActualTimeMsBg (msec)     }      private void checkMisc(String[] parts) {         assertTrue(parts.length >= 19);         assertInteger(parts[4]);      // screenOnTime         assertInteger(parts[5]);      // phoneOnTime         assertInteger(parts[6]);      // fullWakeLockTimeTotal         assertInteger(parts[7]);      // partialWakeLockTimeTotal         assertInteger(parts[8]);      // mobileRadioActiveTime         assertInteger(parts[9]);      // mobileRadioActiveAdjustedTime         assertInteger(parts[10]);     // interactiveTime         assertInteger(parts[11]);     // lowPowerModeEnabledTime         assertInteger(parts[12]);     // connChanges         assertInteger(parts[13]);     // deviceIdleModeEnabledTime         assertInteger(parts[14]);     // deviceIdleModeEnabledCount         assertInteger(parts[15]);     // deviceIdlingTime         assertInteger(parts[16]);     // deviceIdlingCount         assertInteger(parts[17]);     // mobileRadioActiveCount         assertInteger(parts[18]);     // mobileRadioActiveUnknownTime     }      private void checkGlobalNetwork(String[] parts) {         assertEquals(14, parts.length);         assertInteger(parts[4]);  // mobileRxTotalBytes         assertInteger(parts[5]);  // mobileTxTotalBytes         assertInteger(parts[6]);  // wifiRxTotalBytes         assertInteger(parts[7]);  // wifiTxTotalBytes         assertInteger(parts[8]);  // mobileRxTotalPackets         assertInteger(parts[9]);  // mobileTxTotalPackets         assertInteger(parts[10]); // wifiRxTotalPackets         assertInteger(parts[11]); // wifiTxTotalPackets         assertInteger(parts[12]); // btRxTotalBytes         assertInteger(parts[13]); // btTxTotalBytes     }      private void checkScreenBrightness(String[] parts) {         assertEquals(9, parts.length);         assertInteger(parts[4]); // dark         assertInteger(parts[5]); // dim         assertInteger(parts[6]); // medium         assertInteger(parts[7]); // light         assertInteger(parts[8]); // bright     }      private void checkSignalStrength(String[] parts) {         assertTrue(parts.length >= 9);         assertInteger(parts[4]); // none         assertInteger(parts[5]); // poor         assertInteger(parts[6]); // moderate         assertInteger(parts[7]); // good         assertInteger(parts[8]); // great     }      private void checkSignalScanningTime(String[] parts) {         assertEquals(5, parts.length);         assertInteger(parts[4]); // signalScanningTime     }      private void checkDataConnection(String[] parts) {         assertEquals(27, parts.length);         assertInteger(parts[4]);  // none         assertInteger(parts[5]);  // gprs         assertInteger(parts[6]);  // edge         assertInteger(parts[7]);  // umts         assertInteger(parts[8]);  // cdma         assertInteger(parts[9]);  // evdo_0         assertInteger(parts[10]); // evdo_A         assertInteger(parts[11]); // 1xrtt         assertInteger(parts[12]); // hsdpa         assertInteger(parts[13]); // hsupa         assertInteger(parts[14]); // hspa         assertInteger(parts[15]); // iden         assertInteger(parts[16]); // evdo_b         assertInteger(parts[17]); // lte         assertInteger(parts[18]); // ehrpd         assertInteger(parts[19]); // hspap         assertInteger(parts[20]); // gsm         assertInteger(parts[21]); // td_scdma         assertInteger(parts[22]); // iwlan         assertInteger(parts[23]); // lte_ca         assertInteger(parts[24]); // nr         assertInteger(parts[25]); // emngcy         assertInteger(parts[26]); // other     }      private void checkWifiState(String[] parts) {         assertEquals(12, parts.length);         assertInteger(parts[4]);  // off         assertInteger(parts[5]);  // scanning         assertInteger(parts[6]);  // no_net         assertInteger(parts[7]);  // disconn         assertInteger(parts[8]);  // sta         assertInteger(parts[9]);  // p2p         assertInteger(parts[10]); // sta_p2p         assertInteger(parts[11]); // soft_ap     }      private void checkWifiSupplState(String[] parts) {         assertEquals(17, parts.length);         assertInteger(parts[4]);  // inv         assertInteger(parts[5]);  // dsc         assertInteger(parts[6]);  // dis         assertInteger(parts[7]);  // inact         assertInteger(parts[8]);  // scan         assertInteger(parts[9]);  // auth         assertInteger(parts[10]); // ascing         assertInteger(parts[11]); // asced         assertInteger(parts[12]); // 4-way         assertInteger(parts[13]); // group         assertInteger(parts[14]); // compl         assertInteger(parts[15]); // dorm         assertInteger(parts[16]); // uninit     }      private void checkWifiSignalStrength(String[] parts) {         assertEquals(9, parts.length);         assertInteger(parts[4]); // none         assertInteger(parts[5]); // poor         assertInteger(parts[6]); // moderate         assertInteger(parts[7]); // good         assertInteger(parts[8]); // great     }      private void checkBluetoothState(String[] parts) {         assertEquals(8, parts.length);         assertInteger(parts[4]); // inactive         assertInteger(parts[5]); // low         assertInteger(parts[6]); // med         assertInteger(parts[7]); // high     }      private void checkPowerUseSummary(String[] parts) {         assertEquals(8, parts.length);         assertDouble(parts[4]); // batteryCapacity         assertDouble(parts[5]); // computedPower         assertDouble(parts[6]); // minDrainedPower         assertDouble(parts[7]); // maxDrainedPower     }      private void checkPowerUseItem(String[] parts) {         assertEquals(9, parts.length);         assertNotNull(parts[4]); // label         final double totalPowerMah = assertDouble(parts[5]);  // totalPowerMah         final long shouldHide = assertInteger(parts[6]);  // shouldHide (0 or 1)         final double screenPowerMah = assertDouble(parts[7]);  // screenPowerMah         final double proportionalSmearMah = assertDouble(parts[8]);  // proportionalSmearMah          assertTrue(""powerUseItem totalPowerMah must be >= 0"", totalPowerMah >= 0);         assertTrue(""powerUseItem screenPowerMah must be >= 0"", screenPowerMah >= 0);         assertTrue(""powerUseItem proportionalSmearMah must be >= 0"", proportionalSmearMah >= 0);         assertTrue(""powerUseItem shouldHide must be 0 or 1"", shouldHide == 0 || shouldHide == 1);          // Largest current Android battery is ~5K. 100K shouldn't get made for a while.         assertTrue(""powerUseItem totalPowerMah is expected to be <= 100000"", totalPowerMah <= 100000);     }      private void checkChargeDischargeStep(String[] parts) {         assertEquals(9, parts.length);         assertInteger(parts[4]); // duration         if (!parts[5].equals(""?"")) {             assertInteger(parts[5]); // level         }         assertNotNull(parts[6]); // screen         assertNotNull(parts[7]); // power-save         assertNotNull(parts[8]); // device-idle     }      private void checkDischargeTimeRemain(String[] parts) {         assertEquals(5, parts.length);         assertInteger(parts[4]); // batteryTimeRemaining     }      private void checkChargeTimeRemain(String[] parts) {         assertEquals(5, parts.length);         assertInteger(parts[4]); // chargeTimeRemaining     }      private void checkUidCpuUsage(String[] parts) {         assertTrue(parts.length >= 6);         assertInteger(parts[4]); // user time         assertInteger(parts[5]); // system time     }      private void checkBluetoothMisc(String[] parts) {         assertEquals(15, parts.length);         assertInteger(parts[4]); // totalTime         assertInteger(parts[5]); // count         assertInteger(parts[6]); // countBg         assertInteger(parts[7]); // actualTime         assertInteger(parts[8]); // actualTimeBg         assertInteger(parts[9]); // resultsCount         assertInteger(parts[10]); // resultsCountBg         assertInteger(parts[11]); // unoptimizedScanTotalTime         assertInteger(parts[12]); // unoptimizedScanTotalTimeBg         assertInteger(parts[13]); // unoptimizedScanMaxTime         assertInteger(parts[14]); // unoptimizedScanMaxTimeBg     }      /**      * Tests the output of ""dumpsys gfxinfo framestats"".      *      * @throws Exception      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.AlertWindowsImportanceTests"	"testAlertWindowOomAdj"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AlertWindowsImportanceTests.java"	""	"@AppModeFull(reason = ""Uses apps targeting older SDK"")     public void testAlertWindowOomAdj() throws Exception {         // Alert windows are always hidden when running in VR.         if (isRunningInVR()) {             return;         }         setAlertWindowPermission(true /* allow */);          assertPackageImportance(IMPORTANCE_PERCEPTIBLE, IMPORTANCE_PERCEPTIBLE_PRE_26);          // TODO AM.getUidImportance() sometimes return a different value from what         // getPackageImportance() returns... b/37950472         // assertUidImportance(IMPORTANCE_PERCEPTIBLE, IMPORTANCE_PERCEPTIBLE_PRE_26);          addAlertWindow();         // Process importance should be increased to visible when the service has an alert window.         assertPackageImportance(IMPORTANCE_VISIBLE, IMPORTANCE_VISIBLE);          addAlertWindow();         assertPackageImportance(IMPORTANCE_VISIBLE, IMPORTANCE_VISIBLE);          setAlertWindowPermission(false /* allow */);         // Process importance should no longer be visible since its alert windows are not allowed to         // be visible.         assertPackageImportance(IMPORTANCE_PERCEPTIBLE, IMPORTANCE_PERCEPTIBLE_PRE_26);          setAlertWindowPermission(true /* allow */);         // They can show again so importance should be visible again.         assertPackageImportance(IMPORTANCE_VISIBLE, IMPORTANCE_VISIBLE);          removeAlertWindow();         assertPackageImportance(IMPORTANCE_VISIBLE, IMPORTANCE_VISIBLE);          removeAlertWindow();         // Process importance should no longer be visible when the service no longer as alert         // windows.         assertPackageImportance(IMPORTANCE_PERCEPTIBLE, IMPORTANCE_PERCEPTIBLE_PRE_26);     }      private void addAlertWindow() throws Exception {         mService.send(Message.obtain(null, AlertWindowService.MSG_ADD_ALERT_WINDOW));         synchronized (mAddedLock) {             // Wait for window addition confirmation before proceeding.             mAddedLock.wait(WAIT_TIME_MS);         }     }      private void removeAlertWindow() throws Exception {         mService.send(Message.obtain(null, AlertWindowService.MSG_REMOVE_ALERT_WINDOW));         synchronized (mRemoveLock) {             // Wait for window removal confirmation before proceeding.             mRemoveLock.wait(WAIT_TIME_MS);         }     }      private void setAlertWindowPermission(boolean allow) throws Exception {         final int mode = allow ? MODE_ALLOWED : MODE_ERRORED;         AppOpsUtils.setOpMode(mServicePackageName, OPSTR_SYSTEM_ALERT_WINDOW, mode);     }      private void assertImportance(ToIntFunction<ActivityManager> apiCaller,             int expectedForO, int expectedForPreO) throws Exception {         try {             getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();              final long TIMEOUT = SystemClock.uptimeMillis() + TimeUnit.SECONDS.toMillis(30);             int actual;             do {                 // TODO: We should try to use ActivityManagerTest.UidImportanceListener here to                 // listen for changes in the uid importance. However, the way it is currently                 // structured doesn't really work for this use case right now...                 Thread.sleep(500);                 actual = apiCaller.applyAsInt(mAm);             } while (actual != expectedForO && (SystemClock.uptimeMillis() < TIMEOUT));              assertEquals(expectedForO, actual);              // Check the result for pre-O apps.             assertEquals(expectedForPreO, apiCaller.applyAsInt(mAm25));         } finally {             getInstrumentation().getUiAutomation().dropShellPermissionIdentity();         }     }      /**      * Make sure {@link ActivityManager#getPackageImportance} returns the expected value.      */     private void assertPackageImportance(int expectedForO, int expectedForPreO) throws Exception {         assertImportance(am -> am.getPackageImportance(mServicePackageName),                 expectedForO, expectedForPreO);     }      private final ServiceConnection mConnection = new ServiceConnection() {         @Override         public void onServiceConnected(ComponentName name, IBinder service) {             if (DEBUG) Log.e(TAG, ""onServiceConnected"");             mService = new Messenger(service);             mServicePackageName = name.getPackageName();             synchronized (mConnection) {                 notifyAll();             }         }          @Override         public void onServiceDisconnected(ComponentName name) {             if (DEBUG) Log.e(TAG, ""onServiceDisconnected"");             mService = null;             mServicePackageName = null;         }     };      private class IncomingHandler extends Handler {          IncomingHandler(Looper looper) {             super(looper);         }          @Override         public void handleMessage(Message msg) {             switch (msg.what) {                 case AlertWindowService.MSG_ON_ALERT_WINDOW_ADDED:                     synchronized (mAddedLock) {                         if (DEBUG) Log.e(TAG, ""MSG_ON_ALERT_WINDOW_ADDED"");                         mAddedLock.notifyAll();                     }                     break;                 case AlertWindowService.MSG_ON_ALERT_WINDOW_REMOVED:                     synchronized (mRemoveLock) {                         if (DEBUG) Log.e(TAG, ""MSG_ON_ALERT_WINDOW_REMOVED"");                         mRemoveLock.notifyAll();                     }                     break;                 default:                     super.handleMessage(msg);             }         }     }      private boolean isRunningInVR() {         final Context context = getInstrumentation().getTargetContext();         if ((context.getResources().getConfiguration().uiMode & Configuration.UI_MODE_TYPE_MASK)              == Configuration.UI_MODE_TYPE_VR_HEADSET) {             return true;         }         return false;     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.fragment.cts.FragmentAnimatorTest"	"getVisibility"	"CtsFragmentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/fragment/src/android/fragment/cts/FragmentAnimatorTest.java"	""	"public void showAnimatorsReordered() throws Throwable {         final FragmentManager fm = mActivityRule.getActivity().getFragmentManager();          // One fragment with a view         final AnimatorFragment fragment = new AnimatorFragment();         fm.beginTransaction().add(R.id.fragmentContainer, fragment).hide(fragment).commit();         FragmentTestUtil.waitForExecution(mActivityRule);          mActivityRule.runOnUiThread(() -> {             assertEquals(View.GONE, fragment.getView().getVisibility());         });          fm.beginTransaction()                 .setCustomAnimations(ENTER, EXIT, POP_ENTER, POP_EXIT)                 .show(fragment)                 .addToBackStack(null)                 .commit();         FragmentTestUtil.waitForExecution(mActivityRule);          mActivityRule.runOnUiThread(() -> {             assertEquals(View.VISIBLE, fragment.getView().getVisibility());         });         assertEnterPopExit(fragment);          mActivityRule.runOnUiThread(() -> {             assertEquals(View.GONE, fragment.getView().getVisibility());         });     }      // Ensure that showing and popping a Fragment uses the enter and popExit animators     // This tests ordered transactions"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.fragment.cts.FragmentAnimatorTest"	"getVisibility"	"CtsFragmentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/fragment/src/android/fragment/cts/FragmentAnimatorTest.java"	""	"public void showAnimatorsOrdered() throws Throwable {         final FragmentManager fm = mActivityRule.getActivity().getFragmentManager();          // One fragment with a view         final AnimatorFragment fragment = new AnimatorFragment();         fm.beginTransaction()                 .add(R.id.fragmentContainer, fragment)                 .hide(fragment)                 .setReorderingAllowed(false)                 .commit();         FragmentTestUtil.waitForExecution(mActivityRule);          mActivityRule.runOnUiThread(() -> {             assertEquals(View.GONE, fragment.getView().getVisibility());         });          fm.beginTransaction()                 .setCustomAnimations(ENTER, EXIT, POP_ENTER, POP_EXIT)                 .show(fragment)                 .setReorderingAllowed(false)                 .addToBackStack(null)                 .commit();         FragmentTestUtil.waitForExecution(mActivityRule);          mActivityRule.runOnUiThread(() -> {             assertEquals(View.VISIBLE, fragment.getView().getVisibility());         });         assertEnterPopExit(fragment);          mActivityRule.runOnUiThread(() -> {             assertEquals(View.GONE, fragment.getView().getVisibility());         });     }      // Ensure that hiding and popping a Fragment uses the exit and popEnter animators"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.fragment.cts.FragmentAnimatorTest"	"getVisibility"	"CtsFragmentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/fragment/src/android/fragment/cts/FragmentAnimatorTest.java"	""	"public void animationOnNullContainer() throws Throwable {         final FragmentManager fm = mActivityRule.getActivity().getFragmentManager();          // One fragment with a view         final AnimatorFragment fragment = new AnimatorFragment();         fm.beginTransaction()                 .setCustomAnimations(ENTER, EXIT, POP_ENTER, POP_EXIT)                 .add(fragment, ""1"")                 .addToBackStack(null)                 .commit();         FragmentTestUtil.waitForExecution(mActivityRule);          fm.beginTransaction()                 .setCustomAnimations(ENTER, EXIT, POP_ENTER, POP_EXIT)                 .hide(fragment)                 .commit();         FragmentTestUtil.waitForExecution(mActivityRule);          fm.beginTransaction()                 .setCustomAnimations(ENTER, EXIT, POP_ENTER, POP_EXIT)                 .show(fragment)                 .commit();          FragmentTestUtil.waitForExecution(mActivityRule);          FragmentTestUtil.popBackStackImmediate(mActivityRule);     }      private void assertEnterPopExit(AnimatorFragment fragment) throws Throwable {         assertFragmentAnimation(fragment, 1, true, ENTER);          final FragmentManager fm = mActivityRule.getActivity().getFragmentManager();         fm.popBackStack();         FragmentTestUtil.waitForExecution(mActivityRule);          assertFragmentAnimation(fragment, 2, false, POP_EXIT);     }      private void assertExitPopEnter(AnimatorFragment fragment) throws Throwable {         assertFragmentAnimation(fragment, 1, false, EXIT);          final FragmentManager fm = mActivityRule.getActivity().getFragmentManager();         fm.popBackStack();         FragmentTestUtil.waitForExecution(mActivityRule);          AnimatorFragment replacement = (AnimatorFragment) fm.findFragmentByTag(""1"");          boolean isSameFragment = replacement == fragment;         int expectedAnimators = isSameFragment ? 2 : 1;         assertFragmentAnimation(replacement, expectedAnimators, true, POP_ENTER);     }      private void assertExitPostponedPopEnter(AnimatorFragment fragment) throws Throwable {         assertFragmentAnimation(fragment, 1, false, EXIT);          fragment.postponeEnterTransition();         FragmentTestUtil.popBackStackImmediate(mActivityRule);          assertPostponed(fragment, 1);          fragment.startPostponedEnterTransition();         FragmentTestUtil.waitForExecution(mActivityRule);         assertFragmentAnimation(fragment, 2, true, POP_ENTER);     }      private void assertFragmentAnimation(AnimatorFragment fragment, int numAnimators,             boolean isEnter, int animatorResourceId) throws InterruptedException {         assertEquals(numAnimators, fragment.numAnimators);         assertEquals(isEnter, fragment.enter);         assertEquals(animatorResourceId, fragment.resourceId);         assertNotNull(fragment.animator);         assertTrue(fragment.wasStarted);         assertTrue(fragment.endLatch.await(1, TimeUnit.SECONDS));     }      private void assertPostponed(AnimatorFragment fragment, int expectedAnimators)             throws InterruptedException {         assertTrue(fragment.mOnCreateViewCalled);         assertEquals(View.VISIBLE, fragment.getView().getVisibility());         assertFalse(FragmentTestUtil.isVisible(fragment));         assertEquals(expectedAnimators, fragment.numAnimators);     }      public static class AnimatorFragment extends StrictViewFragment {         int numAnimators;         Animator animator;         boolean enter;         int resourceId;         boolean wasStarted;         CountDownLatch endLatch;          @Override         public Animator onCreateAnimator(int transit, boolean enter, int nextAnim) {             if (nextAnim == 0) {                 return null;             }             this.numAnimators++;             this.wasStarted = false;             this.animator = ValueAnimator.ofFloat(0, 1).setDuration(1);             this.endLatch = new CountDownLatch(1);             this.animator.addListener(new AnimatorListenerAdapter() {                 @Override                 public void onAnimationStart(Animator animation) {                     wasStarted = true;                 }                  @Override                 public void onAnimationEnd(Animator animation) {                     endLatch.countDown();                 }             });             this.resourceId = nextAnim;             this.enter = enter;             return this.animator;         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToolbarTest"	"testMenuOverflowShowHide"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToolbarTest.java"	""	"public void testMenuOverflowShowHide() throws Throwable {         // Inflate menu and check that we're not showing overflow menu yet         mActivityRule.runOnUiThread(() -> mMainToolbar.inflateMenu(R.menu.toolbar_menu));         assertFalse(mMainToolbar.isOverflowMenuShowing());          // Ask to show overflow menu and check that it's showing         mActivityRule.runOnUiThread(() -> mMainToolbar.showOverflowMenu());         PollingCheck.waitFor(() -> mMainToolbar.isOverflowMenuShowing());          // Ask to hide the overflow menu and check that it's not showing         mActivityRule.runOnUiThread(() -> mMainToolbar.hideOverflowMenu());         PollingCheck.waitFor(() -> !mMainToolbar.isOverflowMenuShowing());     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"isNotNull"	"CtsWifiTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"/*  *.  */  package android.net.wifi.cts;  import static android.content.pm.PackageManager.PERMISSION_GRANTED; import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_METERED; import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NONE; import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NOT_METERED;  import static com.google.common.truth.Truth.assertThat; import static com.google.common.truth.Truth.assertWithMessage;  import static org.junit.Assume.assumeTrue;  import android.app.UiAutomation; import android.content.Context; import android.net.IpConfiguration; import android.net.LinkAddress; import android.net.ProxyInfo; import android.net.StaticIpConfiguration; import android.net.Uri; import android.net.wifi.SoftApConfiguration; import android.net.wifi.WifiConfiguration; import android.net.wifi.WifiEnterpriseConfig; import android.net.wifi.WifiManager; import android.platform.test.annotations.AppModeFull; import android.support.test.uiautomator.UiDevice; import android.util.Log;  import androidx.test.filters.SmallTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.PollingCheck; import com.android.compatibility.common.util.ShellIdentityUtils; import com.android.compatibility.common.util.SystemUtil; import com.android.compatibility.common.util.ThrowingRunnable;   import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.DataInputStream; import java.io.IOException; import java.io.InputStream; import java.net.InetAddress; import java.net.UnknownHostException; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Set; import java.util.stream.Collectors;  /**  * Tests for wifi backup/restore functionality.  */ @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"") @SmallTest @RunWith(AndroidJUnit4.class) public class WifiBackupRestoreTest extends WifiJUnit4TestBase {     private static final String TAG = ""WifiBackupRestoreTest"";     private static final String LEGACY_SUPP_CONF_FILE =             ""assets/BackupLegacyFormatSupplicantConf.txt"";     private static final String LEGACY_IP_CONF_FILE =             ""assets/BackupLegacyFormatIpConf.txt"";     private static final String V1_0_FILE = ""assets/BackupV1.0Format.xml"";     private static final String V1_1_FILE = ""assets/BackupV1.1Format.xml"";     private static final String V1_2_FILE = ""assets/BackupV1.2Format.xml"";      public static final String EXPECTED_LEGACY_STATIC_IP_LINK_ADDRESS = ""192.168.48.2"";     public static final int EXPECTED_LEGACY_STATIC_IP_LINK_PREFIX_LENGTH = 8;     public static final String EXPECTED_LEGACY_STATIC_IP_GATEWAY_ADDRESS = ""192.168.48.1"";     public static final String[] EXPECTED_LEGACY_STATIC_IP_DNS_SERVER_ADDRESSES =             new String[]{""192.168.48.1"", ""192.168.48.10""};     public static final String EXPECTED_LEGACY_STATIC_PROXY_HOST = ""192.168.48.1"";     public static final int EXPECTED_LEGACY_STATIC_PROXY_PORT = 8000;     public static final String EXPECTED_LEGACY_STATIC_PROXY_EXCLUSION_LIST = """";     public static final String EXPECTED_LEGACY_PAC_PROXY_LOCATION = ""http://"";      private Context mContext;     private WifiManager mWifiManager;     private UiDevice mUiDevice;     private boolean mWasVerboseLoggingEnabled;      private static final int DURATION = 10_000;     private static final int DURATION_SCREEN_TOGGLE = 2000;      @Before     public void setUp() throws Exception {         mContext = InstrumentationRegistry.getInstrumentation().getContext();         // skip the test if WiFi is not supported         assumeTrue(WifiFeature.isWifiSupported(mContext));          mWifiManager = mContext.getSystemService(WifiManager.class);         assertThat(mWifiManager).isNotNull();          // turn on verbose logging for tests         mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.isVerboseLoggingEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(true));         // Disable scan throttling for tests.         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setScanThrottleEnabled(false));          if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);         mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());         turnScreenOn();         PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());          List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.getPrivilegedConfiguredNetworks());         assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();     }      @After     public void tearDown() throws Exception {         if (!WifiFeature.isWifiSupported(mContext)) return;         if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);         turnScreenOff();         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));     }      private void setWifiEnabled(boolean enable) throws Exception {         // now trigger the change using shell commands.         SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));     }      private void turnScreenOn() throws Exception {         mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");         mUiDevice.executeShellCommand(""wm dismiss-keyguard"");         // Since the screen on/off intent is ordered, they will not be sent right now.         Thread.sleep(DURATION_SCREEN_TOGGLE);     }      private void turnScreenOff() throws Exception {         mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");         // Since the screen on/off intent is ordered, they will not be sent right now.         Thread.sleep(DURATION_SCREEN_TOGGLE);     }      private void flipMeteredOverride(WifiConfiguration network) {         if (network.meteredOverride == METERED_OVERRIDE_NONE) {             network.meteredOverride = METERED_OVERRIDE_METERED;         } else if (network.meteredOverride == METERED_OVERRIDE_METERED) {             network.meteredOverride = METERED_OVERRIDE_NOT_METERED;         } else if (network.meteredOverride == METERED_OVERRIDE_NOT_METERED) {             network.meteredOverride = METERED_OVERRIDE_NONE;         }     }      /** WifiConfiguration#isEnterprise() is @hide, so copy/paste partial implementation here. */     private static boolean isEnterprise(WifiConfiguration config) {         WifiEnterpriseConfig enterpriseConfig = config.enterpriseConfig;         return enterpriseConfig != null                 && enterpriseConfig.getEapMethod() != WifiEnterpriseConfig.Eap.NONE;     }      /**      * Tests for {@link WifiManager#retrieveBackupData()} &      * {@link WifiManager#restoreBackupData(byte[])}      * Note: If the network was not created by an app with OVERRIDE_WIFI_CONFIG permission (held      * by AOSP settings app for example), then the backup data will not contain that network. If      * the device does not contain any such pre-existing saved network, then this test will be      * a no-op, will only ensure that the device does not crash when invoking the API's.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testCanRestoreSoftApBackupData"	"CtsWifiTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"public void testCanRestoreSoftApBackupData() {         UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();         SoftApConfiguration origSoftApConfig = null;         try {             uiAutomation.adoptShellPermissionIdentity();              // Retrieve original soft ap config.             origSoftApConfig = mWifiManager.getSoftApConfiguration();              // Retrieve backup data.             byte[] backupData = mWifiManager.retrieveSoftApBackupData();              // Modify softap config and set it.             SoftApConfiguration modSoftApConfig = new SoftApConfiguration.Builder(origSoftApConfig)                     .setSsid(origSoftApConfig.getSsid() + ""b"")                     .build();             mWifiManager.setSoftApConfiguration(modSoftApConfig);             // Ensure that it does not match the orig softap config.             assertThat(mWifiManager.getSoftApConfiguration()).isNotEqualTo(origSoftApConfig);              // Restore the original backup data & ensure that the orig softap config is restored.             mWifiManager.restoreSoftApBackupData(backupData);             assertThat(mWifiManager.getSoftApConfiguration()).isEqualTo(origSoftApConfig);         } finally {             if (origSoftApConfig != null) {                 mWifiManager.setSoftApConfiguration(origSoftApConfig);             }             uiAutomation.dropShellPermissionIdentity();         }     }      /**      * Read the content of the given resource file into a String.      *      * @param filename String name of the file      * @return Byte array of the contents of the file.      * @throws IOException      */     private byte[] loadResourceFile(String filename) throws IOException {         InputStream in = getClass().getClassLoader().getResourceAsStream(filename);         DataInputStream dis = new DataInputStream(in);         byte[] data = new byte[dis.available()];         dis.readFully(data);         return data;     }      private WifiConfiguration createExpectedLegacyWepWifiConfiguration() {         WifiConfiguration configuration = new WifiConfiguration();         configuration.SSID = ""\""TestSsid1\"""";         configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);         configuration.wepKeys = new String[4];         configuration.wepKeys[0] = ""\""WepAscii1\"""";         configuration.wepKeys[1] = ""\""WepAscii2\"""";         configuration.wepKeys[2] = ""45342312ab"";         configuration.wepKeys[3] = ""45342312ab45342312ab34ac12"";         configuration.wepTxKeyIndex = 1;         return configuration;     }      private WifiConfiguration createExpectedLegacyPskWifiConfiguration() {         WifiConfiguration configuration = new WifiConfiguration();         configuration.SSID = ""\""TestSsid2\"""";         configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);         configuration.preSharedKey = ""\""TestPsk123\"""";         return configuration;     }      private WifiConfiguration createExpectedLegacyOpenWifiConfiguration() {         WifiConfiguration configuration = new WifiConfiguration();         configuration.SSID = ""\""TestSsid3\"""";         configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);         return configuration;     }      private IpConfiguration createExpectedLegacyDHCPIpConfigurationWithPacProxy() throws Exception {         IpConfiguration ipConfiguration = new IpConfiguration();         ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.DHCP);         ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.PAC);         ipConfiguration.setHttpProxy(ProxyInfo.buildPacProxy(                 Uri.parse(EXPECTED_LEGACY_PAC_PROXY_LOCATION)));         return ipConfiguration;     }      private StaticIpConfiguration createExpectedLegacyStaticIpconfiguration() throws Exception {         return new StaticIpConfiguration.Builder()                 .setIpAddress(                         new LinkAddress(                                 InetAddress.getByName(EXPECTED_LEGACY_STATIC_IP_LINK_ADDRESS),                                 EXPECTED_LEGACY_STATIC_IP_LINK_PREFIX_LENGTH))                 .setGateway(InetAddress.getByName(EXPECTED_LEGACY_STATIC_IP_GATEWAY_ADDRESS))                 .setDnsServers(Arrays.asList(EXPECTED_LEGACY_STATIC_IP_DNS_SERVER_ADDRESSES)                         .stream()                         .map(s -> {                             try {                                 return InetAddress.getByName(s);                             } catch (UnknownHostException e) {                                 return null;                             }                         })                         .collect(Collectors.toList()))                 .build();     }      private IpConfiguration createExpectedLegacyStaticIpConfigurationWithPacProxy()             throws Exception {         IpConfiguration ipConfiguration = new IpConfiguration();         ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.STATIC);         ipConfiguration.setStaticIpConfiguration(createExpectedLegacyStaticIpconfiguration());         ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.PAC);         ipConfiguration.setHttpProxy(ProxyInfo.buildPacProxy(                 Uri.parse(EXPECTED_LEGACY_PAC_PROXY_LOCATION)));         return ipConfiguration;     }      private IpConfiguration createExpectedLegacyStaticIpConfigurationWithStaticProxy()             throws Exception {         IpConfiguration ipConfiguration = new IpConfiguration();         ipConfiguration.setIpAssignment(IpConfiguration.IpAssignment.STATIC);         ipConfiguration.setStaticIpConfiguration(createExpectedLegacyStaticIpconfiguration());         ipConfiguration.setProxySettings(IpConfiguration.ProxySettings.STATIC);         ipConfiguration.setHttpProxy(ProxyInfo.buildDirectProxy(                 EXPECTED_LEGACY_STATIC_PROXY_HOST, EXPECTED_LEGACY_STATIC_PROXY_PORT,                 Arrays.asList(EXPECTED_LEGACY_STATIC_PROXY_EXCLUSION_LIST)));         return ipConfiguration;     }      /**      * Asserts that the 2 lists of WifiConfigurations are equal. This compares all the elements      * saved for backup/restore.      */     public static void assertConfigurationsEqual(             List<WifiConfiguration> expected, List<WifiConfiguration> actual) {         assertThat(actual.size()).isEqualTo(expected.size());         for (WifiConfiguration expectedConfiguration : expected) {             String expectedConfigKey = expectedConfiguration.getKey();             boolean didCompare = false;             for (WifiConfiguration actualConfiguration : actual) {                 String actualConfigKey = actualConfiguration.getKey();                 if (actualConfigKey.equals(expectedConfigKey)) {                     assertConfigurationEqual(                             expectedConfiguration, actualConfiguration);                     didCompare = true;                 }             }             assertWithMessage(""Didn't find matching config for key = ""                     + expectedConfigKey).that(didCompare).isTrue();         }     }      /**      * Asserts that the 2 WifiConfigurations are equal.      */     private static void assertConfigurationEqual(             WifiConfiguration expected, WifiConfiguration actual) {         assertThat(actual).isNotNull();         assertThat(expected).isNotNull();         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.SSID).isEqualTo(expected.SSID);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.preSharedKey).isEqualTo(expected.preSharedKey);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.wepKeys).isEqualTo(expected.wepKeys);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.wepTxKeyIndex).isEqualTo(expected.wepTxKeyIndex);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.hiddenSSID).isEqualTo(expected.hiddenSSID);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.requirePmf).isEqualTo(expected.requirePmf);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.allowedKeyManagement).isEqualTo(expected.allowedKeyManagement);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.shared).isEqualTo(expected.shared);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.allowAutojoin).isEqualTo(expected.allowAutojoin);         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.getIpConfiguration()).isEqualTo(expected.getIpConfiguration());         assertWithMessage(""Network: "" + actual.toString())                 .that(actual.meteredOverride).isEqualTo(expected.meteredOverride);     }      private void testRestoreFromBackupData(             List<WifiConfiguration> expectedConfigurations, ThrowingRunnable restoreMethod)         throws Exception {         UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();         List<WifiConfiguration> restoredSavedNetworks = null;         try {             uiAutomation.adoptShellPermissionIdentity();             Set<String> origSavedSsids = mWifiManager.getConfiguredNetworks().stream()                     .map(n -> n.SSID)                     .collect(Collectors.toSet());              restoreMethod.run();              restoredSavedNetworks = mWifiManager.getPrivilegedConfiguredNetworks().stream()                     .filter(n -> !origSavedSsids.contains(n.SSID))                     .collect(Collectors.toList());             assertConfigurationsEqual(                     expectedConfigurations, restoredSavedNetworks);         } finally {             // clean up all restored networks.             if (restoredSavedNetworks != null) {                 for (WifiConfiguration network : restoredSavedNetworks) {                     mWifiManager.removeNetwork(network.networkId);                 }             }             uiAutomation.dropShellPermissionIdentity();         }     }      private List<WifiConfiguration> createExpectedLegacyConfigurations() throws Exception {         List<WifiConfiguration> expectedConfigurations = new ArrayList<>();         WifiConfiguration wepNetwork = createExpectedLegacyWepWifiConfiguration();         wepNetwork.setIpConfiguration(createExpectedLegacyDHCPIpConfigurationWithPacProxy());         expectedConfigurations.add(wepNetwork);          WifiConfiguration pskNetwork = createExpectedLegacyPskWifiConfiguration();         pskNetwork.setIpConfiguration(createExpectedLegacyStaticIpConfigurationWithPacProxy());         expectedConfigurations.add(pskNetwork);          WifiConfiguration openNetwork = createExpectedLegacyOpenWifiConfiguration();         openNetwork.setIpConfiguration(                 createExpectedLegacyStaticIpConfigurationWithStaticProxy());         expectedConfigurations.add(openNetwork);         return expectedConfigurations;     }      /**      * Verify that 3 network configuration is deserialized correctly from AOSP      * legacy supplicant/ipconf backup data format.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.managedprofile.CurrentApiHelperTest"	"testGetPublicApisIncludeMethods"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/CurrentApiHelperTest.java"	""	"public void testGetPublicApisIncludeMethods() throws Exception {         Method publicMethod = mClazz.getMethod(""lockNow"");         assertTrue(mPublicApis.contains(publicMethod));         publicMethod = mClazz.getMethod(""isProfileOwnerApp"", String.class);         assertTrue(mPublicApis.contains(publicMethod));         publicMethod = mClazz.getMethod(""resetPassword"", String.class, int.class);         assertTrue(mPublicApis.contains(publicMethod));         publicMethod = mClazz.getMethod(""hasGrantedPolicy"", ComponentName.class, int.class);         assertTrue(mPublicApis.contains(publicMethod));         publicMethod = mClazz.getMethod(""installCaCert"", ComponentName.class, Class.forName(""[B""));         assertTrue(mPublicApis.contains(publicMethod));     }      /**      * Test: {@link CurrentApiHelper#getPublicApis} excludes private, hidden or {@code @SystemApi}      * methods.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.managedprofile.CurrentApiHelperTest"	"testGetPublicApisExcludeMethods"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/CurrentApiHelperTest.java"	""	"public void testGetPublicApisExcludeMethods() throws Exception {         Method privateMethod = mClazz.getDeclaredMethod(""throwIfParentInstance"", String.class);         assertFalse(mPublicApis.contains(privateMethod));         Method hiddenMethod = mClazz.getMethod(""isDeviceProvisioned"");         assertFalse(mPublicApis.contains(hiddenMethod));         Method systemMethod = mClazz.getMethod(""getProfileOwnerNameAsUser"", int.class);         assertFalse(mPublicApis.contains(systemMethod));     }      /** Test for {@link CurrentApiHelper#instantiate}. */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsAnimationControllerTests"	"testControl_immediately_hide"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsAnimationControllerTests.java"	""	"public void testControl_immediately_hide() throws Throwable {         setVisibilityAndWait(mType, true);          runOnUiThread(() -> {             setupAnimationListener();             mRootView.getWindowInsetsController().controlWindowInsetsAnimation(mType, 0,                     null, null, mListener);         });          mListener.awaitAndAssert(READY);          runOnUiThread(() -> {             mListener.mController.finish(false);         });          mListener.awaitAndAssert(FINISHED);         mListener.assertWasNotCalled(CANCELLED);     }      @Presubmit"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsAnimationControllerTests"	"testControl_transition_hide"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsAnimationControllerTests.java"	""	"public void testControl_transition_hide() throws Throwable {         setVisibilityAndWait(mType, true);          runOnUiThread(() -> {             setupAnimationListener();             mRootView.getWindowInsetsController().controlWindowInsetsAnimation(mType, 0,                     null, null, mListener);         });          mListener.awaitAndAssert(READY);          runTransition(false);          mListener.awaitAndAssert(FINISHED);         mListener.assertWasNotCalled(CANCELLED);     }      @Presubmit"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsAnimationControllerTests"	"testControl_transition_hide_interpolator"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsAnimationControllerTests.java"	""	"public void testControl_transition_hide_interpolator() throws Throwable {         mInterpolator = new AccelerateInterpolator();         setVisibilityAndWait(mType, true);          runOnUiThread(() -> {             setupAnimationListener();             mRootView.getWindowInsetsController().controlWindowInsetsAnimation(mType, 0,                     mInterpolator, null, mListener);         });          mListener.awaitAndAssert(READY);          runTransition(false);          mListener.awaitAndAssert(FINISHED);         mListener.assertWasNotCalled(CANCELLED);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowInsetsAnimationControllerTests"	"testImeControl_isntInterruptedByStartingInput"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsAnimationControllerTests.java"	""	"public void testImeControl_isntInterruptedByStartingInput() throws Throwable {         if (mType != ime()) {             return;         }          setVisibilityAndWait(mType, false);          runOnUiThread(() -> {             setupAnimationListener();             mRootView.getWindowInsetsController().controlWindowInsetsAnimation(mType, 0,                     null, null, mListener);         });          mListener.awaitAndAssert(READY);          runTransition(true);         runOnUiThread(() -> {             mActivity.getSystemService(InputMethodManager.class).restartInput(mActivity.mEditor);         });          mListener.awaitAndAssert(FINISHED);         mListener.assertWasNotCalled(CANCELLED);     }      private void setupAnimationListener() {         WindowInsets initialInsets = mActivity.mLastWindowInsets;         VerifyingCallback callback = new VerifyingCallback(                 new Callback(Callback.DISPATCH_MODE_STOP) {             @Override             public void onPrepare(@NonNull WindowInsetsAnimation animation) {                 mErrorCollector.checkThat(""onPrepare"",                         mActivity.mLastWindowInsets.getInsets(mType),                         equalTo(initialInsets.getInsets(mType)));             }              @NonNull             @Override             public WindowInsetsAnimation.Bounds onStart(                     @NonNull WindowInsetsAnimation animation,                     @NonNull WindowInsetsAnimation.Bounds bounds) {                 mErrorCollector.checkThat(""onStart"",                         mActivity.mLastWindowInsets, not(equalTo(initialInsets)));                 mErrorCollector.checkThat(""onStart"",                         animation.getInterpolator(), sameInstance(mInterpolator));                 return bounds;             }              @NonNull             @Override             public WindowInsets onProgress(@NonNull WindowInsets insets,                     @NonNull List<WindowInsetsAnimation> runningAnimations) {                 mOnProgressCalled = true;                 if (mAnimator != null) {                     float fraction = runningAnimations.get(0).getFraction();                     mErrorCollector.checkThat(                             String.format(Locale.US, ""onProgress(%.2f)"", fraction),                             insets.getInsets(mType), equalTo(mAnimator.getAnimatedValue()));                     mErrorCollector.checkThat(""onProgress"",                             fraction, equalTo(mAnimator.getAnimatedFraction()));                      Interpolator interpolator =                             mInterpolator != null ? mInterpolator                                     : new LinearInterpolator();                     mErrorCollector.checkThat(""onProgress"",                             runningAnimations.get(0).getInterpolatedFraction(),                             equalTo(interpolator.getInterpolation(                                     mAnimator.getAnimatedFraction())));                 }                 return insets;             }              @Override             public void onEnd(@NonNull WindowInsetsAnimation animation) {                 mRootView.setWindowInsetsAnimationCallback(null);             }         });         mCallbacks.add(callback);         mRootView.setWindowInsetsAnimationCallback(callback);     }      private void runTransition(boolean show) throws Throwable {         runTransition(show, 1000);     }      private void runTransition(boolean show, long durationMillis) throws Throwable {         runOnUiThread(() -> {             mAnimator = ValueAnimator.ofObject(                     INSETS_EVALUATOR,                     show ? mListener.mController.getHiddenStateInsets()                             : mListener.mController.getShownStateInsets(),                     show ? mListener.mController.getShownStateInsets()                             : mListener.mController.getHiddenStateInsets()             );             mAnimator.setDuration(durationMillis);             mAnimator.addUpdateListener((animator1) -> {                 if (!mListener.mController.isReady()) {                     // Lost control - Don't crash the instrumentation below.                     if (!mLossOfControlExpected) {                         mErrorCollector.addError(new AssertionError(""Unexpectedly lost control.""));                     }                     mAnimator.cancel();                     return;                 }                 Insets insets = (Insets) mAnimator.getAnimatedValue();                 mOnProgressCalled = false;                 mListener.mController.setInsetsAndAlpha(insets, 1.0f,                         mAnimator.getAnimatedFraction());                 mErrorCollector.checkThat(                         ""setInsetsAndAlpha() must synchronously call onProgress() but didn't"",                         mOnProgressCalled, is(true));             });             mAnimator.addListener(new AnimatorListenerAdapter() {                 @Override                 public void onAnimationEnd(Animator animation) {                     if (!mListener.mController.isCancelled()) {                         mListener.mController.finish(show);                     }                 }             });              mAnimator.start();         });     }      private void setVisibilityAndWait(int type, boolean visible) throws Throwable {         runOnUiThread(() -> {             if (visible) {                 mRootView.getWindowInsetsController().show(type);             } else {                 mRootView.getWindowInsetsController().hide(type);             }         });          waitForOrFail(""Timeout waiting for inset to become "" + (visible ? ""visible"" : ""invisible""),                 () -> mActivity.mLastWindowInsets.isVisible(mType) == visible);     }      static class ControlListener implements WindowInsetsAnimationControlListener {         private final ErrorCollector mErrorCollector;          WindowInsetsAnimationController mController = null;         int mTypes = -1;          ControlListener(ErrorCollector errorCollector) {             mErrorCollector = errorCollector;         }          enum Event {             READY, FINISHED, CANCELLED;         }          /** Latch for every callback event. */         private CountDownLatch[] mLatches = {                 new CountDownLatch(1),                 new CountDownLatch(1),                 new CountDownLatch(1),         };          @Override         public void onReady(@NonNull WindowInsetsAnimationController controller, int types) {             mController = controller;             mTypes = types;              // Collect errors here and below, so we don't crash the main thread.             mErrorCollector.checkThat(controller, notNullValue());             mErrorCollector.checkThat(types, not(equalTo(0)));             mErrorCollector.checkThat(""isReady"", controller.isReady(), is(true));             mErrorCollector.checkThat(""isFinished"", controller.isFinished(), is(false));             mErrorCollector.checkThat(""isCancelled"", controller.isCancelled(), is(false));             report(READY);         }          @Override         public void onFinished(@NonNull WindowInsetsAnimationController controller) {             mErrorCollector.checkThat(controller, notNullValue());             mErrorCollector.checkThat(controller, sameInstance(mController));             mErrorCollector.checkThat(""isReady"", controller.isReady(), is(false));             mErrorCollector.checkThat(""isFinished"", controller.isFinished(), is(true));             mErrorCollector.checkThat(""isCancelled"", controller.isCancelled(), is(false));             report(FINISHED);         }          @Override         public void onCancelled(@Nullable WindowInsetsAnimationController controller) {             mErrorCollector.checkThat(controller, sameInstance(mController));             if (controller != null) {                 mErrorCollector.checkThat(""isReady"", controller.isReady(), is(false));                 mErrorCollector.checkThat(""isFinished"", controller.isFinished(), is(false));                 mErrorCollector.checkThat(""isCancelled"", controller.isCancelled(), is(true));             }             report(CANCELLED);         }          private void report(Event event) {             CountDownLatch latch = mLatches[event.ordinal()];             mErrorCollector.checkThat(event + "": count"", latch.getCount(), is(1L));             latch.countDown();         }          void awaitAndAssert(Event event) {             CountDownLatch latch = mLatches[event.ordinal()];             try {                 if (!latch.await(10, TimeUnit.SECONDS)) {                     fail(""Timeout waiting for "" + event);                 }             } catch (InterruptedException e) {                 throw new AssertionError(""Interrupted"", e);             }         }          void assertWasCalled(Event event) {             CountDownLatch latch = mLatches[event.ordinal()];             assertEquals(event + "" expected, but never called"", 0, latch.getCount());         }          void assertWasNotCalled(Event event) {             CountDownLatch latch = mLatches[event.ordinal()];             assertEquals(event + "" not expected, but was called"", 1, latch.getCount());         }     }       private class VerifyingCallback extends Callback {         private final Callback mInner;         private final Set<WindowInsetsAnimation> mPreparedAnimations = new HashSet<>();         private final Set<WindowInsetsAnimation> mRunningAnimations = new HashSet<>();          public VerifyingCallback(Callback callback) {             super(callback.getDispatchMode());             mInner = callback;         }          @Override         public void onPrepare(@NonNull WindowInsetsAnimation animation) {             mErrorCollector.checkThat(""onPrepare"", mPreparedAnimations, not(hasItem(animation)));             mPreparedAnimations.add(animation);             mInner.onPrepare(animation);         }          @NonNull         @Override         public WindowInsetsAnimation.Bounds onStart(@NonNull WindowInsetsAnimation animation,                 @NonNull WindowInsetsAnimation.Bounds bounds) {             mErrorCollector.checkThat(""onStart: mPreparedAnimations"",                     mPreparedAnimations, hasItem(animation));             mErrorCollector.checkThat(""onStart: mRunningAnimations"",                     mRunningAnimations, not(hasItem(animation)));             mRunningAnimations.add(animation);             mPreparedAnimations.remove(animation);             return mInner.onStart(animation, bounds);         }          @NonNull         @Override         public WindowInsets onProgress(@NonNull WindowInsets insets,                 @NonNull List<WindowInsetsAnimation> runningAnimations) {             mErrorCollector.checkThat(""onProgress"", new HashSet<>(runningAnimations),                     is(equalTo(mRunningAnimations)));             return mInner.onProgress(insets, runningAnimations);         }          @Override         public void onEnd(@NonNull WindowInsetsAnimation animation) {             mErrorCollector.checkThat(""onEnd: mRunningAnimations"",                     mRunningAnimations, hasItem(animation));             mRunningAnimations.remove(animation);             mPreparedAnimations.remove(animation);             mInner.onEnd(animation);         }          public void assertNoRunningAnimations() {             mErrorCollector.checkThat(mRunningAnimations, hasSize(0));         }     }      public static final class LimitedErrorCollector extends ErrorCollector {         private static final int LIMIT = 1;         private int mCount = 0;          @Override         public void addError(Throwable error) {             if (mCount++ < LIMIT) {                 super.addError(error);             }         }          @Override         protected void verify() throws Throwable {             if (mCount > LIMIT) {                 super.addError(new AssertionError((mCount - LIMIT) + "" errors skipped.""));             }             super.verify();         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.AppTaskTests"	"testMoveToFront"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/AppTaskTests.java"	""	"public void testMoveToFront() throws Exception {         final Activity a1 = mActivityRule.launchActivity(null);          // Launch fullscreen activity as an another task to hide the first activity         final Intent intent = new Intent();         intent.setComponent(new ComponentName(mTargetContext, MockActivity.class));         intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_NEW_DOCUMENT                     | FLAG_ACTIVITY_MULTIPLE_TASK);         final ActivityOptions options = ActivityOptions.makeBasic();         options.setLaunchWindowingMode(WINDOWING_MODE_FULLSCREEN);         mInstrumentation.startActivitySync(intent, options.toBundle());          final BooleanValue targetResumed = new BooleanValue();         mLifecycleMonitor.addLifecycleCallback(new ActivityLifecycleCallback() {             public void onActivityLifecycleChanged(Activity activity, Stage stage) {                 if (activity == a1 && stage == Stage.RESUMED) {                     targetResumed.value = true;                 }             }         });          getAppTask(a1).moveToFront();         waitAndAssertCondition(() -> targetResumed.value,                 ""Expected activity brought to front and resumed"");     }      /**      * Ensure that starting a new activity in the same task results in two activities in the task.      */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testCanCreateHiddenFile"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	"public void testCanCreateHiddenFile() throws Exception {         runDeviceTest(""testCanCreateHiddenFile"");     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testCanRenameHiddenFile"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	"public void testCanRenameHiddenFile() throws Exception {         runDeviceTest(""testCanRenameHiddenFile"");     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testHiddenDirectory"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	"public void testHiddenDirectory() throws Exception {         runDeviceTest(""testHiddenDirectory"");     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testHiddenDirectory_nomedia"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	"public void testHiddenDirectory_nomedia() throws Exception {         runDeviceTest(""testHiddenDirectory_nomedia"");     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testListHiddenFile"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	"public void testListHiddenFile() throws Exception {         runDeviceTest(""testListHiddenFile"");     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.verifier.audio.RingerModeActivity"	"TestVolumeDndAffectedStream"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/RingerModeActivity.java"	""	"Api method to query the VolumPolicy         //tests.add(new TestVolumeDndAffectedStream());         tests.add(new TestVolume());         tests.add(new TestMuteStreams());         tests.add(new EnableSoundEffects());         tests.add(new TestSoundEffects());         return tests;     }      private int getVolumeDelta(int volume) {         return 1;     }      private boolean hasAudioOutput() {         return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT);     }      private void testStreamMuting(int stream) {         if (stream == AudioManager.STREAM_VOICE_CALL) {             // Voice call requires MODIFY_PHONE_STATE, so we should not be able to mute             mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_MUTE, 0);             assertFalse(""Muting stream "" + stream + "" should require MODIFY_PHONE_STATE permission."",                     mAudioManager.isStreamMute(stream));         } else {             mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_MUTE, 0);             assertTrue(""Muting stream "" + stream + "" failed."",                     mAudioManager.isStreamMute(stream));              mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_UNMUTE, 0);             assertFalse(""Unmuting stream "" + stream + "" failed."",                     mAudioManager.isStreamMute(stream));              mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_TOGGLE_MUTE, 0);             assertTrue(""Toggling mute on stream "" + stream + "" failed."",                     mAudioManager.isStreamMute(stream));              mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_TOGGLE_MUTE, 0);             assertFalse(""Toggling mute on stream "" + stream + "" failed."",                     mAudioManager.isStreamMute(stream));              mAudioManager.setStreamMute(stream, true);             assertTrue(""Muting stream "" + stream + "" using setStreamMute failed"",                     mAudioManager.isStreamMute(stream));              // mute it three more times to verify the ref counting is gone.             mAudioManager.setStreamMute(stream, true);             mAudioManager.setStreamMute(stream, true);             mAudioManager.setStreamMute(stream, true);              mAudioManager.setStreamMute(stream, false);             assertFalse(""Unmuting stream "" + stream + "" using setStreamMute failed."",                     mAudioManager.isStreamMute(stream));         }     }      // Tests      protected class PassTest extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createRetryItem(parent, R.string.ringer_mode_pass_test);         }          @Override         protected void test() {            status = PASS;         }     }       protected class SetModeAllTest extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createRetryItem(parent, R.string.attention_filter_all);         }          @Override         protected void test() {             if (mUserVerified) {                 status = PASS;             } else {                 status = WAIT_FOR_USER;             }         }          @Override         protected void tearDown() {             mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, 1, 0);             delay();         }     }      protected class SetModePriorityTest extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createRetryItem(parent, R.string.attention_filter_priority_mimic_alarms_only);         }          @Override         protected void test() {             if (mUserVerified) {                 status = PASS;             } else {                 status = WAIT_FOR_USER;             }         }          @Override         protected void tearDown() {             mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, 1, 0);             delay();         }     }      protected class EnableSoundEffects extends InteractiveTestCase {          @Override         protected View inflate(ViewGroup parent) {             return createRetryItem(parent, R.string.enable_sound_effects);         }          @Override         protected void test() {              if (mSkipTouchSoundTests) {                 status = PASS;                 return;             }              boolean touchSoundEnabled =                 Settings.System.getInt(mContext.getContentResolver(),                     Settings.System.SOUND_EFFECTS_ENABLED, 1) == 1;             if (mUserVerified) {                 if (touchSoundEnabled) {                     status = PASS;                     return;                 } else {                     setFailed();                     return;                 }             } else {                 status = WAIT_FOR_USER;             }         }          @Override         protected void tearDown() {             delay();         }     }      protected class TestSoundEffects extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_sound_effects);         }          @Override         protected void test() {              if (mSkipTouchSoundTests) {                 status = PASS;                 return;             }              // should hear sound after loadSoundEffects() called.             mAudioManager.loadSoundEffects();             try {                 Thread.sleep(TIME_TO_PLAY);             } catch (InterruptedException e) {                 e.printStackTrace();             }             float volume = 13;             mAudioManager.playSoundEffect(SoundEffectConstants.CLICK);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);              mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP, volume);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN, volume);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT, volume);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT, volume);              // won't hear sound after unloadSoundEffects() called();             mAudioManager.unloadSoundEffects();             mAudioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);              mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP, volume);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN, volume);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT, volume);             mAudioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT, volume);             status = PASS;         }     }      protected class TestVibrateNotificationDndOn extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_vibrate_notification);         }          @Override         protected void test() {             if (mUseFixedVolume || !mHasVibrator) {                 status = PASS;                 return;             }              // VIBRATE_SETTING_ON             mAudioManager.setVibrateSetting(VIBRATE_TYPE_NOTIFICATION, VIBRATE_SETTING_ON);             if (VIBRATE_SETTING_ON != mAudioManager.getVibrateSetting(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              if (mAudioManager.shouldVibrate(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              // VIBRATE_SETTING_OFF             mAudioManager.setVibrateSetting(VIBRATE_TYPE_NOTIFICATION, VIBRATE_SETTING_OFF);             if (VIBRATE_SETTING_OFF != mAudioManager.getVibrateSetting(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              if (mAudioManager.shouldVibrate(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              // VIBRATE_SETTING_ONLY_SILENT             mAudioManager.setVibrateSetting(VIBRATE_TYPE_NOTIFICATION, VIBRATE_SETTING_ONLY_SILENT);             if (VIBRATE_SETTING_ONLY_SILENT                     != mAudioManager.getVibrateSetting(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              if (mAudioManager.shouldVibrate(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }             status = PASS;         }     }      protected class TestVibrateNotification extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_vibrate_notification);         }          @Override         protected void test() {             if (mUseFixedVolume || !mHasVibrator) {                 status = PASS;                 return;             }             // VIBRATE_SETTING_ON             mAudioManager.setVibrateSetting(VIBRATE_TYPE_NOTIFICATION, VIBRATE_SETTING_ON);             if (VIBRATE_SETTING_ON != mAudioManager.getVibrateSetting(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }             if (!mAudioManager.shouldVibrate(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              mAudioManager.setRingerMode(RINGER_MODE_VIBRATE);             if (RINGER_MODE_VIBRATE != mAudioManager.getRingerMode()) {                 setFailed();                 return;             }             if (!mAudioManager.shouldVibrate(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              // VIBRATE_SETTING_OFF             mAudioManager.setVibrateSetting(VIBRATE_TYPE_NOTIFICATION, VIBRATE_SETTING_OFF);             if (VIBRATE_SETTING_OFF != mAudioManager.getVibrateSetting(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }             mAudioManager.setRingerMode(RINGER_MODE_NORMAL);             if (mAudioManager.shouldVibrate(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              mAudioManager.setRingerMode(RINGER_MODE_VIBRATE);             if (RINGER_MODE_VIBRATE != mAudioManager.getRingerMode()) {                 setFailed();                 return;             }             if (mAudioManager.shouldVibrate(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              // VIBRATE_SETTING_ONLY_SILENT             mAudioManager.setVibrateSetting(VIBRATE_TYPE_NOTIFICATION, VIBRATE_SETTING_ONLY_SILENT);             if (VIBRATE_SETTING_ONLY_SILENT                     != mAudioManager.getVibrateSetting(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }             mAudioManager.setRingerMode(RINGER_MODE_NORMAL);             if (mAudioManager.shouldVibrate(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              mAudioManager.setRingerMode(RINGER_MODE_VIBRATE);             if (RINGER_MODE_VIBRATE != mAudioManager.getRingerMode()) {                 setFailed();                 return;             }             if (!mAudioManager.shouldVibrate(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }              // VIBRATE_TYPE_NOTIFICATION             mAudioManager.setVibrateSetting(VIBRATE_TYPE_NOTIFICATION, VIBRATE_SETTING_ON);             if(VIBRATE_SETTING_ON  != mAudioManager.getVibrateSetting(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }             mAudioManager.setVibrateSetting(VIBRATE_TYPE_NOTIFICATION, VIBRATE_SETTING_OFF);             if(VIBRATE_SETTING_OFF != mAudioManager.getVibrateSetting(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }             mAudioManager.setVibrateSetting(VIBRATE_TYPE_NOTIFICATION, VIBRATE_SETTING_ONLY_SILENT);             if (VIBRATE_SETTING_ONLY_SILENT                     != mAudioManager.getVibrateSetting(VIBRATE_TYPE_NOTIFICATION)) {                 setFailed();                 return;             }             status = PASS;         }     }      protected class TestVibrateRingerDndOn extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_vibrate_ringer);         }          @Override         protected void test() {             if (mUseFixedVolume || !mHasVibrator) {                 status = PASS;                 return;             }              // VIBRATE_SETTING_ON             mAudioManager.setVibrateSetting(VIBRATE_TYPE_RINGER, VIBRATE_SETTING_ON);             if (VIBRATE_SETTING_ON != mAudioManager.getVibrateSetting(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              if (mAudioManager.shouldVibrate(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              // VIBRATE_SETTING_OFF             mAudioManager.setVibrateSetting(VIBRATE_TYPE_RINGER, VIBRATE_SETTING_OFF);             if (VIBRATE_SETTING_OFF != mAudioManager.getVibrateSetting(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              if (mAudioManager.shouldVibrate(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              // VIBRATE_SETTING_ONLY_SILENT             mAudioManager.setVibrateSetting(VIBRATE_TYPE_RINGER, VIBRATE_SETTING_ONLY_SILENT);             if (VIBRATE_SETTING_ONLY_SILENT                     != mAudioManager.getVibrateSetting(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              if (mAudioManager.shouldVibrate(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }             status = PASS;         }     }      protected class TestVibrateRinger extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_vibrate_ringer);         }          @Override         protected void test() {             if (mUseFixedVolume || !mHasVibrator) {                 status = PASS;                 return;             }             // VIBRATE_SETTING_ON             mAudioManager.setVibrateSetting(VIBRATE_TYPE_RINGER, VIBRATE_SETTING_ON);             if (VIBRATE_SETTING_ON != mAudioManager.getVibrateSetting(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }             if (!mAudioManager.shouldVibrate(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              mAudioManager.setRingerMode(RINGER_MODE_VIBRATE);             if (RINGER_MODE_VIBRATE != mAudioManager.getRingerMode()) {                 setFailed();                 return;             }             if (!mAudioManager.shouldVibrate(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              // VIBRATE_SETTING_OFF             mAudioManager.setVibrateSetting(VIBRATE_TYPE_RINGER, VIBRATE_SETTING_OFF);             if (VIBRATE_SETTING_OFF != mAudioManager.getVibrateSetting(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }             mAudioManager.setRingerMode(RINGER_MODE_NORMAL);             if (mAudioManager.shouldVibrate(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              mAudioManager.setRingerMode(RINGER_MODE_VIBRATE);             if (RINGER_MODE_VIBRATE != mAudioManager.getRingerMode()) {                 setFailed();                 return;             }             if (mAudioManager.shouldVibrate(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              // VIBRATE_SETTING_ONLY_SILENT             mAudioManager.setVibrateSetting(VIBRATE_TYPE_RINGER, VIBRATE_SETTING_ONLY_SILENT);             if (VIBRATE_SETTING_ONLY_SILENT                     != mAudioManager.getVibrateSetting(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }             mAudioManager.setRingerMode(RINGER_MODE_NORMAL);             if (mAudioManager.shouldVibrate(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              mAudioManager.setRingerMode(RINGER_MODE_VIBRATE);             if (RINGER_MODE_VIBRATE != mAudioManager.getRingerMode()) {                 setFailed();                 return;             }             if (!mAudioManager.shouldVibrate(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }              // VIBRATE_TYPE_NOTIFICATION             mAudioManager.setVibrateSetting(VIBRATE_TYPE_RINGER, VIBRATE_SETTING_ON);             if (VIBRATE_SETTING_ON != mAudioManager.getVibrateSetting(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }             mAudioManager.setVibrateSetting(VIBRATE_TYPE_RINGER, VIBRATE_SETTING_OFF);             if (VIBRATE_SETTING_OFF != mAudioManager.getVibrateSetting(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }             mAudioManager.setVibrateSetting(VIBRATE_TYPE_RINGER, VIBRATE_SETTING_ONLY_SILENT);             if (VIBRATE_SETTING_ONLY_SILENT                     != mAudioManager.getVibrateSetting(VIBRATE_TYPE_RINGER)) {                 setFailed();                 return;             }             status = PASS;         }     }      protected class TestAccessRingerMode extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_access_ringer_mode);         }          @Override         protected void test() {             if (mSkipRingerTests) {                 status = PASS;                 return;             }             mAudioManager.setRingerMode(RINGER_MODE_NORMAL);             if (RINGER_MODE_NORMAL != mAudioManager.getRingerMode()) {                 setFailed();                 return;             }              if (mHasVibrator) {                 mAudioManager.setRingerMode(RINGER_MODE_VIBRATE);                 if (RINGER_MODE_VIBRATE != mAudioManager.getRingerMode()) {                     setFailed();                     return;                 }             }             status = PASS;         }          @Override         protected void tearDown() {             mAudioManager.setRingerMode(RINGER_MODE_NORMAL);             next();         }     }      protected class TestAccessRingerModeDndOn extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_access_ringer_mode);         }          @Override         protected void test() {             if (mSkipRingerTests) {                 status = PASS;                 return;             }             if (RINGER_MODE_SILENT != mAudioManager.getRingerMode()) {                 setFailed();                 return;             }             status = PASS;         }     }      protected class TestSetRingerModePolicyAccessDndOn extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_ringer_mode_policy_access);         }          @Override         protected void test() {             if (mSkipRingerTests) {                 status = PASS;                 return;             }             // This tests a subset of testSetRingerModePolicyAccess as cts verifier cannot             // get policy access on these devices.             try {                 mAudioManager.setRingerMode(RINGER_MODE_NORMAL);                 status = FAIL;                 logFail(""Apps without notification policy access cannot change ringer mode"");             } catch (SecurityException e) {             }              try {                 mAudioManager.setRingerMode(RINGER_MODE_VIBRATE);                 status = FAIL;                 logFail(""Apps without notification policy access cannot change ringer mode"");             } catch (SecurityException e) {             }             status = PASS;         }     }      protected class TestSetRingerModePolicyAccess extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_ringer_mode_policy_access);         }          @Override         protected void test() {             if (mSkipRingerTests) {                 status = PASS;                 return;             }             // This tests a subset of testSetRingerModePolicyAccess as cts verifier cannot             // get policy access on these devices.              try {                 mAudioManager.setRingerMode(RINGER_MODE_SILENT);                 status = FAIL;                 logFail(""Apps without notification policy access cannot change ringer mode"");             } catch (SecurityException e) {             }              if (mHasVibrator) {                 mAudioManager.setRingerMode(RINGER_MODE_VIBRATE);                  try {                     mAudioManager.setRingerMode(RINGER_MODE_SILENT);                     status = FAIL;                     logFail(""Apps without notification policy access cannot change ringer mode"");                 } catch (SecurityException e) {                 }             }             status = PASS;         }     }      protected class TestVolumeDndAffectedStream extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_volume_dnd_affected_stream);         }          @Override         protected void test() {             if (mSkipRingerTests || mHasVibrator) {                 status = PASS;                 return;             }              mAudioManager.setStreamVolume(                     AudioManager.STREAM_SYSTEM, 7, AudioManager.FLAG_ALLOW_RINGER_MODES);              // 7 to 0, fail.             try {                 mAudioManager.setStreamVolume(                         AudioManager.STREAM_SYSTEM, 0, AudioManager.FLAG_ALLOW_RINGER_MODES);                 status = FAIL;                 logFail(""Apps without notification policy access cannot change ringer mode"");                 return;             } catch (SecurityException e) {}              // 7 to 1: success             mAudioManager.setStreamVolume(                     AudioManager.STREAM_SYSTEM, 1, AudioManager.FLAG_ALLOW_RINGER_MODES);             if (1 !=  mAudioManager.getStreamVolume(AudioManager.STREAM_SYSTEM)) {                 setFailed();                 return;             }             status = PASS;         }     }      protected class TestVolumeDndAffectedStreamDndOn extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_volume_dnd_affected_stream);         }          @Override         protected void test() {             if (mSkipRingerTests || mHasVibrator) {                 status = PASS;                 return;             }              mAudioManager.setStreamVolume(                     AudioManager.STREAM_SYSTEM, 0, AudioManager.FLAG_ALLOW_RINGER_MODES);              try {                 mAudioManager.setStreamVolume(                         AudioManager.STREAM_SYSTEM, 6, AudioManager.FLAG_ALLOW_RINGER_MODES);                 status = FAIL;                 logFail(""Apps without notification policy access cannot change ringer mode"");                 return;             } catch (SecurityException e) {}             status = PASS;         }     }      protected class TestVolume extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_volume_dnd_affected_stream);         }          @Override         protected void test() {             if (mSkipRingerTests) {                 status = PASS;                 return;             }              int volume, volumeDelta;             int[] streams = {STREAM_MUSIC,                     AudioManager.STREAM_VOICE_CALL,                     AudioManager.STREAM_ALARM,                     AudioManager.STREAM_RING};              mAudioManager.adjustVolume(ADJUST_RAISE, 0);             // adjusting volume is aynchronous, wait before other volume checks             try {                 Thread.sleep(ASYNC_TIMING_TOLERANCE_MS);             } catch (InterruptedException e) {                 e.printStackTrace();             }             mAudioManager.adjustSuggestedStreamVolume(                     ADJUST_LOWER, USE_DEFAULT_STREAM_TYPE, 0);             try {                 Thread.sleep(ASYNC_TIMING_TOLERANCE_MS);             } catch (InterruptedException e) {                 e.printStackTrace();             }             int maxMusicVolume = mAudioManager.getStreamMaxVolume(STREAM_MUSIC);              for (int stream : streams) {                 Log.d(TAG, ""testing stream: "" + stream);                 mAudioManager.setRingerMode(RINGER_MODE_NORMAL);                 int maxVolume = mAudioManager.getStreamMaxVolume(stream);                 int minVolume = 1; // mAudioManager.getStreamMinVolume(stream); is @hide                  // validate min                 assertTrue(String.format(""minVolume(%d) must be >= 0"", minVolume), minVolume >= 0);                 assertTrue(String.format(""minVolume(%d) must be < maxVolume(%d)"", minVolume,                         maxVolume),                         minVolume < maxVolume);                  mAudioManager.setStreamVolume(stream, 1, 0);                 if (mUseFixedVolume) {                     assertEquals(maxVolume, mAudioManager.getStreamVolume(stream));                     return;                 }                 assertEquals(String.format(""stream=%d"", stream),                         1, mAudioManager.getStreamVolume(stream));                  if (stream == STREAM_MUSIC && mAudioManager.isWiredHeadsetOn()) {                     // due to new regulations, music sent over a wired headset may be volume limited                     // until the user explicitly increases the limit, so we can't rely on being able                     // to set the volume to getStreamMaxVolume(). Instead, determine the current limit                     // by increasing the volume until it won't go any higher, then use that volume as                     // the maximum for the purposes of this test                     int curvol = 0;                     int prevvol = 0;                     do {                         prevvol = curvol;                         mAudioManager.adjustStreamVolume(stream, ADJUST_RAISE, 0);                         curvol = mAudioManager.getStreamVolume(stream);                     } while (curvol != prevvol);                     maxVolume = maxMusicVolume = curvol;                 }                 mAudioManager.setStreamVolume(stream, maxVolume, 0);                 mAudioManager.adjustStreamVolume(stream, ADJUST_RAISE, 0);                 assertEquals(maxVolume, mAudioManager.getStreamVolume(stream));                  volumeDelta = getVolumeDelta(mAudioManager.getStreamVolume(stream));                 mAudioManager.adjustSuggestedStreamVolume(ADJUST_LOWER, stream, 0);                 try {                     Thread.sleep(ASYNC_TIMING_TOLERANCE_MS);                 } catch (InterruptedException e) {                     e.printStackTrace();                 }                 assertEquals(maxVolume - volumeDelta, mAudioManager.getStreamVolume(stream));                  // volume lower                 mAudioManager.setStreamVolume(stream, maxVolume, 0);                 volume = mAudioManager.getStreamVolume(stream);                 while (volume > minVolume) {                     volumeDelta = getVolumeDelta(mAudioManager.getStreamVolume(stream));                     mAudioManager.adjustStreamVolume(stream, ADJUST_LOWER, 0);                     assertEquals(Math.max(0, volume - volumeDelta),                             mAudioManager.getStreamVolume(stream));                     volume = mAudioManager.getStreamVolume(stream);                 }                  mAudioManager.adjustStreamVolume(stream, ADJUST_SAME, 0);                  // volume raise                 mAudioManager.setStreamVolume(stream, 1, 0);                 volume = mAudioManager.getStreamVolume(stream);                 while (volume < maxVolume) {                     volumeDelta = getVolumeDelta(mAudioManager.getStreamVolume(stream));                     mAudioManager.adjustStreamVolume(stream, ADJUST_RAISE, 0);                     assertEquals(Math.min(volume + volumeDelta, maxVolume),                             mAudioManager.getStreamVolume(stream));                     volume = mAudioManager.getStreamVolume(stream);                 }                  // volume same                 mAudioManager.setStreamVolume(stream, maxVolume, 0);                 for (int k = 0; k < maxVolume; k++) {                     mAudioManager.adjustStreamVolume(stream, ADJUST_SAME, 0);                     assertEquals(maxVolume, mAudioManager.getStreamVolume(stream));                 }                  mAudioManager.setStreamVolume(stream, maxVolume, 0);             }              if (mUseFixedVolume) {                 return;             }              // adjust volume             mAudioManager.adjustVolume(ADJUST_RAISE, 0);             try {                 Thread.sleep(ASYNC_TIMING_TOLERANCE_MS);             } catch (InterruptedException e) {                 e.printStackTrace();             }              boolean isMusicPlayingBeforeTest = false;             if (mAudioManager.isMusicActive()) {                 isMusicPlayingBeforeTest = true;             }              MediaPlayer mp = MediaPlayer.create(mContext, MP3_TO_PLAY);             assertNotNull(mp);             mp.setAudioStreamType(STREAM_MUSIC);             mp.setLooping(true);             mp.start();             try {                 Thread.sleep(TIME_TO_PLAY);             } catch (InterruptedException e) {                 e.printStackTrace();             }             assertTrue(mAudioManager.isMusicActive());              // adjust volume as ADJUST_SAME             for (int k = 0; k < maxMusicVolume; k++) {                 mAudioManager.adjustVolume(ADJUST_SAME, 0);                 try {                     Thread.sleep(ASYNC_TIMING_TOLERANCE_MS);                 } catch (InterruptedException e) {                     e.printStackTrace();                 }                 assertEquals(maxMusicVolume, mAudioManager.getStreamVolume(STREAM_MUSIC));             }              // adjust volume as ADJUST_RAISE             mAudioManager.setStreamVolume(STREAM_MUSIC, 0, 0);             volumeDelta = getVolumeDelta(mAudioManager.getStreamVolume(STREAM_MUSIC));             mAudioManager.adjustVolume(ADJUST_RAISE, 0);             try {                 Thread.sleep(ASYNC_TIMING_TOLERANCE_MS);             } catch (InterruptedException e) {                 e.printStackTrace();             }             assertEquals(Math.min(volumeDelta, maxMusicVolume),                     mAudioManager.getStreamVolume(STREAM_MUSIC));              // adjust volume as ADJUST_LOWER             mAudioManager.setStreamVolume(STREAM_MUSIC, maxMusicVolume, 0);             maxMusicVolume = mAudioManager.getStreamVolume(STREAM_MUSIC);             volumeDelta = getVolumeDelta(mAudioManager.getStreamVolume(STREAM_MUSIC));             mAudioManager.adjustVolume(ADJUST_LOWER, 0);             try {                 Thread.sleep(ASYNC_TIMING_TOLERANCE_MS);             } catch (InterruptedException e) {                 e.printStackTrace();             }             assertEquals(Math.max(0, maxMusicVolume - volumeDelta),                     mAudioManager.getStreamVolume(STREAM_MUSIC));              mp.stop();             mp.release();             try {                 Thread.sleep(TIME_TO_PLAY);             } catch (InterruptedException e) {                 e.printStackTrace();             }             if (!isMusicPlayingBeforeTest) {                 assertFalse(mAudioManager.isMusicActive());             }             status = PASS;         }     }      protected class TestMuteDndAffectedStreamsDndOn extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_mute_dnd_affected_streams);         }          @Override         protected void test() {             if (mSkipRingerTests) {                 status = PASS;                 return;             }             int[] streams = { AudioManager.STREAM_RING };              // Verify streams cannot be unmuted without policy access.             for (int stream : streams) {                 try {                     mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_UNMUTE, 0);                     assertEquals(""Apps without Notification policy access can't change ringer mode"",                             RINGER_MODE_SILENT, mAudioManager.getRingerMode());                 } catch (SecurityException e) {                 }                  try {                     mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_TOGGLE_MUTE,                             0);                     assertEquals(""Apps without Notification policy access can't change ringer mode"",                             RINGER_MODE_SILENT, mAudioManager.getRingerMode());                 } catch (SecurityException e) {                 }                  try {                     mAudioManager.setStreamMute(stream, false);                     assertEquals(""Apps without Notification policy access can't change ringer mode"",                             RINGER_MODE_SILENT, mAudioManager.getRingerMode());                 } catch (SecurityException e) {                 }             }             status = PASS;         }     }      protected class TestMuteStreams extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_mute_dnd_affected_streams);         }          @Override         protected void test() {             if (mSkipRingerTests) {                 status = PASS;                 return;             }             int[] streams = { AudioManager.STREAM_RING };              for (int stream : streams) {                 // ensure each stream is on and turned up.                 mAudioManager.setStreamVolume(stream, mAudioManager.getStreamMaxVolume(stream),0);                  try {                     mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_MUTE, 0);                     assertEquals(""Apps without Notification policy access can't change ringer mode"",                             RINGER_MODE_NORMAL, mAudioManager.getRingerMode());                 } catch (SecurityException e) {                 }                 try {                     mAudioManager.adjustStreamVolume(                             stream, AudioManager.ADJUST_TOGGLE_MUTE, 0);                     assertEquals(""Apps without Notification policy access can't change ringer mode"",                             RINGER_MODE_NORMAL, mAudioManager.getRingerMode());                 } catch (SecurityException e) {                 }                  try {                     mAudioManager.setStreamMute(stream, true);                     assertEquals(""Apps without Notification policy access can't change ringer mode"",                             RINGER_MODE_NORMAL, mAudioManager.getRingerMode());                 } catch (SecurityException e) {                 }                 testStreamMuting(stream);             }              streams = new int[] {                     AudioManager.STREAM_VOICE_CALL,                     AudioManager.STREAM_MUSIC,                     AudioManager.STREAM_ALARM             };              int muteAffectedStreams = Settings.System.getInt(mContext.getContentResolver(),                     Settings.System.MUTE_STREAMS_AFFECTED,                     // same defaults as in AudioService. Should be kept in sync.                     (1 << STREAM_MUSIC) |                             (1 << AudioManager.STREAM_RING) |                             (1 << AudioManager.STREAM_NOTIFICATION) |                             (1 << AudioManager.STREAM_SYSTEM) |                             (1 << AudioManager.STREAM_VOICE_CALL));              for (int stream : streams) {                 // ensure each stream is on and turned up.                 mAudioManager.setStreamVolume(stream, mAudioManager.getStreamMaxVolume(stream), 0);                 if (((1 << stream) & muteAffectedStreams) == 0) {                     if (stream == AudioManager.STREAM_VOICE_CALL) {                         // Voice call requires MODIFY_PHONE_STATE, so we should not be able to mute                         mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_MUTE, 0);                         assertFalse(""Voice call stream ("" + stream + "") should require MODIFY_PHONE_STATE ""                                 + ""to mute."", mAudioManager.isStreamMute(stream));                     } else {                         mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_MUTE, 0);                         assertFalse(""Stream "" + stream + "" should not be affected by mute."",                                 mAudioManager.isStreamMute(stream));                         mAudioManager.setStreamMute(stream, true);                         assertFalse(""Stream "" + stream + "" should not be affected by mute."",                                 mAudioManager.isStreamMute(stream));                         mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_TOGGLE_MUTE,                                 0);                         assertFalse(""Stream "" + stream + "" should not be affected by mute."",                                 mAudioManager.isStreamMute(stream));                         continue;                     }                 }                 testStreamMuting(stream);             }             status = PASS;         }     }      protected class TestAdjustVolumeInPriorityOnlyAllowAlarmsMediaMode extends InteractiveTestCase {         @Override         protected View inflate(ViewGroup parent) {             return createAutoItem(parent, R.string.test_volume_dnd_affected_stream);         }          @Override         protected void test() {             if (mSkipRingerTests) {                 status = PASS;                 return;             }             int musicVolume = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);             mAudioManager.adjustStreamVolume(                     AudioManager.STREAM_MUSIC, AudioManager.ADJUST_RAISE, 0);             int volumeDelta =                     getVolumeDelta(mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC));             assertEquals(musicVolume + volumeDelta,                     mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC));              mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, 3, 0);             assertEquals(3, mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC));              status = PASS;         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.fragment.cts.FragmentTransitionTest"	"getVisibility"	"CtsFragmentTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/fragment/src/android/fragment/cts/FragmentTransitionTest.java"	""	"public void showHideTransition() throws Throwable {         TransitionFragment fragment1 = setupInitialFragment();         TransitionFragment fragment2 = new TransitionFragment();         fragment2.setLayoutId(R.layout.scene2);          final View startBlue = findBlue();         final View startGreen = findGreen();          mFragmentManager.beginTransaction()                 .setReorderingAllowed(mReordered)                 .add(R.id.fragmentContainer, fragment2)                 .hide(fragment1)                 .addToBackStack(null)                 .commit();          FragmentTestUtil.waitForExecution(mActivityRule);         fragment1.waitForTransition();         fragment2.waitForTransition();          final View endGreen = findViewById(fragment2, R.id.greenSquare);         final View endBlue = findViewById(fragment2, R.id.blueSquare);          assertEquals(View.GONE, fragment1.getView().getVisibility());         assertEquals(View.VISIBLE, startGreen.getVisibility());         assertEquals(View.VISIBLE, startBlue.getVisibility());          verifyAndClearTransition(fragment1.exitTransition, null, startGreen, startBlue);         verifyNoOtherTransitions(fragment1);          verifyAndClearTransition(fragment2.enterTransition, null, endGreen, endBlue);         verifyNoOtherTransitions(fragment2);          FragmentTestUtil.popBackStackImmediate(mActivityRule);          FragmentTestUtil.waitForExecution(mActivityRule);         fragment1.waitForTransition();         fragment2.waitForTransition();          verifyAndClearTransition(fragment1.reenterTransition, null, startGreen, startBlue);         verifyNoOtherTransitions(fragment1);          assertEquals(View.VISIBLE, fragment1.getView().getVisibility());         assertEquals(View.VISIBLE, startGreen.getVisibility());         assertEquals(View.VISIBLE, startBlue.getVisibility());          verifyAndClearTransition(fragment2.returnTransition, null, endGreen, endBlue);         verifyNoOtherTransitions(fragment2);     }      // Ensure that transitions are done when a fragment is attached and detached"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.TextViewTest"	"testUndo_imeEmptyBatch"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"public void testUndo_imeEmptyBatch() {         InputConnection input = initTextViewForSimulatedIme();         mTextView.setText(""flower"");          // Send an empty batch edit. This happens if the IME is hidden and shown.         input.beginBatchEdit();         input.endBatchEdit();          // Undo and redo do nothing.         mTextView.onTextContextMenuItem(android.R.id.undo);         assertEquals(""flower"", mTextView.getText().toString());         mTextView.onTextContextMenuItem(android.R.id.redo);         assertEquals(""flower"", mTextView.getText().toString());     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.provider.cts.SettingsPanelTest"	"isCar"	"CtsProviderTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"faketouch"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/provider/src/android/provider/cts/SettingsPanelTest.java"	""	"/*  *.  */  package android.provider.cts;  import static com.google.common.truth.Truth.assertThat; import static org.junit.Assume.assumeFalse; import static org.junit.Assume.assumeTrue;  import android.content.Context; import android.content.Intent; import android.content.pm.PackageManager; import android.provider.Settings; import android.support.test.uiautomator.By; import android.support.test.uiautomator.UiDevice; import android.support.test.uiautomator.UiObject2; import android.support.test.uiautomator.Until;  import com.android.compatibility.common.util.RequiredServiceRule;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.MediumTest; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.Arrays;  /**  * Tests related SettingsPanels:  *  * atest SettingsPanelTest  */ @MediumTest @RunWith(AndroidJUnit4.class) public class SettingsPanelTest {      private static final int TIMEOUT = 8000;      private static final String RESOURCE_DONE = ""done"";     private static final String RESOURCE_SEE_MORE = ""see_more"";     private static final String RESOURCE_TITLE = ""panel_title"";      private String mSettingsPackage;     private String mLauncherPackage;      private Context mContext;     private boolean mHasTouchScreen;     private boolean mHasBluetooth;      private UiDevice mDevice;      @Before     public void setUp() throws Exception {         mContext = InstrumentationRegistry.getTargetContext();         mDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());          final PackageManager packageManager = mContext.getPackageManager();          mHasTouchScreen = packageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)                 || packageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH);         mHasBluetooth = packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH);          Intent launcherIntent = new Intent(Intent.ACTION_MAIN);         launcherIntent.addCategory(Intent.CATEGORY_HOME);         mLauncherPackage = packageManager.resolveActivity(launcherIntent,                 PackageManager.MATCH_DEFAULT_ONLY).activityInfo.packageName;          Intent settingsIntent = new Intent(android.provider.Settings.ACTION_SETTINGS);         mSettingsPackage = packageManager.resolveActivity(settingsIntent,                 PackageManager.MATCH_DEFAULT_ONLY).activityInfo.packageName;          assumeFalse(""Skipping test: Auto does not support provider android.settings.panel"", isCar());         assumeFalse(             ""Skipping test: Watch does not support provider android.settings.panel"", isWatch());     }      @After     public void cleanUp() {         mDevice.pressHome();         mDevice.wait(Until.hasObject(By.pkg(mLauncherPackage).depth(0)), TIMEOUT);     }      // Check correct package is opened"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.devicepolicy.LauncherAppsProfileTest"	"testProfileOwnerAppHiddenInPrimaryProfile"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsProfileTest.java"	""	"public void testProfileOwnerAppHiddenInPrimaryProfile() throws Exception {         if (!mHasFeature) {             return;         }         String command = ""pm disable --user "" + mParentUserId + "" "" + MANAGED_PROFILE_PKG                 + ""/.PrimaryUserFilterSetterActivity"";         CLog.d(""Output for command "" + command + "": "" + getDevice().executeShellCommand(command));         runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,                 LAUNCHER_TESTS_CLASS, ""testProfileOwnerInjectedActivityNotFound"",                 mParentUserId, Collections.singletonMap(PARAM_TEST_USER, mMainUserSerialNumber));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.devicepolicy.LauncherAppsProfileTest"	"testNoHiddenActivityInProfile"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsProfileTest.java"	""	"public void testNoHiddenActivityInProfile() throws Exception {         if (!mHasFeature) {             return;         }         // Install app for all users.         installAppAsUser(LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK, mParentUserId);         installAppAsUser(LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK, mProfileUserId);          // Run tests to check SimpleApp exists in both profile and main user.         runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,                 LAUNCHER_TESTS_CLASS, ""testDoPoNoTestAppInjectedActivityFound"",                 mParentUserId, Collections.singletonMap(PARAM_TEST_USER, mProfileSerialNumber));         runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,                 LAUNCHER_TESTS_CLASS, ""testHasLauncherActivityAppHasAppDetailsActivityInjected"",                 mParentUserId, Collections.singletonMap(PARAM_TEST_USER, mMainUserSerialNumber));     }      @FlakyTest"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.car.cts.CarBluetoothTest"	"disable"	"CtsCarTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/car/src/android/car/cts/CarBluetoothTest.java"	""	"/*  *.  */  package android.car.cts;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.bluetooth.BluetoothAdapter; import android.bluetooth.BluetoothManager; import android.bluetooth.BluetoothProfile; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.content.pm.PackageManager; import android.platform.test.annotations.RequiresDevice; import android.test.suitebuilder.annotation.SmallTest; import android.util.Log; import android.util.SparseArray; import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4; import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.FeatureUtil; import com.android.compatibility.common.util.RequiredFeatureRule; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; import org.junit.After; import org.junit.Before; import org.junit.ClassRule; import org.junit.Test; import org.junit.runner.RunWith;  /**  * Contains the tests to prove compliance with android automotive specific bluetooth requirements.  */ // TODO(b/146663105): Fix hidden API //@SmallTest //@RequiresDevice //@RunWith(AndroidJUnit4.class) public class CarBluetoothTest {     @ClassRule     public static final RequiredFeatureRule sRequiredFeatureRule = new RequiredFeatureRule(             PackageManager.FEATURE_AUTOMOTIVE);      private static final String TAG = ""CarBluetoothTest"";     private static final boolean DBG = false;     private Context mContext;      // Bluetooth Core objects     private BluetoothManager mBluetoothManager;     private BluetoothAdapter mBluetoothAdapter;      // Timeout for waiting for an adapter state change     private static final int BT_ADAPTER_TIMEOUT_MS = 8000; // ms      // Objects to block until the adapter has reached a desired state     private ReentrantLock mBluetoothAdapterLock;     private Condition mConditionAdapterStateReached;     private int mDesiredState;     private int mOriginalState;      /**      * Handles BluetoothAdapter state changes and signals when we've reached a desired state      */     private class BluetoothAdapterReceiver extends BroadcastReceiver {         @Override         public void onReceive(Context context, Intent intent) {              // Decode the intent             String action = intent.getAction();              // Watch for BluetoothAdapter intents only             if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(action)) {                 int newState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1);                 if (DBG) {                     Log.d(TAG, ""Bluetooth adapter state changed: "" + newState);                 }                  // Signal if the state is set to the one we're waiting on. If its not and we got a                 // STATE_OFF event then handle the unexpected off event. Note that we could                 // proactively turn the adapter back on to continue testing. For now we'll just                 // log it                 mBluetoothAdapterLock.lock();                 try {                     if (mDesiredState == newState) {                         mConditionAdapterStateReached.signal();                     } else if (newState == BluetoothAdapter.STATE_OFF) {                         Log.w(TAG, ""Bluetooth turned off unexpectedly while test was running."");                     }                 } finally {                     mBluetoothAdapterLock.unlock();                 }             }         }     }     private BluetoothAdapterReceiver mBluetoothAdapterReceiver;      private void waitForAdapterOn() {         if (DBG) {             Log.d(TAG, ""Waiting for adapter to be on..."");         }         waitForAdapterState(BluetoothAdapter.STATE_ON);     }      private void waitForAdapterOff() {         if (DBG) {             Log.d(TAG, ""Waiting for adapter to be off..."");         }         waitForAdapterState(BluetoothAdapter.STATE_OFF);     }      // Wait for the bluetooth adapter to be in a given state     private void waitForAdapterState(int desiredState) {         if (DBG) {             Log.d(TAG, ""Waiting for adapter state "" + desiredState);         }         mBluetoothAdapterLock.lock();         try {             // Update the desired state so that we'll signal when we get there             mDesiredState = desiredState;             if (desiredState == BluetoothAdapter.STATE_ON) {                 mBluetoothAdapter.enable();             } else {                 mBluetoothAdapter.disable();             }              // Wait until we're reached that desired state             while (desiredState != mBluetoothAdapter.getState()) {                 if (!mConditionAdapterStateReached.await(                     BT_ADAPTER_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {                     Log.e(TAG, ""Timeout while waiting for Bluetooth adapter state "" + desiredState);                     break;                 }             }         } catch (InterruptedException e) {             Log.w(TAG, ""waitForAdapterState("" + desiredState + ""): interrupted"", e);         } finally {             mBluetoothAdapterLock.unlock();         }     }      // Utility class to hold profile information and state     private static class ProfileInfo {         final String mName;         boolean mConnected;          public ProfileInfo(String name) {             mName = name;             mConnected = false;         }     } // TODO(b/146663105): Fix hidden API /*     // Automotive required profiles and meta data. Profile defaults to 'not connected' and name     // is used in debug and error messages     private static SparseArray<ProfileInfo> sRequiredBluetoothProfiles = new SparseArray();     static {         sRequiredBluetoothProfiles.put(BluetoothProfile.A2DP_SINK,                 new ProfileInfo(""A2DP Sink"")); // 11         sRequiredBluetoothProfiles.put(BluetoothProfile.AVRCP_CONTROLLER,                 new ProfileInfo(""AVRCP Controller"")); // 12         sRequiredBluetoothProfiles.put(BluetoothProfile.HEADSET_CLIENT,                 new ProfileInfo(""HSP Client"")); // 16         sRequiredBluetoothProfiles.put(BluetoothProfile.PBAP_CLIENT,                 new ProfileInfo(""PBAP Client"")); // 17     }     private static final int MAX_PROFILES_SUPPORTED = sRequiredBluetoothProfiles.size();      // Configurable timeout for waiting for profile proxies to connect     private static final int PROXY_CONNECTIONS_TIMEOUT_MS = 1000; // ms      // Objects to block until all profile proxy connections have finished, or the timeout occurs     private Condition mConditionAllProfilesConnected;     private ReentrantLock mProfileConnectedLock;     private int mProfilesSupported;      // Capture profile proxy connection events     private final class ProfileServiceListener implements BluetoothProfile.ServiceListener {         @Override         public void onServiceConnected(int profile, BluetoothProfile proxy) {             if (DBG) {                 Log.d(TAG, ""Profile '"" + profile + ""' has connected"");             }             mProfileConnectedLock.lock();             try {                 sRequiredBluetoothProfiles.get(profile).mConnected = true;                 mProfilesSupported++;                 if (mProfilesSupported == MAX_PROFILES_SUPPORTED) {                     mConditionAllProfilesConnected.signal();                 }             } finally {                 mProfileConnectedLock.unlock();             }         }          @Override         public void onServiceDisconnected(int profile) {             if (DBG) {                 Log.d(TAG, ""Profile '"" + profile + ""' has disconnected"");             }             mProfileConnectedLock.lock();             try {                 sRequiredBluetoothProfiles.get(profile).mConnected = false;                 mProfilesSupported--;             } finally {                 mProfileConnectedLock.unlock();             }         }     }      // Initiate connections to all profiles and wait until we connect to all, or time out     private void waitForProfileConnections() {         if (DBG) {             Log.d(TAG, ""Starting profile proxy connections..."");         }         mProfileConnectedLock.lock();         try {             // Attempt connection to each required profile             for (int i = 0; i < sRequiredBluetoothProfiles.size(); i++) {                 int profile = sRequiredBluetoothProfiles.keyAt(i);                 mBluetoothAdapter.getProfileProxy(mContext, new ProfileServiceListener(), profile);             }              // Wait for the Adapter to be disabled             while (mProfilesSupported != MAX_PROFILES_SUPPORTED) {                 if (!mConditionAllProfilesConnected.await(                     PROXY_CONNECTIONS_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {                     Log.e(TAG, ""Timeout while waiting for Profile Connections"");                     break;                 }             }         } catch (InterruptedException e) {             Log.w(TAG, ""waitForProfileConnections: interrupted"", e);         } finally {             mProfileConnectedLock.unlock();         }          if (DBG) {             Log.d(TAG, ""Proxy connection attempts complete. Connected "" + mProfilesSupported                     + ""/"" + MAX_PROFILES_SUPPORTED + "" profiles"");         }     }      // Check and make sure each profile is connected. If any are not supported then build an     // error string to report each missing profile and assert a failure     private void checkProfileConnections() {         if (DBG) {             Log.d(TAG, ""Checking for all required profiles"");         }         mProfileConnectedLock.lock();         try {             if (mProfilesSupported != MAX_PROFILES_SUPPORTED) {                 if (DBG) {                     Log.d(TAG, ""Some profiles failed to connect"");                 }                 StringBuilder e = new StringBuilder();                 for (int i = 0; i < sRequiredBluetoothProfiles.size(); i++) {                     int profile = sRequiredBluetoothProfiles.keyAt(i);                     String name = sRequiredBluetoothProfiles.get(profile).mName;                     if (!sRequiredBluetoothProfiles.get(profile).mConnected) {                         if (e.length() == 0) {                             e.append(""Missing Profiles: "");                         } else {                             e.append("", "");                         }                         e.append(name + "" ("" + profile + "")"");                          if (DBG) {                             Log.d(TAG, name + "" failed to connect"");                         }                     }                 }                 fail(e.toString());             }         } finally {             mProfileConnectedLock.unlock();         }     }      // Set the connection status for each profile to false     private void clearProfileStatuses() {         if (DBG) {             Log.d(TAG, ""Setting all profiles to 'disconnected'"");         }         for (int i = 0; i < sRequiredBluetoothProfiles.size(); i++) {             int profile = sRequiredBluetoothProfiles.keyAt(i);             sRequiredBluetoothProfiles.get(profile).mConnected = false;         }     }      @Before     public void setUp() throws Exception {         if (DBG) {             Log.d(TAG, ""Setting up Automotive Bluetooth test. Device is ""                     + (FeatureUtil.isAutomotive() ? """" : ""not "") + ""automotive"");         }          // Get the context         mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();          // Get bluetooth core objects so we can get proxies/check for profile existence         mBluetoothManager = (BluetoothManager) mContext.getSystemService(                 Context.BLUETOOTH_SERVICE);         mBluetoothAdapter = mBluetoothManager.getAdapter();          // Initialize all the profile connection variables         mProfilesSupported = 0;         mProfileConnectedLock = new ReentrantLock();         mConditionAllProfilesConnected = mProfileConnectedLock.newCondition();         clearProfileStatuses();          // Register the adapter receiver and initialize adapter state wait objects         mDesiredState = -1; // Set and checked by waitForAdapterState()         mBluetoothAdapterLock = new ReentrantLock();         mConditionAdapterStateReached = mBluetoothAdapterLock.newCondition();         mBluetoothAdapterReceiver = new BluetoothAdapterReceiver();         IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);         mContext.registerReceiver(mBluetoothAdapterReceiver, filter);          // Make sure Bluetooth is enabled before the test         waitForAdapterOn();         assertTrue(mBluetoothAdapter.isEnabled());     }      @After     public void tearDown() {         waitForAdapterOff();         mContext.unregisterReceiver(mBluetoothAdapterReceiver);     }      // [A-0-2] : Android Automotive devices must support the following Bluetooth profiles:     //  * Hands Free Profile (HFP) [Phone calling]     //  * Audio Distribution Profile (A2DP) [Media playback]     //  * Audio/Video Remote Control Profile (AVRCP) [Media playback control]     //  * Phone Book Access Profile (PBAP) [Contact sharing/receiving]     //     // This test fires off connections to each required profile (which are asynchronous in nature)     // and waits for all of them to connect (proving they are there and implemented), or for the     // configured timeout. If all required profiles connect, the test passes."	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.inputmethodservice.cts.hostside.ShellCommandFromAppTest"	"testShellCommandFull"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/ShellCommandFromAppTest.java"	""	"public void testShellCommandFull() throws Exception {         runDeviceTestMethodWithoutHiddenApiCheck(DeviceTestConstants.TEST_SHELL_COMMAND, false);     }      /**      * Make sure      * {@code IInputMethodManager#shellCommand(in, out, err, new String[]{}, null, receiver)}      * returns {@link SecurityException} for instant apps.      */     @AppModeInstant"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.inputmethodservice.cts.hostside.ShellCommandFromAppTest"	"testShellCommandInstant"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/ShellCommandFromAppTest.java"	""	"public void testShellCommandInstant() throws Exception {         runDeviceTestMethodWithoutHiddenApiCheck(DeviceTestConstants.TEST_SHELL_COMMAND, true);     }      /**      * Make sure      * {@code IInputMethodManager#shellCommand(in, out, err, new String[]{""ime""}, null, receiver)}      * returns {@link SecurityException} for full (non-instant) apps.      */     @AppModeFull"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.inputmethodservice.cts.hostside.ShellCommandFromAppTest"	"testShellCommandImeFull"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/ShellCommandFromAppTest.java"	""	"public void testShellCommandImeFull() throws Exception {         runDeviceTestMethodWithoutHiddenApiCheck(DeviceTestConstants.TEST_SHELL_COMMAND_IME, false);     }      /**      * Make sure      * {@code IInputMethodManager#shellCommand(in, out, err, new String[]{""ime""}, null, receiver)}      * returns {@link SecurityException} for instant apps.      */     @AppModeInstant"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.inputmethodservice.cts.hostside.ShellCommandFromAppTest"	"testShellCommandImeInstant"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/ShellCommandFromAppTest.java"	""	"public void testShellCommandImeInstant() throws Exception {         runDeviceTestMethodWithoutHiddenApiCheck(DeviceTestConstants.TEST_SHELL_COMMAND_IME, true);     }      /**      * Make sure      * {@code IInputMethodManager#shellCommand(in, out, err, new String[]{""ime"", ""list""}, null,      * receiver)} returns {@link SecurityException} for full (non-instant) apps.      */     @AppModeFull"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.inputmethodservice.cts.hostside.ShellCommandFromAppTest"	"testShellCommandImeListFull"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/ShellCommandFromAppTest.java"	""	"public void testShellCommandImeListFull() throws Exception {         runDeviceTestMethodWithoutHiddenApiCheck(DeviceTestConstants.TEST_SHELL_COMMAND_IME_LIST,                 false);     }      /**      * Make sure      * {@code IInputMethodManager#shellCommand(in, out, err, new String[]{""ime"", ""list""}, null,      * receiver)} returns {@link SecurityException} for instant apps.      */     @AppModeInstant"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.inputmethodservice.cts.hostside.ShellCommandFromAppTest"	"testShellCommandImeListInstant"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/ShellCommandFromAppTest.java"	""	"public void testShellCommandImeListInstant() throws Exception {         runDeviceTestMethodWithoutHiddenApiCheck(DeviceTestConstants.TEST_SHELL_COMMAND_IME_LIST,                 true);     }      /**      * Make sure      * {@code IInputMethodManager#shellCommand(in, out, err, new String[]{""ime"", ""list""}, null,      * receiver)} returns {@link SecurityException} for full (non-instant) apps.      */     @AppModeFull"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.inputmethodservice.cts.hostside.ShellCommandFromAppTest"	"testShellCommandDumpFull"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/ShellCommandFromAppTest.java"	""	"public void testShellCommandDumpFull() throws Exception {         runDeviceTestMethodWithoutHiddenApiCheck(DeviceTestConstants.TEST_SHELL_COMMAND_DUMP,                 false);     }      /**      * Make sure      * {@code IInputMethodManager#shellCommand(in, out, err, new String[]{""ime"", ""list""}, null,      * receiver)} returns {@link SecurityException} for instant apps.      */     @AppModeInstant"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.inputmethodservice.cts.hostside.ShellCommandFromAppTest"	"testShellCommandDumpInstant"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/ShellCommandFromAppTest.java"	""	"public void testShellCommandDumpInstant() throws Exception {         runDeviceTestMethodWithoutHiddenApiCheck(DeviceTestConstants.TEST_SHELL_COMMAND_DUMP, true);     }      /**      * Make sure      * {@code IInputMethodManager#shellCommand(in, out, err, new String[]{""ime"", ""list""}, null,      * receiver)} returns {@link SecurityException} for full (non-instant) apps.      */     @AppModeFull"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.inputmethodservice.cts.hostside.ShellCommandFromAppTest"	"testShellCommandHelpFull"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/ShellCommandFromAppTest.java"	""	"public void testShellCommandHelpFull() throws Exception {         runDeviceTestMethodWithoutHiddenApiCheck(DeviceTestConstants.TEST_SHELL_COMMAND_HELP,                 false);     }      /**      * Make sure      * {@code IInputMethodManager#shellCommand(in, out, err, new String[]{""ime"", ""list""}, null,      * receiver)} returns {@link SecurityException} for instant apps.      */     @AppModeInstant"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.inputmethodservice.cts.hostside.ShellCommandFromAppTest"	"testShellCommandHelpInstant"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/ShellCommandFromAppTest.java"	""	"public void testShellCommandHelpInstant() throws Exception {         runDeviceTestMethodWithoutHiddenApiCheck(DeviceTestConstants.TEST_SHELL_COMMAND_HELP, true);     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.inline.InlineLoginActivityTest"	"testAutofill_selectDatasetThenHideInlineSuggestion"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/InlineLoginActivityTest.java"	""	"public void testAutofill_selectDatasetThenHideInlineSuggestion() throws Exception {         // Set service.         enableService();          final CannedFillResponse.Builder builder = new CannedFillResponse.Builder()                 .addDataset(new CannedFillResponse.CannedDataset.Builder()                         .setField(ID_USERNAME, ""dude"")                         .setPresentation(createPresentation(""The Username""))                         .setInlinePresentation(createInlinePresentation(""The Username""))                         .build());          sReplier.addResponse(builder.build());         mActivity.expectAutoFill(""dude"");          // Trigger auto-fill.         mUiBot.selectByRelativeId(ID_USERNAME);         mUiBot.waitForIdleSync();          mUiBot.assertDatasets(""The Username"");          mUiBot.selectDataset(""The Username"");         mUiBot.waitForIdleSync();          mUiBot.assertNoDatasets();          // Make sure input was sanitized.         final InstrumentedAutoFillService.FillRequest request = sReplier.getNextFillRequest();         assertWithMessage(""CancelationSignal is null"").that(request.cancellationSignal).isNotNull();         assertTextIsSanitized(request.structure, ID_PASSWORD);         final FillContext fillContext = request.contexts.get(request.contexts.size() - 1);         assertThat(fillContext.getFocusedId())                 .isEqualTo(findAutofillIdByResourceId(fillContext, ID_USERNAME));          // Make sure initial focus was properly set.         assertWithMessage(""Username node is not focused"").that(                 findNodeByResourceId(request.structure, ID_USERNAME).isFocused()).isTrue();         assertWithMessage(""Password node is focused"").that(                 findNodeByResourceId(request.structure, ID_PASSWORD).isFocused()).isFalse();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.DatasetFilteringTest"	"testFilter"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/DatasetFilteringTest.java"	""	"public void testFilter() throws Exception {         final String aa = ""Two A's"";         final String ab = ""A and B"";         final String b = ""Only B"";          enableService();          // Set expectations.         sReplier.addResponse(new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""aa"")                         .setPresentation(aa, isInlineMode())                         .build())                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""ab"")                         .setPresentation(ab, isInlineMode())                         .build())                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""b"")                         .setPresentation(b, isInlineMode())                         .build())                 .build());          // Trigger auto-fill.         mUiBot.selectByRelativeId(ID_USERNAME);         mUiBot.waitForIdle();         sReplier.getNextFillRequest();          // With no filter text all datasets should be shown         mUiBot.assertDatasets(aa, ab, b);          // Only two datasets start with 'a'         changeUsername(""a"");         mUiBot.assertDatasets(aa, ab);          // Only one dataset start with 'aa'         changeUsername(""aa"");         mUiBot.assertDatasets(aa);          // No dataset start with 'aaa'         final MyAutofillCallback callback = mActivity.registerCallback();         changeUsername(""aaa"");         callback.assertUiHiddenEvent(mActivity.getUsername());         mUiBot.assertNoDatasets();          // Delete some text to bring back 2 datasets         changeUsername(""a"");         mUiBot.assertDatasets(aa, ab);          // With no filter text all datasets should be shown again         changeUsername("""");         mUiBot.assertDatasets(aa, ab, b);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.DatasetFilteringTest"	"testFilter_injectingEvents"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/DatasetFilteringTest.java"	""	"public void testFilter_injectingEvents() throws Exception {         final String aa = ""Two A's"";         final String ab = ""A and B"";         final String b = ""Only B"";          enableService();          // Set expectations.         sReplier.addResponse(new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""aa"")                         .setPresentation(aa, isInlineMode())                         .build())                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""ab"")                         .setPresentation(ab, isInlineMode())                         .build())                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""b"")                         .setPresentation(b, isInlineMode())                         .build())                 .build());          // Trigger auto-fill.         mUiBot.selectByRelativeId(ID_USERNAME);         mUiBot.waitForIdle();         sReplier.getNextFillRequest();          // With no filter text all datasets should be shown         mUiBot.assertDatasets(aa, ab, b);          // Only two datasets start with 'a'         sendKeyEvent(""KEYCODE_A"");         mUiBot.assertDatasets(aa, ab);          // Only one dataset start with 'aa'         sendKeyEvent(""KEYCODE_A"");         mUiBot.assertDatasets(aa);          // Only two datasets start with 'a'         sendKeyEvent(""KEYCODE_DEL"");         mUiBot.assertDatasets(aa, ab);          // With no filter text all datasets should be shown         sendKeyEvent(""KEYCODE_DEL"");         mUiBot.assertDatasets(aa, ab, b);          // No dataset start with 'aaa'         final MyAutofillCallback callback = mActivity.registerCallback();         sendKeyEvent(""KEYCODE_A"");         sendKeyEvent(""KEYCODE_A"");         sendKeyEvent(""KEYCODE_A"");         callback.assertUiHiddenEvent(mActivity.getUsername());         mUiBot.assertNoDatasets();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.DatasetFilteringTest"	"testFilter_usingKeyboard"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/DatasetFilteringTest.java"	""	"public void testFilter_usingKeyboard() throws Exception {         final MockImeSession mockImeSession = sMockImeSessionRule.getMockImeSession();         assumeTrue(""MockIME not available"", mockImeSession != null);          final String aa = ""Two A's"";         final String ab = ""A and B"";         final String b = ""Only B"";          enableService();          // Set expectations.         sReplier.addResponse(new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""aa"")                         .setPresentation(aa, isInlineMode())                         .build())                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""ab"")                         .setPresentation(ab, isInlineMode())                         .build())                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""b"")                         .setPresentation(b, isInlineMode())                         .build())                 .build());          final ImeEventStream stream = mockImeSession.openEventStream();          // Trigger auto-fill.         mUiBot.selectByRelativeId(ID_USERNAME);         mUiBot.waitForIdle();          // Wait until the MockIme gets bound to the TestActivity.         expectBindInput(stream, Process.myPid(), MOCK_IME_TIMEOUT_MS);         expectEvent(stream, editorMatcher(""onStartInput"", mActivity.getUsername().getId()),                 MOCK_IME_TIMEOUT_MS);          sReplier.getNextFillRequest();          // With no filter text all datasets should be shown         mUiBot.assertDatasets(aa, ab, b);          // Only two datasets start with 'a'         final ImeCommand cmd1 = mockImeSession.callCommitText(""a"", 1);         expectCommand(stream, cmd1, MOCK_IME_TIMEOUT_MS);         mUiBot.assertDatasets(aa, ab);          // Only one dataset start with 'aa'         final ImeCommand cmd2 = mockImeSession.callCommitText(""a"", 1);         expectCommand(stream, cmd2, MOCK_IME_TIMEOUT_MS);         mUiBot.assertDatasets(aa);          // Only two datasets start with 'a'         final ImeCommand cmd3 = mockImeSession.callSendDownUpKeyEvents(KeyEvent.KEYCODE_DEL);         expectCommand(stream, cmd3, MOCK_IME_TIMEOUT_MS);         mUiBot.assertDatasets(aa, ab);          // With no filter text all datasets should be shown         final ImeCommand cmd4 = mockImeSession.callSendDownUpKeyEvents(KeyEvent.KEYCODE_DEL);         expectCommand(stream, cmd4, MOCK_IME_TIMEOUT_MS);         mUiBot.assertDatasets(aa, ab, b);          // No dataset start with 'aaa'         final MyAutofillCallback callback = mActivity.registerCallback();         final ImeCommand cmd5 = mockImeSession.callCommitText(""aaa"", 1);         expectCommand(stream, cmd5, MOCK_IME_TIMEOUT_MS);         callback.assertUiHiddenEvent(mActivity.getUsername());         mUiBot.assertNoDatasets();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.DatasetFilteringTest"	"testFilter"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/DatasetFilteringTest.java"	""	"@AppModeFull(reason = ""testFilter() is enough"")     public void testFilter_usingRegex() throws Exception {         // Dataset presentations.         final String aa = ""Two A's"";         final String ab = ""A and B"";         final String b = ""Only B"";          enableService();          // Set expectations.         sReplier.addResponse(new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""whatever"", Pattern.compile(""a|aa""))                         .setPresentation(aa, isInlineMode())                         .build())                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""whatsoever"",                                 Pattern.compile(""a|ab""))                         .setPresentation(ab, isInlineMode())                         .build())                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, (String) null, Pattern.compile(""b""))                         .setPresentation(b, isInlineMode())                         .build())                 .build());          // Trigger auto-fill.         mUiBot.selectByRelativeId(ID_USERNAME);         mUiBot.waitForIdle();         sReplier.getNextFillRequest();          // With no filter text all datasets should be shown         mUiBot.assertDatasets(aa, ab, b);          // Only two datasets start with 'a'         changeUsername(""a"");         mUiBot.assertDatasets(aa, ab);          // Only one dataset start with 'aa'         changeUsername(""aa"");         mUiBot.assertDatasets(aa);          // Only two datasets start with 'a'         changeUsername(""a"");         mUiBot.assertDatasets(aa, ab);          // With no filter text all datasets should be shown         changeUsername("""");         mUiBot.assertDatasets(aa, ab, b);          // No dataset start with 'aaa'         final MyAutofillCallback callback = mActivity.registerCallback();         changeUsername(""aaa"");         callback.assertUiHiddenEvent(mActivity.getUsername());         mUiBot.assertNoDatasets();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.DatasetFilteringTest"	"testFilter"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/DatasetFilteringTest.java"	""	"@AppModeFull(reason = ""testFilter() is enough"")     public void testFilter_disabledUsingNullRegex() throws Exception {         // Dataset presentations.         final String unfilterable = ""Unfilterabled"";         final String aOrW = ""A or W"";         final String w = ""Wazzup"";          enableService();          // Set expectations.         sReplier.addResponse(new CannedFillResponse.Builder()                 // This dataset has a value but filter is disabled                 .addDataset(new CannedDataset.Builder()                         .setUnfilterableField(ID_USERNAME, ""a am I"")                         .setPresentation(unfilterable, isInlineMode())                         .build())                 // This dataset uses pattern to filter                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""whatsoever"",                                 Pattern.compile(""a|aw""))                         .setPresentation(aOrW, isInlineMode())                         .build())                 // This dataset uses value to filter                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""wazzup"")                         .setPresentation(w, isInlineMode())                         .build())                 .build());          // Trigger auto-fill.         mUiBot.selectByRelativeId(ID_USERNAME);         mUiBot.waitForIdle();         sReplier.getNextFillRequest();          // With no filter text all datasets should be shown         mUiBot.assertDatasets(unfilterable, aOrW, w);          // Only one dataset start with 'a'         changeUsername(""a"");         mUiBot.assertDatasets(aOrW);          // No dataset starts with 'aa'         changeUsername(""aa"");         mUiBot.assertNoDatasets();          // Only one datasets start with 'a'         changeUsername(""a"");         mUiBot.assertDatasets(aOrW);          // With no filter text all datasets should be shown         changeUsername("""");         mUiBot.assertDatasets(unfilterable, aOrW, w);          // Only one datasets start with 'w'         changeUsername(""w"");         if (!isInlineMode()) { // With inline, we don't show the datasets now to protect privacy.             mUiBot.assertDatasets(w);         }          // No dataset start with 'aaa'         final MyAutofillCallback callback = mActivity.registerCallback();         changeUsername(""aaa"");         callback.assertUiHiddenEvent(mActivity.getUsername());         mUiBot.assertNoDatasets();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.DatasetFilteringTest"	"testFilter"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/DatasetFilteringTest.java"	""	"@AppModeFull(reason = ""testFilter() is enough"")     public void testFilter_resetFilter_chooseThird() throws Exception {         resetFilterTest(3);     }      // Tests that datasets are re-shown and filtering still works after clearing a selected value.     private void resetFilterTest(int number) throws Exception {         final String aa = ""Two A's"";         final String ab = ""A and B"";         final String b = ""Only B"";          enableService();          // Set expectations.         sReplier.addResponse(new CannedFillResponse.Builder()                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""aa"")                         .setPresentation(aa, isInlineMode())                         .build())                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""ab"")                         .setPresentation(ab, isInlineMode())                         .build())                 .addDataset(new CannedDataset.Builder()                         .setField(ID_USERNAME, ""b"")                         .setPresentation(b, isInlineMode())                         .build())                 .build());          final String chosenOne;         switch (number) {             case 1:                 chosenOne = aa;                 mActivity.expectAutoFill(""aa"");                 break;             case 2:                 chosenOne = ab;                 mActivity.expectAutoFill(""ab"");                 break;             case 3:                 chosenOne = b;                 mActivity.expectAutoFill(""b"");                 break;             default:                 throw new IllegalArgumentException(""invalid dataset number: "" + number);         }          final MyAutofillCallback callback = mActivity.registerCallback();         final EditText username = mActivity.getUsername();          // Trigger auto-fill.         mUiBot.selectByRelativeId(ID_USERNAME);         callback.assertUiShownEvent(username);          sReplier.getNextFillRequest();          // With no filter text all datasets should be shown         mUiBot.assertDatasets(aa, ab, b);          // select the choice         mUiBot.selectDataset(chosenOne);         callback.assertUiHiddenEvent(username);         mUiBot.assertNoDatasets();          // Check the results.         mActivity.assertAutoFilled();          // Change the filled text and check that filtering still works.         changeUsername(""a"");         mUiBot.assertDatasets(aa, ab);          // Reset back to all choices         changeUsername("""");         mUiBot.assertDatasets(aa, ab, b);     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.deviceandprofileowner.ApplicationHiddenParentTest"	"isNotNull"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationHiddenParentTest.java"	""	"public void test/*  *.  */  package com.android.cts.deviceandprofileowner;  import static com.google.common.truth.Truth.assertThat;  import static org.testng.Assert.assertThrows;  import android.app.admin.DevicePolicyManager; import android.content.pm.PackageManager;  public class ApplicationHiddenParentTest extends BaseDeviceAdminTest {      private DevicePolicyManager mParentDevicePolicyManager;     private PackageManager mPackageManager;      private static final String SYSTEM_PACKAGE_TO_HIDE = ""com.android.keychain"";     private static final String NON_SYSTEM_NON_INSTALLED_PACKAGE = ""com.android.cts.permissionapp"";     private static final String NON_SYSTEM_INSTALLED_PACKAGE =             ""com.android.cts.deviceandprofileowner"";      @Override     protected void setUp() throws Exception {         super.setUp();         mParentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         mPackageManager = mContext.getPackageManager();         assertThat(mParentDevicePolicyManager).isNotNull();          assertThat(mDevicePolicyManager.isProfileOwnerApp(ADMIN_RECEIVER_COMPONENT.getPackageName())).isTrue();         assertThat(mDevicePolicyManager.isOrganizationOwnedDeviceWithManagedProfile()).isTrue();     }      @Override     protected void tearDown() throws Exception {         mParentDevicePolicyManager.setApplicationHidden(ADMIN_RECEIVER_COMPONENT,                 SYSTEM_PACKAGE_TO_HIDE, false);         super.tearDown();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.deviceandprofileowner.ApplicationHiddenParentTest"	"testSetApplicationHidden_systemPackage"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationHiddenParentTest.java"	""	"public void testSetApplicationHidden_systemPackage()             throws PackageManager.NameNotFoundException {         assertThat(mPackageManager.getPackageInfo(SYSTEM_PACKAGE_TO_HIDE, 0)).isNotNull();          assertThat(mParentDevicePolicyManager.setApplicationHidden(ADMIN_RECEIVER_COMPONENT,                 SYSTEM_PACKAGE_TO_HIDE, true)).isTrue();         assertThat(mParentDevicePolicyManager.isApplicationHidden(ADMIN_RECEIVER_COMPONENT,                 SYSTEM_PACKAGE_TO_HIDE)).isTrue();         assertThat(mPackageManager.getPackageInfo(SYSTEM_PACKAGE_TO_HIDE,                 PackageManager.MATCH_UNINSTALLED_PACKAGES)).isNotNull();          assertThat(mParentDevicePolicyManager.setApplicationHidden(ADMIN_RECEIVER_COMPONENT,                 SYSTEM_PACKAGE_TO_HIDE, false)).isTrue();         assertThat(mParentDevicePolicyManager.isApplicationHidden(ADMIN_RECEIVER_COMPONENT,                 SYSTEM_PACKAGE_TO_HIDE)).isFalse();         assertThat(mPackageManager.getPackageInfo(SYSTEM_PACKAGE_TO_HIDE, 0)).isNotNull();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.deviceandprofileowner.ApplicationHiddenParentTest"	"testSetApplicationHidden_nonSystemPackage"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationHiddenParentTest.java"	""	"public void testSetApplicationHidden_nonSystemPackage() {         assertThrows(IllegalArgumentException.class, () -> {             mParentDevicePolicyManager.setApplicationHidden(ADMIN_RECEIVER_COMPONENT,                     NON_SYSTEM_NON_INSTALLED_PACKAGE, true);             mParentDevicePolicyManager.isApplicationHidden(ADMIN_RECEIVER_COMPONENT,                     NON_SYSTEM_NON_INSTALLED_PACKAGE);         });         assertThrows(IllegalArgumentException.class, () -> {             mParentDevicePolicyManager.setApplicationHidden(ADMIN_RECEIVER_COMPONENT,                     NON_SYSTEM_NON_INSTALLED_PACKAGE, false);             mParentDevicePolicyManager.isApplicationHidden(ADMIN_RECEIVER_COMPONENT,                     NON_SYSTEM_NON_INSTALLED_PACKAGE);         });     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"com.android.cts.deviceandprofileowner.ApplicationHiddenParentTest"	"testSetApplicationHidden_nonSystemPackageStackTrace"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationHiddenParentTest.java"	""	"public void testSetApplicationHidden_nonSystemPackageStackTrace() {         StackTraceElement[] stackTrace1 = new StackTraceElement[0];         StackTraceElement[] stackTrace2 = new StackTraceElement[0];         String message1 = """";         String message2 = """";          // Scenario 1: Non-system non-installed package         try {             mParentDevicePolicyManager.setApplicationHidden(ADMIN_RECEIVER_COMPONENT,                     NON_SYSTEM_NON_INSTALLED_PACKAGE, true);         } catch (IllegalArgumentException e) {             stackTrace1 = e.getStackTrace();             message1 = e.getMessage();         }          // Scenario 2: Non-system installed package         try {             mParentDevicePolicyManager.setApplicationHidden(ADMIN_RECEIVER_COMPONENT,                     NON_SYSTEM_INSTALLED_PACKAGE, true);         } catch (IllegalArgumentException e) {             stackTrace2 = e.getStackTrace();             message2 = e.getMessage();         }          // Ensure the messages and stack traces of both scenarios are equal         assertThat(message1).isEqualTo(message2);         assertThat(stackTrace1.length).isEqualTo(stackTrace2.length);         for (int i = 0; i < stackTrace1.length; i++) {             if (stackTrace1[i].getClassName().equals(this.getClass().getName())) {                 continue;             }             assertThat(stackTrace1[i].toString()).isEqualTo(stackTrace2[i].toString());         }     }  }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.DisplayCutoutTests"	"testDisplayCutout_always"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java"	""	"public void testDisplayCutout_always() {         runTest(LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS, (a, insets, displayCutout, which) -> {             if (which == ROOT) {                 assertThat(""Display.getCutout() must equal view root cutout"",                         a.getDisplay().getCutout(), equalTo(displayCutout));             }         });     }      private void runTest(int cutoutMode, TestDef test) {         runTest(cutoutMode, test, orientation);     }      private void runTest(int cutoutMode, TestDef test, int orientation) {         assumeTrue(""Skipping test: orientation not supported"", supportsOrientation(orientation));         final TestActivity activity = launchAndWait(mDisplayCutoutActivity,                 cutoutMode, orientation);          WindowInsets insets = getOnMainSync(activity::getRootInsets);         WindowInsets dispatchedInsets = getOnMainSync(activity::getDispatchedInsets);         Assert.assertThat(""test setup failed, no insets at root"", insets, notNullValue());         Assert.assertThat(""test setup failed, no insets dispatched"",                 dispatchedInsets, notNullValue());          final DisplayCutout displayCutout = insets.getDisplayCutout();         final DisplayCutout dispatchedDisplayCutout = dispatchedInsets.getDisplayCutout();         if (displayCutout != null) {             commonAsserts(activity, displayCutout);             if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS) {                 shortEdgeAsserts(activity, insets, displayCutout);             }             assertCutoutsAreConsistentWithInsets(activity, displayCutout);             assertSafeInsetsAreConsistentWithDisplayCutoutInsets(insets);         }         test.run(activity, insets, displayCutout, ROOT);          if (dispatchedDisplayCutout != null) {             commonAsserts(activity, dispatchedDisplayCutout);             if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS) {                 shortEdgeAsserts(activity, insets, displayCutout);             }             assertCutoutsAreConsistentWithInsets(activity, dispatchedDisplayCutout);             if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT) {                 assertSafeInsetsAreConsistentWithDisplayCutoutInsets(dispatchedInsets);             }         }         test.run(activity, dispatchedInsets, dispatchedDisplayCutout, DISPATCHED);     }      private void assertSafeInsetsAreConsistentWithDisplayCutoutInsets(WindowInsets insets) {         DisplayCutout cutout = insets.getDisplayCutout();         Insets safeInsets = Insets.of(safeInsets(cutout));         assertEquals(""WindowInsets.getInsets(displayCutout()) must equal""                         + "" DisplayCutout.getSafeInsets()"",                 safeInsets, insets.getInsets(Type.displayCutout()));         assertEquals(""WindowInsets.getInsetsIgnoringVisibility(displayCutout()) must equal""                         + "" DisplayCutout.getSafeInsets()"",                 safeInsets, insets.getInsetsIgnoringVisibility(Type.displayCutout()));     }      private void commonAsserts(TestActivity activity, DisplayCutout cutout) {         assertSafeInsetsValid(cutout);         assertCutoutsAreWithinSafeInsets(activity, cutout);         assertBoundsAreNonEmpty(cutout);         assertAtMostOneCutoutPerEdge(activity, cutout);     }      private void shortEdgeAsserts(             TestActivity activity, WindowInsets insets, DisplayCutout cutout) {         assertOnlyShortEdgeHasInsets(activity, cutout);         assertOnlyShortEdgeHasBounds(activity, cutout);         assertThat(""systemWindowInsets (also known as content insets) must be at least as ""                         + ""large as cutout safe insets"",                 safeInsets(cutout), insetsLessThanOrEqualTo(systemWindowInsets(insets)));     }      private void assertCutoutIsConsistentWithInset(String position, DisplayCutout cutout,             int safeInsetSize, Rect appBound) {         if (safeInsetSize > 0) {             assertThat(""cutout must have a bound on the "" + position,                     hasBound(position, cutout, appBound), is(true));         } else {             assertThat(""cutout  must have no bound on the "" + position,                     hasBound(position, cutout, appBound), is(false));         }     }      public void assertCutoutsAreConsistentWithInsets(TestActivity activity, DisplayCutout cutout) {         final Rect appBounds = getAppBounds(activity);         assertCutoutIsConsistentWithInset(TOP, cutout, cutout.getSafeInsetTop(), appBounds);         assertCutoutIsConsistentWithInset(BOTTOM, cutout, cutout.getSafeInsetBottom(), appBounds);         assertCutoutIsConsistentWithInset(LEFT, cutout, cutout.getSafeInsetLeft(), appBounds);         assertCutoutIsConsistentWithInset(RIGHT, cutout, cutout.getSafeInsetRight(), appBounds);     }      private void assertSafeInsetsValid(DisplayCutout displayCutout) {         //noinspection unchecked         assertThat(""all safe insets must be non-negative"", safeInsets(displayCutout),                 insetValues(everyItem((Matcher)greaterThanOrEqualTo(0))));         assertThat(""at least one safe inset must be positive,""                         + "" otherwise WindowInsets.getDisplayCutout()) must return null"",                 safeInsets(displayCutout), insetValues(hasItem(greaterThan(0))));     }      private void assertCutoutsAreWithinSafeInsets(TestActivity a, DisplayCutout cutout) {         final Rect safeRect = getSafeRect(a, cutout);          assertThat(""safe insets must not cover the entire screen"", safeRect.isEmpty(), is(false));         for (Rect boundingRect : cutout.getBoundingRects()) {             assertThat(""boundingRects must not extend beyond safeInsets"",                     boundingRect, not(intersectsWith(safeRect)));         }     }      private void assertAtMostOneCutoutPerEdge(TestActivity a, DisplayCutout cutout) {         final Rect safeRect = getSafeRect(a, cutout);          assertThat(""must not have more than one left cutout"",                 boundsWith(cutout, (r) -> r.right <= safeRect.left), hasSize(lessThanOrEqualTo(1)));         assertThat(""must not have more than one top cutout"",                 boundsWith(cutout, (r) -> r.bottom <= safeRect.top), hasSize(lessThanOrEqualTo(1)));         assertThat(""must not have more than one right cutout"",                 boundsWith(cutout, (r) -> r.left >= safeRect.right), hasSize(lessThanOrEqualTo(1)));         assertThat(""must not have more than one bottom cutout"",                 boundsWith(cutout, (r) -> r.top >= safeRect.bottom), hasSize(lessThanOrEqualTo(1)));     }      private void assertBoundsAreNonEmpty(DisplayCutout cutout) {         for (Rect boundingRect : cutout.getBoundingRects()) {             assertThat(""rect in boundingRects must not be empty"",                     boundingRect.isEmpty(), is(false));         }     }      private void assertOnlyShortEdgeHasInsets(TestActivity activity,             DisplayCutout displayCutout) {         final Rect appBounds = getAppBounds(activity);         if (appBounds.height() > appBounds.width()) {             // Portrait display             assertThat(""left edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetLeft(), is(0));             assertThat(""right edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetRight(), is(0));         }         if (appBounds.height() < appBounds.width()) {             // Landscape display             assertThat(""top edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetTop(), is(0));             assertThat(""bottom edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetBottom(), is(0));         }     }      private void assertOnlyShortEdgeHasBounds(TestActivity activity, DisplayCutout cutout) {         final Rect appBounds = getAppBounds(activity);         if (appBounds.height() > appBounds.width()) {             // Portrait display             assertThat(""left edge has a cutout despite being long edge"",                     hasBound(LEFT, cutout, appBounds), is(false));              assertThat(""right edge has a cutout despite being long edge"",                     hasBound(RIGHT, cutout, appBounds), is(false));         }         if (appBounds.height() < appBounds.width()) {             // Landscape display             assertThat(""top edge has a cutout despite being long edge"",                     hasBound(TOP, cutout, appBounds), is(false));              assertThat(""bottom edge has a cutout despite being long edge"",                     hasBound(BOTTOM, cutout, appBounds), is(false));         }     }      private boolean hasBound(String position, DisplayCutout cutout, Rect appBound) {         final Rect cutoutRect;         final int waterfallSize;         if (LEFT.equals(position)) {             cutoutRect = cutout.getBoundingRectLeft();             waterfallSize = cutout.getWaterfallInsets().left;         } else if (TOP.equals(position)) {             cutoutRect = cutout.getBoundingRectTop();             waterfallSize = cutout.getWaterfallInsets().top;         } else if (RIGHT.equals(position)) {             cutoutRect = cutout.getBoundingRectRight();             waterfallSize = cutout.getWaterfallInsets().right;         } else {             cutoutRect = cutout.getBoundingRectBottom();             waterfallSize = cutout.getWaterfallInsets().bottom;         }         return Rect.intersects(cutoutRect, appBound) || waterfallSize > 0;     }      private List<Rect> boundsWith(DisplayCutout cutout, Predicate<Rect> predicate) {         return cutout.getBoundingRects().stream().filter(predicate).collect(Collectors.toList());     }      private static Rect safeInsets(DisplayCutout displayCutout) {         if (displayCutout == null) {             return null;         }         return new Rect(displayCutout.getSafeInsetLeft(), displayCutout.getSafeInsetTop(),                 displayCutout.getSafeInsetRight(), displayCutout.getSafeInsetBottom());     }      private static Rect systemWindowInsets(WindowInsets insets) {         return new Rect(insets.getSystemWindowInsetLeft(), insets.getSystemWindowInsetTop(),                 insets.getSystemWindowInsetRight(), insets.getSystemWindowInsetBottom());     }      private static Rect stableInsets(WindowInsets insets) {         return new Rect(insets.getStableInsetLeft(), insets.getStableInsetTop(),                 insets.getStableInsetRight(), insets.getStableInsetBottom());     }      private Rect getSafeRect(TestActivity a, DisplayCutout cutout) {         final Rect safeRect = safeInsets(cutout);         safeRect.bottom = getOnMainSync(() -> a.getDecorView().getHeight()) - safeRect.bottom;         safeRect.right = getOnMainSync(() -> a.getDecorView().getWidth()) - safeRect.right;         return safeRect;     }      private Rect getAppBounds(TestActivity a) {         final Rect appBounds = new Rect();         runOnMainSync(() -> {             appBounds.right = a.getDecorView().getWidth();             appBounds.bottom = a.getDecorView().getHeight();         });         return appBounds;     }      private static Matcher<Rect> insetsLessThanOrEqualTo(Rect max) {         return new CustomTypeSafeMatcher<Rect>(""must be smaller on each side than "" + max) {             @Override             protected boolean matchesSafely(Rect actual) {                 return actual.left <= max.left && actual.top <= max.top                         && actual.right <= max.right && actual.bottom <= max.bottom;             }         };     }      private static Matcher<Rect> intersectsWith(Rect safeRect) {         return new CustomTypeSafeMatcher<Rect>(""intersects with "" + safeRect) {             @Override             protected boolean matchesSafely(Rect item) {                 return Rect.intersects(safeRect, item);             }         };     }      private static Matcher<Rect> insetValues(Matcher<Iterable<? super Integer>> valuesMatcher) {         return new FeatureMatcher<Rect, Iterable<Integer>>(valuesMatcher, ""inset values"",                 ""inset values"") {             @Override             protected Iterable<Integer> featureValueOf(Rect actual) {                 return Arrays.asList(actual.left, actual.top, actual.right, actual.bottom);             }         };     }      private <T> void assertThat(String reason, T actual, Matcher<? super T> matcher) {         mErrorCollector.checkThat(reason, actual, matcher);     }      private <R> R getOnMainSync(Supplier<R> f) {         final Object[] result = new Object[1];         runOnMainSync(() -> result[0] = f.get());         //noinspection unchecked         return (R) result[0];     }      private void runOnMainSync(Runnable runnable) {         getInstrumentation().runOnMainSync(runnable);     }      private <T extends TestActivity> T launchAndWait(ActivityTestRule<T> rule, int cutoutMode,             int orientation) {         final T activity = rule.launchActivity(                 new Intent().putExtra(EXTRA_CUTOUT_MODE, cutoutMode)                         .putExtra(EXTRA_ORIENTATION, orientation));         PollingCheck.waitFor(activity::hasWindowFocus);         PollingCheck.waitFor(() -> {             final Rect appBounds = getAppBounds(activity);             final Point displaySize = new Point();             activity.getDisplay().getRealSize(displaySize);             // During app launch into a different rotation, we have temporarily have the display             // in a different rotation than the app itself. Wait for this to settle.             return (appBounds.width() > appBounds.height()) == (displaySize.x > displaySize.y);         });         return activity;     }      private boolean supportsOrientation(int orientation) {         String systemFeature = """";         switch(orientation) {             case SCREEN_ORIENTATION_PORTRAIT:             case SCREEN_ORIENTATION_REVERSE_PORTRAIT:                 systemFeature = PackageManager.FEATURE_SCREEN_PORTRAIT;                 break;             case SCREEN_ORIENTATION_LANDSCAPE:             case SCREEN_ORIENTATION_REVERSE_LANDSCAPE:                 systemFeature = PackageManager.FEATURE_SCREEN_LANDSCAPE;                 break;             default:                 throw new UnsupportedOperationException(""Orientation not supported"");         }          return getInstrumentation().getTargetContext().getPackageManager()                 .hasSystemFeature(systemFeature);     }      public static class TestActivity extends Activity {          static final String EXTRA_CUTOUT_MODE = ""extra.cutout_mode"";         static final String EXTRA_ORIENTATION = ""extra.orientation"";         private WindowInsets mDispatchedInsets;          @Override         protected void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             getWindow().requestFeature(Window.FEATURE_NO_TITLE);             if (getIntent() != null) {                 getWindow().getAttributes().layoutInDisplayCutoutMode = getIntent().getIntExtra(                         EXTRA_CUTOUT_MODE, LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT);                 setRequestedOrientation(getIntent().getIntExtra(                         EXTRA_ORIENTATION, SCREEN_ORIENTATION_UNSPECIFIED));             }             View view = new View(this);             view.setLayoutParams(new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));             view.setOnApplyWindowInsetsListener((v, insets) -> mDispatchedInsets = insets);             setContentView(view);         }          @Override         public void onWindowFocusChanged(boolean hasFocus) {             if (hasFocus) {                 getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN                         | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION                         | View.SYSTEM_UI_FLAG_FULLSCREEN                         | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);             }         }          View getDecorView() {             return getWindow().getDecorView();         }          WindowInsets getRootInsets() {             return getWindow().getDecorView().getRootWindowInsets();         }          WindowInsets getDispatchedInsets() {             return mDispatchedInsets;         }     }      interface TestDef {         void run(TestActivity a, WindowInsets insets, DisplayCutout cutout, Which whichInsets);          enum Which {             DISPATCHED, ROOT         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.animation.cts.LayoutAnimationTest"	"testSetStagger"	"CtsAnimationTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/animation/src/android/animation/cts/LayoutAnimationTest.java"	""	"public void testSetStagger() {         long duration = 100;         int transitionType = LayoutTransition.CHANGE_APPEARING;         mLayoutTransition.setStagger(transitionType, duration);         assertEquals(duration, mLayoutTransition.getStagger(transitionType));     }      private void setDefaultTransition() {         long duration = 5000;         mView.setLayoutTransition(mLayoutTransition);         mLayoutTransition.setDuration(duration);         mLayoutTransition.setInterpolator(LayoutTransition.APPEARING,                 new AccelerateInterpolator());     }      private void clickButton() throws Throwable {         CountDownLatch startLatch = new CountDownLatch(1);         TransitionListener listener = new TransitionListener() {              @Override             public void startTransition(                     LayoutTransition layoutTransition,                     ViewGroup viewGroup,                     View view,                     int i             ) {                 startLatch.countDown();             }              @Override             public void endTransition(                     LayoutTransition layoutTransition,                     ViewGroup viewGroup,                     View view,                     int i             ) {             }         };         mLayoutTransition.addTransitionListener(listener);         mActivityRule.runOnUiThread(mButton::callOnClick);         InstrumentationRegistry.getInstrumentation().waitForIdleSync();         assertTrue(startLatch.await(5, TimeUnit.SECONDS));     }      class MyTransitionListener implements LayoutTransition.TransitionListener {         ViewGroup mContainer;         View mView;         int mTransitionType;         boolean mTransition = false;         public void endTransition(LayoutTransition transition,                 ViewGroup container, View view, int transitionType) {             this.mContainer = container;             this.mView = view;             this.mTransitionType = transitionType;             mTransition = false;         }          public void startTransition(LayoutTransition transition,                 ViewGroup container, View view, int transitionType) {             this.mContainer = container;             this.mView = view;             this.mTransitionType = transitionType;             mTransition = true;         }     }      class MyLayoutTransition extends LayoutTransition {         boolean mAddChild = false;         boolean mHideChild = false;         boolean mRemoveChild = false;         boolean mShowChild = false;         boolean mSetAnimator = false;         boolean mRemoveListener = false;         boolean isChangingLayout = false;          @Override         public void addChild(ViewGroup parent, View child) {             super.addChild(parent, child);             mAddChild = true;         }          @Override         public void hideChild(ViewGroup parent, View child) {             super.hideChild(parent, child);             mHideChild = true;         }          @Override         public boolean isChangingLayout() {             return super.isChangingLayout();         }          @Override         public boolean isRunning() {             isChangingLayout =  true;             return super.isRunning();         }          @Override         public void removeChild(ViewGroup parent, View child) {             super.removeChild(parent, child);             mRemoveChild = true;         }          @Override         public void removeTransitionListener(TransitionListener listener) {             super.removeTransitionListener(listener);             mRemoveListener = true;         }          @Override         public void setAnimator(int transitionType, Animator animator) {             super.setAnimator(transitionType, animator);             mSetAnimator = true;         }          @Override         public void showChild(ViewGroup parent, View child) {             super.showChild(parent, child);             mShowChild = true;         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.provider.cts.media.MediaStoreUtils"	"testStub"	"CtsProviderTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStoreUtils.java"	""	"public void testStub() {     }      /**      * Create a new pending media item using the given parameters. Pending items      * are expected to have a short lifetime, and owners should either      * {@link PendingSession#publish()} or {@link PendingSession#abandon()} a      * pending item within a few hours after first creating it.      *      * @return token which can be passed to {@link #openPending(Context, Uri)}      *         to work with this pending item.      * @see MediaColumns#IS_PENDING      * @see MediaStore#setIncludePending(Uri)      * @see MediaStore#createPending(Context, PendingParams)      * @removed      */     @Deprecated     public static @NonNull Uri createPending(@NonNull Context context,             @NonNull PendingParams params) {         return context.getContentResolver().insert(params.insertUri, params.insertValues);     }      /**      * Open a pending media item to make progress on it. You can open a pending      * item multiple times before finally calling either      * {@link PendingSession#publish()} or {@link PendingSession#abandon()}.      *      * @param uri token which was previously returned from      *            {@link #createPending(Context, PendingParams)}.      * @removed      */     @Deprecated     public static @NonNull PendingSession openPending(@NonNull Context context, @NonNull Uri uri) {         return new PendingSession(context, uri);     }      /**      * Parameters that describe a pending media item.      *      * @removed      */     @Deprecated     public static class PendingParams {         /** {@hide} */         public final Uri insertUri;         /** {@hide} */         public final ContentValues insertValues;          /**          * Create parameters that describe a pending media item.          *          * @param insertUri the {@code content://} Uri where this pending item          *            should be inserted when finally published. For example, to          *            publish an image, use          *            {@link MediaStore.Images.Media#getContentUri(String)}.          */         public PendingParams(@NonNull Uri insertUri, @NonNull String displayName,                 @NonNull String mimeType) {             this.insertUri = Objects.requireNonNull(insertUri);             final long now = System.currentTimeMillis() / 1000;             this.insertValues = new ContentValues();             this.insertValues.put(MediaColumns.DISPLAY_NAME, Objects.requireNonNull(displayName));             this.insertValues.put(MediaColumns.MIME_TYPE, Objects.requireNonNull(mimeType));             this.insertValues.put(MediaColumns.DATE_ADDED, now);             this.insertValues.put(MediaColumns.DATE_MODIFIED, now);             this.insertValues.put(MediaColumns.IS_PENDING, 1);             this.insertValues.put(MediaColumns.DATE_EXPIRES,                     (System.currentTimeMillis() + DateUtils.DAY_IN_MILLIS) / 1000);         }          public void setPath(@Nullable String path) {             if (path == null) {                 this.insertValues.remove(MediaColumns.RELATIVE_PATH);             } else {                 this.insertValues.put(MediaColumns.RELATIVE_PATH, path);             }         }          /**          * Optionally set the Uri from where the file has been downloaded. This is used          * for files being added to {@link Downloads} table.          *          * @see DownloadColumns#DOWNLOAD_URI          */         public void setDownloadUri(@Nullable Uri downloadUri) {             if (downloadUri == null) {                 this.insertValues.remove(DownloadColumns.DOWNLOAD_URI);             } else {                 this.insertValues.put(DownloadColumns.DOWNLOAD_URI, downloadUri.toString());             }         }          /**          * Optionally set the Uri indicating HTTP referer of the file. This is used for          * files being added to {@link Downloads} table.          *          * @see DownloadColumns#REFERER_URI          */         public void setRefererUri(@Nullable Uri refererUri) {             if (refererUri == null) {                 this.insertValues.remove(DownloadColumns.REFERER_URI);             } else {                 this.insertValues.put(DownloadColumns.REFERER_URI, refererUri.toString());             }         }     }      /**      * Session actively working on a pending media item. Pending items are      * expected to have a short lifetime, and owners should either      * {@link PendingSession#publish()} or {@link PendingSession#abandon()} a      * pending item within a few hours after first creating it.      *      * @removed      */     @Deprecated     public static class PendingSession implements AutoCloseable {         /** {@hide} */         private final Context mContext;         /** {@hide} */         private final Uri mUri;          /** {@hide} */         public PendingSession(Context context, Uri uri) {             mContext = Objects.requireNonNull(context);             mUri = Objects.requireNonNull(uri);         }          /**          * Open the underlying file representing this media item. When a media          * item is successfully completed, you should          * {@link ParcelFileDescriptor#close()} and then {@link #publish()} it.          *          * @see #notifyProgress(int)          */         public @NonNull ParcelFileDescriptor open() throws FileNotFoundException {             return mContext.getContentResolver().openFileDescriptor(mUri, ""rw"");         }          /**          * Open the underlying file representing this media item. When a media          * item is successfully completed, you should          * {@link OutputStream#close()} and then {@link #publish()} it.          *          * @see #notifyProgress(int)          */         public @NonNull OutputStream openOutputStream() throws FileNotFoundException {             return mContext.getContentResolver().openOutputStream(mUri);         }          /**          * When this media item is successfully completed, call this method to          * publish and make the final item visible to the user.          *          * @return the final {@code content://} Uri representing the newly          *         published media.          */         public @NonNull Uri publish() {             final ContentValues values = new ContentValues();             values.put(MediaColumns.IS_PENDING, 0);             values.putNull(MediaColumns.DATE_EXPIRES);             mContext.getContentResolver().update(mUri, values, null, null);             return mUri;         }          /**          * When this media item has failed to be completed, call this method to          * destroy the pending item record and any data related to it.          */         public void abandon() {             mContext.getContentResolver().delete(mUri, null, null);         }          @Override         public void close() {             // No resources to close, but at least we can inform people that no             // progress is being actively made.         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.PopupWindowTest"	"testAccessSoftInputMode"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/PopupWindowTest.java"	""	"public void testAccessSoftInputMode() throws Throwable {         mPopupWindow = createPopupWindow(createPopupContent(CONTENT_SIZE_DP, CONTENT_SIZE_DP));         mActivityRule.runOnUiThread(                 () -> mPopupWindow.setSoftInputMode(                         WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE));          showPopup();         assertEquals(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE,                 mPopupWindow.getSoftInputMode());          dismissPopup();         mActivityRule.runOnUiThread(                 () -> mPopupWindow.setSoftInputMode(                         WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN));         showPopup();         assertEquals(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN,                 mPopupWindow.getSoftInputMode());     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.assist.cts.LifecycleTest"	"testLayerDoesNotTriggerLifecycleMethods"	"CtsAssistTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/assist/src/android/assist/cts/LifecycleTest.java"	""	"public void testLayerDoesNotTriggerLifecycleMethods() throws Exception {         if (!mContext.getPackageManager().hasSystemFeature(FEATURE_VOICE_RECOGNIZERS)) {             Log.d(TAG, ""Not running assist tests - voice_recognizers feature is not supported"");             return;         }         startTest(TEST_CASE_TYPE);         waitForAssistantToBeReady();         start3pApp(TEST_CASE_TYPE);         waitForHasFocus();         final AutoResetLatch latch = startSession();         waitForContext(latch);         // Since there is no UI, focus should not be lost.  We are counting focus lost as         // a lifecycle event in this case.         // Do this after waitForContext(), since we don't start looking for context until         // calling the above (RACY!!!).         waitForLostFocus();         waitAndSeeIfLifecycleMethodsAreTriggered();          Bundle bundle = new Bundle();         bundle.putString(Utils.EXTRA_REMOTE_CALLBACK_ACTION, Utils.HIDE_LIFECYCLE_ACTIVITY);         m3pActivityCallback.sendResult(bundle);          waitForDestroy();     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.assist.cts.LifecycleTest"	"testNoUiLayerDoesNotTriggerLifecycleMethods"	"CtsAssistTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/assist/src/android/assist/cts/LifecycleTest.java"	""	"public void testNoUiLayerDoesNotTriggerLifecycleMethods() throws Exception {         if (mActivityManager.isLowRamDevice()) {             Log.d(TAG, ""Not running assist tests on low-RAM device."");             return;         }         mLostFocusIsLifecycle = true;         startTest(Utils.LIFECYCLE_NOUI);         waitForAssistantToBeReady();         start3pApp(Utils.LIFECYCLE_NOUI);         waitForHasFocus();         final AutoResetLatch latch = startSession();         waitForContext(latch);         // Do this after waitForContext(), since we don't start looking for context until         // calling the above (RACY!!!).         waitAndSeeIfLifecycleMethodsAreTriggered();          Bundle bundle = new Bundle();         bundle.putString(Utils.EXTRA_REMOTE_CALLBACK_ACTION, Utils.HIDE_LIFECYCLE_ACTIVITY);         m3pActivityCallback.sendResult(bundle);          waitForDestroy();     }      private class LifecycleTestReceiver extends ActionLatchReceiver {          @Override         protected void onAction(Bundle bundle, String action) {             if (action.equals(ACTION_HAS_FOCUS) && mHasFocusLatch != null) {                 mHasFocusLatch.countDown();             } else if (action.equals(ACTION_LOST_FOCUS) && mLostFocusLatch != null) {                 if (mLostFocusIsLifecycle) {                     mActivityLifecycleLatch.countDown();                 } else {                     mLostFocusLatch.countDown();                 }             } else if (action.equals(ACTION_ON_PAUSE) && mActivityLifecycleLatch != null) {                 mActivityLifecycleLatch.countDown();             } else if (action.equals(ACTION_ON_STOP) && mActivityLifecycleLatch != null) {                 mActivityLifecycleLatch.countDown();             } else if (action.equals(ACTION_ON_DESTROY) && mActivityLifecycleLatch != null) {                 mActivityLifecycleLatch.countDown();                 mDestroyLatch.countDown();             } else {                 super.onAction(bundle, action);             }         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testConstructorNullContext"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"(expected=NullPointerException.class)     public void testConstructorNullContext() {         new Toast(null);     }      private static void assertShowCustomToast(final View view) {         PollingCheck.waitFor(TIME_OUT, () -> null != view.getParent());     }      private void assertShowToast(Toast toast) {         assertTrue(mToastShown.block(TIME_OUT));     }      private static void assertShowAndHideCustomToast(final View view) {         assertShowCustomToast(view);         PollingCheck.waitFor(TIME_OUT, () -> null == view.getParent());     }      private void assertShowAndHide(Toast toast) {         assertTrue(mToastShown.block(TIME_OUT));         assertTrue(mToastHidden.block(TIME_OUT));     }      private static void assertNotShowCustomToast(final View view) {         // sleep a while and then make sure do not show toast         SystemClock.sleep(TIME_FOR_UI_OPERATION);         assertNull(view.getParent());     }      private void assertNotShowToast(Toast toast) {         assertFalse(mToastShown.block(TIME_FOR_UI_OPERATION));     }      private void registerLayoutListener(final View view) {         mLayoutDone = false;         view.getViewTreeObserver().addOnGlobalLayoutListener(mLayoutListener);     }      private void assertLayoutDone(final View view) {         PollingCheck.waitFor(TIME_OUT, () -> mLayoutDone);         view.getViewTreeObserver().removeOnGlobalLayoutListener(mLayoutListener);     }      private void makeToast() throws Throwable {         mToastShown = new ConditionVariable(false);         mToastHidden = new ConditionVariable(false);         mActivityRule.runOnUiThread(                 () -> {                     mToast = Toast.makeText(mContext, TEST_TOAST_TEXT, Toast.LENGTH_LONG);                     mToast.addCallback(new ConditionCallback(mToastShown, mToastHidden));                 });     }      private void makeCustomToast() throws Throwable {         mActivityRule.runOnUiThread(                 () -> {                     mToast = new Toast(mContext);                     mToast.setDuration(Toast.LENGTH_LONG);                     TextView view = new TextView(mContext);                     view.setText(TEST_CUSTOM_TOAST_TEXT);                     mToast.setView(view);                 }         );     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testShow_whenCustomToast"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testShow_whenCustomToast() throws Throwable {         makeCustomToast();          final View view = mToast.getView();          // view has not been attached to screen yet         assertNull(view.getParent());         assertEquals(View.VISIBLE, view.getVisibility());          runOnMainAndDrawSync(view, mToast::show);          // view will be attached to screen when show it         assertEquals(View.VISIBLE, view.getVisibility());         assertShowAndHideCustomToast(view);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testShow_whenTextToast"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testShow_whenTextToast() throws Throwable {         makeToast();          mActivityRule.runOnUiThread(mToast::show);          assertShowAndHide(mToast);     }      @UiThreadTest"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testAccessView_whenCustomToast"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testAccessView_whenCustomToast() throws Throwable {         makeToast();         assertFalse(mToast.getView() instanceof ImageView);          final ImageView imageView = new ImageView(mContext);         Drawable drawable = mContext.getResources().getDrawable(R.drawable.pass);         imageView.setImageDrawable(drawable);          runOnMainAndDrawSync(imageView, () -> {             mToast.setView(imageView);             mToast.show();         });         assertSame(imageView, mToast.getView());         assertShowAndHideCustomToast(imageView);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testAccessDuration_whenCustomToast"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testAccessDuration_whenCustomToast() throws Throwable {         long start = SystemClock.uptimeMillis();         makeCustomToast();         runOnMainAndDrawSync(mToast.getView(), mToast::show);         assertEquals(Toast.LENGTH_LONG, mToast.getDuration());          View view = mToast.getView();         assertShowAndHideCustomToast(view);         long longDuration = SystemClock.uptimeMillis() - start;          start = SystemClock.uptimeMillis();         runOnMainAndDrawSync(mToast.getView(), () -> {             mToast.setDuration(Toast.LENGTH_SHORT);             mToast.show();         });         assertEquals(Toast.LENGTH_SHORT, mToast.getDuration());          view = mToast.getView();         assertShowAndHideCustomToast(view);         long shortDuration = SystemClock.uptimeMillis() - start;          assertTrue(longDuration > shortDuration);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testAccessDuration_whenTextToast"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testAccessDuration_whenTextToast() throws Throwable {         long start = SystemClock.uptimeMillis();         makeToast();         mActivityRule.runOnUiThread(mToast::show);         assertEquals(Toast.LENGTH_LONG, mToast.getDuration());          assertShowAndHide(mToast);         long longDuration = SystemClock.uptimeMillis() - start;          start = SystemClock.uptimeMillis();         makeToast();         mActivityRule.runOnUiThread(() -> {             mToast.setDuration(Toast.LENGTH_SHORT);             mToast.show();         });         assertEquals(Toast.LENGTH_SHORT, mToast.getDuration());          assertShowAndHide(mToast);         long shortDuration = SystemClock.uptimeMillis() - start;          assertTrue(longDuration > shortDuration);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testAccessDuration_whenCustomToastAndWithA11yTimeoutEnabled"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testAccessDuration_whenCustomToastAndWithA11yTimeoutEnabled() throws Throwable {         makeCustomToast();         final Runnable showToast = () -> {             mToast.setDuration(Toast.LENGTH_SHORT);             mToast.show();         };         long start = SystemClock.uptimeMillis();         runOnMainAndDrawSync(mToast.getView(), showToast);         assertShowAndHideCustomToast(mToast.getView());         final long shortDuration = SystemClock.uptimeMillis() - start;          final String originalSetting = Settings.Secure.getString(mContext.getContentResolver(),                 SETTINGS_ACCESSIBILITY_UI_TIMEOUT);         try {             final int a11ySettingDuration = (int) shortDuration + 1000;             putSecureSetting(SETTINGS_ACCESSIBILITY_UI_TIMEOUT,                     Integer.toString(a11ySettingDuration));             waitForA11yRecommendedTimeoutChanged(mContext,                     ACCESSIBILITY_STATE_WAIT_TIMEOUT_MS, a11ySettingDuration);             start = SystemClock.uptimeMillis();             runOnMainAndDrawSync(mToast.getView(), showToast);             assertShowAndHideCustomToast(mToast.getView());             final long a11yDuration = SystemClock.uptimeMillis() - start;             assertTrue(""Toast duration "" + a11yDuration + ""ms < A11y setting "" + a11ySettingDuration                     + ""ms"", a11yDuration >= a11ySettingDuration);         } finally {             putSecureSetting(SETTINGS_ACCESSIBILITY_UI_TIMEOUT, originalSetting);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testAccessDuration_whenTextToastAndWithA11yTimeoutEnabled"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testAccessDuration_whenTextToastAndWithA11yTimeoutEnabled() throws Throwable {         makeToast();         final Runnable showToast = () -> {             mToast.setDuration(Toast.LENGTH_SHORT);             mToast.show();         };         long start = SystemClock.uptimeMillis();         mActivityRule.runOnUiThread(showToast);         assertShowAndHide(mToast);         final long shortDuration = SystemClock.uptimeMillis() - start;          final String originalSetting = Settings.Secure.getString(mContext.getContentResolver(),                 SETTINGS_ACCESSIBILITY_UI_TIMEOUT);         try {             final int a11ySettingDuration = (int) shortDuration + 1000;             putSecureSetting(SETTINGS_ACCESSIBILITY_UI_TIMEOUT,                     Integer.toString(a11ySettingDuration));             waitForA11yRecommendedTimeoutChanged(mContext,                     ACCESSIBILITY_STATE_WAIT_TIMEOUT_MS, a11ySettingDuration);             makeToast();             start = SystemClock.uptimeMillis();             mActivityRule.runOnUiThread(showToast);             assertShowAndHide(mToast);             final long a11yDuration = SystemClock.uptimeMillis() - start;             assertTrue(""Toast duration "" + a11yDuration + ""ms < A11y setting "" + a11ySettingDuration                     + ""ms"", a11yDuration >= a11ySettingDuration);         } finally {             putSecureSetting(SETTINGS_ACCESSIBILITY_UI_TIMEOUT, originalSetting);         }     }      /**      * Wait for accessibility recommended timeout changed and equals to expected timeout.      *      * @param expectedTimeoutMs expected recommended timeout      */     private void waitForA11yRecommendedTimeoutChanged(Context context,             long waitTimeoutMs, int expectedTimeoutMs) {         final AccessibilityManager manager =                 (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);         final Object lock = new Object();         AccessibilityManager.AccessibilityServicesStateChangeListener listener = (m) -> {             synchronized (lock) {                 lock.notifyAll();             }         };         manager.addAccessibilityServicesStateChangeListener(listener, null);         try {             TestUtils.waitOn(lock,                     () -> manager.getRecommendedTimeoutMillis(0,                             AccessibilityManager.FLAG_CONTENT_TEXT) == expectedTimeoutMs,                     waitTimeoutMs,                     ""Wait for accessibility recommended timeout changed"");         } finally {             manager.removeAccessibilityServicesStateChangeListener(listener);         }     }      private void putSecureSetting(String name, String value) {         final StringBuilder cmd = new StringBuilder(""settings put secure "")                 .append(name).append("" "")                 .append(value);         SystemUtil.runShellCommand(cmd.toString());     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testAccessMargin_whenCustomToast"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testAccessMargin_whenCustomToast() throws Throwable {         assumeFalse(""Skipping test: Auto does not support toast with margin"", isCar());          makeCustomToast();         View view = mToast.getView();         assertFalse(view.getLayoutParams() instanceof WindowManager.LayoutParams);          final float horizontal1 = 1.0f;         final float vertical1 = 1.0f;         runOnMainAndDrawSync(view, () -> {             mToast.setMargin(horizontal1, vertical1);             mToast.show();             registerLayoutListener(mToast.getView());         });         assertShowCustomToast(view);          assertEquals(horizontal1, mToast.getHorizontalMargin(), 0.0f);         assertEquals(vertical1, mToast.getVerticalMargin(), 0.0f);         WindowManager.LayoutParams params1 = (WindowManager.LayoutParams) view.getLayoutParams();         assertEquals(horizontal1, params1.horizontalMargin, 0.0f);         assertEquals(vertical1, params1.verticalMargin, 0.0f);         assertLayoutDone(view);          int[] xy1 = new int[2];         view.getLocationOnScreen(xy1);         assertShowAndHideCustomToast(view);          final float horizontal2 = 0.1f;         final float vertical2 = 0.1f;         runOnMainAndDrawSync(view, () -> {             mToast.setMargin(horizontal2, vertical2);             mToast.show();             registerLayoutListener(mToast.getView());         });         assertShowCustomToast(view);          assertEquals(horizontal2, mToast.getHorizontalMargin(), 0.0f);         assertEquals(vertical2, mToast.getVerticalMargin(), 0.0f);         WindowManager.LayoutParams params2 = (WindowManager.LayoutParams) view.getLayoutParams();         assertEquals(horizontal2, params2.horizontalMargin, 0.0f);         assertEquals(vertical2, params2.verticalMargin, 0.0f);          assertLayoutDone(view);         int[] xy2 = new int[2];         view.getLocationOnScreen(xy2);         assertShowAndHideCustomToast(view);          /** Check if the test is being run on a watch.          *          * Change I8180e5080e0a6860b40dbb2faa791f0ede926ca7 updated how toast are displayed on the          * watch. Unlike the phone, which displays toast centered horizontally at the bottom of the          * screen, the watch now displays toast in the center of the screen.          */         if (Gravity.CENTER == mToast.getGravity()) {             assertTrue(xy1[0] > xy2[0]);             assertTrue(xy1[1] > xy2[1]);         } else {             assertTrue(xy1[0] > xy2[0]);             assertTrue(xy1[1] < xy2[1]);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testAccessGravity_whenCustomToast"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testAccessGravity_whenCustomToast() throws Throwable {         assumeFalse(""Skipping test: Auto does not support toast with gravity"", isCar());          makeCustomToast();         runOnMainAndDrawSync(mToast.getView(), () -> {             mToast.setGravity(Gravity.CENTER, 0, 0);             mToast.show();             registerLayoutListener(mToast.getView());         });         View view = mToast.getView();         assertShowCustomToast(view);         assertEquals(Gravity.CENTER, mToast.getGravity());         assertEquals(0, mToast.getXOffset());         assertEquals(0, mToast.getYOffset());         assertLayoutDone(view);         int[] centerXY = new int[2];         view.getLocationOnScreen(centerXY);         assertShowAndHideCustomToast(view);          runOnMainAndDrawSync(mToast.getView(), () -> {             mToast.setGravity(Gravity.BOTTOM, 0, 0);             mToast.show();             registerLayoutListener(mToast.getView());         });         view = mToast.getView();         assertShowCustomToast(view);         assertEquals(Gravity.BOTTOM, mToast.getGravity());         assertEquals(0, mToast.getXOffset());         assertEquals(0, mToast.getYOffset());         assertLayoutDone(view);         int[] bottomXY = new int[2];         view.getLocationOnScreen(bottomXY);         assertShowAndHideCustomToast(view);          // x coordinate is the same         assertEquals(centerXY[0], bottomXY[0]);         // bottom view is below of center view         assertTrue(centerXY[1] < bottomXY[1]);          final int xOffset = 20;         final int yOffset = 10;         runOnMainAndDrawSync(mToast.getView(), () -> {             mToast.setGravity(Gravity.BOTTOM, xOffset, yOffset);             mToast.show();             registerLayoutListener(mToast.getView());         });         view = mToast.getView();         assertShowCustomToast(view);         assertEquals(Gravity.BOTTOM, mToast.getGravity());         assertEquals(xOffset, mToast.getXOffset());         assertEquals(yOffset, mToast.getYOffset());         assertLayoutDone(view);         int[] bottomOffsetXY = new int[2];         view.getLocationOnScreen(bottomOffsetXY);         assertShowAndHideCustomToast(view);          assertEquals(bottomXY[0] + xOffset, bottomOffsetXY[0]);         assertEquals(bottomXY[1] - yOffset, bottomOffsetXY[1]);     }      @UiThreadTest"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testRemovedCallbackIsNotCalled"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testRemovedCallbackIsNotCalled() throws Throwable {         CompletableFuture<Void> toastShown = new CompletableFuture<>();         CompletableFuture<Void> toastHidden = new CompletableFuture<>();         Toast.Callback testCallback = new Toast.Callback() {             @Override             public void onToastShown() {                 toastShown.complete(null);             }             @Override             public void onToastHidden() {                 toastHidden.complete(null);             }         };         mToastShown = new ConditionVariable(false);         mToastHidden = new ConditionVariable(false);         mActivityRule.runOnUiThread(                 () -> {                     mToast = Toast.makeText(mContext, TEST_TOAST_TEXT, Toast.LENGTH_LONG);                     mToast.addCallback(testCallback);                     mToast.addCallback(new ConditionCallback(mToastShown, mToastHidden));                     mToast.removeCallback(testCallback);                 });          mActivityRule.runOnUiThread(mToast::show);          assertShowAndHide(mToast);         assertFalse(toastShown.isDone());         assertFalse(toastHidden.isDone());     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testCallback_whenTextToast_isCalled"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testCallback_whenTextToast_isCalled() throws Throwable {         ConditionVariable toastShown = new ConditionVariable(false);         ConditionVariable toastHidden = new ConditionVariable(false);         mActivityRule.runOnUiThread(                 () -> {                     mToast = Toast.makeText(mContext, TEST_TOAST_TEXT, Toast.LENGTH_LONG);                     mToast.addCallback(new ConditionCallback(toastShown, toastHidden));                 });          mActivityRule.runOnUiThread(mToast::show);          assertTrue(toastShown.block(TIME_OUT));         assertTrue(toastHidden.block(TIME_OUT));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testCallback_whenCustomToast_isCalled"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testCallback_whenCustomToast_isCalled() throws Throwable {         makeCustomToast();         ConditionVariable toastShown = new ConditionVariable(false);         ConditionVariable toastHidden = new ConditionVariable(false);         mActivityRule.runOnUiThread(                 () -> mToast.addCallback(new ConditionCallback(toastShown, toastHidden)));          mActivityRule.runOnUiThread(mToast::show);          assertTrue(toastShown.block(TIME_OUT));         assertTrue(toastHidden.block(TIME_OUT));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testTextToastAllowed_whenInTheForeground"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testTextToastAllowed_whenInTheForeground() throws Throwable {         makeToast();          mActivityRule.runOnUiThread(mToast::show);          assertShowAndHide(mToast);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testCustomToastAllowed_whenInTheForeground"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testCustomToastAllowed_whenInTheForeground() throws Throwable {         makeCustomToast();         View view = mToast.getView();         // View has not been attached to screen yet         assertNull(view.getParent());          mActivityRule.runOnUiThread(mToast::show);          assertShowAndHideCustomToast(view);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testTextToastAllowed_whenInTheBackground"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testTextToastAllowed_whenInTheBackground() throws Throwable {         assumeFalse(""Skipping test: Watch does not support new Toast behavior yet"", isWatch());         // Make it background         mActivityRule.finishActivity();         makeToast();          mActivityRule.runOnUiThread(mToast::show);          assertShowAndHide(mToast);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts.ToastTest"	"testShow_whenCustomToast_sendsAccessibilityEvent"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	"public void testShow_whenCustomToast_sendsAccessibilityEvent() throws Throwable {         makeCustomToast();         AccessibilityEventFilter filter =                 event -> event.getEventType() == AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED;          AccessibilityEvent event = mUiAutomation.executeAndWaitForEvent(                 () -> uncheck(() -> mActivityRule.runOnUiThread(mToast::show)), filter, TIME_OUT);          assertThat(event.getEventType()).isEqualTo(                 AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);         assertThat(event.getClassName()).isEqualTo(Toast.class.getCanonicalName());         assertThat(event.getPackageName()).isEqualTo(mContext.getPackageName());         assertThat(event.getText()).contains(TEST_CUSTOM_TOAST_TEXT);     }      private ConditionVariable registerBlockingReceiver(String action) {         ConditionVariable broadcastReceived = new ConditionVariable(false);         IntentFilter filter = new IntentFilter(action);         mContext.registerReceiver(new BroadcastReceiver() {             @Override             public void onReceive(Context context, Intent intent) {                 broadcastReceived.open();             }         }, filter);         return broadcastReceived;     }      private void runOnMainAndDrawSync(@NonNull final View toastView,             @Nullable final Runnable runner) {         final CountDownLatch latch = new CountDownLatch(1);          try {             mActivityRule.runOnUiThread(() -> {                 final ViewTreeObserver.OnDrawListener listener =                         new ViewTreeObserver.OnDrawListener() {                             @Override                             public void onDraw() {                                 // posting so that the sync happens after the draw that's about                                 // to happen                                 toastView.post(() -> {                                     toastView.getViewTreeObserver().removeOnDrawListener(this);                                     latch.countDown();                                 });                             }                         };                  toastView.getViewTreeObserver().addOnDrawListener(listener);                  if (runner != null) {                     runner.run();                 }                 toastView.invalidate();             });              Assert.assertTrue(""Expected toast draw pass occurred within 5 seconds"",                     latch.await(5, TimeUnit.SECONDS));         } catch (Throwable t) {             throw new RuntimeException(t);         }     }      private boolean isCar() {         PackageManager pm = mContext.getPackageManager();         return pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);     }      private boolean isWatch() {         PackageManager pm = mContext.getPackageManager();         return pm.hasSystemFeature(PackageManager.FEATURE_WATCH);     }      private static void uncheck(ThrowingRunnable runnable) {         try {             runnable.run();         } catch (Throwable e) {             throw new RuntimeException(e);         }     }      private interface ThrowingRunnable {         void run() throws Throwable;     }      private static class ConditionCallback extends Toast.Callback {         private final ConditionVariable mToastShown;         private final ConditionVariable mToastHidden;          ConditionCallback(ConditionVariable toastShown, ConditionVariable toastHidden) {             mToastShown = toastShown;             mToastHidden = toastHidden;         }          @Override         public void onToastShown() {             mToastShown.open();         }          @Override         public void onToastHidden() {             mToastHidden.open();         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.ActivityManagerProcessStateTest"	"testCycleFgAppAndAlert"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	"public void testCycleFgAppAndAlert() throws Exception {         ApplicationInfo stubInfo = mContext.getPackageManager().getApplicationInfo(                 STUB_PACKAGE_NAME, 0);         ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(                 PACKAGE_NAME_APP1, 0);         ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(                 PACKAGE_NAME_APP2, 0);         ApplicationInfo app3Info = mContext.getPackageManager().getApplicationInfo(                 PACKAGE_NAME_APP3, 0);          PermissionUtils.grantPermission(                 STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);         PermissionUtils.grantPermission(                 PACKAGE_NAME_APP1, android.Manifest.permission.PACKAGE_USAGE_STATS);         PermissionUtils.grantPermission(                 PACKAGE_NAME_APP2, android.Manifest.permission.PACKAGE_USAGE_STATS);         PermissionUtils.grantPermission(                 PACKAGE_NAME_APP3, android.Manifest.permission.PACKAGE_USAGE_STATS);          UidImportanceListener stubListener = new UidImportanceListener(mContext,                 stubInfo.uid, ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE,                 WAITFOR_MSEC);         stubListener.register();          UidImportanceListener uid1Listener = new UidImportanceListener(mContext,                 app1Info.uid, IMPORTANCE_VISIBLE,                 WAITFOR_MSEC);         uid1Listener.register();          UidImportanceListener uid2Listener = new UidImportanceListener(mContext,                 app2Info.uid, IMPORTANCE_VISIBLE,                 WAITFOR_MSEC);         uid2Listener.register();          UidImportanceListener uid3Listener = new UidImportanceListener(mContext,                 app3Info.uid, IMPORTANCE_VISIBLE,                 WAITFOR_MSEC);         uid3Listener.register();          WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,                 WAITFOR_MSEC);         WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,                 WAITFOR_MSEC);         WatchUidRunner uid3Watcher = new WatchUidRunner(mInstrumentation, app3Info.uid,                 WAITFOR_MSEC);          try {             // Stub app should have been in foreground since it's being instrumented.              PermissionUtils.grantPermission(                     STUB_PACKAGE_NAME, android.Manifest.permission.SYSTEM_ALERT_WINDOW);             // Show an alert on app0             CommandReceiver.sendCommand(mContext,                     CommandReceiver.COMMAND_START_ALERT_SERVICE, STUB_PACKAGE_NAME,                     STUB_PACKAGE_NAME, 0, null);              // Start a FGS in app2             CommandReceiver.sendCommand(mContext,                     CommandReceiver.COMMAND_START_FOREGROUND_SERVICE, PACKAGE_NAME_APP2,                     PACKAGE_NAME_APP2, 0, null);              uid2Listener.waitForValue(IMPORTANCE_FOREGROUND_SERVICE,                     IMPORTANCE_FOREGROUND_SERVICE);              // Bind from app0 to a service in app1             CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_BIND_SERVICE,                     STUB_PACKAGE_NAME, PACKAGE_NAME_APP1, 0, null);              // Bind from app2 to a service in app1             CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_BIND_SERVICE,                     PACKAGE_NAME_APP2, PACKAGE_NAME_APP1, 0, null);              // Bind from app3 to a service in app1             CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_BIND_SERVICE,                     PACKAGE_NAME_APP3, PACKAGE_NAME_APP1, 0, null);              // Create a cycle             CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_BIND_SERVICE,                     PACKAGE_NAME_APP1, PACKAGE_NAME_APP3, 0, null);              uid1Listener.waitForValue(IMPORTANCE_FOREGROUND_SERVICE,                     IMPORTANCE_FOREGROUND_SERVICE);             uid3Listener.waitForValue(IMPORTANCE_FOREGROUND_SERVICE,                     IMPORTANCE_FOREGROUND_SERVICE);              CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,                     STUB_PACKAGE_NAME, PACKAGE_NAME_APP1, 0, null);              CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,                     PACKAGE_NAME_APP2, PACKAGE_NAME_APP1, 0, null);              CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,                     PACKAGE_NAME_APP3, PACKAGE_NAME_APP1, 0, null);              CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,                     PACKAGE_NAME_APP1, PACKAGE_NAME_APP3, 0, null);              // Stop the foreground service             CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,                     PACKAGE_NAME_APP2, PACKAGE_NAME_APP2, 0, null);              // hide the alert             CommandReceiver.sendCommand(mContext,                     CommandReceiver.COMMAND_STOP_ALERT_SERVICE, STUB_PACKAGE_NAME,                     STUB_PACKAGE_NAME, 0, null);              // Check that the apps' proc state has fallen             uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);             uid2Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);             uid3Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);         } finally {             stubListener.unregister();             uid1Listener.unregister();             uid2Listener.unregister();             uid3Listener.unregister();             uid1Watcher.finish();             uid2Watcher.finish();             uid3Watcher.finish();         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.WindowTest"	"testSetFitsContentForInsets_defaultLegacy_sysuiFlags"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowTest.java"	""	"public void testSetFitsContentForInsets_defaultLegacy_sysuiFlags()             throws Throwable {         mActivityRule.runOnUiThread(() -> {             mWindow.getDecorView().setSystemUiVisibility(SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);             mWindow.getDecorView().setSystemUiVisibility(SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);         });         mInstrumentation.waitForIdleSync();         assertEquals(mActivity.getContentView().getRootWindowInsets().getSystemWindowInsets(),                 mActivity.getLastInsets().getSystemWindowInsets());     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.media.cts.CameraProfileTest"	"testGetWithId"	"CtsMediaTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/CameraProfileTest.java"	""	"public void testGetWithId() {         int nCamera = Camera.getNumberOfCameras();         for (int id = 0; id < nCamera; id++) {             int low = CameraProfile.getJpegEncodingQualityParameter(id, CameraProfile.QUALITY_LOW);             int mid = CameraProfile.getJpegEncodingQualityParameter(id, CameraProfile.QUALITY_MEDIUM);             int high = CameraProfile.getJpegEncodingQualityParameter(id, CameraProfile.QUALITY_HIGH);             checkQuality(low, mid, high);         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.cts.MenuInflaterTest"	"testInflateAlphabeticShortcutFromXml"	"CtsViewTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/MenuInflaterTest.java"	""	"public void testInflateAlphabeticShortcutFromXml() {         // the visibility and shortcut         mMenuInflater.inflate(R.menu.visible_shortcut, mMenu);          assertTrue(mMenu.findItem(R.id.visible_item).isVisible());         assertEquals('a', mMenu.findItem(R.id.visible_item).getAlphabeticShortcut());          assertFalse(mMenu.findItem(R.id.hidden_item).isVisible());         assertEquals('b', mMenu.findItem(R.id.hidden_item).getAlphabeticShortcut());          assertEquals(R.id.hidden_group, mMenu.findItem(R.id.hidden_by_group).getGroupId());         assertFalse(mMenu.findItem(R.id.hidden_by_group).isVisible());         assertEquals('c', mMenu.findItem(R.id.hidden_by_group).getAlphabeticShortcut());     }      @UiThreadTest"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.media.cts.MediaScannerTest"	"testMediaScanner"	"CtsMediaTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/MediaScannerTest.java"	""	"public void testMediaScanner() throws InterruptedException, IOException {         mMediaScannerConnectionClient = new MockMediaScannerConnectionClient();         mMediaScannerConnection = new MockMediaScannerConnection(getContext(),                                     mMediaScannerConnectionClient);          assertFalse(mMediaScannerConnection.isConnected());          // start connection and wait until connected         mMediaScannerConnection.connect();         checkConnectionState(true);          // start and wait for scan         mMediaScannerConnection.scanFile(mMediaFile.getAbsolutePath(), MEDIA_TYPE);         checkMediaScannerConnection();          Uri insertUri = mMediaScannerConnectionClient.mediaUri;         long id = Long.valueOf(insertUri.getLastPathSegment());         ContentResolver res = mContext.getContentResolver();          // check that the file ended up in the audio view         Cursor c = res.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, null,                 MediaColumns.DATA + ""=?"", new String[] { mMediaFile.getAbsolutePath() }, null);         assertEquals(1, c.getCount());         c.close();          // add nomedia file and insert into database, file should no longer be in audio view         File nomedia = new File(mMediaFile.getParent() + ""/.nomedia"");         nomedia.createNewFile();         startMediaScanAndWait();          // entry should not be in audio view anymore         c = res.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, null,                 MediaColumns.DATA + ""=?"", new String[] { mMediaFile.getAbsolutePath() }, null);         assertEquals(0, c.getCount());         c.close();          // with nomedia file removed, do media scan and check that entry is in audio table again         nomedia.delete();         startMediaScanAndWait();          // Give the 2nd stage scan that makes the unhidden files visible again         // a little more time         SystemClock.sleep(10000);         // entry should be in audio view again         c = res.query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, null,                 MediaColumns.DATA + ""=?"", new String[] { mMediaFile.getAbsolutePath() }, null);         assertEquals(1, c.getCount());         c.close();          // ensure that we don't currently have playlists named ctsmediascanplaylist*         res.delete(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,                 MediaStore.Audio.PlaylistsColumns.NAME + ""=?"",                 new String[] { ""ctsmediascanplaylist1""});         res.delete(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,                 MediaStore.Audio.PlaylistsColumns.NAME + ""=?"",                 new String[] { ""ctsmediascanplaylist2""});         // delete the playlist file entries, if they exist         res.delete(MediaStore.Files.getContentUri(""external""),                 MediaStore.Files.FileColumns.DATA + ""=?"",                 new String[] { mFileDir + ""/ctsmediascanplaylist1.pls""});         res.delete(MediaStore.Files.getContentUri(""external""),                 MediaStore.Files.FileColumns.DATA + ""=?"",                 new String[] { mFileDir + ""/ctsmediascanplaylist2.m3u""});          // write some more files         writeFile(R.raw.testmp3, mFileDir + ""/testmp3.mp3"");         writeFile(R.raw.testmp3_2, mFileDir + ""/testmp3_2.mp3"");         writeFile(R.raw.playlist1, mFileDir + ""/ctsmediascanplaylist1.pls"");         writeFile(R.raw.playlist2, mFileDir + ""/ctsmediascanplaylist2.m3u"");          startMediaScanAndWait();          // verify that the two playlists were created correctly;         c = res.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, null,                 MediaStore.Audio.PlaylistsColumns.NAME + ""=?"",                 new String[] { ""ctsmediascanplaylist1""}, null);         assertEquals(1, c.getCount());         c.moveToFirst();         long playlistid = c.getLong(c.getColumnIndex(MediaStore.MediaColumns._ID));         c.close();          c = res.query(MediaStore.Audio.Playlists.Members.getContentUri(""external"", playlistid),                 null, null, null, MediaStore.Audio.Playlists.Members.PLAY_ORDER);         assertEquals(2, c.getCount());         c.moveToNext();         long song1a = c.getLong(c.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID));         c.moveToNext();         long song1b = c.getLong(c.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID));         c.close();         assertTrue(""song id should not be 0"", song1a != 0);         assertTrue(""song id should not be 0"", song1b != 0);         assertTrue(""song ids should not be same"", song1a != song1b);          // 2nd playlist should have the same songs, in reverse order         c = res.query(MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, null,                 MediaStore.Audio.PlaylistsColumns.NAME + ""=?"",                 new String[] { ""ctsmediascanplaylist2""}, null);         assertEquals(1, c.getCount());         c.moveToFirst();         playlistid = c.getLong(c.getColumnIndex(MediaStore.MediaColumns._ID));         c.close();          c = res.query(MediaStore.Audio.Playlists.Members.getContentUri(""external"", playlistid),                 null, null, null, MediaStore.Audio.Playlists.Members.PLAY_ORDER);         assertEquals(2, c.getCount());         c.moveToNext();         long song2a = c.getLong(c.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID));         c.moveToNext();         long song2b = c.getLong(c.getColumnIndex(MediaStore.Audio.Playlists.Members.AUDIO_ID));         c.close();         assertEquals(""mismatched song ids"", song1a, song2b);         assertEquals(""mismatched song ids"", song2a, song1b);          mMediaScannerConnection.disconnect();          checkConnectionState(false);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.WearableExtenderTest"	"testWearableExtender"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/WearableExtenderTest.java"	""	"public void testWearableExtender() {         final String bridgeTag = ""bridge_tag"";         final String dismissalId = ""dismissal_id"";         final int contentActionIndex = 2;         final Bitmap background = Bitmap.createBitmap(10, 10, Config.ARGB_8888);         PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, new Intent(), 0);         Notification page1 = new Notification.Builder(mContext, ""test id"")             .setSmallIcon(1)             .setContentTitle(""page1"")             .build();         Notification page2 = new Notification.Builder(mContext, ""test id"")             .setSmallIcon(1)             .setContentTitle(""page2"")             .build();         List<Notification> pages = new ArrayList<>();         pages.add(page2);         final int gravity = Gravity.LEFT;         final int icon = 3;         final int height = 4;         final int size = 5;         final int timeout = 6;          WearableExtender extender = new WearableExtender()                 .setStartScrollBottom(true)                 .setContentIntentAvailableOffline(true)                 .setHintContentIntentLaunchesActivity(true)                 .setBridgeTag(bridgeTag)                 .setDismissalId(dismissalId)                 .setContentAction(contentActionIndex)                 // deprecated methods follow                 .setBackground(background)                 .setGravity(gravity)                 .setContentIcon(icon)                 .setContentIconGravity(gravity)                 .setCustomContentHeight(height)                 .setCustomSizePreset(size)                 .setDisplayIntent(pendingIntent)                 .setHintAmbientBigPicture(true)                 .setHintAvoidBackgroundClipping(true)                 .setHintHideIcon(true)                 .setHintScreenTimeout(timeout)                 .setHintShowBackgroundOnly(true)                 .addPage(page1)                 .clearPages()                 .addPages(pages);          assertTrue(extender.getStartScrollBottom());         assertTrue(extender.getContentIntentAvailableOffline());         assertTrue(extender.getHintContentIntentLaunchesActivity());         assertEquals(bridgeTag, extender.getBridgeTag());         assertEquals(dismissalId, extender.getDismissalId());         assertEquals(contentActionIndex, extender.getContentAction());         // deprecated methods follow         assertEquals(background, extender.getBackground());         assertEquals(gravity, extender.getGravity());         assertEquals(icon, extender.getContentIcon());         assertEquals(gravity, extender.getContentIconGravity());         assertEquals(height, extender.getCustomContentHeight());         assertEquals(size, extender.getCustomSizePreset());         assertEquals(pendingIntent, extender.getDisplayIntent());         assertTrue(extender.getHintAmbientBigPicture());         assertTrue(extender.getHintAvoidBackgroundClipping());         assertTrue(extender.getHintHideIcon());         assertEquals(timeout, extender.getHintScreenTimeout());         assertTrue(extender.getHintShowBackgroundOnly());         assertEquals(1, extender.getPages().size());         assertEquals(page2, extender.getPages().get(0));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.app.cts.WearableExtenderTest"	"testWriteToParcel"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/WearableExtenderTest.java"	""	"public void testWriteToParcel() {         final String bridgeTag = ""bridge_tag"";         final String dismissalId = ""dismissal_id"";         final int contentActionIndex = 2;         Notification.Action action = newActionBuilder().build();         final Bitmap background = Bitmap.createBitmap(10, 10, Config.ARGB_8888);         PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, new Intent(), 0);         Notification page1 = new Notification.Builder(mContext, ""test id"")             .setSmallIcon(1)             .setContentTitle(""page1"")             .build();         Notification page2 = new Notification.Builder(mContext, ""test id"")             .setSmallIcon(1)             .setContentTitle(""page2"")             .build();         List<Notification> pages = new ArrayList<>();         pages.add(page2);         final int gravity = Gravity.LEFT;         final int icon = 3;         final int height = 4;         final int size = 5;         final int timeout = 6;          Notification notif = new Notification.Builder(mContext, ""test id"")                 .setSmallIcon(1)                 .setContentTitle(""test_title"")                 .extend(new Notification.WearableExtender()                         .setStartScrollBottom(true)                         .setContentIntentAvailableOffline(true)                         .setHintContentIntentLaunchesActivity(true)                         .setBridgeTag(bridgeTag)                         .setDismissalId(dismissalId)                         .addAction(action)                         .setContentAction(contentActionIndex)                         // deprecated methods follow                         .setBackground(background)                         .setGravity(gravity)                         .setContentIcon(icon)                         .setContentIconGravity(gravity)                         .setCustomContentHeight(height)                         .setCustomSizePreset(size)                         .setDisplayIntent(pendingIntent)                         .setHintAmbientBigPicture(true)                         .setHintAvoidBackgroundClipping(true)                         .setHintHideIcon(true)                         .setHintScreenTimeout(timeout)                         .setHintShowBackgroundOnly(true)                         .addPage(page1))                 .build();          Parcel parcel = Parcel.obtain();         notif.writeToParcel(parcel, 0);         parcel.setDataPosition(0);         Notification result = new Notification(parcel);          WearableExtender extender = new WearableExtender(result);         assertTrue(extender.getStartScrollBottom());         assertTrue(extender.getContentIntentAvailableOffline());         assertTrue(extender.getHintContentIntentLaunchesActivity());         assertEquals(bridgeTag, extender.getBridgeTag());         assertEquals(dismissalId, extender.getDismissalId());         assertEquals(contentActionIndex, extender.getContentAction());         assertEquals(1, extender.getActions().size());         // deprecated methods follow         assertNotNull(extender.getBackground());         assertEquals(gravity, extender.getGravity());         assertEquals(icon, extender.getContentIcon());         assertEquals(gravity, extender.getContentIconGravity());         assertEquals(height, extender.getCustomContentHeight());         assertEquals(size, extender.getCustomSizePreset());         assertEquals(pendingIntent, extender.getDisplayIntent());         assertTrue(extender.getHintAmbientBigPicture());         assertTrue(extender.getHintAvoidBackgroundClipping());         assertTrue(extender.getHintHideIcon());         assertEquals(timeout, extender.getHintScreenTimeout());         assertTrue(extender.getHintShowBackgroundOnly());         assertEquals(1, extender.getPages().size());     }      private static Notification.Action.Builder newActionBuilder() {         return new Notification.Action.Builder(0, ""title"", null);     }      /** Notification.Action.WearableExtender functions */"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.hardware.input.cts.tests.SonyDualshock4ProUsbTest"	"SonyDualshock4ProUsbTest"	"CtsHardwareTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/SonyDualshock4ProUsbTest.java"	""	"/*  *.  */  package android.hardware.input.cts.tests;  import static org.junit.Assume.assumeTrue;  import android.hardware.cts.R; import android.os.Build; import android.os.VintfRuntimeInfo; import android.text.TextUtils; import android.util.Pair;  import androidx.test.ext.junit.runners.AndroidJUnit4; import androidx.test.filters.SmallTest;  import java.util.regex.Matcher; import java.util.regex.Pattern;  import org.junit.Test; import org.junit.runner.RunWith;  @SmallTest @RunWith(AndroidJUnit4.class) public class SonyDualshock4ProUsbTest extends InputTestCase {      // Simulates the behavior of PlayStation DualShock4 Pro gamepad (model CUH-ZCT2U)     public SonyDualshock4ProUsbTest() {         super(R.raw.sony_dualshock4pro_usb_register);     }      // Copied from cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java     private static Pair<Integer, Integer> getVersionFromString(String version) {         // Only gets major and minor number of the version string.         final Pattern versionPattern = Pattern.compile(""^(\\d+)(\\.(\\d+))?.*"");         final Matcher m = versionPattern.matcher(version);         if (m.matches()) {             final int major = Integer.parseInt(m.group(1));             final int minor = TextUtils.isEmpty(m.group(3)) ? 0 : Integer.parseInt(m.group(3));             return new Pair<>(major, minor);         } else {             return new Pair<>(0, 0);         }     }      // Copied from cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java     public static int compareMajorMinorVersion(final String s1, final String s2) {         final Pair<Integer, Integer> v1 = getVersionFromString(s1);         final Pair<Integer, Integer> v2 = getVersionFromString(s2);          if (v1.first == v2.first) {             return Integer.compare(v1.second, v2.second);         } else {             return Integer.compare(v1.first, v2.first);         }     }      // This test requires updates to hid-sony.c that are only available for     // kernels 3.18+. Skip this test for kernels older than 3.18 because it is     // too difficult to backport these changes to those older kernels.     private static boolean isDualshock4DriverSupportedByKernel() {         final String kVersionString = VintfRuntimeInfo.getKernelVersion();         return compareMajorMinorVersion(kVersionString, ""3.18"") >= 0;     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.text.cts.AnnotationTest"	"testGetSpanTypeId"	"CtsTextTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/text/src/android/text/cts/AnnotationTest.java"	""	"public void testGetSpanTypeId() {         mAnnotation = new Annotation(KEY1, VALUE1);         // Because of the return value is a hide value, we only can assert the return value isn't 0.         assertTrue(mAnnotation.getSpanTypeId() != 0);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.cts.statsd.atom.UidAtomTests"	"testHiddenApiUsed"	""	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/statsd/src/android/cts/statsd/atom/UidAtomTests.java"	""	"public void testHiddenApiUsed() throws Exception {         String oldRate = getDevice().executeShellCommand(                 ""device_config get app_compat hidden_api_access_statslog_sampling_rate"").trim();          getDevice().executeShellCommand(                 ""device_config put app_compat hidden_api_access_statslog_sampling_rate 65536"");          Thread.sleep(WAIT_TIME_SHORT);          try {             final int atomTag = Atom.HIDDEN_API_USED_FIELD_NUMBER;              createAndUploadConfig(atomTag, false);              runActivity(""HiddenApiUsedActivity"", null, null, 2_500);              List<EventMetricData> data = getEventMetricDataList();             assertThat(data).hasSize(1);              HiddenApiUsed atom = data.get(0).getAtom().getHiddenApiUsed();              int uid = getUid();             assertThat(atom.getUid()).isEqualTo(uid);             assertThat(atom.getAccessDenied()).isFalse();             assertThat(atom.getSignature())                 .isEqualTo(""Landroid/app/Activity;->mWindow:Landroid/view/Window;"");         } finally {             if (!oldRate.equals(""null"")) {                 getDevice().executeShellCommand(                         ""device_config put app_compat hidden_api_access_statslog_sampling_rate ""                         + oldRate);             } else {                 getDevice().executeShellCommand(                         ""device_config delete hidden_api_access_statslog_sampling_rate"");             }         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.LayoutTests"	"testLayoutAfterRemovingFocus"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/LayoutTests.java"	""	"public void testLayoutAfterRemovingFocus() throws InterruptedException {         final TestActivity activity = startActivity(TestActivity.class);          // Get the visible frame of the main activity before adding any window.         final Rect visibleFrame = new Rect();         getInstrumentation().runOnMainSync(() ->                 activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(visibleFrame));         assertFalse(""Visible frame must not be empty."", visibleFrame.isEmpty());          doTestLayoutAfterRemovingFocus(activity, visibleFrame, SYSTEM_UI_FLAG_FULLSCREEN);         doTestLayoutAfterRemovingFocus(activity, visibleFrame, SYSTEM_UI_FLAG_HIDE_NAVIGATION);         doTestLayoutAfterRemovingFocus(activity, visibleFrame, SYSTEM_UI_FLAG_HIDE_ALL);     }      private void doTestLayoutAfterRemovingFocus(TestActivity activity,             Rect visibleFrameBeforeAddingWindow, int systemUiFlags) throws InterruptedException {         // Add a window which can affect the global layout.         getInstrumentation().runOnMainSync(() -> {             final View view = new View(activity);             view.setSystemUiVisibility(systemUiFlags);             activity.addWindow(view, new LayoutParams());         });          // Wait for the global layout triggered by adding window.         activity.waitForGlobalLayout();          // Remove the window we added previously.         getInstrumentation().runOnMainSync(activity::removeAllWindows);          // Wait for the global layout triggered by removing window.         activity.waitForGlobalLayout();          // Wait for the activity has focus before get the visible frame         activity.waitAndAssertWindowFocusState(true);          // Get the visible frame of the main activity after removing the window we added.         final Rect visibleFrameAfterRemovingWindow = new Rect();         getInstrumentation().runOnMainSync(() ->                 activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(                         visibleFrameAfterRemovingWindow));          // Test whether the visible frame after removing window is the same as one before adding         // window. If not, it shows that the layout after removing window has a problem.         assertEquals(visibleFrameBeforeAddingWindow, visibleFrameAfterRemovingWindow);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.LayoutTests"	"testAddingImmersiveWindow"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/LayoutTests.java"	""	"public void testAddingImmersiveWindow() throws InterruptedException {         // Automotive device implementations [3.8/A] MAY restrict the application requests to limit         // the ability to enter a full screen mode as described in immersive documentation.         assumeFalse(""Skipping test: Immersive mode could be disabled in Automotive"",                 FeatureUtil.isAutomotive());          final boolean[] systemUiFlagsGotCleared = { false };         final TestActivity activity = startActivity(TestActivity.class);          // Add a window which has clearable system UI flags.         getInstrumentation().runOnMainSync(() -> {             final View view = new View(activity);             view.setSystemUiVisibility(SYSTEM_UI_FLAG_IMMERSIVE_STICKY | SYSTEM_UI_FLAG_HIDE_ALL);             view.setOnSystemUiVisibilityChangeListener(                     visibility -> {                         if ((visibility & SYSTEM_UI_FLAG_HIDE_ALL) != SYSTEM_UI_FLAG_HIDE_ALL) {                             systemUiFlagsGotCleared[0] = true;                             // Early break because things go wrong already.                             synchronized (activity) {                                 activity.notify();                             }                         }                     });             activity.addWindow(view, new LayoutParams());         });          // Wait for the possible failure.         synchronized (activity) {             activity.wait(TIMEOUT_SYSTEM_UI_VISIBILITY_CHANGE);         }          // Test if flags got cleared.         assertFalse(""System UI flags must not be cleared."", systemUiFlagsGotCleared[0]);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.server.wm.LayoutTests"	"testSysuiFlagLayoutHideNavigation"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/LayoutTests.java"	""	"public void testSysuiFlagLayoutHideNavigation() {         final TestActivity activity = startActivity(TestActivity.class);          final View[] views = new View[2];         getInstrumentation().runOnMainSync(() -> {             views[0] = new View(activity);             final LayoutParams attrs = new LayoutParams();             attrs.setFitInsetsTypes(attrs.getFitInsetsTypes() & ~Type.systemBars());             activity.addWindow(views[0], attrs);              views[1] = new View(activity);             views[1].setSystemUiVisibility(SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);             activity.addWindow(views[1], new LayoutParams());         });         getInstrumentation().waitForIdleSync();          assertLayoutEquals(views[0], views[1]);     }      private static void assertLayoutEquals(View view1, View view2) {         final int[][] locations = new int[2][2];         view1.getLocationOnScreen(locations[0]);         view2.getLocationOnScreen(locations[1]);         assertArrayEquals(""Location must be the same."", locations[0], locations[1]);         assertEquals(""Width must be the same."", view1.getWidth(), view2.getWidth());         assertEquals(""Height must be the same."", view1.getHeight(), view2.getHeight());     }      public static class TestActivity extends FocusableActivity {         private static final long TIMEOUT_LAYOUT = 200; // milliseconds          private final Object mLockGlobalLayout = new Object();         private ArrayList<View> mViews = new ArrayList<>();          @Override         protected void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             getWindow().getDecorView().getViewTreeObserver().addOnGlobalLayoutListener(() -> {                 synchronized (mLockGlobalLayout) {                     mLockGlobalLayout.notify();                 }             });         }          void waitForGlobalLayout() throws InterruptedException {             synchronized (mLockGlobalLayout) {                 mLockGlobalLayout.wait(TIMEOUT_LAYOUT);             }         }          void addWindow(View view, LayoutParams attrs) {             getWindowManager().addView(view, attrs);             mViews.add(view);         }          void removeAllWindows() {             for (View view : mViews) {                 getWindowManager().removeViewImmediate(view);             }             mViews.clear();         }          @Override         protected void onPause() {             super.onPause();             removeAllWindows();         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.inputmethod.cts.SearchViewTest"	"testTapThenSetQuery"	"CtsInputMethodTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/SearchViewTest.java"	""	"public void testTapThenSetQuery() throws Exception {         try (MockImeSession imeSession = MockImeSession.create(                 InstrumentationRegistry.getInstrumentation().getContext(),                 InstrumentationRegistry.getInstrumentation().getUiAutomation(),                 new ImeSettings.Builder())) {             final ImeEventStream stream = imeSession.openEventStream();              final SearchView searchView = launchTestActivity(false /* requestFocus */);              // Emulate tap event on SearchView             CtsTouchUtils.emulateTapOnViewCenter(                     InstrumentationRegistry.getInstrumentation(), null, searchView);              // Expect input to bind since EditText is focused.             expectBindInput(stream, Process.myPid(), TIMEOUT);              // Wait until ""showSoftInput"" gets called with a real InputConnection             expectEvent(stream, event ->                     ""showSoftInput"".equals(event.getEventName())                             && !event.getExitState().hasDummyInputConnection(),                     CHECK_EXIT_EVENT_ONLY, TIMEOUT);              expectImeVisible(TIMEOUT);              // Make sure that ""setQuery"" triggers ""hideSoftInput"" in the IME side.             runOnMainSync(() -> searchView.setQuery(""test"", true /* submit */));             expectEvent(stream, event -> ""hideSoftInput"".equals(event.getEventName()), TIMEOUT);              expectImeInvisible(TIMEOUT);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.view.inputmethod.cts.SearchViewTest"	"testShowImeWhenSearchViewFocusInListView"	"CtsInputMethodTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/SearchViewTest.java"	""	"public void testShowImeWhenSearchViewFocusInListView() throws Exception {         try (MockImeSession imeSession = MockImeSession.create(                 InstrumentationRegistry.getInstrumentation().getContext(),                 InstrumentationRegistry.getInstrumentation().getUiAutomation(),                 new ImeSettings.Builder())) {             final ImeEventStream stream = imeSession.openEventStream();              final SearchView searchView = launchTestActivityWithListView(true /* requestFocus */);              // Emulate tap event on SearchView             CtsTouchUtils.emulateTapOnViewCenter(                     InstrumentationRegistry.getInstrumentation(), null, searchView);              // Expect input to bind since EditText is focused.             expectBindInput(stream, Process.myPid(), TIMEOUT);              // Wait until ""showSoftInput"" gets called with a real InputConnection             expectEvent(stream, event ->                             ""showSoftInput"".equals(event.getEventName())                                     && !event.getExitState().hasDummyInputConnection(),                     CHECK_EXIT_EVENT_ONLY, TIMEOUT);              expectImeVisible(TIMEOUT);              notExpectEvent(stream, event -> ""hideSoftInput"".equals(event.getEventName()),                     NOT_EXPECT_TIMEOUT);         }     }      static final class SingleItemAdapter extends BaseAdapter {         private final SearchView mSearchView;          SingleItemAdapter(SearchView searchView) {             mSearchView = searchView;         }          @Override         public int getCount() {             return 1;         }          @Override         public Object getItem(int i) {             return mSearchView;         }          @Override         public long getItemId(int i) {             return 0;         }          @Override         public View getView(int i, View view, ViewGroup viewGroup) {             return mSearchView;         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.accessibilityservice.cts.AccessibilitySoftKeyboardTest"	"testApiReturnValues_shouldChangeValueOnRequestAndSendCallback"	"CtsAccessibilityServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySoftKeyboardTest.java"	""	"public void testApiReturnValues_shouldChangeValueOnRequestAndSendCallback() throws Exception {         final SoftKeyboardController controller = mService.getSoftKeyboardController();          // Confirm that we start in the default state         assertEquals(SHOW_MODE_AUTO, controller.getShowMode());          controller.addOnShowModeChangedListener(mListener);         assertCanSetAndGetShowModeAndCallbackHappens(SHOW_MODE_HIDDEN, mService);         assertCanSetAndGetShowModeAndCallbackHappens(SHOW_MODE_IGNORE_HARD_KEYBOARD, mService);         assertCanSetAndGetShowModeAndCallbackHappens(SHOW_MODE_AUTO, mService);          // Make sure we can remove our listener.         assertTrue(controller.removeOnShowModeChangedListener(mListener));     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.accessibilityservice.cts.AccessibilitySoftKeyboardTest"	"disableSelf"	"CtsAccessibilityServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySoftKeyboardTest.java"	""	"public void secondServiceChangingTheShowMode_updatesModeAndNotifiesFirstService()             throws Exception {          final SoftKeyboardController controller = mService.getSoftKeyboardController();         // Confirm that we start in the default state         assertEquals(SHOW_MODE_AUTO, controller.getShowMode());          final InstrumentedAccessibilityService secondService =                 enableService(StubAccessibilityButtonService.class);         try {             // Listen on the first service             controller.addOnShowModeChangedListener(mListener);             assertCanSetAndGetShowModeAndCallbackHappens(SHOW_MODE_HIDDEN, mService);              // Change the mode on the second service             assertCanSetAndGetShowModeAndCallbackHappens(SHOW_MODE_IGNORE_HARD_KEYBOARD,                     secondService);         } finally {             secondService.runOnServiceSync(() -> secondService.disableSelf());         }          // Shutting down the second service, which was controlling the mode, should put us back         // to the default         waitForCallbackValueWithLock(SHOW_MODE_AUTO);         final int showMode = mService.getOnService(() -> controller.getShowMode());         assertEquals(SHOW_MODE_AUTO, showMode);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.accessibilityservice.cts.AccessibilitySoftKeyboardTest"	"testSwitchToInputMethod"	"CtsAccessibilityServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySoftKeyboardTest.java"	""	"public void testSwitchToInputMethod() throws Exception {         final SoftKeyboardController controller = mService.getSoftKeyboardController();         String currentIME = Settings.Secure.getString(                 mService.getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD);         assertNotEquals(Ime1Constants.IME_ID, currentIME);         // Enable a dummy IME for this test.         try (TestImeSession imeSession = new TestImeSession(Ime1Constants.IME_ID)) {             // Switch to the dummy IME.             final boolean success = controller.switchToInputMethod(Ime1Constants.IME_ID);             currentIME = Settings.Secure.getString(                     mService.getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD);              // The current IME should be set to the dummy IME successfully.             assertTrue(success);             assertEquals(Ime1Constants.IME_ID, currentIME);         }     }      private void assertCanSetAndGetShowModeAndCallbackHappens(             int mode, InstrumentedAccessibilityService service)             throws Exception  {         final SoftKeyboardController controller = service.getSoftKeyboardController();         mLastCallbackValue = -1;         final boolean setShowModeReturns =                 service.getOnService(() -> controller.setShowMode(mode));         assertTrue(setShowModeReturns);         waitForCallbackValueWithLock(mode);         assertEquals(mode, controller.getShowMode());     }      private void waitForCallbackValueWithLock(int expectedValue) throws Exception {         long timeoutTimeMillis = SystemClock.uptimeMillis() + AsyncUtils.DEFAULT_TIMEOUT_MS;          while (SystemClock.uptimeMillis() < timeoutTimeMillis) {             synchronized(mLock) {                 if (mLastCallbackValue == expectedValue) {                     return;                 }                 try {                     mLock.wait(timeoutTimeMillis - SystemClock.uptimeMillis());                 } catch (InterruptedException e) {                     // Wait until timeout.                 }             }         }          throw new IllegalStateException(""last callback value <"" + mLastCallbackValue                 + ""> does not match expected value < "" + expectedValue + "">"");     }      /**      * Activity for testing the AccessibilityService API for hiding and showing the soft keyboard.      */     public static class SoftKeyboardModesActivity extends AccessibilityTestActivity {         public SoftKeyboardModesActivity() {             super();         }          @Override         public void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             setContentView(R.layout.accessibility_soft_keyboard_modes_test);         }     }      private class TestImeSession implements AutoCloseable {         TestImeSession(String imeId) {             // Enable the dummy IME by shell command.             final String enableImeCommand = ShellCommandUtils.enableIme(imeId);             ShellCommandBuilder.create(mInstrumentation)                     .addCommand(enableImeCommand)                     .run();         }          @Override         public void close() throws Exception {             // Reset IMEs by shell command.             ShellCommandBuilder.create(mInstrumentation)                     .addCommand(ShellCommandUtils.resetImes())                     .run();         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testConstructorNullContext"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"(expected=NullPointerException.class)     public void testConstructorNullContext() {         new Toast(null);     }      private static void assertShowToast(final View view) {         PollingCheck.waitFor(TIME_OUT, () -> null != view.getParent());     }      private static void assertShowAndHide(final View view) {         assertShowToast(view);         PollingCheck.waitFor(TIME_OUT, () -> null == view.getParent());     }      private static void assertNotShowToast(final View view) {         // sleep a while and then make sure do not show toast         SystemClock.sleep(TIME_FOR_UI_OPERATION);         assertNull(view.getParent());     }      private void registerLayoutListener(final View view) {         mLayoutDone = false;         view.getViewTreeObserver().addOnGlobalLayoutListener(mLayoutListener);     }      private void assertLayoutDone(final View view) {         PollingCheck.waitFor(TIME_OUT, () -> mLayoutDone);         view.getViewTreeObserver().removeOnGlobalLayoutListener(mLayoutListener);     }      private void makeToast() throws Throwable {         mActivityRule.runOnUiThread(                 () -> mToast = Toast.makeText(mContext, TEST_TOAST_TEXT, Toast.LENGTH_LONG));     }      private void makeCustomToast() throws Throwable {         mActivityRule.runOnUiThread(                 () -> {                     mToast = new Toast(mContext);                     mToast.setDuration(Toast.LENGTH_LONG);                     TextView view = new TextView(mContext);                     view.setText(TEST_CUSTOM_TOAST_TEXT);                     mToast.setView(view);                 }         );     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testShow"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"public void testShow() throws Throwable {         makeToast();          final View view = mToast.getView();          // view has not been attached to screen yet         assertNull(view.getParent());         assertEquals(View.VISIBLE, view.getVisibility());          runOnMainAndDrawSync(view, mToast::show);          // view will be attached to screen when show it         assertEquals(View.VISIBLE, view.getVisibility());         assertShowAndHide(view);     }      @UiThreadTest"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testAccessView"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"public void testAccessView() throws Throwable {         makeToast();         assertFalse(mToast.getView() instanceof ImageView);          final ImageView imageView = new ImageView(mContext);         Drawable drawable = mContext.getResources().getDrawable(R.drawable.pass);         imageView.setImageDrawable(drawable);          runOnMainAndDrawSync(imageView, () -> {             mToast.setView(imageView);             mToast.show();         });         assertSame(imageView, mToast.getView());         assertShowAndHide(imageView);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testAccessDuration"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"public void testAccessDuration() throws Throwable {         long start = SystemClock.uptimeMillis();         makeToast();         runOnMainAndDrawSync(mToast.getView(), mToast::show);         assertEquals(Toast.LENGTH_LONG, mToast.getDuration());          View view = mToast.getView();         assertShowAndHide(view);         long longDuration = SystemClock.uptimeMillis() - start;          start = SystemClock.uptimeMillis();         runOnMainAndDrawSync(mToast.getView(), () -> {             mToast.setDuration(Toast.LENGTH_SHORT);             mToast.show();         });         assertEquals(Toast.LENGTH_SHORT, mToast.getDuration());          view = mToast.getView();         assertShowAndHide(view);         long shortDuration = SystemClock.uptimeMillis() - start;          assertTrue(longDuration > shortDuration);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testAccessDuration_withA11yTimeoutEnabled"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"public void testAccessDuration_withA11yTimeoutEnabled() throws Throwable {         makeToast();         final Runnable showToast = () -> {             mToast.setDuration(Toast.LENGTH_SHORT);             mToast.show();         };         long start = SystemClock.uptimeMillis();         runOnMainAndDrawSync(mToast.getView(), showToast);         assertShowAndHide(mToast.getView());         final long shortDuration = SystemClock.uptimeMillis() - start;          final String originalSetting = Settings.Secure.getString(mContext.getContentResolver(),                 SETTINGS_ACCESSIBILITY_UI_TIMEOUT);         try {             final int a11ySettingDuration = (int) shortDuration + 1000;             putSecureSetting(SETTINGS_ACCESSIBILITY_UI_TIMEOUT,                     Integer.toString(a11ySettingDuration));             waitForA11yRecommendedTimeoutChanged(mContext,                     ACCESSIBILITY_STATE_WAIT_TIMEOUT_MS, a11ySettingDuration);             start = SystemClock.uptimeMillis();             runOnMainAndDrawSync(mToast.getView(), showToast);             assertShowAndHide(mToast.getView());             final long a11yDuration = SystemClock.uptimeMillis() - start;             assertTrue(a11yDuration >= a11ySettingDuration);         } finally {             putSecureSetting(SETTINGS_ACCESSIBILITY_UI_TIMEOUT, originalSetting);         }     }      /**      * Wait for accessibility recommended timeout changed and equals to expected timeout.      *      * @param expectedTimeoutMs expected recommended timeout      */     private void waitForA11yRecommendedTimeoutChanged(Context context,             long waitTimeoutMs, int expectedTimeoutMs) {         final AccessibilityManager manager =                 (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);         final Object lock = new Object();         AccessibilityManager.AccessibilityServicesStateChangeListener listener = (m) -> {             synchronized (lock) {                 lock.notifyAll();             }         };         manager.addAccessibilityServicesStateChangeListener(listener, null);         try {             TestUtils.waitOn(lock,                     () -> manager.getRecommendedTimeoutMillis(0,                             AccessibilityManager.FLAG_CONTENT_TEXT) == expectedTimeoutMs,                     waitTimeoutMs,                     ""Wait for accessibility recommended timeout changed"");         } finally {             manager.removeAccessibilityServicesStateChangeListener(listener);         }     }      private void putSecureSetting(String name, String value) {         final StringBuilder cmd = new StringBuilder(""settings put secure "")                 .append(name).append("" "")                 .append(value);         SystemUtil.runShellCommand(cmd.toString());     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testAccessMargin"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"public void testAccessMargin() throws Throwable {         assumeFalse(""Skipping test: Auto does not support toast with margin"", isCar());          makeToast();         View view = mToast.getView();         assertFalse(view.getLayoutParams() instanceof WindowManager.LayoutParams);          final float horizontal1 = 1.0f;         final float vertical1 = 1.0f;         runOnMainAndDrawSync(view, () -> {             mToast.setMargin(horizontal1, vertical1);             mToast.show();             registerLayoutListener(mToast.getView());         });         assertShowToast(view);          assertEquals(horizontal1, mToast.getHorizontalMargin(), 0.0f);         assertEquals(vertical1, mToast.getVerticalMargin(), 0.0f);         WindowManager.LayoutParams params1 = (WindowManager.LayoutParams) view.getLayoutParams();         assertEquals(horizontal1, params1.horizontalMargin, 0.0f);         assertEquals(vertical1, params1.verticalMargin, 0.0f);         assertLayoutDone(view);          int[] xy1 = new int[2];         view.getLocationOnScreen(xy1);         assertShowAndHide(view);          final float horizontal2 = 0.1f;         final float vertical2 = 0.1f;         runOnMainAndDrawSync(view, () -> {             mToast.setMargin(horizontal2, vertical2);             mToast.show();             registerLayoutListener(mToast.getView());         });         assertShowToast(view);          assertEquals(horizontal2, mToast.getHorizontalMargin(), 0.0f);         assertEquals(vertical2, mToast.getVerticalMargin(), 0.0f);         WindowManager.LayoutParams params2 = (WindowManager.LayoutParams) view.getLayoutParams();         assertEquals(horizontal2, params2.horizontalMargin, 0.0f);         assertEquals(vertical2, params2.verticalMargin, 0.0f);          assertLayoutDone(view);         int[] xy2 = new int[2];         view.getLocationOnScreen(xy2);         assertShowAndHide(view);          /** Check if the test is being run on a watch.          *          * Change I8180e5080e0a6860b40dbb2faa791f0ede926ca7 updated how toast are displayed on the          * watch. Unlike the phone, which displays toast centered horizontally at the bottom of the          * screen, the watch now displays toast in the center of the screen.          */         if (Gravity.CENTER == mToast.getGravity()) {             assertTrue(xy1[0] > xy2[0]);             assertTrue(xy1[1] > xy2[1]);         } else {             assertTrue(xy1[0] > xy2[0]);             assertTrue(xy1[1] < xy2[1]);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testAccessGravity"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"public void testAccessGravity() throws Throwable {         assumeFalse(""Skipping test: Auto does not support toast with gravity"", isCar());          makeToast();         runOnMainAndDrawSync(mToast.getView(), () -> {             mToast.setGravity(Gravity.CENTER, 0, 0);             mToast.show();             registerLayoutListener(mToast.getView());         });         View view = mToast.getView();         assertShowToast(view);         assertEquals(Gravity.CENTER, mToast.getGravity());         assertEquals(0, mToast.getXOffset());         assertEquals(0, mToast.getYOffset());         assertLayoutDone(view);         int[] centerXY = new int[2];         view.getLocationOnScreen(centerXY);         assertShowAndHide(view);          runOnMainAndDrawSync(mToast.getView(), () -> {             mToast.setGravity(Gravity.BOTTOM, 0, 0);             mToast.show();             registerLayoutListener(mToast.getView());         });         view = mToast.getView();         assertShowToast(view);         assertEquals(Gravity.BOTTOM, mToast.getGravity());         assertEquals(0, mToast.getXOffset());         assertEquals(0, mToast.getYOffset());         assertLayoutDone(view);         int[] bottomXY = new int[2];         view.getLocationOnScreen(bottomXY);         assertShowAndHide(view);          // x coordinate is the same         assertEquals(centerXY[0], bottomXY[0]);         // bottom view is below of center view         assertTrue(centerXY[1] < bottomXY[1]);          final int xOffset = 20;         final int yOffset = 10;         runOnMainAndDrawSync(mToast.getView(), () -> {             mToast.setGravity(Gravity.BOTTOM, xOffset, yOffset);             mToast.show();             registerLayoutListener(mToast.getView());         });         view = mToast.getView();         assertShowToast(view);         assertEquals(Gravity.BOTTOM, mToast.getGravity());         assertEquals(xOffset, mToast.getXOffset());         assertEquals(yOffset, mToast.getYOffset());         assertLayoutDone(view);         int[] bottomOffsetXY = new int[2];         view.getLocationOnScreen(bottomOffsetXY);         assertShowAndHide(view);          assertEquals(bottomXY[0] + xOffset, bottomOffsetXY[0]);         assertEquals(bottomXY[1] - yOffset, bottomOffsetXY[1]);     }      @UiThreadTest"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testTextToastAllowed_whenInTheForeground"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"public void testTextToastAllowed_whenInTheForeground() throws Throwable {         makeToast();         View view = mToast.getView();          mActivityRule.runOnUiThread(mToast::show);          assertShowAndHide(view);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testCustomToastAllowed_whenInTheForeground"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"public void testCustomToastAllowed_whenInTheForeground() throws Throwable {         makeCustomToast();         View view = mToast.getView();         // View has not been attached to screen yet         assertNull(view.getParent());          mActivityRule.runOnUiThread(mToast::show);          assertShowAndHide(view);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testTextToastAllowed_whenInTheBackground"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"public void testTextToastAllowed_whenInTheBackground() throws Throwable {         // Make it background         mActivityRule.finishActivity();         makeToast();         View view = mToast.getView();          mActivityRule.runOnUiThread(mToast::show);          assertShowAndHide(view);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.widget.cts29.ToastTest"	"testCustomToastAllowed_whenInTheBackground"	"CtsWidgetTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/widget29/src/android/widget/cts29/ToastTest.java"	""	"public void testCustomToastAllowed_whenInTheBackground() throws Throwable {         // Make it background         mActivityRule.finishActivity();         makeCustomToast();         View view = mToast.getView();         // View has not been attached to screen yet         assertNull(view.getParent());          mActivityRule.runOnUiThread(mToast::show);          assertShowAndHide(view);     }      @UiThreadTest"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.provider.cts.media.MediaStore_Audio_AlbumsTest"	"testAlbumArt"	"CtsProviderTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Audio_AlbumsTest.java"	""	"public void testAlbumArt() throws Exception {         final File dir = ProviderTestUtils.stageDir(mVolumeName);         final File path = new File(dir, ""test"" + System.currentTimeMillis() + "".mp3"");         try {             ProviderTestUtils.stageFile(R.raw.testmp3, path);              ContentValues v = new ContentValues();             v.put(Media.DATA, path.getAbsolutePath());             v.put(Media.TITLE, ""testing"");             v.put(Albums.ALBUM, ""test"" + System.currentTimeMillis());              final Uri mediaUri = mContentResolver                     .insert(MediaStore.Audio.Media.getContentUri(mVolumeName), v);             final long mediaId = ContentUris.parseId(mediaUri);              final long albumId;             try (Cursor c = mContentResolver.query(mediaUri, null, null, null, null)) {                 assertTrue(c.moveToFirst());                 albumId = c.getLong(c.getColumnIndex(Albums.ALBUM_ID));             }              final Uri albumUri = ContentUris                     .withAppendedId(MediaStore.Audio.Albums.getContentUri(mVolumeName), albumId);              // Verify that normal thumbnails work             assertNotNull(mContentResolver.loadThumbnail(mediaUri, new Size(32, 32), null));             assertNotNull(mContentResolver.loadThumbnail(albumUri, new Size(32, 32), null));              // Verify that hidden APIs still work to obtain album art             final Uri byMedia = MediaStore.AUTHORITY_URI.buildUpon().appendPath(mVolumeName)                     .appendPath(""audio"").appendPath(""media"")                     .appendPath(Long.toString(mediaId)).appendPath(""albumart"").build();             final Uri byAlbum = MediaStore.AUTHORITY_URI.buildUpon().appendPath(mVolumeName)                     .appendPath(""audio"").appendPath(""albumart"")                     .appendPath(Long.toString(albumId)).build();             assertNotNull(BitmapFactory.decodeStream(mContentResolver.openInputStream(byMedia)));             assertNotNull(BitmapFactory.decodeStream(mContentResolver.openInputStream(byAlbum)));              // Delete item and confirm art is cleaned up             mContentResolver.delete(mediaUri, null, null);             MediaStore.waitForIdle(mContentResolver);              try {                 mContentResolver.loadThumbnail(mediaUri, new Size(32, 32), null);                 fail();             } catch (IOException expected) {             }             try {                 mContentResolver.loadThumbnail(albumUri, new Size(32, 32), null);                 fail();             } catch (IOException expected) {             }             try {                 BitmapFactory.decodeStream(mContentResolver.openInputStream(byMedia));                 fail();             } catch (IOException expected) {             }             try {                 BitmapFactory.decodeStream(mContentResolver.openInputStream(byAlbum));                 fail();             } catch (IOException expected) {             }          } finally {             path.delete();         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.renderscript.cts.ElementTest"	"testDataType"	"CtsRenderscriptTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/renderscript/src/android/renderscript/cts/ElementTest.java"	""	"public void testDataType() {         // Uncomment when NONE is no longer hidden.         //assertEquals(DataType.NONE, DataType.valueOf(""NONE""));          assertEquals(DataType.FLOAT_16, DataType.valueOf(""FLOAT_16""));         assertEquals(DataType.FLOAT_32, DataType.valueOf(""FLOAT_32""));         assertEquals(DataType.FLOAT_64, DataType.valueOf(""FLOAT_64""));         assertEquals(DataType.SIGNED_8, DataType.valueOf(""SIGNED_8""));         assertEquals(DataType.SIGNED_16, DataType.valueOf(""SIGNED_16""));         assertEquals(DataType.SIGNED_32, DataType.valueOf(""SIGNED_32""));         assertEquals(DataType.SIGNED_64, DataType.valueOf(""SIGNED_64""));         assertEquals(DataType.UNSIGNED_8, DataType.valueOf(""UNSIGNED_8""));         assertEquals(DataType.UNSIGNED_16, DataType.valueOf(""UNSIGNED_16""));         assertEquals(DataType.UNSIGNED_32, DataType.valueOf(""UNSIGNED_32""));         assertEquals(DataType.UNSIGNED_64, DataType.valueOf(""UNSIGNED_64""));          assertEquals(DataType.BOOLEAN, DataType.valueOf(""BOOLEAN""));          assertEquals(DataType.UNSIGNED_5_6_5, DataType.valueOf(""UNSIGNED_5_6_5""));         assertEquals(DataType.UNSIGNED_5_5_5_1, DataType.valueOf(""UNSIGNED_5_5_5_1""));         assertEquals(DataType.UNSIGNED_4_4_4_4, DataType.valueOf(""UNSIGNED_4_4_4_4""));          assertEquals(DataType.MATRIX_4X4, DataType.valueOf(""MATRIX_4X4""));         assertEquals(DataType.MATRIX_3X3, DataType.valueOf(""MATRIX_3X3""));         assertEquals(DataType.MATRIX_2X2, DataType.valueOf(""MATRIX_2X2""));          assertEquals(DataType.RS_ELEMENT, DataType.valueOf(""RS_ELEMENT""));         assertEquals(DataType.RS_TYPE, DataType.valueOf(""RS_TYPE""));         assertEquals(DataType.RS_ALLOCATION, DataType.valueOf(""RS_ALLOCATION""));         assertEquals(DataType.RS_SAMPLER, DataType.valueOf(""RS_SAMPLER""));         assertEquals(DataType.RS_SCRIPT, DataType.valueOf(""RS_SCRIPT""));         assertEquals(DataType.RS_MESH, DataType.valueOf(""RS_MESH""));         assertEquals(DataType.RS_PROGRAM_FRAGMENT, DataType.valueOf(""RS_PROGRAM_FRAGMENT""));         assertEquals(DataType.RS_PROGRAM_VERTEX, DataType.valueOf(""RS_PROGRAM_VERTEX""));         assertEquals(DataType.RS_PROGRAM_RASTER, DataType.valueOf(""RS_PROGRAM_RASTER""));         assertEquals(DataType.RS_PROGRAM_STORE, DataType.valueOf(""RS_PROGRAM_STORE""));         // Make sure no new enums are added         assertEquals(30, DataType.values().length);          for (DataType dt : DataType.values()) {             switch (dt) {             case FLOAT_16:             case FLOAT_32:             case FLOAT_64:             case SIGNED_8:             case SIGNED_16:             case SIGNED_32:             case SIGNED_64:             case UNSIGNED_8:             case UNSIGNED_16:             case UNSIGNED_32:             case UNSIGNED_64:             case BOOLEAN:                 Element.createVector(mRS, dt, 2);                 break;              default: {                 try {                     Element.createVector(mRS, dt, 2);                     fail(""should throw RSIllegalArgumentException"");                 } catch (RSIllegalArgumentException e) {                 }                 break;             }             }         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.autofillservice.cts.augmented.AugmentedLoginActivityTest"	"testAugmentedAutoFill_callback"	"CtsAutoFillServiceTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/augmented/AugmentedLoginActivityTest.java"	""	"public void testAugmentedAutoFill_callback() throws Exception {         // Set services         enableService();         enableAugmentedService();          // Set expectations         final MyAutofillCallback callback = mActivity.registerCallback();         final EditText username = mActivity.getUsername();         final AutofillId usernameId = username.getAutofillId();         final AutofillValue usernameValue = username.getAutofillValue();         sReplier.addResponse(NO_RESPONSE);         sAugmentedReplier.addResponse(new CannedAugmentedFillResponse.Builder()                 .setDataset(new CannedAugmentedFillResponse.Dataset.Builder(""req1"")                         .build(), usernameId)                 .build());          // Trigger autofill         mActivity.onUsername(View::requestFocus);         sReplier.getNextFillRequest();         final AugmentedFillRequest request1 = sAugmentedReplier.getNextFillRequest();          // Assert request         assertBasicRequestInfo(request1, mActivity, usernameId, usernameValue);          // Make sure standard Autofill UI is not shown.         mUiBot.assertNoDatasetsEver();          // Make sure Augmented Autofill UI is shown.         callback.assertUiShownEvent(username);         mAugmentedUiBot.assertUiShown(usernameId, ""req1"");          // Move focus away to make sure Augmented Autofill UI is gone.         mActivity.onLogin(View::requestFocus);         mAugmentedUiBot.assertUiGone();         callback.assertUiHiddenEvent(username);          // Tap on password field         final EditText password = mActivity.getPassword();         final AutofillId passwordId = password.getAutofillId();         final AutofillValue passwordValue = password.getAutofillValue();         sAugmentedReplier.addResponse(new CannedAugmentedFillResponse.Builder()                 .setDataset(new CannedAugmentedFillResponse.Dataset.Builder(""req2"")                         .build(), passwordId)                 .build());         mActivity.onPassword(View::requestFocus);         mUiBot.assertNoDatasetsEver();          // (TODO: b/141703197) password request temp disabled.         callback.assertNotCalled();         mAugmentedUiBot.assertUiGone();         sAugmentedReplier.reset();          // Tap on username again...         sAugmentedReplier.addResponse(new CannedAugmentedFillResponse.Builder()                 .setDataset(new CannedAugmentedFillResponse.Dataset.Builder(""Augment Me"")                         .setField(usernameId, ""dude"")                         .setField(passwordId, ""sweet"")                         .build(), usernameId)                 .build());          mActivity.onUsername(View::requestFocus);         final AugmentedFillRequest request3 = sAugmentedReplier.getNextFillRequest();         assertBasicRequestInfo(request3, mActivity, usernameId, usernameValue);         final UiObject2 ui = mAugmentedUiBot.assertUiShown(usernameId, ""Augment Me"");         callback.assertUiShownEvent(username);          // ...and autofill this time         mActivity.expectAutoFill(""dude"", ""sweet"");         ui.click();         mActivity.assertAutoFilled();         mAugmentedUiBot.assertUiGone();         callback.assertUiHiddenEvent(username);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.telephony.cts.TelephonyManagerTest"	"testTelephonyManager"	"CtsTelephonyTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	"public void testTelephonyManager() {         assertTrue(mTelephonyManager.getNetworkType() >= TelephonyManager.NETWORK_TYPE_UNKNOWN);         assertTrue(mTelephonyManager.getPhoneType() >= TelephonyManager.PHONE_TYPE_NONE);         assertTrue(mTelephonyManager.getSimState() >= TelephonyManager.SIM_STATE_UNKNOWN);         assertTrue(mTelephonyManager.getDataActivity() >= TelephonyManager.DATA_ACTIVITY_NONE);         assertTrue(mTelephonyManager.getDataState() >= TelephonyManager.DATA_DISCONNECTED);         assertTrue(mTelephonyManager.getCallState() >= TelephonyManager.CALL_STATE_IDLE);          for (int i = 0; i < mTelephonyManager.getPhoneCount(); ++i) {             assertTrue(mTelephonyManager.getSimState(i) >= TelephonyManager.SIM_STATE_UNKNOWN);         }          // Make sure devices without MMS service won't fail on this         if (InstrumentationRegistry.getContext().getPackageManager()                 .hasSystemFeature(PackageManager.FEATURE_TELEPHONY)                 && (mTelephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_NONE)) {             assertFalse(mTelephonyManager.getMmsUserAgent().isEmpty());             assertFalse(mTelephonyManager.getMmsUAProfUrl().isEmpty());         }          // The following methods may return any value depending on the state of the device. Simply         // call them to make sure they do not throw any exceptions.         mTelephonyManager.getVoiceMailNumber();         mTelephonyManager.getSimOperatorName();         mTelephonyManager.getNetworkCountryIso();         mTelephonyManager.getCellLocation();         mTelephonyManager.getSimCarrierId();         mTelephonyManager.getSimCarrierIdName();         mTelephonyManager.getSimSpecificCarrierId();         mTelephonyManager.getSimSpecificCarrierIdName();         mTelephonyManager.getCarrierIdFromSimMccMnc();         mTelephonyManager.isDataRoamingEnabled();         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.getSimSerialNumber());         mTelephonyManager.getSimOperator();         mTelephonyManager.getSignalStrength();         mTelephonyManager.getNetworkOperatorName();         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.getSubscriberId());         mTelephonyManager.getLine1Number();         mTelephonyManager.getNetworkOperator();         mTelephonyManager.getSimCountryIso();         mTelephonyManager.getVoiceMailAlphaTag();         mTelephonyManager.isNetworkRoaming();         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.getDeviceId());         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.getDeviceId(mTelephonyManager.getSlotIndex()));         mTelephonyManager.getDeviceSoftwareVersion();         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.getDeviceSoftwareVersion(mTelephonyManager.getSlotIndex()));         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.getImei());         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.getImei(mTelephonyManager.getSlotIndex()));         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.isManualNetworkSelectionAllowed());         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.getManualNetworkSelectionPlmn());          mTelephonyManager.getPhoneCount();         mTelephonyManager.getDataEnabled();         mTelephonyManager.getNetworkSpecifier();         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager, (tm) -> tm.getNai());         TelecomManager telecomManager = getContext().getSystemService(TelecomManager.class);         PhoneAccountHandle defaultAccount = telecomManager                 .getDefaultOutgoingPhoneAccount(PhoneAccount.SCHEME_TEL);         mTelephonyManager.getVoicemailRingtoneUri(defaultAccount);         mTelephonyManager.isVoicemailVibrationEnabled(defaultAccount);         mTelephonyManager.getSubscriptionId(defaultAccount);         mTelephonyManager.getCarrierConfig();         mTelephonyManager.isVoiceCapable();         mTelephonyManager.isSmsCapable();         mTelephonyManager.isLteCdmaEvdoGsmWcdmaEnabled();         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.isDataConnectionAllowed());         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.isAnyRadioPoweredOn());         ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,                 (tm) -> tm.resetIms(tm.getSlotIndex()));          // Verify TelephonyManager.getCarrierPrivilegeStatus         List<Integer> validCarrierPrivilegeStatus = new ArrayList<>();         validCarrierPrivilegeStatus.add(TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS);         validCarrierPrivilegeStatus.add(TelephonyManager.CARRIER_PRIVILEGE_STATUS_NO_ACCESS);         validCarrierPrivilegeStatus.add(                 TelephonyManager.CARRIER_PRIVILEGE_STATUS_RULES_NOT_LOADED);         validCarrierPrivilegeStatus.add(                 TelephonyManager.CARRIER_PRIVILEGE_STATUS_ERROR_LOADING_RULES);         int carrierPrivilegeStatusResult = ShellIdentityUtils.invokeMethodWithShellPermissions(                 mTelephonyManager, (tm) -> tm.getCarrierPrivilegeStatus(Process.myUid()));         assertTrue(validCarrierPrivilegeStatus.contains(carrierPrivilegeStatusResult));          // Verify TelephonyManager.getCarrierPrivilegedPackagesForAllActiveSubscriptions         List<String> resultForGetCarrierPrivilegedApis =                 ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                         (tm) -> tm.getCarrierPrivilegedPackagesForAllActiveSubscriptions());         assertNotNull(resultForGetCarrierPrivilegedApis);         for (String result : resultForGetCarrierPrivilegedApis) {             assertFalse(TextUtils.isEmpty(result));         }          mTelephonyManager.getDefaultRespondViaMessageApplication();         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 TelephonyManager::getAndUpdateDefaultRespondViaMessageApplication);     }      /**      * Due to the corresponding API is hidden in R and will be public in S, this test      * is commented and will be un-commented in Android S.      *"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.telephony.cts.TelephonyManagerTest"	"testGetCallForwarding"	"CtsTelephonyTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	"public void testGetCallForwarding() {         List<Integer> callForwardingReasons = new ArrayList<>();         callForwardingReasons.add(CallForwardingInfo.REASON_UNCONDITIONAL);         callForwardingReasons.add(CallForwardingInfo.REASON_BUSY);         callForwardingReasons.add(CallForwardingInfo.REASON_NO_REPLY);         callForwardingReasons.add(CallForwardingInfo.REASON_NOT_REACHABLE);         callForwardingReasons.add(CallForwardingInfo.REASON_ALL);         callForwardingReasons.add(CallForwardingInfo.REASON_ALL_CONDITIONAL);          Set<Integer> callForwardingStatus = new HashSet<Integer>();         callForwardingStatus.add(CallForwardingInfo.STATUS_INACTIVE);         callForwardingStatus.add(CallForwardingInfo.STATUS_ACTIVE);         callForwardingStatus.add(CallForwardingInfo.STATUS_FDN_CHECK_FAILURE);         callForwardingStatus.add(CallForwardingInfo.STATUS_UNKNOWN_ERROR);         callForwardingStatus.add(CallForwardingInfo.STATUS_NOT_SUPPORTED);          for (int callForwardingReasonToGet : callForwardingReasons) {             Log.d(TAG, ""[testGetCallForwarding] callForwardingReasonToGet: ""                     + callForwardingReasonToGet);             CallForwardingInfo callForwardingInfo =                     ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                             (tm) -> tm.getCallForwarding(callForwardingReasonToGet));              assertNotNull(callForwardingInfo);             assertTrue(callForwardingStatus.contains(callForwardingInfo.getStatus()));             assertTrue(callForwardingReasons.contains(callForwardingInfo.getReason()));             callForwardingInfo.getNumber();             assertTrue(callForwardingInfo.getTimeoutSeconds() >= 0);         }     }      */      /**      * Due to the corresponding API is hidden in R and will be public in S, this test      * is commented and will be un-commented in Android S.      *"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.telephony.cts.TelephonyManagerTest"	"testSetCallForwarding"	"CtsTelephonyTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	"public void testSetCallForwarding() {         List<Integer> callForwardingReasons = new ArrayList<>();         callForwardingReasons.add(CallForwardingInfo.REASON_UNCONDITIONAL);         callForwardingReasons.add(CallForwardingInfo.REASON_BUSY);         callForwardingReasons.add(CallForwardingInfo.REASON_NO_REPLY);         callForwardingReasons.add(CallForwardingInfo.REASON_NOT_REACHABLE);         callForwardingReasons.add(CallForwardingInfo.REASON_ALL);         callForwardingReasons.add(CallForwardingInfo.REASON_ALL_CONDITIONAL);          // Enable Call Forwarding         for (int callForwardingReasonToEnable : callForwardingReasons) {             final CallForwardingInfo callForwardingInfoToEnable = new CallForwardingInfo(                     CallForwardingInfo.STATUS_ACTIVE,                     callForwardingReasonToEnable,                     TEST_FORWARD_NUMBER,                     // time seconds                     1);             Log.d(TAG, ""[testSetCallForwarding] Enable Call Forwarding. Status: ""                     + CallForwardingInfo.STATUS_ACTIVE + "" Reason: ""                     + callForwardingReasonToEnable + "" Number: "" + TEST_FORWARD_NUMBER                     + "" Time Seconds: 1"");             ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                     (tm) -> tm.setCallForwarding(callForwardingInfoToEnable));         }          // Disable Call Forwarding         for (int callForwardingReasonToDisable : callForwardingReasons) {             final CallForwardingInfo callForwardingInfoToDisable = new CallForwardingInfo(                     CallForwardingInfo.STATUS_INACTIVE,                     callForwardingReasonToDisable,                     TEST_FORWARD_NUMBER,                     // time seconds                     1);             Log.d(TAG, ""[testSetCallForwarding] Disable Call Forwarding. Status: ""                     + CallForwardingInfo.STATUS_INACTIVE + "" Reason: ""                     + callForwardingReasonToDisable + "" Number: "" + TEST_FORWARD_NUMBER                     + "" Time Seconds: 1"");             ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                     (tm) -> tm.setCallForwarding(callForwardingInfoToDisable));         }     }     */      /**      * Due to the corresponding API is hidden in R and will be public in S, this test      * is commented and will be un-commented in Android S.      *"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.telephony.cts.TelephonyManagerTest"	"testGetCallWaitingStatus"	"CtsTelephonyTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	"public void testGetCallWaitingStatus() {         Set<Integer> callWaitingStatus = new HashSet<Integer>();         callWaitingStatus.add(TelephonyManager.CALL_WAITING_STATUS_ACTIVE);         callWaitingStatus.add(TelephonyManager.CALL_WAITING_STATUS_INACTIVE);         callWaitingStatus.add(TelephonyManager.CALL_WAITING_STATUS_UNKNOWN_ERROR);         callWaitingStatus.add(TelephonyManager.CALL_WAITING_STATUS_NOT_SUPPORTED);          int status = ShellIdentityUtils.invokeMethodWithShellPermissions(                 mTelephonyManager, (tm) -> tm.getCallWaitingStatus());         assertTrue(callWaitingStatus.contains(status));     }      */      /**      * Due to the corresponding API is hidden in R and will be public in S, this test      * is commented and will be un-commented in Android S.      *"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-2"	""	"android.telephony.cts.TelephonyManagerTest"	"testGetIsimDomain"	"CtsTelephonyTestCases"	""	"7.2.4/C-3-2"	"""C-3-2] MUST report only android.hardware.faketouch. """	""	"faketouch android.hardware.faketouch hid"	""	""	""	"hid"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	"public void testGetIsimDomain() {         if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {             return;         }         ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,                 (tm) -> tm.getIsimDomain());     }      /**      * Verifies that {@link TelephonyManager#getIsimImpu()} does not throw any exception when called      * and has the correct permissions.      */     @Ignore(""API moved back to @hide for Android R."")"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.app.cts.SystemFeaturesTest"	"testTouchScreenFeatures"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"TOUCHSCREEN_NOTOUCH"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.app.cts.SystemFeaturesTest"	"testFakeTouchFeatures"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"TOUCHSCREEN_NOTOUCH"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.app.cts.SystemFeaturesTest"	"testTouchScreenFeatures"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.app.cts.SystemFeaturesTest"	"testFakeTouchFeatures"	"CtsAndroidAppTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigurationTest"	"testSetToDefaults"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigurationTest.java"	""	"public void testSetToDefaults() {         final Configuration config = new Configuration(mConfig);         assertFalse(config.equals(mConfigDefault));          config.setToDefaults();         assertTrue(config.equals(mConfigDefault));          assertEquals(1.0f, config.fontScale);         assertEquals(0, config.mcc);         assertEquals(0, config.mnc);         assertTrue(config.getLocales().isEmpty());         assertEquals(null, config.locale);         assertFalse(config.userSetLocale);         assertEquals(Configuration.TOUCHSCREEN_UNDEFINED, config.touchscreen);         assertEquals(Configuration.KEYBOARD_UNDEFINED, config.keyboard);         assertEquals(Configuration.KEYBOARDHIDDEN_UNDEFINED, config.keyboardHidden);         assertEquals(Configuration.HARDKEYBOARDHIDDEN_UNDEFINED, config.hardKeyboardHidden);         assertEquals(Configuration.NAVIGATION_UNDEFINED, config.navigation);         assertEquals(Configuration.NAVIGATIONHIDDEN_UNDEFINED, config.navigationHidden);         assertEquals(Configuration.ORIENTATION_UNDEFINED, config.orientation);         assertEquals(Configuration.SCREENLAYOUT_UNDEFINED, config.screenLayout);         assertEquals(Configuration.UI_MODE_TYPE_UNDEFINED, config.uiMode);         assertEquals(Configuration.SCREEN_WIDTH_DP_UNDEFINED, config.screenWidthDp);         assertEquals(Configuration.SCREEN_WIDTH_DP_UNDEFINED, config.compatScreenWidthDp);         assertEquals(Configuration.SCREEN_HEIGHT_DP_UNDEFINED, config.screenHeightDp);         assertEquals(Configuration.SCREEN_HEIGHT_DP_UNDEFINED, config.compatScreenHeightDp);         assertEquals(Configuration.SMALLEST_SCREEN_WIDTH_DP_UNDEFINED,                 config.smallestScreenWidthDp);         assertEquals(Configuration.DENSITY_DPI_UNDEFINED, config.densityDpi);         assertEquals(Configuration.COLOR_MODE_UNDEFINED, config.colorMode);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigurationTest"	"testUnset"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigurationTest.java"	""	"public void testUnset() {         Configuration config = new Configuration();         assertEquals(0.0f, config.fontScale);         assertEquals(0, config.mcc);         assertEquals(0, config.mnc);         assertTrue(config.getLocales().isEmpty());         assertEquals(null, config.locale);         assertFalse(config.userSetLocale);         assertEquals(Configuration.TOUCHSCREEN_UNDEFINED, config.touchscreen);         assertEquals(Configuration.KEYBOARD_UNDEFINED, config.keyboard);         assertEquals(Configuration.KEYBOARDHIDDEN_UNDEFINED, config.keyboardHidden);         assertEquals(Configuration.HARDKEYBOARDHIDDEN_UNDEFINED, config.hardKeyboardHidden);         assertEquals(Configuration.NAVIGATION_UNDEFINED, config.navigation);         assertEquals(Configuration.NAVIGATIONHIDDEN_UNDEFINED, config.navigationHidden);         assertEquals(Configuration.ORIENTATION_UNDEFINED, config.orientation);         assertEquals(Configuration.SCREENLAYOUT_UNDEFINED, config.screenLayout);         assertEquals(Configuration.UI_MODE_TYPE_UNDEFINED, config.uiMode);         assertEquals(Configuration.SCREEN_WIDTH_DP_UNDEFINED, config.screenWidthDp);         assertEquals(Configuration.SCREEN_WIDTH_DP_UNDEFINED, config.compatScreenWidthDp);         assertEquals(Configuration.SCREEN_HEIGHT_DP_UNDEFINED, config.screenHeightDp);         assertEquals(Configuration.SCREEN_HEIGHT_DP_UNDEFINED, config.compatScreenHeightDp);         assertEquals(Configuration.SMALLEST_SCREEN_WIDTH_DP_UNDEFINED,                 config.smallestScreenWidthDp);         assertEquals(Configuration.DENSITY_DPI_UNDEFINED, config.densityDpi);         assertEquals(Configuration.COLOR_MODE_UNDEFINED, config.colorMode);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigurationTest"	"testSetLocale_overridesSetLocales"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigurationTest.java"	""	"public void testSetLocale_overridesSetLocales() {         Configuration config = new Configuration();         config.setLocales(LocaleList.forLanguageTags(""az-Arab,en""));         config.setLocale(Locale.ENGLISH);          assertEquals(Locale.ENGLISH, config.locale);         assertEquals(new LocaleList(Locale.ENGLISH), config.getLocales());         assertEquals(View.LAYOUT_DIRECTION_LTR, config.getLayoutDirection());     }      private Configuration createConfig(LocaleList list) {         Configuration config = createConfig();         config.setLocales(list);         return config;     }      private Configuration createConfig(Locale locale) {         Configuration config = createConfig();         config.locale = locale;         return config;     }      private Configuration createConfig() {         Configuration config = new Configuration();         config.fontScale = 13.37f;         config.mcc = 0;         config.mnc = 1;         config.touchscreen = Configuration.TOUCHSCREEN_STYLUS;         config.keyboard = Configuration.KEYBOARD_UNDEFINED;         config.keyboardHidden = Configuration.KEYBOARDHIDDEN_YES;         config.hardKeyboardHidden = Configuration.KEYBOARDHIDDEN_UNDEFINED;         config.navigation = Configuration.NAVIGATION_DPAD;         config.navigationHidden = Configuration.NAVIGATIONHIDDEN_UNDEFINED;         config.orientation = Configuration.ORIENTATION_PORTRAIT;         config.screenLayout = Configuration.SCREENLAYOUT_LONG_UNDEFINED;         return config;     }      private void assertWriteToParcel(Configuration config) {         final Parcel parcel = Parcel.obtain();         try {             config.writeToParcel(parcel, 0);             parcel.setDataPosition(0);             Configuration readConf = new Configuration();             readConf.readFromParcel(parcel);             assertEquals(config, readConf);         } finally {             parcel.recycle();         }     } }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.server.wm.ActivityManagerGetConfigTests"	"isLowRamDevice"	"CtsWindowManagerDeviceTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityManagerGetConfigTests.java"	""	"/*  *.  */  package android.server.wm;  import static androidx.test.InstrumentationRegistry.getInstrumentation;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals;  import android.app.ActivityManager; import android.app.KeyguardManager; import android.content.Context; import android.content.nano.DeviceConfigurationProto; import android.content.nano.GlobalConfigurationProto; import android.content.nano.LocaleProto; import android.content.nano.ResourcesConfigurationProto; import android.content.pm.ConfigurationInfo; import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.content.pm.SharedLibraryInfo; import android.content.res.Configuration; import android.hardware.display.DisplayManager; import android.opengl.GLES10; import android.os.Build; import android.os.LocaleList; import android.os.ParcelFileDescriptor; import android.platform.test.annotations.Presubmit; import android.text.TextUtils; import android.util.DisplayMetrics; import android.view.Display;  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;  import org.junit.Before; import org.junit.Test;  import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.HashSet; import java.util.List; import java.util.Set;  import javax.microedition.khronos.egl.EGL10; import javax.microedition.khronos.egl.EGLConfig; import javax.microedition.khronos.egl.EGLContext; import javax.microedition.khronos.egl.EGLDisplay; import javax.microedition.khronos.egl.EGLSurface;  @Presubmit public class ActivityManagerGetConfigTests {     Context mContext;     ActivityManager mAm;     PackageManager mPm;      @Before     public void setUp() throws Exception {         mContext = getInstrumentation().getTargetContext();         mAm = mContext.getSystemService(ActivityManager.class);         mPm = mContext.getPackageManager();     }      private byte[] executeShellCommand(String cmd) {         try {             ParcelFileDescriptor pfd = getInstrumentation().getUiAutomation()                     .executeShellCommand(cmd);             byte[] buf = new byte[512];             int bytesRead;             FileInputStream fis = new ParcelFileDescriptor.AutoCloseInputStream(pfd);             ByteArrayOutputStream stdout = new ByteArrayOutputStream();             while ((bytesRead = fis.read(buf)) != -1) {                 stdout.write(buf, 0, bytesRead);             }             fis.close();             return stdout.toByteArray();         } catch (IOException e) {             throw new RuntimeException(e);         }     }      /**      * Adds all supported GL extensions for a provided EGLConfig to a set by creating an EGLContext      * and EGLSurface and querying extensions.      *      * @param egl An EGL API object      * @param display An EGLDisplay to create a context and surface with      * @param config The EGLConfig to get the extensions for      * @param surfaceSize eglCreatePbufferSurface generic parameters      * @param contextAttribs eglCreateContext generic parameters      * @param glExtensions A Set<String> to add GL extensions to      */     private static void addExtensionsForConfig(             EGL10 egl,             EGLDisplay display,             EGLConfig config,             int[] surfaceSize,             int[] contextAttribs,             Set<String> glExtensions) {         // Create a context.         EGLContext context =                 egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT, contextAttribs);         // No-op if we can't create a context.         if (context == EGL10.EGL_NO_CONTEXT) {             return;         }          // Create a surface.         EGLSurface surface = egl.eglCreatePbufferSurface(display, config, surfaceSize);         if (surface == EGL10.EGL_NO_SURFACE) {             egl.eglDestroyContext(display, context);             return;         }          // Update the current surface and context.         egl.eglMakeCurrent(display, surface, surface, context);          // Get the list of extensions.         String extensionList = GLES10.glGetString(GLES10.GL_EXTENSIONS);         if (!TextUtils.isEmpty(extensionList)) {             // The list of extensions comes from the driver separated by spaces.             // Split them apart and add them into a Set for deduping purposes.             for (String extension : extensionList.split("" "")) {                 glExtensions.add(extension);             }         }          // Tear down the context and surface for this config.         egl.eglMakeCurrent(display, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);         egl.eglDestroySurface(display, surface);         egl.eglDestroyContext(display, context);     }       Set<String> getGlExtensionsFromDriver() {         Set<String> glExtensions = new HashSet<>();          // Get the EGL implementation.         EGL10 egl = (EGL10) EGLContext.getEGL();         if (egl == null) {             throw new RuntimeException(""Warning: couldn't get EGL"");         }          // Get the default display and initialize it.         EGLDisplay display = egl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);         int[] version = new int[2];         egl.eglInitialize(display, version);          // Call getConfigs() in order to find out how many there are.         int[] numConfigs = new int[1];         if (!egl.eglGetConfigs(display, null, 0, numConfigs)) {             throw new RuntimeException(""Warning: couldn't get EGL config count"");         }          // Allocate space for all configs and ask again.         EGLConfig[] configs = new EGLConfig[numConfigs[0]];         if (!egl.eglGetConfigs(display, configs, numConfigs[0], numConfigs)) {             throw new RuntimeException(""Warning: couldn't get EGL configs"");         }          // Allocate surface size parameters outside of the main loop to cut down         // on GC thrashing.  1x1 is enough since we are only using it to get at         // the list of extensions.         int[] surfaceSize =                 new int[] {                         EGL10.EGL_WIDTH, 1,                         EGL10.EGL_HEIGHT, 1,                         EGL10.EGL_NONE                 };          // For when we need to create a GLES2.0 context.         final int EGL_CONTEXT_CLIENT_VERSION = 0x3098;         int[] gles2 = new int[] {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE};          // For getting return values from eglGetConfigAttrib         int[] attrib = new int[1];          for (int i = 0; i < numConfigs[0]; i++) {             // Get caveat for this config in order to skip slow (i.e. software) configs.             egl.eglGetConfigAttrib(display, configs[i], EGL10.EGL_CONFIG_CAVEAT, attrib);             if (attrib[0] == EGL10.EGL_SLOW_CONFIG) {                 continue;             }              // If the config does not support pbuffers we cannot do an eglMakeCurrent             // on it in addExtensionsForConfig(), so skip it here. Attempting to make             // it current with a pbuffer will result in an EGL_BAD_MATCH error             egl.eglGetConfigAttrib(display, configs[i], EGL10.EGL_SURFACE_TYPE, attrib);             if ((attrib[0] & EGL10.EGL_PBUFFER_BIT) == 0) {                 continue;             }              final int EGL_OPENGL_ES_BIT = 0x0001;             final int EGL_OPENGL_ES2_BIT = 0x0004;             egl.eglGetConfigAttrib(display, configs[i], EGL10.EGL_RENDERABLE_TYPE, attrib);             if ((attrib[0] & EGL_OPENGL_ES_BIT) != 0) {                 addExtensionsForConfig(egl, display, configs[i], surfaceSize, null, glExtensions);             }             if ((attrib[0] & EGL_OPENGL_ES2_BIT) != 0) {                 addExtensionsForConfig(egl, display, configs[i], surfaceSize, gles2, glExtensions);             }         }          // Release all EGL resources.         egl.eglTerminate(display);          return glExtensions;     }      private void checkResourceConfig(Configuration config, DisplayMetrics metrics,             ResourcesConfigurationProto resConfig) {         final int width, height;         if (metrics.widthPixels >= metrics.heightPixels) {             width = metrics.widthPixels;             height = metrics.heightPixels;         } else {             //noinspection SuspiciousNameCombination             width = metrics.heightPixels;             //noinspection SuspiciousNameCombination             height = metrics.widthPixels;         }          assertEquals(""Expected SDK version does not match"",                 Build.VERSION.RESOURCES_SDK_INT, resConfig.sdkVersion);         assertEquals(""Expected screen width px does not match"",                 width, resConfig.screenWidthPx);         assertEquals(""Expected screen width px does not match"",                 height, resConfig.screenHeightPx);          assertEquals(""Expected font scale does not match"",                 config.fontScale, resConfig.configuration.fontScale, Float.MIN_VALUE*5);         assertEquals(""Expected mcc does not match"",                 config.mcc, resConfig.configuration.mcc);         assertEquals(""Expected mnc does not match"",                 config.mnc, resConfig.configuration.mnc);         LocaleList llist = config.getLocales();         LocaleList lprotos = LocaleList.forLanguageTags(resConfig.configuration.localeList);         assertEquals(""Expected number of locales does not match"", llist.size(), lprotos.size());         for (int i = 0; i < llist.size(); i++) {             assertEquals(""Expected locale #"" + i + "" does not match"",                     llist.get(i).toLanguageTag(), lprotos.get(i).toLanguageTag());         }         assertEquals(""Expected screen layout does not match"",                 config.screenLayout, resConfig.configuration.screenLayout);         assertEquals(""Expected color mode does not match"",                 config.colorMode, resConfig.configuration.colorMode);         assertEquals(""Expected touchscreen does not match"",                 config.touchscreen, resConfig.configuration.touchscreen);         assertEquals(""Expected keyboard does not match"",                 config.keyboard, resConfig.configuration.keyboard);         assertEquals(""Expected keyboard hidden does not match"",                 config.keyboardHidden, resConfig.configuration.keyboardHidden);         assertEquals(""Expected hard keyboard hidden does not match"",                 config.hardKeyboardHidden, resConfig.configuration.hardKeyboardHidden);         assertEquals(""Expected navigation does not match"",                 config.navigation, resConfig.configuration.navigation);         assertEquals(""Expected navigation hidden does not match"",                 config.navigationHidden, resConfig.configuration.navigationHidden);         assertEquals(""Expected orientation does not match"",                 config.orientation, resConfig.configuration.orientation);         assertEquals(""Expected UI mode does not match"",                 config.uiMode, resConfig.configuration.uiMode);         assertEquals(""Expected screen width dp does not match"",                 config.screenWidthDp, resConfig.configuration.screenWidthDp);         assertEquals(""Expected screen hight dp does not match"",                 config.screenHeightDp, resConfig.configuration.screenHeightDp);         assertEquals(""Expected smallest screen width dp does not match"",                 config.smallestScreenWidthDp, resConfig.configuration.smallestScreenWidthDp);         assertEquals(""Expected density dpi does not match"",                 config.densityDpi, resConfig.configuration.densityDpi);         // XXX not comparing windowConfiguration, since by definition this is contextual.     }      private void checkDeviceConfig(DisplayMetrics displayMetrics,             DeviceConfigurationProto deviceConfig) {         assertEquals(""Expected stable screen width does not match"",                 displayMetrics.widthPixels, deviceConfig.stableScreenWidthPx);         assertEquals(""Expected stable screen height does not match"",                 displayMetrics.heightPixels, deviceConfig.stableScreenHeightPx);         assertEquals(""Expected stable screen density does not match"",                 DisplayMetrics.DENSITY_DEVICE_STABLE, deviceConfig.stableDensityDpi);          assertEquals(""Expected total RAM does not match"",                 mAm.getTotalRam(), deviceConfig.totalRam);         assertEquals(""Expected low RAM does not match"",                 mAm.isLowRamDevice(), deviceConfig.lowRam);         assertEquals(""Expected max cores does not match"",                 Runtime.getRuntime().availableProcessors(), deviceConfig.maxCores);         KeyguardManager kgm = mContext.getSystemService(KeyguardManager.class);         assertEquals(""Expected has secure screen lock does not match"",                 kgm.isDeviceSecure(), deviceConfig.hasSecureScreenLock);          ConfigurationInfo configInfo = mAm.getDeviceConfigurationInfo();         if (configInfo.reqGlEsVersion != ConfigurationInfo.GL_ES_VERSION_UNDEFINED) {             assertEquals(""Expected opengl version does not match"",                     configInfo.reqGlEsVersion, deviceConfig.openglVersion);         }          Set<String> glExtensionsSet = getGlExtensionsFromDriver();         String[] glExtensions = new String[glExtensionsSet.size()];         glExtensions = glExtensionsSet.toArray(glExtensions);         Arrays.sort(glExtensions);         assertArrayEquals(""Expected opengl extensions does not match"",                 glExtensions, deviceConfig.openglExtensions);          List<SharedLibraryInfo> slibs = mPm.getSharedLibraries(0);         Collections.sort(slibs, Comparator.comparing(SharedLibraryInfo::getName));         String[] slibNames = new String[slibs.size()];         for (int i = 0; i < slibs.size(); i++) {             slibNames[i] = slibs.get(i).getName();         }         assertArrayEquals(""Expected shared libraries does not match"",                 slibNames, deviceConfig.sharedLibraries);          FeatureInfo[] features = mPm.getSystemAvailableFeatures();         Arrays.sort(features, (o1, o2) -> {             if (o1.name == o2.name) return 0;             if (o1.name == null) return -1;             if (o2.name == null) return 1;             return o1.name.compareTo(o2.name);         });          int size = 0;         for (int i = 0; i < features.length; i++) {             if (features[i].name != null) {                 size++;             }         }         String[] featureNames = new String[size];         for (int i = 0, j = 0; i < features.length; i++) {             if (features[i].name != null) {                 featureNames[j] = features[i].name;                 j++;             }         }         assertArrayEquals(""Expected features does not match"",                 featureNames, deviceConfig.features);     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigTest"	"testAllEmptyConfigs"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"TOUCHSCREEN_NOTOUCH"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigTest.java"	""	"public void testAllEmptyConfigs() {         /**          * Test a resource that contains a value for each possible single          * configuration value.          */         TotalConfig config = makeEmptyConfig();         Resources res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple default"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag default""});          config = makeEmptyConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx""});          config = makeEmptyConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.COUNTRY, ""YY"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx-rYY""});          config = makeEmptyConfig();         config.setProperty(Properties.MCC, 111);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111""});          config = makeEmptyConfig();         config.setProperty(Properties.MNC, 222);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mnc222"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mnc222""});          config = makeEmptyConfig();         config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_NOTOUCH);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple notouch"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag notouch""});          config = makeEmptyConfig();         config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_STYLUS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple stylus"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag stylus""});          config = makeEmptyConfig();         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_NOKEYS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nokeys"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nokeys""});          config = makeEmptyConfig();         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_12KEY);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 12key"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 12key""});          config = makeEmptyConfig();         config.setProperty(Properties.KEYBOARDHIDDEN, Configuration.KEYBOARDHIDDEN_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple keysexposed"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag keysexposed""});          config = makeEmptyConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_NONAV);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nonav"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nonav""});          config = makeEmptyConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_DPAD);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple dpad"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag dpad""});          config = makeEmptyConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_WHEEL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple wheel"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag wheel""});          config = makeEmptyConfig();         config.setProperty(Properties.HEIGHT, 480);         config.setProperty(Properties.WIDTH, 320);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 480x320"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 480x320""});          config = makeEmptyConfig();         config.setProperty(Properties.DENSITY, 240);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 240dpi"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 240dpi""});          config = makeEmptyConfig();         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_LANDSCAPE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple landscape"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag landscape""});          config = makeEmptyConfig();         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_SQUARE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple square"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag square""});          config = makeEmptyConfig();         config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_HDR_YES);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple hdr"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag hdr""});          config = makeEmptyConfig();         config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_HDR_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple ldr"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag ldr""});          config = makeEmptyConfig();         config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_WIDE_COLOR_GAMUT_YES);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple widecg"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag widecg""});          config = makeEmptyConfig();         config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_WIDE_COLOR_GAMUT_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nowidecg"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nowidecg""});          config = makeEmptyConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_SMALL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple small"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag small""});          config = makeEmptyConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_NORMAL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple normal"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag normal""});          config = makeEmptyConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_LARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple large"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag large""});          config = makeEmptyConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_XLARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xlarge"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xlarge""});          config = makeEmptyConfig();         config.setProperty(Properties.SWIDTH_DP, 600);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw600"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw600""});          config = makeEmptyConfig();         config.setProperty(Properties.SWIDTH_DP, 600);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw600"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw600""});          config = makeEmptyConfig();         config.setProperty(Properties.SWIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw720""});          config = makeEmptyConfig();         config.setProperty(Properties.WIDTH_DP, 600);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple w600"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag w600""});          config = makeEmptyConfig();         config.setProperty(Properties.WIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple w720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag w720""});          config = makeEmptyConfig();         config.setProperty(Properties.HEIGHT_DP, 550);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h550"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h550""});          config = makeEmptyConfig();         config.setProperty(Properties.HEIGHT_DP, 670);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h670"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h670""});     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigTest"	"testAllClassicConfigs"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"TOUCHSCREEN_NOTOUCH"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigTest.java"	""	"public void testAllClassicConfigs() {         /**          * Test a resource that contains a value for each possible single          * configuration value.          */         TotalConfig config = makeClassicConfig();         Resources res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple default"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag default""});          config = makeClassicConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx""});          config = makeClassicConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.COUNTRY, ""YY"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx-rYY""});          config = makeClassicConfig();         config.setProperty(Properties.MCC, 111);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111""});          config = makeClassicConfig();         config.setProperty(Properties.MNC, 222);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mnc222"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mnc222""});          config = makeClassicConfig();         config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_NOTOUCH);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple notouch"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag notouch""});          config = makeClassicConfig();         config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_STYLUS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple stylus"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag stylus""});          config = makeClassicConfig();         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_NOKEYS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nokeys"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nokeys""});          config = makeClassicConfig();         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_12KEY);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 12key 63x57"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 12key 63x57""});          config = makeClassicConfig();         config.setProperty(Properties.KEYBOARDHIDDEN, Configuration.KEYBOARDHIDDEN_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple keysexposed"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag keysexposed""});          config = makeClassicConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_NONAV);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nonav"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nonav""});          config = makeClassicConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_DPAD);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple dpad 63x57"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag dpad 63x57""});          config = makeClassicConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_WHEEL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple wheel"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag wheel""});          config = makeClassicConfig();         config.setProperty(Properties.HEIGHT, 480);         config.setProperty(Properties.WIDTH, 320);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 480x320"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 480x320""});          config = makeClassicConfig();         config.setProperty(Properties.DENSITY, 240);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 240dpi"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 240dpi""});          config = makeClassicConfig();         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_LANDSCAPE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple landscape"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag landscape""});          config = makeClassicConfig();         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_SQUARE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple square"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag square""});          config = makeClassicConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_SMALL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple small"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag small""});          config = makeClassicConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_NORMAL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple normal"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag normal""});          config = makeClassicConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_LARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple large"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag large""});          config = makeClassicConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_XLARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xlarge"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xlarge""});          config = makeClassicConfig();         config.setProperty(Properties.SWIDTH_DP, 600);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw600"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw600""});          config = makeClassicConfig();         config.setProperty(Properties.SWIDTH_DP, 600);         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_LANDSCAPE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw600 land"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw600 land""});          config = makeClassicConfig();         config.setProperty(Properties.SWIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw720""});          config = makeClassicConfig();         config.setProperty(Properties.WIDTH_DP, 600);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple w600"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag w600""});          config = makeClassicConfig();         config.setProperty(Properties.WIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple w720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag w720""});          config = makeClassicConfig();         config.setProperty(Properties.HEIGHT_DP, 550);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h550"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h550""});          config = makeClassicConfig();         config.setProperty(Properties.HEIGHT_DP, 670);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h670"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h670""});     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigTest"	"testPrecedence"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"TOUCHSCREEN_NOTOUCH"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigTest.java"	""	"public void testPrecedence() {         /**          * Check for precedence of resources selected when there are multiple          * options matching the current config.          */         TotalConfig config = makeEmptyConfig();         config.setProperty(Properties.HEIGHT, 640);         config.setProperty(Properties.WIDTH, 400);         Resources res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 640x400"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 640x400""});          config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_NONAV);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nonav"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nonav""});          config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_NOKEYS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nokeys"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nokeys""});          config.setProperty(Properties.KEYBOARDHIDDEN, Configuration.KEYBOARDHIDDEN_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple keysexposed"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag keysexposed""});          config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_NOTOUCH);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple notouch"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag notouch""});          config.setProperty(Properties.DENSITY, 240);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 240dpi"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 240dpi""});          config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_LANDSCAPE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple landscape"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag landscape""});          config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_HDR_YES);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple hdr"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag hdr""});          config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_WIDE_COLOR_GAMUT_YES);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple widecg"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag widecg""});          config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_XLARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xlarge"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xlarge""});          config.setProperty(Properties.HEIGHT_DP, 670);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h670"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h670""});          config.setProperty(Properties.WIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 720-670"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 720-670""});          config.setProperty(Properties.SWIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw720""});          config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.COUNTRY, ""YY"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx-rYY""});          config.setProperty(Properties.MCC, 111);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111 xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111 xx-rYY""});          config.setProperty(Properties.MNC, 222);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111 mnc222"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111 mnc222""});     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigTest"	"DisplayMetrics"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigTest.java"	""	"/*  *.  */  package android.content.res.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.content.Context; import android.content.cts.R; import android.content.pm.ApplicationInfo; import android.content.pm.PackageManager; import android.content.pm.PackageManager.NameNotFoundException; import android.content.res.AssetManager; import android.content.res.Configuration; import android.content.res.Resources; import android.content.res.Resources.NotFoundException; import android.content.res.TypedArray; import android.util.DisplayMetrics;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.ArrayList; import java.util.List; import java.util.Locale;  @RunWith(AndroidJUnit4.class) public class ConfigTest {     private static final String TEST_PACKAGE = ""android.content.cts"";      private Context mContext;     private int mTargetSdkVersion;      enum Properties {         LANGUAGE,         COUNTRY,         SCRIPT,         VARIANT,         MCC,         MNC,         TOUCHSCREEN,         KEYBOARD,         KEYBOARDHIDDEN,         NAVIGATION,         ORIENTATION,         COLOR_MODE,         WIDTH,         HEIGHT,         DENSITY,         SCREENLAYOUT,         SWIDTH_DP,         WIDTH_DP,         HEIGHT_DP     }      private static void checkValue(final Resources res, final int resId,             final String expectedValue) {         try {             final String actual = res.getString(resId);             assertNotNull(""Returned wrong configuration-based simple value: expected <nothing>, ""                     + ""got '"" + actual + ""' from resource 0x"" + Integer.toHexString(resId),                     expectedValue);             assertEquals(""Returned wrong configuration-based simple value: expected '""                     + expectedValue + ""', got '"" + actual + ""' from resource 0x""                     + Integer.toHexString(resId), expectedValue, actual);         } catch (NotFoundException e) {             assertNull(""Resource not found for configuration-based simple value: expecting \""""                     + expectedValue + ""\"""", expectedValue);         }     }      private static void checkValue(final Resources res, final int resId,             final int[] styleable, final String[] expectedValues) {         final Resources.Theme theme = res.newTheme();         final TypedArray sa = theme.obtainStyledAttributes(resId, styleable);         for (int i = 0; i < styleable.length; i++) {             final String actual = sa.getString(i);             assertEquals(""Returned wrong configuration-based style value: expected '""                     + expectedValues[i] + ""', got '"" + actual + ""' from attr ""                     + i + "" of resource 0x"" + Integer.toHexString(resId),                     actual, expectedValues[i]);         }         sa.recycle();     }      private class TotalConfig {         final Configuration mConfig;         final DisplayMetrics mMetrics;          public TotalConfig() {             mConfig = new Configuration();             mMetrics = new DisplayMetrics();             mConfig.locale = Locale.ROOT;         }          public void setProperty(final Properties p, final int value) {             switch(p) {                 case MCC:                     mConfig.mcc = value;                     break;                 case MNC:                     mConfig.mnc = value;                     break;                 case TOUCHSCREEN:                     mConfig.touchscreen = value;                     break;                 case KEYBOARD:                     mConfig.keyboard = value;                     break;                 case KEYBOARDHIDDEN:                     mConfig.keyboardHidden = value;                     break;                 case NAVIGATION:                     mConfig.navigation = value;                     break;                 case ORIENTATION:                     mConfig.orientation = value;                     break;                 case COLOR_MODE:                     mConfig.colorMode = value;                     break;                 case WIDTH:                     mMetrics.widthPixels = value;                     mMetrics.noncompatWidthPixels = value;                     break;                 case HEIGHT:                     mMetrics.heightPixels = value;                     mMetrics.noncompatHeightPixels = value;                     break;                 case DENSITY:                     // this is the ratio from the standard                     mMetrics.density = (((float)value)/((float)DisplayMetrics.DENSITY_DEFAULT));                     mMetrics.noncompatDensity = mMetrics.density;                     mConfig.densityDpi = value;                     break;                 case SCREENLAYOUT:                     mConfig.screenLayout = value;                     break;                 case SWIDTH_DP:                     mConfig.smallestScreenWidthDp = value;                     break;                 case WIDTH_DP:                     mConfig.screenWidthDp = value;                     break;                 case HEIGHT_DP:                     mConfig.screenHeightDp = value;                     break;                 default:                     assert(false);                     break;             }         }          public void setProperty(final Properties p, final String value) {             switch(p) {                 case LANGUAGE:                     mConfig.locale = new Locale.Builder()                             .setLocale(mConfig.locale)                             .setLanguage(value)                             .build();                     break;                 case COUNTRY:                     mConfig.locale = new Locale.Builder()                             .setLocale(mConfig.locale)                             .setRegion(value)                             .build();                     break;                 case SCRIPT:                     mConfig.locale = new Locale.Builder()                             .setLocale(mConfig.locale)                             .setScript(value)                             .build();                     break;                 case VARIANT:                     mConfig.locale = new Locale.Builder()                             .setLocale(mConfig.locale)                             .setVariant(value)                             .build();                     break;                 default:                     assert(false);                     break;             }         }          public Resources getResources() {             final AssetManager assmgr = new AssetManager();             assmgr.addAssetPath(mContext.getPackageResourcePath());             return new Resources(assmgr, mMetrics, mConfig);         }     }      public TotalConfig makeEmptyConfig() {         return new TotalConfig();     }      public TotalConfig makeClassicConfig() {         TotalConfig config = new TotalConfig();         config.setProperty(Properties.LANGUAGE, ""en"");         config.setProperty(Properties.COUNTRY, ""US"");         config.setProperty(Properties.MCC, 310);         config.setProperty(Properties.MNC, 001); // unused         config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_FINGER);         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_QWERTY);         config.setProperty(Properties.KEYBOARDHIDDEN, Configuration.KEYBOARDHIDDEN_YES);         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_TRACKBALL);         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_PORTRAIT);         config.setProperty(Properties.SWIDTH_DP, 320);         config.setProperty(Properties.WIDTH_DP, 320);         config.setProperty(Properties.HEIGHT_DP, 480);         config.setProperty(Properties.DENSITY, 160);         config.setProperty(Properties.WIDTH, 200);         config.setProperty(Properties.HEIGHT, 320);         return config;     }      private static void checkPair(Resources res, int[] notResIds,             int simpleRes, String simpleString,             int bagRes, String bagString) {         boolean willHave = true;         if (notResIds != null) {             for (int i : notResIds) {                 if (i == simpleRes) {                     willHave = false;                     break;                 }             }         }         checkValue(res, simpleRes, willHave ? simpleString : null);         checkValue(res, bagRes, R.styleable.TestConfig,                 new String[]{willHave ? bagString : null});     }      @Before     public void setUp() {         mContext = InstrumentationRegistry.getContext();         final PackageManager pm = mContext.getPackageManager();         try {             ApplicationInfo appInfo = pm.getApplicationInfo(TEST_PACKAGE, 0);             mTargetSdkVersion = appInfo.targetSdkVersion;         } catch (NameNotFoundException e) {             fail(""Should be able to find application info for this package"");         }     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigTest"	"testAllEmptyConfigs"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigTest.java"	""	"public void testAllEmptyConfigs() {         /**          * Test a resource that contains a value for each possible single          * configuration value.          */         TotalConfig config = makeEmptyConfig();         Resources res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple default"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag default""});          config = makeEmptyConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx""});          config = makeEmptyConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.COUNTRY, ""YY"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx-rYY""});          config = makeEmptyConfig();         config.setProperty(Properties.MCC, 111);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111""});          config = makeEmptyConfig();         config.setProperty(Properties.MNC, 222);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mnc222"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mnc222""});          config = makeEmptyConfig();         config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_NOTOUCH);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple notouch"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag notouch""});          config = makeEmptyConfig();         config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_STYLUS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple stylus"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag stylus""});          config = makeEmptyConfig();         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_NOKEYS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nokeys"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nokeys""});          config = makeEmptyConfig();         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_12KEY);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 12key"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 12key""});          config = makeEmptyConfig();         config.setProperty(Properties.KEYBOARDHIDDEN, Configuration.KEYBOARDHIDDEN_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple keysexposed"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag keysexposed""});          config = makeEmptyConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_NONAV);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nonav"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nonav""});          config = makeEmptyConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_DPAD);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple dpad"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag dpad""});          config = makeEmptyConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_WHEEL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple wheel"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag wheel""});          config = makeEmptyConfig();         config.setProperty(Properties.HEIGHT, 480);         config.setProperty(Properties.WIDTH, 320);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 480x320"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 480x320""});          config = makeEmptyConfig();         config.setProperty(Properties.DENSITY, 240);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 240dpi"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 240dpi""});          config = makeEmptyConfig();         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_LANDSCAPE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple landscape"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag landscape""});          config = makeEmptyConfig();         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_SQUARE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple square"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag square""});          config = makeEmptyConfig();         config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_HDR_YES);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple hdr"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag hdr""});          config = makeEmptyConfig();         config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_HDR_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple ldr"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag ldr""});          config = makeEmptyConfig();         config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_WIDE_COLOR_GAMUT_YES);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple widecg"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag widecg""});          config = makeEmptyConfig();         config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_WIDE_COLOR_GAMUT_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nowidecg"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nowidecg""});          config = makeEmptyConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_SMALL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple small"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag small""});          config = makeEmptyConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_NORMAL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple normal"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag normal""});          config = makeEmptyConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_LARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple large"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag large""});          config = makeEmptyConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_XLARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xlarge"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xlarge""});          config = makeEmptyConfig();         config.setProperty(Properties.SWIDTH_DP, 600);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw600"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw600""});          config = makeEmptyConfig();         config.setProperty(Properties.SWIDTH_DP, 600);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw600"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw600""});          config = makeEmptyConfig();         config.setProperty(Properties.SWIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw720""});          config = makeEmptyConfig();         config.setProperty(Properties.WIDTH_DP, 600);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple w600"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag w600""});          config = makeEmptyConfig();         config.setProperty(Properties.WIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple w720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag w720""});          config = makeEmptyConfig();         config.setProperty(Properties.HEIGHT_DP, 550);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h550"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h550""});          config = makeEmptyConfig();         config.setProperty(Properties.HEIGHT_DP, 670);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h670"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h670""});     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigTest"	"testAllClassicConfigs"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigTest.java"	""	"public void testAllClassicConfigs() {         /**          * Test a resource that contains a value for each possible single          * configuration value.          */         TotalConfig config = makeClassicConfig();         Resources res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple default"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag default""});          config = makeClassicConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx""});          config = makeClassicConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.COUNTRY, ""YY"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx-rYY""});          config = makeClassicConfig();         config.setProperty(Properties.MCC, 111);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111""});          config = makeClassicConfig();         config.setProperty(Properties.MNC, 222);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mnc222"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mnc222""});          config = makeClassicConfig();         config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_NOTOUCH);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple notouch"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag notouch""});          config = makeClassicConfig();         config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_STYLUS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple stylus"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag stylus""});          config = makeClassicConfig();         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_NOKEYS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nokeys"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nokeys""});          config = makeClassicConfig();         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_12KEY);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 12key 63x57"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 12key 63x57""});          config = makeClassicConfig();         config.setProperty(Properties.KEYBOARDHIDDEN, Configuration.KEYBOARDHIDDEN_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple keysexposed"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag keysexposed""});          config = makeClassicConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_NONAV);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nonav"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nonav""});          config = makeClassicConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_DPAD);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple dpad 63x57"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag dpad 63x57""});          config = makeClassicConfig();         config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_WHEEL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple wheel"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag wheel""});          config = makeClassicConfig();         config.setProperty(Properties.HEIGHT, 480);         config.setProperty(Properties.WIDTH, 320);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 480x320"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 480x320""});          config = makeClassicConfig();         config.setProperty(Properties.DENSITY, 240);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 240dpi"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 240dpi""});          config = makeClassicConfig();         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_LANDSCAPE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple landscape"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag landscape""});          config = makeClassicConfig();         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_SQUARE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple square"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag square""});          config = makeClassicConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_SMALL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple small"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag small""});          config = makeClassicConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_NORMAL);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple normal"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag normal""});          config = makeClassicConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_LARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple large"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag large""});          config = makeClassicConfig();         config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_XLARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xlarge"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xlarge""});          config = makeClassicConfig();         config.setProperty(Properties.SWIDTH_DP, 600);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw600"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw600""});          config = makeClassicConfig();         config.setProperty(Properties.SWIDTH_DP, 600);         config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_LANDSCAPE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw600 land"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw600 land""});          config = makeClassicConfig();         config.setProperty(Properties.SWIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw720""});          config = makeClassicConfig();         config.setProperty(Properties.WIDTH_DP, 600);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple w600"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag w600""});          config = makeClassicConfig();         config.setProperty(Properties.WIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple w720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag w720""});          config = makeClassicConfig();         config.setProperty(Properties.HEIGHT_DP, 550);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h550"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h550""});          config = makeClassicConfig();         config.setProperty(Properties.HEIGHT_DP, 670);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h670"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h670""});     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigTest"	"testPrecedence"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigTest.java"	""	"public void testPrecedence() {         /**          * Check for precedence of resources selected when there are multiple          * options matching the current config.          */         TotalConfig config = makeEmptyConfig();         config.setProperty(Properties.HEIGHT, 640);         config.setProperty(Properties.WIDTH, 400);         Resources res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 640x400"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 640x400""});          config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_NONAV);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nonav"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nonav""});          config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_NOKEYS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nokeys"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nokeys""});          config.setProperty(Properties.KEYBOARDHIDDEN, Configuration.KEYBOARDHIDDEN_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple keysexposed"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag keysexposed""});          config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_NOTOUCH);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple notouch"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag notouch""});          config.setProperty(Properties.DENSITY, 240);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 240dpi"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 240dpi""});          config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_LANDSCAPE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple landscape"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag landscape""});          config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_HDR_YES);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple hdr"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag hdr""});          config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_WIDE_COLOR_GAMUT_YES);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple widecg"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag widecg""});          config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_XLARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xlarge"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xlarge""});          config.setProperty(Properties.HEIGHT_DP, 670);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h670"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h670""});          config.setProperty(Properties.WIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 720-670"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 720-670""});          config.setProperty(Properties.SWIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw720""});          config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.COUNTRY, ""YY"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx-rYY""});          config.setProperty(Properties.MCC, 111);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111 xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111 xx-rYY""});          config.setProperty(Properties.MNC, 222);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111 mnc222"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111 mnc222""});     }"	""	""	""	""	""
"169:533444) 7.2.4  . Touchscreen Input"	"7.2.4"	"C-3-3"	""	"android.content.res.cts.ConfigTest"	"testCombinations"	"CtsContentTestCases"	""	"7.2.4/C-3-3"	"""C-3-3] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field. <h4 id="""	""	"TOUCHSCREEN_NOTOUCH Configuration.touchscreen"	""	""	""	"Configuration.touchscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigTest.java"	""	"public void testCombinations() {         /**          * Verify that in cases of ties, the specific ordering is followed          */          /**          * Precidence order: mcc, mnc, locale, swdp, wdp, hdp, screenlayout-size,          * screenlayout-long, orientation, density,          * touchscreen, hidden, keyboard, navigation, width-height          */          /**          * verify mcc trumps mnc.  Have 110-xx, 220-xx but no 110-220          * so which is selected?  Should be mcc110-xx.          */         TotalConfig config = makeClassicConfig();         config.setProperty(Properties.MCC, 110);         config.setProperty(Properties.MNC, 220);         config.setProperty(Properties.LANGUAGE, ""xx"");         Resources res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc110 xx"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc110 xx""});          /* full A + B + C doesn't exist.  Do we get A + C or B + C?           */         config = makeClassicConfig();         config.setProperty(Properties.MCC, 111);         config.setProperty(Properties.MNC, 222);         config.setProperty(Properties.LANGUAGE, ""xx"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111 mnc222"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111 mnc222""});          config = makeClassicConfig();         config.setProperty(Properties.MNC, 222);         config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.ORIENTATION,                  Configuration.ORIENTATION_SQUARE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mnc222 xx"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mnc222 xx""});          config = makeClassicConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.ORIENTATION,                  Configuration.ORIENTATION_SQUARE);         config.setProperty(Properties.DENSITY, 32);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx square"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx square""});          /**          * Verify that proper strings are found for multiple-selectivity case          * (ie, a string set for locale and mcc is found only when both are          * true).          */         config = makeClassicConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.COUNTRY, ""YY"");         config.setProperty(Properties.MCC, 111);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111 xx-rYY"");         checkValue(res, R.configVarying.bag, R.styleable.TestConfig,                 new String[] { ""bag mcc111 xx-rYY"" });          config = makeClassicConfig();         config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.COUNTRY, ""YY"");         config.setProperty(Properties.MCC, 333);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[] { ""bag xx-rYY"" });          config = makeClassicConfig();         config.setProperty(Properties.MNC, 333);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple default"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag default""});          config = makeClassicConfig();         config.setProperty(Properties.ORIENTATION,                  Configuration.ORIENTATION_SQUARE);         config.setProperty(Properties.DENSITY, 32);         config.setProperty(Properties.TOUCHSCREEN,                  Configuration.TOUCHSCREEN_STYLUS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple square 32dpi"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag square 32dpi""});          config = makeClassicConfig();         config.setProperty(Properties.DENSITY, 32);         config.setProperty(Properties.TOUCHSCREEN,                  Configuration.TOUCHSCREEN_STYLUS);         config.setProperty(Properties.KEYBOARDHIDDEN,                  Configuration.KEYBOARDHIDDEN_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 32dpi stylus"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 32dpi stylus""});          config = makeClassicConfig();         config.setProperty(Properties.TOUCHSCREEN,                  Configuration.TOUCHSCREEN_STYLUS);         config.setProperty(Properties.KEYBOARDHIDDEN,                  Configuration.KEYBOARDHIDDEN_NO);         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_12KEY);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple stylus keysexposed"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag stylus keysexposed""});          config = makeClassicConfig();         config.setProperty(Properties.KEYBOARDHIDDEN,                  Configuration.KEYBOARDHIDDEN_NO);         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_12KEY);         config.setProperty(Properties.NAVIGATION,                  Configuration.NAVIGATION_DPAD);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple keysexposed 12key"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag keysexposed 12key""});          config = makeClassicConfig();         config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_12KEY);         config.setProperty(Properties.NAVIGATION,                  Configuration.NAVIGATION_DPAD);         config.setProperty(Properties.HEIGHT, 63);         config.setProperty(Properties.WIDTH, 57);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 12key dpad"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 12key dpad""});          config = makeClassicConfig();         config.setProperty(Properties.NAVIGATION,                  Configuration.NAVIGATION_DPAD);         config.setProperty(Properties.HEIGHT, 640);         config.setProperty(Properties.WIDTH, 400);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple dpad 63x57"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag dpad 63x57""});     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_THUMBR"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_L1"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_Y"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_THUMBL"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_A"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_X"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_R1"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	done	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.MotionEventTest"	"testAxisFromToString"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"AXIS_LTRIGGER"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/MotionEventTest.java"	""	"public void testAxisFromToString() {         final int[] axes = {                 MotionEvent.AXIS_X,                 MotionEvent.AXIS_Y,                 MotionEvent.AXIS_PRESSURE,                 MotionEvent.AXIS_SIZE,                 MotionEvent.AXIS_TOUCH_MAJOR,                 MotionEvent.AXIS_TOUCH_MINOR,                 MotionEvent.AXIS_TOOL_MAJOR,                 MotionEvent.AXIS_TOOL_MINOR,                 MotionEvent.AXIS_ORIENTATION,                 MotionEvent.AXIS_VSCROLL,                 MotionEvent.AXIS_HSCROLL,                 MotionEvent.AXIS_Z,                 MotionEvent.AXIS_RX,                 MotionEvent.AXIS_RY,                 MotionEvent.AXIS_RZ,                 MotionEvent.AXIS_HAT_X,                 MotionEvent.AXIS_HAT_Y,                 MotionEvent.AXIS_LTRIGGER,                 MotionEvent.AXIS_RTRIGGER,                 MotionEvent.AXIS_THROTTLE,                 MotionEvent.AXIS_RUDDER,                 MotionEvent.AXIS_WHEEL,                 MotionEvent.AXIS_GAS,                 MotionEvent.AXIS_BRAKE,                 MotionEvent.AXIS_DISTANCE,                 MotionEvent.AXIS_TILT,                 MotionEvent.AXIS_SCROLL,                 MotionEvent.AXIS_RELATIVE_X,                 MotionEvent.AXIS_RELATIVE_Y,                 MotionEvent.AXIS_GENERIC_1,                 MotionEvent.AXIS_GENERIC_2,                 MotionEvent.AXIS_GENERIC_3,                 MotionEvent.AXIS_GENERIC_4,                 MotionEvent.AXIS_GENERIC_5,                 MotionEvent.AXIS_GENERIC_6,                 MotionEvent.AXIS_GENERIC_7,                 MotionEvent.AXIS_GENERIC_8,                 MotionEvent.AXIS_GENERIC_9,                 MotionEvent.AXIS_GENERIC_10,                 MotionEvent.AXIS_GENERIC_11,                 MotionEvent.AXIS_GENERIC_12,                 MotionEvent.AXIS_GENERIC_13,                 MotionEvent.AXIS_GENERIC_14,                 MotionEvent.AXIS_GENERIC_15,                 MotionEvent.AXIS_GENERIC_16         };          // There is no hard guarantee on the actual return result on any specific axis         // from MotionEvent.axisToString. Verify that we are not crashing on those calls         // and that the return result on each is not empty. However, we do expect the two-way         // call chain of to/from to get us back to the original integer value.         for (int i = 0; i < axes.length; i++) {             String axisToString = MotionEvent.axisToString(axes[i]);             assertFalse(TextUtils.isEmpty(axisToString));             assertEquals(axes[i], MotionEvent.axisFromString(axisToString));         }     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.MotionEventTest"	"testAxisFromToString"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"AXIS_RTRIGGER"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/MotionEventTest.java"	""	"public void testAxisFromToString() {         final int[] axes = {                 MotionEvent.AXIS_X,                 MotionEvent.AXIS_Y,                 MotionEvent.AXIS_PRESSURE,                 MotionEvent.AXIS_SIZE,                 MotionEvent.AXIS_TOUCH_MAJOR,                 MotionEvent.AXIS_TOUCH_MINOR,                 MotionEvent.AXIS_TOOL_MAJOR,                 MotionEvent.AXIS_TOOL_MINOR,                 MotionEvent.AXIS_ORIENTATION,                 MotionEvent.AXIS_VSCROLL,                 MotionEvent.AXIS_HSCROLL,                 MotionEvent.AXIS_Z,                 MotionEvent.AXIS_RX,                 MotionEvent.AXIS_RY,                 MotionEvent.AXIS_RZ,                 MotionEvent.AXIS_HAT_X,                 MotionEvent.AXIS_HAT_Y,                 MotionEvent.AXIS_LTRIGGER,                 MotionEvent.AXIS_RTRIGGER,                 MotionEvent.AXIS_THROTTLE,                 MotionEvent.AXIS_RUDDER,                 MotionEvent.AXIS_WHEEL,                 MotionEvent.AXIS_GAS,                 MotionEvent.AXIS_BRAKE,                 MotionEvent.AXIS_DISTANCE,                 MotionEvent.AXIS_TILT,                 MotionEvent.AXIS_SCROLL,                 MotionEvent.AXIS_RELATIVE_X,                 MotionEvent.AXIS_RELATIVE_Y,                 MotionEvent.AXIS_GENERIC_1,                 MotionEvent.AXIS_GENERIC_2,                 MotionEvent.AXIS_GENERIC_3,                 MotionEvent.AXIS_GENERIC_4,                 MotionEvent.AXIS_GENERIC_5,                 MotionEvent.AXIS_GENERIC_6,                 MotionEvent.AXIS_GENERIC_7,                 MotionEvent.AXIS_GENERIC_8,                 MotionEvent.AXIS_GENERIC_9,                 MotionEvent.AXIS_GENERIC_10,                 MotionEvent.AXIS_GENERIC_11,                 MotionEvent.AXIS_GENERIC_12,                 MotionEvent.AXIS_GENERIC_13,                 MotionEvent.AXIS_GENERIC_14,                 MotionEvent.AXIS_GENERIC_15,                 MotionEvent.AXIS_GENERIC_16         };          // There is no hard guarantee on the actual return result on any specific axis         // from MotionEvent.axisToString. Verify that we are not crashing on those calls         // and that the return result on each is not empty. However, we do expect the two-way         // call chain of to/from to get us back to the original integer value.         for (int i = 0; i < axes.length; i++) {             String axisToString = MotionEvent.axisToString(axes[i]);             assertFalse(TextUtils.isEmpty(axisToString));             assertEquals(axes[i], MotionEvent.axisFromString(axisToString));         }     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_THUMBR"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_L1"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_Y"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_THUMBL"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_A"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_X"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.KeyCharacterMapTest"	"testIsPrintingKey"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"KEYCODE_BUTTON_R1"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java"	""	"public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.MotionEventTest"	"testAxisFromToString"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"AXIS_LTRIGGER"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/MotionEventTest.java"	""	"public void testAxisFromToString() {         final int[] axes = {                 MotionEvent.AXIS_X,                 MotionEvent.AXIS_Y,                 MotionEvent.AXIS_PRESSURE,                 MotionEvent.AXIS_SIZE,                 MotionEvent.AXIS_TOUCH_MAJOR,                 MotionEvent.AXIS_TOUCH_MINOR,                 MotionEvent.AXIS_TOOL_MAJOR,                 MotionEvent.AXIS_TOOL_MINOR,                 MotionEvent.AXIS_ORIENTATION,                 MotionEvent.AXIS_VSCROLL,                 MotionEvent.AXIS_HSCROLL,                 MotionEvent.AXIS_Z,                 MotionEvent.AXIS_RX,                 MotionEvent.AXIS_RY,                 MotionEvent.AXIS_RZ,                 MotionEvent.AXIS_HAT_X,                 MotionEvent.AXIS_HAT_Y,                 MotionEvent.AXIS_LTRIGGER,                 MotionEvent.AXIS_RTRIGGER,                 MotionEvent.AXIS_THROTTLE,                 MotionEvent.AXIS_RUDDER,                 MotionEvent.AXIS_WHEEL,                 MotionEvent.AXIS_GAS,                 MotionEvent.AXIS_BRAKE,                 MotionEvent.AXIS_DISTANCE,                 MotionEvent.AXIS_TILT,                 MotionEvent.AXIS_SCROLL,                 MotionEvent.AXIS_RELATIVE_X,                 MotionEvent.AXIS_RELATIVE_Y,                 MotionEvent.AXIS_GENERIC_1,                 MotionEvent.AXIS_GENERIC_2,                 MotionEvent.AXIS_GENERIC_3,                 MotionEvent.AXIS_GENERIC_4,                 MotionEvent.AXIS_GENERIC_5,                 MotionEvent.AXIS_GENERIC_6,                 MotionEvent.AXIS_GENERIC_7,                 MotionEvent.AXIS_GENERIC_8,                 MotionEvent.AXIS_GENERIC_9,                 MotionEvent.AXIS_GENERIC_10,                 MotionEvent.AXIS_GENERIC_11,                 MotionEvent.AXIS_GENERIC_12,                 MotionEvent.AXIS_GENERIC_13,                 MotionEvent.AXIS_GENERIC_14,                 MotionEvent.AXIS_GENERIC_15,                 MotionEvent.AXIS_GENERIC_16         };          // There is no hard guarantee on the actual return result on any specific axis         // from MotionEvent.axisToString. Verify that we are not crashing on those calls         // and that the return result on each is not empty. However, we do expect the two-way         // call chain of to/from to get us back to the original integer value.         for (int i = 0; i < axes.length; i++) {             String axisToString = MotionEvent.axisToString(axes[i]);             assertFalse(TextUtils.isEmpty(axisToString));             assertEquals(axes[i], MotionEvent.axisFromString(axisToString));         }     }"	""	""	""	""	""
"172:544587) 7.2.6.1  . Button Mappings"	"7.2.6.1"	"C-2-1"	""	"android.view.cts.MotionEventTest"	"testAxisFromToString"	"CtsViewTestCases"	""	"7.2.6.1/C-2-1"	"""C-2-1] MUST declare the feature flag android.hardware.gamepad Button HID Usage2 Android Button A1 0x09 0x0001 KEYCODE_BUTTON_A (96) B1 0x09 0x0002 KEYCODE_BUTTON_B (97) X1 0x09 0x0004 KEYCODE_BUTTON_X (99) Y1 0x09 0x0005 KEYCODE_BUTTON_Y (100) D-pad up1 D-pad down1 0x01 0x00393 AXIS_HAT_Y4 D-pad left1 D-pad right1 0x01 0x00393 AXIS_HAT_X4 Left shoulder button1 0x09 0x0007 KEYCODE_BUTTON_L1 (102) Right shoulder button1 0x09 0x0008 KEYCODE_BUTTON_R1 (103) Left stick click1 0x09 0x000E KEYCODE_BUTTON_THUMBL (106) Right stick click1 0x09 0x000F KEYCODE_BUTTON_THUMBR (107) Home1 0x0c 0x0223 KEYCODE_HOME (3) Back1 0x0c 0x0224 KEYCODE_BACK (4) 1 KeyEvent 2 The above HID usages must be declared within a Game pad CA (0x01 0x0005). 3 This usage must have a Logical Minimum of 0, a Logical Maximum of 7, a Physical Minimum of 0, a Physical Maximum of 315, Units in Degrees, and a Report Size of 4. The logical value is defined to be the clockwise rotation away from the vertical axis; for example, a logical value of 0 represents no rotation and the up button being pressed, while a logical value of 1 represents a rotation of 45 degrees and both the up and left keys being pressed. 4 MotionEvent Analog Controls1 HID Usage Android Button Left Trigger 0x02 0x00C5 AXIS_LTRIGGER Right Trigger 0x02 0x00C4 AXIS_RTRIGGER Left Joystick 0x01 0x0030 0x01 0x0031 AXIS_X AXIS_Y Right Joystick 0x01 0x0032 0x01 0x0035 AXIS_Z AXIS_RZ 1 MotionEvent <h4 id="""	""	"android.hardware.gamepad KEYCODE_BUTTON_THUMBR AXIS_LTRIGGER KEYCODE_BUTTON_L1 AXIS_RTRIGGER KEYCODE_BUTTON_Y AXIS_HAT_Y4 KEYCODE_BUTTON_THUMBL AXIS_HAT_X4 KEYCODE_BUTTON_A KEYCODE_BUTTON_X KEYCODE_BUTTON_R1"	""	""	""	"AXIS_RTRIGGER"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/MotionEventTest.java"	""	"public void testAxisFromToString() {         final int[] axes = {                 MotionEvent.AXIS_X,                 MotionEvent.AXIS_Y,                 MotionEvent.AXIS_PRESSURE,                 MotionEvent.AXIS_SIZE,                 MotionEvent.AXIS_TOUCH_MAJOR,                 MotionEvent.AXIS_TOUCH_MINOR,                 MotionEvent.AXIS_TOOL_MAJOR,                 MotionEvent.AXIS_TOOL_MINOR,                 MotionEvent.AXIS_ORIENTATION,                 MotionEvent.AXIS_VSCROLL,                 MotionEvent.AXIS_HSCROLL,                 MotionEvent.AXIS_Z,                 MotionEvent.AXIS_RX,                 MotionEvent.AXIS_RY,                 MotionEvent.AXIS_RZ,                 MotionEvent.AXIS_HAT_X,                 MotionEvent.AXIS_HAT_Y,                 MotionEvent.AXIS_LTRIGGER,                 MotionEvent.AXIS_RTRIGGER,                 MotionEvent.AXIS_THROTTLE,                 MotionEvent.AXIS_RUDDER,                 MotionEvent.AXIS_WHEEL,                 MotionEvent.AXIS_GAS,                 MotionEvent.AXIS_BRAKE,                 MotionEvent.AXIS_DISTANCE,                 MotionEvent.AXIS_TILT,                 MotionEvent.AXIS_SCROLL,                 MotionEvent.AXIS_RELATIVE_X,                 MotionEvent.AXIS_RELATIVE_Y,                 MotionEvent.AXIS_GENERIC_1,                 MotionEvent.AXIS_GENERIC_2,                 MotionEvent.AXIS_GENERIC_3,                 MotionEvent.AXIS_GENERIC_4,                 MotionEvent.AXIS_GENERIC_5,                 MotionEvent.AXIS_GENERIC_6,                 MotionEvent.AXIS_GENERIC_7,                 MotionEvent.AXIS_GENERIC_8,                 MotionEvent.AXIS_GENERIC_9,                 MotionEvent.AXIS_GENERIC_10,                 MotionEvent.AXIS_GENERIC_11,                 MotionEvent.AXIS_GENERIC_12,                 MotionEvent.AXIS_GENERIC_13,                 MotionEvent.AXIS_GENERIC_14,                 MotionEvent.AXIS_GENERIC_15,                 MotionEvent.AXIS_GENERIC_16         };          // There is no hard guarantee on the actual return result on any specific axis         // from MotionEvent.axisToString. Verify that we are not crashing on those calls         // and that the return result on each is not empty. However, we do expect the two-way         // call chain of to/from to get us back to the original integer value.         for (int i = 0; i < axes.length; i++) {             String axisToString = MotionEvent.axisToString(axes[i]);             assertFalse(TextUtils.isEmpty(axisToString));             assertEquals(axes[i], MotionEvent.axisFromString(axisToString));         }     }"	""	""	""	""	""
