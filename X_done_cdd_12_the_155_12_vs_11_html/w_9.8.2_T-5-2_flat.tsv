"Section"	"section_id"	"req_id"	"full_key"	"manual_search_terms"	"requirement"	"Test Availability"	"class_def"	"method"	"module"	"matched_terms"	"methods_string"	"search_terms"	"file_name"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"Test Level"
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsTest"	"testGrantPersistablePrefixUriPermission"	""	"1: direct"	"public void testGrantPersistablePrefixUriPermission() {
        final ContentResolver resolver = getContext().getContentResolver();

        final Uri target = Uri.withAppendedPath(PERM_URI_GRANTING, ""foo2"");
        final Uri targetMeow = Uri.withAppendedPath(target, ""meow"");

        final ClipData clip = makeSingleClipData(target);
        final ClipData clipMeow = makeSingleClipData(targetMeow);

        // Make sure we can't see the target
        assertReadingClipNotAllowed(clip, ""reading should have failed"");

        // Give ourselves prefix read access
        ReceiveUriActivity.clearStarted();
        grantClipUriPermissionViaActivity(clip, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION);
        ReceiveUriActivity.waitForStart();

        // Verify prefix read access
        assertReadingClipAllowed(clip);
        assertReadingClipAllowed(clipMeow);

        // Verify we can persist direct grant
        long before = System.currentTimeMillis();
        resolver.takePersistableUriPermission(target, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        long after = System.currentTimeMillis();
        assertPersistedUriPermission(target, Intent.FLAG_GRANT_READ_URI_PERMISSION, before, after);

        // But we can't take anywhere under the prefix
        try {
            resolver.takePersistableUriPermission(targetMeow,
                    Intent.FLAG_GRANT_READ_URI_PERMISSION);
            fail(""taking under prefix should have failed"");
        } catch (SecurityException expected) {
        }

        // Should still have access regardless of taking
        assertReadingClipAllowed(clip);
        assertReadingClipAllowed(clipMeow);

        // And clean up our grants
        resolver.releasePersistableUriPermission(target, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        assertNoPersistedUriPermission();

        ReceiveUriActivity.finishCurInstanceSync();
    }

    /**
     * Validate behavior of directly granting/revoking permission grants.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsTest"	"testDirectGrantRevokeUriPermission"	""	"1: direct"	"public void testDirectGrantRevokeUriPermission() throws Exception {
        final ContentResolver resolver = getContext().getContentResolver();

        final Uri target = Uri.withAppendedPath(PERM_URI_GRANTING, ""foo3"");
        final Uri targetMeow = Uri.withAppendedPath(target, ""meow"");
        final Uri targetMeowCat = Uri.withAppendedPath(targetMeow, ""cat"");

        final ClipData clip = makeSingleClipData(target);
        final ClipData clipMeow = makeSingleClipData(targetMeow);
        final ClipData clipMeowCat = makeSingleClipData(targetMeowCat);

        // Make sure we can't see the target
        assertReadingClipNotAllowed(clipMeow, ""reading should have failed"");
        assertWritingClipNotAllowed(clipMeow, ""writing should have failed"");

        // Give ourselves some grants:
        // /meow/cat  WRITE|PERSISTABLE
        // /meow      READ|PREFIX
        // /meow      WRITE
        grantClipUriPermissionViaContext(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
        grantClipUriPermissionViaContext(targetMeow, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION);
        grantClipUriPermissionViaContext(targetMeow, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);

        long before = System.currentTimeMillis();
        resolver.takePersistableUriPermission(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        long after = System.currentTimeMillis();
        assertPersistedUriPermission(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, before, after);

        // Verify they look good
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertReadingClipAllowed(clipMeow);
        assertReadingClipAllowed(clipMeowCat);
        assertWritingClipNotAllowed(clip, ""writing should have failed"");
        assertWritingClipAllowed(clipMeow);
        assertWritingClipAllowed(clipMeowCat);

        // Revoke anyone with write under meow
        revokeClipUriPermissionViaContext(targetMeow, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);

        // This should have nuked persisted permission at lower level, but it
        // shoulnd't have touched our prefix read.
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertReadingClipAllowed(clipMeow);
        assertReadingClipAllowed(clipMeowCat);
        assertWritingClipNotAllowed(clip, ""writing should have failed"");
        assertWritingClipNotAllowed(clipMeow, ""writing should have failed"");
        assertWritingClipNotAllowed(clipMeowCat, ""writing should have failed"");
        assertNoPersistedUriPermission();

        // Revoking read at top of tree should nuke everything else
        revokeClipUriPermissionViaContext(target, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertReadingClipNotAllowed(clipMeow, ""reading should have failed"");
        assertReadingClipNotAllowed(clipMeowCat, ""reading should have failed"");
        assertWritingClipNotAllowed(clip, ""writing should have failed"");
        assertWritingClipNotAllowed(clipMeow, ""writing should have failed"");
        assertWritingClipNotAllowed(clipMeowCat, ""writing should have failed"");
        assertNoPersistedUriPermission();
    }

    /**
     * Validate behavior of a direct permission grant, where the receiver of
     * that permission revokes it.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsTest"	"testDirectGrantReceiverRevokeUriPermission"	""	"1: direct"	"public void testDirectGrantReceiverRevokeUriPermission() throws Exception {
        final ContentResolver resolver = getContext().getContentResolver();

        final Uri target = Uri.withAppendedPath(PERM_URI_GRANTING, ""foo3"");
        final Uri targetMeow = Uri.withAppendedPath(target, ""meow"");
        final Uri targetMeowCat = Uri.withAppendedPath(targetMeow, ""cat"");

        final ClipData clip = makeSingleClipData(target);
        final ClipData clipMeow = makeSingleClipData(targetMeow);
        final ClipData clipMeowCat = makeSingleClipData(targetMeowCat);

        // Make sure we can't see the target
        assertReadingClipNotAllowed(clipMeow, ""reading should have failed"");
        assertWritingClipNotAllowed(clipMeow, ""writing should have failed"");

        // Give ourselves some grants:
        // /meow/cat  WRITE|PERSISTABLE
        // /meow      READ|PREFIX
        // /meow      WRITE
        grantClipUriPermissionViaContext(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
        grantClipUriPermissionViaContext(targetMeow, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION);
        grantClipUriPermissionViaContext(targetMeow, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);

        long before = System.currentTimeMillis();
        resolver.takePersistableUriPermission(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        long after = System.currentTimeMillis();
        assertPersistedUriPermission(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, before, after);

        // Verify they look good
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertReadingClipAllowed(clipMeow);
        assertReadingClipAllowed(clipMeowCat);
        assertWritingClipNotAllowed(clip, ""writing should have failed"");
        assertWritingClipAllowed(clipMeow);
        assertWritingClipAllowed(clipMeowCat);

        // Revoke anyone with write under meow
        getContext().revokeUriPermission(targetMeow, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);

        // This should have nuked persisted permission at lower level, but it
        // shoulnd't have touched our prefix read.
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertReadingClipAllowed(clipMeow);
        assertReadingClipAllowed(clipMeowCat);
        assertWritingClipNotAllowed(clip, ""writing should have failed"");
        assertWritingClipNotAllowed(clipMeow, ""writing should have failed"");
        assertWritingClipNotAllowed(clipMeowCat, ""writing should have failed"");
        assertNoPersistedUriPermission();

        // Revoking read at top of tree should nuke everything else
        getContext().revokeUriPermission(target, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertReadingClipNotAllowed(clipMeow, ""reading should have failed"");
        assertReadingClipNotAllowed(clipMeowCat, ""reading should have failed"");
        assertWritingClipNotAllowed(clip, ""writing should have failed"");
        assertWritingClipNotAllowed(clipMeow, ""writing should have failed"");
        assertWritingClipNotAllowed(clipMeowCat, ""writing should have failed"");
        assertNoPersistedUriPermission();
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsClipboardTest"	"testClipboardWithoutPermission"	""	"1: direct"	"public void testClipboardWithoutPermission() throws Exception {
        for (Uri target : NOT_GRANTABLE) {
            Log.d(TAG, ""Testing "" + target);
            final ClipData clip = makeSingleClipData(target);

            // Can't see it directly
            assertReadingClipNotAllowed(clip);
            assertWritingClipNotAllowed(clip);

            // Can't put on clipboard if we don't own it
            try {
                setPrimaryClip(clip);
                fail(""Unexpected ability to put protected data "" + clip + "" on clipboard!"");
            } catch (Exception expected) {
            }
        }
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsClipboardTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.cts.statsdatom.permissionstate.DangerousPermissionStateTests"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"1: user"	"public void test/*
 *.
 */

package android.cts.statsdatom.permissionstate;

import static com.google.common.truth.Truth.assertThat;

import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;

import com.android.os.AtomsProto;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.util.ArrayList;
import java.util.List;

public class DangerousPermissionStateTests extends DeviceTestCase implements IBuildReceiver {
    private static final int FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED = 1 << 8;

    private IBuildInfo mCtsBuild;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        super.tearDown();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/permissionstate/DangerousPermissionStateTests.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.cts.statsdatom.permissionstate.DangerousPermissionStateTests"	"testDangerousPermissionState"	"CtsStatsdAtomHostTestCases"	"1: user"	"public void testDangerousPermissionState() throws Exception {

        final int FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED = 1 << 9;
        final int PROTECTION_FLAG_DANGEROUS = 1;
        final int PROTECTION_FLAG_INSTANT = 0x1000;

        // Set up what to collect
        ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.DANGEROUS_PERMISSION_STATE_FIELD_NUMBER);

        boolean verifiedKnowPermissionState = false;

        // Pull a report
        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        int testAppId = getAppId(DeviceUtils.getStatsdTestAppUid(getDevice()));

        for (AtomsProto.Atom atom : ReportUtils.getGaugeMetricAtoms(getDevice())) {
            AtomsProto.DangerousPermissionState permissionState = atom.getDangerousPermissionState();

            assertThat(permissionState.getPermissionName()).isNotNull();
            assertThat(permissionState.getUid()).isAtLeast(0);
            assertThat(permissionState.getPackageName()).isNotNull();

            if (getAppId(permissionState.getUid()) == testAppId) {

                if (permissionState.getPermissionName().contains(
                        ""ACCESS_FINE_LOCATION"")) {
                    assertThat(permissionState.getIsGranted()).isTrue();
                    assertThat(permissionState.getPermissionFlags() & ~(
                            FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED
                                    | FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED))
                            .isEqualTo(0);
                    assertThat(permissionState.getProtectionFlags()).isEqualTo(
                            PROTECTION_FLAG_DANGEROUS | PROTECTION_FLAG_INSTANT
                    );

                    verifiedKnowPermissionState = true;
                }
            }
        }

        assertThat(verifiedKnowPermissionState).isTrue();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/permissionstate/DangerousPermissionStateTests.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.cts.statsdatom.permissionstate.DangerousPermissionStateTests"	"testDangerousPermissionStateSampled"	"CtsStatsdAtomHostTestCases"	"1: user"	"public void testDangerousPermissionStateSampled() throws Exception {
        // get full atom for reference
        ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.DANGEROUS_PERMISSION_STATE_FIELD_NUMBER);

        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        List<AtomsProto.DangerousPermissionState> fullDangerousPermissionState = new ArrayList<>();
        for (AtomsProto.Atom atom : ReportUtils.getGaugeMetricAtoms(getDevice())) {
            fullDangerousPermissionState.add(atom.getDangerousPermissionState());
        }

        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice()); // Clears data.
        List<AtomsProto.Atom> gaugeMetricDataList = null;

        // retries in case sampling returns full list or empty list - which should be extremely rare
        for (int attempt = 0; attempt < 10; attempt++) {
            // Set up what to collect
            ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                    AtomsProto.Atom.DANGEROUS_PERMISSION_STATE_SAMPLED_FIELD_NUMBER);

            // Pull a report
            AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
            Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

            gaugeMetricDataList = ReportUtils.getGaugeMetricAtoms(getDevice());
            if (gaugeMetricDataList.size() > 0
                    && gaugeMetricDataList.size() < fullDangerousPermissionState.size()) {
                break;
            }
            ConfigUtils.removeConfig(getDevice());
            ReportUtils.clearReports(getDevice()); // Clears data.
        }
        assertThat(gaugeMetricDataList.size()).isGreaterThan(0);
        assertThat(gaugeMetricDataList.size()).isLessThan(fullDangerousPermissionState.size());

        long lastUid = -1;
        int fullIndex = 0;

        for (AtomsProto.Atom atom : ReportUtils.getGaugeMetricAtoms(getDevice())) {
            AtomsProto.DangerousPermissionStateSampled permissionState =
                    atom.getDangerousPermissionStateSampled();

            AtomsProto.DangerousPermissionState referenceState
                    = fullDangerousPermissionState.get(fullIndex);

            if (referenceState.getUid() != permissionState.getUid()) {
                // atoms are sampled on uid basis if uid is present, all related permissions must
                // be logged.
                assertThat(permissionState.getUid()).isNotEqualTo(lastUid);
                continue;
            }

            lastUid = permissionState.getUid();

            assertThat(permissionState.getPermissionFlags()).isEqualTo(
                    referenceState.getPermissionFlags());
            assertThat(permissionState.getIsGranted()).isEqualTo(referenceState.getIsGranted());
            assertThat(permissionState.getPermissionName()).isEqualTo(
                    referenceState.getPermissionName());
            assertThat(permissionState.getProtectionFlags()).isEqualTo(
                    referenceState.getProtectionFlags());

            fullIndex++;
        }
    }

    /**
     * The app id from a uid.
     *
     * @param uid The uid of the app
     *
     * @return The app id of the app
     *
     * @see android.os.UserHandle#getAppId
     */
    private static int getAppId(int uid) {
        return uid % 100000;
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/permissionstate/DangerousPermissionStateTests.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.directreportapi30.DirectReportAPI30Test"	"testSamplingRateMicToggleOff"	""	"2: direct user"	"public void testSamplingRateMicToggleOff() throws InterruptedException {
        // Only run this test if we know for sure that the highest direct report rate level of
        // corresponds to a sampling rate of > 200 Hz
        if (mDirectReportTestHelper.getSensor().getHighestDirectReportRateLevel()
                <= SensorDirectChannel.RATE_FAST) {
            return;
        }

        mDirectReportTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                mDirectReportTestHelper.getSensorEvents(SensorDirectChannel.RATE_VERY_FAST);

        double obtainedRate = SensorRatePermissionDirectReportTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mDirectReportTestHelper.errorWhenBelowExpectedRate(),
                obtainedRate > SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DirectReportAPI30/src/android/sensorratepermission/cts/directreportapi30/DirectReportAPI30Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.directreportapi30.DirectReportAPI30Test"	"testSamplingRateMicToggleOn"	""	"2: direct user"	"public void testSamplingRateMicToggleOn() throws InterruptedException {
        mDirectReportTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                mDirectReportTestHelper.getSensorEvents(SensorDirectChannel.RATE_VERY_FAST);

        double obtainedRate = SensorRatePermissionDirectReportTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mDirectReportTestHelper.errorWhenExceedCappedRate(),
                obtainedRate <= SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }

    /**
     * Test the case where a connection is ongoing while the mic toggle changes its state:
     * off -> on -> off. This test is to show that the sensor service is able to cap/uncap the
     * rate of ongoing direct sensor connections when the state of the mic toggle changes.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DirectReportAPI30/src/android/sensorratepermission/cts/directreportapi30/DirectReportAPI30Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.directreportapi30.DirectReportAPI30Test"	"testSamplingRateMicToggleOffOnOff"	""	"2: direct user"	"public void testSamplingRateMicToggleOffOnOff() throws InterruptedException {
        // Only run this test if we know for sure that the highest direct report rate level of
        // the sensor corresponds to a sampling rate of > 200 Hz and that the sensor supports
        // direct channel.
        Sensor s = mDirectReportTestHelper.getSensor();
        if (s.getHighestDirectReportRateLevel() <= SensorDirectChannel.RATE_FAST
                || !s.isDirectChannelTypeSupported(SensorDirectChannel.TYPE_HARDWARE_BUFFER)) {
            return;
        }
        // Start with the mic toggle off
        mDirectReportTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);

        // Configure a direct channel.
        int sensorEventCount = 5500; // 800 Hz * 2.5s  + 200 Hz * 2.5s + extra
        int sharedMemorySize = sensorEventCount *
                SensorRatePermissionDirectReportTestHelper.SENSORS_EVENT_SIZE;
        HardwareBuffer hardwareBuffer = HardwareBuffer.create(
                sharedMemorySize, 1, HardwareBuffer.BLOB, 1,
                HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_GPU_DATA_BUFFER
                        | HardwareBuffer.USAGE_SENSOR_DIRECT_DATA);
        SensorDirectChannel channel = mSensorManager.createDirectChannel(hardwareBuffer);
        int token = channel.configure(s, SensorDirectChannel.RATE_VERY_FAST);

        // Flip the mic toggle on
        mDirectReportTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);
        long startMicToggleOn = SystemClock.elapsedRealtimeNanos();
        SensorCtsHelper.sleep(
                SensorRatePermissionDirectReportTestHelper.TEST_RUN_TIME_PERIOD_MILLISEC / 2,
                TimeUnit.MILLISECONDS);
        long endMicToggleOn = SystemClock.elapsedRealtimeNanos();

        // Flip the mic toggle off
        mDirectReportTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        long startMicToggleOff = SystemClock.elapsedRealtimeNanos();
        SensorCtsHelper.sleep(
                SensorRatePermissionDirectReportTestHelper.TEST_RUN_TIME_PERIOD_MILLISEC / 2,
                TimeUnit.MILLISECONDS);

        // Read the sensor events out
        channel.configure(s, SensorDirectChannel.RATE_STOP);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                mDirectReportTestHelper.readEventsFromHardwareBuffer(token,
                        hardwareBuffer, sensorEventCount);
        channel.close();
        hardwareBuffer.close();

        // Check the sampling rates when the mic toggle were on and off
        double rateWhenMicToggleOn =
                SensorRatePermissionDirectReportTestHelper.computeAvgRate(events,
                        startMicToggleOn, endMicToggleOn);
        Assert.assertTrue(mDirectReportTestHelper.errorWhenExceedCappedRate(),
                rateWhenMicToggleOn
                        <= SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);

        double rateWhenMicToggleOff = SensorRatePermissionDirectReportTestHelper.computeAvgRate(
                events, startMicToggleOff, Long.MAX_VALUE);
        Assert.assertTrue(mDirectReportTestHelper.errorWhenBelowExpectedRate(),
                rateWhenMicToggleOff
                        > SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DirectReportAPI30/src/android/sensorratepermission/cts/directreportapi30/DirectReportAPI30Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.debuggableapi31.DebuggableAPI31Test"	"testDirectChannel"	""	"1: direct"	"public void testDirectChannel() {
        try {
            Sensor s = mSensorManager.getDefaultSensor(sensorType);
            if (s == null) {
                return;
            }
            if (!s.isDirectChannelTypeSupported(SensorDirectChannel.TYPE_HARDWARE_BUFFER)
                    || s.getHighestDirectReportRateLevel() <= SensorDirectChannel.RATE_FAST) {
                return;
            }
            int rateLevel = SensorDirectChannel.RATE_VERY_FAST;
            HardwareBuffer hardwareBuffer = HardwareBuffer.create(
                    1000, 1, HardwareBuffer.BLOB, 1,
                    HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_GPU_DATA_BUFFER
                            | HardwareBuffer.USAGE_SENSOR_DIRECT_DATA);
            SensorDirectChannel channel = mSensorManager.createDirectChannel(hardwareBuffer);
            channel.configure(s, rateLevel);
            hardwareBuffer.close();
            fail(""Should have thrown a SecurityException"");
        } catch (SecurityException e) {
            // Expected
        }
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DebuggableAPI31/src/android/sensorratepermission/cts/debuggableapi31/DebuggableAPI31Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.eventconnectionapi30.EventConnectionAPI30Test"	"testSamplingRateMicToggleOff"	""	"1: user"	"public void testSamplingRateMicToggleOff() throws InterruptedException {
        // Only run this test if minDelay of the sensor is smaller than the capped min delay
        if (mUncappedMinDelayMicros >= mCappedMinDelayMicros) {
            return;
        }

        mEventConnectionTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        List<TestSensorEvent> events = mEventConnectionTestHelper.getSensorEvents(
                true,
                NUM_EVENTS_COUNT);
        double obtainedRate = SensorRatePermissionEventConnectionTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mEventConnectionTestHelper.errorWhenBelowExpectedRate(),
                obtainedRate
                        > SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/EventConnectionAPI30/src/android/sensorratepermission/cts/eventconnectionapi30/EventConnectionAPI30Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.eventconnectionapi30.EventConnectionAPI30Test"	"testSamplingRateMicToggleOn"	""	"1: user"	"public void testSamplingRateMicToggleOn() throws InterruptedException {
        mEventConnectionTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);

        List<TestSensorEvent> events = mEventConnectionTestHelper.getSensorEvents(
                true,
                NUM_EVENTS_COUNT);
        double obtainedRate = SensorRatePermissionEventConnectionTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mEventConnectionTestHelper.errorWhenExceedCappedRate(),
                obtainedRate
                        <= SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }

    /**
     * Test the case where a connection is ongoing while the mic toggle changes its state:
     * off -> on -> off. This test is to show that the sensor service is able to cap/uncap the
     * rate of ongoing SensorEventConnections when the state of the mic toggle changes.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/EventConnectionAPI30/src/android/sensorratepermission/cts/eventconnectionapi30/EventConnectionAPI30Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.eventconnectionapi30.EventConnectionAPI30Test"	"testSamplingRateMicToggleOffOnOff"	""	"1: user"	"public void testSamplingRateMicToggleOffOnOff() throws InterruptedException {
        // Only run this test if minDelay of the sensor is smaller than the capped min delay
        if (mUncappedMinDelayMicros >= mCappedMinDelayMicros) {
            return;
        }
        // Start with the mic toggle off
        mEventConnectionTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        // Register a listener
        TestSensorEventListener listener = new TestSensorEventListener(mTestEnvironment);
        TestSensorManager testSensorManager = new TestSensorManager(mTestEnvironment);
        testSensorManager.registerListener(listener);

        // Flip the mic toggle on and clear all the events so far.
        mEventConnectionTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);
        listener.clearEvents();

        // Wait for 1000 events and check the sampling rates.
        CountDownLatch eventLatch = listener.getLatchForSensorEvents(1000 /*numOfEvents*/);
        listener.waitForEvents(eventLatch, 1000 /*numOfEvents*/, false);
        List<TestSensorEvent> events = listener.getCollectedEvents();
        double rateWhenMicToggleOn =
                SensorRatePermissionEventConnectionTestHelper.computeAvgRate(events,
                        Long.MIN_VALUE, Long.MAX_VALUE);
        Assert.assertTrue(mEventConnectionTestHelper.errorWhenExceedCappedRate(),
                rateWhenMicToggleOn
                        <= SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);

        // Flip the mic toggle off, clear all the events so far.
        mEventConnectionTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        listener.clearEvents();

        // Wait for 2000 events and check the sampling rates.
        eventLatch = listener.getLatchForSensorEvents(2000 /*numOfEvents*/);
        listener.waitForEvents(eventLatch, 2000 /*numOfEvents*/, false);
        events = listener.getCollectedEvents();
        double rateWhenMicToggleOff = SensorRatePermissionEventConnectionTestHelper.computeAvgRate(
                events, Long.MIN_VALUE, Long.MAX_VALUE);
        Assert.assertTrue(mEventConnectionTestHelper.errorWhenBelowExpectedRate(),
                rateWhenMicToggleOff
                        > SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);

        listener.clearEvents();
        testSensorManager.unregisterListener();
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/EventConnectionAPI30/src/android/sensorratepermission/cts/eventconnectionapi30/EventConnectionAPI30Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.returnedrateinfo.ReturnedRateInfoTest"	"getSensorList"	""	"1: direct"	"/*
 *.
 */

package android.sensorratepermission.cts.returnedrateinfo;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorManager;
import android.hardware.cts.helpers.SensorRatePermissionDirectReportTestHelper;
import android.hardware.cts.helpers.SensorRatePermissionEventConnectionTestHelper;

import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.util.Collection;
import java.util.List;

/**
 * Test output of the following methods when the app targets API level >= S.
 * - getMinDelay()
 * - getSensorList()
 * - getHighestDirectReportRateLevel()
 */
@RunWith(Parameterized.class)
public class ReturnedRateInfoTest {
    private static SensorManager mSensorManager;

    private final int sensorType;

    public ReturnedRateInfoTest(int sensorType) {
        this.sensorType = sensorType;
    }

    @Parameterized.Parameters
    public static Collection cappedSensorTypeSet() {
        return SensorRatePermissionEventConnectionTestHelper.CAPPED_SENSOR_TYPE_SET;
    }

    @Before
    public void setUp() {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        mSensorManager = context.getSystemService(SensorManager.class);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/ReturnedRateInfo/src/android/sensorratepermission/cts/returnedrateinfo/ReturnedRateInfoTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.returnedrateinfo.ReturnedRateInfoTest"	"testGetHighestDirectReportRateLevelMethod"	""	"1: direct"	"public void testGetHighestDirectReportRateLevelMethod() {
        Sensor s = mSensorManager.getDefaultSensor(sensorType);
        if (s == null) {
            return;
        }
        int obtainedHighestRateLevel = s.getHighestDirectReportRateLevel();

        Assert.assertTrue(""Highest direct report rate level cannot be larger than ""
                        + SensorRatePermissionDirectReportTestHelper.CAPPED_DIRECT_REPORT_RATE_LEVEL,
                obtainedHighestRateLevel
                        <= SensorRatePermissionDirectReportTestHelper.CAPPED_DIRECT_REPORT_RATE_LEVEL);
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/ReturnedRateInfo/src/android/sensorratepermission/cts/returnedrateinfo/ReturnedRateInfoTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.directreportapi31.DirectReportAPI31Test"	"testSamplingRateMicToggleOn"	""	"2: direct user"	"public void testSamplingRateMicToggleOn() throws InterruptedException {
        mDirectReportTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                mDirectReportTestHelper.getSensorEvents(SensorDirectChannel.RATE_VERY_FAST);

        double obtainedRate = SensorRatePermissionDirectReportTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mDirectReportTestHelper.errorWhenExceedCappedRate(),
                obtainedRate <= SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DirectReportAPI31/src/android/sensorratepermission/cts/directreportapi31/DirectReportAPI31Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.directreportapi31.DirectReportAPI31Test"	"testSamplingRateMicToggleOff"	""	"2: direct user"	"public void testSamplingRateMicToggleOff() throws InterruptedException {
        mDirectReportTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                mDirectReportTestHelper.getSensorEvents(SensorDirectChannel.RATE_VERY_FAST);

        double obtainedRate = SensorRatePermissionDirectReportTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mDirectReportTestHelper.errorWhenExceedCappedRate(),
                obtainedRate <= SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DirectReportAPI31/src/android/sensorratepermission/cts/directreportapi31/DirectReportAPI31Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.eventconnectionapi31.EventConnectionAPI31Test"	"testSamplingRateMicToggleOn"	""	"1: user"	"public void testSamplingRateMicToggleOn() throws InterruptedException {
        mEventConnectionTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);

        List<TestSensorEvent> events = mEventConnectionTestHelper.getSensorEvents(true,
                NUM_EVENTS_COUNT);

        double obtainedRate = SensorRatePermissionEventConnectionTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mEventConnectionTestHelper.errorWhenExceedCappedRate(),
                obtainedRate
                        <= SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/EventConnectionAPI31/src/android/sensorratepermission/cts/eventconnectionapi31/EventConnectionAPI31Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.sensorratepermission.cts.eventconnectionapi31.EventConnectionAPI31Test"	"testSamplingRateMicToggleOff"	""	"1: user"	"public void testSamplingRateMicToggleOff() throws InterruptedException {
        mEventConnectionTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);

        List<TestSensorEvent> events = mEventConnectionTestHelper.getSensorEvents(true,
                NUM_EVENTS_COUNT);
        double obtainedRate = SensorRatePermissionEventConnectionTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mEventConnectionTestHelper.errorWhenExceedCappedRate(),
                obtainedRate
                        <= SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/EventConnectionAPI31/src/android/sensorratepermission/cts/eventconnectionapi31/EventConnectionAPI31Test.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk29CanOptOutViaUpdate"	"CtsPermission2TestCases"	"1: tv"	"@AppModeFull
    public void testTargetingSdk29CanOptOutViaUpdate() throws Exception {
        installApp(APK_USES_STORAGE_DEFAULT_29, null);
        installApp(APK_USES_STORAGE_OPT_OUT_29, null);

        assertHasFullStorageAccess();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk29CanOptOutViaDowngradeTo28"	"CtsPermission2TestCases"	"1: tv"	"@AppModeFull
    public void testTargetingSdk29CanOptOutViaDowngradeTo28() throws Exception {
        installApp(APK_USES_STORAGE_DEFAULT_29, null);
        installApp(APK_USES_STORAGE_DEFAULT_28, null);

        assertHasFullStorageAccess();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testStorageTargetingSdk30CannotPreserveLegacyOnInstall"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    public void testStorageTargetingSdk30CannotPreserveLegacyOnInstall() throws Exception {
        installApp(APK_USES_STORAGE_PRESERVED_OPT_OUT_30, null);

        assertHasIsolatedStorageAccess();
    }

    private void assertHasFullStorageAccess() throws Exception {
        runWithShellPermissionIdentity(() -> {
            AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final int uid = getContext().getPackageManager().getPackageUid(PKG, 0);
            eventually(() -> assertThat(appOpsManager.unsafeCheckOpRawNoThrow(
                    AppOpsManager.OPSTR_LEGACY_STORAGE,
                    uid, PKG)).isEqualTo(AppOpsManager.MODE_ALLOWED));
        });
    }

    private void assertHasIsolatedStorageAccess() throws Exception {
        runWithShellPermissionIdentity(() -> {
            AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final int uid = getContext().getPackageManager().getPackageUid(PKG, 0);
            eventually(() -> assertThat(appOpsManager.unsafeCheckOpRawNoThrow(
                    AppOpsManager.OPSTR_LEGACY_STORAGE,
                    uid, PKG)).isNotEqualTo(AppOpsManager.MODE_ALLOWED));
        });
    }

    private void assertCannotWhitelistStorage() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();

        runWithShellPermissionIdentity(() -> {
            // Assert added only to none whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });

        // Assert we cannot add.
        try {
            packageManager.addWhitelistedRestrictedPermission(
                    PKG,
                    permission.READ_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }
        try {
            packageManager.addWhitelistedRestrictedPermission(
                    PKG,
                    permission.WRITE_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }

        runWithShellPermissionIdentity(() -> {
            // Assert added only to none whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });
    }

    private void assertCannotUnWhitelistStorage() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();

        runWithShellPermissionIdentity(() -> {
            // Assert added only to install whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.WRITE_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });

        try {
            // Assert we cannot remove.
            packageManager.removeWhitelistedRestrictedPermission(
                    PKG,
                    permission.READ_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }
        try {
            packageManager.removeWhitelistedRestrictedPermission(
                    PKG,
                    permission.WRITE_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }

        runWithShellPermissionIdentity(() -> {
            // Assert added only to install whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.WRITE_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });
    }

    private @NonNull Set<String> getPermissionsOfAppWithAnyOfFlags(int flags) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final Set<String> restrictedPermissions = new ArraySet<>();
        for (String permission : getRequestedPermissionsOfApp()) {
            PermissionInfo permInfo = packageManager.getPermissionInfo(permission, 0);

            if ((permInfo.flags & flags) != 0) {
                restrictedPermissions.add(permission);
            }
        }
        return restrictedPermissions;
    }

    private @NonNull Set<String> getRestrictedPermissionsOfApp() throws Exception {
        return getPermissionsOfAppWithAnyOfFlags(
                PermissionInfo.FLAG_HARD_RESTRICTED | PermissionInfo.FLAG_SOFT_RESTRICTED);
    }

    private @NonNull String[] getRequestedPermissionsOfApp() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo =
                packageManager.getPackageInfo(PKG, PackageManager.GET_PERMISSIONS);
        return packageInfo.requestedPermissions;
    }

    private static @NonNull Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static void runWithShellPermissionIdentity(@NonNull ThrowingRunnable command)
            throws Exception {
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .adoptShellPermissionIdentity();
        try {
            command.run();
        } finally {
            InstrumentationRegistry.getInstrumentation()
                    .getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }

    /**
     * Install an app.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installApp(
            @NonNull String app,
            @Nullable Set<String> whitelistedPermissions)
            throws Exception {
        // Install the app and whitelist/grant all permission if requested.
        String installResult = runShellCommand(""pm install -r --restrict-permissions "" + app);
        assertThat(installResult.trim()).isEqualTo(""Success"");

        final Set<String> adjustedWhitelistedPermissions;
        if (whitelistedPermissions == null) {
            adjustedWhitelistedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedWhitelistedPermissions = whitelistedPermissions;
        }

        final Set<String> adjustedGrantedPermissions = getRestrictedPermissionsOfApp();

        // Whitelist subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedWhitelistedPermissions) {
                packageManager.addWhitelistedRestrictedPermission(
                        PKG,
                        permission,
                        PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            }
        });

        // Grant subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedGrantedPermissions) {
                packageManager.grantRuntimePermission(PKG, permission, getContext().getUser());
                packageManager.updatePermissionFlags(
                        permission,
                        PKG,
                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,
                        0,
                        getContext().getUser());
            }
        });

        // Mark all permissions as reviewed as for pre-22 apps the restriction state might not be
        // applied until reviewed
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : getRequestedPermissionsOfApp()) {
                packageManager.updatePermissionFlags(
                        permission,
                        PKG,
                        PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED,
                        0,
                        getContext().getUser());
            }
        });
    }

    @After
    public void uninstallApp() {
        runShellCommand(""pm uninstall "" + PKG);
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.ContactsProviderTest"	"testInsertContacts"	"CtsPermission2TestCases"	"1: tv"	"public void testInsertContacts() {
        try {
            getContext().getContentResolver().insert(ContactsContract.Contacts.CONTENT_URI,
                    new ContentValues());
        } catch (SecurityException e) {
            fail(""insert(ContactsContract.Contacts.CONTENT_URI) threw SecurityException"");
        } catch (UnsupportedOperationException e) {
            // It is okay for this fail in this manner.
        }
    }

    /**
     * Verifies that query(ContactsContract.Profile.CONTENT_URI) only requires
     * permission {@link android.Manifest.permission#READ_CONTACTS}.
     */
    @SmallTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.ContactsProviderTest"	"testInsertProfile"	"CtsPermission2TestCases"	"1: tv"	"public void testInsertProfile() {
     try {
         getContext().getContentResolver().insert(ContactsContract.Profile.CONTENT_URI,
                new ContentValues(0));
        } catch (SecurityException e) {
            fail(""insert(ContactsContract.Profile.CONTENT_URI) threw SecurityException"");
        } catch (UnsupportedOperationException e) {
            // It is okay for this fail in this manner.
        }
    }

    /**
     * Verifies that update(ContactsContract.Profile.CONTENT_URI) only requires
     * permission {@link android.Manifest.permission#WRITE_CONTACTS}.
     */
    @SmallTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.ContactsProviderTest"	"testUpdateProfile"	"CtsPermission2TestCases"	"1: tv"	"public void testUpdateProfile() {
        getContext().getContentResolver().update(ContactsContract.Profile.CONTENT_URI,
                new ContentValues(0), null, null);
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.NoWriteSecureSettingsPermissionTest"	"testWriteSecureSettings"	"CtsPermission2TestCases"	"1: tv"	"public void testWriteSecureSettings() {
        try {
            ContentValues values = new ContentValues();
            values.put(Settings.Secure.NAME, Settings.Secure.ACCESSIBILITY_ENABLED);
            values.put(Settings.Secure.VALUE, Boolean.TRUE);
            getContext().getContentResolver().insert(Settings.Secure.CONTENT_URI, values);
            fail(""expected SecurityException requiring ""
                    + Manifest.permission.WRITE_SECURE_SETTINGS);
        } catch (SecurityException expected) {
           /* do nothing */
        }
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/NoWriteSecureSettingsPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"testDefaultAllRestrictedPermissionsWhitelistedAtInstall29"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    public void testDefaultAllRestrictedPermissionsWhitelistedAtInstall29() throws Exception {
        // Install with no changes to whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/,
                Collections.EMPTY_SET /*grantedPermissions*/);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsWhitelistedAtInstall29"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    public void testSomeRestrictedPermissionsWhitelistedAtInstall29() throws Exception {
        // Whitelist only these permissions.
        final Set<String> whitelistedPermissions = new ArraySet<>(2);
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with some whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(whitelistedPermissions,
                Collections.EMPTY_SET /*grantedPermissions*/);

        // Some restricted permission should be whitelisted.
        assertRestrictedPermissionWhitelisted(whitelistedPermissions);

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"testNoneRestrictedPermissionWhitelistedAtInstall29"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    public void testNoneRestrictedPermissionWhitelistedAtInstall29() throws Exception {
        // Install with all whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(Collections.emptySet(),
                Collections.EMPTY_SET /*grantedPermissions*/);

        // No restricted permission should be whitelisted.
        assertNoRestrictedPermissionWhitelisted();

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"testDefaultAllRestrictedPermissionsWhitelistedAtInstall22"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void testDefaultAllRestrictedPermissionsWhitelistedAtInstall22() throws Exception {
        // Install with no changes to whitelisted permissions
        runShellCommand(""pm install -g --force-queryable "" + APK_USES_SMS_CALL_LOG_22);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsWhitelistedAtInstall22"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void testSomeRestrictedPermissionsWhitelistedAtInstall22() throws Exception {
        // Whitelist only these permissions.
        final Set<String> whitelistedPermissions = new ArraySet<>(2);
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with some whitelisted permissions
        installApp(APK_USES_SMS_CALL_LOG_22, whitelistedPermissions, null /*grantedPermissions*/);

        // Some restricted permission should be whitelisted.
        assertRestrictedPermissionWhitelisted(whitelistedPermissions);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsGrantedAtInstall"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void testSomeRestrictedPermissionsGrantedAtInstall() throws Exception {
        // Grant only these permissions.
        final Set<String> grantedPermissions = new ArraySet<>(1);
        grantedPermissions.add(Manifest.permission.SEND_SMS);
        grantedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with no whitelisted permissions attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/, grantedPermissions);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // Some restricted permission should be granted.
        assertRestrictedPermissionGranted(grantedPermissions);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"testAllRestrictedPermissionsGrantedAtInstall"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void testAllRestrictedPermissionsGrantedAtInstall() throws Exception {
        // Install with whitelisted permissions attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/,
                null);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // Some restricted permission should be granted.
        assertAllRestrictedPermissionGranted();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"testWhitelistAccessControl"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    public void testWhitelistAccessControl() throws Exception {
        // Install with no whitelisted permissions not attempting to grant.
        installRestrictedPermissionUserApp(Collections.emptySet(), null);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadRestrictedPermissionsWhitelistingDefault"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    public void onSideLoadRestrictedPermissionsWhitelistingDefault() throws Exception {
        installRestrictedPermissionUserApp(new SessionParams(SessionParams.MODE_FULL_INSTALL));

        // All restricted permissions whitelisted on side-load by default
        assertAllRestrictedPermissionWhitelisted();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadAllRestrictedPermissionsWhitelisted"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    public void onSideLoadAllRestrictedPermissionsWhitelisted() throws Exception {
        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(SessionParams.RESTRICTED_PERMISSIONS_ALL);

        installRestrictedPermissionUserApp(params);

        assertAllRestrictedPermissionWhitelisted();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadWhitelistSomePermissions"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    public void onSideLoadWhitelistSomePermissions() throws Exception {
        Set<String> whitelistedPermissions = new ArraySet<>();
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(whitelistedPermissions);

        installRestrictedPermissionUserApp(params);

        assertRestrictedPermissionWhitelisted(whitelistedPermissions);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadWhitelistNoPermissions"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    public void onSideLoadWhitelistNoPermissions() throws Exception {
        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(Collections.emptySet());

        installRestrictedPermissionUserApp(params);

        assertNoRestrictedPermissionWhitelisted();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission2.cts.RestrictedPermissionsTest"	"isTrue"	"CtsPermission2TestCases"	"1: user"	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void shareUidBetweenRestrictedAndNotRestrictedApp() throws Exception {
        runShellCommand(
                ""pm install -g --force-queryable --restrict-permissions ""
                + APK_USES_SMS_RESTRICTED_SHARED_UID);
        runShellCommand(""pm install -g --force-queryable ""
                + APK_USES_SMS_NOT_RESTRICTED_SHARED_UID);

        eventually(
                () -> assertThat(isGranted(PKG_USES_SMS_RESTRICTED_SHARED_UID, READ_SMS)).isTrue());
        // The apps share a UID, hence the whitelisting is shared too
        assertThat(isGranted(PKG_USES_SMS_NOT_RESTRICTED_SHARED_UID, READ_SMS)).isTrue();
    }

    private static void installRestrictedPermissionUserApp(@NonNull SessionParams params)
            throws Exception {
        final CountDownLatch installLatch = new CountDownLatch(1);

        // Create an install result receiver.
        final BroadcastReceiver installReceiver = new BroadcastReceiver() {
            public void onReceive(Context context, Intent intent) {
                if (intent.getIntExtra(PackageInstaller.EXTRA_STATUS,
                        PackageInstaller.STATUS_FAILURE_INVALID)
                            == PackageInstaller.STATUS_SUCCESS) {
                    installLatch.countDown();
                }
            }
        };

        // Register the result receiver.
        final String action = ""android.permission2.cts.ACTION_INSTALL_COMMIT"";
        final IntentFilter intentFilter = new IntentFilter(action);
        getContext().registerReceiver(installReceiver, intentFilter);

        try {
            // Create a session.
            final PackageInstaller packageInstaller = getContext()
                    .getPackageManager().getPackageInstaller();
            final int sessionId = packageInstaller.createSession(params);
            final Session session = packageInstaller.openSession(sessionId);

            // Write the apk.
            try (
                    InputStream in = new BufferedInputStream(new FileInputStream(
                        new File(APK_USES_SMS_CALL_LOG_29)));
                    OutputStream out = session.openWrite(
                            APK_NAME_USES_SMS_CALL_LOG_29, 0, -1);
            ) {
                final byte[] buf = new byte[8192];
                int size;
                while ((size = in.read(buf)) != -1) {
                    out.write(buf, 0, size);
                }
            }

            final Intent intent = new Intent(action);
            final IntentSender intentSender = PendingIntent.getBroadcast(getContext(),
                    1, intent, PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE)
                    .getIntentSender();

            // Commit as shell to avoid confirm UI
            runWithShellPermissionIdentity(() -> {
                session.commit(intentSender);
                installLatch.await(UI_TIMEOUT, TimeUnit.MILLISECONDS);
            });
        } finally {
            getContext().unregisterReceiver(installReceiver);
        }
    }

    private void assertWeCannotReadOrWriteWhileShellCanReadAndWrite(int whitelist)
            throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        try {
            packageManager.getWhitelistedRestrictedPermissions(PKG, whitelist);
            fail();
        } catch (SecurityException expected) {
            /*ignore*/
        }
        try {
            packageManager.addWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            fail();
        } catch (SecurityException expected) {
            /*ignore*/
        }
        runWithShellPermissionIdentity(() -> {
            packageManager.addWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    whitelist)).contains(permission.SEND_SMS);
            packageManager.removeWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    whitelist)).doesNotContain(permission.SEND_SMS);
        });
    }

    private @NonNull Set<String> getPermissionsOfAppWithAnyOfFlags(int flags) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final Set<String> restrictedPermissions = new ArraySet<>();
        for (String permission : getRequestedPermissionsOfApp()) {
            PermissionInfo permInfo = packageManager.getPermissionInfo(permission, 0);

            if ((permInfo.flags & flags) != 0) {
                restrictedPermissions.add(permission);
            }
        }
        return restrictedPermissions;
    }

    private @NonNull Set<String> getRestrictedPermissionsOfApp() throws Exception {
        return getPermissionsOfAppWithAnyOfFlags(
                PermissionInfo.FLAG_HARD_RESTRICTED | PermissionInfo.FLAG_SOFT_RESTRICTED);
    }

    private @NonNull String[] getRequestedPermissionsOfApp() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(PKG,
                PackageManager.GET_PERMISSIONS);
        return packageInfo.requestedPermissions;
    }

    private void assertAllRestrictedPermissionWhitelisted() throws Exception {
        assertRestrictedPermissionWhitelisted(getRestrictedPermissionsOfApp());
    }

    private void assertNoRestrictedPermissionWhitelisted() throws Exception {
        assertRestrictedPermissionWhitelisted(
                Collections.EMPTY_SET /*expectedWhitelistedPermissions*/);
    }

    /**
     * Assert that the passed in restrictions are whitelisted and that their app-op is set
     * correctly.
     *
     * @param expectedWhitelistedPermissions The expected white listed permissions
     */
    private void assertRestrictedPermissionWhitelisted(
            @NonNull Set<String> expectedWhitelistedPermissions) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        eventually(() -> runWithShellPermissionIdentity(() -> {
            final AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final PackageInfo packageInfo = packageManager.getPackageInfo(PKG,
                    PackageManager.GET_PERMISSIONS);

            final Set<String> whitelistedPermissions = packageManager
                .getWhitelistedRestrictedPermissions(PKG,
                        PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                        | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER
                        | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE);

            assertThat(whitelistedPermissions).isNotNull();
            assertWithMessage(""Whitelisted permissions"").that(whitelistedPermissions)
                    .containsExactlyElementsIn(expectedWhitelistedPermissions);

            // Also assert that apps ops are properly set
            for (String permission : getRestrictedPermissionsOfApp()) {
                String op = AppOpsManager.permissionToOp(permission);
                ArraySet<Integer> possibleModes = new ArraySet<>();

                if (permission.equals(Manifest.permission.ACCESS_BACKGROUND_LOCATION)) {
                    op = AppOpsManager.OPSTR_FINE_LOCATION;

                    // If permission is denied app-op might be allowed/fg or ignored. It does
                    // not matter. If permission is granted, it has to be allowed/fg.
                    if (isPermissionGranted(PKG, Manifest.permission.ACCESS_FINE_LOCATION)) {
                        if (expectedWhitelistedPermissions.contains(permission)
                                && isPermissionGranted(PKG, permission)) {
                            possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        } else {
                            possibleModes.add(AppOpsManager.MODE_FOREGROUND);
                        }
                    } else {
                        possibleModes.add(AppOpsManager.MODE_IGNORED);
                        possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        possibleModes.add(AppOpsManager.MODE_FOREGROUND);
                    }
                } else {
                    if (expectedWhitelistedPermissions.contains(permission)) {
                        // If permission is denied app-op might be allowed or ignored. It does not
                        // matter. If permission is granted, it has to be allowed.
                        possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        if (!isPermissionGranted(PKG, permission)) {
                            possibleModes.add(AppOpsManager.MODE_IGNORED);
                        }
                    } else {
                        possibleModes.add(AppOpsManager.MODE_IGNORED);
                    }
                }

                assertWithMessage(op).that(appOpsManager.unsafeCheckOpRawNoThrow(op,
                        packageInfo.applicationInfo.uid, PKG)).isIn(possibleModes);
            }
        }));
    }

    private void assertAllRestrictedPermissionGranted() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(
                PKG, PackageManager.GET_PERMISSIONS);
        if (packageInfo.requestedPermissions != null) {
            final int permissionCount = packageInfo.requestedPermissions.length;
            for (int i = 0; i < permissionCount; i++) {
                final String permission = packageInfo.requestedPermissions[i];
                final PermissionInfo permissionInfo = packageManager.getPermissionInfo(
                        permission, 0);
                if ((permissionInfo.flags & PermissionInfo.FLAG_HARD_RESTRICTED) != 0) {
                    assertThat((packageInfo.requestedPermissionsFlags[i]
                            & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isNotEqualTo(0);
                }
            }
        }
    }

    private void assertNoRestrictedPermissionGranted() throws Exception {
        assertRestrictedPermissionGranted(Collections.EMPTY_SET);
    }

    private void assertRestrictedPermissionGranted(@NonNull Set<String> expectedGrantedPermissions)
            throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(
                PKG, PackageManager.GET_PERMISSIONS);
        if (packageInfo.requestedPermissions != null) {
            final int permissionCount = packageInfo.requestedPermissions.length;
            for (int i = 0; i < permissionCount; i++) {
                final String permission = packageInfo.requestedPermissions[i];
                final PermissionInfo permissionInfo = packageManager.getPermissionInfo(
                        permission, 0);
                if ((permissionInfo.flags & PermissionInfo.FLAG_HARD_RESTRICTED) != 0
                        || (permissionInfo.flags & PermissionInfo.FLAG_SOFT_RESTRICTED) != 0) {
                    if (expectedGrantedPermissions.contains(permission)) {
                        assertThat((packageInfo.requestedPermissionsFlags[i]
                                & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isNotEqualTo(0);
                    } else {
                        assertThat((packageInfo.requestedPermissionsFlags[i]
                                & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isEqualTo(0);
                    }
                }
            }
        }
    }

    /**
     * Install {@link #APK_USES_SMS_CALL_LOG_29}.
     *
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installRestrictedPermissionUserApp(@Nullable Set<String> whitelistedPermissions,
            @Nullable Set<String> grantedPermissions) throws Exception {
        installApp(APK_USES_SMS_CALL_LOG_29, whitelistedPermissions, grantedPermissions);
    }

    /**
     * Install app and grant all permission.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     */
    private void installApp(@NonNull String app, @Nullable Set<String> whitelistedPermissions)
            throws Exception {
        installApp(app, whitelistedPermissions, null /*grantedPermissions*/);
    }

    /**
     * Install an app.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installApp(@NonNull String app, @Nullable Set<String> whitelistedPermissions,
            @Nullable Set<String> grantedPermissions) throws Exception {
        // Install the app and whitelist/grant all permission if requested.
        String installResult = runShellCommand(""pm install -r --force-queryable ""
                + ""--restrict-permissions "" + app);
        assertThat(installResult.trim()).isEqualTo(""Success"");

        final Set<String> adjustedWhitelistedPermissions;
        if (whitelistedPermissions == null) {
            adjustedWhitelistedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedWhitelistedPermissions = whitelistedPermissions;
        }

        final Set<String> adjustedGrantedPermissions;
        if (grantedPermissions == null) {
            adjustedGrantedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedGrantedPermissions = grantedPermissions;
        }

        // Whitelist subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedWhitelistedPermissions) {
                packageManager.addWhitelistedRestrictedPermission(PKG, permission,
                        PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            }
        });

        // Grant subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedGrantedPermissions) {
                packageManager.grantRuntimePermission(PKG, permission,
                        getContext().getUser());
                packageManager.updatePermissionFlags(permission, PKG,
                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, 0, getContext().getUser());
            }
        });

        // Mark all permissions as reviewed as for pre-22 apps the restriction state might not be
        // applied until reviewed
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : getRequestedPermissionsOfApp()) {
                packageManager.updatePermissionFlags(permission, PKG,
                        PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED, 0,
                        getContext().getUser());
            }
        });
    }

    @After
    public void uninstallApp() {
        runShellCommand(""pm uninstall "" + PKG);
        runShellCommand(""pm uninstall "" + PKG_USES_SMS_NOT_RESTRICTED_SHARED_UID);
        runShellCommand(""pm uninstall "" + PKG_USES_SMS_RESTRICTED_SHARED_UID);
    }

    private static @NonNull Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static void runWithShellPermissionIdentity(@NonNull ThrowingRunnable command)
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity();
        try {
            command.run();
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.telephony.cts.telephonypermission.TelephonyManagerReadPhoneStatePermissionTest"	"getVisualVoicemailPackageName"	"CtsTelephonyTestCases"	"1: tv"	"/*
 *.
 */

package android.telephony.cts.telephonypermission;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;

import android.content.Context;
import android.content.pm.PackageManager;
import android.platform.test.annotations.AppModeFull;
import android.telecom.PhoneAccount;
import android.telecom.TelecomManager;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.telephony.cts.TelephonyUtils;
import android.telephony.emergency.EmergencyNumber;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test TelephonyManager APIs with READ_PHONE_STATE Permission.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Cannot grant the runtime permission in instant app mode"")
public class TelephonyManagerReadPhoneStatePermissionTest {

    private boolean mHasTelephony;
    TelephonyManager mTelephonyManager = null;
    TelecomManager mTelecomManager = null;

    @Before
    public void setUp() throws Exception {
        mHasTelephony = getContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_TELEPHONY);
        mTelephonyManager =
                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
        assertNotNull(mTelephonyManager);
        mTelecomManager =
                (TelecomManager) getContext().getSystemService(Context.TELECOM_SERVICE);
        assertNotNull(mTelecomManager);
    }

    @After
    public void tearDown() throws Exception {
        TelephonyUtils.resetCompatCommand(InstrumentationRegistry.getInstrumentation(),
                TelephonyUtils.CTS_APP_PACKAGE,
                TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
    }

    /**
     * Verify that TelephonyManager APIs requiring READ_PHONE_STATE Permission must work.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE}.
     *
     * APIs list:
     * getDeviceSoftwareVersion()
     * getCarrierConfig()
     * getNetworkType()
     * getDataNetworkType()
     * getVoiceNetworkType()
     * getGroupIdLevel1()
     * getLine1AlphaTag()
     * getVoiceMailNumber()
     * getVisualVoicemailPackageName()
     * getVoiceMailAlphaTag()
     * getForbiddenPlmns()
     * isDataRoamingEnabled()
     * getSubscriptionId(@NonNull PhoneAccountHandle phoneAccountHandle)
     * getServiceState()
     * getEmergencyNumberList()
     * getEmergencyNumberList(@EmergencyServiceCategories int categories)
     * getPreferredOpportunisticDataSubscription()
     * isModemEnabledForSlot(int slotIndex)
     * isMultiSimSupported()
     * doesSwitchMultiSimConfigTriggerReboot()
     * getCallState() (when compat fwk enables enforcement)
     * getCallStateForSubscription() (when compat fwk enables enforcement)
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/permissions/src/android/telephony/cts/telephonypermission/TelephonyManagerReadPhoneStatePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.telephony.cts.telephonypermission.TelephonyManagerReadPhoneStatePermissionTest"	"testTelephonyManagersAPIsRequiringReadPhoneStatePermissions"	"CtsTelephonyTestCases"	"1: tv"	"public void testTelephonyManagersAPIsRequiringReadPhoneStatePermissions() throws Exception {
        if (!mHasTelephony) {
            return;
        }

        try {
            // We must ensure that compat fwk enables READ_PHONE_STATE enforcement
            TelephonyUtils.enableCompatCommand(InstrumentationRegistry.getInstrumentation(),
                    TelephonyUtils.CTS_APP_PACKAGE,
                    TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getCallState());
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getCallStateForSubscription());
        } catch (SecurityException e) {
            fail(""TelephonyManager#getCallState and TelephonyManager#getCallStateForSubscription ""
                    + ""must not throw a SecurityException because READ_PHONE_STATE permission is ""
                    + ""granted and TelecomManager#ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION is ""
                    + ""enabled."");
        }

        int subId = mTelephonyManager.getSubscriptionId();

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getNetworkType());
        } catch (SecurityException e) {
            fail(""getNetworkType() must not throw a SecurityException with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getDeviceSoftwareVersion());
        } catch (SecurityException e) {
            fail(""getDeviceSoftwareVersion() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getCarrierConfig());
        } catch (SecurityException e) {
            fail(""getCarrierConfig() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getDataNetworkType());
        } catch (SecurityException e) {
            fail(""getDataNetworkType() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getVoiceNetworkType());
        } catch (SecurityException e) {
            fail(""getVoiceNetworkType() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getGroupIdLevel1());
        } catch (SecurityException e) {
            fail(""getGroupIdLevel1() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getLine1AlphaTag());
        } catch (SecurityException e) {
            fail(""getLine1AlphaTag() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getVoiceMailNumber());
        } catch (SecurityException e) {
            fail(""getVoiceMailNumber() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getVisualVoicemailPackageName());
        } catch (SecurityException e) {
            fail(""getVisualVoicemailPackageName() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getVoiceMailAlphaTag());
        } catch (SecurityException e) {
            fail(""getVoiceMailAlphaTag() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getForbiddenPlmns());
        } catch (SecurityException e) {
            fail(""getForbiddenPlmns() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.isDataRoamingEnabled());
        } catch (SecurityException e) {
            fail(""isDataRoamingEnabled() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getSubscriptionId(
                            mTelecomManager.getDefaultOutgoingPhoneAccount(
                                    PhoneAccount.SCHEME_TEL)));
        } catch (SecurityException e) {
            fail(""getSubscriptionId(phoneAccountHandle) must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getServiceState());
        } catch (SecurityException e) {
            fail(""getServiceState() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getEmergencyNumberList());
        } catch (SecurityException e) {
            fail(""getEmergencyNumberList() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getEmergencyNumberList(
                            EmergencyNumber.EMERGENCY_SERVICE_CATEGORY_POLICE));
        } catch (SecurityException e) {
            fail(""getEmergencyNumberList(EMERGENCY_SERVICE_CATEGORY_POLICE) must""
                    + "" not throw a SecurityException with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getPreferredOpportunisticDataSubscription());
        } catch (SecurityException e) {
            fail(""getPreferredOpportunisticDataSubscription() must not throw""
                    + "" a SecurityException with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.isModemEnabledForSlot(
                            SubscriptionManager.getSlotIndex(subId)));
        } catch (SecurityException e) {
            fail(""isModemEnabledForSlot(slotIndex) must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.isMultiSimSupported());
        } catch (SecurityException e) {
            fail(""isMultiSimSupported() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.doesSwitchMultiSimConfigTriggerReboot());
        } catch (SecurityException e) {
            fail(""doesSwitchMultiSimConfigTriggerReboot() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
    }

    private static Context getContext() {
        return InstrumentationRegistry.getContext();
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/permissions/src/android/telephony/cts/telephonypermission/TelephonyManagerReadPhoneStatePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testSetForbiddenPlmns"	"CtsPermissionTestCases"	"1: indicator"	"public void testSetForbiddenPlmns() {
        if (!mHasTelephony) {
            return;
        }

        try {
            mTelephonyManager.setForbiddenPlmns(new ArrayList<String>());
            fail(""SetForbiddenPlmns did not throw a SecurityException"");
        } catch (SecurityException e) {
            // expected
        }
    }

    static final int PHONE_STATE_PERMISSION_MASK =
                PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR
                        | PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR
                        | PhoneStateListener.LISTEN_EMERGENCY_NUMBER_LIST;

    static final int PRECISE_PHONE_STATE_PERMISSION_MASK =
                PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE
                        | PhoneStateListener.LISTEN_CALL_DISCONNECT_CAUSES
                        | PhoneStateListener.LISTEN_IMS_CALL_DISCONNECT_CAUSES
                        | PhoneStateListener.LISTEN_REGISTRATION_FAILURE
                        | PhoneStateListener.LISTEN_BARRING_INFO;

    static final int PHONE_PERMISSIONS_MASK =
            PHONE_STATE_PERMISSION_MASK | PRECISE_PHONE_STATE_PERMISSION_MASK;

    /**
     * Verify the documented permissions for PhoneStateListener.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testGetSubscriberId"	"CtsPermissionTestCases"	"1: tv"	"public void testGetSubscriberId() {
        if (!mHasTelephony) {
            return;
        }

        try {
            String sid = mTelephonyManager.getSubscriberId();
            fail(""Got subscriber id: "" + sid);
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that TelephonyManager.getVoiceMailNumber requires Permission.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE}.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testVoiceMailNumber"	"CtsPermissionTestCases"	"1: tv"	"public void testVoiceMailNumber() {
        if (!mHasTelephony) {
            return;
        }

        try {
            String vmnum = mTelephonyManager.getVoiceMailNumber();
            fail(""Got voicemail number: "" + vmnum);
        } catch (SecurityException e) {
            // expected
        }
    }
    /**
     * Verify that AudioManager.setMode requires Permission.
     * <p>
     * Requires Permissions:
     * {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS} and
     * {@link android.Manifest.permission#MODIFY_PHONE_STATE} for
     * {@link AudioManager#MODE_IN_CALL}.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_OnBehalfOfDisavowingApp"	"CtsPermissionTestCases"	"1: user"	"public void testRequestBluetoothPermission31_OnBehalfOfDisavowingApp() throws Throwable {
        install(APK_BLUETOOTH_31);
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_NO_PROVIDER);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(DISAVOWAL_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(DISAVOWAL_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(""PROXY"", Result.FILTERED);
    }

    /**
     * Verify that upgrading an app doesn't gain them any access to Bluetooth
     * scan results; they'd always need to involve the user to gain permissions.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission_Upgrade"	"CtsPermissionTestCases"	"1: user"	"@Ignore
    public void testRequestBluetoothPermission_Upgrade() throws Throwable {
        install(APK_BLUETOOTH_30);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);

        // Upgrading to target a new SDK level means they need to explicitly
        // request the new runtime permission; by default it's denied
        install(APK_BLUETOOTH_31);
        assertScanBluetoothResult(Result.EXCEPTION);

        // If the user does grant it, they can scan again
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.FULL);
    }

    /**
     * Verify that downgrading an app doesn't gain them any access to Bluetooth
     * scan results; they'd always need to involve the user to gain permissions.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.LocationAccessCheckTest"	"getPermissionControllerPackageName"	"CtsPermissionTestCases"	"2: visible user"	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.app.AppOpsManager.OPSTR_FINE_LOCATION;
import static android.app.AppOpsManager.OP_FLAGS_ALL_TRUSTED;
import static android.app.Notification.EXTRA_TITLE;
import static android.content.Context.BIND_AUTO_CREATE;
import static android.content.Context.BIND_NOT_FOREGROUND;
import static android.content.Intent.ACTION_BOOT_COMPLETED;
import static android.content.Intent.FLAG_RECEIVER_FOREGROUND;
import static android.location.Criteria.ACCURACY_FINE;
import static android.os.Process.myUserHandle;
import static android.provider.Settings.Secure.LOCATION_ACCESS_CHECK_DELAY_MILLIS;
import static android.provider.Settings.Secure.LOCATION_ACCESS_CHECK_INTERVAL_MILLIS;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;
import static com.android.server.job.nano.JobPackageHistoryProto.START_PERIODIC_JOB;
import static com.android.server.job.nano.JobPackageHistoryProto.STOP_JOB;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import static java.lang.Math.max;
import static java.util.concurrent.TimeUnit.MILLISECONDS;

import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.location.Criteria;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Looper;
import android.permission.cts.appthataccesseslocation.IAccessLocationOnCommand;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;
import android.platform.test.annotations.SystemUserOnly;
import android.provider.DeviceConfig;
import android.provider.Settings;
import android.service.notification.NotificationListenerService;
import android.service.notification.StatusBarNotification;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.DeviceConfigStateHelper;
import com.android.compatibility.common.util.ProtoUtils;
import com.android.compatibility.common.util.mainline.MainlineModule;
import com.android.compatibility.common.util.mainline.ModuleDetector;
import com.android.server.job.nano.JobPackageHistoryProto;
import com.android.server.job.nano.JobSchedulerServiceDumpProto;
import com.android.server.job.nano.JobSchedulerServiceDumpProto.RegisteredJob;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

/**
 * Tests the {@code LocationAccessCheck} in permission controller.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Cannot set system settings as instant app. Also we never show a location ""
        + ""access check notification for instant apps."")
public class LocationAccessCheckTest {
    private static final String LOG_TAG = LocationAccessCheckTest.class.getSimpleName();

    private static final String TEST_APP_PKG = ""android.permission.cts.appthataccesseslocation"";
    private static final String TEST_APP_LABEL = ""CtsLocationAccess"";
    private static final String TEST_APP_SERVICE = TEST_APP_PKG + "".AccessLocationOnCommand"";
    private static final String TEST_APP_LOCATION_BG_ACCESS_APK =
            ""/data/local/tmp/cts/permissions/CtsAppThatAccessesLocationOnCommand.apk"";
    private static final String TEST_APP_LOCATION_FG_ACCESS_APK =
            ""/data/local/tmp/cts/permissions/AppThatDoesNotHaveBgLocationAccess.apk"";
    private static final int LOCATION_ACCESS_CHECK_JOB_ID = 0;

    /** Whether to show location access check notifications. */
    private static final String PROPERTY_LOCATION_ACCESS_CHECK_ENABLED =
            ""location_access_check_enabled"";

    private static final long UNEXPECTED_TIMEOUT_MILLIS = 10000;
    private static final long EXPECTED_TIMEOUT_MILLIS = 15000;
    private static final long LOCATION_ACCESS_TIMEOUT_MILLIS = 15000;

    private static final Context sContext = InstrumentationRegistry.getTargetContext();
    private static final ActivityManager sActivityManager =
            sContext.getSystemService(ActivityManager.class);
    private static final PackageManager sPackageManager = sContext.getPackageManager();
    private static final AppOpsManager sAppOpsManager =
            sContext.getSystemService(AppOpsManager.class);
    private static final UiAutomation sUiAutomation = InstrumentationRegistry.getInstrumentation()
            .getUiAutomation();

    private static final String PERMISSION_CONTROLLER_PKG = sContext.getPackageManager()
            .getPermissionControllerPackageName();

    /**
     * The result of {@link #assumeCanGetFineLocation()}, so we don't have to run it over and over
     * again.
     */
    private static Boolean sCanAccessFineLocation = null;

    private static ServiceConnection sConnection;
    private static IAccessLocationOnCommand sLocationAccessor;

    private DeviceConfigStateHelper mPrivacyDeviceConfig =
            new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_PRIVACY);
    private static DeviceConfigStateHelper sJobSchedulerDeviceConfig =
            new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_JOB_SCHEDULER);

    private static void assumeNotPlayManaged() throws Exception {
        assumeFalse(ModuleDetector.moduleIsPlayManaged(
                sContext.getPackageManager(), MainlineModule.PERMISSION_CONTROLLER));
    }

    /**
     * Connected to {@value #TEST_APP_PKG} and make it access the location in the background
     */
    private void accessLocation() throws Throwable {
        if (sConnection == null || sLocationAccessor == null) {
            bindService();
        }

        long beforeAccess = System.currentTimeMillis();
        // Wait a little to avoid raciness in timing between threads
        Thread.sleep(1000);

        // Try again until binder call goes though. It might not go through if the sLocationAccessor
        // is not bound yet
        eventually(() -> {
            assertNotNull(sLocationAccessor);
            sLocationAccessor.accessLocation();
        }, EXPECTED_TIMEOUT_MILLIS);

        // Wait until the access is recorded
        eventually(() -> {
            List<AppOpsManager.PackageOps> ops = runWithShellPermissionIdentity(
                    () -> sAppOpsManager.getOpsForPackage(
                            sPackageManager.getPackageUid(TEST_APP_PKG, 0), TEST_APP_PKG,
                            OPSTR_FINE_LOCATION));

            // Background access must have happened after ""beforeAccess""
            assertTrue(ops.get(0).getOps().get(0).getLastAccessBackgroundTime(OP_FLAGS_ALL_TRUSTED)
                    >= beforeAccess);
        }, EXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * A {@link java.util.concurrent.Callable} that can throw a {@link Throwable}
     */
    private interface ThrowingCallable<T> {
        T call() throws Throwable;
    }

    /**
     * A {@link Runnable} that can throw a {@link Throwable}
     */
    private interface ThrowingRunnable {
        void run() throws Throwable;
    }

    /**
     * Make sure that a {@link ThrowingRunnable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r       The {@link ThrowingRunnable} to run.
     * @param timeout the maximum time to wait
     */
    public static void eventually(@NonNull ThrowingRunnable r, long timeout) throws Throwable {
        eventually(() -> {
            r.run();
            return 0;
        }, timeout);
    }

    /**
     * Make sure that a {@link ThrowingCallable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r       The {@link ThrowingCallable} to run.
     * @param timeout the maximum time to wait
     * @return the return value from the callable
     * @throws NullPointerException If the return value never becomes non-null
     */
    public static <T> T eventually(@NonNull ThrowingCallable<T> r, long timeout) throws Throwable {
        long start = System.currentTimeMillis();

        while (true) {
            try {
                T res = r.call();
                if (res == null) {
                    throw new NullPointerException(""No result"");
                }

                return res;
            } catch (Throwable e) {
                if (System.currentTimeMillis() - start < timeout) {
                    Log.d(LOG_TAG, ""Ignoring exception"", e);

                    Thread.sleep(500);
                } else {
                    throw e;
                }
            }
        }
    }

    /**
     * Get the state of the job scheduler
     */
    public static JobSchedulerServiceDumpProto getJobSchedulerDump() throws Exception {
        return ProtoUtils.getProto(sUiAutomation, JobSchedulerServiceDumpProto.class,
                ProtoUtils.DUMPSYS_JOB_SCHEDULER);
    }

    /**
     * Clear all data of a package including permissions and files.
     *
     * @param pkg The name of the package to be cleared
     */
    private static void clearPackageData(@NonNull String pkg) {
        unbindService();
        runShellCommand(""pm clear --user -2 "" + pkg);
    }

    /**
     * Get the last time the LOCATION_ACCESS_CHECK_JOB_ID job was started/stopped for permission
     * controller.
     *
     * @param event the job event (start/stop)
     *
     * @return the last time the event happened.
     */
    private static long getLastJobTime(int event) throws Exception {
        int permControllerUid = sPackageManager.getPackageUid(PERMISSION_CONTROLLER_PKG, 0);

        long lastTime = -1;

        for (JobPackageHistoryProto.HistoryEvent historyEvent :
                getJobSchedulerDump().history.historyEvent) {
            if (historyEvent.uid == permControllerUid
                    && historyEvent.jobId == LOCATION_ACCESS_CHECK_JOB_ID
                    && historyEvent.event == event) {
                lastTime = max(lastTime,
                        System.currentTimeMillis() - historyEvent.timeSinceEventMs);
            }
        }

        return lastTime;
    }

    /**
     * Force a run of the location check.
     */
    private static void runLocationCheck() throws Throwable {
        // Sleep a little bit to make sure we don't have overlap in timing
        Thread.sleep(1000);

        long beforeJob = System.currentTimeMillis();

        // Sleep a little bit to avoid raciness in time keeping
        Thread.sleep(1000);

        runShellCommand(
                ""cmd jobscheduler run -u "" + android.os.Process.myUserHandle().getIdentifier()
                        + "" -f "" + PERMISSION_CONTROLLER_PKG + "" 0"");

        eventually(() -> {
            long startTime = getLastJobTime(START_PERIODIC_JOB);
            assertTrue(startTime + "" !> "" + beforeJob, startTime > beforeJob);
        }, EXPECTED_TIMEOUT_MILLIS);

        // We can't simply require startTime <= endTime because the time being reported isn't
        // accurate, and sometimes the end time may come before the start time by around 100 ms.
        eventually(() -> {
            long stopTime = getLastJobTime(STOP_JOB);
            assertTrue(stopTime + "" !> "" + beforeJob, stopTime > beforeJob);
        }, EXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * Get a notification thrown by the permission controller that is currently visible.
     *
     * @return The notification or {@code null} if there is none
     */
    private @Nullable StatusBarNotification getPermissionControllerNotification() throws Exception {
        NotificationListenerService notificationService = NotificationListener.getInstance();

        for (StatusBarNotification notification : notificationService.getActiveNotifications()) {
            if (notification.getPackageName().equals(PERMISSION_CONTROLLER_PKG)) {
                return notification;
            }
        }

        return null;
    }

    /**
     * Get a location access notification that is currently visible.
     *
     * @param cancelNotification if {@code true} the notification is canceled inside this method
     * @return The notification or {@code null} if there is none
     */
    private StatusBarNotification getNotification(boolean cancelNotification) throws Throwable {
        NotificationListenerService notificationService = NotificationListener.getInstance();

        StatusBarNotification notification = getPermissionControllerNotification();
        if (notification == null) {
            return null;
        }

        if (notification.getNotification().extras.getString(EXTRA_TITLE, """")
                .contains(TEST_APP_LABEL)) {
            if (cancelNotification) {
                notificationService.cancelNotification(notification.getKey());

                // Wait for notification to get canceled
                eventually(() -> assertFalse(
                        Arrays.asList(notificationService.getActiveNotifications()).contains(
                                notification)), UNEXPECTED_TIMEOUT_MILLIS);
            }

            return notification;
        }

        Log.d(LOG_TAG, ""Bad notification "" + notification);

        return null;
    }

    /**
     * Grant a permission to the {@value #TEST_APP_PKG}.
     *
     * @param permission The permission to grant
     */
    private void grantPermissionToTestApp(@NonNull String permission) {
        sUiAutomation.grantRuntimePermission(TEST_APP_PKG, permission);
    }

    /**
     * Register {@link NotificationListener}.
     */
    @BeforeClass
    public static void allowNotificationAccess() {
        runShellCommand(""cmd notification allow_listener "" + (new ComponentName(sContext,
                NotificationListener.class).flattenToString()));
    }

    /**
     * Change settings so that permission controller can show location access notifications more
     * often.
     */
    @BeforeClass
    public static void reduceDelays() {
        runWithShellPermissionIdentity(() -> {
            ContentResolver cr = sContext.getContentResolver();

            // New settings will be applied in when permission controller is reset
            Settings.Secure.putLong(cr, LOCATION_ACCESS_CHECK_INTERVAL_MILLIS, 100);
            Settings.Secure.putLong(cr, LOCATION_ACCESS_CHECK_DELAY_MILLIS, 50);

            // Disable job scheduler throttling by allowing 300000 jobs per 30 sec
            sJobSchedulerDeviceConfig.set(""qc_max_job_count_per_rate_limiting_window"", ""3000000"");
            sJobSchedulerDeviceConfig.set(""qc_rate_limiting_window_ms"", ""30000"");
        });
    }

    @BeforeClass
    public static void installBackgroundAccessApp() throws Exception {
        installBackgroundAccessApp(false);
    }

    private static void installBackgroundAccessApp(boolean isDowngrade) throws Exception {
        String command = ""pm install -r -g "";
        if (isDowngrade) {
            command = command + ""-d "";
        }
        String output = runShellCommand(command + TEST_APP_LOCATION_BG_ACCESS_APK);
        assertTrue(output.contains(""Success""));
        // Wait for user sensitive to be updated, which is checked by LocationAccessCheck.
        Thread.sleep(5000);
    }

    @AfterClass
    public static void uninstallBackgroundAccessApp() {
        unbindService();
        runShellCommand(""pm uninstall "" + TEST_APP_PKG);
    }

    private static void unbindService() {
        if (sConnection != null) {
            sContext.unbindService(sConnection);
        }
        sConnection = null;
        sLocationAccessor = null;
    }


    private static void installForegroundAccessApp() throws Exception {
        unbindService();
        runShellCommand(""pm install -r -g "" + TEST_APP_LOCATION_FG_ACCESS_APK);
        // Wait for user sensitive to be updated, which is checked by LocationAccessCheck.
        Thread.sleep(5000);
    }

    private static void uninstallForegroundAccessApp() {
        runShellCommand(""pm uninstall "" + TEST_APP_LOCATION_FG_ACCESS_APK);
    }

    /**
     * Skip each test for low ram device
     */
    @Before
    public void assumeIsNotLowRamDevice() {
        assumeFalse(sActivityManager.isLowRamDevice());
    }

    @Before
    public void wakeUpAndDismissKeyguard() {
        runShellCommand(""input keyevent KEYCODE_WAKEUP"");
        runShellCommand(""wm dismiss-keyguard"");
    }

    @Before
    public void bindService() {
        sConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                sLocationAccessor = IAccessLocationOnCommand.Stub.asInterface(service);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                sConnection = null;
                sLocationAccessor = null;
            }
        };

        Intent testAppService = new Intent();
        testAppService.setComponent(new ComponentName(TEST_APP_PKG, TEST_APP_SERVICE));

        sContext.bindService(testAppService, sConnection, BIND_AUTO_CREATE | BIND_NOT_FOREGROUND);
    }

    /**
     * Reset the permission controllers state before each test
     */
    @Before
    public void resetPermissionControllerBeforeEachTest() throws Throwable {
        // Has to be before resetPermissionController to make sure enablement time is the reset time
        // of permission controller
        enableLocationAccessCheck();

        resetPermissionController();

        eventually(() -> assertNull(getNotification(false)), UNEXPECTED_TIMEOUT_MILLIS);

        // Reset job scheduler stats (to allow more jobs to be run)
        runShellCommand(
                ""cmd jobscheduler reset-execution-quota -u "" + myUserHandle().getIdentifier() + "" ""
                        + PERMISSION_CONTROLLER_PKG);
    }

    /**
     * Enable location access check
     */
    public void enableLocationAccessCheck() throws Throwable {
        mPrivacyDeviceConfig.set(PROPERTY_LOCATION_ACCESS_CHECK_ENABLED, ""true"");

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    /**
     * Disable location access check
     */
    private void disableLocationAccessCheck() throws Throwable {
        mPrivacyDeviceConfig.set(PROPERTY_LOCATION_ACCESS_CHECK_ENABLED, ""false"");

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    /**
     * Make sure fine location can be accessed at all.
     */
    @Before
    public void assumeCanGetFineLocation() {
        if (sCanAccessFineLocation == null) {
            Criteria crit = new Criteria();
            crit.setAccuracy(ACCURACY_FINE);

            CountDownLatch locationCounter = new CountDownLatch(1);
            sContext.getSystemService(LocationManager.class).requestSingleUpdate(crit,
                    new LocationListener() {
                        @Override
                        public void onLocationChanged(Location location) {
                            locationCounter.countDown();
                        }

                        @Override
                        public void onStatusChanged(String provider, int status, Bundle extras) {
                        }

                        @Override
                        public void onProviderEnabled(String provider) {
                        }

                        @Override
                        public void onProviderDisabled(String provider) {
                        }
                    }, Looper.getMainLooper());


            try {
                sCanAccessFineLocation = locationCounter.await(LOCATION_ACCESS_TIMEOUT_MILLIS,
                        MILLISECONDS);
            } catch (InterruptedException ignored) {
            }
        }

        assumeTrue(sCanAccessFineLocation);
    }

    /**
     * Reset the permission controllers state.
     */
    private static void resetPermissionController() throws Throwable {
        clearPackageData(PERMISSION_CONTROLLER_PKG);
        int currentUserId = myUserHandle().getIdentifier();

        // Wait until jobs are cleared
        eventually(() -> {
            JobSchedulerServiceDumpProto dump = getJobSchedulerDump();

            for (RegisteredJob job : dump.registeredJobs) {
                if (job.dump.sourceUserId == currentUserId) {
                    assertNotEquals(job.dump.sourcePackageName, PERMISSION_CONTROLLER_PKG);
                }
            }
        }, UNEXPECTED_TIMEOUT_MILLIS);

        // Setup up permission controller again (simulate a reboot)
        Intent permissionControllerSetupIntent = null;
        for (ResolveInfo ri : sContext.getPackageManager().queryBroadcastReceivers(
                new Intent(ACTION_BOOT_COMPLETED), 0)) {
            String pkg = ri.activityInfo.packageName;

            if (pkg.equals(PERMISSION_CONTROLLER_PKG)) {
                permissionControllerSetupIntent = new Intent()
                        .setClassName(pkg, ri.activityInfo.name)
                        .setFlags(FLAG_RECEIVER_FOREGROUND)
                        .setPackage(PERMISSION_CONTROLLER_PKG);

                sContext.sendBroadcast(permissionControllerSetupIntent);
            }
        }

        // Wait until jobs are set up
        eventually(() -> {
            JobSchedulerServiceDumpProto dump = getJobSchedulerDump();

            for (RegisteredJob job : dump.registeredJobs) {
                if (job.dump.sourceUserId == currentUserId
                        && job.dump.sourcePackageName.equals(PERMISSION_CONTROLLER_PKG)
                        && job.dump.jobInfo.service.className.contains(""LocationAccessCheck"")) {
                    return;
                }
            }

            fail(""Permission controller jobs not found"");
        }, UNEXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * Unregister {@link NotificationListener}.
     */
    @AfterClass
    public static void disallowNotificationAccess() {
        runShellCommand(""cmd notification disallow_listener "" + (new ComponentName(sContext,
                NotificationListener.class)).flattenToString());
    }

    /**
     * Reset settings so that permission controller runs normally.
     */
    @AfterClass
    public static void resetDelays() throws Throwable {
        runWithShellPermissionIdentity(() -> {
            ContentResolver cr = sContext.getContentResolver();

            Settings.Secure.resetToDefaults(cr, LOCATION_ACCESS_CHECK_INTERVAL_MILLIS);
            Settings.Secure.resetToDefaults(cr, LOCATION_ACCESS_CHECK_DELAY_MILLIS);

            sJobSchedulerDeviceConfig.restoreOriginalValues();
        });
    }

    /**
     * Reset location access check
     */
    @After
    public void resetPrivacyConfig() throws Throwable {
        mPrivacyDeviceConfig.restoreOriginalValues();

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    @After
    public void locationUnbind() throws Throwable {
        unbindService();
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.LocationAccessCheckTest"	"notificationIsShownOnlyOnce"	"CtsPermissionTestCases"	"1: user"	"@AsbSecurityTest(cveBugId = 141028068)
    public void notificationIsShownOnlyOnce() throws Throwable {
        assumeNotPlayManaged();

        accessLocation();
        runLocationCheck();

        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);

        accessLocation();
        runLocationCheck();

        assertNull(getNotification(true));
    }

    @SystemUserOnly(reason = ""b/172259935"")"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.LocationAccessCheckTest"	"notificationIsShownAgainAfterClear"	"CtsPermissionTestCases"	"1: user"	"@AsbSecurityTest(cveBugId = 141028068)
    public void notificationIsShownAgainAfterClear() throws Throwable {
        assumeNotPlayManaged();
        accessLocation();
        runLocationCheck();

        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);

        clearPackageData(TEST_APP_PKG);

        // Wait until package is cleared and permission controller has cleared the state
        Thread.sleep(10000);

        // Clearing removed the permissions, hence grant them again
        grantPermissionToTestApp(ACCESS_FINE_LOCATION);
        grantPermissionToTestApp(ACCESS_BACKGROUND_LOCATION);

        accessLocation();
        runLocationCheck();

        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);
    }

    @SystemUserOnly(reason = ""b/172259935"")"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testDevHwRandomLockedDown"	"CtsPermissionTestCases"	"1: visible"	"public void testDevHwRandomLockedDown() throws Exception {
        File f = new File(""/dev/hw_random"");
        if (!f.exists()) {
            // HW RNG is not required to be exposed on all devices.
            return;
        }

        // SELinux policy should ensure that the file isn't visible to apps at
        // all.
        FileUtils.FileStatus status = new FileUtils.FileStatus();
        assertFalse(""stat permitted on "" + f + "" (SELinux issue?)"",
                FileUtils.getFileStatus(f.getPath(), status, false));

        // Double-check that we really can't read/write the file.
        assertFalse(f + "" can be opened for reading (SELinux issue?)"", canOpenForReading(f));
        assertFalse(f + "" can be opened for writing (SELinux issue?)"", canOpenForWriting(f));
    }

    private static boolean canOpenForReading(File f) {
        try (InputStream in = new FileInputStream(f)) {
            return true;
        } catch (IOException expected) {
            return false;
        }
    }

    private static boolean canOpenForWriting(File f) {
        try (OutputStream out = new FileOutputStream(f)) {
            return true;
        } catch (IOException expected) {
            return false;
        }
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testCreateDirectoryHasSanePermissions"	"CtsPermissionTestCases"	"1: direct"	"public void testCreateDirectoryHasSanePermissions() throws Exception {
        File myDir = new File(getContext().getFilesDir(), ""helloDirectory"");
        assertTrue(myDir.mkdir());
        try {
            FileUtils.FileStatus status = new FileUtils.FileStatus();
            FileUtils.getFileStatus(myDir.getAbsolutePath(), status, false);
            int expectedPerms = FileUtils.S_IFDIR
                    | FileUtils.S_IWUSR
                    | FileUtils.S_IRUSR
                    | FileUtils.S_IXUSR;
            assertEquals(
                    ""Newly created directories should have 0700 permissions"",
                    Integer.toOctalString(expectedPerms),
                    Integer.toOctalString(status.mode));

        } finally {
            assertTrue(myDir.delete());
        }
    }

    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testOtherApplicationDirectoriesAreNotWritable"	"CtsPermissionTestCases"	"1: direct"	"public void testOtherApplicationDirectoriesAreNotWritable() throws Exception {
        Set<File> writableDirs = new HashSet<File>();
        List<ApplicationInfo> apps = getContext()
                .getPackageManager()
                .getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES);
        String myAppDirectory = getContext().getApplicationInfo().dataDir;
        for (ApplicationInfo app : apps) {
            if (app.dataDir != null && !myAppDirectory.equals(app.dataDir)) {
                writableDirs.addAll(getWritableDirectoriesAndSubdirectoriesOf(new File(app.dataDir)));
            }
        }

        assertTrue(""Found writable directories: "" + writableDirs.toString(),
                writableDirs.isEmpty());
    }

    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testApplicationParentDirectoryNotWritable"	"CtsPermissionTestCases"	"1: direct"	"public void testApplicationParentDirectoryNotWritable() throws Exception {
        String myDataDir = getContext().getApplicationInfo().dataDir;
        File parentDir = new File(myDataDir).getParentFile();
        assertFalse(parentDir.toString(), isDirectoryWritable(parentDir));
    }

    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testDataDirectoryNotWritable"	"CtsPermissionTestCases"	"1: direct"	"public void testDataDirectoryNotWritable() throws Exception {
        assertFalse(isDirectoryWritable(Environment.getDataDirectory()));
    }

    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testAndroidRootDirectoryNotWritable"	"CtsPermissionTestCases"	"1: direct"	"public void testAndroidRootDirectoryNotWritable() throws Exception {
        assertFalse(isDirectoryWritable(Environment.getRootDirectory()));
    }

    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testDownloadCacheDirectoryNotWritable"	"CtsPermissionTestCases"	"1: direct"	"public void testDownloadCacheDirectoryNotWritable() throws Exception {
        assertFalse(isDirectoryWritable(Environment.getDownloadCacheDirectory()));
    }

    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testRootDirectoryNotWritable"	"CtsPermissionTestCases"	"1: direct"	"public void testRootDirectoryNotWritable() throws Exception {
        assertFalse(isDirectoryWritable(new File(""/"")));
    }

    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testDevDirectoryNotWritable"	"CtsPermissionTestCases"	"1: direct"	"public void testDevDirectoryNotWritable() throws Exception {
        assertFalse(isDirectoryWritable(new File(""/dev"")));
    }

    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testProcDirectoryNotWritable"	"CtsPermissionTestCases"	"1: direct"	"public void testProcDirectoryNotWritable() throws Exception {
        assertFalse(isDirectoryWritable(new File(""/proc"")));
    }

    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testIdletimerDirectoryExistsAndSane"	"CtsPermissionTestCases"	"1: direct"	"public void testIdletimerDirectoryExistsAndSane() throws Exception {
        File dir = new File(""/sys/class/xt_idletimer"");
        assertTrue(dir.isDirectory());
        assertFalse(dir.canWrite());
        assertTrue(dir.canExecute());

        assertFileOwnedBy(dir, ""root"");
        assertFileOwnedByGroup(dir, ""root"");
    }


    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testMntSecureSane"	"CtsPermissionTestCases"	"1: direct"	"public void testMntSecureSane() throws Exception {
        final File f = new File(""/mnt/secure"");
        assertFalse(f.canRead());
        assertFalse(f.canWrite());
        assertFalse(f.canExecute());
    }

    private static boolean isDirectoryWritable(File directory) {
        File toCreate = new File(directory, ""hello"");
        try {
            toCreate.createNewFile();
            return true;
        } catch (IOException e) {
            // It's expected we'll get a ""Permission denied"" exception.
        } finally {
            toCreate.delete();
        }
        return false;
    }

    /**
     * Verify that any publicly readable directories reachable from
     * the root directory are not writable.  An application should only be
     * able to write to it's own home directory. World writable directories
     * are a security hole because they enable a number of different attacks.
     * <ul>
     *   <li><a href=""http://en.wikipedia.org/wiki/Symlink_race"">Symlink Races</a></li>
     *   <li>Data destruction by deleting or renaming files you don't own</li>
     *   <li>Data substitution by replacing trusted files with untrusted files</li>
     * </ul>
     *
     * Note: Because not all directories are readable, this is a best-effort
     * test only.  Writable directories within unreadable subdirectories
     * will NOT be detected by this code.
     */
    @LargeTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testAllOtherDirectoriesNotWritable"	"CtsPermissionTestCases"	"2: direct user"	"public void testAllOtherDirectoriesNotWritable() throws Exception {
        File start = new File(""/"");
        Set<File> writableDirs = getWritableDirectoriesAndSubdirectoriesOf(start);

        assertTrue(""Found writable directories: "" + writableDirs.toString(),
                writableDirs.isEmpty());
    }

    private static final Set<String> OTHER_RANDOM_DIRECTORIES = new HashSet<String>(
            Arrays.asList(
                    ""/app-cache"",
                    ""/app-cache/ciq/socket"",
                    ""/cache/fotapkg"",
                    ""/cache/fotapkg/tmp"",
                    ""/data/_SamsungBnR_"",
                    ""/data/_SamsungBnR_/BR"",
                    ""/data/2nd-init"",
                    ""/data/amit"",
                    ""/data/anr"",
                    ""/data/app"",
                    ""/data/app-private"",
                    ""/data/backup"",
                    ""/data/battd"",
                    ""/data/bootlogo"",
                    ""/data/btips"",
                    ""/data/btips/TI"",
                    ""/data/btips/TI/opp"",
                    ""/data/cache"",
                    ""/data/calibration"",
                    ""/data/clipboard"",
                    ""/data/clp"",
                    ""/data/dalvik-cache"",
                    ""/data/data"",
                    ""/data/data/.drm"",
                    ""/data/data/.drm/.wmdrm"",
                    ""/data/data/cw"",
                    ""/data/data/com.android.htcprofile"",
                    ""/data/data/com.android.providers.drm/rights"",
                    ""/data/data/com.htc.android.qxdm2sd"",
                    ""/data/data/com.htc.android.qxdm2sd/bin"",
                    ""/data/data/com.htc.android.qxdm2sd/data"",
                    ""/data/data/com.htc.android.qxdm2sd/tmp"",
                    ""/data/data/com.htc.android.netlogger/data"",
                    ""/data/data/com.htc.messagecs/att"",
                    ""/data/data/com.htc.messagecs/pdu"",
                    ""/data/data/com.htc.loggers/bin"",
                    ""/data/data/com.htc.loggers/data"",
                    ""/data/data/com.htc.loggers/htclog"",
                    ""/data/data/com.htc.loggers/tmp"",
                    ""/data/data/com.htc.loggers/htcghost"",
                    ""/data/data/com.lge.ers/android"",
                    ""/data/data/com.lge.ers/arm9"",
                    ""/data/data/com.lge.ers/kernel"",
                    ""/data/data/com.lge.wmc"",
                    ""/data/data/com.redbend.vdmc/lib"",
                    ""/data/data/recovery"",
                    ""/data/data/recovery/HTCFOTA"",
                    ""/data/data/recovery/OMADM"",
                    ""/data/data/shared"",
                    ""/data/diag_logs"",
                    ""/data/dontpanic"",
                    ""/data/drm"",
                    ""/data/drm/fwdlock"",
                    ""/data/drm/IDM"",
                    ""/data/drm/IDM/HTTP"",
                    ""/data/drm/rights"",
                    ""/data/dump"",
                    ""/data/efslog"",
                    ""/data/emt"",
                    ""/data/factory"",
                    ""/data/fics"",
                    ""/data/fics/dev"",
                    ""/data/fota"",
                    ""/data/gps"",
                    ""/data/gps/log"",
                    ""/data/gps/var"",
                    ""/data/gps/var/run"",
                    ""/data/gpscfg"",
                    ""/data/hwvefs"",
                    ""/data/htcfs"",
                    ""/data/img"",
                    ""/data/install"",
                    ""/data/internal-device"",
                    ""/data/internal-device/DCIM"",
                    ""/data/last_alog"",
                    ""/data/last_klog"",
                    ""/data/local"",
                    ""/data/local/logs"",
                    ""/data/local/logs/kernel"",
                    ""/data/local/logs/logcat"",
                    ""/data/local/logs/resetlog"",
                    ""/data/local/logs/smem"",
                    ""/data/local/mono"",
                    ""/data/local/mono/pulse"",
                    ""/data/local/purple"",
                    ""/data/local/purple/sound"",
                    ""/data/local/rights"",
                    ""/data/local/rwsystag"",
                    ""/data/local/skel"",
                    ""/data/local/skel/default"",
                    ""/data/local/skel/defualt"", // Mispelled ""defualt"" is intentional
                    ""/data/local/tmp"",
                    ""/data/local/tmp/com.nuance.android.vsuite.vsuiteapp"",
                    ""/data/log"",
                    ""/data/logger"",
                    ""/data/logs"",
                    ""/data/logs/core"",
                    ""/data/lost+found"",
                    ""/data/mdl"",
                    ""/data/misc"",
                    ""/data/misc/bluetooth"",
                    ""/data/misc/bluetooth/logs"",
                    ""/data/misc/dhcp"",
                    ""/data/misc/lockscreen"",
                    ""/data/misc/sensor"",
                    ""/data/misc/webwidgets"",
                    ""/data/misc/webwidgets/chess"",
                    ""/data/misc/widgets"",
                    ""/data/misc/wifi"",
                    ""/data/misc/wifi/sockets"",
                    ""/data/misc/wimax"",
                    ""/data/misc/wimax/sockets"",
                    ""/data/misc/wminput"",
                    ""/data/misc/wpa_supplicant"",
                    ""/data/nv"",
                    ""/data/nvcam"",
                    ""/data/panic"",
                    ""/data/panicreports"",
                    ""/data/preinstall_md5"",
                    ""/data/property"",
                    ""/data/radio"",
                    ""/data/secure"",
                    ""/data/security"",
                    ""/data/sensors"",
                    ""/data/shared"",
                    ""/data/simcom"",
                    ""/data/simcom/btadd"",
                    ""/data/simcom/simlog"",
                    ""/data/system"",
                    ""/data/tmp"",
                    ""/data/tombstones"",
                    ""/data/tombstones/ramdump"",
                    ""/data/tpapi"",
                    ""/data/tpapi/etc"",
                    ""/data/tpapi/etc/tpa"",
                    ""/data/tpapi/etc/tpa/persistent"",
                    ""/data/tpapi/user.bin"",
                    ""/data/vpnch"",
                    ""/data/wapi"",
                    ""/data/wifi"",
                    ""/data/wimax"",
                    ""/data/wimax/log"",
                    ""/data/wiper"",
                    ""/data/wpstiles"",
                    ""/data/xt9"",
                    ""/dbdata/databases"",
                    ""/efs/.android"",
                    ""/mnt/sdcard"",
                    ""/mnt/usbdrive"",
                    ""/mnt_ext"",
                    ""/mnt_ext/badablk2"",
                    ""/mnt_ext/badablk3"",
                    ""/mnt_ext/cache"",
                    ""/mnt_ext/data"",
                    ""/system/etc/security/drm"",
                    ""/synthesis/hades"",
                    ""/synthesis/chimaira"",
                    ""/synthesis/shdisp"",
                    ""/synthesis/hdmi"",
                    ""/tmp""
            )
    );

    /**
     * Verify that directories not discoverable by
     * testAllOtherDirectoriesNotWritable are not writable.  An application
     * should only be able to write to it's own home directory. World
     * writable directories are a security hole because they enable a
     * number of different attacks.
     * <ul>
     *   <li><a href=""http://en.wikipedia.org/wiki/Symlink_race"">Symlink Races</a></li>
     *   <li>Data destruction by deleting or renaming files you don't own</li>
     *   <li>Data substitution by replacing trusted files with untrusted files</li>
     * </ul>
     *
     * Because /data and /data/data are not readable, we blindly try to
     * poke around in there looking for bad directories.  There has to be
     * a better way...
     */
    @LargeTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testOtherRandomDirectoriesNotWritable"	"CtsPermissionTestCases"	"1: direct"	"public void testOtherRandomDirectoriesNotWritable() throws Exception {
        Set<File> writableDirs = new HashSet<File>();
        for (String dir : OTHER_RANDOM_DIRECTORIES) {
            File start = new File(dir);
            writableDirs.addAll(getWritableDirectoriesAndSubdirectoriesOf(start));
        }

        assertTrue(""Found writable directories: "" + writableDirs.toString(),
                writableDirs.isEmpty());
    }

    @LargeTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testReadingSysFilesDoesntFail"	"CtsPermissionTestCases"	"2: direct user"	"public void testReadingSysFilesDoesntFail() throws Exception {
        ExecutorService executor = Executors.newCachedThreadPool();
        tryToReadFromAllIn(new File(""/sys""), executor);
        executor.shutdownNow();
    }

    private static void tryToReadFromAllIn(File dir, ExecutorService executor) throws IOException {
        assertTrue(dir.isDirectory());

        if (isSymbolicLink(dir)) {
            // don't examine symbolic links.
            return;
        }

        File[] files = dir.listFiles();

        if (files != null) {
            for (File f : files) {
                if (f.isDirectory()) {
                    tryToReadFromAllIn(f, executor);
                } else {
                    tryFileOpenRead(f, executor);
                }
            }
        }
    }

    private static void tryFileOpenRead(final File f, ExecutorService executor) throws IOException {
        // Callable requires stack variables to be final.
        Callable<Boolean> readFile = new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                return tryFileRead(f);
            }
        };

        Boolean completed = false;
        String fileName = null;
        Future<Boolean> future = null;
        try {
            fileName = f.getCanonicalPath();

            future = executor.submit(readFile);

            // Block, waiting no more than set seconds.
            completed = future.get(3, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            System.out.println(""TIMEOUT: "" + fileName);
        } catch (InterruptedException e) {
            System.out.println(""INTERRUPTED: "" + fileName);
        } catch (ExecutionException e) {
            System.out.println(""TASK WAS ABORTED BY EXCEPTION: "" + fileName);
        } catch (IOException e) {
            // File.getCanonicalPath() will throw this.
        } finally {
            if (future != null) {
                future.cancel(true);
            }
        }
    }

    private static Boolean tryFileRead(File f) {
        byte[] b = new byte[1024];
        try {
            System.out.println(""looking at "" + f.getCanonicalPath());

            FileInputStream fis = new FileInputStream(f);
            while((fis.available() != 0) && (fis.read(b) != -1)) {
                // throw away data
            }

            fis.close();
        } catch (IOException e) {
            // ignore
        }
        return true;
    }

    private static final Set<File> SYS_EXCEPTIONS = new HashSet<File>(
            Arrays.asList(
                new File(""/sys/kernel/debug/tracing/trace_marker""),
                new File(""/sys/fs/selinux/member""),
                new File(""/sys/fs/selinux/user""),
                new File(""/sys/fs/selinux/relabel""),
                new File(""/sys/fs/selinux/create""),
                new File(""/sys/fs/selinux/access""),
                new File(""/sys/fs/selinux/context""),
                new File(""/sys/fs/selinux/validatetrans"")
            ));

    @LargeTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testAllFilesInSysAreNotWritable"	"CtsPermissionTestCases"	"2: direct tv"	"public void testAllFilesInSysAreNotWritable() throws Exception {
        Set<File> writable = getAllWritableFilesInDirAndSubDir(new File(""/sys""));
        writable.removeAll(SYS_EXCEPTIONS);
        assertTrue(""Found writable: "" + writable.toString(),
                writable.isEmpty());
    }

    private static Set<File>
    getAllWritableFilesInDirAndSubDir(File dir) throws Exception {
        assertTrue(dir.isDirectory());
        Set<File> retval = new HashSet<File>();

        if (isSymbolicLink(dir)) {
            // don't examine symbolic links.
            return retval;
        }

        File[] subDirectories = dir.listFiles(new FileFilter() {
            @Override public boolean accept(File pathname) {
                return pathname.isDirectory();
            }
        });


        /* recurse into subdirectories */
        if (subDirectories != null) {
            for (File f : subDirectories) {
                retval.addAll(getAllWritableFilesInDirAndSubDir(f));
            }
        }

        File[] filesInThisDirectory = dir.listFiles(new FileFilter() {
            @Override public boolean accept(File pathname) {
                return pathname.isFile();
            }
        });
        if (filesInThisDirectory == null) {
            return retval;
        }

        for (File f: filesInThisDirectory) {
            if (f.canWrite()) {
                retval.add(f.getCanonicalFile());
            }
        }
        return retval;
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testRunAsHasCorrectCapabilities"	"CtsPermissionTestCases"	"3: direct tv user"	"public void testRunAsHasCorrectCapabilities() throws Exception {
        // ensure file is user and group read/executable
        String filename = ""/system/bin/run-as"";
        FileUtils.FileStatus status = new FileUtils.FileStatus();
        assertTrue(FileUtils.getFileStatus(filename, status, false));
        assertTrue(status.hasModeFlag(FileUtils.S_IRUSR | FileUtils.S_IXUSR));
        assertTrue(status.hasModeFlag(FileUtils.S_IRGRP | FileUtils.S_IXGRP));

        // ensure file owner/group is set correctly
        File f = new File(filename);
        assertFileOwnedBy(f, ""root"");
        assertFileOwnedByGroup(f, ""shell"");

        // ensure file has setuid/setgid enabled
        assertTrue(FileUtils.hasSetUidCapability(filename));
        assertTrue(FileUtils.hasSetGidCapability(filename));

        // ensure file has *only* setuid/setgid attributes enabled
        assertTrue(new FileUtils.CapabilitySet()
                .add(OsConstants.CAP_SETUID)
                .add(OsConstants.CAP_SETGID)
                .fileHasOnly(""/system/bin/run-as""));
    }

    private static Set<File>
    getAllInsecureDevicesInDirAndSubdir(File dir, int type) throws Exception {
        assertTrue(dir.isDirectory());
        Set<File> retval = new HashSet<File>();

        if (isSymbolicLink(dir)) {
            // don't examine symbolic links.
            return retval;
        }

        File[] subDirectories = dir.listFiles(new FileFilter() {
            @Override public boolean accept(File pathname) {
                return pathname.isDirectory();
            }
        });


        /* recurse into subdirectories */
        if (subDirectories != null) {
            for (File f : subDirectories) {
                retval.addAll(getAllInsecureDevicesInDirAndSubdir(f, type));
            }
        }

        File[] filesInThisDirectory = dir.listFiles();
        if (filesInThisDirectory == null) {
            return retval;
        }

        for (File f: filesInThisDirectory) {
            FileUtils.FileStatus status = new FileUtils.FileStatus();
            FileUtils.getFileStatus(f.getAbsolutePath(), status, false);
            if (status.isOfType(type)) {
                if (f.canRead() || f.canWrite() || f.canExecute()) {
                    retval.add(f);
                }
                if (status.uid == 2000) {
                    // The shell user should not own any devices
                    retval.add(f);
                }

                // Don't allow devices owned by GIDs
                // accessible to non-privileged applications.
                if ((status.gid == 1007)           // AID_LOG
                          || (status.gid == 1015)  // AID_SDCARD_RW
                          || (status.gid == 1023)  // AID_MEDIA_RW
                          || (status.gid == 1028)  // AID_SDCARD_R
                          || (status.gid == 2000)) // AID_SHELL
                {
                    if (status.hasModeFlag(FileUtils.S_IRGRP)
                            || status.hasModeFlag(FileUtils.S_IWGRP)
                            || status.hasModeFlag(FileUtils.S_IXGRP))
                    {
                        retval.add(f);
                    }
                }
            }
        }
        return retval;
    }

    private Set<File> getWritableDirectoriesAndSubdirectoriesOf(File dir) throws Exception {
        Set<File> retval = new HashSet<File>();
        if (!dir.isDirectory()) {
            return retval;
        }

        if (isSymbolicLink(dir)) {
            // don't examine symbolic links.
            return retval;
        }

        String myHome = getContext().getApplicationInfo().dataDir;
        String thisDir = dir.getCanonicalPath();
        if (thisDir.startsWith(myHome)) {
            // Don't examine directories within our home directory.
            // We expect these directories to be writable.
            return retval;
        }

        if (isDirectoryWritable(dir)) {
            retval.add(dir);
        }

        File[] subFiles = dir.listFiles();
        if (subFiles == null) {
            return retval;
        }

        for (File f : subFiles) {
            retval.addAll(getWritableDirectoriesAndSubdirectoriesOf(f));
        }

        return retval;
    }

    private static boolean isSymbolicLink(File f) throws IOException {
        return !f.getAbsolutePath().equals(f.getCanonicalPath());
    }

}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testSystemMountedRO"	"CtsPermissionTestCases"	"1: tv"	"public void testSystemMountedRO() throws Exception {
        StructStatVfs vfs = Os.statvfs(""/system"");
        assertTrue(""/system is not mounted read-only"", (vfs.f_flag & OsConstants.ST_RDONLY) != 0);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testRootMountedRO"	"CtsPermissionTestCases"	"1: tv"	"public void testRootMountedRO() throws Exception {
        StructStatVfs vfs = Os.statvfs(""/"");
        assertTrue(""rootfs is not mounted read-only"", (vfs.f_flag & OsConstants.ST_RDONLY) != 0);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testVendorMountedRO"	"CtsPermissionTestCases"	"1: tv"	"public void testVendorMountedRO() throws Exception {
        StructStatVfs vfs = Os.statvfs(""/vendor"");
        assertTrue(""/vendor is not mounted read-only"", (vfs.f_flag & OsConstants.ST_RDONLY) != 0);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testOdmMountedRO"	"CtsPermissionTestCases"	"1: tv"	"public void testOdmMountedRO() throws Exception {
        StructStatVfs vfs = Os.statvfs(""/odm"");
        assertTrue(""/odm is not mounted read-only"", (vfs.f_flag & OsConstants.ST_RDONLY) != 0);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testOemMountedRO"	"CtsPermissionTestCases"	"1: tv"	"public void testOemMountedRO() throws Exception {
        StructStatVfs vfs = Os.statvfs(""/oem"");
        assertTrue(""/oem is not mounted read-only"", (vfs.f_flag & OsConstants.ST_RDONLY) != 0);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testDataMountedNoSuidNoDev"	"CtsPermissionTestCases"	"1: tv"	"public void testDataMountedNoSuidNoDev() throws Exception {
        StructStatVfs vfs = Os.statvfs(getContext().getFilesDir().getAbsolutePath());
        assertTrue(""/data is not mounted NOSUID"", (vfs.f_flag & OsConstants.ST_NOSUID) != 0);
        assertTrue(""/data is not mounted NODEV"", (vfs.f_flag & OsConstants.ST_NODEV) != 0);
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.FileSystemPermissionTest"	"testProcfsMmapRndBitsExistsAndSane"	"CtsPermissionTestCases"	"1: user"	"public void testProcfsMmapRndBitsExistsAndSane() throws Exception {
        String arch = System.getProperty(""os.arch"");
        boolean supported = false;
        boolean supported_64 = false;

        if (arch.equals(""aarch64"") || arch.equals(""x86_64""))
            supported_64 = true;
        else if (arch.startsWith(""arm"") || arch.endsWith(""86""))
            supported = true;

        /* 64-bit OS should support running 32-bit applications */
        if (supported_64) {
            File f = new File(""/proc/sys/vm/mmap_rnd_compat_bits"");
            assertTrue(f.exists());
            assertFalse(f.canRead());
            assertFalse(f.canWrite());
            assertFalse(f.canExecute());
        }

        if (supported_64 || supported) {
            File f = new File(""/proc/sys/vm/mmap_rnd_bits"");
            assertTrue(f.exists());
            assertFalse(f.canRead());
            assertFalse(f.canWrite());
            assertFalse(f.canExecute());
        }
    }

    /**
     * Assert that a file is owned by a specific owner. This is a noop if the
     * file does not exist.
     *
     * @param file The file to check.
     * @param expectedOwner The owner of the file.
     */
    private static void assertFileOwnedBy(File file, String expectedOwner) {
        FileUtils.FileStatus status = new FileUtils.FileStatus();
        String path = file.getAbsolutePath();
        if (file.exists() && FileUtils.getFileStatus(path, status, true)) {
            String actualOwner = FileUtils.getUserName(status.uid);
            if (!expectedOwner.equals(actualOwner)) {
                String msg = String.format(""Wrong owner. Expected '%s', but found '%s' for %s."",
                        expectedOwner, actualOwner, path);
                fail(msg);
            }
        }
    }

    /**
     * Assert that a file is owned by a specific group. This is a noop if the
     * file does not exist.
     *
     * @param file The file to check.
     * @param expectedGroup The owner group of the file.
     */
    private static void assertFileOwnedByGroup(File file, String expectedGroup) {
        FileUtils.FileStatus status = new FileUtils.FileStatus();
        String path = file.getAbsolutePath();
        if (file.exists() && FileUtils.getFileStatus(path, status, true)) {
            String actualGroup = FileUtils.getGroupName(status.gid);
            if (!expectedGroup.equals(actualGroup)) {
                String msg = String.format(""Wrong group. Expected '%s', but found '%s' for %s."",
                        expectedGroup, actualGroup, path);
                fail(msg);
            }
        }
    }

    @MediumTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.StorageEscalationTest.kt"	"grantStoragePermissions"	"CtsPermissionTestCases"	"2: direct user"	"/*
 *.
 */

package android.permission.cts

import android.Manifest.permission.ACCESS_MEDIA_LOCATION
import android.Manifest.permission.READ_EXTERNAL_STORAGE
import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
import android.app.Instrumentation
import android.app.UiAutomation
import android.content.Context
import android.content.pm.PackageManager
import android.os.Process
import android.os.UserHandle
import android.platform.test.annotations.AppModeFull
import androidx.test.platform.app.InstrumentationRegistry
import com.android.compatibility.common.util.SystemUtil
import org.junit.After
import org.junit.Assert
import org.junit.Assert.assertTrue
import org.junit.Assume.assumeNoException
import org.junit.Before
import org.junit.Test

@AppModeFull
class StorageEscalationTest {
    companion object {
        private const val APK_DIRECTORY = ""/data/local/tmp/cts/permissions""
        const val APP_APK_PATH_28 = ""$APK_DIRECTORY/CtsStorageEscalationApp28.apk""
        const val APP_APK_PATH_29_SCOPED = ""$APK_DIRECTORY/CtsStorageEscalationApp29Scoped.apk""
        const val APP_APK_PATH_29_FULL = ""$APK_DIRECTORY/CtsStorageEscalationApp29Full.apk""
        const val APP_PACKAGE_NAME = ""android.permission3.cts.storageescalation""
        const val DELAY_TIME_MS: Long = 200
        val permissions = listOf<String>(READ_EXTERNAL_STORAGE, WRITE_EXTERNAL_STORAGE,
            ACCESS_MEDIA_LOCATION)
    }

    private val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
    private val context: Context = instrumentation.context
    private val uiAutomation: UiAutomation = instrumentation.uiAutomation
    private var secondaryUserId: Int? = null

    @Before
    @After
    fun uninstallApp() {
        SystemUtil.runShellCommand(""pm uninstall $APP_PACKAGE_NAME --user ALL"")
    }

    private fun installPackage(apk: String) {
        var userString = """"
        secondaryUserId?.let { userId ->
            userString = "" --user $userId""
        }
        val result = SystemUtil.runShellCommand(""pm install -r$userString $apk"")
        assertTrue(""Expected output to contain \""Success\"", but was \""$result\"""",
                result.contains(""Success""))
    }

    private fun createSecondaryUser() {
        val createUserOutput: String = SystemUtil.runShellCommand(""pm create-user secondary"")
        var formatException: Exception? = null
        val userId = try {
            createUserOutput.split("" id "".toRegex())[1].trim { it <= ' ' }.toInt()
        } catch (e: Exception) {
            formatException = e
            -1
        }
        assumeNoException(""Failed to parse userId from $createUserOutput"", formatException)
        SystemUtil.runShellCommand(""am start-user -w $userId"")
        secondaryUserId = userId
    }

    @After
    fun removeSecondaryUser() {
        secondaryUserId?.let { userId ->
            SystemUtil.runShellCommand(""pm remove-user $userId"")
            secondaryUserId = null
        }
    }

    private fun grantStoragePermissions() {
        for (permName in permissions) {
            var user = Process.myUserHandle()
            secondaryUserId?.let {
                user = UserHandle.of(it)
            }
            uiAutomation.grantRuntimePermissionAsUser(APP_PACKAGE_NAME, permName, user)
        }
    }

    private fun assertStoragePermissionState(granted: Boolean) {
        for (permName in permissions) {
            var userContext = context
            secondaryUserId?.let { userId ->
                SystemUtil.runWithShellPermissionIdentity {
                    userContext = context.createPackageContextAsUser(
                            APP_PACKAGE_NAME, 0, UserHandle.of(userId))
                }
            }
            Assert.assertEquals(granted, userContext.packageManager.checkPermission(permName,
                APP_PACKAGE_NAME) == PackageManager.PERMISSION_GRANTED)
        }
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/StorageEscalationTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.StorageEscalationTest.kt"	"testCannotEscalateWithSdkDowngradeSecondary"	"CtsPermissionTestCases"	"1: user"	"fun testCannotEscalateWithSdkDowngradeSecondary() {
        createSecondaryUser()
        runStorageEscalationTest(APP_APK_PATH_29_SCOPED, APP_APK_PATH_28)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/StorageEscalationTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.StorageEscalationTest.kt"	"testCannotEscalateWithNewManifestLegacyRequestSecondary"	"CtsPermissionTestCases"	"1: user"	"fun testCannotEscalateWithNewManifestLegacyRequestSecondary() {
        createSecondaryUser()
        runStorageEscalationTest(APP_APK_PATH_29_SCOPED, APP_APK_PATH_29_FULL)
    }

    private fun runStorageEscalationTest(startPackageApk: String, finishPackageApk: String) {
        installPackage(startPackageApk)
        grantStoragePermissions()
        assertStoragePermissionState(granted = true)
        installPackage(finishPackageApk)
        // permission revoke is async, so wait a short period
        Thread.sleep(DELAY_TIME_MS)
        assertStoragePermissionState(granted = false)
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/StorageEscalationTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.CameraPermissionTest"	"testCamera"	"CtsPermissionTestCases"	"1: camera"	"public void testCamera() {
        try {
            (Camera.open()).takePicture(new ShutterCallback(),
                                        new RawPictureCallback(),
                                        new JpegPictureCallback());
            fail(""Was able to take a picture with the camera with no permission"");
        }
        catch (SecurityException e) {
            // expected
        } catch (RuntimeException e) {
            // expected
            // The JNI layer isn't translating the EPERM error status into
            // a SecurityException.
        }
    }

}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/CameraPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.AppIdleStatePermissionTest"	"testChangeAppIdleStatePermission"	"CtsPermissionTestCases"	"1: user"	"public void testChangeAppIdleStatePermission() throws Exception {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[]{
                android.Manifest.permission.CHANGE_APP_IDLE_STATE
        }, PackageManager.MATCH_SYSTEM_ONLY);

        int count = 0;
        String pkgNames = """";
        for (PackageInfo pkg : holding) {
            int uid = pm.getApplicationInfo(pkg.packageName, 0).uid;
            if (UserHandle.isApp(uid)) {
                pkgNames += pkg.packageName + ""\n"";
                count++;
            }
        }
        if (count > 1) {
            fail(""Only one app may hold the CHANGE_APP_IDLE_STATE permission; found packages: \n""
                    + pkgNames);
        }
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/AppIdleStatePermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.ContactsProviderTest"	"testInsertContacts"	"CtsPermissionTestCases"	"1: tv"	"public void testInsertContacts() {
        try {
            getContext().getContentResolver().insert(ContactsContract.Contacts.CONTENT_URI,
                    new ContentValues());
            fail(""insert(ContactsContract.Contacts.CONTENT_URI) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that query(ContactsContract.Profile.CONTENT_URI) requires
     * Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#READ_CONTACTS}.
     */
    @SmallTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.ContactsProviderTest"	"testInsertProfile"	"CtsPermissionTestCases"	"1: tv"	"public void testInsertProfile() {
        try {
            getContext().getContentResolver().insert(ContactsContract.Profile.CONTENT_URI,
                    new ContentValues(0));
            fail(""insert(ContactsContract.Profile.CONTENT_URI) did not throw SecurityException ""
                    + ""as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that update(ContactsContract.Profile.CONTENT_URI) requires
     * Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#WRITE_CONTACTS}.
     */
    @SmallTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.ContactsProviderTest"	"testUpdateProfile"	"CtsPermissionTestCases"	"2: tv user"	"public void testUpdateProfile() {
        try {
            getContext().getContentResolver().update(ContactsContract.Profile.CONTENT_URI,
                    new ContentValues(0), null, null);
            fail(""update(ContactsContract.Profile.CONTENT_URI) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
    * Verifies that query(ContactsContract.CommonDataKinds.Phone.ENTERPRISE_CONTENT_URI) requires
    * Permission.
    * <p>
    * Requires Permission: {@link android.Manifest.permission#INTERACT_ACROSS_USERS}.
    */
    @SmallTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.ContactsProviderTest"	"testQueryPhoneEnterprise"	"CtsPermissionTestCases"	"1: user"	"public void testQueryPhoneEnterprise() {
        try {
            getContext().getContentResolver().query(
                    ContactsContract.CommonDataKinds.Phone.ENTERPRISE_CONTENT_URI,
                    null, null, null, null);
            fail(""query(ContactsContract.CommonDataKinds.Phone.ENTERPRISE_CONTENT_URI) did not""
                    + "" throw SecurityException as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
    * Verifies that query(ContactsContract.RawContactsEntity.CORP_CONTENT_URI) requires
    * Permission.
    * <p>
    * Requires Permission: {@link android.Manifest.permission#INTERACT_ACROSS_USERS}.
    */
    @SmallTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.ProviderPermissionTest"	"testWriteCallLogInstant"	"CtsPermissionTestCases"	"1: tv"	"public void testWriteCallLogInstant() {
        try {
            getContext().getContentResolver().insert(CallLog.CONTENT_URI, new ContentValues());
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException expected) {
        }
    }

    /**
     * Verify that reading already received SMS messages requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#READ_SMS}
     *
     * <p>Note: The WRITE_SMS permission has been removed.
     */
    @AppModeFull"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.ProviderPermissionTest"	"testWriteSettings"	"CtsPermissionTestCases"	"2: tv user"	"public void testWriteSettings() {
        final String permission = android.Manifest.permission.WRITE_SETTINGS;
        ContentValues value = new ContentValues();
        value.put(Settings.System.NAME, ""name"");
        value.put(Settings.System.VALUE, ""value_insert"");

        try {
            getContext().getContentResolver().insert(Settings.System.CONTENT_URI, value);
            fail(""expected SecurityException requiring "" + permission);
        } catch (SecurityException expected) {
            assertNotNull(""security exception's error message."", expected.getMessage());
            assertTrue(""error message should contain \"""" + permission + ""\"". Got: \""""
                    + expected.getMessage() + ""\""."",
                    expected.getMessage().contains(permission));
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#MANAGE_DOCUMENTS}
     * permission is only held by up to one package: whoever handles the
     * {@link android.content.Intent#ACTION_OPEN_DOCUMENT} intent, if any.
     * <p>
     * No other apps should <em>ever</em> attempt to acquire this permission,
     * since it would give those apps extremely broad access to all storage
     * providers on the device without user involvement in the arbitration
     * process. Apps should instead always rely on Uri permission grants for
     * access, using
     * {@link android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION} and related
     * APIs.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.ProviderPermissionTest"	"testManageDocuments"	"CtsPermissionTestCases"	"1: user"	"public void testManageDocuments() {
        final PackageManager pm = getContext().getPackageManager();

        final Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(""*/*"");
        final ResolveInfo ri = pm.resolveActivity(intent, 0);

        if (ri != null) {
            final String validPkg = ri.activityInfo.packageName;

            final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                    android.Manifest.permission.MANAGE_DOCUMENTS
                    }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
            for (PackageInfo pi : holding) {
                if (!Objects.equals(pi.packageName, validPkg)) {
                    fail(""Exactly one package (must be "" + validPkg
                            + "") can request the MANAGE_DOCUMENTS permission; found package ""
                            + pi.packageName + "" which must be revoked for security reasons"");
                }
            }
        }
    }

    /**
     * The {@link android.Manifest.permission#WRITE_MEDIA_STORAGE} permission is
     * a very powerful permission that grants raw storage access to all devices,
     * and as such it's only appropriate to be granted to the media stack.
     * <p>
     * CDD now requires that all apps requesting this permission also hold the
     * ""Storage"" runtime permission, to give users visibility into the
     * capabilities of each app, and control over those capabilities.
     * <p>
     * If the end user revokes the ""Storage"" permission from an app, but that
     * app still has raw access to storage via {@code WRITE_MEDIA_STORAGE}, that
     * would be a CDD violation and a privacy incident.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.ProviderPermissionTest"	"testWriteMediaStorage"	"CtsPermissionTestCases"	"1: user"	"public void testWriteMediaStorage() throws Exception {
        final UiAutomation ui = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        final PackageManager pm = getContext().getPackageManager();
        final UserHandle userHandle = getContext().getUser();
        final List<PackageInfo> pkgs = pm.getInstalledPackages(
                PackageManager.MATCH_UNINSTALLED_PACKAGES | PackageManager.GET_PERMISSIONS);
        for (PackageInfo pkg : pkgs) {
            final int appUid = userHandle.getAppId(pkg.applicationInfo.uid);
            final boolean isSystem = appUid == android.os.Process.SYSTEM_UID;
            final boolean hasFrontDoor = pm.getLaunchIntentForPackage(pkg.packageName) != null;
            final boolean grantedMedia = pm.checkPermission(WRITE_MEDIA_STORAGE,
                    pkg.packageName) == PackageManager.PERMISSION_GRANTED;

            if (!isSystem && hasFrontDoor && grantedMedia) {
                final boolean requestsStorage = contains(pkg.requestedPermissions,
                        WRITE_EXTERNAL_STORAGE);
                if (!requestsStorage) {
                    fail(""Found "" + pkg.packageName + "" holding WRITE_MEDIA_STORAGE permission ""
                            + ""without also requesting WRITE_EXTERNAL_STORAGE; these permissions ""
                            + ""must be requested together"");
                }

                final boolean grantedStorage = pm.checkPermission(WRITE_EXTERNAL_STORAGE,
                        pkg.packageName) == PackageManager.PERMISSION_GRANTED;
                if (grantedStorage) {
                    final int flags;
                    ui.adoptShellPermissionIdentity(""android.permission.GET_RUNTIME_PERMISSIONS"");
                    try {
                        flags = pm.getPermissionFlags(WRITE_EXTERNAL_STORAGE, pkg.packageName,
                                android.os.Process.myUserHandle());
                    } finally {
                        ui.dropShellPermissionIdentity();
                    }

                    final boolean isFixed = (flags & (PackageManager.FLAG_PERMISSION_USER_FIXED
                            | PackageManager.FLAG_PERMISSION_POLICY_FIXED
                            | PackageManager.FLAG_PERMISSION_SYSTEM_FIXED)) != 0;
                    if (isFixed) {
                        fail(""Found "" + pkg.packageName + "" holding WRITE_EXTERNAL_STORAGE in a ""
                                + ""fixed state; this permission must be revokable by the user"");
                    }
                }
            }
        }
    }

    private static boolean contains(String[] haystack, String needle) {
        if (haystack != null) {
            for (String test : haystack) {
                if (Objects.equals(test, needle)) {
                    return true;
                }
            }
        }
        return false;
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokeFakePackageWithReason"	"CtsPermissionTestCases"	"1: user"	"@AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokeFakePackageWithReason() {
        val fakePackageName = ""fake.package.name.which.should.not.exist""
        assertPackageNotInstalled(fakePackageName)
        testRevoke(
                packageName = fakePackageName,
                permission = READ_CALENDAR,
                reason = ""test reason"")
    }

    @After
    fun uninstallApp() {
        runShellCommand(""pm uninstall $APP_PKG_NAME"")
    }

    private fun testRevoke(
        packageName: String,
        permission: String,
        reason: String? = null,
        isGranted: Boolean = false,
        throwableType: Class<*>? = null,
        throwableMessage: String = """"
    ) {
        val context = InstrumentationRegistry.getInstrumentation().targetContext
        val pm = context.packageManager

        if (isGranted) {
            assertEquals(PERMISSION_GRANTED, pm.checkPermission(READ_CALENDAR, APP_PKG_NAME))
        }

        runWithShellPermissionIdentity {
            if (throwableType == null) {
                if (reason == null) {
                    pm.revokeRuntimePermission(packageName, permission, Process.myUserHandle())
                } else {
                    pm.revokeRuntimePermission(packageName, permission, Process.myUserHandle(),
                            reason)
                }
            } else {
                try {
                    if (reason == null) {
                        pm.revokeRuntimePermission(packageName, permission, Process.myUserHandle())
                    } else {
                        pm.revokeRuntimePermission(packageName, permission, Process.myUserHandle(),
                                reason)
                    }
                } catch (t: Throwable) {
                    if (t::class.java.name == throwableType.name &&
                            t.message!!.contains(throwableMessage)) {
                        return@runWithShellPermissionIdentity
                    }
                    throw RuntimeException(""Unexpected throwable"", t)
                }
                throw RuntimeException(""revokeRuntimePermission expected to throw."")
            }
        }
    }

    private fun assertPackageNotInstalled(packageName: String) {
        val context = InstrumentationRegistry.getInstrumentation().targetContext
        val pm = context.packageManager
        try {
            pm.getPackageInfo(packageName, 0)
            throw RuntimeException(""$packageName exists on this device"")
        } catch (e: PackageManager.NameNotFoundException) {
            // Expected
        }
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokePermissionNotRequested"	"CtsPermissionTestCases"	"1: camera"	"@AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokePermissionNotRequested() {
        testRevoke(
                packageName = APP_PKG_NAME,
                permission = CAMERA,
                throwableType = SecurityException::class.java,
                throwableMessage = ""has not requested permission"")
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokePermissionNotRequestedWithReason"	"CtsPermissionTestCases"	"1: camera"	"@AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokePermissionNotRequestedWithReason() {
        testRevoke(
                packageName = APP_PKG_NAME,
                permission = CAMERA,
                reason = ""test reason"",
                throwableType = SecurityException::class.java,
                throwableMessage = ""has not requested permission"")
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.UndefinedGroupPermissionTest.kt"	"testCustomPermissionGrantedAlone"	"CtsPermissionTestCases"	"2: user camera"	"fun testCustomPermissionGrantedAlone() {
        Assert.assertEquals(mPm!!.checkPermission(CAMERA, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
        Assert.assertEquals(mPm!!.checkPermission(RECORD_AUDIO, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
        Assert.assertEquals(mPm!!.checkPermission(TEST, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
        eventually {
            startRequestActivity(arrayOf(TEST))
            mUiDevice!!.waitForIdle()
            findAllowButton().click()
        }
        eventually {
            Assert.assertEquals(mPm!!.checkPermission(CAMERA, APP_PKG_NAME),
                    PackageManager.PERMISSION_DENIED)
            Assert.assertEquals(mPm!!.checkPermission(RECORD_AUDIO, APP_PKG_NAME),
                    PackageManager.PERMISSION_DENIED)
            Assert.assertEquals(mPm!!.checkPermission(TEST, APP_PKG_NAME),
                    PackageManager.PERMISSION_GRANTED)
        }
    }

    @After
    fun uninstall() {
        SystemUtil.runShellCommand(""pm uninstall $APP_PKG_NAME"")
    }

    fun findAllowButton(): UiObject2 {
        return if (mContext?.packageManager
                        ?.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE) == true) {
            waitFindObject(By.text(mAllowButtonText), 100)
        } else {
            waitFindObject(By.res(
                    ""com.android.permissioncontroller:id/permission_allow_button""),
                    100)
        }
    }

    /**
     * If app has one permission granted, then it can't grant itself another permission for free.
     */
    fun testOtherGroupPermissionsNotGranted(grantedPerm: String, targetPermission: String) {
        // Grant the permission in the background
        SystemUtil.runWithShellPermissionIdentity {
            mPm!!.grantRuntimePermission(
                    APP_PKG_NAME, grantedPerm, Process.myUserHandle())
        }
        Assert.assertEquals(""$grantedPerm not granted."", mPm!!.checkPermission(grantedPerm,
                APP_PKG_NAME), PackageManager.PERMISSION_GRANTED)

        // If the dialog shows, success. If not then either the UI is broken or the permission was
        // granted in the background.
        eventually {
            startRequestActivity(arrayOf(targetPermission))
            mUiDevice!!.waitForIdle()
            try {
                if (mContext?.packageManager
                                ?.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE) == true) {
                    waitFindObject(By.text(mDenyButtonText), 100)
                } else {
                    waitFindObject(By.res(""com.android.permissioncontroller:id/grant_dialog""), 100)
                }
            } catch (e: UiObjectNotFoundException) {
                Assert.assertEquals(""grant dialog never showed."",
                        mPm!!.checkPermission(targetPermission,
                                APP_PKG_NAME), PackageManager.PERMISSION_GRANTED)
            }
        }
        Assert.assertEquals(mPm!!.checkPermission(targetPermission, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
    }

    private fun startRequestActivity(permissions: Array<String>) {
        mContext!!.startActivity(Intent()
                .setComponent(
                        ComponentName(APP_PKG_NAME, ""$APP_PKG_NAME.RequestPermissions""))
                .putExtra(EXTRA_PERMISSIONS, permissions)
                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK))
    }

    companion object {
        private const val TEST_APP_DEFINES_UNDEFINED_PERMISSION_GROUP_ELEMENT_APK =
                ""/data/local/tmp/cts/permissions/AppThatDefinesUndefinedPermissionGroupElement.apk""
        private const val APP_PKG_NAME = ""android.permission.cts.appthatrequestpermission""
        private const val EXTRA_PERMISSIONS =
                ""android.permission.cts.appthatrequestpermission.extra.PERMISSIONS""
        const val TEST = ""android.permission.cts.appthatrequestpermission.TEST""
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/UndefinedGroupPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.UndefinedGroupPermissionTest.kt"	"testOtherGroupPermissionsNotGranted_1"	"CtsPermissionTestCases"	"1: camera"	"fun testOtherGroupPermissionsNotGranted_1() {
        testOtherGroupPermissionsNotGranted(CAMERA, RECORD_AUDIO)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/UndefinedGroupPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.UndefinedGroupPermissionTest.kt"	"testOtherGroupPermissionsNotGranted_3"	"CtsPermissionTestCases"	"1: camera"	"fun testOtherGroupPermissionsNotGranted_3() {
        testOtherGroupPermissionsNotGranted(CAMERA, TEST)
    }

    /**
     * When the custom permission is granted nothing else gets granted as a byproduct.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/UndefinedGroupPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.TvPermissionTest"	"testInsertChannels"	"CtsPermissionTestCases"	"1: tv"	"public void testInsertChannels() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyInsert(TvContract.Channels.CONTENT_URI, ""channels"");
    }

    @AppModeFull"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.TvPermissionTest"	"testUpdateChannels"	"CtsPermissionTestCases"	"1: tv"	"public void testUpdateChannels() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyUpdate(TvContract.Channels.CONTENT_URI, ""channels"");
    }

    @AppModeFull"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.TvPermissionTest"	"testDeleteChannels"	"CtsPermissionTestCases"	"1: tv"	"public void testDeleteChannels() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyDelete(TvContract.Channels.CONTENT_URI, ""channels"");
    }

    @AppModeFull"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.TvPermissionTest"	"testInsertPrograms"	"CtsPermissionTestCases"	"1: tv"	"public void testInsertPrograms() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyInsert(TvContract.Programs.CONTENT_URI, ""programs"");
    }

    @AppModeFull"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.TvPermissionTest"	"testUpdatePrograms"	"CtsPermissionTestCases"	"1: tv"	"public void testUpdatePrograms() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyUpdate(TvContract.Programs.CONTENT_URI, ""programs"");
    }

    @AppModeFull"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.TvPermissionTest"	"testDeletePrograms"	"CtsPermissionTestCases"	"1: tv"	"public void testDeletePrograms() throws Exception {
        if (!mHasTvInputFramework) return;
        verifyDelete(TvContract.Programs.CONTENT_URI, ""programs"");
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/TvPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.NoSystemFunctionPermissionTest"	"testVibrator"	"CtsPermissionTestCases"	"1: tv"	"public void testVibrator() {
        Vibrator vibrator = (Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);

        try {
            vibrator.cancel();
            fail(""Vibrator.cancel() did not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }

        try {
            vibrator.vibrate(1);
            fail(""Vibrator.vibrate(long) did not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }

        long[] testPattern = {1, 1, 1, 1, 1};

        try {
            vibrator.vibrate(testPattern, 1);
            fail(""Vibrator.vibrate(long[], int) not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that sending sms requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#SMS}.
     */
    @SmallTest"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoSystemFunctionPermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.Camera2PermissionTest"	"getCameraIdList"	"CtsPermissionTestCases"	"1: camera"	"public void test/*
 *.
 */

package android.permission.cts;

import static com.android.ex.camera2.blocking.BlockingStateCallback.*;

import android.content.Context;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraCharacteristics.Key;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.os.Handler;
import android.os.HandlerThread;
import android.platform.test.annotations.Presubmit;
import android.test.AndroidTestCase;
import android.util.Log;

import com.android.ex.camera2.blocking.BlockingCameraManager;
import com.android.ex.camera2.blocking.BlockingStateCallback;

import java.util.ArrayList;
import java.util.List;

/**
 * Tests for Camera2 API related Permissions. Currently, this means
 * android.permission.CAMERA.
 */
public class Camera2PermissionTest extends AndroidTestCase {
    private static final String TAG = ""Camera2PermissionTest"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    private static final int CAMERA_CLOSE_TIMEOUT_MS = 2000;

    private CameraManager mCameraManager;
    private CameraDevice mCamera;
    private BlockingStateCallback mCameraListener;
    private String[] mCameraIds;
    protected Handler mHandler;
    protected HandlerThread mHandlerThread;

    @Override
    public void setContext(Context context) {
        super.setContext(context);
        mCameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
        assertNotNull(""Can't connect to camera manager!"", mCameraManager);
    }

    /**
     * Set up the camera2 test case required environments, including CameraManager,
     * HandlerThread, Camera IDs, and CameraStateCallback etc.
     */
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mCameraIds = mCameraManager.getCameraIdList();
        assertNotNull(""Camera ids shouldn't be null"", mCameraIds);
        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
        mCameraListener = new BlockingStateCallback();
    }

    @Override
    protected void tearDown() throws Exception {
        mHandlerThread.quitSafely();
        mHandler = null;

        super.tearDown();
    }

    /**
     * Attempt to open camera. Requires Permission:
     * {@link android.Manifest.permission#CAMERA}.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.Camera2PermissionTest"	"testCameraOpen"	"CtsPermissionTestCases"	"1: camera"	"public void testCameraOpen() throws Exception {
        for (String id : mCameraIds) {
            try {
                openCamera(id);
                fail(""Was able to open camera "" + id + "" with no permission"");
            }
            catch (SecurityException e) {
                // expected
            } finally {
                closeCamera();
            }
        }
    }

    /**
     * Check that no system cameras can be discovered without
     * {@link android.Manifest.permission#CAMERA} and android.permission.SYSTEM_CAMERA
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.Camera2PermissionTest"	"testSystemCameraDiscovery"	"CtsPermissionTestCases"	"1: camera"	"public void testSystemCameraDiscovery() throws Exception {
        for (String id : mCameraIds) {
            Log.i(TAG, ""testSystemCameraDiscovery for camera id "" +  id);
            CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(id);
            assertNotNull(""Camera characteristics shouldn't be null"", characteristics);
            int[] availableCapabilities =
                    characteristics.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);
            assertTrue(""Camera capabilities shouldn't be null"", availableCapabilities != null);
            List<Integer> capList = toList(availableCapabilities);
            assertFalse(""System camera device "" + id + "" should not be public"",
                    capList.contains(
                            CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_SYSTEM_CAMERA));
        }
    }

    /**
     * Check the absence of camera characteristics keys that require Permission:
     * {@link android.Manifest.permission#CAMERA}.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.Camera2PermissionTest"	"testCameraCharacteristicsNeedingPermission"	"CtsPermissionTestCases"	"1: camera"	"public void testCameraCharacteristicsNeedingPermission() throws Exception {
        for (String id : mCameraIds) {
            CameraCharacteristics capabilities = mCameraManager.getCameraCharacteristics(id);
            assertNotNull(""Camera characteristics shouldn't be null"", capabilities);
            List<Key<?>> keysNeedingPermission = capabilities.getKeysNeedingPermission();
            if (keysNeedingPermission == null) {
                continue;
            }
            List<Key<?>> keys = capabilities.getKeys();
            assertNotNull(""Camera characteristics key list shouldn't be null"", keys);
            for (Key<?> key : keysNeedingPermission) {
                assertEquals(""Key "" + key.getName() + "" needing permission is part of the"" +
                        "" available characteristics keys"", -1, keys.indexOf(key));
                assertNull(""Key "" + key.getName() + "" needing permission must not present"" +
                        "" in camera characteristics"", capabilities.get(key));
            }
        }
    }

    /**
     * Add and remove availability listeners should work without permission.
     */
    @Presubmit"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.Camera2PermissionTest"	"testAvailabilityCallback"	"CtsPermissionTestCases"	"1: camera"	"public void testAvailabilityCallback() throws Exception {
        DummyCameraListener availabilityListener = new DummyCameraListener();
        // Remove a not-registered listener is a no-op.
        mCameraManager.unregisterAvailabilityCallback(availabilityListener);
        mCameraManager.registerAvailabilityCallback(availabilityListener, mHandler);
        mCameraManager.unregisterAvailabilityCallback(availabilityListener);
        mCameraManager.registerAvailabilityCallback(availabilityListener, mHandler);
        mCameraManager.registerAvailabilityCallback(availabilityListener, mHandler);
        mCameraManager.unregisterAvailabilityCallback(availabilityListener);
        // Remove a previously-added listener second time is a no-op.
        mCameraManager.unregisterAvailabilityCallback(availabilityListener);
    }

    private class DummyCameraListener extends CameraManager.AvailabilityCallback {
        @Override
        public void onCameraAvailable(String cameraId) {
        }

        @Override
        public void onCameraUnavailable(String cameraId) {
        }
    }

    private void openCamera(String cameraId) throws Exception {
        mCamera = (new BlockingCameraManager(mCameraManager)).openCamera(
                cameraId, mCameraListener, mHandler);
    }

    private static List<Integer> toList(int[] array) {
        List<Integer> list = new ArrayList<Integer>();
        for (int i  : array) {
            list.add(i);
        }
        return list;
    }

    private void closeCamera() {
        if (mCamera != null) {
            mCamera.close();
            mCameraListener.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
            mCamera = null;
        }
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission.cts.PackageManagerRequiringPermissionsTest"	"testVerifyPendingInstall"	"CtsPermissionTestCases"	"1: tv"	"public void testVerifyPendingInstall() {
        try {
            mPackageManager.verifyPendingInstall(1, 1);
            fail(""PackageManager.verifyPendingInstall did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that PackageManager.extendVerificationTimeout requires permission.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#PACKAGE_VERIFICATION_AGENT}.
     */"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PackageManagerRequiringPermissionsTest.java"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionUpgradeTest.kt"	"testUpgradeKeepsPermissions"	"CtsPermission3TestCases"	"1: camera"	"fun testUpgradeKeepsPermissions() {
        Assume.assumeFalse(packageManager.arePermissionsIndividuallyControlled())

        installPackage(APP_APK_PATH_22)

        approvePermissionReview()

        assertAllPermissionsGrantedByDefault()

        installPackage(APP_APK_PATH_23, reinstall = true)

        assertAllPermissionsGrantedOnUpgrade()
    }

    private fun assertAllPermissionsGrantedByDefault() {
        arrayOf(
            android.Manifest.permission.SEND_SMS,
            android.Manifest.permission.RECEIVE_SMS,
            // The APK does not request READ_CONTACTS because of other tests
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_CALENDAR,
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.RECEIVE_WAP_PUSH,
            android.Manifest.permission.RECEIVE_MMS,
            ""android.permission.READ_CELL_BROADCASTS"",
            android.Manifest.permission.READ_EXTERNAL_STORAGE,
            android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
            android.Manifest.permission.ACCESS_FINE_LOCATION,
            android.Manifest.permission.ACCESS_COARSE_LOCATION,
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.READ_CALL_LOG,
            android.Manifest.permission.WRITE_CALL_LOG,
            android.Manifest.permission.ADD_VOICEMAIL,
            android.Manifest.permission.USE_SIP,
            android.Manifest.permission.PROCESS_OUTGOING_CALLS,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.BODY_SENSORS,
            // Split permissions
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION
        ).forEach {
            assertAppHasPermission(it, true)
        }
    }

    private fun assertAllPermissionsGrantedOnUpgrade() {
        assertAppHasAllOrNoPermissions(true)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUpgradeTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionUpgradeTest.kt"	"testRevokePropagatedOnUpgradeNewToNewModel"	"CtsPermission3TestCases"	"1: camera"	"fun testRevokePropagatedOnUpgradeNewToNewModel() {
        installPackage(APP_APK_PATH_23)

        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, false)
        assertAppHasPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE, false)

        // Request the permission and allow it
        // Make sure the permission is granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.READ_CALENDAR to true) {
            clickPermissionRequestAllowButton()
        }

        installPackage(APP_APK_PATH_23, reinstall = true)

        // Make sure the permission is still granted after the upgrade
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, true)
        // Also make sure one of the not granted permissions is still not granted
        assertAppHasPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE, false)
    }

    private fun assertAppHasAllOrNoPermissions(expectPermissions: Boolean) {
        arrayOf(
            android.Manifest.permission.SEND_SMS,
            android.Manifest.permission.RECEIVE_SMS,
            android.Manifest.permission.RECEIVE_WAP_PUSH,
            android.Manifest.permission.RECEIVE_MMS,
            android.Manifest.permission.READ_CALENDAR,
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.READ_CALL_LOG,
            android.Manifest.permission.WRITE_CALL_LOG,
            android.Manifest.permission.ADD_VOICEMAIL,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.USE_SIP,
            android.Manifest.permission.PROCESS_OUTGOING_CALLS,
            android.Manifest.permission.RECORD_AUDIO,
            android.Manifest.permission.ACCESS_FINE_LOCATION,
            android.Manifest.permission.ACCESS_COARSE_LOCATION,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.BODY_SENSORS,
            android.Manifest.permission.READ_CELL_BROADCASTS,
            // Split permissions
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION,
            // Storage permissions
            android.Manifest.permission.READ_EXTERNAL_STORAGE,
            android.Manifest.permission.WRITE_EXTERNAL_STORAGE
        ).forEach {
            assertAppHasPermission(it, expectPermissions)
        }
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUpgradeTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionPolicyTest25.kt"	"BasePermissionTest"	"CtsPermission3TestCases"	"1: direct"	"/*
 *.
 */

package android.permission3.cts

import android.app.Activity
import android.content.ComponentName
import android.content.Intent
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import java.util.concurrent.TimeUnit

/**
 * Tests for the platform permission policy around apps targeting API 25.
 */
class PermissionPolicyTest25 : BasePermissionTest() {
    companion object {
        const val APP_APK_PATH_25 = ""$APK_DIRECTORY/CtsPermissionPolicyApp25.apk""
        const val APP_PACKAGE_NAME = ""android.permission3.cts.permissionpolicy""
    }

    @Before
    fun installApp25() {
        uninstallPackage(APP_PACKAGE_NAME, requireSuccess = false)
        installPackage(APP_APK_PATH_25)
    }

    @After
    fun uninstallApp() {
        uninstallPackage(APP_PACKAGE_NAME, requireSuccess = false)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionPolicyTest25.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionReviewTest.kt"	"testReviewPermissionWhenServiceIsBound"	"CtsPermission3TestCases"	"1: direct"	"fun testReviewPermissionWhenServiceIsBound() {
        val results = LinkedBlockingQueue<Int>()
        // We are starting a activity instead of the service directly, because
        // the service comes from a different app than the CTS tests.
        // This app will be considered idle on devices that have idling enabled (automotive),
        // and the service wouldn't be allowed to be started without the activity.
        activityRule.launchActivity(null).startActivity(
            Intent().apply {
                component = ComponentName(
                    APP_PACKAGE_NAME, ""$APP_PACKAGE_NAME.StartCheckPermissionServiceActivity""
                )
                putExtra(
                    ""$APP_PACKAGE_NAME.RESULT"",
                    object : ResultReceiver(Handler(Looper.getMainLooper())) {
                        override fun onReceiveResult(resultCode: Int, resultData: Bundle?) {
                            results.offer(resultCode)
                        }
                    }
                )
                putExtra(
                    ""$APP_PACKAGE_NAME.PERMISSION"", android.Manifest.permission.READ_CALENDAR
                )
            }
        )

        // Service is not started before permission are reviewed
        assertNull(results.poll(UNEXPECTED_TIMEOUT_MILLIS.toLong(), TimeUnit.MILLISECONDS))

        clickPermissionReviewContinue()

        // Service should be started after permission review
        assertEquals(
            PackageManager.PERMISSION_GRANTED, results.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
        )
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionReviewTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionTest30WithBluetooth.kt"	"testRevokedCompatPersistsOnReinstall"	"CtsPermission3TestCases"	"1: user"	"fun testRevokedCompatPersistsOnReinstall() {
        assertBluetoothRevokedCompatState(revoked = false)
        revokeAppPermissions(BLUETOOTH_SCAN, isLegacyApp = true)
        assertBluetoothRevokedCompatState(revoked = true)
        reinstallApp()
        assertBluetoothRevokedCompatState(revoked = true)
        installApp()
        assertBluetoothRevokedCompatState(revoked = true)
    }

    private fun assertBluetoothRevokedCompatState(revoked: Boolean = true) {
        runWithShellPermissionIdentity {
            val flag = context.packageManager.getPermissionFlags(BLUETOOTH_SCAN,
                TEST_APP_PKG, Process.myUserHandle()) and FLAG_PERMISSION_REVOKED_COMPAT
            if (revoked) {
                assertNotEquals(0, flag)
            } else {
                assertEquals(0, flag)
            }
        }
    }
    private fun scanForBluetoothDevices(): BluetoothScanResult {
        val resolver = InstrumentationRegistry.getTargetContext().getContentResolver()
        val result = resolver.call(TEST_APP_AUTHORITY, """", null, null)
        return BluetoothScanResult.values()[result!!.getInt(Intent.EXTRA_INDEX)]
    }

    private fun supportsBluetooth(): Boolean =
        context.packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)

    private fun enableTestMode() = runShellCommandOrThrow(""dumpsys activity service"" +
        "" com.android.bluetooth/.btservice.AdapterService set-test-mode enabled"")

    private fun disableTestMode() = runShellCommandOrThrow(""dumpsys activity service"" +
        "" com.android.bluetooth/.btservice.AdapterService set-test-mode disabled"")
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest30WithBluetooth.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionHistoryTest.kt"	"testCameraTimelineWithMultipleApps"	"CtsPermission3TestCases"	"2: direct camera"	"fun testCameraTimelineWithMultipleApps() {
        openMicrophoneApp(INTENT_ACTION_1)
        waitFindObject(By.textContains(APP_LABEL_1))

        openMicrophoneApp(INTENT_ACTION_2)
        waitFindObject(By.textContains(APP_LABEL_2))

        openMicrophoneTimeline()
        waitFindObject(By.descContains(micLabel))
        waitFindObject(By.textContains(APP_LABEL_1))
        waitFindObject(By.textContains(APP_LABEL_2))
    }

    private fun openMicrophoneApp(intentAction: String) {
        context.startActivity(Intent(intentAction).apply {
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        })
    }

    private fun openMicrophoneTimeline() {
        SystemUtil.runWithShellPermissionIdentity {
            context.startActivity(Intent(Intent.ACTION_REVIEW_PERMISSION_HISTORY).apply {
                putExtra(Intent.EXTRA_PERMISSION_GROUP_NAME, Manifest.permission_group.MICROPHONE)
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            })
        }
    }

    companion object {
        const val APP_APK_PATH = ""$APK_DIRECTORY/CtsAccessMicrophoneApp.apk""
        const val APP_PACKAGE_NAME = ""android.permission3.cts.accessmicrophoneapp""
        const val APP2_APK_PATH = ""$APK_DIRECTORY/CtsAccessMicrophoneApp2.apk""
        const val APP2_PACKAGE_NAME = ""android.permission3.cts.accessmicrophoneapp2""
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionHistoryTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionTest23.kt"	"testInvalidPermission"	"CtsPermission3TestCases"	"2: tv camera"	"fun testInvalidPermission() {
        // Request the permission and allow it
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(INVALID_PERMISSION to false) {}
    }

    private fun denyPermissionRequestWithPrejudice() {
        if (isTv || isWatch) {
            clickPermissionRequestDontAskAgainButton()
        } else {
            clickPermissionRequestDenyAndDontAskAgainButton()
        }
    }

    private fun assertAppHasAllOrNoPermissions(expectPermissions: Boolean) {
        arrayOf(
            android.Manifest.permission.SEND_SMS,
            android.Manifest.permission.RECEIVE_SMS,
            android.Manifest.permission.RECEIVE_WAP_PUSH,
            android.Manifest.permission.RECEIVE_MMS,
            android.Manifest.permission.READ_CALENDAR,
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.READ_CALL_LOG,
            android.Manifest.permission.WRITE_CALL_LOG,
            android.Manifest.permission.ADD_VOICEMAIL,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.USE_SIP,
            android.Manifest.permission.PROCESS_OUTGOING_CALLS,
            android.Manifest.permission.RECORD_AUDIO,
            android.Manifest.permission.ACCESS_FINE_LOCATION,
            android.Manifest.permission.ACCESS_COARSE_LOCATION,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.BODY_SENSORS,
            android.Manifest.permission.READ_CELL_BROADCASTS,
            // Split permissions
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION,
            // Storage permissions
            android.Manifest.permission.READ_EXTERNAL_STORAGE,
            android.Manifest.permission.WRITE_EXTERNAL_STORAGE
        ).forEach {
            assertAppHasPermission(it, expectPermissions)
        }
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionTest23.kt"	"testGrantPreviouslyRevokedWithPrejudiceShowsPrompt"	"CtsPermission3TestCases"	"1: camera"	"fun testGrantPreviouslyRevokedWithPrejudiceShowsPrompt() {
        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.CAMERA, false)

        // Request the permission and deny it
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.CAMERA to false) {
            clickPermissionRequestDenyButton()
        }

        // Request the permission and choose don't ask again
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.CAMERA to false) {
            denyPermissionRequestWithPrejudice()
        }

        // Clear the denial with prejudice
        grantAppPermissions(android.Manifest.permission.CAMERA)
        revokeAppPermissions(android.Manifest.permission.CAMERA)

        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.CAMERA, false)

        // Request the permission and allow it
        // Make sure the permission is granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.CAMERA to true) {
            if (SdkLevel.isAtLeastS()) {
                clickPermissionRequestAllowForegroundButton()
            } else {
                clickPermissionRequestAllowButton()
            }
        }
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionTest23.kt"	"testNoResidualPermissionsOnUninstall"	"CtsPermission3TestCases"	"1: camera"	"(timeout = 120000)
    @FlakyTest
    fun testNoResidualPermissionsOnUninstall() {
        Assume.assumeFalse(packageManager.arePermissionsIndividuallyControlled())

        // Grant all permissions
        grantAppPermissions(
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.RECORD_AUDIO,
            android.Manifest.permission.BODY_SENSORS,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.READ_EXTERNAL_STORAGE, targetSdk = 23
        )
        // Don't use UI for granting location permission as this shows another dialog
        uiAutomation.grantRuntimePermission(
            APP_PACKAGE_NAME, android.Manifest.permission.ACCESS_FINE_LOCATION
        )
        uiAutomation.grantRuntimePermission(
            APP_PACKAGE_NAME, android.Manifest.permission.ACCESS_COARSE_LOCATION
        )
        uiAutomation.grantRuntimePermission(
            APP_PACKAGE_NAME, android.Manifest.permission.ACCESS_BACKGROUND_LOCATION
        )

        uninstallPackage(APP_PACKAGE_NAME)
        installPackage(APP_APK_PATH_23)

        // Make no permissions are granted after uninstalling and installing the app
        assertAppHasAllOrNoPermissions(false)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionUsageInfoTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: tv"	"/*
 *.
 */

package android.permission3.cts

import android.content.Intent
import android.support.test.uiautomator.By
import com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test

/**
 * Tests permission usage info action.
 */
class PermissionUsageInfoTest : BaseUsePermissionTest() {
    @Before
    fun assumeHandheld() {
        assumeFalse(isAutomotive)
        assumeFalse(isTv)
        assumeFalse(isWatch)
    }

    @Before
    fun installApp() {
        installPackage(APP_APK_PATH_LATEST)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUsageInfoTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionSplitTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: tv"	"/*
 *.
 */

package android.permission3.cts

import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test

/**
 * Runtime permission behavior tests for permission splits.
 */
class PermissionSplitTest : BaseUsePermissionTest() {
    @Before
    fun assumeNotTv() {
        assumeFalse(isTv)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionSplitTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionTapjackingTest.kt"	"testTapjackGrantDialog_fullOverlay"	"CtsPermission3TestCases"	"4: visible hide television tv"	"fun testTapjackGrantDialog_fullOverlay() {
        // PermissionController for television uses a floating window.
        assumeFalse(isTv)

        assertAppHasPermission(ACCESS_FINE_LOCATION, false)
        requestAppPermissionsForNoResult(ACCESS_FINE_LOCATION) {}

        val buttonCenter = waitFindObject(By.text(
                getPermissionControllerString(ALLOW_FOREGROUND_BUTTON_TEXT))).visibleCenter

        // Wait for overlay to hide the dialog
        context.sendBroadcast(Intent(ACTION_SHOW_OVERLAY)
                .putExtra(EXTRA_FULL_OVERLAY, true))
        waitFindObject(By.res(""android.permission3.cts.usepermission:id/overlay""))

        tryClicking(buttonCenter)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTapjackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionTapjackingTest.kt"	"testTapjackGrantDialog_partialOverlay"	"CtsPermission3TestCases"	"4: visible hide television tv"	"fun testTapjackGrantDialog_partialOverlay() {
        // PermissionController for television uses a floating window.
        assumeFalse(isTv)
        // Automotive doesn't support detecting partial overlays yet: b/192088266
        assumeFalse(isAutomotive)

        assertAppHasPermission(ACCESS_FINE_LOCATION, false)
        requestAppPermissionsForNoResult(ACCESS_FINE_LOCATION) {}

        val buttonCenter = waitFindObject(By.text(
                getPermissionControllerString(ALLOW_FOREGROUND_BUTTON_TEXT))).visibleCenter
        val dialogBounds = waitFindObject(By.res(
                ""com.android.permissioncontroller"", ""grant_dialog"")).visibleBounds
        val messageBottom = waitFindObject(By.res(
                ""com.android.permissioncontroller"", ""permission_message"")).visibleBounds.bottom

        // Wait for overlay to hide the dialog
        context.sendBroadcast(Intent(ACTION_SHOW_OVERLAY)
                .putExtra(EXTRA_FULL_OVERLAY, false)
                .putExtra(DIALOG_LEFT, dialogBounds.left)
                .putExtra(DIALOG_TOP, dialogBounds.top)
                .putExtra(DIALOG_RIGHT, dialogBounds.right)
                .putExtra(MESSAGE_BOTTOM, messageBottom))
        waitFindObject(By.res(""android.permission3.cts.usepermission:id/overlay""))

        tryClicking(buttonCenter)
    }

    private fun tryClicking(buttonCenter: Point) {
        try {
            // Try to grant the permission, this should fail
            SystemUtil.eventually({
                if (packageManager.checkPermission(ACCESS_FINE_LOCATION, APP_PACKAGE_NAME) ==
                        PackageManager.PERMISSION_DENIED) {
                    uiDevice.click(buttonCenter.x, buttonCenter.y)
                    Thread.sleep(100)
                }
                assertAppHasPermission(ACCESS_FINE_LOCATION, true)
            }, 10000)
        } catch (e: RuntimeException) {
            // expected
        }
        // Permission should not be granted
        assertAppHasPermission(ACCESS_FINE_LOCATION, false)

        // On Automotive the dialog gets closed by the tapjacking activity popping up
        if (!isAutomotive) {
            // Verify that clicking the dialog without the overlay still works
            context.sendBroadcast(Intent(ACTION_HIDE_OVERLAY))
            SystemUtil.eventually({
                if (packageManager.checkPermission(ACCESS_FINE_LOCATION, APP_PACKAGE_NAME) ==
                        PackageManager.PERMISSION_DENIED) {
                    uiDevice.click(buttonCenter.x, buttonCenter.y)
                    Thread.sleep(100)
                }
                assertAppHasPermission(ACCESS_FINE_LOCATION, true)
            }, 10000)
        }
    }

    companion object {
        const val ACTION_SHOW_OVERLAY = ""android.permission3.cts.usepermission.ACTION_SHOW_OVERLAY""
        const val ACTION_HIDE_OVERLAY = ""android.permission3.cts.usepermission.ACTION_HIDE_OVERLAY""

        const val EXTRA_FULL_OVERLAY = ""android.permission3.cts.usepermission.extra.FULL_OVERLAY""

        const val DIALOG_LEFT = ""android.permission3.cts.usepermission.extra.DIALOG_LEFT""
        const val DIALOG_TOP = ""android.permission3.cts.usepermission.extra.DIALOG_TOP""
        const val DIALOG_RIGHT = ""android.permission3.cts.usepermission.extra.DIALOG_RIGHT""
        const val MESSAGE_BOTTOM = ""android.permission3.cts.usepermission.extra.MESSAGE_BOTTOM""
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTapjackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission3.cts.PermissionTest29.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: tv"	"/*
 *.
 */

package android.permission3.cts

import android.support.test.uiautomator.By
import androidx.test.filters.FlakyTest
import com.android.compatibility.common.util.SystemUtil.eventually
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test

/**
 * Runtime permission behavior tests for apps targeting API 29.
 */
class PermissionTest29 : BaseUsePermissionTest() {
    @Before
    fun assumeNotTv() {
        assumeFalse(isTv)
    }

    @Before
    fun installApp29() {
        installPackage(APP_APK_PATH_29)
    }

    @Before
    fun assertAppHasNoPermissions() {
        assertAppHasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, false)
        assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest29.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission4.cts.CameraMicIndicatorsPermissionTest.kt"	"testHotwordIndicatorBehavior"	"CtsPermission4TestCases"	"4: visible indicator tv camera"	"fun testHotwordIndicatorBehavior() {
        testCameraAndMicIndicator(useMic = false, useCamera = false, useHotword = true)
    }

    private fun testCameraAndMicIndicator(
        useMic: Boolean,
        useCamera: Boolean,
        useHotword: Boolean = false
    ) {
        openApp(useMic, useCamera, useHotword)
        eventually {
            val appView = uiDevice.findObject(UiSelector().textContains(APP_LABEL))
            assertTrue(""View with text $APP_LABEL not found"", appView.exists())
        }

        if (packageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
            assertTvIndicatorsShown(useMic, useCamera, useHotword)
        } else if (packageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            assertCarIndicatorsShown(useMic, useCamera)
        } else {
            uiDevice.openQuickSettings()
            assertPrivacyChipAndIndicatorsPresent(useMic, useCamera)
        }
    }

    private fun assertTvIndicatorsShown(useMic: Boolean, useCamera: Boolean, useHotword: Boolean) {
        if (useMic || useHotword) {
            val found = WindowManagerStateHelper()
                .waitFor(""Waiting for the mic indicator window to come up"") {
                    it.containsWindow(TV_MIC_INDICATOR_WINDOW_TITLE) &&
                    it.isWindowVisible(TV_MIC_INDICATOR_WINDOW_TITLE)
                }
            if (useMic) {
                assertTrue(""Did not find chip"", found)
            } else {
                assertFalse(""Found chip, but did not expect to"", found)
            }
        }
        if (useCamera) {
            // There is no camera indicator on TVs.
        }
    }

    private fun assertCarIndicatorsShown(useMic: Boolean, useCamera: Boolean) {
        // Ensure the privacy chip is present (or not)
        val chipFound = isChipPresent()
        if (useMic || useCamera) {
            assertTrue(""Did not find chip"", chipFound)
        } else {
            assertFalse(""Found chip, but did not expect to"", chipFound)
            return
        }

        eventually {
            if (useMic) {
                val appView = uiDevice.findObject(UiSelector().textContains(micLabel))
                assertTrue(""View with text $APP_LABEL not found"", appView.exists())
            }
            if (useCamera) {
                // There is no camera indicator in Cars.
            }
            val appView = uiDevice.findObject(UiSelector().textContains(APP_LABEL))
            assertTrue(""View with text $APP_LABEL not found"", appView.exists())
        }
    }

    private fun assertPrivacyChipAndIndicatorsPresent(useMic: Boolean, useCamera: Boolean) {
        // Ensure the privacy chip is present (or not)
        val chipFound = isChipPresent()
        if (useMic || useCamera) {
            assertTrue(""Did not find chip"", chipFound)
        } else {
            assertFalse(""Found chip, but did not expect to"", chipFound)
            return
        }

        eventually {
            if (useMic) {
                val iconView = uiDevice.findObject(UiSelector().descriptionContains(micLabel))
                assertTrue(""View with description $micLabel not found"", iconView.exists())
            }
            if (useCamera) {
                val iconView = uiDevice.findObject(UiSelector().descriptionContains(cameraLabel))
                assertTrue(""View with text $APP_LABEL not found"", iconView.exists())
            }
            val appView = uiDevice.findObject(UiSelector().textContains(APP_LABEL))
            assertTrue(""View with text $APP_LABEL not found"", appView.exists())
        }
    }

    private fun isChipPresent(): Boolean {
        var chipFound = false
        try {
            eventually {
                val privacyChip = uiDevice.findObject(By.res(PRIVACY_CHIP_ID))
                assertNotNull(""view with id $PRIVACY_CHIP_ID not found"", privacyChip)
                privacyChip.click()
                chipFound = true
            }
        } catch (e: Exception) {
            // Handle more gracefully after
        }
        return chipFound
    }

    private fun pressBack() {
        uiDevice.pressBack()
        waitForIdle()
    }

    private fun pressHome() {
        uiDevice.pressHome()
        waitForIdle()
    }

    private fun waitForIdle() =
        uiAutomation.waitForIdle(IDLE_TIMEOUT_MILLIS, TIMEOUT_MILLIS)
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission4/src/android/permission4/cts/CameraMicIndicatorsPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission4.cts.CameraMicIndicatorsPermissionTest.kt"	"DisableAnimationRule"	"CtsPermission4TestCases"	"3: indicator tv camera"	"/*
 *.
 */
package android.permission4.cts

import android.Manifest
import android.app.Instrumentation
import android.app.UiAutomation
import android.app.compat.CompatChanges
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.hardware.camera2.CameraManager
import android.os.Process
import android.provider.DeviceConfig
import android.provider.Settings
import android.server.wm.WindowManagerStateHelper
import android.support.test.uiautomator.By
import android.support.test.uiautomator.UiDevice
import android.support.test.uiautomator.UiSelector
import androidx.test.platform.app.InstrumentationRegistry
import com.android.compatibility.common.util.DisableAnimationRule
import com.android.compatibility.common.util.SystemUtil.*
import org.junit.After
import org.junit.Assert.*
import org.junit.Assume.assumeFalse
import org.junit.Assume.assumeTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test

private const val APP_LABEL = ""CtsCameraMicAccess""
private const val USE_CAMERA = ""use_camera""
private const val USE_MICROPHONE = ""use_microphone""
private const val USE_HOTWORD = ""use_hotword""
private const val INTENT_ACTION = ""test.action.USE_CAMERA_OR_MIC""
private const val PRIVACY_CHIP_ID = ""com.android.systemui:id/privacy_chip""
private const val INDICATORS_FLAG = ""camera_mic_icons_enabled""
private const val PERMISSION_INDICATORS_NOT_PRESENT = 162547999L
private const val IDLE_TIMEOUT_MILLIS: Long = 1000
private const val UNEXPECTED_TIMEOUT_MILLIS = 1000
private const val TIMEOUT_MILLIS: Long = 20000
private const val TV_MIC_INDICATOR_WINDOW_TITLE = ""MicrophoneCaptureIndicator""

class CameraMicIndicatorsPermissionTest {
    private val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
    private val context: Context = instrumentation.context
    private val uiAutomation: UiAutomation = instrumentation.uiAutomation
    private val uiDevice: UiDevice = UiDevice.getInstance(instrumentation)
    private val packageManager: PackageManager = context.packageManager

    private var wasEnabled = false
    private val micLabel = packageManager.getPermissionGroupInfo(
        Manifest.permission_group.MICROPHONE, 0).loadLabel(packageManager).toString()
    private val cameraLabel = packageManager.getPermissionGroupInfo(
        Manifest.permission_group.CAMERA, 0).loadLabel(packageManager).toString()

    private var screenTimeoutBeforeTest: Long = 0L

    @get:Rule
    val disableAnimationRule = DisableAnimationRule()

    @Before
    fun setUp() {
        runWithShellPermissionIdentity {
            screenTimeoutBeforeTest = Settings.System.getLong(
                context.contentResolver, Settings.System.SCREEN_OFF_TIMEOUT
            )
            Settings.System.putLong(
                context.contentResolver, Settings.System.SCREEN_OFF_TIMEOUT, 1800000L
            )
        }

        uiDevice.wakeUp()
        runShellCommand(instrumentation, ""wm dismiss-keyguard"")

        uiDevice.findObject(By.text(""Close""))?.click()
        wasEnabled = setIndicatorsEnabledStateIfNeeded(true)
        // If the change Id is not present, then isChangeEnabled will return true. To bypass this,
        // the change is set to ""false"" if present.
        assumeFalse(""feature not present on this device"", callWithShellPermissionIdentity {
            CompatChanges.isChangeEnabled(PERMISSION_INDICATORS_NOT_PRESENT, Process.SYSTEM_UID)
        })
    }

    private fun setIndicatorsEnabledStateIfNeeded(shouldBeEnabled: Boolean): Boolean {
        var currentlyEnabled = false
        runWithShellPermissionIdentity {
            currentlyEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_PRIVACY,
                INDICATORS_FLAG, true)
            if (currentlyEnabled != shouldBeEnabled) {
                DeviceConfig.setProperty(DeviceConfig.NAMESPACE_PRIVACY, INDICATORS_FLAG,
                    shouldBeEnabled.toString(), false)
            }
        }
        return currentlyEnabled
    }

    @After
    fun tearDown() {
        if (!wasEnabled) {
            setIndicatorsEnabledStateIfNeeded(false)
        }
        runWithShellPermissionIdentity {
            Settings.System.putLong(
                context.contentResolver, Settings.System.SCREEN_OFF_TIMEOUT,
                screenTimeoutBeforeTest
            )
        }

        pressBack()
        pressBack()
        pressHome()
        pressHome()
        Thread.sleep(3000)
    }

    private fun openApp(useMic: Boolean, useCamera: Boolean, useHotword: Boolean) {
        context.startActivity(Intent(INTENT_ACTION).apply {
            putExtra(USE_CAMERA, useCamera)
            putExtra(USE_MICROPHONE, useMic)
            putExtra(USE_HOTWORD, useHotword)
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        })
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission4/src/android/permission4/cts/CameraMicIndicatorsPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	Test Available	"android.permission4.cts.CameraMicIndicatorsPermissionTest.kt"	"testCameraIndicator"	"CtsPermission4TestCases"	"2: indicator camera"	"fun testCameraIndicator() {
        val manager = context.getSystemService(CameraManager::class.java)!!
        assumeTrue(manager.cameraIdList.isNotEmpty())
        testCameraAndMicIndicator(useMic = false, useCamera = true)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission4/src/android/permission4/cts/CameraMicIndicatorsPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission4.cts.CameraMicIndicatorsPermissionTest.kt"	"testMicIndicator"	"CtsPermission4TestCases"	"2: indicator camera"	"fun testMicIndicator() {
        testCameraAndMicIndicator(useMic = true, useCamera = false)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission4/src/android/permission4/cts/CameraMicIndicatorsPermissionTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"setUpTest"	"CtsPermission5TestCases"	"2: tv user"	"/*
 *.
 */
package android.permission5.cts

import android.Manifest
import android.app.AppOpsManager
import android.app.Instrumentation
import android.content.AttributionSource
import android.content.ComponentName
import android.content.ContentValues
import android.content.Context
import android.content.ContextParams
import android.content.Intent
import android.content.pm.PackageManager.FEATURE_LEANBACK
import android.net.Uri
import android.os.Bundle
import android.os.Process
import android.os.RemoteCallback
import android.os.SystemClock
import android.os.UserHandle
import android.permission.PermissionManager
import android.platform.test.annotations.AppModeFull
import android.provider.CalendarContract
import android.provider.CallLog
import android.provider.ContactsContract
import android.provider.Telephony
import android.speech.RecognitionListener
import android.speech.SpeechRecognizer
import androidx.test.platform.app.InstrumentationRegistry
import com.android.compatibility.common.util.SystemUtil
import com.google.common.truth.Truth.assertThat
import org.junit.After
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test
import org.mockito.ArgumentMatcher
import org.mockito.Mockito.eq
import org.mockito.Mockito.inOrder
import org.mockito.Mockito.intThat
import org.mockito.Mockito.isNull
import org.mockito.Mockito.mock
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicReference
import java.util.concurrent.locks.ReentrantLock
import java.util.function.Consumer

@AppModeFull(reason = ""Instant apps cannot hold READ_CONTACTS/READ_CALENDAR/READ_SMS/READ_CALL_LOG"")
class RuntimePermissionsAppOpTrackingTest {

    @Before
    fun setUpTest() {
        val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
        SystemUtil.runWithShellPermissionIdentity {
            appOpsManager.clearHistory()
            appOpsManager.setHistoryParameters(
                    AppOpsManager.HISTORICAL_MODE_ENABLED_ACTIVE,
                    SNAPSHOT_INTERVAL_MILLIS,
                    INTERVAL_COMPRESSION_MULTIPLIER)

            appOpsManager.resetPackageOpsNoHistory(context.packageName)
            appOpsManager.resetPackageOpsNoHistory(SHELL_PACKAGE_NAME)
            appOpsManager.resetPackageOpsNoHistory(RECEIVER_PACKAGE_NAME)
            appOpsManager.resetPackageOpsNoHistory(RECEIVER2_PACKAGE_NAME)
        }
    }

    @After
    fun tearDownTest() {
        val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
        SystemUtil.runWithShellPermissionIdentity {
            appOpsManager.clearHistory()
            appOpsManager.resetHistoryParameters()
        }
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfSmsAccess"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testSelfSmsAccess() {
        assumeNotTv()
        testSelfAccess(Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfCallLogWrite"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testSelfCallLogWrite() {
        testSelfWrite(CallLog.Calls.CONTENT_URI,
                Manifest.permission.WRITE_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testSelfWrite(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG, null, null)
        val beginEndMillis = System.currentTimeMillis()
        context.contentResolver.insert(uri, ContentValues())
        val endTimeMillis = System.currentTimeMillis()

        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, context.attributionSource,
                /*accessorForeground*/ true, /*receiverForeground*/ false,
                /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 0, /*checkAccessor*/ true,
                /*fromDatasource*/ false)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedSmsAccessAttributeToAnother"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testUntrustedSmsAccessAttributeToAnother() {
        assumeNotTv()
        testUntrustedAccessAttributeToAnother(Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedSmsAccessAttributeToAnotherThroughIntermediary"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testUntrustedSmsAccessAttributeToAnotherThroughIntermediary() {
        assumeNotTv()
        testUntrustedAccessAttributeToAnotherThroughIntermediary(
                Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testTrustedAccessSmsAttributeToAnother"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testTrustedAccessSmsAttributeToAnother() {
        assumeNotTv()
        testTrustedAccessAttributeToAnother(Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testMicRecognitionMicRecoWithAttribution"	"CtsPermission5TestCases"	"1: tv"	"@Throws(Exception::class)
    fun testMicRecognitionMicRecoWithAttribution() {
        runWithAuxiliaryApps {
            startBlamedAppActivity()

            val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                    RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)

            val listener = mock(AppOpsManager.OnOpActiveChangedListener::class.java)
            val appopsManager = context.getSystemService(AppOpsManager::class.java)
            SystemUtil.runWithShellPermissionIdentity<Unit> {
                appopsManager!!.startWatchingActive(arrayOf(AppOpsManager.OPSTR_RECORD_AUDIO),
                        context.mainExecutor, listener)
            }

            val speechStartTime = System.currentTimeMillis()
            val recognizerRef = AtomicReference<SpeechRecognizer>()
            var currentOperationComplete = CountDownLatch(1)

            instrumentation.runOnMainSync {
                val recognizer = SpeechRecognizer.createSpeechRecognizer(context,
                        ComponentName(RECEIVER2_PACKAGE_NAME, RECOGNITION_SERVICE))

                recognizer.setRecognitionListener(object : RecognitionListener {
                    override fun onReadyForSpeech(params: Bundle?) {}
                    override fun onRmsChanged(rmsdB: Float) {}
                    override fun onBufferReceived(buffer: ByteArray?) {
                        currentOperationComplete.countDown()
                    }
                    override fun onPartialResults(partialResults: Bundle?) {}
                    override fun onEvent(eventType: Int, params: Bundle?) {}
                    override fun onError(error: Int) {}
                    override fun onResults(results: Bundle?) {}
                    override fun onBeginningOfSpeech() {}
                    override fun onEndOfSpeech() {}
                })

                val recoIntent = Intent()
                recoIntent.putExtra(OPERATION, OPERATION_MIC_RECO_WITH_ATTRIBUTION)
                recognizer.startListening(recoIntent)

                recognizerRef.set(recognizer)
            }

            try {
                currentOperationComplete.await(ASYNC_OPERATION_TIMEOUT_MILLIS,
                        TimeUnit.MILLISECONDS)

                val op = AppOpsManager.permissionToOp(Manifest.permission.RECORD_AUDIO)!!

                assertRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        AttributionSource(context.packageManager.getPackageUid(
                                RECEIVER2_PACKAGE_NAME, 0), RECEIVER2_PACKAGE_NAME,
                                /*attributionTag*/ null, null, context.attributionSource),
                        /*accessorForeground*/ true, /*receiverForeground*/ true,
                        /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                        /*receiverAccessCount*/ 1, /*checkAccessor*/ true,
                        /*fromDatasource*/ true)

                assertRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        context.attributionSource, /*accessorForeground*/ true,
                        /*receiverForeground*/ true, /*accessorTrusted*/ true,
                        /*accessorAccessCount*/ 0, /*receiverAccessCount*/ 1,
                        /*checkAccessor*/ false, /*fromDatasource*/ true)

                // Finish recon and check if all ops are finished
                currentOperationComplete = CountDownLatch(1)
                instrumentation.runOnMainSync { recognizerRef.get().cancel() }
                currentOperationComplete.await(ASYNC_OPERATION_TIMEOUT_MILLIS,
                        TimeUnit.MILLISECONDS)

                val recognizerUid = context.packageManager.getPackageUid(
                        RECEIVER2_PACKAGE_NAME, 0)

                assertNotRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        AttributionSource(recognizerUid, RECEIVER2_PACKAGE_NAME,
                                /*attributionTag*/ null, null, context.attributionSource),
                        /*accessorForeground*/ true, /*receiverForeground*/ true,
                        /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                        /*receiverAccessCount*/ 1, /*checkAccessor*/ true,
                        /*fromDatasource*/ true)

                assertNotRunningOpAccess(op, speechStartTime, System.currentTimeMillis(),
                        context.attributionSource, /*accessorForeground*/ true,
                        /*receiverForeground*/ true, /*accessorTrusted*/ true,
                        /*accessorAccessCount*/ 0, /*receiverAccessCount*/ 1,
                        /*checkAccessor*/ false, /*fromDatasource*/ true)

                var attributionChainId: Int? = null
                val inOrder = inOrder(listener)
                val attributionChainIdMatcher = ArgumentMatcher<Int> {
                    if (attributionChainId == null) {
                        attributionChainId = it
                        return@ArgumentMatcher true
                    } else {
                        return@ArgumentMatcher (attributionChainId == it)
                    }
                }
                val receiverUid = context.packageManager.getPackageUid(
                        RECEIVER_PACKAGE_NAME, 0)

                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(recognizerUid), eq(RECEIVER2_PACKAGE_NAME), isNull(), eq(true),
                        eq(AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR or ATTRIBUTION_FLAG_TRUSTED),
                        intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(Process.myUid()), eq(context.packageName), eq(ACCESSOR_ATTRIBUTION_TAG),
                        eq(true), eq(AppOpsManager.ATTRIBUTION_FLAG_INTERMEDIARY or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(receiverUid), eq(RECEIVER_PACKAGE_NAME), eq(RECEIVER_ATTRIBUTION_TAG),
                        eq(true), eq(AppOpsManager.ATTRIBUTION_FLAG_RECEIVER or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))

                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(recognizerUid), eq(RECEIVER2_PACKAGE_NAME), isNull(), eq(false),
                        eq(AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR or ATTRIBUTION_FLAG_TRUSTED),
                        intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(Process.myUid()), eq(context.packageName), eq(ACCESSOR_ATTRIBUTION_TAG),
                        eq(false), eq(AppOpsManager.ATTRIBUTION_FLAG_INTERMEDIARY or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))
                inOrder.verify(listener).onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(receiverUid), eq(RECEIVER_PACKAGE_NAME), eq(RECEIVER_ATTRIBUTION_TAG),
                        eq(false), eq(AppOpsManager.ATTRIBUTION_FLAG_RECEIVER or
                        ATTRIBUTION_FLAG_TRUSTED), intThat(attributionChainIdMatcher))
            } finally {
                // Take down the recognition service
                instrumentation.runOnMainSync { recognizerRef.get().destroy() }
            }
        }
    }

    fun runWithAuxiliaryApps(worker: () -> Unit) {
        ensureAuxiliaryAppsNotRunningAndNoResidualProcessState()
        try {
            worker.invoke()
        } finally {
            ensureAuxiliaryAppsNotRunningAndNoResidualProcessState()
        }
    }

    companion object {
        private const val ASYNC_OPERATION_TIMEOUT_MILLIS: Long = 5000 // 5 sec
        private const val INTERVAL_COMPRESSION_MULTIPLIER = 10
        private const val SNAPSHOT_INTERVAL_MILLIS: Long = 1000

        val SHELL_PACKAGE_NAME = ""com.android.shell""
        val RECEIVER_PACKAGE_NAME = ""android.permission5.cts.blamed""
        val BRING_TO_FOREGROUND_ACTIVITY =
                ""android.permission5.cts.blamed.BringToForegroundActivity""
        val RECOGNITION_SERVICE = ""android.permission5.cts.blamed2.MyRecognitionService""
        val REMOTE_CALLBACK = ""remote_callback""
        val ATTRIBUTION_SOURCE = ""attribution_source""
        val ACCESSOR_ATTRIBUTION_TAG = ""accessor_attribution_tag""
        val RECEIVER2_PACKAGE_NAME = ""android.permission5.cts.blamed2""
        val RECEIVER_ATTRIBUTION_TAG = ""receiver_attribution_tag""
        val RECEIVER2_ATTRIBUTION_TAG = ""receiver2_attribution_tag""

        val OPERATION = ""operation""
        val OPERATION_MIC_RECO_WITH_ATTRIBUTION = ""operation:mic_reco_with_attribution""
        val OPERATION_INJECT_RECO_WITHOUT_ATTRIBUTION = ""operation:inject_reco_without_attribution""

        val ATTRIBUTION_FLAG_TRUSTED = 0x8

        private val context: Context
            get() = InstrumentationRegistry.getInstrumentation().getContext()

        private val instrumentation: Instrumentation
            get() = InstrumentationRegistry.getInstrumentation()

        private val isTv = context.packageManager.hasSystemFeature(FEATURE_LEANBACK)

        fun ensureAuxiliaryAppsNotRunningAndNoResidualProcessState() {
            SystemUtil.runShellCommand(""am force-stop $RECEIVER_PACKAGE_NAME"")
            SystemUtil.runShellCommand(""am force-stop $RECEIVER2_PACKAGE_NAME"")
            SystemClock.sleep(ASYNC_OPERATION_TIMEOUT_MILLIS)
        }

        @Throws(Exception::class)
        private fun assertRunningOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            assertOpAccess(op, beginEndMillis, endTimeMillis, attributionSource,
                    accessorForeground, receiverForeground, accessorTrusted,
                    /*assertRunning*/ true, accessorAccessCount, receiverAccessCount,
                    checkAccessor, fromDatasource)
        }

        @Throws(Exception::class)
        private fun assertNotRunningOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            assertOpAccess(op, beginEndMillis, endTimeMillis, attributionSource,
                    accessorForeground, receiverForeground, accessorTrusted,
                    /*assertRunning*/ false, accessorAccessCount, receiverAccessCount,
                    checkAccessor, fromDatasource)
        }

        @Throws(Exception::class)
        private fun assertOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            assertLastOpAccess(op, beginEndMillis, endTimeMillis, attributionSource,
                    accessorForeground, receiverForeground, accessorTrusted, assertRunning,
                    checkAccessor, fromDatasource)
            assertHistoricalOpAccess(op, attributionSource, accessorForeground,
                    receiverForeground, accessorTrusted, accessorAccessCount, receiverAccessCount,
                    checkAccessor, fromDatasource)
        }

        private fun assertLastOpAccess(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
            val allPackagesOps: MutableList<AppOpsManager.PackageOps?> = ArrayList()
            SystemUtil.runWithShellPermissionIdentity<Boolean> {
                allPackagesOps.addAll(appOpsManager.getPackagesForOps(arrayOf(op)))
            }
            if (checkAccessor) {
                assertLastAccessorOps(op, beginEndMillis, endTimeMillis, attributionSource,
                        accessorForeground, accessorTrusted, assertRunning, fromDatasource,
                        allPackagesOps)
            } else {
                assertNotLastAccessorOps(op, attributionSource, allPackagesOps)
            }
            if (attributionSource.next != null) {
                assertLastReceiverOps(op, beginEndMillis, endTimeMillis, attributionSource,
                        receiverForeground, accessorTrusted, assertRunning, allPackagesOps)
            }
        }

        @Throws(Exception::class)
        private fun assertHistoricalOpAccess(
            op: String,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            accessorAccessCount: Int,
            receiverAccessCount: Int,
            checkAccessor: Boolean,
            fromDatasource: Boolean
        ) {
            val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
            val request = AppOpsManager.HistoricalOpsRequest.Builder(0, Long.MAX_VALUE)
                    .setOpNames(listOf(op))
                    .build()
            val historicalOpsRef = AtomicReference<AppOpsManager.HistoricalOps>()
            val lock = ReentrantLock()
            val condition = lock.newCondition()
            SystemUtil.runWithShellPermissionIdentity {
                appOpsManager.getHistoricalOps(request, context.mainExecutor,
                        Consumer { historicalOps: AppOpsManager.HistoricalOps ->
                            historicalOpsRef.set(historicalOps)
                            lock.lock()
                            try {
                                condition.signalAll()
                            } finally {
                                lock.unlock()
                            }
                        })
            }
            lock.lock()
            try {
                condition.await(ASYNC_OPERATION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
            } finally {
                lock.unlock()
            }

            val historicalOps = historicalOpsRef.get()
            if (checkAccessor) {
                assertHistoricalAccessorOps(op, attributionSource, accessorForeground,
                        accessorTrusted, fromDatasource, accessorAccessCount, historicalOps)
            } else {
                assertNoHistoricalAccessorOps(op, attributionSource, historicalOps)
            }
            if (attributionSource.next != null) {
                assertHistoricalReceiverOps(op, attributionSource, receiverForeground,
                        accessorTrusted, receiverAccessCount, historicalOps)
            }
        }

        private fun assertLastAccessorOps(
            op: String,
            beginEndMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            fromDatasource: Boolean,
            allPackagesOps: List<AppOpsManager.PackageOps?>
        ) {
            val accessorPackageOps = findPackageOps(attributionSource.uid,
                    attributionSource.packageName!!, allPackagesOps)
            for (opEntry in accessorPackageOps!!.ops) {
                if (!op.equals(opEntry.opStr)) {
                    continue
                }
                val attributedOpEntry = opEntry.attributedOpEntries[
                        attributionSource.attributionTag]
                if (attributionSource.next == null) {
                    // Access for ourselves
                    assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_SELF, accessorForeground, assertRunning)
                } else if (accessorTrusted) {
                    // Access for others and we are trusted. If we got the data from a datasource
                    // the latter is the proxy and we proxied, otherwise we are the proxy.
                    if (fromDatasource) {
                        assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                                AppOpsManager.OP_FLAG_TRUSTED_PROXIED, accessorForeground,
                                assertRunning)
                    } else {
                        assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                                AppOpsManager.OP_FLAG_TRUSTED_PROXY, accessorForeground,
                                assertRunning)
                    }
                } else {
                    // Access for others and we are not trusted.
                    assertLastAccessInRange(attributedOpEntry!!, beginEndMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_UNTRUSTED_PROXY, accessorForeground,
                            assertRunning)
                }
            }
        }

        private fun assertNotLastAccessorOps(
            op: String,
            attributionSource: AttributionSource,
            allPackagesOps: List<AppOpsManager.PackageOps?>
        ) {
            val accessorPackageOps = findPackageOps(attributionSource.uid,
                    attributionSource.packageName!!, allPackagesOps) ?: return
            for (opEntry in accessorPackageOps.ops) {
                if (!op.equals(opEntry.opStr)) {
                    continue
                }
                val attributedOpEntry = opEntry.attributedOpEntries[
                        attributionSource.attributionTag]
                if (attributedOpEntry != null) {
                    assertThat(attributedOpEntry.getLastAccessBackgroundTime(
                            AppOpsManager.OP_FLAG_SELF
                            or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                            or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(-1)
                    assertThat(attributedOpEntry.getLastAccessBackgroundTime(
                            AppOpsManager.OP_FLAG_SELF
                            or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                            or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(-1)
                }
            }
        }

        private fun assertHistoricalAccessorOps(
            op: String,
            attributionSource: AttributionSource,
            accessorForeground: Boolean,
            accessorTrusted: Boolean,
            fromDatasource: Boolean,
            assertedAccessCount: Int,
            historicalOps: AppOpsManager.HistoricalOps
        ) {
            val accessorPackageOps = findPackageOps(
                    attributionSource.uid, attributionSource.packageName!!,
                    historicalOps)
            val attributedPackageOps = accessorPackageOps?.getAttributedOps(
                    attributionSource.attributionTag)

            val attributedPackageOp = attributedPackageOps!!.getOp(op)
            if (attributionSource.next == null) {
                // Access for ourselves
                assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_SELF,
                        accessorForeground, assertedAccessCount)
            } else if (accessorTrusted) {
                // Access for others and we are trusted. If we got the data from a datasource it
                // would blame the accessor in a trusted way
                if (fromDatasource) {
                    assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                            accessorForeground, assertedAccessCount)
                } else {
                    assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_TRUSTED_PROXY,
                            accessorForeground, assertedAccessCount)
                }
            } else {
                // Access for others and we are not trusted
                assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_UNTRUSTED_PROXY,
                        accessorForeground, assertedAccessCount)
            }
        }

        private fun assertNoHistoricalAccessorOps(
            op: String,
            attributionSource: AttributionSource,
            historicalOps: AppOpsManager.HistoricalOps
        ) {
            val accessorPackageOps = findPackageOps(
                    attributionSource.uid, attributionSource.packageName!!,
                    historicalOps)
            val attributedPackageOps = accessorPackageOps?.getAttributedOps(
                    attributionSource.attributionTag) ?: return
            val attributedPackageOp = attributedPackageOps.getOp(op)
            if (attributedPackageOp != null) {
                assertThat(attributedPackageOp.getBackgroundAccessCount(
                        AppOpsManager.OP_FLAG_SELF
                                or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                                or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(0)
                assertThat(attributedPackageOp.getBackgroundAccessCount(
                        AppOpsManager.OP_FLAG_SELF
                                or AppOpsManager.OP_FLAG_UNTRUSTED_PROXY
                                or AppOpsManager.OP_FLAG_TRUSTED_PROXY)).isEqualTo(0)
            }
        }

        private fun assertLastReceiverOps(
            op: String,
            beginTimeMillis: Long,
            endTimeMillis: Long,
            attributionSource: AttributionSource,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertRunning: Boolean,
            allPackagesOps: List<AppOpsManager.PackageOps?>
        ) {
            val receiverPackageOps = findPackageOps(
                    attributionSource.next!!.uid,
                    attributionSource.next!!.packageName!!,
                    allPackagesOps)
            for (opEntry in receiverPackageOps!!.ops) {
                if (op != opEntry.opStr) {
                    continue
                }
                val attributedOpEntry = opEntry.attributedOpEntries[
                        attributionSource.next!!.attributionTag]
                val opProxyInfo: AppOpsManager.OpEventProxyInfo?
                opProxyInfo = if (accessorTrusted) {
                    // Received from a trusted accessor. If we got the data from a datasource it
                    // would blame the accessor in a trusted way
                    assertLastAccessInRange(attributedOpEntry!!, beginTimeMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_TRUSTED_PROXIED, receiverForeground,
                            assertRunning)
                    attributedOpEntry.getLastProxyInfo(AppOpsManager.OP_FLAG_TRUSTED_PROXIED)
                } else {
                    // Received from an untrusted accessor
                    assertLastAccessInRange(attributedOpEntry!!, beginTimeMillis, endTimeMillis,
                            AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED, receiverForeground,
                            assertRunning)
                    attributedOpEntry.getLastProxyInfo(
                            AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED)
                }
                assertThat(opProxyInfo!!.uid).isEqualTo(attributionSource.uid)
                assertThat(opProxyInfo.packageName).isEqualTo(attributionSource.packageName)
                assertThat(opProxyInfo.attributionTag).isEqualTo(attributionSource.attributionTag)
            }
        }

        private fun assertHistoricalReceiverOps(
            op: String,
            attributionSource: AttributionSource,
            receiverForeground: Boolean,
            accessorTrusted: Boolean,
            assertedAccessCount: Int,
            historicalOps: AppOpsManager.HistoricalOps
        ) {
            val accessorPackageOps = findPackageOps(
                    attributionSource.next!!.uid,
                    attributionSource.next!!.packageName!!,
                    historicalOps)
            val attributedPackageOps = accessorPackageOps?.getAttributedOps(
                    attributionSource.next!!.attributionTag!!)
            val attributedPackageOp = attributedPackageOps!!.getOp(op)
            if (accessorTrusted) {
                // Received from a trusted accessor.
                    assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                            receiverForeground, assertedAccessCount)
            } else {
                // Received from an untrusted accessor
                assertAccessCount(attributedPackageOp!!, AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED,
                        receiverForeground, assertedAccessCount)
            }
        }

        private fun assertLastAccessInRange(
            opEntry: AppOpsManager.AttributedOpEntry,
            beginTimeMillis: Long,
            endTimeMillis: Long,
            assertedFlag: Int,
            assertForeground: Boolean,
            assertRunning: Boolean
        ) {
            assertThat(opEntry.isRunning).isEqualTo(assertRunning)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_SELF,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_TRUSTED_PROXY,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_UNTRUSTED_PROXY,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                    assertForeground, beginTimeMillis, endTimeMillis)
            assertTimeInRangeIfRequired(opEntry, assertedFlag,
                    AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED,
                    assertForeground, beginTimeMillis, endTimeMillis)
            if (assertForeground) {
                assertThat(opEntry.getLastAccessBackgroundTime(AppOpsManager.OP_FLAGS_ALL))
                        .isEqualTo(-1)
            } else {
                assertThat(opEntry.getLastAccessForegroundTime(AppOpsManager.OP_FLAGS_ALL))
                        .isEqualTo(-1)
            }
        }

        private fun assertTimeInRangeIfRequired(
            opEntry: AppOpsManager.AttributedOpEntry,
            assertedFlag: Int,
            accessedFlag: Int,
            assertForeground: Boolean,
            beginTimeMillis: Long,
            endTimeMillis: Long
        ) {
            if (assertedFlag != accessedFlag) {
                return
            }
            val accessTime: Long
            accessTime = if (assertForeground) {
                opEntry.getLastAccessForegroundTime(accessedFlag)
            } else {
                opEntry.getLastAccessBackgroundTime(accessedFlag)
            }
            assertThat(accessTime).isAtLeast(beginTimeMillis)
            assertThat(accessTime).isAtMost(endTimeMillis)
        }

        private fun assertAccessCount(
            historicalOp: AppOpsManager.HistoricalOp,
            assertedFlag: Int,
            assertForeground: Boolean,
            assertedAccessCount: Int
        ) {
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_SELF,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_TRUSTED_PROXY,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_UNTRUSTED_PROXY,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_TRUSTED_PROXIED,
                    assertedFlag, assertForeground, assertedAccessCount)
            assertAccessCountIfRequired(historicalOp, AppOpsManager.OP_FLAG_UNTRUSTED_PROXIED,
                    assertedFlag, assertForeground, assertedAccessCount)
            if (assertForeground) {
                assertThat(historicalOp.getBackgroundAccessCount(
                        AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            } else {
                assertThat(historicalOp.getForegroundAccessCount(
                        AppOpsManager.OP_FLAGS_ALL)).isEqualTo(0)
            }
        }

        private fun assertAccessCountIfRequired(
            historicalOp: AppOpsManager.HistoricalOp,
            assertedFlag: Int,
            accessedFlag: Int,
            assertForeground: Boolean,
            assertedAccessCount: Int
        ) {
            if (assertedFlag != accessedFlag) {
                return
            }
            val accessCount: Long
            accessCount = if (assertForeground) {
                historicalOp.getForegroundAccessCount(accessedFlag)
            } else {
                historicalOp.getBackgroundAccessCount(accessedFlag)
            }
            assertThat(accessCount).isEqualTo(assertedAccessCount)
        }

        private fun findPackageOps(
            uid: Int,
            packageName: String,
            searchedList: List<AppOpsManager.PackageOps?>
        ): AppOpsManager.PackageOps? {
            return searchedList.stream()
                    .filter { packageOps: AppOpsManager.PackageOps? ->
                        packageOps!!.uid == uid && packageOps.packageName == packageName
                    }
                    .findAny()
                    .orElse(null)
        }

        private fun findPackageOps(
            uid: Int,
            packageName: String,
            historicalOps: AppOpsManager.HistoricalOps
        ): AppOpsManager.HistoricalPackageOps? {
            val uidOps = historicalOps.getUidOps(uid)
            return uidOps?.getPackageOps(packageName)
        }

        fun createAttributionContext(
            attributionTag: String?,
            receiverPackageName: String?,
            receiverAttributionTag: String?
        ): Context {
            val attributionParamsBuilder = ContextParams.Builder()
            if (attributionTag != null) {
                attributionParamsBuilder.setAttributionTag(attributionTag)
            }
            if (receiverPackageName != null) {
                val attributionSourceBuilder = AttributionSource.Builder(
                        context.packageManager.getPackageUid(receiverPackageName, 0))
                attributionSourceBuilder.setPackageName(receiverPackageName)
                if (receiverAttributionTag != null) {
                    attributionSourceBuilder.setAttributionTag(receiverAttributionTag)
                }
                var receiverAttributionSource = attributionSourceBuilder.build()
                SystemUtil.runWithShellPermissionIdentity {
                    receiverAttributionSource = context.getSystemService(
                            PermissionManager::class.java)!!.registerAttributionSource(
                            receiverAttributionSource)
                }
                attributionParamsBuilder.setNextAttributionSource(receiverAttributionSource)
            }
            return context.createContext(attributionParamsBuilder.build())
        }

        fun startBlamedAppActivity(): AttributionSource {
            val activityStatedLatch = CountDownLatch(1)
            val attributionSourceRef = AtomicReference<AttributionSource>()
            val intent = Intent()
            intent.setClassName(RECEIVER_PACKAGE_NAME, BRING_TO_FOREGROUND_ACTIVITY)
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_SINGLE_TOP)
            intent.putExtra(REMOTE_CALLBACK, RemoteCallback {
                attributionSourceRef.set(it?.getParcelable(ATTRIBUTION_SOURCE))
                activityStatedLatch.countDown()
            })
            context.startActivity(intent)
            activityStatedLatch.await(ASYNC_OPERATION_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
            return attributionSourceRef.get()
        }

        private fun assumeNotTv() = assumeFalse(isTv)
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testTrustedAccessCallLogAttributeToAnother"	"CtsPermission5TestCases"	"1: user"	"@Throws(Exception::class)
    fun testTrustedAccessCallLogAttributeToAnother() {
        testTrustedAccessAttributeToAnother(CallLog.Calls.CONTENT_URI,
                Manifest.permission.READ_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testTrustedAccessAttributeToAnother(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)
        val beginEndMillis = System.currentTimeMillis()
        SystemUtil.runWithShellPermissionIdentity {
            context.contentResolver.query(uri, null, null, null)!!.close()
        }
        val endTimeMillis = System.currentTimeMillis()

        // Calculate the shellUid to account for running this from a secondary user.
        val shellUid = UserHandle.getUid(Process.myUserHandle().identifier,
            UserHandle.getAppId(Process.SHELL_UID))
        // Since we use adopt the shell permission identity we need to adjust
        // the permission identity to have the shell as the accessor.
        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, AttributionSource(shellUid,
                SHELL_PACKAGE_NAME, context.attributionTag, null,
                context.attributionSource.next),
                /*accessorForeground*/ false, /*receiverForeground*/ false,
                /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 1, /*checkAccessor*/ false,
                /*fromDatasource*/ false)
    }"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"2.3.5  . Security Model"	"9.8.2"	"T-5-2"	"9.8.2/T-5-2"	"tv television not"	"""[9.8.2/T-5-2] MUST not hide the camera indicator for system apps that have visible user interfaces or direct user interaction. <h4 id=""236_developer_tools_and_options_compatibility"" """	""	"android.permission5.cts.RenouncedPermissionsTest.kt"	"testCannotRequestRenouncePermissions"	"CtsPermission5TestCases"	"1: user user"	"(expected = IllegalArgumentException::class)
    fun testCannotRequestRenouncePermissions() {
        val renouncedPermissions = ArraySet<String>()
        renouncedPermissions.add(Manifest.permission.READ_CONTACTS);
        val activity = createActivityWithAttributionSource(AttributionSource(Process.myUid(),
                context.packageName, null, renouncedPermissions, null))

        // Requesting renounced permissions throws
        activity.requestPermissions(arrayOf(Manifest.permission.READ_CONTACTS), 1)
    }

    fun createActivityWithAttributionContext(receiverAttributionSource: AttributionSource?,
            renouncedPermissions: Set<String>? = null) : Activity {
        val contextParams = ContextParams.Builder()
                .setRenouncedPermissions(renouncedPermissions)
                .setNextAttributionSource(receiverAttributionSource)
                .build()
        return createActivityWithContextParams(contextParams)
    }

    fun createActivityWithAttributionSource(attributionSource: AttributionSource) : Activity {
        val mockActivity = Mockito.mock(Activity::class.java)
        `when`(mockActivity.getAttributionSource()).thenReturn(attributionSource)
        return mockActivity
    }

    fun createActivityWithContextParams(contextParams: ContextParams) : Activity {
        val activityReference = AtomicReference<NoOpActivity>()
        instrumentation.runOnMainSync {
            activityReference.set(NoOpActivity())
        }
        val activity = activityReference.get()
        activity.attachBaseContext(context.createContext(contextParams))
        return activity
    }

    companion object {
        private val context: Context
            get () = InstrumentationRegistry.getInstrumentation().getContext()

        private val instrumentation: Instrumentation
            get () = InstrumentationRegistry.getInstrumentation()

        fun getShellAttributionSourceWithRenouncedPermissions() : AttributionSource {
            // Let's cook up an attribution source for the shell with its cooperation
            val renouncedPermissionsSet = ArraySet<String>();
            renouncedPermissionsSet.add(Manifest.permission.READ_CONTACTS)
            renouncedPermissionsSet.add(Manifest.permission.READ_CALENDAR)

            // Calculate the shellUid to account for running this from a secondary user.
            val shellUid = UserHandle.getUid(Process.myUserHandle().identifier,
                UserHandle.getAppId(Process.SHELL_UID))
            var shellAttributionSource = AttributionSource.Builder(shellUid)
                    .setPackageName(""com.android.shell"")
                    .setRenouncedPermissions(renouncedPermissionsSet)
                    .build()

            SystemUtil.runWithShellPermissionIdentity {
                val permissionManager = context.getSystemService(PermissionManager::class.java)!!
                shellAttributionSource = permissionManager.registerAttributionSource(
                        shellAttributionSource)
            }

            return shellAttributionSource
        }
    }
}"	"visible hide direct indicator television <h4 tv 2/T-5-2 interaction user id=236_developer_tools_and_options_compatibility camera interfaces"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RenouncedPermissionsTest.kt"	""	""	""
