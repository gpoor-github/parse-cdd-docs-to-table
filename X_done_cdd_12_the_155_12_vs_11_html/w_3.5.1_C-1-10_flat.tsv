"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testApplicationRestrictionIsRestricted"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testApplicationRestrictionIsRestricted() throws Exception {
        installAppAsUser(DELEGATE_APP_APK, mUserId);
        runDeviceTestsAsUser(DELEGATE_APP_PKG, "".AppRestrictionsIsCallerDelegateHelper"",
            ""testAssertCallerIsNotApplicationRestrictionsManagingPackage"", mUserId);
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".ApplicationRestrictionsIsCallerDelegateHelper"",
            ""testSetApplicationRestrictionsManagingPackageToDelegate"", mUserId);
        runDeviceTestsAsUser(DELEGATE_APP_PKG, "".AppRestrictionsIsCallerDelegateHelper"",
            ""testAssertCallerIsApplicationRestrictionsManagingPackage"", mUserId);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetNearbyAppStreamingPolicy_changesPolicy"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testSetNearbyAppStreamingPolicy_changesPolicy() throws Exception {
        executeDeviceTestMethod(
                "".NearbyAppStreamingPolicyTest"", ""testSetNearbyAppStreamingPolicy_changesPolicy"");
    }

    /**
     * Executes a test class on device. Prior to running, turn off background data usage
     * restrictions, and restore the original restrictions after the test.
     */
    private void executeDeviceTestClassNoRestrictBackground(String className) throws Exception {
        boolean originalRestriction = ensureRestrictBackgroundPolicyOff();
        try {
            executeDeviceTestClass(className);
        } catch (Exception e) {
            throw e;
        } finally {
            // if the test throws exception, still restore the policy
            restoreRestrictBackgroundPolicyTo(originalRestriction);
        }
    }

    protected void executeDeviceTestClass(String className) throws Exception {
        executeDeviceTestMethod(className, /* testName= */ null);
    }

    protected void executeDeviceTestMethod(String className, String testName) throws Exception {
        executeDeviceTestMethod(className, testName, /* params= */ new HashMap<>());
    }

    protected void executeDeviceTestMethod(String className, String testName,
            Map<String, String> params) throws Exception {
        executeDeviceTestMethod(className, testName, mUserId, params);
    }

    protected void executeDeviceTestMethod(String className, String testName, int userId,
            Map<String, String> params) throws Exception {
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, className, testName, userId, params);
    }

    protected void installAppPermissionAppAsUser()
            throws FileNotFoundException, DeviceNotAvailableException {
        installAppAsUser(PERMISSIONS_APP_APK, false, mUserId);
    }

    private void executeSuspendPackageTestMethod(String testName) throws Exception {
        runDeviceTestsAsUser(INTENT_SENDER_PKG, "".SuspendPackageTest"", testName, mUserId);
    }

    private void executeAccountTest(String testName) throws DeviceNotAvailableException {
        runDeviceTestsAsUser(ACCOUNT_MANAGEMENT_PKG, "".AccountManagementTest"",
                testName, mUserId);
        // Send a home intent to dismiss an error dialog.
        String command = ""am start -a android.intent.action.MAIN""
                + "" -c android.intent.category.HOME"";
        CLog.i(""Output for command "" + command + "": "" + getDevice().executeShellCommand(command));
    }

    private void executeAppRestrictionsManagingPackageTest(String testName) throws Exception {
        runDeviceTestsAsUser(DELEGATE_APP_PKG,
                "".AppRestrictionsDelegateTest"", testName, mUserId);
    }

    private void executeDelegationTests(Map<String, DevicePolicyEventWrapper[]> delegationTests,
            boolean positive)
            throws Exception {
        for (Map.Entry<String, DevicePolicyEventWrapper[]> entry : delegationTests.entrySet()) {
            final String delegationTestClass = entry.getKey();
            final DevicePolicyEventWrapper[] expectedMetrics = entry.getValue();
            final DevicePolicyEventLogVerifier.Action testRun = () -> {
                runDeviceTestsAsUser(DELEGATE_APP_PKG, delegationTestClass,
                        positive ? ""testCanAccessApis"" : ""testCannotAccessApis"", mUserId);
            };
            if (expectedMetrics != null && positive) {
                assertMetricsLogged(getDevice(), testRun, expectedMetrics);
            } else {
                testRun.apply();
            }
        }
    }

    private void changeUserRestrictionOrFail(String key, boolean value, int userId)
            throws DeviceNotAvailableException {
        changeUserRestrictionOrFail(key, value, userId, DEVICE_ADMIN_PKG);
    }

    private void changeAccountManagement(String command, String accountType, int userId)
            throws DeviceNotAvailableException {
        changePolicyOrFail(command, ""--es extra-account-type "" + accountType, userId);
    }

    private void changeApplicationRestrictionsManagingPackage(String packageName)
            throws DeviceNotAvailableException {
        String packageNameExtra = (packageName != null)
                ? ""--es extra-package-name "" + packageName : """";
        changePolicyOrFail(""set-app-restrictions-manager"", packageNameExtra, mUserId);
    }

    protected void setDelegatedScopes(String packageName, List<String> scopes)
            throws DeviceNotAvailableException {
        final String packageNameExtra = ""--es extra-package-name "" + packageName;
        String scopesExtra = """";
        if (scopes != null && scopes.size() > 0) {
            scopesExtra = ""--esa extra-scopes-list "" + scopes.get(0);
            for (int i = 1; i < scopes.size(); ++i) {
                scopesExtra += "","" + scopes.get(i);
            }
        }
        final String extras = packageNameExtra + "" "" + scopesExtra;

        changePolicyOrFail(""set-delegated-scopes"", extras, mUserId);
    }

    private void setInstallPackageAppOps(String packageName, boolean allowed, int userId)
            throws DeviceNotAvailableException {
        String command = ""appops set --user "" + userId + "" "" + packageName + "" "" +
                ""REQUEST_INSTALL_PACKAGES ""
                + (allowed ? ""allow"" : ""default"");
        CLog.d(""Output for command "" + command + "": "" + getDevice().executeShellCommand(command));
    }

    private void changePolicyOrFail(String command, String extras, int userId)
            throws DeviceNotAvailableException {
        changePolicyOrFail(command, extras, userId, DEVICE_ADMIN_PKG);
    }

    /**
     * Start SimpleActivity synchronously in a particular user.
     */
    protected void startSimpleActivityAsUser(int userId) throws Exception {
        installAppAsUser(TEST_APP_APK, /* grantPermissions */ true, /* dontKillApp */ true, userId);
        startActivityAsUser(userId, TEST_APP_PKG, TEST_APP_PKG + "".SimpleActivity"");
    }

    protected void setScreenCaptureDisabled(int userId, boolean disabled) throws Exception {
        String testMethodName = disabled
                ? ""testSetScreenCaptureDisabled_true""
                : ""testSetScreenCaptureDisabled_false"";
        executeDeviceTestMethod("".ScreenCaptureDisabledTest"", testMethodName);

        testMethodName = disabled
                ? ""testScreenCaptureImpossible""
                : ""testScreenCapturePossible"";

        startSimpleActivityAsUser(userId);
        executeDeviceTestMethod("".ScreenCaptureDisabledTest"", testMethodName);
        forceStopPackageForUser(TEST_APP_PKG, userId);
    }

    protected void setScreenCaptureDisabled_assist(int userId, boolean disabled) throws Exception {
        // Set the policy.
        String testMethodName = disabled
                ? ""testSetScreenCaptureDisabled_true""
                : ""testSetScreenCaptureDisabled_false"";
        executeDeviceTestMethod("".ScreenCaptureDisabledTest"", testMethodName);
        testMethodName = disabled
                ? ""testScreenCaptureImpossible_assist""
                : ""testScreenCapturePossible_assist"";

        // Check whether the VoiceInteractionService can retrieve the screenshot.
        installAppAsUser(DEVICE_ADMIN_APK, mPrimaryUserId);

        if (userId == mPrimaryUserId) {
            // If testing for user-0, also make sure the existing screen can't be captured.
            runDeviceTestsAsUser(
                    DEVICE_ADMIN_PKG,
                    "".AssistScreenCaptureDisabledTest"",
                    testMethodName,
                    mPrimaryUserId);
        }

        // Make sure the foreground activity is from the target user.
        startSimpleActivityAsUser(userId);

        runDeviceTestsAsUser(
                DEVICE_ADMIN_PKG,
                "".AssistScreenCaptureDisabledTest"",
                testMethodName,
                mPrimaryUserId);
    }

    /**
     * Allows packageName to manage notification policy configuration, which
     * includes toggling zen mode.
     */
    private void allowNotificationPolicyAccess(String packageName, int userId)
            throws DeviceNotAvailableException {
        List<String> enabledPackages = getEnabledNotificationPolicyPackages(userId);
        if (!enabledPackages.contains(packageName)) {
            enabledPackages.add(packageName);
            setEnabledNotificationPolicyPackages(enabledPackages, userId);
        }
    }

    /**
     * Disallows packageName to manage notification policy configuration, which
     * includes toggling zen mode.
     */
    private void disallowNotificationPolicyAccess(String packageName, int userId)
            throws DeviceNotAvailableException {
        List<String> enabledPackages = getEnabledNotificationPolicyPackages(userId);
        if (enabledPackages.contains(packageName)) {
            enabledPackages.remove(packageName);
            setEnabledNotificationPolicyPackages(enabledPackages, userId);
        }
    }

    private void setEnabledNotificationPolicyPackages(List<String> packages, int userId)
            throws DeviceNotAvailableException {
        getDevice().setSetting(userId, ""secure"", ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES,
                String.join("":"", packages));
    }

    private List<String> getEnabledNotificationPolicyPackages(int userId)
            throws DeviceNotAvailableException {
        String settingValue = getDevice().getSetting(userId, ""secure"",
                ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES);
        if (settingValue == null) {
            return new ArrayList<String>();
        }
        return new ArrayList<String>(Arrays.asList(settingValue.split("":|\n"")));
    }

    protected void setVoiceInteractionService(String componentName)
            throws DeviceNotAvailableException {
        getDevice().setSetting(
                mPrimaryUserId, ""secure"", ""voice_interaction_service"", componentName);
        getDevice().setSetting(mPrimaryUserId, ""secure"", ""assist_structure_enabled"", ""1"");
        getDevice().setSetting(mPrimaryUserId, ""secure"", ""assist_screenshot_enabled"", ""1"");
    }

    protected void clearVoiceInteractionService() throws DeviceNotAvailableException {
        getDevice().executeShellCommand(""settings delete secure voice_interaction_service"");
    }

    /**
     * Ensure that restrict background policy is off.
     * Returns the original status of restrict background policy.
     */
    private boolean ensureRestrictBackgroundPolicyOff() throws Exception {
        String restriction = getDevice().executeShellCommand(RESTRICT_BACKGROUND_GET_CMD);
        if (restriction.contains(""enabled"")) {
            getDevice().executeShellCommand(RESTRICT_BACKGROUND_OFF_CMD);
            return true;
        }
        return false;
    }

    private void restoreRestrictBackgroundPolicyTo(boolean restricted) throws Exception {
        getDevice().executeShellCommand(
                restricted ? RESTRICT_BACKGROUND_ON_CMD : RESTRICT_BACKGROUND_OFF_CMD);
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerTest"	"testIsBackgroundRestricted"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	"public void testIsBackgroundRestricted() throws IOException {
        // This instrumentation runs in the target package's uid.
        final Context targetContext = mInstrumentation.getTargetContext();
        final String targetPackage = targetContext.getPackageName();
        final ActivityManager am = targetContext.getSystemService(ActivityManager.class);
        setForcedAppStandby(targetPackage, true);
        assertTrue(am.isBackgroundRestricted());
        setForcedAppStandby(targetPackage, false);
        assertFalse(am.isBackgroundRestricted());
    }"	""	""	"BackgroundRestricted RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerTest"	"finish"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	"public void test/*
 *.
 */
package android.app.cts;

import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;

import static org.junit.Assert.assertArrayEquals;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.ActivityManager.RecentTaskInfo;
import android.app.ActivityManager.RunningAppProcessInfo;
import android.app.ActivityManager.RunningServiceInfo;
import android.app.ActivityManager.RunningTaskInfo;
import android.app.ActivityOptions;
import android.app.HomeVisibilityListener;
import android.app.Instrumentation;
import android.app.Instrumentation.ActivityMonitor;
import android.app.Instrumentation.ActivityResult;
import android.app.PendingIntent;
import android.app.cts.android.app.cts.tools.WatchUidRunner;
import android.app.stubs.ActivityManagerRecentOneActivity;
import android.app.stubs.ActivityManagerRecentTwoActivity;
import android.app.stubs.CommandReceiver;
import android.app.stubs.LocalForegroundService;
import android.app.stubs.MockApplicationActivity;
import android.app.stubs.MockService;
import android.app.stubs.ScreenOnActivity;
import android.app.stubs.TrimMemService;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.pm.ApplicationInfo;
import android.content.pm.ConfigurationInfo;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.os.Binder;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.Message;
import android.os.Messenger;
import android.os.Parcel;
import android.os.RemoteException;
import android.os.SystemClock;
import android.platform.test.annotations.RestrictedBuildTest;
import android.provider.DeviceConfig;
import android.provider.Settings;
import android.server.wm.settings.SettingsSession;
import android.support.test.uiautomator.UiDevice;
import android.test.InstrumentationTestCase;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.Log;
import android.util.Pair;

import androidx.test.filters.LargeTest;

import com.android.compatibility.common.util.AmMonitor;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;
import java.util.function.Supplier;

public class ActivityManagerTest extends InstrumentationTestCase {
    private static final String TAG = ActivityManagerTest.class.getSimpleName();
    private static final String STUB_PACKAGE_NAME = ""android.app.stubs"";
    private static final int WAITFOR_MSEC = 5000;
    private static final String SERVICE_NAME = ""android.app.stubs.MockService"";
    private static final int WAIT_TIME = 2000;
    // A secondary test activity from another APK.
    static final String SIMPLE_PACKAGE_NAME = ""com.android.cts.launcherapps.simpleapp"";
    static final String SIMPLE_ACTIVITY = "".SimpleActivity"";
    static final String SIMPLE_ACTIVITY_IMMEDIATE_EXIT = "".SimpleActivityImmediateExit"";
    static final String SIMPLE_ACTIVITY_CHAIN_EXIT = "".SimpleActivityChainExit"";
    static final String SIMPLE_RECEIVER = "".SimpleReceiver"";
    static final String SIMPLE_REMOTE_RECEIVER = "".SimpleRemoteReceiver"";
    // The action sent back by the SIMPLE_APP after a restart.
    private static final String ACTIVITY_LAUNCHED_ACTION =
            ""com.android.cts.launchertests.LauncherAppsTests.LAUNCHED_ACTION"";
    // The action sent back by the SIMPLE_APP_IMMEDIATE_EXIT when it terminates.
    private static final String ACTIVITY_EXIT_ACTION =
            ""com.android.cts.launchertests.LauncherAppsTests.EXIT_ACTION"";
    // The action sent back by the SIMPLE_APP_CHAIN_EXIT when the task chain ends. 
    private static final String ACTIVITY_CHAIN_EXIT_ACTION =
            ""com.android.cts.launchertests.LauncherAppsTests.CHAIN_EXIT_ACTION"";
    // The action sent to identify the time track info.
    private static final String ACTIVITY_TIME_TRACK_INFO = ""com.android.cts.TIME_TRACK_INFO"";

    private static final String PACKAGE_NAME_APP1 = ""com.android.app1"";
    private static final String PACKAGE_NAME_APP2 = ""com.android.app2"";
    private static final String PACKAGE_NAME_APP3 = ""com.android.app3"";

    private static final String CANT_SAVE_STATE_1_PACKAGE_NAME = ""com.android.test.cantsavestate1"";
    private static final String ACTION_FINISH = ""com.android.test.action.FINISH"";

    private static final String MCC_TO_UPDATE = ""987"";
    private static final String MNC_TO_UPDATE = ""654"";
    private static final String SHELL_COMMAND_GET_CONFIG = ""am get-config"";
    private static final String SHELL_COMMAND_RESULT_CONFIG_NAME_MCC = ""mcc"";
    private static final String SHELL_COMMAND_RESULT_CONFIG_NAME_MNC = ""mnc"";

    // Return states of the ActivityReceiverFilter.
    public static final int RESULT_PASS = 1;
    public static final int RESULT_FAIL = 2;
    public static final int RESULT_TIMEOUT = 3;

    private Context mTargetContext;
    private ActivityManager mActivityManager;
    private PackageManager mPackageManager;
    private Intent mIntent;
    private List<Activity> mStartedActivityList;
    private int mErrorProcessID;
    private Instrumentation mInstrumentation;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mInstrumentation = getInstrumentation();
        mTargetContext = mInstrumentation.getTargetContext();
        mActivityManager = (ActivityManager) mInstrumentation.getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);
        mPackageManager = mInstrumentation.getContext().getPackageManager();
        mStartedActivityList = new ArrayList<Activity>();
        mErrorProcessID = -1;
        startSubActivity(ScreenOnActivity.class);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        if (mIntent != null) {
            mInstrumentation.getContext().stopService(mIntent);
        }
        for (int i = 0; i < mStartedActivityList.size(); i++) {
            mStartedActivityList.get(i).finish();
        }
        if (mErrorProcessID != -1) {
            android.os.Process.killProcess(mErrorProcessID);
        }
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerTest"	"testIsUserAMonkey"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	"public void testIsUserAMonkey() {
        assertFalse(ActivityManager.isUserAMonkey());
    }

    /**
     * Verify that {@link ActivityManager#isRunningInTestHarness()} is false.
     */
    @RestrictedBuildTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.lib.DeviceUtils"	"CollectingTestListener"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/lib/DeviceUtils.java"	""	"public void test/*
 *.
 */

package android.cts.statsdatom.lib;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.service.battery.BatteryServiceDumpProto;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.ddmlib.testrunner.TestResult.TestStatus;
import com.android.internal.os.StatsdConfigProto.StatsdConfig;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.CollectingByteOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.result.CollectingTestListener;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.result.TestResult;
import com.android.tradefed.result.TestRunResult;
import com.android.tradefed.util.Pair;

import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.MessageLite;
import com.google.protobuf.Parser;

import java.io.FileNotFoundException;
import java.util.Map;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * Contains utility functions for interacting with the device.
 * Largely copied from incident's ProtoDumpTestCase.
 */
public final class DeviceUtils {
    public static final String STATSD_ATOM_TEST_APK = ""CtsStatsdAtomApp.apk"";
    public static final String STATSD_ATOM_TEST_PKG = ""com.android.server.cts.device.statsdatom"";

    private static final String TEST_RUNNER = ""androidx.test.runner.AndroidJUnitRunner"";

    private static final String KEY_ACTION = ""action"";

    // feature names
    public static final String FEATURE_WATCH = ""android.hardware.type.watch"";

    public static final String DUMP_BATTERY_CMD = ""dumpsys battery"";

    /**
     * Runs device side tests.
     *
     * @param device Can be retrieved by running getDevice() in a class that extends DeviceTestCase
     * @param pkgName Test package name, such as ""com.android.server.cts.statsdatom""
     * @param testClassName Test class name which can either be a fully qualified name or ""."" + a
     *     class name; if null, all test in the package will be run
     * @param testMethodName Test method name; if null, all tests in class or package will be run
     * @return {@link TestRunResult} of this invocation
     * @throws DeviceNotAvailableException
     */
    public static @Nonnull TestRunResult runDeviceTests(ITestDevice device, String pkgName,
            @Nullable String testClassName, @Nullable String testMethodName)
            throws DeviceNotAvailableException {
        if (testClassName != null && testClassName.startsWith(""."")) {
            testClassName = pkgName + testClassName;
        }

        RemoteAndroidTestRunner testRunner = new RemoteAndroidTestRunner(
                pkgName, TEST_RUNNER, device.getIDevice());
        if (testClassName != null && testMethodName != null) {
            testRunner.setMethodName(testClassName, testMethodName);
        } else if (testClassName != null) {
            testRunner.setClassName(testClassName);
        }

        CollectingTestListener listener = new CollectingTestListener();
        assertThat(device.runInstrumentationTests(testRunner, listener)).isTrue();

        final TestRunResult result = listener.getCurrentRunResults();
        if (result.isRunFailure()) {
            throw new Error(""Failed to successfully run device tests for ""
                    + result.getName() + "": "" + result.getRunFailureMessage());
        }
        if (result.getNumTests() == 0) {
            throw new Error(""No tests were run on the device"");
        }
        if (result.hasFailedTests()) {
            StringBuilder errorBuilder = new StringBuilder(""On-device tests failed:\n"");
            for (Map.Entry<TestDescription, TestResult> resultEntry :
                    result.getTestResults().entrySet()) {
                if (!resultEntry.getValue().getStatus().equals(TestStatus.PASSED)) {
                    errorBuilder.append(resultEntry.getKey().toString());
                    errorBuilder.append("":\n"");
                    errorBuilder.append(resultEntry.getValue().getStackTrace());
                }
            }
            throw new AssertionError(errorBuilder.toString());
        }
        return result;
    }

    /**
     * Runs device side tests from the com.android.server.cts.device.statsdatom package.
     */
    public static @Nonnull TestRunResult runDeviceTestsOnStatsdApp(ITestDevice device,
            @Nullable String testClassName, @Nullable String testMethodName)
            throws DeviceNotAvailableException {
        return runDeviceTests(device, STATSD_ATOM_TEST_PKG, testClassName, testMethodName);
    }

    /**
     * Install the statsdatom CTS app to the device.
     */
    public static void installStatsdTestApp(ITestDevice device, IBuildInfo ctsBuildInfo)
            throws FileNotFoundException, DeviceNotAvailableException {
        installTestApp(device, STATSD_ATOM_TEST_APK, STATSD_ATOM_TEST_PKG, ctsBuildInfo);
    }

    /**
     * Install a test app to the device.
     */
    public static void installTestApp(ITestDevice device, String apkName, String pkgName,
            IBuildInfo ctsBuildInfo) throws FileNotFoundException, DeviceNotAvailableException {
        CLog.d(""Installing app "" + apkName);
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(ctsBuildInfo);
        final String result = device.installPackage(
                buildHelper.getTestFile(apkName), /*reinstall=*/true, /*grantPermissions=*/true);
        assertWithMessage(""Failed to install "" + apkName + "": "" + result).that(result).isNull();
        allowBackgroundServices(device, pkgName);
    }

    /**
     * Required to successfully start a background service from adb, starting in O.
     */
    private static void allowBackgroundServices(ITestDevice device, String pkgName)
            throws DeviceNotAvailableException {
        String cmd = ""cmd deviceidle tempwhitelist "" + pkgName;
        device.executeShellCommand(cmd);
    }

    /**
     * Uninstall the statsdatom CTS app from the device.
     */
    public static void uninstallStatsdTestApp(ITestDevice device) throws Exception {
        uninstallTestApp(device, STATSD_ATOM_TEST_PKG);
    }

    /**
     * Uninstall the test app from the device.
     */
    public static void uninstallTestApp(ITestDevice device, String pkgName) throws Exception {
        device.uninstallPackage(pkgName);
    }

    /**
     * Run an adb shell command on device and parse the results as a proto of a given type.
     *
     * @param device Device to run cmd on
     * @param parser Protobuf parser object, which can be retrieved by running MyProto.parser()
     * @param cmd The adb shell command to run (e.g. ""cmd stats update config"")
     *
     * @throws DeviceNotAvailableException
     * @throws InvalidProtocolBufferException Occurs if there was an error parsing the proto. Note
     *     that a 0 length buffer is not necessarily an error.
     * @return Proto of specified type
     */
    public static <T extends MessageLite> T getShellCommandOutput(@Nonnull ITestDevice device,
            Parser<T> parser, String cmd)
            throws DeviceNotAvailableException, InvalidProtocolBufferException {
        final CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();
        device.executeShellCommand(cmd, receiver);
        try {
            return parser.parseFrom(receiver.getOutput());
        } catch (Exception ex) {
            CLog.d(""Error parsing "" + parser.getClass().getCanonicalName() + "" for cmd "" + cmd);
            throw ex;
        }
    }

    /**
     * Returns the UID of the host, which should always either be AID_SHELL (2000) or AID_ROOT (0).
     */
    public static int getHostUid(ITestDevice device) throws DeviceNotAvailableException {
        String uidString = """";
        try {
            uidString = device.executeShellCommand(""id -u"");
            return Integer.parseInt(uidString.trim());
        } catch (NumberFormatException ex) {
            CLog.e(""Failed to get host's uid via shell command. Found "" + uidString);
            // Fall back to alternative method...
            if (device.isAdbRoot()) {
                return 0;
            } else {
                return 2000; // SHELL
            }
        }
    }

    /**
     * Returns the UID of the statsdatom CTS test app.
     */
    public static int getStatsdTestAppUid(ITestDevice device) throws DeviceNotAvailableException {
        return getAppUid(device, STATSD_ATOM_TEST_PKG);
    }

    /**
     * Returns the UID of the test app.
     */
    public static int getAppUid(ITestDevice device, String pkgName)
            throws DeviceNotAvailableException {
        int currentUser = device.getCurrentUser();
        String uidLine = device.executeShellCommand(""cmd package list packages -U --user ""
                + currentUser + "" "" + pkgName);
        String[] uidLineArr = uidLine.split("":"");

        // Package uid is located at index 2.
        assertThat(uidLineArr.length).isGreaterThan(2);
        int appUid = Integer.parseInt(uidLineArr[2].trim());
        assertThat(appUid).isGreaterThan(10000);
        return appUid;
    }

    /**
     * Determines if the device has the given features.
     *
     * @param feature name of the feature (e.g. ""android.hardware.bluetooth"")
     */
    public static boolean hasFeature(ITestDevice device, String feature) throws Exception {
        final String features = device.executeShellCommand(""pm list features"");
        return features.contains(feature);
    }

    /**
     * Runs an activity in a particular app.
     */
    public static void runActivity(ITestDevice device, String pkgName, String activity,
            @Nullable String actionKey, @Nullable String actionValue) throws Exception {
        runActivity(device, pkgName, activity, actionKey, actionValue,
                AtomTestUtils.WAIT_TIME_LONG);
    }

    /**
     * Runs an activity in a particular app for a certain period of time.
     *
     * @param pkgName name of package that contains the Activity
     * @param activity name of the Activity class
     * @param actionKey key of extra data that is passed to the Activity via an Intent
     * @param actionValue value of extra data that is passed to the Activity via an Intent
     * @param waitTimeMs duration that the activity runs for
     */
    public static void runActivity(ITestDevice device, String pkgName, String activity,
            @Nullable String actionKey, @Nullable String actionValue, long waitTimeMs)
            throws Exception {
        try (AutoCloseable a = withActivity(device, pkgName, activity, actionKey, actionValue)) {
            Thread.sleep(waitTimeMs);
        }
    }

    /**
     * Starts the specified activity and returns an {@link AutoCloseable} that stops the activity
     * when closed.
     *
     * <p>Example usage:
     * <pre>
     *     try (AutoClosable a = withActivity(""activity"", ""action"", ""action-value"")) {
     *         doStuff();
     *     }
     * </pre>
     */
    public static AutoCloseable withActivity(ITestDevice device, String pkgName, String activity,
            @Nullable String actionKey, @Nullable String actionValue) throws Exception {
        String intentString;
        if (actionKey != null && actionValue != null) {
            intentString = actionKey + "" "" + actionValue;
        } else {
            intentString = null;
        }

        String cmd = ""am start -n "" + pkgName + ""/."" + activity;
        if (intentString != null) {
            cmd += "" -e "" + intentString;
        }
        device.executeShellCommand(cmd);

        return () -> {
            device.executeShellCommand(""am force-stop "" + pkgName);
            Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);
        };
    }

    public static void setChargingState(ITestDevice device, int state) throws Exception {
        device.executeShellCommand(""cmd battery set status "" + state);
    }

    public static void unplugDevice(ITestDevice device) throws Exception {
        // On batteryless devices on Android P or above, the 'unplug' command
        // alone does not simulate the really unplugged state.
        //
        // This is because charging state is left as ""unknown"". Unless a valid
        // state like 3 = BatteryManager.BATTERY_STATUS_DISCHARGING is set,
        // framework does not consider the device as running on battery.
        setChargingState(device, 3);
        device.executeShellCommand(""cmd battery unplug"");
    }

    public static void plugInAc(ITestDevice device) throws Exception {
        device.executeShellCommand(""cmd battery set ac 1"");
    }

    public static void turnScreenOn(ITestDevice device) throws Exception {
        device.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        device.executeShellCommand(""wm dismiss-keyguard"");
    }

    public static void turnScreenOff(ITestDevice device) throws Exception {
        device.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
    }

    public static void turnBatteryStatsAutoResetOn(ITestDevice device) throws Exception {
        device.executeShellCommand(""dumpsys batterystats enable no-auto-reset"");
    }

    public static void turnBatteryStatsAutoResetOff(ITestDevice device) throws Exception {
        device.executeShellCommand(""dumpsys batterystats enable no-auto-reset"");
    }

    public static void flushBatteryStatsHandlers(ITestDevice device) throws Exception {
        // Dumping batterystats will flush everything in the batterystats handler threads.
        device.executeShellCommand(""dumpsys batterystats"");
    }

    public static boolean hasBattery(ITestDevice device) throws Exception {
        try {
            BatteryServiceDumpProto batteryProto = getShellCommandOutput(device, BatteryServiceDumpProto.parser(),
                    String.join("" "", DUMP_BATTERY_CMD, ""--proto""));
            LogUtil.CLog.d(""Got battery service dump:\n "" + batteryProto.toString());
            return batteryProto.getIsPresent();
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump batteryservice proto"");
            throw (e);
        }
    }

    public static void resetBatteryStatus(ITestDevice device) throws Exception {
        device.executeShellCommand(""cmd battery reset"");
    }

    public static String getProperty(ITestDevice device, String prop) throws Exception {
        return device.executeShellCommand(""getprop "" + prop).replace(""\n"", """");
    }

    public static boolean isDebuggable(ITestDevice device) throws Exception {
        return Integer.parseInt(getProperty(device, ""ro.debuggable"")) == 1;
    }

    public static boolean checkDeviceFor(ITestDevice device, String methodName) throws Exception {
        try {
            runDeviceTestsOnStatsdApp(device, "".Checkers"", methodName);
            // Test passes, meaning that the answer is true.
            LogUtil.CLog.d(methodName + ""() indicates true."");
            return true;
        } catch (AssertionError e) {
            // Method is designed to fail if the answer is false.
            LogUtil.CLog.d(methodName + ""() indicates false."");
            return false;
        }
    }

    /** Make the test app standby-active so it can run syncs and jobs immediately. */
    public static void allowImmediateSyncs(ITestDevice device) throws Exception {
        device.executeShellCommand(""am set-standby-bucket ""
                + DeviceUtils.STATSD_ATOM_TEST_PKG + "" active"");
    }

    /**
     * Runs a (background) service to perform the given action.
     * @param actionValue the action code constants indicating the desired action to perform.
     */
    public static void executeBackgroundService(ITestDevice device, String actionValue)
            throws Exception {
        executeServiceAction(device, ""StatsdCtsBackgroundService"", actionValue);
    }

    /**
     * Runs the specified statsd package service to perform the given action.
     * @param actionValue the action code constants indicating the desired action to perform.
     */
    public static void executeServiceAction(ITestDevice device, String service, String actionValue)
            throws Exception {
        allowBackgroundServices(device);
        device.executeShellCommand(String.format(
                ""am startservice -n '%s/.%s' -e %s %s"",
                STATSD_ATOM_TEST_PKG, service,
                KEY_ACTION, actionValue));
    }

    /**
     * Required to successfully start a background service from adb in Android O.
     */
    private static void allowBackgroundServices(ITestDevice device) throws Exception {
        device.executeShellCommand(String.format(
                ""cmd deviceidle tempwhitelist %s"", STATSD_ATOM_TEST_PKG));
    }

    /**
     * Returns the kernel major version as a pair of ints.
     */
    public static Pair<Integer, Integer> getKernelVersion(ITestDevice device)
            throws Exception {
        String[] version = device.executeShellCommand(""uname -r"").split(""\\."");
        if (version.length < 2) {
              throw new RuntimeException(""Could not parse kernel version"");
        }
        return Pair.create(Integer.parseInt(version[0]), Integer.parseInt(version[1]));
    }

    /** Returns if the device kernel version >= input kernel version. */
    public static boolean isKernelGreaterEqual(ITestDevice device, Pair<Integer, Integer> version)
            throws Exception {
        Pair<Integer, Integer> kernelVersion = getKernelVersion(device);
        return kernelVersion.first > version.first
                || (kernelVersion.first == version.first && kernelVersion.second >= version.second);
    }

    private DeviceUtils() {}
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.media.cts.BaseMultiUserTest"	"listUsers"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/cts/BaseMultiUserTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.ddmlib.testrunner.TestResult.TestStatus;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.result.CollectingTestListener;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.result.TestResult;
import com.android.tradefed.result.TestRunResult;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * Base class for host-side tests for multi-user aware media APIs.
 */
public class BaseMultiUserTest extends BaseMediaHostSideTest {
    private static final String SETTINGS_PACKAGE_VERIFIER_NAMESPACE = ""global"";
    private static final String SETTINGS_PACKAGE_VERIFIER_NAME = ""package_verifier_enable"";

    /**
     * User ID for all users.
     * The value is from the UserHandle class.
     */
    protected static final int USER_ALL = -1;

    /**
     * User ID for the system user.
     * The value is from the UserHandle class.
     */
    protected static final int USER_SYSTEM = 0;

    private String mPackageVerifier;

    private Set<String> mExistingPackages;
    private List<Integer> mExistingUsers;
    private HashSet<String> mAvailableFeatures;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        // Ensure that build has been set before test is run.
        assertNotNull(mCtsBuild);
        mExistingPackages = getDevice().getInstalledPackageNames();

        // Disable the package verifier to avoid the dialog when installing an app
        mPackageVerifier =
                getSettings(
                        SETTINGS_PACKAGE_VERIFIER_NAMESPACE,
                        SETTINGS_PACKAGE_VERIFIER_NAME,
                        USER_ALL);
        putSettings(
                SETTINGS_PACKAGE_VERIFIER_NAMESPACE,
                SETTINGS_PACKAGE_VERIFIER_NAME,
                ""0"",
                USER_ALL);

        mExistingUsers = new ArrayList<>();
        int primaryUserId = getDevice().getPrimaryUserId();
        mExistingUsers.add(primaryUserId);
        mExistingUsers.add(USER_SYSTEM);

        executeShellCommand(""am switch-user "" + primaryUserId);
        executeShellCommand(""wm dismiss-keyguard"");
    }

    @Override
    protected void tearDown() throws Exception {
        // Reset the package verifier setting to its original value.
        putSettings(
                SETTINGS_PACKAGE_VERIFIER_NAMESPACE,
                SETTINGS_PACKAGE_VERIFIER_NAME,
                mPackageVerifier,
                USER_ALL);

        // Remove users created during the test.
        for (int userId : getDevice().listUsers()) {
            if (!mExistingUsers.contains(userId)) {
                removeUser(userId);
            }
        }
        // Remove packages installed during the test.
        for (String packageName : getDevice().getUninstallablePackageNames()) {
            if (mExistingPackages.contains(packageName)) {
                continue;
            }
            CLog.d(""Removing leftover package: "" + packageName);
            getDevice().uninstallPackage(packageName);
        }
        super.tearDown();
    }

    /**
     * Installs the app as if the user of the ID {@param userId} has installed the app.
     *
     * @param appFileName file name of the app.
     * @param userId user ID to install the app against.
     */
    protected void installAppAsUser(String appFileName, int userId, boolean asInstantApp)
            throws FileNotFoundException, DeviceNotAvailableException {
        CLog.d(""Installing app "" + appFileName + "" for user "" + userId);
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        String result = getDevice().installPackageForUser(
                buildHelper.getTestFile(appFileName),
                true,
                true,
                userId,
                ""-t"",
                asInstantApp ? ""--instant"" : """");
        assertNull(""Failed to install "" + appFileName + "" for user "" + userId + "": "" + result,
                result);
    }

    private int createAndStartUser(String extraParam) throws Exception {
        String command = ""pm create-user"" + extraParam + "" TestUser_"" + System.currentTimeMillis();
        String commandOutput = executeShellCommand(command);

        String[] tokens = commandOutput.split(""\\s+"");
        assertTrue(tokens.length > 0);
        assertEquals(""Success:"", tokens[0]);
        int userId = Integer.parseInt(tokens[tokens.length-1]);

        // Start user for MediaSessionService to notice the created user.
        getDevice().startUser(userId);
        return userId;
    }

    /**
     * Creates and starts a new user.
     */
    protected int createAndStartUser() throws Exception {
        return createAndStartUser("""");
    }

    /**
     * Creates and starts a restricted profile for the {@param parentUserId}.
     *
     * @param parentUserId parent user id.
     */
    protected int createAndStartRestrictedProfile(int parentUserId) throws Exception {
        return createAndStartUser("" --profileOf "" + parentUserId + "" --restricted"");
    }

    /**
     * Creates and starts a managed profile for the {@param parentUserId}.
     *
     * @param parentUserId parent user id.
     */
    protected int createAndStartManagedProfile(int parentUserId) throws Exception {
        return createAndStartUser("" --profileOf "" + parentUserId + "" --managed"");
    }

    /**
     * Removes the user that is created during the test.
     * <p>It will be no-op if the user cannot be removed or doesn't exist.
     *
     * @param userId user ID to remove.
     */
    protected void removeUser(int userId) throws Exception  {
        if (getDevice().listUsers().contains(userId) && userId != USER_SYSTEM
                && !mExistingUsers.contains(userId)) {
            getDevice().executeShellCommand(""am wait-for-broadcast-idle"");
            // Don't log output, as tests sometimes set no debug user restriction, which
            // causes this to fail, we should still continue and remove the user.
            String stopUserCommand = ""am stop-user -w -f "" + userId;
            CLog.d(""Stopping and removing user "" + userId);
            getDevice().executeShellCommand(stopUserCommand);
            assertTrue(""Couldn't remove user"", getDevice().removeUser(userId));
        }
    }

    /**
     * Runs tests on the device as if it's {@param userId}.
     *
     * @param pkgName test package file name that contains the {@link AndroidTestCase}
     * @param testClassName Class name to test within the test package. Can be {@code null} if you
     *    want to run all test classes in the package.
     * @param testMethodName Method name to test within the test class. Can be {@code null} if you
     *    want to run all test methods in the class. Will be ignored if {@param testClassName} is
     *    {@code null}.
     * @param userId user ID to run the tests as.
     */
    protected void runDeviceTests(
            String pkgName, @Nullable String testClassName,
            @Nullable String testMethodName, int userId) throws DeviceNotAvailableException {
        RemoteAndroidTestRunner testRunner = getTestRunner(pkgName, testClassName, testMethodName);
        CollectingTestListener listener = new CollectingTestListener();
        assertTrue(getDevice().runInstrumentationTestsAsUser(testRunner, userId, listener));

        final TestRunResult result = listener.getCurrentRunResults();
        assertTestsPassed(result);
    }

    /**
     * Checks whether it is possible to create the desired number of users.
     */
    protected boolean canCreateAdditionalUsers(int numberOfUsers)
            throws DeviceNotAvailableException {
        return getDevice().listUsers().size() + numberOfUsers <=
                getDevice().getMaxNumberOfUsersSupported();
    }

    /**
     * Gets the system setting as a string from the system settings provider for the user.
     *
     * @param namespace namespace of the setting.
     * @param name name of the setting.
     * @param userId user ID to query the setting. Can be {@link #USER_ALL}.
     * @return value of the system setting provider with the given namespace and name.
     *    {@code null}, empty string, or ""null"" will be returned to the empty string ("""") instead.
     */
    protected @Nonnull String getSettings(@Nonnull String namespace, @Nonnull String name,
            int userId) throws Exception {
        String userFlag = (userId == USER_ALL) ? """" : "" --user "" + userId;
        String commandOutput = executeShellCommand(
                ""settings"" + userFlag + "" get "" + namespace + "" "" + name);
        if (commandOutput == null || commandOutput.isEmpty() || commandOutput.equals(""null"")) {
            commandOutput = """";
        }
        return commandOutput;
    }

    /**
     * Puts the string to the system settings provider for the user.
     * <p>This deletes the setting for an empty {@param value} as 'settings put' doesn't allow
     * putting empty value.
     *
     * @param namespace namespace of the setting.
     * @param name name of the setting.
     * @param value value of the system setting provider with the given namespace and name.
     * @param userId user ID to set the setting. Can be {@link #USER_ALL}.
     */
    protected void putSettings(@Nonnull String namespace, @Nonnull String name,
            @Nullable String value, int userId) throws Exception {
        if (value == null || value.isEmpty()) {
            // Delete the setting if the value is null or empty as 'settings put' doesn't accept
            // them.
            // Ignore userId here because 'settings delete' doesn't support it.
            executeShellCommand(""settings delete "" + namespace + "" "" + name);
        } else {
            String userFlag = (userId == USER_ALL) ? """" : "" --user "" + userId;
            executeShellCommand(""settings"" + userFlag + "" put "" + namespace + "" "" + name
                    + "" "" + value);
        }
    }

    protected boolean hasDeviceFeature(String requiredFeature) throws DeviceNotAvailableException {
        if (mAvailableFeatures == null) {
            // TODO: Move this logic to ITestDevice.
            String command = ""pm list features"";
            String commandOutput = getDevice().executeShellCommand(command);
            CLog.i(""Output for command "" + command + "": "" + commandOutput);

            // Extract the id of the new user.
            mAvailableFeatures = new HashSet<>();
            for (String feature : commandOutput.split(""\\s+"")) {
                // Each line in the output of the command has the format ""feature:{FEATURE_VALUE}"".
                String[] tokens = feature.split("":"");
                assertTrue(
                        ""\"""" + feature + ""\"" expected to have format feature:{FEATURE_VALUE}"",
                        tokens.length > 1);
                assertEquals(feature, ""feature"", tokens[0]);
                mAvailableFeatures.add(tokens[1]);
            }
        }
        boolean result = mAvailableFeatures.contains(requiredFeature);
        return result;
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"isStaConcurrencyForRestrictedConnectionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForRestrictedConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSuggestion} which has
 * {@link WifiNetworkSuggestion.Builder#setOemPaid(boolean)} or
 * {@link WifiNetworkSuggestion.Builder#setOemPrivate(boolean)} set along with a concurrent internet
 * connection using {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForRestrictedConnection;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNsNetworkCallback;
    private ScheduledExecutorService mExecutorService;
    private TestHelper mTestHelper;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported or not automotive platform.
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported or not automitve platform.
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"").that(
                mContext.getSystemService(LocationManager.class).isLocationEnabled()).isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"").that(
                matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForRestrictedConnection = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForRestrictedConnection.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNsNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using restricted suggestion API.
     * 3. Verify that both connections are active.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestionWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestionWhenConnectedToInternetNetwork() throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPaid(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using restricted suggestion API.
     * 2. Connect to a network using internet connectivity API.
     * 3. Verify that both connections are active.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToInternetNetworkWhenConnectedToOemPaidSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToInternetNetworkWhenConnectedToOemPaidSuggestion() throws Exception {
        // First trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPaid(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Now trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using restricted suggestion API.
     * 3. Verify that both connections are active.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestionWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestionWhenConnectedToInternetNetwork() throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPrivate(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using restricted suggestion API.
     * 2. Connect to a network using internet connectivity API.
     * 3. Verify that both connections are active.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToInternetNetworkWhenConnectedToOemPrivateSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToInternetNetworkWhenConnectedToOemPrivateSuggestion() throws Exception {
        // First trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPrivate(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Now trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Ensure that there are 2 wifi connections available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(2);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a network using restricted suggestion API & different net
     *    capability (need corresponding net capability requested for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestionFailureWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestionFailureWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPaid(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a network using restricted suggestion API & different net
     *    capability (need corresponding net capability requested for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestionFailureWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestionFailureWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .setOemPrivate(true)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a restricted network using suggestion API & restricted net
     *    capability (need corresponding restricted bit set in suggestion for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToSuggestionFailureWithOemPaidNetCapabilityWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void
            testConnectToSuggestionFailureWithOemPaidNetCapabilityWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Simulate connection failure to a restricted network using suggestion API & restricted net
     *    capability (need corresponding restricted bit set in suggestion for platform to connect).
     * 3. Verify that only 1 connection is active.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"testConnectToSuggestionFailureWithOemPrivateNetCapabilityWhenConnectedToInternetNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"public void
        testConnectToSuggestionFailureWithOemPrivateNetCapabilityWhenConnectedToInternetNetwork()
            throws Exception {
        // First trigger internet connectivity.
        mNetworkCallback = mTestHelper.testConnectionFlowWithConnect(
                mTestNetworkForInternetConnection);

        // Now trigger restricted connection.
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        mTestNetworkForRestrictedConnection)
                        .build();
        mNsNetworkCallback = mTestHelper.testConnectionFailureFlowWithSuggestion(
                mTestNetworkForRestrictedConnection, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PRIVATE));

        // Ensure that there is only 1 connection available for apps.
        assertThat(mTestHelper.getNumWifiConnections()).isEqualTo(1);
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.telephony.cts.ServiceStateTest"	"testNrStateRedacted"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/ServiceStateTest.java"	""	"public void testNrStateRedacted() {
        final TelephonyManager tm = getContext().getSystemService(TelephonyManager.class);

        // Verify that NR State is not leaked in user builds.
        if (!Build.IS_DEBUGGABLE) {
            final String sss = tm.getServiceState().toString();
            // The string leaked in previous releases is ""nrState=<val>""; test that there is
            // no matching or highly similar string leak, such as:
            // nrState=NONE
            // nrState=0
            // mNrState=RESTRICTED
            // NRSTATE=NOT_RESTRICTED
            // nrState = CONNECTED
            // etc.
            Pattern p = Pattern.compile(""nrState\\s*=\\s*[a-zA-Z0-9_]+"", Pattern.CASE_INSENSITIVE);
            Matcher m = p.matcher(sss);
            // Need to use if (find) fail to ensure that the start and end are populated
            if (m.find()) fail(""Found nrState reported as: "" + sss.substring(m.start(), m.end()));
        }
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AccountManagementParentTest"	"testSetAccountManagementDisabledOnParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AccountManagementParentTest.java"	""	"public void testSetAccountManagementDisabledOnParent() {
        DevicePolicyManager parentDevicePolicyManager = getParentInstance();

        parentDevicePolicyManager.setAccountManagementDisabled(ADMIN_RECEIVER_COMPONENT,
                SOME_ACCOUNT_TYPE, true);
        assertThat(
                parentDevicePolicyManager.getAccountTypesWithManagementDisabled()).asList()
                .containsExactly(SOME_ACCOUNT_TYPE);
        // Ensure that account management is not restricted on the managed profile itself.
        assertThat(mDevicePolicyManager.getAccountTypesWithManagementDisabled()).isEmpty();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.metrics.AtomMetricTester"	"getReportList"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/metrics/AtomMetricTester.java"	""	"public void test/*
 *.
 */
package com.android.cts.devicepolicy.metrics;

import static junit.framework.Assert.assertTrue;

import com.android.internal.os.StatsdConfigProto.AtomMatcher;
import com.android.internal.os.StatsdConfigProto.EventMetric;
import com.android.internal.os.StatsdConfigProto.FieldValueMatcher;
import com.android.internal.os.StatsdConfigProto.SimpleAtomMatcher;
import com.android.internal.os.StatsdConfigProto.StatsdConfig;
import com.android.os.AtomsProto.Atom;
import com.android.os.StatsLog.ConfigMetricsReport;
import com.android.os.StatsLog.ConfigMetricsReportList;
import com.android.os.StatsLog.EventMetricData;
import com.android.os.StatsLog.StatsLogReport;
import com.android.tradefed.device.CollectingByteOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.google.common.io.Files;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.MessageLite;
import com.google.protobuf.Parser;
import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Tests Statsd atoms.
 * <p/>
 * Uploads statsd event configs, retrieves logs from host side and validates them
 * against specified criteria.
 */
class AtomMetricTester {
    private static final String UPDATE_CONFIG_CMD = ""cat %s | cmd stats config update %d"";
    private static final String DUMP_REPORT_CMD =
            ""cmd stats dump-report %d --include_current_bucket --proto"";
    private static final String REMOVE_CONFIG_CMD = ""cmd stats config remove %d"";
    /** ID of the config, which evaluates to -1572883457. */
    private static final long CONFIG_ID = ""cts_config"".hashCode();

    private final ITestDevice mDevice;

    AtomMetricTester(ITestDevice device) {
        mDevice = device;
    }

    void cleanLogs() throws Exception {
        removeConfig(CONFIG_ID);
        getReportList(); // Clears data.
    }

    private static StatsdConfig.Builder createConfigBuilder() {
        return StatsdConfig.newBuilder().setId(CONFIG_ID)
                .addAllowedLogSource(""AID_SYSTEM"");
    }

    void createAndUploadConfig(int atomTag) throws Exception {
        StatsdConfig.Builder conf = createConfigBuilder();
        addAtomEvent(conf, atomTag);
        uploadConfig(conf);
    }

    private void uploadConfig(StatsdConfig.Builder config) throws Exception {
        uploadConfig(config.build());
    }

    private void uploadConfig(StatsdConfig config) throws Exception {
        CLog.d(""Uploading the following config:\n"" + config.toString());
        File configFile = File.createTempFile(""statsdconfig"", "".config"");
        configFile.deleteOnExit();
        Files.write(config.toByteArray(), configFile);
        String remotePath = ""/data/local/tmp/"" + configFile.getName();
        mDevice.pushFile(configFile, remotePath);
        mDevice.executeShellCommand(String.format(UPDATE_CONFIG_CMD, remotePath, CONFIG_ID));
        mDevice.executeShellCommand(""rm "" + remotePath);
    }

    private void removeConfig(long configId) throws Exception {
        mDevice.executeShellCommand(String.format(REMOVE_CONFIG_CMD, configId));
    }

    /**
     * Gets the statsd report and sorts it.
     * Note that this also deletes that report from statsd.
     */
    List<EventMetricData> getEventMetricDataList() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        return getEventMetricDataList(reportList);
    }

    /**
     * Extracts and sorts the EventMetricData from the given ConfigMetricsReportList (which must
     * contain a single report).
     */
    private List<EventMetricData> getEventMetricDataList(ConfigMetricsReportList reportList)
            throws Exception {
        assertTrue(""Expected one report"", reportList.getReportsCount() == 1);
        final ConfigMetricsReport report = reportList.getReports(0);
        final List<StatsLogReport> metricsList = report.getMetricsList();
        return metricsList.stream()
                .flatMap(statsLogReport -> statsLogReport.getEventMetrics().getDataList().stream())
                .sorted(Comparator.comparing(EventMetricData::getElapsedTimestampNanos))
                .peek(eventMetricData -> {
                    CLog.d(""Atom at "" + eventMetricData.getElapsedTimestampNanos()
                            + "":\n"" + eventMetricData.getAtom().toString());
                })
                .collect(Collectors.toList());
    }

    /** Gets the statsd report. Note that this also deletes that report from statsd. */
    private ConfigMetricsReportList getReportList() throws Exception {
        try {
            return getDump(ConfigMetricsReportList.parser(),
                    String.format(DUMP_REPORT_CMD, CONFIG_ID));
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            CLog.e(""Failed to fetch and parse the statsd output report. ""
                    + ""Perhaps there is not a valid statsd config for the requested ""
                    + ""uid="" + getHostUid() + "", id="" + CONFIG_ID + ""."");
            throw (e);
        }
    }

    /** Creates a FieldValueMatcher.Builder corresponding to the given field. */
    private static FieldValueMatcher.Builder createFvm(int field) {
        return FieldValueMatcher.newBuilder().setField(field);
    }

    private void addAtomEvent(StatsdConfig.Builder conf, int atomTag) throws Exception {
        addAtomEvent(conf, atomTag, new ArrayList<FieldValueMatcher.Builder>());
    }

    /**
     * Adds an event to the config for an atom that matches the given keys.
     *
     * @param conf   configuration
     * @param atomTag atom tag (from atoms.proto)
     * @param fvms   list of FieldValueMatcher.Builders to attach to the atom. May be null.
     */
    private void addAtomEvent(StatsdConfig.Builder conf, int atomTag,
            List<FieldValueMatcher.Builder> fvms) throws Exception {

        final String atomName = ""Atom"" + System.nanoTime();
        final String eventName = ""Event"" + System.nanoTime();

        SimpleAtomMatcher.Builder sam = SimpleAtomMatcher.newBuilder().setAtomId(atomTag);
        if (fvms != null) {
            for (FieldValueMatcher.Builder fvm : fvms) {
                sam.addFieldValueMatcher(fvm);
            }
        }
        conf.addAtomMatcher(AtomMatcher.newBuilder()
                .setId(atomName.hashCode())
                .setSimpleAtomMatcher(sam));
        conf.addEventMetric(EventMetric.newBuilder()
                .setId(eventName.hashCode())
                .setWhat(atomName.hashCode()));
    }

    /**
     * Removes all elements from data prior to the first occurrence of an element for which
     * the <code>atomMatcher</code> predicate returns <code>true</code>.
     * After this method is called, the first element of data (if non-empty) is guaranteed to be
     * an element in state.
     *
     * @param atomMatcher predicate that takes an Atom and returns <code>true</code> if it
     * fits criteria.
     */
    static void dropWhileNot(List<EventMetricData> metricData, Predicate<Atom> atomMatcher) {
        int firstStateIdx;
        for (firstStateIdx = 0; firstStateIdx < metricData.size(); firstStateIdx++) {
            final Atom atom = metricData.get(firstStateIdx).getAtom();
            if (atomMatcher.test(atom)) {
                break;
            }
        }
        if (firstStateIdx == 0) {
            // First first element already is in state, so there's nothing to do.
            return;
        }
        metricData.subList(0, firstStateIdx).clear();
    }

    /** Returns the UID of the host, which should always either be SHELL (2000) or ROOT (0). */
    private int getHostUid() throws DeviceNotAvailableException {
        String strUid = """";
        try {
            strUid = mDevice.executeShellCommand(""id -u"");
            return Integer.parseInt(strUid.trim());
        } catch (NumberFormatException e) {
            CLog.e(""Failed to get host's uid via shell command. Found "" + strUid);
            // Fall back to alternative method...
            if (mDevice.isAdbRoot()) {
                return 0; // ROOT
            } else {
                return 2000; // SHELL
            }
        }
    }

    /**
     * Execute a shell command on device and get the results of
     * that as a proto of the given type.
     *
     * @param parser A protobuf parser object. e.g. MyProto.parser()
     * @param command The adb shell command to run. e.g. ""dumpsys fingerprint --proto""
     *
     * @throws DeviceNotAvailableException If there was a problem communicating with
     *      the test device.
     * @throws InvalidProtocolBufferException If there was an error parsing
     *      the proto. Note that a 0 length buffer is not necessarily an error.
     */
    private <T extends MessageLite> T getDump(Parser<T> parser, String command)
            throws DeviceNotAvailableException, InvalidProtocolBufferException {
        final CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();
        mDevice.executeShellCommand(command, receiver);
        return parser.parseFrom(receiver.getOutput());
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"isDeviceIdleMode"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"Api
    private static final String SCREEN_OFF_TIMEOUT = ""screen_off_timeout"";

    enum Bucket {
        ACTIVE,
        WORKING_SET,
        FREQUENT,
        RARE,
        RESTRICTED,
        NEVER
    }

    private Context mContext;
    private UiDevice mUiDevice;
    private PowerManager mPowerManager;
    private int mTestJobId;
    private int mTestPackageUid;
    private boolean mDeviceInDoze;
    private boolean mDeviceIdleEnabled;
    private boolean mAppStandbyEnabled;
    private WifiManager mWifiManager;
    private ConnectivityManager mCm;
    /** Whether the device running these tests supports WiFi. */
    private boolean mHasWifi;
    /** Track whether WiFi was enabled in case we turn it off. */
    private boolean mInitialWiFiState;
    private boolean mInitialAirplaneModeState;
    private String mInitialDisplayTimeout;
    private String mInitialRestrictedBucketEnabled;
    private boolean mAutomotiveDevice;
    private boolean mLeanbackOnly;

    private TestAppInterface mTestAppInterface;
    private DeviceConfigStateHelper mDeviceConfigStateHelper;

    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            Log.d(TAG, ""Received action "" + intent.getAction());
            switch (intent.getAction()) {
                case ACTION_DEVICE_IDLE_MODE_CHANGED:
                case ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED:
                    synchronized (JobThrottlingTest.this) {
                        mDeviceInDoze = mPowerManager.isDeviceIdleMode();
                        Log.d(TAG, ""mDeviceInDoze: "" + mDeviceInDoze);
                    }
                    break;
            }
        }
    };

    private static boolean isDeviceIdleEnabled(UiDevice uiDevice) throws Exception {
        final String output = uiDevice.executeShellCommand(""cmd deviceidle enabled deep"").trim();
        return Integer.parseInt(output) != 0;
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getTargetContext();
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mPowerManager = mContext.getSystemService(PowerManager.class);
        mDeviceInDoze = mPowerManager.isDeviceIdleMode();
        mTestPackageUid = mContext.getPackageManager().getPackageUid(TEST_APP_PACKAGE, 0);
        mTestJobId = (int) (SystemClock.uptimeMillis() / 1000);
        mTestAppInterface = new TestAppInterface(mContext, mTestJobId);
        final IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(ACTION_DEVICE_IDLE_MODE_CHANGED);
        intentFilter.addAction(ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
        mContext.registerReceiver(mReceiver, intentFilter);
        assertFalse(""Test package already in temp whitelist"", isTestAppTempWhitelisted());
        makeTestPackageIdle();
        mDeviceIdleEnabled = isDeviceIdleEnabled(mUiDevice);
        mAppStandbyEnabled = AppStandbyUtils.isAppStandbyEnabled();
        if (mAppStandbyEnabled) {
            setTestPackageStandbyBucket(Bucket.ACTIVE);
        } else {
            Log.w(TAG, ""App standby not enabled on test device"");
        }
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mCm = mContext.getSystemService(ConnectivityManager.class);
        mHasWifi = mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI);
        mInitialWiFiState = mWifiManager.isWifiEnabled();
        mInitialAirplaneModeState = isAirplaneModeOn();
        mInitialRestrictedBucketEnabled = Settings.Global.getString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET);
        // Make sure test jobs can run regardless of bucket.
        mDeviceConfigStateHelper =
                new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_JOB_SCHEDULER);
        mDeviceConfigStateHelper.set(
                new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_JOB_SCHEDULER)
                        .setInt(""min_ready_non_active_jobs_count"", 0).build());
        // Make sure the screen doesn't turn off when the test turns it on.
        mInitialDisplayTimeout =
                Settings.System.getString(mContext.getContentResolver(), SCREEN_OFF_TIMEOUT);
        Settings.System.putString(mContext.getContentResolver(), SCREEN_OFF_TIMEOUT, ""300000"");

        // In automotive device, always-on screen and endless battery charging are assumed.
        mAutomotiveDevice =
                mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
        // In leanback devices, it is assumed that there is no battery.
        mLeanbackOnly =
                mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK_ONLY);
        if (mAutomotiveDevice || mLeanbackOnly) {
            setScreenState(true);
            // TODO(b/159176758): make sure that initial power supply is on.
            BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        }

        // Kill as many things in the background as possible so we avoid LMK interfering with the
        // test.
        mUiDevice.executeShellCommand(""am kill-all"");
    }"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testBackgroundConnectivityJobsThrottled"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testBackgroundConnectivityJobsThrottled() throws Exception {
        if (!mHasWifi) {
            Log.d(TAG, ""Skipping test that requires the device be WiFi enabled."");
            return;
        }
        ensureSavedWifiNetwork(mWifiManager);
        setAirplaneMode(false);
        setWifiState(true, mCm, mWifiManager);
        assumeTrue(""device idle not enabled"", mDeviceIdleEnabled);
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        ThermalUtils.overrideThermalStatus(Temperature.THROTTLING_CRITICAL);
        assertTrue(""Job did not stop on thermal throttling"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        Thread.sleep(TestJobSchedulerReceiver.JOB_INITIAL_BACKOFF);
        ThermalUtils.overrideThermalNotThrottling();
        runJob();
        assertTrue(""Job did not start back from throttling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
    }

    /** Tests that apps in the RESTRICTED bucket still get their one parole session per day. */"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInRestrictedBucket_ParoleSession"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInRestrictedBucket_ParoleSession() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        setRestrictedBucketEnabled(true);

        // Disable coalescing
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");

        setScreenState(true);

        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.RESTRICTED);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        sendScheduleJobBroadcast(false);
        runJob();
        assertTrue(""Parole job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(3_000));

        sendScheduleJobBroadcast(false);
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));
    }

    /**
     * Tests that apps in the RESTRICTED bucket have their parole sessions properly counted even
     * when charging (but not idle).
     */"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInRestrictedBucket_CorrectParoleWhileCharging"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInRestrictedBucket_CorrectParoleWhileCharging() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        setRestrictedBucketEnabled(true);

        // Disable coalescing
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""1"");

        setScreenState(true);
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        BatteryUtils.runDumpsysBatterySetLevel(100);

        setTestPackageStandbyBucket(Bucket.RESTRICTED);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        sendScheduleJobBroadcast(false);
        runJob();
        assertTrue(""Parole job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(3_000));

        sendScheduleJobBroadcast(false);
        assertFalse(""New job started in RESTRICTED bucket after parole used"",
                mTestAppInterface.awaitJobStart(3_000));
    }

    /**
     * Tests that apps in the RESTRICTED bucket that have used their one parole session per day
     * don't get to run again until the device is charging + idle.
     */"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInRestrictedBucket_DeferredUntilFreeResources"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInRestrictedBucket_DeferredUntilFreeResources() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        setRestrictedBucketEnabled(true);

        // Disable coalescing
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");

        setScreenState(true);

        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.RESTRICTED);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        sendScheduleJobBroadcast(false);
        runJob();
        assertTrue(""Parole job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(3_000));

        sendScheduleJobBroadcast(false);
        assertFalse(""New job started in RESTRICTED bucket after parole used"",
                mTestAppInterface.awaitJobStart(3_000));

        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        BatteryUtils.runDumpsysBatterySetLevel(100);
        assertFalse(""New job started in RESTRICTED bucket after parole when charging but not idle"",
                mTestAppInterface.awaitJobStart(3_000));

        setScreenState(false);
        triggerJobIdle();
        assertTrue(""Job didn't start in RESTRICTED bucket when charging + idle"",
                mTestAppInterface.awaitJobStart(3_000));

        // Make sure job can be stopped and started again when charging + idle
        sendScheduleJobBroadcast(false);
        assertTrue(""Job didn't restart in RESTRICTED bucket when charging + idle"",
                mTestAppInterface.awaitJobStart(3_000));
    }"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInRestrictedBucket_NoRequiredNetwork"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInRestrictedBucket_NoRequiredNetwork() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        setRestrictedBucketEnabled(true);

        // Disable coalescing and the parole session
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");

        setAirplaneMode(true);
        setScreenState(true);

        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.RESTRICTED);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_NONE, false);
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));

        // Slowly add back required bucket constraints.

        // Battery charging and high.
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));
        BatteryUtils.runDumpsysBatterySetLevel(100);
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));

        // Device is idle.
        setScreenState(false);
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));
        triggerJobIdle();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(3_000));
    }

    @RequiresDevice // Emulators don't always have access to wifi/network"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInRestrictedBucket_WithRequiredNetwork"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInRestrictedBucket_WithRequiredNetwork() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        assumeTrue(mHasWifi);
        ensureSavedWifiNetwork(mWifiManager);

        setRestrictedBucketEnabled(true);

        // Disable coalescing and the parole session
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");

        setAirplaneMode(true);
        setScreenState(true);

        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.RESTRICTED);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));

        // Slowly add back required bucket constraints.

        // Battery charging and high.
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        runJob();
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));
        BatteryUtils.runDumpsysBatterySetLevel(100);
        runJob();
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));

        // Device is idle.
        setScreenState(false);
        runJob();
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));
        triggerJobIdle();
        runJob();
        assertFalse(""New job started in RESTRICTED bucket"", mTestAppInterface.awaitJobStart(3_000));

        // Add network
        setAirplaneMode(false);
        setWifiState(true, mCm, mWifiManager);
        setWifiMeteredState(false);
        runJob();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(5_000));
    }"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobsInNeverApp"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobsInNeverApp() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.NEVER);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        sendScheduleJobBroadcast(false);
        assertFalse(""New job started in NEVER bucket"", mTestAppInterface.awaitJobStart(3_000));
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testUidActiveBypassesStandby"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testUidActiveBypassesStandby() throws Exception {
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.NEVER);
        tempWhitelistTestApp(6_000);
        Thread.sleep(DEFAULT_WAIT_TIMEOUT);
        sendScheduleJobBroadcast(false);
        assertTrue(""New job in uid-active app failed to start in NEVER standby"",
                mTestAppInterface.awaitJobStart(4_000));
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictingStopReason_RestrictedBucket"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictingStopReason_RestrictedBucket() throws Exception {
        assumeTrue(""app standby not enabled"", mAppStandbyEnabled);
        assumeFalse(""not testable in automotive device"", mAutomotiveDevice);
        assumeFalse(""not testable in leanback device"", mLeanbackOnly);

        assumeTrue(mHasWifi);
        ensureSavedWifiNetwork(mWifiManager);

        setRestrictedBucketEnabled(true);
        setTestPackageStandbyBucket(Bucket.RESTRICTED);

        // Disable coalescing and the parole session
        mDeviceConfigStateHelper.set(""qc_timing_session_coalescing_duration_ms"", ""0"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");

        // Satisfy all additional constraints.
        setAirplaneMode(false);
        setWifiState(true, mCm, mWifiManager);
        setWifiMeteredState(false);
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        BatteryUtils.runDumpsysBatterySetLevel(100);
        setScreenState(false);
        triggerJobIdle();

        // Toggle individual constraints

        // Connectivity
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setAirplaneMode(true);
        assertTrue(""New job didn't stop when connectivity dropped"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_CONSTRAINT_CONNECTIVITY,
                mTestAppInterface.getLastParams().getStopReason());
        setAirplaneMode(false);
        setWifiState(true, mCm, mWifiManager);

        // Idle
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setScreenState(true);
        assertTrue(""New job didn't stop when device no longer idle"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_APP_STANDBY,
                mTestAppInterface.getLastParams().getStopReason());
        setScreenState(false);
        triggerJobIdle();

        // Charging
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        BatteryUtils.runDumpsysBatteryUnplug();
        assertTrue(""New job didn't stop when device no longer charging"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_APP_STANDBY,
                mTestAppInterface.getLastParams().getStopReason());
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        BatteryUtils.runDumpsysBatterySetLevel(100);

        // Battery not low
        setScreenState(false);
        triggerJobIdle();
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_ANY, false);
        runJob();
        assertTrue(""New job didn't start in RESTRICTED bucket"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        BatteryUtils.runDumpsysBatterySetLevel(1);
        assertTrue(""New job didn't stop when battery too low"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_APP_STANDBY,
                mTestAppInterface.getLastParams().getStopReason());
    }"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictingStopReason_Quota"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictingStopReason_Quota() throws Exception {
        // Reduce allowed time for testing.
        mDeviceConfigStateHelper.set(""qc_allowed_time_per_period_ms"", ""60000"");
        BatteryUtils.runDumpsysBatteryUnplug();
        setTestPackageStandbyBucket(Bucket.RARE);

        sendScheduleJobBroadcast(false);
        runJob();
        assertTrue(""New job didn't start"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        Thread.sleep(60000);

        assertTrue(""New job didn't stop after using up quota"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_QUOTA,
                mTestAppInterface.getLastParams().getStopReason());
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictingStopReason_Doze"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictingStopReason_Doze() throws Exception {
        assumeTrue(""device idle not enabled"", mDeviceIdleEnabled);

        toggleDozeState(false);
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_NONE, false);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        toggleDozeState(true);
        assertTrue(""Job did not stop on entering doze"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_DEVICE_STATE,
                mTestAppInterface.getLastParams().getStopReason());
    }

    @After
    public void tearDown() throws Exception {
        AppOpsUtils.reset(TEST_APP_PACKAGE);
        // Lock thermal service to not throttling
        ThermalUtils.overrideThermalNotThrottling();
        if (mDeviceIdleEnabled) {
            toggleDozeState(false);
        }
        mTestAppInterface.cleanup();
        BatteryUtils.runDumpsysBatteryReset();
        BatteryUtils.enableBatterySaver(false);
        removeTestAppFromTempWhitelist();

        // Ensure that we leave WiFi in its previous state.
        if (mHasWifi && mWifiManager.isWifiEnabled() != mInitialWiFiState) {
            try {
                setWifiState(mInitialWiFiState, mCm, mWifiManager);
            } catch (AssertionFailedError e) {
                // Don't fail the test just because wifi state wasn't set in tearDown.
                Log.e(TAG, ""Failed to return wifi state to "" + mInitialWiFiState, e);
            }
        }
        mDeviceConfigStateHelper.restoreOriginalValues();
        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, mInitialRestrictedBucketEnabled);
        if (isAirplaneModeOn() != mInitialAirplaneModeState) {
            setAirplaneMode(mInitialAirplaneModeState);
        }
        mUiDevice.executeShellCommand(
                ""cmd jobscheduler reset-execution-quota -u "" + UserHandle.myUserId()
                        + "" "" + TEST_APP_PACKAGE);

        Settings.System.putString(
                mContext.getContentResolver(), SCREEN_OFF_TIMEOUT, mInitialDisplayTimeout);
    }

    private void setTestPackageRestricted(boolean restricted) throws Exception {
        AppOpsUtils.setOpMode(TEST_APP_PACKAGE, ""RUN_ANY_IN_BACKGROUND"",
                restricted ? AppOpsManager.MODE_IGNORED : AppOpsManager.MODE_ALLOWED);
    }

    private void setRestrictedBucketEnabled(boolean enabled) {
        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, enabled ? ""1"" : ""0"");
    }

    private boolean isTestAppTempWhitelisted() throws Exception {
        final String output = mUiDevice.executeShellCommand(""cmd deviceidle tempwhitelist"").trim();
        for (String line : output.split(""\n"")) {
            if (line.contains(""UID="" + mTestPackageUid)) {
                return true;
            }
        }
        return false;
    }

    private void sendScheduleJobBroadcast(boolean allowWhileIdle) throws Exception {
        mTestAppInterface.scheduleJob(allowWhileIdle, NETWORK_TYPE_NONE, false);
    }

    private void toggleDozeState(final boolean idle) throws Exception {
        mUiDevice.executeShellCommand(""cmd deviceidle "" + (idle ? ""force-idle"" : ""unforce""));
        if (!idle) {
            // Make sure the device doesn't stay idle, even after unforcing.
            mUiDevice.executeShellCommand(""cmd deviceidle motion"");
        }
        assertTrue(""Could not change device idle state to "" + idle,
                waitUntilTrue(SHELL_TIMEOUT, () -> {
                    synchronized (JobThrottlingTest.this) {
                        return mDeviceInDoze == idle;
                    }
                }));
    }

    private void tempWhitelistTestApp(long duration) throws Exception {
        mUiDevice.executeShellCommand(""cmd deviceidle tempwhitelist -d "" + duration
                + "" "" + TEST_APP_PACKAGE);
    }

    private void makeTestPackageIdle() throws Exception {
        mUiDevice.executeShellCommand(""am make-uid-idle --user current "" + TEST_APP_PACKAGE);
    }

    void setTestPackageStandbyBucket(Bucket bucket) throws Exception {
        setTestPackageStandbyBucket(mUiDevice, bucket);
    }

    static void setTestPackageStandbyBucket(UiDevice uiDevice, Bucket bucket) throws Exception {
        final String bucketName;
        switch (bucket) {
            case ACTIVE:
                bucketName = ""active"";
                break;
            case WORKING_SET:
                bucketName = ""working"";
                break;
            case FREQUENT:
                bucketName = ""frequent"";
                break;
            case RARE:
                bucketName = ""rare"";
                break;
            case RESTRICTED:
                bucketName = ""restricted"";
                break;
            case NEVER:
                bucketName = ""never"";
                break;
            default:
                throw new IllegalArgumentException(""Requested unknown bucket "" + bucket);
        }
        uiDevice.executeShellCommand(""am set-standby-bucket "" + TEST_APP_PACKAGE
                + "" "" + bucketName);
    }

    private boolean removeTestAppFromTempWhitelist() throws Exception {
        mUiDevice.executeShellCommand(""cmd deviceidle tempwhitelist -r "" + TEST_APP_PACKAGE);
        return waitUntilTrue(SHELL_TIMEOUT, () -> !isTestAppTempWhitelisted());
    }

    /**
     * Set the screen state.
     */
    private void setScreenState(boolean on) throws Exception {
        if (on) {
            mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
            mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        } else {
            mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        }
        // Wait a little bit to make sure the screen state has changed.
        Thread.sleep(2_000);
    }

    /**
     * Trigger job idle (not device idle);
     */
    private void triggerJobIdle() throws Exception {
        mUiDevice.executeShellCommand(""cmd activity idle-maintenance"");
        // Wait a moment to let that happen before proceeding.
        Thread.sleep(2_000);
    }

    /** Asks (not forces) JobScheduler to run the job if constraints are met. */
    private void runJob() throws Exception {
        // Since connectivity is a functional constraint, calling the ""run"" command without force
        // will only get the job to run if the constraint is satisfied.
        mUiDevice.executeShellCommand(""cmd jobscheduler run -s""
                + "" -u "" + UserHandle.myUserId() + "" "" + TEST_APP_PACKAGE + "" "" + mTestJobId);
    }

    private boolean isAirplaneModeOn() throws IOException {
        final String output =
                mUiDevice.executeShellCommand(""cmd connectivity airplane-mode"").trim();
        return ""enabled"".equals(output);
    }

    private void setAirplaneMode(boolean on) throws Exception {
        final CallbackAsserter airplaneModeBroadcastAsserter = CallbackAsserter.forBroadcast(
                new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
        mUiDevice.executeShellCommand(
                ""cmd connectivity airplane-mode "" + (on ? ""enable"" : ""disable""));
        airplaneModeBroadcastAsserter.assertCalled(""Didn't get airplane mode changed broadcast"",
                15 /* 15 seconds */);
        if (!on && mHasWifi) {
            // Force wifi to connect ASAP.
            mUiDevice.executeShellCommand(""svc wifi enable"");
            //noinspection deprecation
            SystemUtil.runWithShellPermissionIdentity(mWifiManager::reconnect,
                    android.Manifest.permission.NETWORK_SETTINGS);
        }
        waitUntil(""Networks didn't change to "" + (!on ? ""on"" : ""off""), 60 /* seconds */,
                () -> {
                    if (on) {
                        return mCm.getActiveNetwork() == null
                                && (!mHasWifi || !isWiFiConnected(mCm, mWifiManager));
                    } else {
                        return mCm.getActiveNetwork() != null;
                    }
                });
        // Wait some time for the network changes to propagate. Can't use
        // waitUntil(isAirplaneModeOn() == on) because the response quickly gives the new
        // airplane mode status even though the network changes haven't propagated all the way to
        // JobScheduler.
        Thread.sleep(5000);
    }

    private static String unquoteSSID(String ssid) {
        // SSID is returned surrounded by quotes if it can be decoded as UTF-8.
        // Otherwise it's guaranteed not to start with a quote.
        if (ssid.charAt(0) == '""') {
            return ssid.substring(1, ssid.length() - 1);
        } else {
            return ssid;
        }
    }

    private String getWifiSSID() {
        final AtomicReference<String> ssid = new AtomicReference<>();
        SystemUtil.runWithShellPermissionIdentity(() -> {
            ssid.set(mWifiManager.getConnectionInfo().getSSID());
        }, Manifest.permission.ACCESS_FINE_LOCATION);
        return unquoteSSID(ssid.get());
    }

    // Returns ""true"", ""false"" or ""none""
    private String getWifiMeteredStatus(String ssid) {
        // Interestingly giving the SSID as an argument to list wifi-networks
        // only works iff the network in question has the ""false"" policy.
        // Also unfortunately runShellCommand does not pass the command to the interpreter
        // so it's not possible to | grep the ssid.
        final String command = ""cmd netpolicy list wifi-networks"";
        final String policyString = SystemUtil.runShellCommand(command);

        final Matcher m = Pattern.compile(""^"" + ssid + "";(true|false|none)$"",
                Pattern.MULTILINE | Pattern.UNIX_LINES).matcher(policyString);
        if (!m.find()) {
            fail(""Unexpected format from cmd netpolicy (when looking for "" + ssid + ""): ""
                    + policyString);
        }
        return m.group(1);
    }

    private void setWifiMeteredState(boolean metered) throws Exception {
        if (metered) {
            // Make sure unmetered cellular networks don't interfere.
            setAirplaneMode(true);
            setWifiState(true, mCm, mWifiManager);
        }
        final String ssid = getWifiSSID();
        setWifiMeteredState(ssid, metered ? ""true"" : ""false"");
    }

    // metered should be ""true"", ""false"" or ""none""
    private void setWifiMeteredState(String ssid, String metered) {
        if (metered.equals(getWifiMeteredStatus(ssid))) {
            return;
        }
        SystemUtil.runShellCommand(""cmd netpolicy set metered-network "" + ssid + "" "" + metered);
        assertEquals(getWifiMeteredStatus(ssid), metered);
    }

    private String getJobState() throws Exception {
        return mUiDevice.executeShellCommand(""cmd jobscheduler get-job-state --user cur ""
                + TEST_APP_PACKAGE + "" "" + mTestJobId).trim();
    }

    private void assertJobWaiting() throws Exception {
        String state = getJobState();
        assertTrue(""Job unexpectedly not waiting, in state: "" + state, state.contains(""waiting""));
    }

    private void assertJobNotReady() throws Exception {
        String state = getJobState();
        assertFalse(""Job unexpectedly ready, in state: "" + state, state.contains(""ready""));
    }

    private void assertJobReady() throws Exception {
        String state = getJobState();
        assertTrue(""Job unexpectedly not ready, in state: "" + state, state.contains(""ready""));
    }

    private boolean waitUntilTrue(long maxWait, Condition condition) throws Exception {
        final long deadLine = SystemClock.uptimeMillis() + maxWait;
        do {
            Thread.sleep(POLL_INTERVAL);
        } while (!condition.isTrue() && SystemClock.uptimeMillis() < deadLine);
        return condition.isTrue();
    }

    private interface Condition {
        boolean isTrue() throws Exception;
    }
}"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testJobStoppedWhenRestricted"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testJobStoppedWhenRestricted() throws Exception {
        sendScheduleJobBroadcast(false);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setTestPackageRestricted(true);
        assertTrue(""Job did not stop after test app was restricted"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_BACKGROUND_RESTRICTION,
                mTestAppInterface.getLastParams().getStopReason());
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictedJobStartedWhenUnrestricted"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictedJobStartedWhenUnrestricted() throws Exception {
        setTestPackageRestricted(true);
        sendScheduleJobBroadcast(false);
        assertFalse(""Job started for restricted app"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setTestPackageRestricted(false);
        assertTrue(""Job did not start when app was unrestricted"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictedJobAllowedWhenUidActive"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictedJobAllowedWhenUidActive() throws Exception {
        setTestPackageRestricted(true);
        sendScheduleJobBroadcast(false);
        assertFalse(""Job started for restricted app"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        // Turn the screen on to ensure the app gets into the TOP state.
        setScreenState(true);
        mTestAppInterface.startAndKeepTestActivity(true);
        assertTrue(""Job did not start when app had an activity"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        mTestAppInterface.closeActivity();
        // Don't put full minute as the timeout to give some leeway with test timing/processing.
        assertFalse(""Job stopped within grace period after activity closed"",
                mTestAppInterface.awaitJobStop(55_000L));
        assertTrue(""Job did not stop after grace period ended"",
                mTestAppInterface.awaitJobStop(15_000L));
        assertEquals(JobParameters.STOP_REASON_BACKGROUND_RESTRICTION,
                mTestAppInterface.getLastParams().getStopReason());
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testEJStoppedWhenRestricted"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testEJStoppedWhenRestricted() throws Exception {
        mTestAppInterface.scheduleJob(false, JobInfo.NETWORK_TYPE_NONE, true);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setTestPackageRestricted(true);
        assertTrue(""Job did not stop after test app was restricted"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_BACKGROUND_RESTRICTION,
                mTestAppInterface.getLastParams().getStopReason());
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictedEJStartedWhenUnrestricted"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictedEJStartedWhenUnrestricted() throws Exception {
        setTestPackageRestricted(true);
        mTestAppInterface.scheduleJob(false, JobInfo.NETWORK_TYPE_NONE, true);
        assertFalse(""Job started for restricted app"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        setTestPackageRestricted(false);
        assertTrue(""Job did not start when app was unrestricted"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictedEJAllowedWhenUidActive"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictedEJAllowedWhenUidActive() throws Exception {
        setTestPackageRestricted(true);
        mTestAppInterface.scheduleJob(false, JobInfo.NETWORK_TYPE_NONE, true);
        assertFalse(""Job started for restricted app"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));
        // Turn the screen on to ensure the app gets into the TOP state.
        setScreenState(true);
        mTestAppInterface.startAndKeepTestActivity(true);
        assertTrue(""Job did not start when app had an activity"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        mTestAppInterface.closeActivity();
        // Don't put full minute as the timeout to give some leeway with test timing/processing.
        assertFalse(""Job stopped within grace period after activity closed"",
                mTestAppInterface.awaitJobStop(55_000L));
        assertTrue(""Job did not stop after grace period ended"",
                mTestAppInterface.awaitJobStop(15_000L));
        assertEquals(JobParameters.STOP_REASON_BACKGROUND_RESTRICTION,
                mTestAppInterface.getLastParams().getStopReason());
    }

    @RequiresDevice // Emulators don't always have access to wifi/network"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService,
                Set.of() /* restrictedNetworkCapability */);
    }

    /**
     * Connect to a network using restricted suggestion API.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPaid(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Connect to a network using restricted suggestion API.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPaidAndOemPrivateSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidAndOemPrivateSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPaid(true)
                        .setOemPrivate(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService,
                Set.of(NET_CAPABILITY_OEM_PAID, NET_CAPABILITY_OEM_PRIVATE));
    }

    /**
     * Connect to a network using restricted suggestion API.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestion() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPrivate(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PRIVATE));
    }

    /**
     * Simulate connection failure to a network using restricted suggestion API & different net
     * capability (need corresponding net capability requested for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPaidSuggestionFailure"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPaidSuggestionFailure() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPaid(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFailureFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PRIVATE));
    }

    /**
     * Simulate connection failure to a network using restricted suggestion API & different net
     * capability (need corresponding net capability requested for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectToOemPrivateSuggestionFailure"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectToOemPrivateSuggestionFailure() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setOemPrivate(true)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFailureFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Simulate connection failure to a restricted network using suggestion API & restricted net
     * capability (need corresponding restricted bit set in suggestion for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testConnectSuggestionFailureWithOemPaidNetCapability"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testConnectSuggestionFailureWithOemPaidNetCapability() throws Exception {
        assertNotNull(sTestNetwork);
        WifiNetworkSuggestion suggestion =
                TestHelper.createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .build();
        sNsNetworkCallback = sTestHelper.testConnectionFailureFlowWithSuggestion(
                sTestNetwork, suggestion, mExecutorService, Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Simulate connection failure to a restricted network using suggestion API & restricted net
     * capability (need corresponding restricted bit set in suggestion for platform to connect).
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.security.cts.FileIntegrityManagerTest"	"testCtsReleaseCertificateTrusted"	"CtsSecurityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/FileIntegrityManagerTest.java"	""	"public void testCtsReleaseCertificateTrusted() throws Exception {
        boolean isReleaseCertTrusted = mFileIntegrityManager.isAppSourceCertificateTrusted(
                readAssetAsX509Certificate(""fsverity-release.x509.der""));
        if (mFileIntegrityManager.isApkVeritySupported()) {
            assertTrue(isReleaseCertTrusted);
        } else {
            assertFalse(isReleaseCertTrusted);
        }
    }

    @CddTest(requirement=""9.10/C-0-3,C-1-1"")
    @RestrictedBuildTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.host.accounts.BaseMultiUserTest"	"listUsers"	"CtsAccountsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/src/android/host/accounts/BaseMultiUserTest.java"	""	"public void test/*
 *
 */
package android.host.accounts;

import static org.junit.Assert.fail;

import com.android.tradefed.device.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.IDeviceTest;

import org.junit.After;
import org.junit.Before;

import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;

/**
 * Base class for multi user tests.
 */
public class BaseMultiUserTest implements IDeviceTest {

    /** Guest flag value from android/content/pm/UserInfo.java */
    private static final int FLAG_GUEST = 0x00000004;

    /**
     * Feature flag for automotive devices
     * https://source.android.com/compatibility/android-cdd#2_5_automotive_requirements
     */
    private static final String FEATURE_AUTOMOTIVE = ""feature:android.hardware.type.automotive"";
    private static final String FEATURE_MANAGED_USERS = ""android.software.managed_users"";

    /** Whether multi-user is supported. */
    protected boolean mSupportsMultiUser;
    protected boolean mSupportsManagedUsers;
    protected int mInitialUserId;
    protected int mPrimaryUserId;

    /** Users we shouldn't delete in the tests. */
    private ArrayList<Integer> mFixedUsers;

    private ITestDevice mDevice;

    @Before
    public void setUp() throws Exception {
        mSupportsMultiUser = getDevice().getMaxNumberOfUsersSupported() > 1;
        mSupportsManagedUsers = getDevice().hasFeature(FEATURE_MANAGED_USERS);

        mInitialUserId = getDevice().getCurrentUser();
        mPrimaryUserId = getDevice().getPrimaryUserId();

        // Test should not modify / remove any of the existing users.
        mFixedUsers = getDevice().listUsers();
    }

    @After
    public void tearDown() throws Exception {
        if (getDevice().getCurrentUser() != mInitialUserId) {
            CLog.w(""User changed during test. Switching back to "" + mInitialUserId);
            getDevice().switchUser(mInitialUserId);
        }
        // Remove the users created during this test.
        removeTestUsers();
    }

    @Override
    public void setDevice(ITestDevice device) {
        mDevice = device;
    }

    @Override
    public ITestDevice getDevice() {
        return mDevice;
    }

    /**
     * @param userId the userId of the parent for this profile
     * @return the userId of the created user
     */
    protected int createRestrictedProfile(int userId)
            throws DeviceNotAvailableException, IllegalStateException {
        return createUser(""--profileOf "" + userId + "" --restricted"");
    }

    /**
     * @param userId the userId of the parent for this profile
     * @return the userId of the created user
     */
    protected int createProfile(int userId)
            throws DeviceNotAvailableException, IllegalStateException {
        return createUser(""--profileOf "" + userId + "" --managed"");
    }

    /**
     * @return the userid of the created user
     */
    protected int createUser()
            throws DeviceNotAvailableException, IllegalStateException {
        return createUser("""");
    }

    private int createUser(String extraParam)
            throws DeviceNotAvailableException, IllegalStateException {
        final String command =
                ""pm create-user "" + extraParam + "" TestUser_"" + System.currentTimeMillis();
        CLog.d(""Starting command: "" + command);
        final String output = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + output);

        if (output.startsWith(""Success"")) {
            try {
                return Integer.parseInt(output.substring(output.lastIndexOf("" "")).trim());
            } catch (NumberFormatException e) {
                CLog.e(""Failed to parse result: %s"", output);
            }
        } else {
            CLog.e(""Failed to create user: %s"", output);
        }
        throw new IllegalStateException();
    }

    protected int createGuestUser() throws Exception {
        return mDevice.createUser(
                ""TestUser_"" + System.currentTimeMillis() /* name */,
                true /* guest */,
                false /* ephemeral */);
    }

    protected int getGuestUser() throws Exception {
        for (int userId : mDevice.listUsers()) {
            if ((mDevice.getUserFlags(userId) & FLAG_GUEST) != 0) {
                return userId;
            }
        }
        return -1;
    }

    protected boolean isAutomotiveDevice() throws Exception {
        return getDevice().hasFeature(FEATURE_AUTOMOTIVE);
    }

    private void removeTestUsers() throws Exception {
        for (int userId : getDevice().listUsers()) {
            if (!mFixedUsers.contains(userId)) {
                getDevice().removeUser(userId);
            }
        }
    }

    protected void waitForBroadcastIdle() throws DeviceNotAvailableException, IOException {
        final CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        // We allow 8min for the command to complete and 4min for the command to start to
        // output something.
        getDevice().executeShellCommand(
                ""am wait-for-broadcast-idle"", receiver, 8, 4, TimeUnit.MINUTES, 0);
        final String output = receiver.getOutput();
        if (!output.contains(""All broadcast queues are idle!"")) {
            CLog.e(""Output from 'am wait-for-broadcast-idle': %s"", output);
            fail(""'am wait-for-broadcase-idle' did not complete."");
        }
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.MeteredDataRestrictionTest"	"testSetMeteredDataDisabledPackages"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/MeteredDataRestrictionTest.java"	""	"public void testSetMeteredDataDisabledPackages() {
        final List<String> restrictedPkgs = new ArrayList<>();
        restrictedPkgs.add(METERED_DATA_APP_PKG);
        final List<String> excludedPkgs = mDevicePolicyManager.setMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT, restrictedPkgs);
        assertTrue(""Packages not restricted: "" + excludedPkgs, excludedPkgs.isEmpty());

        List<String> actualRestrictedPkgs = mDevicePolicyManager.getMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT);
        assertEquals(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                1, actualRestrictedPkgs.size());
        assertTrue(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                actualRestrictedPkgs.contains(METERED_DATA_APP_PKG));
        verifyAppNetworkState(true);

        restrictedPkgs.clear();
        mDevicePolicyManager.setMeteredDataDisabledPackages(ADMIN_RECEIVER_COMPONENT,
                restrictedPkgs);
        actualRestrictedPkgs = mDevicePolicyManager.getMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT);
        assertTrue(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                actualRestrictedPkgs.isEmpty());
        verifyAppNetworkState(false);
    }

    private void verifyAppNetworkState(boolean blocked) {
        final Bundle extras = new Bundle();
        extras.putBinder(EXTRA_MESSENGER, mCallbackMessenger.getBinder());
        mNetworkInfos.clear();
        final Intent launchIntent = new Intent()
                .setClassName(METERED_DATA_APP_PKG, METERED_DATA_APP_MAIN_ACTIVITY)
                .putExtras(extras)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(launchIntent);

        try {
            final NetworkInfo networkInfo = mNetworkInfos.poll(WAIT_FOR_NETWORK_INFO_TIMEOUT_SEC,
                    TimeUnit.SECONDS);
            if (networkInfo == null) {
                fail(""Timed out waiting for the network info"");
            }

            final String expectedState = (blocked ? State.DISCONNECTED : State.CONNECTED).name();
            final String expectedDetailedState = (blocked ? DetailedState.BLOCKED
                    : DetailedState.CONNECTED).name();
            assertEquals(""Wrong state: "" + networkInfo,
                    expectedState, networkInfo.getState().name());
            assertEquals(""Wrong detailed state: "" + networkInfo,
                    expectedDetailedState, networkInfo.getDetailedState().name());
        } catch (InterruptedException e) {
            fail(""Waiting for networkinfo got interrupted: "" + e);
        }
    }

    private class CallbackHandler extends Handler {
        public CallbackHandler() {
            super(Looper.getMainLooper());
        }

        @Override
        public void handleMessage(Message msg) {
            if (msg.what == MSG_NOTIFY_NETWORK_STATE) {
                final NetworkInfo networkInfo = (NetworkInfo) msg.obj;
                if (!mNetworkInfos.offer(networkInfo)) {
                    Log.e(TAG, ""Error while adding networkinfo"");
                }
            } else {
                Log.e(TAG, ""Unknown msg type: "" + msg.what);
            }
        }
    }

    private void setMeteredNetwork() throws Exception {
        final int oldNetId = getActiveNetworkNetId();
        final boolean oldMeteredState = mCm.isActiveNetworkMetered();
        final NetworkInfo networkInfo = mCm.getActiveNetworkInfo();
        Log.d(TAG, ""setMeteredNetwork(): oldNetId="" + oldNetId
                + "", oldMeteredState="" + oldMeteredState + "", activeNetworkInfo="" + networkInfo);
        if (networkInfo == null) {
            fail(""Active network is not available"");
        } else if (networkInfo.getType() != ConnectivityManager.TYPE_WIFI) {
            fail(""Active network doesn't support setting metered status: "" + networkInfo);
        }
        final String ssid = setWifiMeteredStatus(true);

        // Set flag so status is reverted on resetMeteredNetwork();
        mMeteredWifi = ssid;

        // When transitioning from unmetered to metered, the network stack will discconect
        // the current WiFi connection and reconnect it. In this case we need to wait for
        // the new network to come up.
        if (!oldMeteredState) {
            waitForReconnection(oldNetId);
        }
        assertWifiMeteredStatus(ssid, true);
        assertActiveNetworkMetered(true);
    }

    private void resetMeteredNetwork() throws Exception {
        if (mMeteredWifi != null) {
            Log.i(TAG, ""Resetting metered status for netId="" + mMeteredWifi);
            setWifiMeteredStatus(mMeteredWifi, /* metered= */ null);
            assertWifiMeteredStatus(mMeteredWifi, /* metered= */ null);
            assertActiveNetworkMetered(false);
        }
    }

    private String setWifiMeteredStatus(Boolean metered) throws Exception {
        // Must use Shell permissions to get the connection info because on headless system user
        // mode the method would be called by the device owner on system user, which have location
        // disabled (and hence the returned connectionInfo would have the SSID redacted).
        WifiInfo connectionInfo = invokeStaticMethodWithShellPermissions(
                () -> mWm.getConnectionInfo());

        String ssid = connectionInfo.getSSID();
        assertNotNull(""null SSID"", ssid);
        assertNotEquals(""unknown SSID"", WifiManager.UNKNOWN_SSID, ssid);

        final String netId = ssid.trim().replaceAll(""\"""", """"); // remove quotes, if any.
        assertFalse(""empty SSID"", ssid.isEmpty());

        Log.d(TAG, ""setWifiMeteredStatus("" + metered + ""): setting "" + connectionInfo);
        setWifiMeteredStatus(netId, metered);
        return netId;
    }

    private void setWifiMeteredStatus(String ssid, Boolean metered) throws Exception {
        Log.i(TAG, ""Setting wi-fi network "" + ssid + "" metered status to "" + metered);
        executeCmd(""cmd netpolicy set metered-network "" + ssid + "" "" +
                (metered != null ? metered.toString() : ""undefined""));
    }

    private void assertWifiMeteredStatus(String ssid, Boolean metered) throws Exception {
        final String cmd = ""cmd netpolicy list wifi-networks"";
        final String expectedResult = ssid + "";"" + (metered != null ? metered.toString() : ""none"");
        String cmdResult = null;
        for (int i = 0; i < NUM_TRIES_METERED_STATUS_CHECK; ++i) {
            cmdResult = executeCmd(cmd);
            if (cmdResult.contains(expectedResult)) {
                return;
            }
            SystemClock.sleep(INTERVAL_METERED_STATUS_CHECK_MS);
        }
        fail(""Timed out waiting for wifi metered status to change. expected="" + expectedResult
                + "", actual status="" + cmdResult);
    }

    private void assertActiveNetworkMetered(boolean metered) {
        boolean actualMeteredStatus = !metered;
        for (int i = 0; i < NUM_TRIES_METERED_STATUS_CHECK; ++i) {
            actualMeteredStatus = mCm.isActiveNetworkMetered();
            if (actualMeteredStatus == metered) {
                return;
            }
            SystemClock.sleep(INTERVAL_METERED_STATUS_CHECK_MS);
        }
        fail(""Timed out waiting for active network metered status to change. expected=""
                + metered + ""; actual="" + actualMeteredStatus
                + ""; networkInfo="" + mCm.getActiveNetwork());
    }

    private String executeCmd(String cmd) throws Exception {
        final String result = SystemUtil.runShellCommand(getInstrumentation(), cmd);
        Log.i(TAG, ""Cmd '"" + cmd + ""' result: "" + result);
        return result;
    }

    private int getActiveNetworkNetId() {
        Network network = mCm.getActiveNetwork();
        if (network == null) {
            return 0;
        }
        return network.getNetId();
    }

    private void waitForReconnection(int oldNetId) throws InterruptedException {
        long pollingDeadline = System.currentTimeMillis()
                + WAIT_FOR_NETWORK_RECONNECTION_TIMEOUT_SEC * 1000;
        int latestNetId;
        do {
            Thread.sleep(1000);
            if (System.currentTimeMillis() >= pollingDeadline) {
                fail(""Timeout waiting for network reconnection"");
            }
            latestNetId = getActiveNetworkNetId();
            // NetId will be 0 while old network is disconnected but new network
            // has not come up yet.
        } while (latestNetId == 0 || latestNetId == oldNetId);
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.provider.cts.media.MediaStore_Images_MediaTest"	"testGroup"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Images_MediaTest.java"	""	"public void testGroup() throws Exception {
        // Confirm that we have at least two images staged
        ProviderTestUtils.stageMedia(R.raw.scenery, mExternalImages);
        ProviderTestUtils.stageMedia(R.raw.scenery, mExternalImages);

        final Bundle queryArgs = new Bundle();
        queryArgs.putStringArray(ContentResolver.QUERY_ARG_GROUP_COLUMNS,
                new String[] { ImageColumns.BUCKET_ID });

        final HashSet<Integer> seen = new HashSet<>();
        int maxCount = 0;
        try (Cursor c = mContentResolver.query(mExternalImages,
                new String[] { ImageColumns.BUCKET_ID, ""COUNT(_id)"" }, queryArgs, null)) {
            final HashSet<String> honored = new HashSet<>(Arrays
                    .asList(c.getExtras().getStringArray(ContentResolver.EXTRA_HONORED_ARGS)));
            assertTrue(honored.contains(ContentResolver.QUERY_ARG_GROUP_COLUMNS));

            while (c.moveToNext()) {
                final int id = c.getInt(0);
                final int count = c.getInt(1);

                // We should never see the same BUCKET_ID twice
                assertFalse(seen.contains(id));
                seen.add(id);

                maxCount = Math.max(maxCount, count);
            }
        }

        // At least one bucket should have more than one item
        assertTrue(maxCount > 1);
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testCannotControlStorageWhitelistPostInstall1"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	"@AppModeFull
    public void testCannotControlStorageWhitelistPostInstall1() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_28, null /*whitelistedPermissions*/);

        // Check expected state of restricted permissions.
        assertCannotUnWhitelistStorage();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testCannotControlStorageWhitelistPostInstall2"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	"@AppModeFull
    public void testCannotControlStorageWhitelistPostInstall2() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_28, Collections.emptySet());

        // Check expected state of restricted permissions.
        assertCannotWhitelistStorage();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"restrictedWritePermDoesNotImplyIsolatedStorageAccess"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	"@AppModeFull
    public void restrictedWritePermDoesNotImplyIsolatedStorageAccess() throws Exception {
        // Install with whitelisted read permissions.
        installApp(
                APK_USES_STORAGE_OPT_OUT_29,
                Collections.singleton(Manifest.permission.READ_EXTERNAL_STORAGE));

        // It does not matter that write is restricted as the storage access level is only
        // controlled by the read perm
        assertHasFullStorageAccess();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testStorageTargetingSdk30CannotPreserveLegacyOnInstall"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	"@AppModeFull
    public void testStorageTargetingSdk30CannotPreserveLegacyOnInstall() throws Exception {
        installApp(APK_USES_STORAGE_PRESERVED_OPT_OUT_30, null);

        assertHasIsolatedStorageAccess();
    }

    private void assertHasFullStorageAccess() throws Exception {
        runWithShellPermissionIdentity(() -> {
            AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final int uid = getContext().getPackageManager().getPackageUid(PKG, 0);
            eventually(() -> assertThat(appOpsManager.unsafeCheckOpRawNoThrow(
                    AppOpsManager.OPSTR_LEGACY_STORAGE,
                    uid, PKG)).isEqualTo(AppOpsManager.MODE_ALLOWED));
        });
    }

    private void assertHasIsolatedStorageAccess() throws Exception {
        runWithShellPermissionIdentity(() -> {
            AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final int uid = getContext().getPackageManager().getPackageUid(PKG, 0);
            eventually(() -> assertThat(appOpsManager.unsafeCheckOpRawNoThrow(
                    AppOpsManager.OPSTR_LEGACY_STORAGE,
                    uid, PKG)).isNotEqualTo(AppOpsManager.MODE_ALLOWED));
        });
    }

    private void assertCannotWhitelistStorage() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();

        runWithShellPermissionIdentity(() -> {
            // Assert added only to none whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });

        // Assert we cannot add.
        try {
            packageManager.addWhitelistedRestrictedPermission(
                    PKG,
                    permission.READ_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }
        try {
            packageManager.addWhitelistedRestrictedPermission(
                    PKG,
                    permission.WRITE_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }

        runWithShellPermissionIdentity(() -> {
            // Assert added only to none whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });
    }

    private void assertCannotUnWhitelistStorage() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();

        runWithShellPermissionIdentity(() -> {
            // Assert added only to install whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.WRITE_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });

        try {
            // Assert we cannot remove.
            packageManager.removeWhitelistedRestrictedPermission(
                    PKG,
                    permission.READ_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }
        try {
            packageManager.removeWhitelistedRestrictedPermission(
                    PKG,
                    permission.WRITE_EXTERNAL_STORAGE,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            fail();
        } catch (SecurityException expected) {
        }

        runWithShellPermissionIdentity(() -> {
            // Assert added only to install whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .contains(permission.WRITE_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM))
                    .doesNotContain(permission.WRITE_EXTERNAL_STORAGE);
        });
    }

    private @NonNull Set<String> getPermissionsOfAppWithAnyOfFlags(int flags) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final Set<String> restrictedPermissions = new ArraySet<>();
        for (String permission : getRequestedPermissionsOfApp()) {
            PermissionInfo permInfo = packageManager.getPermissionInfo(permission, 0);

            if ((permInfo.flags & flags) != 0) {
                restrictedPermissions.add(permission);
            }
        }
        return restrictedPermissions;
    }

    private @NonNull Set<String> getRestrictedPermissionsOfApp() throws Exception {
        return getPermissionsOfAppWithAnyOfFlags(
                PermissionInfo.FLAG_HARD_RESTRICTED | PermissionInfo.FLAG_SOFT_RESTRICTED);
    }

    private @NonNull String[] getRequestedPermissionsOfApp() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo =
                packageManager.getPackageInfo(PKG, PackageManager.GET_PERMISSIONS);
        return packageInfo.requestedPermissions;
    }

    private static @NonNull Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static void runWithShellPermissionIdentity(@NonNull ThrowingRunnable command)
            throws Exception {
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .adoptShellPermissionIdentity();
        try {
            command.run();
        } finally {
            InstrumentationRegistry.getInstrumentation()
                    .getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }

    /**
     * Install an app.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installApp(
            @NonNull String app,
            @Nullable Set<String> whitelistedPermissions)
            throws Exception {
        // Install the app and whitelist/grant all permission if requested.
        String installResult = runShellCommand(""pm install -r --restrict-permissions "" + app);
        assertThat(installResult.trim()).isEqualTo(""Success"");

        final Set<String> adjustedWhitelistedPermissions;
        if (whitelistedPermissions == null) {
            adjustedWhitelistedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedWhitelistedPermissions = whitelistedPermissions;
        }

        final Set<String> adjustedGrantedPermissions = getRestrictedPermissionsOfApp();

        // Whitelist subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedWhitelistedPermissions) {
                packageManager.addWhitelistedRestrictedPermission(
                        PKG,
                        permission,
                        PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            }
        });

        // Grant subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedGrantedPermissions) {
                packageManager.grantRuntimePermission(PKG, permission, getContext().getUser());
                packageManager.updatePermissionFlags(
                        permission,
                        PKG,
                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT,
                        0,
                        getContext().getUser());
            }
        });

        // Mark all permissions as reviewed as for pre-22 apps the restriction state might not be
        // applied until reviewed
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : getRequestedPermissionsOfApp()) {
                packageManager.updatePermissionFlags(
                        permission,
                        PKG,
                        PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED,
                        0,
                        getContext().getUser());
            }
        });
    }

    @After
    public void uninstallApp() {
        runShellCommand(""pm uninstall "" + PKG);
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.battery.IgnoreBatteryOptimizationsTestActivity"	"getTests"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/battery/IgnoreBatteryOptimizationsTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.battery;

import android.app.usage.UsageStatsManager;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.PowerManager;
import android.provider.Settings;
import android.view.View;

import com.android.cts.verifier.OrderedTestActivity;
import com.android.cts.verifier.R;

/** Test activity to check fulfillment of the ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS intent. */
public class IgnoreBatteryOptimizationsTestActivity extends OrderedTestActivity {
    private PowerManager mPowerManager;
    private UsageStatsManager mUsageStatsManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setInfoResources(R.string.ibo_test, R.string.ibo_test_info, -1);

        mPowerManager = getSystemService(PowerManager.class);
        mUsageStatsManager = getSystemService(UsageStatsManager.class);
    }

    @Override
    protected Test[] getTests() {
        return new Test[]{
                mConfirmNotExemptedAtStart,
                mRequestExemption,
                mIntermediate,
                mConfirmIsExempted,
                mRemoveExemption,
                mIntermediate,
                mConfirmIsNotExempted,
                mOpenAppExemptionListToExempt,
                mIntermediate,
                mConfirmIsExempted,
                mOpenAppExemptionListToUnexempt,
                mIntermediate,
                mConfirmIsNotExempted
        };
    }

    private boolean isExempted() {
        return mPowerManager.isIgnoringBatteryOptimizations(getPackageName())
                && mUsageStatsManager.getAppStandbyBucket()
                == UsageStatsManager.STANDBY_BUCKET_EXEMPTED;
    }

    private boolean isFullyNotExempted() {
        // Use an OR so we check both values to make sure neither of them say the app is exempted.
        if (mPowerManager.isIgnoringBatteryOptimizations(getPackageName())
                || mUsageStatsManager.getAppStandbyBucket()
                == UsageStatsManager.STANDBY_BUCKET_EXEMPTED) {
            return false;
        }
        return true;
    }

    private void openAppInfoPage() {
        Intent appInfoIntent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
        appInfoIntent.setData(Uri.parse(""package:"" + getPackageName()));
        startActivity(appInfoIntent);
    }

    private void openIgnoreBatteryOptimizationsAppList() {
        Intent intent = new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS);
        startActivity(intent);
    }

    private final Test mConfirmNotExemptedAtStart = new Test(R.string.ibo_test_start_unexempt_app) {
        @Override
        protected void run() {
            super.run();

            if (isFullyNotExempted()) {
                succeed();
            }
        }

        @Override
        protected void onNextClick() {
            if (isExempted()) {
                openAppInfoPage();
            } else {
                succeed();
            }
        }
    };

    private final Test mRequestExemption = new Test(R.string.ibo_exempt_app_request) {
        @Override
        protected void onNextClick() {
            Intent request = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);
            request.setData(Uri.parse(""package:"" + getPackageName()));
            startActivity(request);
            succeed();
        }
    };

    private final Test mIntermediate = new Test(R.string.ibo_next_to_confirm) {
        @Override
        protected void onNextClick() {
            succeed();
        }
    };

    private final Test mConfirmIsExempted = new Test(R.string.ibo_app_not_exempted) {
        @Override
        protected void run() {
            super.run();

            if (isExempted()) {
                succeed();
            } else {
                findViewById(R.id.btn_next).setVisibility(View.GONE);
            }
        }
    };

    private final Test mRemoveExemption = new Test(R.string.ibo_unexempt_app) {
        @Override
        protected void run() {
            super.run();

            if (isFullyNotExempted()) {
                succeed();
            }
        }

        @Override
        protected void onNextClick() {
            if (isExempted()) {
                openAppInfoPage();
            } else {
                succeed();
            }
        }
    };

    private final Test mConfirmIsNotExempted = new Test(R.string.ibo_app_is_exempted) {
        @Override
        protected void run() {
            super.run();

            if (isFullyNotExempted()) {
                succeed();
            } else {
                findViewById(R.id.btn_next).setVisibility(View.GONE);
            }
        }
    };

    private final Test mOpenAppExemptionListToExempt = new Test(R.string.ibo_exempt_app_list) {
        @Override
        protected void onNextClick() {
            openIgnoreBatteryOptimizationsAppList();
            succeed();
        }
    };

    private final Test mOpenAppExemptionListToUnexempt = new Test(R.string.ibo_unexempt_app_list) {
        @Override
        protected void onNextClick() {
            openIgnoreBatteryOptimizationsAppList();
            succeed();
        }
    };
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.os.cts.BuildVersionTest"	"testIncremental"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/BuildVersionTest.java"	""	"public void testIncremental() {
        assertNotEmpty(Build.VERSION.INCREMENTAL);
    }

    /**
     * Verifies {@link Build#FINGERPRINT} follows expected format:
     * <p/>
     * <code>
     * (BRAND)/(PRODUCT)/(DEVICE):(VERSION.RELEASE_OR_CODENAME)/(BUILD_ID)/
     * (BUILD_NUMBER):(BUILD_VARIANT)/(TAGS)
     * </code>
     */
    @RestrictedBuildTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.text.style.cts.TextAppearanceSpanTest"	"testRestrictContext"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/style/cts/TextAppearanceSpanTest.java"	""	"public void testRestrictContext() throws PackageManager.NameNotFoundException {
        final Context ctx = mContext.createPackageContext(mContext.getPackageName(),
                Context.CONTEXT_RESTRICTED);
        final TextAppearanceSpan span = new TextAppearanceSpan(ctx,
                android.text.cts.R.style.customFont);
        final TextPaint tp = new TextPaint();
        final float originalTextWidth = tp.measureText(""a"");
        span.updateDrawState(tp);
        // Custom font must not be loaded with the restricted context.
        assertEquals(originalTextWidth, tp.measureText(""a""), 0.0f);

    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.media.cts.VideoEncoderTest"	"isEncoder"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/VideoEncoderTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.media.cts.CodecUtils;

import android.graphics.ImageFormat;
import android.graphics.SurfaceTexture;
import android.media.Image;
import android.media.MediaCodec;
import android.media.MediaCodec.BufferInfo;
import android.media.MediaCodecInfo;
import android.media.MediaCodecInfo.CodecCapabilities;
import android.media.MediaCodecInfo.VideoCapabilities;
import android.media.MediaCodecList;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.media.MediaMuxer;
import android.net.Uri;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.Presubmit;
import android.platform.test.annotations.RequiresDevice;
import android.util.Log;
import android.util.Pair;
import android.util.Range;
import android.util.Size;
import android.view.Surface;

import androidx.test.filters.SmallTest;

import com.android.compatibility.common.util.MediaUtils;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;

@MediaHeavyPresubmitTest
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class VideoEncoderTest extends MediaPlayerTestBase {
    private static final int MAX_SAMPLE_SIZE = 256 * 1024;
    private static final String TAG = ""VideoEncoderTest"";
    private static final long FRAME_TIMEOUT_MS = 1000;
    // use larger delay before we get first frame, some encoders may need more time
    private static final long INIT_TIMEOUT_MS = 2000;

    static final String mInpPrefix = WorkDir.getMediaDirString();
    private static final String SOURCE_URL =
            mInpPrefix + ""video_480x360_mp4_h264_871kbps_30fps.mp4"";

    private final boolean DEBUG = false;

    class VideoStorage {
        private LinkedList<Pair<ByteBuffer, BufferInfo>> mStream;
        private MediaFormat mFormat;
        private int mInputBufferSize;
        // Media buffers(no CSD, no EOS) enqueued.
        private int mMediaBuffersEnqueuedCount;
        // Media buffers decoded.
        private int mMediaBuffersDecodedCount;
        private final AtomicReference<String> errorMsg = new AtomicReference(null);

        public VideoStorage() {
            mStream = new LinkedList<Pair<ByteBuffer, BufferInfo>>();
        }

        public void setFormat(MediaFormat format) {
            mFormat = format;
        }

        public void addBuffer(ByteBuffer buffer, BufferInfo info) {
            ByteBuffer savedBuffer = ByteBuffer.allocate(info.size);
            savedBuffer.put(buffer);
            if (info.size > mInputBufferSize) {
                mInputBufferSize = info.size;
            }
            BufferInfo savedInfo = new BufferInfo();
            savedInfo.set(0, savedBuffer.position(), info.presentationTimeUs, info.flags);
            mStream.addLast(Pair.create(savedBuffer, savedInfo));
            if (info.size > 0 && (info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {
                ++mMediaBuffersEnqueuedCount;
            }
        }

        private void play(MediaCodec decoder, Surface surface) {
            decoder.reset();
            final Object condition = new Object();
            final Iterator<Pair<ByteBuffer, BufferInfo>> it = mStream.iterator();
            decoder.setCallback(new MediaCodec.Callback() {
                public void onOutputBufferAvailable(MediaCodec codec, int ix, BufferInfo info) {
                    if (info.size > 0) {
                        ++mMediaBuffersDecodedCount;
                    }
                    codec.releaseOutputBuffer(ix, info.size > 0);
                    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                        synchronized (condition) {
                            condition.notifyAll();
                        }
                    }
                }
                public void onInputBufferAvailable(MediaCodec codec, int ix) {
                    if (it.hasNext()) {
                        Pair<ByteBuffer, BufferInfo> el = it.next();
                        el.first.clear();
                        try {
                            codec.getInputBuffer(ix).put(el.first);
                        } catch (java.nio.BufferOverflowException e) {
                            Log.e(TAG, ""cannot fit "" + el.first.limit()
                                    + ""-byte encoded buffer into ""
                                    + codec.getInputBuffer(ix).remaining()
                                    + ""-byte input buffer of "" + codec.getName()
                                    + "" configured for "" + codec.getInputFormat());
                            throw e;
                        }
                        BufferInfo info = el.second;
                        codec.queueInputBuffer(
                                ix, 0, info.size, info.presentationTimeUs, info.flags);
                    }
                }
                public void onError(MediaCodec codec, MediaCodec.CodecException e) {
                    Log.i(TAG, ""got codec exception"", e);
                    errorMsg.set(""received codec error during decode"" + e);
                    synchronized (condition) {
                        condition.notifyAll();
                    }
                }
                public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) {
                    Log.i(TAG, ""got output format "" + format);
                }
            });
            mFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, mInputBufferSize);
            decoder.configure(mFormat, surface, null /* crypto */, 0 /* flags */);
            decoder.start();
            synchronized (condition) {
                try {
                    condition.wait();
                } catch (InterruptedException e) {
                    fail(""playback interrupted"");
                }
            }
            decoder.stop();
            assertNull(errorMsg.get(), errorMsg.get());
            // All enqueued media data buffers should have got decoded.
            if (mMediaBuffersEnqueuedCount != mMediaBuffersDecodedCount) {
                Log.i(TAG, ""mMediaBuffersEnqueuedCount:"" + mMediaBuffersEnqueuedCount);
                Log.i(TAG, ""mMediaBuffersDecodedCount:"" + mMediaBuffersDecodedCount);
                fail(""not all enqueued encoded media buffers were decoded"");
            }
            mMediaBuffersDecodedCount = 0;
        }

        public boolean playAll(Surface surface) {
            boolean skipped = true;
            if (mFormat == null) {
                Log.i(TAG, ""no stream to play"");
                return !skipped;
            }
            String mime = mFormat.getString(MediaFormat.KEY_MIME);
            MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
            for (MediaCodecInfo info : mcl.getCodecInfos()) {
                if (info.isEncoder() || info.isAlias()) {
                    continue;
                }
                MediaCodec codec = null;
                try {
                    CodecCapabilities caps = info.getCapabilitiesForType(mime);
                    if (!caps.isFormatSupported(mFormat)) {
                        continue;
                    }
                    codec = MediaCodec.createByCodecName(info.getName());
                } catch (IllegalArgumentException | IOException e) {
                    continue;
                }
                play(codec, surface);
                codec.release();
                skipped = false;
            }
            return !skipped;
        }
    }

    abstract class VideoProcessorBase extends MediaCodec.Callback {
        private static final String TAG = ""VideoProcessorBase"";

        /*
         * Set this to true to save the encoding results to /data/local/tmp
         * You will need to make /data/local/tmp writeable, run ""setenforce 0"",
         * and remove files left from a previous run.
         */
        private boolean mSaveResults = false;
        private static final String FILE_DIR = ""/data/local/tmp"";
        protected int mMuxIndex = -1;

        protected String mProcessorName = ""VideoProcessor"";
        private MediaExtractor mExtractor;
        protected MediaMuxer mMuxer;
        private ByteBuffer mBuffer = ByteBuffer.allocate(MAX_SAMPLE_SIZE);
        protected int mTrackIndex = -1;
        private boolean mSignaledDecoderEOS;

        protected boolean mCompleted;
        protected boolean mEncoderIsActive;
        protected boolean mEncodeOutputFormatUpdated;
        protected final Object mCondition = new Object();
        protected final Object mCodecLock = new Object();

        protected MediaFormat mDecFormat;
        protected MediaCodec mDecoder, mEncoder;

        private VideoStorage mEncodedStream;
        protected int mFrameRate = 0;
        protected int mBitRate = 0;

        protected Function<MediaFormat, Boolean> mUpdateConfigFormatHook;
        protected Function<MediaFormat, Boolean> mCheckOutputFormatHook;

        public void setProcessorName(String name) {
            mProcessorName = name;
        }

        public void setUpdateConfigHook(Function<MediaFormat, Boolean> hook) {
            mUpdateConfigFormatHook = hook;
        }

        public void setCheckOutputFormatHook(Function<MediaFormat, Boolean> hook) {
            mCheckOutputFormatHook = hook;
        }

        protected void open(String path) throws IOException {
            mExtractor = new MediaExtractor();
            if (path.startsWith(""android.resource://"")) {
                mExtractor.setDataSource(mContext, Uri.parse(path), null);
            } else {
                mExtractor.setDataSource(path);
            }

            for (int i = 0; i < mExtractor.getTrackCount(); i++) {
                MediaFormat fmt = mExtractor.getTrackFormat(i);
                String mime = fmt.getString(MediaFormat.KEY_MIME).toLowerCase();
                if (mime.startsWith(""video/"")) {
                    mTrackIndex = i;
                    mDecFormat = fmt;
                    mExtractor.selectTrack(i);
                    break;
                }
            }
            mEncodedStream = new VideoStorage();
            assertTrue(""file "" + path + "" has no video"", mTrackIndex >= 0);
        }

        // returns true if encoder supports the size
        protected boolean initCodecsAndConfigureEncoder(
                String videoEncName, String outMime, int width, int height,
                int colorFormat) throws IOException {
            mDecFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);

            MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
            String videoDecName = mcl.findDecoderForFormat(mDecFormat);
            Log.i(TAG, ""decoder for "" + mDecFormat + "" is "" + videoDecName);
            mDecoder = MediaCodec.createByCodecName(videoDecName);
            mEncoder = MediaCodec.createByCodecName(videoEncName);

            mDecoder.setCallback(this);
            mEncoder.setCallback(this);

            VideoCapabilities encCaps =
                mEncoder.getCodecInfo().getCapabilitiesForType(outMime).getVideoCapabilities();
            if (!encCaps.isSizeSupported(width, height)) {
                Log.i(TAG, videoEncName + "" does not support size: "" + width + ""x"" + height);
                return false;
            }

            MediaFormat outFmt = MediaFormat.createVideoFormat(outMime, width, height);
            int bitRate = 0;
            MediaUtils.setMaxEncoderFrameAndBitrates(encCaps, outFmt, 30);
            if (mFrameRate > 0) {
                outFmt.setInteger(MediaFormat.KEY_FRAME_RATE, mFrameRate);
            }
            if (mBitRate > 0) {
                outFmt.setInteger(MediaFormat.KEY_BIT_RATE, mBitRate);
            }
            outFmt.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1);
            outFmt.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat);
            // Some extra configure before starting the encoder.
            if (mUpdateConfigFormatHook != null) {
                if (!mUpdateConfigFormatHook.apply(outFmt)) {
                    return false;
                }
            }
            mEncoder.configure(outFmt, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
            Log.i(TAG, ""encoder input format "" + mEncoder.getInputFormat() + "" from "" + outFmt);
            if (mSaveResults) {
                try {
                    String outFileName =
                            FILE_DIR + mProcessorName + ""_"" + bitRate + ""bps"";
                    if (outMime.equals(MediaFormat.MIMETYPE_VIDEO_VP8) ||
                            outMime.equals(MediaFormat.MIMETYPE_VIDEO_VP9)) {
                        mMuxer = new MediaMuxer(
                                outFileName + "".webm"", MediaMuxer.OutputFormat.MUXER_OUTPUT_WEBM);
                    } else {
                        mMuxer = new MediaMuxer(
                                outFileName + "".mp4"", MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);
                    }
                    // The track can't be added until we have the codec specific data
                } catch (Exception e) {
                    Log.i(TAG, ""couldn't create muxer: "" + e);
                }
            }
            return true;
        }

        protected void close() {
            synchronized (mCodecLock) {
                if (mDecoder != null) {
                    mDecoder.release();
                    mDecoder = null;
                }
                if (mEncoder != null) {
                    mEncoder.release();
                    mEncoder = null;
                }
            }
            if (mExtractor != null) {
                mExtractor.release();
                mExtractor = null;
            }
            if (mMuxer != null) {
                mMuxer.stop();
                mMuxer.release();
                mMuxer = null;
            }
        }

        // returns true if filled buffer
        protected boolean fillDecoderInputBuffer(int ix) {
            if (DEBUG) Log.v(TAG, ""decoder received input #"" + ix);
            while (!mSignaledDecoderEOS) {
                int track = mExtractor.getSampleTrackIndex();
                if (track >= 0 && track != mTrackIndex) {
                    mExtractor.advance();
                    continue;
                }
                int size = mExtractor.readSampleData(mBuffer, 0);
                if (size < 0) {
                    // queue decoder input EOS
                    if (DEBUG) Log.v(TAG, ""queuing decoder EOS"");
                    mDecoder.queueInputBuffer(
                            ix, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                    mSignaledDecoderEOS = true;
                } else {
                    mBuffer.limit(size);
                    mBuffer.position(0);
                    BufferInfo info = new BufferInfo();
                    info.set(
                            0, mBuffer.limit(), mExtractor.getSampleTime(),
                            mExtractor.getSampleFlags());
                    mDecoder.getInputBuffer(ix).put(mBuffer);
                    if (DEBUG) Log.v(TAG, ""queing input #"" + ix + "" for decoder with timestamp ""
                            + info.presentationTimeUs);
                    mDecoder.queueInputBuffer(
                            ix, 0, mBuffer.limit(), info.presentationTimeUs, 0);
                }
                mExtractor.advance();
                return true;
            }
            return false;
        }

        protected void emptyEncoderOutputBuffer(int ix, BufferInfo info) {
            if (DEBUG) Log.v(TAG, ""encoder received output #"" + ix
                     + "" (sz="" + info.size + "", f="" + info.flags
                     + "", ts="" + info.presentationTimeUs + "")"");
            ByteBuffer outputBuffer = mEncoder.getOutputBuffer(ix);
            mEncodedStream.addBuffer(outputBuffer, info);

            if (mMuxer != null) {
                // reset position as addBuffer() modifies it
                outputBuffer.position(info.offset);
                outputBuffer.limit(info.offset + info.size);
                mMuxer.writeSampleData(mMuxIndex, outputBuffer, info);
            }

            if (!mCompleted) {
                mEncoder.releaseOutputBuffer(ix, false);
                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                    Log.d(TAG, ""encoder received output EOS"");
                    synchronized(mCondition) {
                        mCompleted = true;
                        mCondition.notifyAll(); // condition is always satisfied
                    }
                } else {
                    synchronized(mCondition) {
                        mEncoderIsActive = true;
                    }
                }
            }
        }

        protected void saveEncoderFormat(MediaFormat format) {
            mEncodedStream.setFormat(format);
            if (mCheckOutputFormatHook != null) {
                mCheckOutputFormatHook.apply(format);
            }
            if (mMuxer != null) {
                if (mMuxIndex < 0) {
                    mMuxIndex = mMuxer.addTrack(format);
                    mMuxer.start();
                }
            }
        }

        public boolean playBack(Surface surface) { return mEncodedStream.playAll(surface); }

        public void setFrameAndBitRates(int frameRate, int bitRate) {
            mFrameRate = frameRate;
            mBitRate = bitRate;
        }

        @Override
        public void onInputBufferAvailable(MediaCodec mediaCodec, int ix) {
            synchronized (mCodecLock) {
                if (mEncoder != null && mDecoder != null) {
                    onInputBufferAvailableLocked(mediaCodec, ix);
                }
            }
        }

        @Override
        public void onOutputBufferAvailable(
                MediaCodec mediaCodec, int ix, BufferInfo info) {
            synchronized (mCodecLock) {
                if (mEncoder != null && mDecoder != null) {
                    onOutputBufferAvailableLocked(mediaCodec, ix, info);
                }
            }
        }

        public abstract boolean processLoop(
                String path, String outMime, String videoEncName,
                int width, int height, boolean optional);
        protected abstract void onInputBufferAvailableLocked(
                MediaCodec mediaCodec, int ix);
        protected abstract void onOutputBufferAvailableLocked(
                MediaCodec mediaCodec, int ix, BufferInfo info);
    }

    class VideoProcessor extends VideoProcessorBase {
        private static final String TAG = ""VideoProcessor"";
        private boolean mWorkInProgress;
        private boolean mGotDecoderEOS;
        private boolean mSignaledEncoderEOS;

        private LinkedList<Pair<Integer, BufferInfo>> mBuffersToRender =
            new LinkedList<Pair<Integer, BufferInfo>>();
        private LinkedList<Integer> mEncInputBuffers = new LinkedList<Integer>();

        private int mEncInputBufferSize = -1;
        private final AtomicReference<String> errorMsg = new AtomicReference(null);

        @Override
        public boolean processLoop(
                 String path, String outMime, String videoEncName,
                 int width, int height, boolean optional) {
            boolean skipped = true;
            try {
                open(path);
                if (!initCodecsAndConfigureEncoder(
                        videoEncName, outMime, width, height,
                        CodecCapabilities.COLOR_FormatYUV420Flexible)) {
                    assertTrue(""could not configure encoder for supported size"", optional);
                    return !skipped;
                }
                skipped = false;

                mDecoder.configure(mDecFormat, null /* surface */, null /* crypto */, 0);

                mDecoder.start();
                mEncoder.start();

                // main loop - process GL ops as only main thread has GL context
                while (!mCompleted && errorMsg.get() == null) {
                    Pair<Integer, BufferInfo> decBuffer = null;
                    int encBuffer = -1;
                    synchronized (mCondition) {
                        try {
                            // wait for an encoder input buffer and a decoder output buffer
                            // Use a timeout to avoid stalling the test if it doesn't arrive.
                            if (!haveBuffers() && !mCompleted) {
                                mCondition.wait(mEncodeOutputFormatUpdated ?
                                        FRAME_TIMEOUT_MS : INIT_TIMEOUT_MS);
                            }
                        } catch (InterruptedException ie) {
                            fail(""wait interrupted"");  // shouldn't happen
                        }
                        if (mCompleted) {
                            break;
                        }
                        if (!haveBuffers()) {
                            if (mEncoderIsActive) {
                                mEncoderIsActive = false;
                                Log.d(TAG, ""No more input but still getting output from encoder."");
                                continue;
                            }
                            fail(""timed out after "" + mBuffersToRender.size()
                                    + "" decoder output and "" + mEncInputBuffers.size()
                                    + "" encoder input buffers"");
                        }

                        if (DEBUG) Log.v(TAG, ""got image"");
                        decBuffer = mBuffersToRender.removeFirst();
                        encBuffer = mEncInputBuffers.removeFirst();
                        if (isEOSOnlyBuffer(decBuffer)) {
                            queueEncoderEOS(decBuffer, encBuffer);
                            continue;
                        }
                        mWorkInProgress = true;
                    }

                    if (mWorkInProgress) {
                        renderDecodedBuffer(decBuffer, encBuffer);
                        synchronized(mCondition) {
                            mWorkInProgress = false;
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
                fail(""received exception "" + e);
            } finally {
                close();
            }
            assertNull(errorMsg.get(), errorMsg.get());
            return !skipped;
        }

        @Override
        public void onInputBufferAvailableLocked(MediaCodec mediaCodec, int ix) {
            if (mediaCodec == mDecoder) {
                // fill input buffer from extractor
                fillDecoderInputBuffer(ix);
            } else if (mediaCodec == mEncoder) {
                synchronized(mCondition) {
                    mEncInputBuffers.addLast(ix);
                    tryToPropagateEOS();
                    if (haveBuffers()) {
                        mCondition.notifyAll();
                    }
                }
            } else {
                fail(""received input buffer on "" + mediaCodec.getName());
            }
        }

        @Override
        public void onOutputBufferAvailableLocked(
                MediaCodec mediaCodec, int ix, BufferInfo info) {
            if (mediaCodec == mDecoder) {
                if (DEBUG) Log.v(TAG, ""decoder received output #"" + ix
                         + "" (sz="" + info.size + "", f="" + info.flags
                         + "", ts="" + info.presentationTimeUs + "")"");
                // render output buffer from decoder
                if (!mGotDecoderEOS) {
                    boolean eos = (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;
                    // can release empty buffers now
                    if (info.size == 0) {
                        mDecoder.releaseOutputBuffer(ix, false /* render */);
                        ix = -1; // fake index used by render to not render
                    }
                    synchronized(mCondition) {
                        if (ix < 0 && eos && mBuffersToRender.size() > 0) {
                            // move lone EOS flag to last buffer to be rendered
                            mBuffersToRender.peekLast().second.flags |=
                                MediaCodec.BUFFER_FLAG_END_OF_STREAM;
                        } else if (ix >= 0 || eos) {
                            mBuffersToRender.addLast(Pair.create(ix, info));
                        }
                        if (eos) {
                            tryToPropagateEOS();
                            mGotDecoderEOS = true;
                        }
                        if (haveBuffers()) {
                            mCondition.notifyAll();
                        }
                    }
                }
            } else if (mediaCodec == mEncoder) {
                emptyEncoderOutputBuffer(ix, info);
            } else {
                fail(""received output buffer on "" + mediaCodec.getName());
            }
        }

        private void renderDecodedBuffer(Pair<Integer, BufferInfo> decBuffer, int encBuffer) {
            // process heavyweight actions under instance lock
            Image encImage = mEncoder.getInputImage(encBuffer);
            Image decImage = mDecoder.getOutputImage(decBuffer.first);
            assertNotNull(""could not get encoder image for "" + mEncoder.getInputFormat(), encImage);
            assertNotNull(""could not get decoder image for "" + mDecoder.getInputFormat(), decImage);
            assertEquals(""incorrect decoder format"",decImage.getFormat(), ImageFormat.YUV_420_888);
            assertEquals(""incorrect encoder format"", encImage.getFormat(), ImageFormat.YUV_420_888);

            CodecUtils.copyFlexYUVImage(encImage, decImage);

            // TRICKY: need this for queueBuffer
            if (mEncInputBufferSize < 0) {
                mEncInputBufferSize = mEncoder.getInputBuffer(encBuffer).capacity();
            }
            Log.d(TAG, ""queuing input #"" + encBuffer + "" for encoder (sz=""
                    + mEncInputBufferSize + "", f="" + decBuffer.second.flags
                    + "", ts="" + decBuffer.second.presentationTimeUs + "")"");
            mEncoder.queueInputBuffer(
                    encBuffer, 0, mEncInputBufferSize, decBuffer.second.presentationTimeUs,
                    decBuffer.second.flags);
            if ((decBuffer.second.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                mSignaledEncoderEOS = true;
            }
            mDecoder.releaseOutputBuffer(decBuffer.first, false /* render */);
        }

        @Override
        public void onError(MediaCodec mediaCodec, MediaCodec.CodecException e) {
            String codecName = null;
            try {
                codecName = mediaCodec.getName();
            } catch (Exception ex) {
                codecName = ""(error getting codec name)"";
            }
            errorMsg.set(""received error on "" + codecName + "": "" + e);
        }

        @Override
        public void onOutputFormatChanged(MediaCodec mediaCodec, MediaFormat mediaFormat) {
            Log.i(TAG, mediaCodec.getName() + "" got new output format "" + mediaFormat);
            if (mediaCodec == mEncoder) {
                mEncodeOutputFormatUpdated = true;
                saveEncoderFormat(mediaFormat);
            }
        }

        // next methods are synchronized on mCondition
        private boolean haveBuffers() {
            return mEncInputBuffers.size() > 0 && mBuffersToRender.size() > 0
                    && !mSignaledEncoderEOS;
        }

        private boolean isEOSOnlyBuffer(Pair<Integer, BufferInfo> decBuffer) {
            return decBuffer.first < 0 || decBuffer.second.size == 0;
        }

        protected void tryToPropagateEOS() {
            if (!mWorkInProgress && haveBuffers() && isEOSOnlyBuffer(mBuffersToRender.getFirst())) {
                Pair<Integer, BufferInfo> decBuffer = mBuffersToRender.removeFirst();
                int encBuffer = mEncInputBuffers.removeFirst();
                queueEncoderEOS(decBuffer, encBuffer);
            }
        }

        void queueEncoderEOS(Pair<Integer, BufferInfo> decBuffer, int encBuffer) {
            Log.d(TAG, ""signaling encoder EOS"");
            mEncoder.queueInputBuffer(encBuffer, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
            mSignaledEncoderEOS = true;
            if (decBuffer.first >= 0) {
                mDecoder.releaseOutputBuffer(decBuffer.first, false /* render */);
            }
        }
    }


    class SurfaceVideoProcessor extends VideoProcessorBase
            implements SurfaceTexture.OnFrameAvailableListener {
        private static final String TAG = ""SurfaceVideoProcessor"";
        private boolean mFrameAvailable;
        private boolean mGotDecoderEOS;
        private boolean mSignaledEncoderEOS;

        private InputSurface mEncSurface;
        private OutputSurface mDecSurface;
        private BufferInfo mInfoOnSurface;

        private LinkedList<Pair<Integer, BufferInfo>> mBuffersToRender =
            new LinkedList<Pair<Integer, BufferInfo>>();

        private final AtomicReference<String> errorMsg = new AtomicReference(null);

        @Override
        public boolean processLoop(
                String path, String outMime, String videoEncName,
                int width, int height, boolean optional) {
            boolean skipped = true;
            try {
                open(path);
                if (!initCodecsAndConfigureEncoder(
                        videoEncName, outMime, width, height,
                        CodecCapabilities.COLOR_FormatSurface)) {
                    assertTrue(""could not configure encoder for supported size"", optional);
                    return !skipped;
                }
                skipped = false;

                mEncSurface = new InputSurface(mEncoder.createInputSurface());
                mEncSurface.makeCurrent();

                mDecSurface = new OutputSurface(this);
                //mDecSurface.changeFragmentShader(FRAGMENT_SHADER);
                mDecoder.configure(mDecFormat, mDecSurface.getSurface(), null /* crypto */, 0);

                mDecoder.start();
                mEncoder.start();

                // main loop - process GL ops as only main thread has GL context
                while (!mCompleted && errorMsg.get() == null) {
                    BufferInfo info = null;
                    synchronized (mCondition) {
                        try {
                            // wait for mFrameAvailable, which is set by onFrameAvailable().
                            // Use a timeout to avoid stalling the test if it doesn't arrive.
                            if (!mFrameAvailable && !mCompleted && !mEncoderIsActive) {
                                mCondition.wait(mEncodeOutputFormatUpdated ?
                                        FRAME_TIMEOUT_MS : INIT_TIMEOUT_MS);
                            }
                        } catch (InterruptedException ie) {
                            fail(""wait interrupted"");  // shouldn't happen
                        }
                        if (mCompleted) {
                            break;
                        }
                        if (mEncoderIsActive) {
                            mEncoderIsActive = false;
                            if (DEBUG) Log.d(TAG, ""encoder is still active, continue"");
                            continue;
                        }
                        assertTrue(""still waiting for image"", mFrameAvailable);
                        if (DEBUG) Log.v(TAG, ""got image"");
                        info = mInfoOnSurface;
                    }
                    if (info == null) {
                        continue;
                    }
                    if (info.size > 0) {
                        mDecSurface.latchImage();
                        if (DEBUG) Log.v(TAG, ""latched image"");
                        mFrameAvailable = false;

                        mDecSurface.drawImage();
                        Log.d(TAG, ""encoding frame at "" + info.presentationTimeUs * 1000);

                        mEncSurface.setPresentationTime(info.presentationTimeUs * 1000);
                        mEncSurface.swapBuffers();
                    }
                    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {
                        mSignaledEncoderEOS = true;
                        Log.d(TAG, ""signaling encoder EOS"");
                        mEncoder.signalEndOfInputStream();
                    }

                    synchronized (mCondition) {
                        mInfoOnSurface = null;
                        if (mBuffersToRender.size() > 0 && mInfoOnSurface == null) {
                            if (DEBUG) Log.v(TAG, ""handling postponed frame"");
                            Pair<Integer, BufferInfo> nextBuffer = mBuffersToRender.removeFirst();
                            renderDecodedBuffer(nextBuffer.first, nextBuffer.second);
                        }
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
                fail(""received exception "" + e);
            } finally {
                close();
                if (mEncSurface != null) {
                    mEncSurface.release();
                    mEncSurface = null;
                }
                if (mDecSurface != null) {
                    mDecSurface.release();
                    mDecSurface = null;
                }
            }
            assertNull(errorMsg.get(), errorMsg.get());
            return !skipped;
        }

        @Override
        public void onFrameAvailable(SurfaceTexture st) {
            if (DEBUG) Log.v(TAG, ""new frame available"");
            synchronized (mCondition) {
                assertFalse(""mFrameAvailable already set, frame could be dropped"", mFrameAvailable);
                mFrameAvailable = true;
                mCondition.notifyAll();
            }
        }

        @Override
        public void onInputBufferAvailableLocked(MediaCodec mediaCodec, int ix) {
            if (mediaCodec == mDecoder) {
                // fill input buffer from extractor
                fillDecoderInputBuffer(ix);
            } else {
                fail(""received input buffer on "" + mediaCodec.getName());
            }
        }

        @Override
        public void onOutputBufferAvailableLocked(
                MediaCodec mediaCodec, int ix, BufferInfo info) {
            if (mediaCodec == mDecoder) {
                if (DEBUG) Log.v(TAG, ""decoder received output #"" + ix
                         + "" (sz="" + info.size + "", f="" + info.flags
                         + "", ts="" + info.presentationTimeUs + "")"");
                // render output buffer from decoder
                if (!mGotDecoderEOS) {
                    boolean eos = (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;
                    if (eos) {
                        mGotDecoderEOS = true;
                    }
                    // can release empty buffers now
                    if (info.size == 0) {
                        mDecoder.releaseOutputBuffer(ix, false /* render */);
                        ix = -1; // fake index used by render to not render
                    }
                    if (eos || info.size > 0) {
                        synchronized(mCondition) {
                            if (mInfoOnSurface != null || mBuffersToRender.size() > 0) {
                                if (DEBUG) Log.v(TAG, ""postponing render, surface busy"");
                                mBuffersToRender.addLast(Pair.create(ix, info));
                            } else {
                                renderDecodedBuffer(ix, info);
                            }
                        }
                    }
                }
            } else if (mediaCodec == mEncoder) {
                emptyEncoderOutputBuffer(ix, info);
                synchronized(mCondition) {
                    if (!mCompleted) {
                        mEncoderIsActive = true;
                        mCondition.notifyAll();
                    }
                }
            } else {
                fail(""received output buffer on "" + mediaCodec.getName());
            }
        }

        private void renderDecodedBuffer(int ix, BufferInfo info) {
            boolean eos = (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;
            mInfoOnSurface = info;
            if (info.size > 0) {
                Log.d(TAG, ""rendering frame #"" + ix + "" at "" + info.presentationTimeUs * 1000
                        + (eos ? "" with EOS"" : """"));
                mDecoder.releaseOutputBuffer(ix, info.presentationTimeUs * 1000);
            }

            if (eos && info.size == 0) {
                if (DEBUG) Log.v(TAG, ""decoder output EOS available"");
                mFrameAvailable = true;
                mCondition.notifyAll();
            }
        }

        @Override
        public void onError(MediaCodec mediaCodec, MediaCodec.CodecException e) {
            String codecName = null;
            try {
                codecName = mediaCodec.getName();
            } catch (Exception ex) {
                codecName = ""(error getting codec name)"";
            }
            errorMsg.set(""received error on "" + codecName + "": "" + e);
        }

        @Override
        public void onOutputFormatChanged(MediaCodec mediaCodec, MediaFormat mediaFormat) {
            Log.i(TAG, mediaCodec.getName() + "" got new output format "" + mediaFormat);
            if (mediaCodec == mEncoder) {
                mEncodeOutputFormatUpdated = true;
                saveEncoderFormat(mediaFormat);
            }
        }
    }

    class Encoder {
        final private String mName;
        final private String mMime;
        final private CodecCapabilities mCaps;
        final private VideoCapabilities mVideoCaps;

        final private Map<Size, Set<Size>> mMinMax;     // extreme sizes
        final private Map<Size, Set<Size>> mNearMinMax; // sizes near extreme
        final private Set<Size> mArbitraryW;            // arbitrary widths in the middle
        final private Set<Size> mArbitraryH;            // arbitrary heights in the middle
        final private Set<Size> mSizes;                 // all non-specifically tested sizes

        final private int xAlign;
        final private int yAlign;

        Encoder(String name, String mime, CodecCapabilities caps) {
            mName = name;
            mMime = mime;
            mCaps = caps;
            mVideoCaps = caps.getVideoCapabilities();

            /* calculate min/max sizes */
            mMinMax = new HashMap<Size, Set<Size>>();
            mNearMinMax = new HashMap<Size, Set<Size>>();
            mArbitraryW = new HashSet<Size>();
            mArbitraryH = new HashSet<Size>();
            mSizes = new HashSet<Size>();

            xAlign = mVideoCaps.getWidthAlignment();
            yAlign = mVideoCaps.getHeightAlignment();

            initializeSizes();
        }

        private void initializeSizes() {
            for (int x = 0; x < 2; ++x) {
                for (int y = 0; y < 2; ++y) {
                    addExtremeSizesFor(x, y);
                }
            }

            // initialize arbitrary sizes
            for (int i = 1; i <= 7; ++i) {
                int j = ((7 * i) % 11) + 1;
                int width, height;
                try {
                    width = alignedPointInRange(i * 0.125, xAlign, mVideoCaps.getSupportedWidths());
                    height = alignedPointInRange(
                            j * 0.077, yAlign, mVideoCaps.getSupportedHeightsFor(width));
                    mArbitraryW.add(new Size(width, height));
                } catch (IllegalArgumentException e) {
                }

                try {
                    height = alignedPointInRange(i * 0.125, yAlign, mVideoCaps.getSupportedHeights());
                    width = alignedPointInRange(j * 0.077, xAlign, mVideoCaps.getSupportedWidthsFor(height));
                    mArbitraryH.add(new Size(width, height));
                } catch (IllegalArgumentException e) {
                }
            }
            mArbitraryW.removeAll(mArbitraryH);
            mArbitraryW.removeAll(mSizes);
            mSizes.addAll(mArbitraryW);
            mArbitraryH.removeAll(mSizes);
            mSizes.addAll(mArbitraryH);
            if (DEBUG) Log.i(TAG, ""arbitrary="" + mArbitraryW + ""/"" + mArbitraryH);
        }

        private void addExtremeSizesFor(int x, int y) {
            Set<Size> minMax = new HashSet<Size>();
            Set<Size> nearMinMax = new HashSet<Size>();

            for (int dx = 0; dx <= xAlign; dx += xAlign) {
                for (int dy = 0; dy <= yAlign; dy += yAlign) {
                    Set<Size> bucket = (dx + dy == 0) ? minMax : nearMinMax;
                    try {
                        int width = getExtreme(mVideoCaps.getSupportedWidths(), x, dx);
                        int height = getExtreme(mVideoCaps.getSupportedHeightsFor(width), y, dy);
                        bucket.add(new Size(width, height));

                        // try max max with more reasonable ratio if too skewed
                        if (x + y == 2 && width >= 4 * height) {
                            Size wideScreen = getLargestSizeForRatio(16, 9);
                            width = getExtreme(
                                    mVideoCaps.getSupportedWidths()
                                            .intersect(0, wideScreen.getWidth()), x, dx);
                            height = getExtreme(mVideoCaps.getSupportedHeightsFor(width), y, 0);
                            bucket.add(new Size(width, height));
                        }
                    } catch (IllegalArgumentException e) {
                    }

                    try {
                        int height = getExtreme(mVideoCaps.getSupportedHeights(), y, dy);
                        int width = getExtreme(mVideoCaps.getSupportedWidthsFor(height), x, dx);
                        bucket.add(new Size(width, height));

                        // try max max with more reasonable ratio if too skewed
                        if (x + y == 2 && height >= 4 * width) {
                            Size wideScreen = getLargestSizeForRatio(9, 16);
                            height = getExtreme(
                                    mVideoCaps.getSupportedHeights()
                                            .intersect(0, wideScreen.getHeight()), y, dy);
                            width = getExtreme(mVideoCaps.getSupportedWidthsFor(height), x, dx);
                            bucket.add(new Size(width, height));
                        }
                    } catch (IllegalArgumentException e) {
                    }
                }
            }

            // keep unique sizes
            minMax.removeAll(mSizes);
            mSizes.addAll(minMax);
            nearMinMax.removeAll(mSizes);
            mSizes.addAll(nearMinMax);

            mMinMax.put(new Size(x, y), minMax);
            mNearMinMax.put(new Size(x, y), nearMinMax);
            if (DEBUG) Log.i(TAG, x + ""x"" + y + "": minMax="" + mMinMax + "", near="" + mNearMinMax);
        }

        private int alignInRange(double value, int align, Range<Integer> range) {
            return range.clamp(align * (int)Math.round(value / align));
        }

        /* point should be between 0. and 1. */
        private int alignedPointInRange(double point, int align, Range<Integer> range) {
            return alignInRange(
                    range.getLower() + point * (range.getUpper() - range.getLower()), align, range);
        }

        private int getExtreme(Range<Integer> range, int i, int delta) {
            int dim = i == 1 ? range.getUpper() - delta : range.getLower() + delta;
            if (delta == 0
                    || (dim > range.getLower() && dim < range.getUpper())) {
                return dim;
            }
            throw new IllegalArgumentException();
        }

        private Size getLargestSizeForRatio(int x, int y) {
            Range<Integer> widthRange = mVideoCaps.getSupportedWidths();
            Range<Integer> heightRange = mVideoCaps.getSupportedHeightsFor(widthRange.getUpper());
            final int xAlign = mVideoCaps.getWidthAlignment();
            final int yAlign = mVideoCaps.getHeightAlignment();

            // scale by alignment
            int width = alignInRange(
                    Math.sqrt(widthRange.getUpper() * heightRange.getUpper() * (double)x / y),
                    xAlign, widthRange);
            int height = alignInRange(
                    width * (double)y / x, yAlign, mVideoCaps.getSupportedHeightsFor(width));
            return new Size(width, height);
        }


        public boolean testExtreme(int x, int y, boolean flexYUV, boolean near) {
            boolean skipped = true;
            for (Size s : (near ? mNearMinMax : mMinMax).get(new Size(x, y))) {
                if (test(s.getWidth(), s.getHeight(), false /* optional */, flexYUV)) {
                    skipped = false;
                }
            }
            return !skipped;
        }

        public boolean testArbitrary(boolean flexYUV, boolean widths) {
            boolean skipped = true;
            for (Size s : (widths ? mArbitraryW : mArbitraryH)) {
                if (test(s.getWidth(), s.getHeight(), false /* optional */, flexYUV)) {
                    skipped = false;
                }
            }
            return !skipped;
        }

        public boolean testSpecific(int width, int height, boolean flexYUV) {
            // already tested by one of the min/max tests
            if (mSizes.contains(new Size(width, height))) {
                return false;
            }
            return test(width, height, true /* optional */, flexYUV);
        }

        public boolean testIntraRefresh(int width, int height) {
            if (!mCaps.isFeatureSupported(CodecCapabilities.FEATURE_IntraRefresh)) {
                return false;
            }

            final int refreshPeriod[] = new int[] {10, 13, 17, 22, 29, 38, 50, 60};

            // Test the support of refresh periods in the range of 10 - 60 frames
            for (int period : refreshPeriod) {
                Function<MediaFormat, Boolean> updateConfigFormatHook =
                new Function<MediaFormat, Boolean>() {
                    public Boolean apply(MediaFormat fmt) {
                        // set i-frame-interval to 10000 so encoded video only has 1 i-frame.
                        fmt.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 10000);
                        fmt.setInteger(MediaFormat.KEY_INTRA_REFRESH_PERIOD, period);
                        return true;
                    }
                };

                Function<MediaFormat, Boolean> checkOutputFormatHook =
                new Function<MediaFormat, Boolean>() {
                    public Boolean apply(MediaFormat fmt) {
                        int intraPeriod = fmt.getInteger(MediaFormat.KEY_INTRA_REFRESH_PERIOD);
                        // Make sure intra period is correct and carried in the output format.
                        // intraPeriod must be larger than 0 and operate within 20% of refresh period.
                        if (intraPeriod > 1.2 * period || intraPeriod < 0.8 * period) {
                            throw new RuntimeException(""Intra period mismatch"");
                        }
                        return true;
                    }
                };

                String testName =
                mName + '_' + width + ""x"" + height + '_' + ""flexYUV_intraRefresh"";

                Consumer<VideoProcessorBase> configureVideoProcessor =
                new Consumer<VideoProcessorBase>() {
                    public void accept(VideoProcessorBase processor) {
                        processor.setProcessorName(testName);
                        processor.setUpdateConfigHook(updateConfigFormatHook);
                        processor.setCheckOutputFormatHook(checkOutputFormatHook);
                    }
                };

                if (!test(width, height, 0 /* frameRate */, 0 /* bitRate */, true /* optional */,
                    true /* flex */, configureVideoProcessor)) {
                    return false;
                }
            }

            return true;
        }

        public boolean testDetailed(
                int width, int height, int frameRate, int bitRate, boolean flexYUV) {
            String testName =
                    mName + '_' + width + ""x"" + height + '_' + (flexYUV ? ""flexYUV"" : "" surface"");
            Consumer<VideoProcessorBase> configureVideoProcessor =
                    new Consumer<VideoProcessorBase>() {
                public void accept(VideoProcessorBase processor) {
                    processor.setProcessorName(testName);
                }
            };
            return test(width, height, frameRate, bitRate, true /* optional */, flexYUV,
                    configureVideoProcessor);
        }

        public boolean testSupport(int width, int height, int frameRate, int bitRate) {
            return mVideoCaps.areSizeAndRateSupported(width, height, frameRate) &&
                    mVideoCaps.getBitrateRange().contains(bitRate);
        }

        private boolean test(
                int width, int height, boolean optional, boolean flexYUV) {
            String testName =
                    mName + '_' + width + ""x"" + height + '_' + (flexYUV ? ""flexYUV"" : "" surface"");
            Consumer<VideoProcessorBase> configureVideoProcessor =
                    new Consumer<VideoProcessorBase>() {
                public void accept(VideoProcessorBase processor) {
                    processor.setProcessorName(testName);
                }
            };
            return test(width, height, 0 /* frameRate */, 0 /* bitRate */,
                    optional, flexYUV, configureVideoProcessor);
        }

        private boolean test(
                int width, int height, int frameRate, int bitRate, boolean optional,
                boolean flexYUV, Consumer<VideoProcessorBase> configureVideoProcessor) {
            Log.i(TAG, ""testing "" + mMime + "" on "" + mName + "" for "" + width + ""x"" + height
                    + (flexYUV ? "" flexYUV"" : "" surface""));

            Preconditions.assertTestFileExists(SOURCE_URL);

            VideoProcessorBase processor =
                flexYUV ? new VideoProcessor() : new SurfaceVideoProcessor();

            processor.setFrameAndBitRates(frameRate, bitRate);
            configureVideoProcessor.accept(processor);

            // We are using a resource URL as an example
            boolean success = processor.processLoop(
                    SOURCE_URL, mMime, mName, width, height, optional);
            if (success) {
                success = processor.playBack(getActivity().getSurfaceHolder().getSurface());
            }
            return success;
        }
    }

    private Encoder[] googH265()  { return goog(MediaFormat.MIMETYPE_VIDEO_HEVC); }
    private Encoder[] googH264()  { return goog(MediaFormat.MIMETYPE_VIDEO_AVC); }
    private Encoder[] googH263()  { return goog(MediaFormat.MIMETYPE_VIDEO_H263); }
    private Encoder[] googMpeg4() { return goog(MediaFormat.MIMETYPE_VIDEO_MPEG4); }
    private Encoder[] googVP8()   { return goog(MediaFormat.MIMETYPE_VIDEO_VP8); }
    private Encoder[] googVP9()   { return goog(MediaFormat.MIMETYPE_VIDEO_VP9); }

    private Encoder[] otherH265()  { return other(MediaFormat.MIMETYPE_VIDEO_HEVC); }
    private Encoder[] otherH264()  { return other(MediaFormat.MIMETYPE_VIDEO_AVC); }
    private Encoder[] otherH263()  { return other(MediaFormat.MIMETYPE_VIDEO_H263); }
    private Encoder[] otherMpeg4() { return other(MediaFormat.MIMETYPE_VIDEO_MPEG4); }
    private Encoder[] otherVP8()   { return other(MediaFormat.MIMETYPE_VIDEO_VP8); }
    private Encoder[] otherVP9()   { return other(MediaFormat.MIMETYPE_VIDEO_VP9); }

    private Encoder[] goog(String mime) {
        return encoders(mime, true /* goog */);
    }

    private Encoder[] other(String mime) {
        return encoders(mime, false /* goog */);
    }

    private Encoder[] combineArray(Encoder[] a, Encoder[] b) {
        Encoder[] all = new Encoder[a.length + b.length];
        System.arraycopy(a, 0, all, 0, a.length);
        System.arraycopy(b, 0, all, a.length, b.length);
        return all;
    }

    private Encoder[] h264()  {
        return combineArray(googH264(), otherH264());
    }

    private Encoder[] vp8()  {
        return combineArray(googVP8(), otherVP8());
    }

    private Encoder[] encoders(String mime, boolean goog) {
        MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);
        ArrayList<Encoder> result = new ArrayList<Encoder>();

        for (MediaCodecInfo info : mcl.getCodecInfos()) {
            if (!info.isEncoder() || !info.isVendor() != goog || info.isAlias()) {
                continue;
            }
            CodecCapabilities caps = null;
            try {
                caps = info.getCapabilitiesForType(mime);
            } catch (IllegalArgumentException e) { // mime is not supported
                continue;
            }
            assertNotNull(info.getName() + "" capabilties for "" + mime + "" returned null"", caps);
            result.add(new Encoder(info.getName(), mime, caps));
        }
        return result.toArray(new Encoder[result.size()]);
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.server.cts.BatteryStatsValidationTest"	"testReportRadioPowerState"	"CtsIncidentHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/BatteryStatsValidationTest.java"	""	"public void testReportRadioPowerState() throws Exception {
        // Simulate usb unplugged.
        batteryOnScreenOff();

        installPackage(DEVICE_SIDE_TEST_APK, true);
        allowImmediateSyncs();

        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".BatteryStatsRadioPowerStateTest"",
                ""testReportMobileRadioPowerState"");
        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".BatteryStatsRadioPowerStateTest"",
                ""testReportWifiRadioPowerState"");

        batteryOffScreenOn();
    }

    private int getUid() throws Exception {
        String uidLine = getDevice().executeShellCommand(""cmd package list packages -U ""
                + DEVICE_SIDE_TEST_PACKAGE);
        String[] uidLineParts = uidLine.split("":"");
        // 3rd entry is package uid
        assertTrue(uidLineParts.length > 2);
        int uid = Integer.parseInt(uidLineParts[2].trim());
        assertTrue(uid > 10000);
        return uid;
    }

    private void assertApproximateTimeInState(int index, long duration) throws Exception {
        assertValueRange(""st"", """", index, (long) (0.7 * duration), 2 * duration);
    }

    /**
     * Verifies that the recorded time for the specified tag and name in the test package
     * is within the specified range.
     */
    private void assertValueRange(String tag, String optionalAfterTag,
            int index, long min, long max) throws Exception {
        int uid = getUid();
        long value = getLongValue(uid, tag, optionalAfterTag, index);
        assertTrue(""Value "" + value + "" is less than min "" + min, value >= min);
        assertTrue(""Value "" + value + "" is greater than max "" + max, value <= max);
    }

    /**
     * Returns a particular long value from a line matched by uid, tag and the optionalAfterTag.
     */
    private long getLongValue(int uid, String tag, String optionalAfterTag, int index)
            throws Exception {
        String dumpsys = getDevice().executeShellCommand(""dumpsys batterystats --checkin"");
        String[] lines = dumpsys.split(""\n"");
        long value = 0;
        if (optionalAfterTag == null) {
            optionalAfterTag = """";
        }
        for (int i = lines.length - 1; i >= 0; i--) {
            String line = lines[i];
            if (line.contains(uid + "",l,"" + tag + "","" + optionalAfterTag)
                    || (!optionalAfterTag.equals("""") &&
                        line.contains(uid + "",l,"" + tag + "",\"""" + optionalAfterTag))) {
                String[] wlParts = line.split("","");
                value = Long.parseLong(wlParts[index]);
            }
        }
        return value;
    }

    /**
     * Runs a (background) service to perform the given action, and waits for
     * the device to report that the action has finished (via a logcat message) before returning.
     * @param actionValue one of the constants in BatteryStatsBgVsFgActions indicating the desired
     *                    action to perform.
     * @param maxTimeMs max time to wait (in ms) for action to report that it has completed.
     * @return A string, representing a random integer, assigned to this particular request for the
     *                     device to perform the given action. This value can be used to receive
     *                     communications via logcat from the device about this action.
     */
    private String executeBackground(String actionValue, int maxTimeMs) throws Exception {
        String requestCode = executeBackground(actionValue);
        String searchString = getCompletedActionString(actionValue, requestCode);
        checkLogcatForText(BG_VS_FG_TAG, searchString, maxTimeMs);
        return requestCode;
    }

    /**
     * Runs a (background) service to perform the given action.
     * @param actionValue one of the constants in BatteryStatsBgVsFgActions indicating the desired
     *                    action to perform.
     * @return A string, representing a random integer, assigned to this particular request for the
      *                     device to perform the given action. This value can be used to receive
      *                     communications via logcat from the device about this action.
     */
    private String executeBackground(String actionValue) throws Exception {
        allowBackgroundServices();
        String requestCode = Integer.toString(new Random().nextInt());
        getDevice().executeShellCommand(String.format(
                ""am startservice -n '%s' -e %s %s -e %s %s"",
                DEVICE_SIDE_BG_SERVICE_COMPONENT,
                KEY_ACTION, actionValue,
                KEY_REQUEST_CODE, requestCode));
        return requestCode;
    }

    /** Required to successfully start a background service from adb in O. */
    private void allowBackgroundServices() throws Exception {
        getDevice().executeShellCommand(String.format(
                ""cmd deviceidle tempwhitelist %s"", DEVICE_SIDE_TEST_PACKAGE));
    }

    /** Make the test-app standby-active so it can run syncs and jobs immediately. */
    protected void allowImmediateSyncs() throws Exception {
        getDevice().executeShellCommand(""am set-standby-bucket ""
                + DEVICE_SIDE_TEST_PACKAGE + "" active"");
    }

    /**
     * Runs an activity (in the foreground) to perform the given action, and waits
     * for the device to report that the action has finished (via a logcat message) before returning.
     * @param actionValue one of the constants in BatteryStatsBgVsFgActions indicating the desired
     *                    action to perform.
     * @param maxTimeMs max time to wait (in ms) for action to report that it has completed.
     * @return A string, representing a random integer, assigned to this particular request for the
     *                     device to perform the given action. This value can be used to receive
     *                     communications via logcat from the device about this action.
     */
    private String executeForeground(String actionValue, int maxTimeMs) throws Exception {
        String requestCode = executeForeground(actionValue);
        String searchString = getCompletedActionString(actionValue, requestCode);
        checkLogcatForText(BG_VS_FG_TAG, searchString, maxTimeMs);
        return requestCode;
    }

    /**
     * Runs an activity (in the foreground) to perform the given action.
     * @param actionValue one of the constants in BatteryStatsBgVsFgActions indicating the desired
     *                    action to perform.
     * @return A string, representing a random integer, assigned to this particular request for the
     *                     device to perform the given action. This value can be used to receive
     *                     communications via logcat from the device about this action.
     */
    private String executeForeground(String actionValue) throws Exception {
        String requestCode = Integer.toString(new Random().nextInt());
        getDevice().executeShellCommand(String.format(
                ""am start -n '%s' -e %s %s -e %s %s"",
                DEVICE_SIDE_FG_ACTIVITY_COMPONENT,
                KEY_ACTION, actionValue,
                KEY_REQUEST_CODE, requestCode));
        return requestCode;
    }

    /**
     * The string that will be printed in the logcat when the action completes. This needs to be
     * identical to {@link com.android.server.cts.device.batterystats.BatteryStatsBgVsFgActions#tellHostActionFinished}.
     */
    private String getCompletedActionString(String actionValue, String requestCode) {
        return String.format(""Completed performing %s for request %s"", actionValue, requestCode);
    }

    /** Determine if device has no battery and is not expected to have proper batterystats. */
    private boolean noBattery() throws Exception {
        final String batteryinfo = getDevice().executeShellCommand(""dumpsys battery"");
        boolean hasBattery = batteryinfo.contains(""present: true"");
        if (!hasBattery) {
            LogUtil.CLog.w(""Device does not have a battery"");
        }
        return !hasBattery;
    }

    /**
     * Determines if the device has the given feature.
     * Prints a warning if its value differs from requiredAnswer.
     */
    private boolean hasFeature(String featureName, boolean requiredAnswer) throws Exception {
        final String features = getDevice().executeShellCommand(""pm list features"");
        boolean hasIt = features.contains(featureName);
        if (hasIt != requiredAnswer) {
            LogUtil.CLog.w(""Device does "" + (requiredAnswer ? ""not "" : """") + ""have feature ""
                    + featureName);
        }
        return hasIt;
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.view.cts.View_FocusHandlingTest"	"testEnabledHandling"	"CtsViewTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/View_FocusHandlingTest.java"	""	"public void testEnabledHandling() {
        Activity activity = mActivityRule.getActivity();

        View v1 = activity.findViewById(R.id.view1);
        View v2 = activity.findViewById(R.id.view2);
        View v3 = activity.findViewById(R.id.view3);
        View v4 = activity.findViewById(R.id.view4);

        for (View v : new View[]{v1, v2, v3, v4}) v.setFocusable(true);

        assertTrue(v1.requestFocus());

        // disabled view should not be focusable
        assertTrue(v1.hasFocus());
        v1.setEnabled(false);
        assertFalse(v1.hasFocus());
        v1.requestFocus();
        assertFalse(v1.hasFocus());
        v1.setEnabled(true);
        v1.requestFocus();
        assertTrue(v1.hasFocus());

        // an enabled view should not take focus if not visible OR not enabled
        v1.setEnabled(false);
        v1.setVisibility(View.INVISIBLE);
        assertFalse(v1.hasFocus());
        v1.setEnabled(true);
        v1.requestFocus();
        assertFalse(v1.hasFocus());
        v1.setEnabled(false);
        v1.setVisibility(View.VISIBLE);
        v1.requestFocus();
        assertFalse(v1.hasFocus());
        v1.setEnabled(true);
        v1.requestFocus();
        assertTrue(v1.hasFocus());

        // test hasFocusable
        ViewGroup parent = (ViewGroup) v1.getParent();
        assertTrue(parent.hasFocusable());
        for (View v : new View[]{v1, v2, v3, v4}) v.setEnabled(false);
        assertFalse(v1.isFocused());
        assertFalse(v2.isFocused());
        assertFalse(v3.isFocused());
        assertFalse(v4.isFocused());
        assertFalse(parent.hasFocusable());

        // a view enabled while nothing has focus should get focus if not in touch mode.
        InstrumentationRegistry.getInstrumentation().setInTouchMode(false);
        for (View v : new View[]{v1, v2, v3, v4}) v.setEnabled(true);
        assertEquals(true, v1.isFocused());

        // enabled state is restricted to the view only (not children)
        v2.requestFocus();
        parent.setEnabled(false);
        assertTrue(v2.isFocused());
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.PermissionPolicyTest"	"platformPermissionPolicyIsUnaltered"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/PermissionPolicyTest.java"	""	"public void platformPermissionPolicyIsUnaltered() throws Exception {
        Map<String, PermissionInfo> declaredPermissionsMap =
                getPermissionsForPackage(sContext, PLATFORM_PACKAGE_NAME);

        List<String> offendingList = new ArrayList<>();

        List<PermissionGroupInfo> declaredGroups = sContext.getPackageManager()
                .getAllPermissionGroups(0);
        Set<String> declaredGroupsSet = new ArraySet<>();
        for (PermissionGroupInfo declaredGroup : declaredGroups) {
            declaredGroupsSet.add(declaredGroup.name);
        }

        Set<String> expectedPermissionGroups = loadExpectedPermissionGroupNames(
                R.raw.android_manifest);
        List<ExpectedPermissionInfo> expectedPermissions = loadExpectedPermissions(
                R.raw.android_manifest);

        if (sContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            expectedPermissions.addAll(loadExpectedPermissions(R.raw.automotive_android_manifest));
            declaredPermissionsMap.putAll(
                    getPermissionsForPackage(sContext, AUTOMOTIVE_SERVICE_PACKAGE_NAME));
        }

        for (ExpectedPermissionInfo expectedPermission : expectedPermissions) {
            String expectedPermissionName = expectedPermission.name;
            if (shouldSkipPermission(expectedPermissionName)) {
                // This permission doesn't need to exist yet, but will exist in
                // a future SPL. It is acceptable to declare the permission
                // even in an earlier SPL, so we remove it here so it doesn't
                // trigger a failure after the loop.
                declaredPermissionsMap.remove(expectedPermissionName);
                continue;
            }

            // OEMs cannot remove permissions
            PermissionInfo declaredPermission = declaredPermissionsMap.get(expectedPermissionName);
            if (declaredPermission == null) {
                offendingList.add(""Permission "" + expectedPermissionName + "" must be declared"");
                continue;
            }

            // We want to end up with OEM defined permissions and groups to check their namespace
            declaredPermissionsMap.remove(expectedPermissionName);

            // OEMs cannot change permission protection
            final int expectedProtection = expectedPermission.protectionLevel
                    & PROTECTION_MASK_BASE;
            final int declaredProtection = declaredPermission.protectionLevel
                    & PROTECTION_MASK_BASE;
            if (expectedProtection != declaredProtection) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid protection level %x, expected %x"",
                                expectedPermissionName, declaredProtection, expectedProtection));
            }

            // OEMs cannot change permission flags
            final int expectedFlags = expectedPermission.flags;
            final int declaredFlags = (declaredPermission.flags & ~FLAG_INSTALLED);
            if (expectedFlags != declaredFlags) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid flags %x, expected %x"",
                                expectedPermissionName,
                                declaredFlags,
                                expectedFlags));
            }

            // OEMs cannot change permission protection flags
            final int expectedProtectionFlags =
                    expectedPermission.protectionLevel & ~PROTECTION_MASK_BASE;
            final int declaredProtectionFlags = declaredPermission.getProtectionFlags();
            if (expectedProtectionFlags != declaredProtectionFlags) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid enforced protection %x, expected %x"",
                                expectedPermissionName,
                                declaredProtectionFlags,
                                expectedProtectionFlags));
            }

            // OEMs cannot change permission grouping
            if ((declaredPermission.protectionLevel & PermissionInfo.PROTECTION_DANGEROUS) != 0) {
                if (!Objects.equals(expectedPermission.group, declaredPermission.group)) {
                    offendingList.add(
                            ""Permission "" + expectedPermissionName + "" not in correct group ""
                            + ""(expected="" + expectedPermission.group + "" actual=""
                                    + declaredPermission.group);
                }

                if (declaredPermission.group != null
                        && !declaredGroupsSet.contains(declaredPermission.group)) {
                    offendingList.add(
                            ""Permission group "" + expectedPermission.group + "" must be defined"");
                }
            }

            // OEMs cannot change background permission mapping
            if (!Objects.equals(expectedPermission.backgroundPermission,
                    declaredPermission.backgroundPermission)) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid background permission %s, expected %s"",
                                expectedPermissionName,
                                declaredPermission.backgroundPermission,
                                expectedPermission.backgroundPermission));
            }
        }

        // OEMs cannot define permissions in the platform namespace
        for (String permission : declaredPermissionsMap.keySet()) {
            if (permission.startsWith(PLATFORM_ROOT_NAMESPACE)) {
                final PermissionInfo permInfo = declaredPermissionsMap.get(permission);
                offendingList.add(
                        ""Cannot define permission "" + permission
                        + "", package "" + permInfo.packageName
                        + "" in android namespace"");
            }
        }

        // OEMs cannot define groups in the platform namespace
        for (PermissionGroupInfo declaredGroup : declaredGroups) {
            if (!expectedPermissionGroups.contains(declaredGroup.name)) {
                if (declaredGroup.name != null) {
                    if (declaredGroup.packageName.equals(PLATFORM_PACKAGE_NAME)
                            && declaredGroup.name.startsWith(PLATFORM_ROOT_NAMESPACE)) {
                        offendingList.add(
                                ""Cannot define group "" + declaredGroup.name
                                + "", package "" + declaredGroup.packageName
                                + "" in android namespace"");
                    }
                }
            }
        }

        // OEMs cannot define new ephemeral permissions
        for (String permission : declaredPermissionsMap.keySet()) {
            PermissionInfo info = declaredPermissionsMap.get(permission);
            if ((info.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
                offendingList.add(""Cannot define new instant permission "" + permission);
            }
        }

        // Fail on any offending item
        assertWithMessage(""list of offending permissions"").that(offendingList).isEmpty();
    }

    private List<ExpectedPermissionInfo> loadExpectedPermissions(int resourceId) throws Exception {
        List<ExpectedPermissionInfo> permissions = new ArrayList<>();
        try (InputStream in = sContext.getResources().openRawResource(resourceId)) {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(in, null);

            final int outerDepth = parser.getDepth();
            int type;
            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
                    && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
                if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                    continue;
                }
                if (TAG_PERMISSION.equals(parser.getName())) {
                    ExpectedPermissionInfo permissionInfo = new ExpectedPermissionInfo(
                            parser.getAttributeValue(null, ATTR_NAME),
                            parser.getAttributeValue(null, ATTR_PERMISSION_GROUP),
                            parser.getAttributeValue(null, ATTR_BACKGROUND_PERMISSION),
                            parsePermissionFlags(
                                    parser.getAttributeValue(null, ATTR_PERMISSION_FLAGS)),
                            parseProtectionLevel(
                                    parser.getAttributeValue(null, ATTR_PROTECTION_LEVEL)));
                    permissions.add(permissionInfo);
                } else {
                    Log.e(LOG_TAG, ""Unknown tag "" + parser.getName());
                }
            }
        }

        return permissions;
    }

    private Set<String> loadExpectedPermissionGroupNames(int resourceId) throws Exception {
        ArraySet<String> permissionGroups = new ArraySet<>();
        try (InputStream in = sContext.getResources().openRawResource(resourceId)) {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(in, null);

            final int outerDepth = parser.getDepth();
            int type;
            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
                    && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
                if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                    continue;
                }
                if (TAG_PERMISSION_GROUP.equals(parser.getName())) {
                    permissionGroups.add(parser.getAttributeValue(null, ATTR_NAME));
                } else {
                    Log.e(LOG_TAG, ""Unknown tag "" + parser.getName());
                }
            }
        }
        return permissionGroups;
    }

    private static int parsePermissionFlags(@Nullable String permissionFlagsString) {
        if (permissionFlagsString == null) {
            return 0;
        }

        int protectionFlags = 0;
        String[] fragments = permissionFlagsString.split(""\\|"");
        for (String fragment : fragments) {
            switch (fragment.trim()) {
                case ""removed"": {
                    protectionFlags |= PermissionInfo.FLAG_REMOVED;
                } break;
                case ""costsMoney"": {
                    protectionFlags |= PermissionInfo.FLAG_COSTS_MONEY;
                } break;
                case ""hardRestricted"": {
                    protectionFlags |= PermissionInfo.FLAG_HARD_RESTRICTED;
                } break;
                case ""immutablyRestricted"": {
                    protectionFlags |= PermissionInfo.FLAG_IMMUTABLY_RESTRICTED;
                } break;
                case ""softRestricted"": {
                    protectionFlags |= PermissionInfo.FLAG_SOFT_RESTRICTED;
                } break;
            }
        }
        return protectionFlags;
    }

    private static int parseProtectionLevel(String protectionLevelString) {
        int protectionLevel = 0;
        String[] fragments = protectionLevelString.split(""\\|"");
        for (String fragment : fragments) {
            switch (fragment.trim()) {
                case ""normal"": {
                    protectionLevel |= PermissionInfo.PROTECTION_NORMAL;
                } break;
                case ""dangerous"": {
                    protectionLevel |= PermissionInfo.PROTECTION_DANGEROUS;
                } break;
                case ""signature"": {
                    protectionLevel |= PermissionInfo.PROTECTION_SIGNATURE;
                } break;
                case ""signatureOrSystem"": {
                    protectionLevel |= PermissionInfo.PROTECTION_SIGNATURE;
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SYSTEM;
                } break;
                case ""internal"": {
                    protectionLevel |= PermissionInfo.PROTECTION_INTERNAL;
                } break;
                case ""system"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SYSTEM;
                } break;
                case ""installer"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_INSTALLER;
                } break;
                case ""verifier"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_VERIFIER;
                } break;
                case ""preinstalled"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_PREINSTALLED;
                } break;
                case ""pre23"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_PRE23;
                } break;
                case ""appop"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_APPOP;
                } break;
                case ""development"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_DEVELOPMENT;
                } break;
                case ""privileged"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_PRIVILEGED;
                } break;
                case ""oem"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_OEM;
                } break;
                case ""vendorPrivileged"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED;
                } break;
                case ""setup"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SETUP;
                } break;
                case ""textClassifier"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER;
                } break;
                case ""configurator"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_CONFIGURATOR;
                } break;
                case ""incidentReportApprover"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_INCIDENT_REPORT_APPROVER;
                } break;
                case ""documenter"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_DOCUMENTER;
                } break;
                case ""appPredictor"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_APP_PREDICTOR;
                } break;
                case ""instant"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_INSTANT;
                } break;
                case ""runtime"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY;
                } break;
                case ""companion"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_COMPANION;
                } break;
                case ""retailDemo"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_RETAIL_DEMO;
                } break;
                case ""recents"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_RECENTS;
                } break;
                case ""role"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_ROLE;
                } break;
            }
        }
        return protectionLevel;
    }

    private static Map<String, PermissionInfo> getPermissionsForPackage(Context context, String pkg)
            throws NameNotFoundException {
        PackageInfo packageInfo = context.getPackageManager()
                .getPackageInfo(pkg, PackageManager.GET_PERMISSIONS);
        Map<String, PermissionInfo> declaredPermissionsMap = new ArrayMap<>();

        for (PermissionInfo declaredPermission : packageInfo.permissions) {
            declaredPermissionsMap.put(declaredPermission.name, declaredPermission);
        }
        return declaredPermissionsMap;
    }

    private static Date parseDate(String date) {
        Date patchDate = new Date();
        try {
            SimpleDateFormat template = new SimpleDateFormat(""yyyy-MM-dd"");
            patchDate = template.parse(date);
        } catch (ParseException e) {
        }

        return patchDate;
    }

    private boolean shouldSkipPermission(String permissionName) {
        switch (permissionName) {
            case HIDE_NON_SYSTEM_OVERLAY_WINDOWS_PERMISSION:
                return parseDate(SECURITY_PATCH).before(HIDE_NON_SYSTEM_OVERLAY_WINDOWS_PATCH_DATE);
            case MANAGE_COMPANION_DEVICES_PERMISSION:
                return parseDate(SECURITY_PATCH).before(MANAGE_COMPANION_DEVICES_PATCH_DATE);
            default:
                return false;
        }
    }

    private class ExpectedPermissionInfo {
        final @NonNull String name;
        final @Nullable String group;
        final @Nullable String backgroundPermission;
        final int flags;
        final int protectionLevel;

        private ExpectedPermissionInfo(@NonNull String name, @Nullable String group,
                @Nullable String backgroundPermission, int flags, int protectionLevel) {
            this.name = name;
            this.group = group;
            this.backgroundPermission = backgroundPermission;
            this.flags = flags;
            this.protectionLevel = protectionLevel;
        }
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.server.cts.GraphicsStatsValidationTest"	"killTestApp"	"CtsIncidentHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/GraphicsStatsValidationTest.java"	""	"public void test/*
 *.
 */
package com.android.server.cts;

import static com.google.common.truth.Truth.assertThat;

import android.platform.test.annotations.RequiresDevice;
import android.service.GraphicsStatsHistogramBucketProto;
import android.service.GraphicsStatsJankSummaryProto;
import android.service.GraphicsStatsProto;
import android.service.GraphicsStatsServiceDumpProto;

import com.android.tradefed.device.CollectingByteOutputReceiver;
import com.google.common.collect.Range;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

// Although this test does not directly test performance, it does indirectly require consistent
// performance for the ""good"" frames. Although pass-through GPU virtual devices should have
// sufficient performance to pass OK, not all virtual devices do. So restrict this to physical
// devices.
@RequiresDevice
public class GraphicsStatsValidationTest extends ProtoDumpTestCase {
    private static final String TAG = ""GraphicsStatsValidationTest"";

    private static final String DEVICE_SIDE_TEST_APK = ""CtsGraphicsStatsApp.apk"";
    private static final String DEVICE_SIDE_TEST_PACKAGE
            = ""com.android.server.cts.device.graphicsstats"";

    @Override
    protected void tearDown() throws Exception {
        getDevice().uninstallPackage(DEVICE_SIDE_TEST_PACKAGE);
        super.tearDown();
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        installPackage(DEVICE_SIDE_TEST_APK, /* grantPermissions= */ true);
        turnScreenOn();
        // Ensure that we have a starting point for our stats
        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".SimpleDrawFrameTests"",
                ""testNothing"");
        // Kill to ensure that stats persist/merge across process death
        killTestApp();
    }

    private void turnScreenOn() throws Exception {
        getDevice().executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        getDevice().executeShellCommand(""wm dismiss-keyguard"");
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.server.cts.GraphicsStatsValidationTest"	"testDaveyDrawFrame"	"CtsIncidentHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/GraphicsStatsValidationTest.java"	""	"public void testDaveyDrawFrame() throws Exception {
        String origRefreshRate[] = setRefreshRate(new String[]{""60"", ""60""});
        GraphicsStatsProto[] results = runDrawTest(""testDrawDaveyFrames"");
        setRefreshRate(origRefreshRate);
        GraphicsStatsProto statsBefore = results[0];
        GraphicsStatsProto statsAfter = results[1];
        GraphicsStatsJankSummaryProto summaryBefore = statsBefore.getSummary();
        GraphicsStatsJankSummaryProto summaryAfter = statsAfter.getSummary();
        assertTrue(summaryAfter.getTotalFrames() > summaryBefore.getTotalFrames());

        int frameDelta = summaryAfter.getTotalFrames() - summaryBefore.getTotalFrames();
        int jankyDelta = summaryAfter.getJankyFrames() - summaryBefore.getJankyFrames();
        // Test draws 40 frames + 1 initial frame. We expect 10 of them to be daveys,
        // 10 of them to be daveyjrs, and 20 to jank from missed vsync (from the davey/daveyjr prior to it)
        assertThat(frameDelta).isAtLeast(40);
        assertThat(jankyDelta).isAtLeast(20);
        assertThat(jankyDelta).isLessThan(25);

        int gt150msDelta = countFramesAbove(statsAfter, 150) - countFramesAbove(statsBefore, 150);
        assertThat(gt150msDelta).isIn(Range.closed(20, 22));
        int gt700msDelta = countFramesAbove(statsAfter, 700) - countFramesAbove(statsBefore, 700);
        assertEquals(10, gt700msDelta); // 10 daveys
    }

    private GraphicsStatsProto[] runDrawTest(String testName)  throws Exception  {
        return doRunDrawTest(testName, true);
    }

    private GraphicsStatsProto[] doRunDrawTest(String testName, boolean canRetry) throws Exception {
        killTestApp();
        turnScreenOn();
        GraphicsStatsProto statsBefore = fetchStats();
        assertNotNull(statsBefore);
        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".SimpleDrawFrameTests"",  testName);
        killTestApp();
        GraphicsStatsProto statsAfter = fetchStats();
        assertNotNull(statsAfter);
        // If we get extremely unlucky a log rotate might have happened. If so we retry, but only once
        // It's a failure if this test takes >24 hours such that 2 rotates could happen while running
        // this test case, or more likely if stats are not being merged/persisted properly
        if (canRetry) {
            if (statsBefore.getStatsStart() != statsAfter.getStatsStart()) {
                return doRunDrawTest(testName, false);
            }
        } else {
            assertEquals(statsBefore.getStatsStart(), statsAfter.getStatsStart());
        }
        validate(statsBefore);
        validate(statsAfter);
        return new GraphicsStatsProto[] { statsBefore, statsAfter };
    }

    private void validate(GraphicsStatsProto proto) {
        assertNotNull(proto.getPackageName());
        assertFalse(proto.getPackageName().isEmpty());
        assertTrue(proto.getVersionCode() > 0);
        assertTrue(proto.getStatsStart() > 0);
        assertTrue(proto.getStatsEnd() > 0);
        assertTrue(proto.hasSummary());
        GraphicsStatsJankSummaryProto summary = proto.getSummary();
        assertTrue(summary.getTotalFrames() > 0);
        // Our test app won't produce that many frames, so we can assert this is a realistic
        // number. We cap it at 1,000,000 in case the test is repeated many, many times in one day
        assertTrue(summary.getTotalFrames() < 1000000);
        // We can't generically assert things about the janky frames, so just assert they fall into
        // valid ranges.
        assertTrue(summary.getJankyFrames() <= summary.getTotalFrames());
        assertTrue(summary.getMissedVsyncCount() <= summary.getJankyFrames());
        assertTrue(summary.getHighInputLatencyCount() <= summary.getTotalFrames());
        assertTrue(summary.getSlowUiThreadCount() <= summary.getJankyFrames());
        assertTrue(summary.getSlowBitmapUploadCount() <= summary.getJankyFrames());
        assertTrue(summary.getSlowDrawCount() <= summary.getJankyFrames());
        assertTrue(proto.getHistogramCount() > 0);
        assertTrue(proto.getGpuHistogramCount() > 0);
        assertTrue(proto.getPipeline() == GraphicsStatsProto.PipelineType.GL
            || proto.getPipeline() == GraphicsStatsProto.PipelineType.VULKAN);

        int histogramTotal = countTotalFrames(proto);
        assertEquals(summary.getTotalFrames(), histogramTotal);
    }

    private int countFramesAbove(GraphicsStatsProto proto, int thresholdMs) {
        int totalFrames = 0;
        for (GraphicsStatsHistogramBucketProto bucket : proto.getHistogramList()) {
            if (bucket.getRenderMillis() >= thresholdMs) {
                totalFrames += bucket.getFrameCount();
            }
        }
        return totalFrames;
    }

    private int countGPUFramesAbove(GraphicsStatsProto proto, int thresholdMs) {
        int totalFrames = 0;
        for (GraphicsStatsHistogramBucketProto bucket : proto.getGpuHistogramList()) {
            if (bucket.getRenderMillis() >= thresholdMs) {
                totalFrames += bucket.getFrameCount();
            }
        }
        return totalFrames;
    }

    private int countTotalFrames(GraphicsStatsProto proto) {
        return countFramesAbove(proto, 0);
    }

    private void killTestApp() throws Exception {
        getDevice().executeShellCommand(""am kill "" + DEVICE_SIDE_TEST_PACKAGE);
    }

    private GraphicsStatsProto fetchStats() throws Exception {
        GraphicsStatsServiceDumpProto serviceDumpProto = getDump(GraphicsStatsServiceDumpProto.parser(),
                ""dumpsys graphicsstats --proto"");
        List<GraphicsStatsProto> protos = filterPackage(serviceDumpProto, DEVICE_SIDE_TEST_PACKAGE);
        return findLatest(protos);
    }

    private List<GraphicsStatsProto> filterPackage(GraphicsStatsServiceDumpProto dump, String pkgName) {
        return filterPackage(dump.getStatsList(), pkgName);
    }

    private List<GraphicsStatsProto> filterPackage(List<GraphicsStatsProto> list, String pkgName) {
        ArrayList<GraphicsStatsProto> filtered = new ArrayList<>();
        for (GraphicsStatsProto proto : list) {
            if (pkgName.equals(proto.getPackageName())) {
                filtered.add(proto);
            }
        }
        return filtered;
    }

    private GraphicsStatsProto findLatest(List<GraphicsStatsProto> list) {
        if (list.size() == 0) { return null; }
        GraphicsStatsProto latest = list.get(0);
        Date latestDate = new Date();
        Date compareTo = new Date();
        latestDate.setTime(latest.getStatsEnd());
        for (int i = 1; i < list.size(); i++) {
            GraphicsStatsProto proto = list.get(i);
            compareTo.setTime(proto.getStatsEnd());
            if (compareTo.after(latestDate)) {
                latestDate.setTime(proto.getStatsEnd());
                latest = proto;
            }
        }
        return latest;
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionSharedUidTest"	"getTestAppCombinations"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionSharedUidTest.java"	""	"/*
 *.
 */

package android.permission2.cts;

import static android.Manifest.permission.READ_EXTERNAL_STORAGE;
import static android.app.AppOpsManager.MODE_ALLOWED;
import static android.app.AppOpsManager.OPSTR_LEGACY_STORAGE;
import static android.permission.cts.PermissionUtils.isGranted;
import static android.permission2.cts.RestrictedStoragePermissionSharedUidTest.StorageState.DENIED;
import static android.permission2.cts.RestrictedStoragePermissionSharedUidTest.StorageState.ISOLATED;
import static android.permission2.cts.RestrictedStoragePermissionSharedUidTest.StorageState.NON_ISOLATED;

import static com.android.compatibility.common.util.SystemUtil.eventually;
import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static com.google.common.truth.Truth.assertWithMessage;

import static java.lang.Integer.min;

import android.app.AppOpsManager;
import android.content.Context;
import android.content.pm.PackageManager;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

import java.util.ArrayList;

@AppModeFull(reason = ""Instant apps cannot access other app's properties"")
@RunWith(Parameterized.class)
public class RestrictedStoragePermissionSharedUidTest {
    private static final String LOG_TAG =
            RestrictedStoragePermissionSharedUidTest.class.getSimpleName();

    public enum StorageState {
        /** The app has non-isolated storage */
        NON_ISOLATED,

        /** The app has isolated storage */
        ISOLATED,

        /** The read-external-storage permission cannot be granted */
        DENIED
    }

    /**
     * An app that is tested
     */
    private static class TestApp {
        private static @NonNull Context sContext =
                InstrumentationRegistry.getInstrumentation().getContext();
        private static @NonNull AppOpsManager sAppOpsManager =
                sContext.getSystemService(AppOpsManager.class);
        private static @NonNull PackageManager sPackageManager = sContext.getPackageManager();

        private final String mApk;
        private final String mPkg;

        public final boolean isRestricted;
        public final boolean hasRequestedLegacyExternalStorage;

        TestApp(@NonNull String apk, @NonNull String pkg, boolean isRestricted,
                @NonNull boolean hasRequestedLegacyExternalStorage) {
            mApk = apk;
            mPkg = pkg;

            this.isRestricted = isRestricted;
            this.hasRequestedLegacyExternalStorage = hasRequestedLegacyExternalStorage;
        }

        /**
         * Assert that the read-external-storage permission was granted or not granted.
         *
         * @param expectGranted {@code true} if the permission is expected to be granted
         */
        void assertStoragePermGranted(boolean expectGranted) {
            eventually(() -> assertWithMessage(this + "" read storage granted"").that(
                    isGranted(mPkg, READ_EXTERNAL_STORAGE)).isEqualTo(expectGranted));
        }

        /**
         * Assert that the app has non-isolated storage
         *
         * @param expectGranted {@code true} if the app is expected to have non-isolated storage
         */
        void assertHasNotIsolatedStorage(boolean expectHasNotIsolatedStorage) {
            eventually(() -> runWithShellPermissionIdentity(() -> {
                int uid = sContext.getPackageManager().getPackageUid(mPkg, 0);
                if (expectHasNotIsolatedStorage) {
                    assertWithMessage(this + "" legacy storage mode"").that(
                            sAppOpsManager.unsafeCheckOpRawNoThrow(OPSTR_LEGACY_STORAGE, uid,
                            mPkg)).isEqualTo(MODE_ALLOWED);
                } else {
                    assertWithMessage(this + "" legacy storage mode"").that(
                            sAppOpsManager.unsafeCheckOpRawNoThrow(OPSTR_LEGACY_STORAGE, uid,
                            mPkg)).isNotEqualTo(MODE_ALLOWED);
                }
            }));
        }

        int getTargetSDK() throws Exception {
            return sPackageManager.getApplicationInfo(mPkg, 0).targetSdkVersion;
        }

        void install() {
            if (isRestricted) {
                runShellCommand(""pm install -g --force-queryable --restrict-permissions "" + mApk);
            } else {
                runShellCommand(""pm install -g --force-queryable "" + mApk);
            }
        }

        void uninstall() {
            runShellCommand(""pm uninstall "" + mPkg);
        }

        @Override
        public String toString() {
            return mPkg.substring(PKG_PREFIX.length());
        }
    }

    /**
     * Placeholder for ""no app"". The properties are chosen that when combined with another app, the
     * other app always decides the resulting property,
     */
    private static class NoApp extends TestApp {
        NoApp() {
            super("""", PKG_PREFIX + ""(none)"", true, false);
        }

        void assertStoragePermGranted(boolean ignored) {
            // empty
        }

        void assertHasNotIsolatedStorage(boolean ignored) {
            // empty
        }

        @Override
        int getTargetSDK() {
            return 10000;
        }

        @Override
        public void install() {
            // empty
        }

        @Override
        public void uninstall() {
            // empty
        }
    }

    private static final String APK_PATH = ""/data/local/tmp/cts/permissions2/"";
    private static final String PKG_PREFIX = ""android.permission2.cts.legacystoragewithshareduid."";

    private static final TestApp[] TEST_APPS = new TestApp[]{
            new TestApp(APK_PATH + ""CtsLegacyStorageNotIsolatedWithSharedUid.apk"",
                    PKG_PREFIX + ""notisolated"", false, true),
            new TestApp(APK_PATH + ""CtsLegacyStorageIsolatedWithSharedUid.apk"",
                    PKG_PREFIX + ""isolated"", false, false),
            new TestApp(APK_PATH + ""CtsLegacyStorageRestrictedWithSharedUid.apk"",
                    PKG_PREFIX + ""restricted"", true, false),
            new TestApp(APK_PATH + ""CtsLegacyStorageRestrictedSdk28WithSharedUid.apk"",
                    PKG_PREFIX + ""restrictedsdk28"", true, true),
            new NoApp()};

    /**
     * First app to be tested. This is the first in an entry created by {@link
     * #getTestAppCombinations}
     */
    @Parameter(0)
    public @NonNull TestApp app1;

    /**
     * Second app to be tested. This is the second in an entry created by {@link
     * #getTestAppCombinations}
     */
    @Parameter(1)
    public @NonNull TestApp app2;

    /**
     * Run this test for all combination of two tests-apps out of {@link #TEST_APPS}. This includes
     * the {@link NoApp}, i.e. we also test a single test-app by itself.
     *
     * @return All combinations of two test-apps
     */
    @Parameters(name = ""{0} and {1}"")
    public static Iterable<Object[]> getTestAppCombinations() {
        ArrayList<Object[]> parameters = new ArrayList<>();

        for (int firstApp = 0; firstApp < TEST_APPS.length; firstApp++) {
            for (int secondApp = firstApp + 1; secondApp < TEST_APPS.length; secondApp++) {
                parameters.add(new Object[]{TEST_APPS[firstApp], TEST_APPS[secondApp]});
            }
        }

        return parameters;
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedStoragePermissionSharedUidTest"	"uninstallAllTestPackages"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionSharedUidTest.java"	""	"public void checkExceptedStorageStateForAppsSharingUid() throws Exception {
        app1.install();
        app2.install();

        int targetSDK = min(app1.getTargetSDK(), app2.getTargetSDK());
        boolean isRestricted = app1.isRestricted && app2.isRestricted;
        boolean hasRequestedLegacyExternalStorage =
                app1.hasRequestedLegacyExternalStorage || app2.hasRequestedLegacyExternalStorage;

        StorageState expectedState;
        if (isRestricted) {
            if (targetSDK < Build.VERSION_CODES.Q) {
                expectedState = DENIED;
            } else {
                expectedState = ISOLATED;
            }
        } else if (hasRequestedLegacyExternalStorage && targetSDK <= Build.VERSION_CODES.Q) {
            expectedState = NON_ISOLATED;
        } else {
            expectedState = ISOLATED;
        }

        Log.i(LOG_TAG, ""Expected state="" + expectedState);

        app1.assertStoragePermGranted(expectedState != DENIED);
        app2.assertStoragePermGranted(expectedState != DENIED);

        if (expectedState != DENIED) {
            app1.assertHasNotIsolatedStorage(expectedState == NON_ISOLATED);
            app2.assertHasNotIsolatedStorage(expectedState == NON_ISOLATED);
        }
    }

    @After
    public void uninstallAllTestPackages() {
        app1.uninstall();
        app2.uninstall();
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.AppIdleHostTest"	"testAppIsNotIdleAfterBeingLaunched"	"CtsAppUsageHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/usage/src/android/app/usage/cts/AppIdleHostTest.java"	""	"public void testAppIsNotIdleAfterBeingLaunched() throws Exception {
        startAndStopTestApp();
        assertFalse(isAppIdle(TEST_APP_PACKAGE));
    }

    private void setAppStandbyBucket(String packageName, int bucket) throws Exception {
        mDevice.executeShellCommand(
                String.format(""am set-standby-bucket %s %s"", packageName, bucket));
    }

    private boolean isAppStandbyEnabled() throws DeviceNotAvailableException {
        final String result = mDevice.executeShellCommand(
                ""dumpsys usagestats is-app-standby-enabled"").trim();
        return Boolean.parseBoolean(result);
    }

    private int getAppStandbyBucket(String packageName) throws Exception {
        String bucketString = mDevice.executeShellCommand(
                String.format(""am get-standby-bucket %s"", packageName));
        try {
            return Integer.parseInt(bucketString.trim());
        } catch (NumberFormatException nfe) {
        }
        return -1;
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.AppIdleHostTest"	"testSetAppStandbyBucket"	"CtsAppUsageHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/usage/src/android/app/usage/cts/AppIdleHostTest.java"	""	"public void testSetAppStandbyBucket() throws Exception {
        assumeTrue(""App standby not enabled on device"", isAppStandbyEnabled());
        // Set to ACTIVE
        setAppStandbyBucket(TEST_APP_PACKAGE, SB_ACTIVE);
        assertEquals(SB_ACTIVE, getAppStandbyBucket(TEST_APP_PACKAGE));
        // set to WORKING_SET
        setAppStandbyBucket(TEST_APP_PACKAGE, 20);
        assertEquals(20, getAppStandbyBucket(TEST_APP_PACKAGE));
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.AppIdleHostTest"	"testSetAppStandbyBuckets"	"CtsAppUsageHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/usage/src/android/app/usage/cts/AppIdleHostTest.java"	""	"public void testSetAppStandbyBuckets() throws Exception {
        assumeTrue(""App standby not enabled on device"", isAppStandbyEnabled());
        // Set multiple packages states
        String command = String.format(""am set-standby-bucket %s %d %s %d"",
                TEST_APP_PACKAGE, SB_FREQUENT, TEST_APP_PACKAGE2, SB_WORKING_SET);
        mDevice.executeShellCommand(command);
        assertEquals(SB_FREQUENT, getAppStandbyBucket(TEST_APP_PACKAGE));
        assertEquals(SB_WORKING_SET, getAppStandbyBucket(TEST_APP_PACKAGE2));
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.AppIdleHostTest"	"testCantSetOwnStandbyBucket"	"CtsAppUsageHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/usage/src/android/app/usage/cts/AppIdleHostTest.java"	""	"public void testCantSetOwnStandbyBucket() throws Exception {
        assumeTrue(""App standby not enabled on device"", isAppStandbyEnabled());
        setAppStandbyBucket(""com.android.shell"", 40);
        assertNotEquals(40, getAppStandbyBucket(""com.android.shell""));
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.AppIdleHostTest"	"testOutOfBoundsStandbyBucket"	"CtsAppUsageHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/usage/src/android/app/usage/cts/AppIdleHostTest.java"	""	"public void testOutOfBoundsStandbyBucket() throws Exception {
        assumeTrue(""App standby not enabled on device"", isAppStandbyEnabled());
        setAppStandbyBucket(TEST_APP_PACKAGE, SB_ACTIVE);
        assertEquals(SB_ACTIVE, getAppStandbyBucket(TEST_APP_PACKAGE));
        // Try lower than min
        setAppStandbyBucket(TEST_APP_PACKAGE, SB_ACTIVE - 1);
        assertEquals(SB_ACTIVE, getAppStandbyBucket(TEST_APP_PACKAGE));
        // Try higher than max
        setAppStandbyBucket(TEST_APP_PACKAGE, 50 + 1);
        assertEquals(SB_ACTIVE, getAppStandbyBucket(TEST_APP_PACKAGE));
    }

    private static void sleepUninterrupted(long timeMillis) {
        boolean interrupted;
        do {
            try {
                Thread.sleep(timeMillis);
                interrupted = false;
            } catch (InterruptedException e) {
                interrupted = true;
            }
        } while (interrupted);
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyAttestationTest"	"testEcAttestation_NoChallenge"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyAttestationTest.java"	""	"public void testEcAttestation_NoChallenge() throws Exception {
        boolean[] devicePropertiesAttestationValues = {true, false};
        for (boolean devicePropertiesAttestation : devicePropertiesAttestationValues) {
            String keystoreAlias = ""test_key"";
            Date now = new Date();
            Date originationEnd = new Date(now.getTime() + ORIGINATION_TIME_OFFSET);
            Date consumptionEnd = new Date(now.getTime() + CONSUMPTION_TIME_OFFSET);
            KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(keystoreAlias, PURPOSE_SIGN)
                    .setAlgorithmParameterSpec(new ECGenParameterSpec(""secp256r1""))
                    .setDigests(DIGEST_NONE, DIGEST_SHA256, DIGEST_SHA512)
                    .setAttestationChallenge(null)
                    .setKeyValidityStart(now)
                    .setKeyValidityForOriginationEnd(originationEnd)
                    .setKeyValidityForConsumptionEnd(consumptionEnd)
                    .setDevicePropertiesAttestationIncluded(devicePropertiesAttestation)
                    .build();

            generateKeyPair(KEY_ALGORITHM_EC, spec);

            KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
            keyStore.load(null);

            try {
                Certificate certificates[] = keyStore.getCertificateChain(keystoreAlias);
                assertEquals(1, certificates.length);

                X509Certificate attestationCert = (X509Certificate) certificates[0];
                assertNull(attestationCert.getExtensionValue(Attestation.ASN1_OID));
                assertNull(attestationCert.getExtensionValue(Attestation.EAT_OID));
            } finally {
                keyStore.deleteEntry(keystoreAlias);
            }
        }
    }

    @RestrictedBuildTest
    @RequiresDevice"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyAttestationTest"	"testRsaAttestation_NoChallenge"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyAttestationTest.java"	""	"public void testRsaAttestation_NoChallenge() throws Exception {
        boolean[] devicePropertiesAttestationValues = {true, false};
        for (boolean devicePropertiesAttestation : devicePropertiesAttestationValues) {
            String keystoreAlias = ""test_key"";
            Date now = new Date();
            Date originationEnd = new Date(now.getTime() + ORIGINATION_TIME_OFFSET);
            Date consumptionEnd = new Date(now.getTime() + CONSUMPTION_TIME_OFFSET);
            KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(keystoreAlias, PURPOSE_SIGN)
                    .setDigests(DIGEST_NONE, DIGEST_SHA256, DIGEST_SHA512)
                    .setAttestationChallenge(null)
                    .setKeyValidityStart(now)
                    .setKeyValidityForOriginationEnd(originationEnd)
                    .setKeyValidityForConsumptionEnd(consumptionEnd)
                    .setDevicePropertiesAttestationIncluded(devicePropertiesAttestation)
                    .build();

            generateKeyPair(KEY_ALGORITHM_RSA, spec);

            KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
            keyStore.load(null);

            try {
                Certificate certificates[] = keyStore.getCertificateChain(keystoreAlias);
                assertEquals(1, certificates.length);

                X509Certificate attestationCert = (X509Certificate) certificates[0];
                assertNull(attestationCert.getExtensionValue(Attestation.ASN1_OID));
            } finally {
                keyStore.deleteEntry(keystoreAlias);
            }
        }
    }

    @RestrictedBuildTest
    @RequiresDevice  // Emulators have no place to store the needed key"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.print.cts.PrintDocumentInfoTest"	"createFirstMockDiscoverySessionCallbacks"	"CtsPrintTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/PrintDocumentInfoTest.java"	""	"/*
 *.
 */

package android.print.cts;

import static android.print.test.Utils.eventually;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import android.os.ParcelFileDescriptor;
import android.print.PageRange;
import android.print.PrintAttributes;
import android.print.PrintAttributes.Margins;
import android.print.PrintAttributes.MediaSize;
import android.print.PrintAttributes.Resolution;
import android.print.PrintDocumentAdapter;
import android.print.PrintDocumentAdapter.LayoutResultCallback;
import android.print.PrintDocumentAdapter.WriteResultCallback;
import android.print.PrintDocumentInfo;
import android.print.PrinterCapabilitiesInfo;
import android.print.PrinterId;
import android.print.PrinterInfo;
import android.print.test.BasePrintTest;
import android.print.test.services.FirstPrintService;
import android.print.test.services.PrintServiceCallbacks;
import android.print.test.services.PrinterDiscoverySessionCallbacks;
import android.print.test.services.SecondPrintService;
import android.print.test.services.StubbablePrinterDiscoverySession;
import android.printservice.PrintJob;
import android.printservice.PrintService;

import androidx.test.runner.AndroidJUnit4;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * This test verifies that the system respects the {@link PrintDocumentAdapter}
 * contract and invokes all callbacks as expected.
 */
@RunWith(AndroidJUnit4.class)
public class PrintDocumentInfoTest extends BasePrintTest {
    private static boolean sIsDefaultPrinterSet;

    @Before
    public void setDefaultPrinter() throws Throwable {
        if (!sIsDefaultPrinterSet) {
            // Create a callback for the target print service.
            FirstPrintService.setCallbacks(createFirstMockPrintServiceCallbacks());
            SecondPrintService.setCallbacks(createSecondMockPrintServiceCallbacks());

            // Create a mock print adapter.
            final PrintDocumentAdapter adapter = createDefaultPrintDocumentAdapter(1);

            makeDefaultPrinter(adapter, ""First printer"");
            resetCounters();

            sIsDefaultPrinterSet = true;
        }
    }

    /**
     * Executes a print process with a given print document info
     *
     * @param name The name of the document info
     * @param contentType The content type of the document
     * @param pageCount The number of pages in the document
     */
    private void printDocumentBaseTest(String name, Integer contentType, Integer pageCount)
            throws Throwable {
        FirstPrintService.setCallbacks(createFirstMockPrintServiceCallbacks());
        SecondPrintService.setCallbacks(createSecondMockPrintServiceCallbacks());

        PrintDocumentInfo.Builder b = new PrintDocumentInfo.Builder(name);
        if (contentType != null) {
            b.setContentType(contentType);
        }
        if (pageCount != null) {
            b.setPageCount(pageCount);
        }
        PrintDocumentInfo info = b.build();

        PrintDocumentInfo queuedInfo[] = new PrintDocumentInfo[1];
        ParcelFileDescriptor queuedData[] = new ParcelFileDescriptor[1];

        PrinterDiscoverySessionCallbacks printerDiscoverySessionCallbacks =
                createFirstMockDiscoverySessionCallbacks();
        PrintServiceCallbacks printServiceCallbacks = createMockPrintServiceCallbacks(
                invocation -> printerDiscoverySessionCallbacks,
                invocation -> {
                    PrintJob printJob = (PrintJob) invocation.getArguments()[0];
                    synchronized (queuedInfo) {
                        queuedInfo[0] = printJob.getDocument().getInfo();
                        queuedData[0] = printJob.getDocument().getData();
                    }
                    printJob.complete();
                    onPrintJobQueuedCalled();
                    return null;
                }, null);

        FirstPrintService.setCallbacks(printServiceCallbacks);

        final PrintAttributes[] printAttributes = new PrintAttributes[1];

        // Create a mock print adapter.
        final PrintDocumentAdapter adapter = createMockPrintDocumentAdapter(
                invocation -> {
                    printAttributes[0] = (PrintAttributes) invocation.getArguments()[1];
                    LayoutResultCallback callback = (LayoutResultCallback) invocation
                            .getArguments()[3];
                    callback.onLayoutFinished(info, false);
                    return null;
                }, invocation -> {
                    Object[] args = invocation.getArguments();
                    ParcelFileDescriptor fd = (ParcelFileDescriptor) args[1];
                    WriteResultCallback callback = (WriteResultCallback) args[3];
                    writeBlankPages(printAttributes[0], fd, 0, 1);
                    fd.close();
                    if (pageCount != null && pageCount > 0) {
                        callback.onWriteFinished(new PageRange[]{new PageRange(0, pageCount - 1)});
                    } else {
                        callback.onWriteFinished(new PageRange[]{new PageRange(0, 1)});
                    }
                    onWriteCalled();
                    return null;
                }, invocation -> null);

        // Start printing.
        print(adapter);

        // Wait for layout.
        waitForWriteAdapterCallback(1);

        // Click the print button.
        mPrintHelper.submitPrintJob();

        // Wait for the session to be destroyed to isolate tests.
        waitForPrinterDiscoverySessionDestroyCallbackCalled(1);
        waitForServiceOnPrintJobQueuedCallbackCalled(1);

        // Check that the document name was carried over 1:1
        eventually(() -> {
            synchronized (queuedInfo) {
                assertEquals(name, queuedInfo[0].getName());
            }
        });

        // Content type is set to document by default, but is otherwise unrestricted
        if (contentType != null) {
            assertEquals(contentType, Integer.valueOf(queuedInfo[0].getContentType()));
        } else {
            assertEquals(PrintDocumentInfo.CONTENT_TYPE_DOCUMENT, queuedInfo[0].getContentType());
        }

        // Page count is set to the real value if unknown, 0 or unset.
        // Otherwise the set value is used
        if (pageCount != null && pageCount != PrintDocumentInfo.PAGE_COUNT_UNKNOWN
                && pageCount != 0) {
            assertEquals(pageCount, Integer.valueOf(queuedInfo[0].getPageCount()));
        } else {
            assertEquals(2, queuedInfo[0].getPageCount());
        }

        // Verify data (== pdf file) size
        assertTrue(queuedInfo[0].getDataSize() > 0);

        long bytesRead = 0;
        try (FileInputStream is = new FileInputStream(queuedData[0].getFileDescriptor())) {
            while (true) {
                int ret = is.read();
                if (ret == -1) {
                    break;
                }
                bytesRead++;
            }
        }
        assertEquals(queuedInfo[0].getDataSize(), bytesRead);
    }

    /**
     * Test that the default values of the PrintDocumentInfo are fine.
     *
     * @throws Exception If anything unexpected happens
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.media.session.cts.MediaSessionManagerHostTest"	"testGetActiveSessionsFull_additionalUser"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/session/cts/MediaSessionManagerHostTest.java"	""	"public void testGetActiveSessionsFull_additionalUser() throws Exception {
        testGetActiveSessions_additionalUser(false);
    }

    private void testGetActiveSessions_additionalUser(boolean instant) throws Exception {
        if (!canCreateAdditionalUsers(1)) {
            CLog.logAndDisplay(LogLevel.INFO,
                    ""Cannot create a new user. Skipping multi-user test cases."");
            return;
        }

        // Test if another user can get the session.
        int newUser = createAndStartUser();
        installAppAsUser(DEVICE_SIDE_TEST_APK, newUser, instant);
        setAllowGetActiveSessionForTest(true, newUser);
        runTestAsUser(""testGetActiveSessions_noMediaSession"", newUser);
        removeUser(newUser);
    }

    /**
     * Tests {@link MediaSessionManager#getActiveSessions} with restricted profiles.
     */
    @AppModeInstant
    @RequiresDevice"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.media.session.cts.MediaSessionManagerHostTest"	"testGetActiveSessionsInstant_restrictedProfiles"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/session/cts/MediaSessionManagerHostTest.java"	""	"public void testGetActiveSessionsInstant_restrictedProfiles() throws Exception {
        testGetActiveSessions_restrictedProfiles(true);
    }

    /**
     * Tests {@link MediaSessionManager#getActiveSessions} with restricted profiles.
     */
    @AppModeFull
    @RequiresDevice"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.media.session.cts.MediaSessionManagerHostTest"	"testGetActiveSessionsFull_restrictedProfiles"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/session/cts/MediaSessionManagerHostTest.java"	""	"public void testGetActiveSessionsFull_restrictedProfiles() throws Exception {
        testGetActiveSessions_restrictedProfiles(false);
    }

    private void testGetActiveSessions_restrictedProfiles(boolean instant)
            throws Exception {
        if (!canCreateAdditionalUsers(1)) {
            CLog.logAndDisplay(LogLevel.INFO,
                    ""Cannot create a new user. Skipping multi-user test cases."");
            return;
        }

        // Test if another restricted profile can get the session.
        // Remove the created user first not to exceed system's user number limit.
        int newUser = createAndStartRestrictedProfile(getDevice().getPrimaryUserId());
        installAppAsUser(DEVICE_SIDE_TEST_APK, newUser, instant);
        setAllowGetActiveSessionForTest(true, newUser);
        runTestAsUser(""testGetActiveSessions_noMediaSession"", newUser);
        removeUser(newUser);
    }

    /**
     * Tests {@link MediaSessionManager#getActiveSessions} with managed profiles.
     */
    @AppModeInstant
    @RequiresDevice"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.media.cts.AudioRecordTest"	"testRestrictedAudioSourcePermissions"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioRecordTest.java"	""	"public void testRestrictedAudioSourcePermissions() throws Exception {
        // Make sure that the following audio sources cannot be used by apps that
        // don't have the CAPTURE_AUDIO_OUTPUT permissions:
        // - VOICE_CALL,
        // - VOICE_DOWNLINK
        // - VOICE_UPLINK
        // - REMOTE_SUBMIX
        // - ECHO_REFERENCE  - 1997
        // - RADIO_TUNER - 1998
        // - HOTWORD - 1999
        // The attempt to build an AudioRecord with those sources should throw either
        // UnsupportedOperationException or IllegalArgumentException exception.
        final int[] restrictedAudioSources = new int [] {
            MediaRecorder.AudioSource.VOICE_CALL,
            MediaRecorder.AudioSource.VOICE_DOWNLINK,
            MediaRecorder.AudioSource.VOICE_UPLINK,
            MediaRecorder.AudioSource.REMOTE_SUBMIX,
            1997,
            1998,
            1999
        };

        for (int source : restrictedAudioSources) {
            // AudioRecord.Builder should fail when trying to use
            // one of the voice call audio sources.
            try {
                AudioRecord ar = new AudioRecord.Builder()
                 .setAudioSource(source)
                 .setAudioFormat(new AudioFormat.Builder()
                         .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                         .setSampleRate(8000)
                         .setChannelMask(AudioFormat.CHANNEL_IN_MONO)
                         .build())
                 .build();
                fail(""testRestrictedAudioSourcePermissions: no exception thrown for source: ""
                        + source);
            } catch (Exception e) {
                Log.i(TAG, ""Exception: "" + e);
                if (!UnsupportedOperationException.class.isInstance(e)
                        && !IllegalArgumentException.class.isInstance(e)) {
                    fail(""testRestrictedAudioSourcePermissions: no exception thrown for source: ""
                        + source + "" Exception:"" + e);
                }
            }
        }
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.appsearch.external.app.AppSearchSessionCtsTestBase"	"testRemoveByQuery_packageFilter"	"CtsAppSearchTestCases"	"/home/gpoor/cts-12-source/cts/tests/appsearch/src/com/android/cts/appsearch/external/app/AppSearchSessionCtsTestBase.java"	""	"public void testRemoveByQuery_packageFilter() throws Exception {
        // Schema registration
        mDb1.setSchema(new SetSchemaRequest.Builder().addSchemas(AppSearchEmail.SCHEMA).build())
                .get();

        // Index documents
        AppSearchEmail email =
                new AppSearchEmail.Builder(""namespace"", ""id1"")
                        .setFrom(""from@example.com"")
                        .setTo(""to1@example.com"", ""to2@example.com"")
                        .setSubject(""foo"")
                        .setBody(""This is the body of the testPut email"")
                        .build();
        checkIsBatchResultSuccess(
                mDb1.put(new PutDocumentsRequest.Builder().addGenericDocuments(email).build()));

        // Check the presence of the documents
        assertThat(doGet(mDb1, ""namespace"", ""id1"")).hasSize(1);

        // Try to delete email with query ""foo"", but restricted to a different package name.
        // Won't work and email will still exist.
        mDb1.remove(
                        ""foo"",
                        new SearchSpec.Builder()
                                .setTermMatch(SearchSpec.TERM_MATCH_PREFIX)
                                .addFilterPackageNames(""some.other.package"")
                                .build())
                .get();
        assertThat(doGet(mDb1, ""namespace"", ""id1"")).hasSize(1);

        // Delete the email by query ""foo"", restricted to the correct package this time.
        mDb1.remove(
                        ""foo"",
                        new SearchSpec.Builder()
                                .setTermMatch(SearchSpec.TERM_MATCH_PREFIX)
                                .addFilterPackageNames(
                                        ApplicationProvider.getApplicationContext()
                                                .getPackageName())
                                .build())
                .get();
        AppSearchBatchResult<String, GenericDocument> getResult =
                mDb1.getByDocumentId(
                                new GetByDocumentIdRequest.Builder(""namespace"")
                                        .addIds(""id1"", ""id2"")
                                        .build())
                        .get();
        assertThat(getResult.isSuccess()).isFalse();
        assertThat(getResult.getFailures().get(""id1"").getResultCode())
                .isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.audio.USBRestrictRecordAActivity"	"LocalClickListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/USBRestrictRecordAActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import android.app.Activity;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.hardware.usb.UsbDevice;
import android.hardware.usb.UsbManager;
import android.Manifest;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import java.util.Collection;
import java.util.HashMap;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;  // needed to access resource in CTSVerifier project namespace.

/*
 * This tests the USB Restrict Record functionality for the explicit USB device open case
 *   (case ""A"").
 * The other 2 cases are:
 *   A SINGLE activity is invoked when a USB device is plugged in. (Case B)
 *   ONE OF A MULTIPLE activities is iUSBRestrictedRecordAActivity. (Case C)
 *
 * We are using simple single-character distiguishes to avoid really long class names.
 */
public class USBRestrictRecordAActivity extends PassFailButtons.Activity {
    private static final String TAG = ""USBRestrictRecordAActivity"";
    private static final boolean DEBUG = false;

    private LocalClickListener mButtonClickListener = new LocalClickListener();

    private Context mContext;

    // Test MUST be run WITHOUT record pemission
    private boolean mHasRecordPermission;

    // System USB stuff
    private UsbManager mUsbManager;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.usb_restrictrecord);

        findViewById(R.id.test_button).setOnClickListener(mButtonClickListener);

        mContext = this;

        mUsbManager = (UsbManager)getSystemService(Context.USB_SERVICE);

        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setInfoResources(R.string.audio_usb_restrict_record_test,
                R.string.audio_usb_restrict_record_entry, -1);

        mHasRecordPermission = hasRecordPermission();

        if (mHasRecordPermission) {
            TextView tx = findViewById(R.id.usb_restrictrecord_instructions);
            tx.setText(getResources().getString(R.string.audio_usb_restrict_permission_info));
        }
        findViewById(R.id.test_button).setEnabled(!mHasRecordPermission);
    }

    private boolean hasRecordPermission() {
        try {
            PackageManager pm = getPackageManager();
            PackageInfo packageInfo = pm.getPackageInfo(
                    getApplicationInfo().packageName, PackageManager.GET_PERMISSIONS);

            if (packageInfo.requestedPermissions != null) {
                for (String permission : packageInfo.requestedPermissions) {
                    if (permission.equals(Manifest.permission.RECORD_AUDIO)) {
                        return checkSelfPermission(permission) == PackageManager.PERMISSION_GRANTED;
                    }
                }
            }
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, ""Unable to load package's permissions"", e);
            Toast.makeText(this, R.string.runtime_permissions_error, Toast.LENGTH_SHORT).show();
        }
        return false;
    }

    public class LocalClickListener implements View.OnClickListener {
        @Override
        public void onClick(View view) {
            int id = view.getId();
            switch (id) {
                case R.id.test_button:
                    connectUSB(mContext);
                    break;
            }
        }
    }

    private class ConnectDeviceBroadcastReceiver extends BroadcastReceiver {
        private final String TAG = ""ConnectDeviceBroadcastReceiver"";
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (ACTION_USB_PERMISSION.equals(action)) {
                synchronized (this) {
                    getPassButton().setEnabled(true);

                    // These messages don't really matter
                    if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                        Toast.makeText(mContext, ""Permission Granted."", Toast.LENGTH_SHORT).show();
                    }
                    else {
                        Toast.makeText(mContext, ""Permission Denied."", Toast.LENGTH_SHORT).show();
                    }
                }
            }
        }
    }

    private static final String ACTION_USB_PERMISSION = ""com.android.usbdescriptors.USB_PERMISSION"";

    public void connectUSB(Context context) {
        HashMap<String, UsbDevice> deviceList = mUsbManager.getDeviceList();
        Collection<UsbDevice> deviceCollection = deviceList.values();
        Object[] devices = deviceCollection.toArray();
        if (devices.length > 0) {
            UsbDevice theDevice = (UsbDevice) devices[0];

            PendingIntent permissionIntent =
                    PendingIntent.getBroadcast(context, 0, new Intent(ACTION_USB_PERMISSION), PendingIntent.FLAG_MUTABLE_UNAUDITED);

            IntentFilter filter = new IntentFilter(ACTION_USB_PERMISSION);
            ConnectDeviceBroadcastReceiver usbReceiver =
                    new ConnectDeviceBroadcastReceiver();
            context.registerReceiver(usbReceiver, filter);

            mUsbManager.requestPermission(theDevice, permissionIntent);
        }
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.telephony4.cts.SimRestrictedApisTest"	"isSimCardPresent"	"CtsSimRestrictedApisTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony4/src/android/telephony4/cts/SimRestrictedApisTest.java"	""	"/*
 *.
 */

package android.telephony4.cts;

import static androidx.test.InstrumentationRegistry.getContext;

import static org.junit.Assert.fail;

import android.content.Context;
import android.telephony.SmsManager;
import android.telephony.TelephonyManager;
import org.junit.Before;
import org.junit.Test;

public class SimRestrictedApisTest {
    private static final byte[] TEST_PDU = { 0, 0 };
    private TelephonyManager mTelephonyManager;

    @Before
    public void setUp() throws Exception {
        mTelephonyManager =
                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
    }

    private boolean isSimCardPresent() {
        return mTelephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_NONE &&
                mTelephonyManager.getSimState() != TelephonyManager.SIM_STATE_ABSENT;
    }

    /**
     * Tests the SmsManager.injectSmsPdu() API. This makes a call to injectSmsPdu() API and expects
     * a SecurityException since the test apk is not signed by a certificate on the SIM.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testCreateDelegateTestInvalidSipMessages"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testCreateDelegateTestInvalidSipMessages() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        TransportInterfaces ifaces = new TransportInterfaces(getDefaultRequest(),
                Collections.emptySet(), 0);
        ifaces.connectAndVerify();

        // Verify restricted SIP request methods are not sent to the delegate.
        sendRestrictedRequestsAndVerifyFailed(ifaces.delegateConn);
        // Verify malformed messages are not sent to the delegate.
        sendInvalidRequestsAndVerifyFailed(ifaces.delegateConn);

        destroySipDelegateAndVerify(ifaces);
        assertEquals(""There should be no more delegates"", 0,
                ifaces.transport.getDelegates().size());
        verifyUpdateRegistrationCalled(ifaces.reg);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testActiveDialogPendingNewInvite"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testActiveDialogPendingNewInvite() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        TransportInterfaces ifaces = new TransportInterfaces(getDefaultRequest(),
                Collections.emptySet(), 0);
        ifaces.connect();
        // Send invite
        SipDialogAttributes attr = new SipDialogAttributes();
        sendChatInvite(attr, ifaces);
        // send close from app
        ifaces.delegateConn.disconnect(ifaces.manager,
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
        // Registration state will change to deregistering during this time.
        ifaces.delegateConn.setOperationCountDownLatch(1);
        ifaces.delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        assertTrue(ifaces.delegateConn.verifyDeregisteringStateContains(ONE_TO_ONE_CHAT_TAG,
                DelegateRegistrationState.DEREGISTERING_REASON_DESTROY_PENDING));
        // receive 200 OK
        receive200OkResponse(attr, ifaces);
        // Send ACK
        sendAck(attr, ifaces);
        // Send invite
        SipDialogAttributes attr2 = new SipDialogAttributes();
        attr2.addAcceptContactTag(ONE_TO_ONE_CHAT_TAG);
        // Should be denied because the transport is now restricted
        sendDeniedChatInvite(attr2, ifaces,
                SipDelegateManager.MESSAGE_FAILURE_REASON_DELEGATE_CLOSED);
        // Send BYE on original invite
        sendByeRequest(attr, ifaces);
        // destroy should not be called until cleanupSession is sent.
        assertFalse(ifaces.transport.isLatchCountDownFinished(
                TestSipTransport.LATCH_DESTROY_DELEGATE));
        ifaces.delegateConn.setOperationCountDownLatch(1);
        // Send the cleanup, which will trigger destroy to complete.
        ifaces.delegateConn.sendCleanupSession(attr.callId);
        ifaces.delegate.verifyCleanupSession(attr.callId);
        ifaces.transport.waitForLatchCountdownAndReset(TestSipTransport.LATCH_DESTROY_DELEGATE);
        ifaces.delegate.notifyOnDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
        ifaces.delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        ifaces.delegateConn.verifyDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);

        assertEquals(""There should be no more delegates"", 0,
                ifaces.transport.getDelegates().size());
        verifyUpdateRegistrationCalled(ifaces.reg);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIncomingInviteDeregistering"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	"public void testIncomingInviteDeregistering() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        TransportInterfaces ifaces = new TransportInterfaces(getDefaultRequest(),
                Collections.emptySet(), 0);
        ifaces.connect();
        // move chat to deregistering
        Set<String> regFeatures = new ArraySet<>(Arrays.asList(DEFAULT_FEATURE_TAGS));
        regFeatures.remove(ONE_TO_ONE_CHAT_TAG);
        DelegateRegistrationState state = getDeregisteringState(regFeatures,
                Collections.singleton(ONE_TO_ONE_CHAT_TAG),
                DelegateRegistrationState.DEREGISTERING_REASON_PROVISIONING_CHANGE);
        verifyRegistrationState(ifaces, state);
        // receive invite, which can not be blocked
        SipDialogAttributes attr = new SipDialogAttributes();
        receiveChatInvite(attr, ifaces);
        // ensure delegate connection can still respond to the request, even if in restricted state.
        send200OkResponse(attr, ifaces);
        receiveAck(attr, ifaces);
        // receive BYE and clean up
        receiveByeRequest(attr, ifaces);
        ifaces.delegateConn.sendCleanupSession(attr.callId);
        ifaces.delegate.verifyCleanupSession(attr.callId);

        destroySipDelegateAndVerify(ifaces);
        assertEquals(""There should be no more delegates"", 0,
                ifaces.transport.getDelegates().size());
        verifyUpdateRegistrationCalled(ifaces.reg);
    }

    private SipMessage generateSipMessage(String str) {
        String crlf = ""\r\n"";
        String[] components = str.split(crlf);
        String startLine = """";
        String header = """";
        String content = """";
        StringBuilder sb = new StringBuilder();
        int idx = 1;
        if (components.length > 0) {
            startLine = components[0] + crlf;
        }
        // generate sip header
        idx = composeSipSection(idx, components, sb);
        header = sb.toString();

        idx++;
        sb.setLength(0);
        // generate sip body
        idx = composeSipSection(idx, components, sb);
        content = sb.toString();

        return new SipMessage(startLine, header, content.getBytes(UTF_8));
    }

    private int composeSipSection(int index, String[] components, StringBuilder sb) {
        String crlf = ""\r\n"";
        while (index < components.length) {
            if (components[index].length() > 0) {
                sb.append(components[index]).append(crlf);
                index++;
            } else {
                break;
            }
        }
        return index;
    }

    private void sendChatInvite(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        SipDialogAttributes invAttr = attr.fromExisting().copyWithNewBranch();
        invAttr.addAcceptContactTag(ONE_TO_ONE_CHAT_TAG);
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.INVITE_SIP_METHOD,
                invAttr);
        sendMessageAndVerifyAck(invite, ifaces);
    }

    private void sendDeniedChatInvite(SipDialogAttributes attr,
            TransportInterfaces ifaces, int denyReason) throws Exception {
        SipDialogAttributes invAttr = attr.fromExisting().copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.INVITE_SIP_METHOD,
                invAttr);
        ifaces.delegateConn.sendMessageAndVerifyFailure(invite, denyReason);
    }

    private void receiveChatInvite(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        SipDialogAttributes invAttr = attr.fromExisting().copyWithNewBranch();
        invAttr.addAcceptContactTag(ONE_TO_ONE_CHAT_TAG);
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.INVITE_SIP_METHOD,
                invAttr);
        receiveMessageAndVerifyAck(invite, ifaces);
    }

    private void send200OkResponse(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr.setToTag();
        // do not update branch here, as it is a response to a request.
        SipMessage resp = SipMessageUtils.generateSipResponse(""200"", ""OK"",
                attr);
        sendMessageAndVerifyAck(resp, ifaces);
    }

    private void receive200OkResponse(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr.setToTag();
        // do not update branch here, as it is a response to a request.
        SipMessage resp = SipMessageUtils.generateSipResponse(""200"", ""OK"",
                attr);
        receiveMessageAndVerifyAck(resp, ifaces);
    }

    private void sendAck(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.ACK_SIP_METHOD,
                attr);
        sendMessageAndVerifyAck(invite, ifaces);
    }

    private void receiveAck(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.ACK_SIP_METHOD,
                attr);
        receiveMessageAndVerifyAck(invite, ifaces);
    }

    private void sendByeRequest(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.BYE_SIP_METHOD,
                attr);
        sendMessageAndVerifyAck(invite, ifaces);
    }

    private void receiveByeRequest(SipDialogAttributes attr,
            TransportInterfaces ifaces) throws Exception {
        attr = attr.copyWithNewBranch();
        SipMessage invite = SipMessageUtils.generateSipRequest(SipMessageUtils.BYE_SIP_METHOD,
                attr);
        receiveMessageAndVerifyAck(invite, ifaces);
    }

    private void createSipDelegateConnectionNoDelegateExpected(SipDelegateManager manager,
            TestSipDelegateConnection conn, TestSipTransport transport) throws Exception {
        // wait for onCreated and reg state changed
        conn.setOperationCountDownLatch(2);
        conn.connect(manager);
        conn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        conn.verifyDelegateCreated();
        conn.verifyRegistrationStateEmpty();
        // All requested features should have been denied due to the app not being the default sms
        // app.
        conn.verifyAllDenied(SipDelegateManager.DENIED_REASON_NOT_ALLOWED);
        // There should not have been a call to create a SipDelegate on the service side, since all
        // features were denied due to permissions issues.
        assertEquals(""SipDelegate should not have been created"", 0,
                transport.getDelegates().size());
    }

    private void destroySipDelegateConnectionNoDelegate(SipDelegateManager manager,
            TestSipDelegateConnection delegateConn) throws Exception {
        delegateConn.setOperationCountDownLatch(1);
        delegateConn.disconnect(manager,
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
    }

    private void destroySipDelegate(SipDelegateManager manager,
            TestSipTransport transportImpl, TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        delegateConn.disconnect(manager,
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
        transportImpl.waitForLatchCountdownAndReset(TestSipTransport.LATCH_DESTROY_DELEGATE);
        delegate.notifyOnDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);

    }

    private void destroySipDelegateAndVerifyConnDestroyed(SipDelegateManager manager,
            TestSipTransport transportImpl, TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        delegateConn.setOperationCountDownLatch(1);
        destroySipDelegate(manager, transportImpl, delegateConn, delegate);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
    }

    private void destroySipDelegateAndVerify(TransportInterfaces ifaces) throws Exception {
        // wait for on destroyed
        destroySipDelegateAndVerifyConnDestroyed(ifaces.manager, ifaces.transport,
                ifaces.delegateConn, ifaces.delegate);
    }

    private void verifySipDelegateDestroyed(TestSipTransport transportImpl,
            TestSipDelegate delegate) {
        transportImpl.waitForLatchCountdownAndReset(TestSipTransport.LATCH_DESTROY_DELEGATE);
        delegate.notifyOnDestroyed(
                SipDelegateManager.SIP_DELEGATE_DESTROY_REASON_REQUESTED_BY_APP);
    }

    private TestSipDelegate createSipDelegateConnectionAndVerify(SipDelegateManager manager,
            TestSipDelegateConnection conn, TestSipTransport transport,
            Set<FeatureTagState>  deniedTags, int delegateIndex) throws Exception {
        conn.setOperationCountDownLatch(1);
        conn.connect(manager);
        TestSipDelegate d = getSipDelegate(transport, deniedTags, delegateIndex);
        conn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        conn.verifyDelegateCreated();
        return d;
    }

    private TestSipDelegate getSipDelegate(TestSipTransport transport,
            Set<FeatureTagState> deniedTags, int delegateIndex) {
        transport.waitForLatchCountdownAndReset(TestSipTransport.LATCH_CREATE_DELEGATE);
        // There must have been a call to create a SipDelegate on the service side.
        assertEquals(""SipDelegate should have been created"", delegateIndex + 1,
                transport.getDelegates().size());
        TestSipDelegate d = transport.getDelegates().get(delegateIndex);
        d.notifyOnCreated(deniedTags);
        return d;
    }

    private void verifyRegisteredAndSendSipConfig(TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate, Set<String> registeredTags,
            Set<FeatureTagState> deniedTags, SipDelegateConfiguration sipConfig) {
        // wait for reg change to be called
        delegateConn.setOperationCountDownLatch(1);
        DelegateRegistrationState s = getRegisteredRegistrationState(registeredTags);
        delegate.notifyImsRegistrationUpdate(s);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyRegistrationStateRegistered(registeredTags);
        delegateConn.verifyDenied(deniedTags);

        // send config change as well.
        sendConfigChange(sipConfig, delegateConn, delegate);
    }

    private Set<FeatureTagState> generateDeniedSetFromRequest(Set<String> grantedTags,
            Set<String> newTags, int reason) {
        // Deny features from newTags that are already granted in grantedTags.
        return grantedTags.stream().filter(newTags::contains)
                .map(s -> new FeatureTagState(s, reason))
                .collect(Collectors.toSet());
    }

    private void verifyUpdateRegistrationCalled(TestImsRegistration regImpl) {
        regImpl.resetLatch(TestImsRegistration.LATCH_UPDATE_REGISTRATION, 1);
        // it is okay to reset and wait here (without race conditions) because there is a
        // second delay between triggering update registration and the latch being triggered.
        assertTrue(regImpl.waitForLatchCountDown(TestImsRegistration.LATCH_UPDATE_REGISTRATION,
                ImsUtils.TEST_TIMEOUT_MS));
    }

    private void sendRestrictedRequestsAndVerifyFailed(
            TestSipDelegateConnection delegateConn) throws Exception {
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_INVALID_SIP_REGISTER,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_INVALID_SIP_PUBLISH,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_INVALID_SIP_OPTIONS,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(
                SipMessageUtils.TEST_INVALID_SIP_SUBSCRIBE_PRESENCE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_HEADER_FIELDS);
    }

    private void verifyFullRegistrationTriggered(TransportInterfaces ifaces) throws Exception {
        ifaces.delegateConn.verifyDelegateCreated();
        ifaces.delegateConn.triggerFullNetworkRegistration(ifaces.manager, 403, ""FORBIDDEN"");
        TestImsRegistration.NetworkRegistrationInfo info =
                ifaces.reg.getNextFullNetworkRegRequest(ImsUtils.TEST_TIMEOUT_MS);
        assertNotNull(""full registration requested, but ImsRegistrationImplBase ""
                + ""implementation did not receive a request."", info);
        assertEquals(403, info.sipCode);
        assertEquals(""FORBIDDEN"", info.sipReason);
    }

    private void sendInvalidRequestsAndVerifyFailed(
            TestSipDelegateConnection delegateConn) throws Exception {
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_SIP_MESSAGE_INVALID_REQUEST,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_SIP_MESSAGE_INVALID_RESPONSE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_START_LINE);
    }

    private void verifyOutgoingTransport(TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        // Send a message and ensure it gets received on the other end as well as acked
        delegateConn.sendMessageAndVerifyCompletedSuccessfully(SipMessageUtils.TEST_SIP_MESSAGE);
        delegate.verifyMessageSend(SipMessageUtils.TEST_SIP_MESSAGE);
        delegateConn.sendCleanupSession(SipMessageUtils.TEST_SIP_MESSAGE.getCallIdParameter());
        delegate.verifyCleanupSession(SipMessageUtils.TEST_SIP_MESSAGE.getCallIdParameter());
        // send a message and notify connection that it failed
        delegate.setSendMessageDenyReason(
                SipDelegateManager.MESSAGE_FAILURE_REASON_NETWORK_NOT_AVAILABLE);
        delegateConn.sendMessageAndVerifyFailure(SipMessageUtils.TEST_SIP_MESSAGE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_NETWORK_NOT_AVAILABLE);
        delegate.verifyMessageSend(SipMessageUtils.TEST_SIP_MESSAGE);
    }

    private void sendMessageAndVerifyAck(SipMessage message,
            TransportInterfaces ifaces) throws Exception {
        // Send a message and ensure it gets received on the other end as well as acked
        ifaces.delegateConn.sendMessageAndVerifyCompletedSuccessfully(message);
    }

    private void verifyIncomingTransport(TestSipDelegateConnection delegateConn,
            TestSipDelegate delegate) throws Exception {
        // Receive a message and ensure it gets received on the other end as well as acked
        delegate.receiveMessageAndVerifyReceivedCalled(SipMessageUtils.TEST_SIP_MESSAGE);
        delegateConn.verifyMessageReceived(SipMessageUtils.TEST_SIP_MESSAGE);
        // Receive a message and have connection notify that it didn't complete
        delegateConn.setReceivedMessageErrorResponseReason(
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_BODY_CONTENT);
        delegate.receiveMessageAndVerifyReceiveErrorCalled(SipMessageUtils.TEST_SIP_MESSAGE,
                SipDelegateManager.MESSAGE_FAILURE_REASON_INVALID_BODY_CONTENT);
    }

    private void receiveMessageAndVerifyAck(SipMessage message,
            TransportInterfaces ifaces) throws Exception {
        // Receive a message and ensure it gets received on the other end as well as acked
        ifaces.delegate.receiveMessageAndVerifyReceivedCalled(message);
        ifaces.delegateConn.verifyMessageReceived(message);
    }

    private void verifyRegistrationState(TransportInterfaces ifaces,
            DelegateRegistrationState state) {
        ifaces.delegateConn.setOperationCountDownLatch(1);
        ifaces.delegate.notifyImsRegistrationUpdate(state);
        ifaces.delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        ifaces.delegateConn.verifyRegistrationStateEquals(state);
    }

    private DelegateRegistrationState getDeregisteringState(Set<String> registered,
            Set<String> deregistering, int deregisteringReason) {
        DelegateRegistrationState.Builder b = new DelegateRegistrationState.Builder();
        b.addRegisteredFeatureTags(registered);
        for (String dereg : deregistering) {
            b.addDeregisteringFeatureTag(dereg, deregisteringReason);
        }
        return b.build();
    }

    private void sendConfigChange(SipDelegateConfiguration c,
            TestSipDelegateConnection delegateConn, TestSipDelegate delegate) {
        delegateConn.setOperationCountDownLatch(1);
        delegate.notifyConfigurationUpdate(c);
        delegateConn.waitForCountDown(ImsUtils.TEST_TIMEOUT_MS);
        delegateConn.verifyConfigEquals(c);
    }

    /**
     * @return A new test SipDelegateConfiguration that has all fields populated.1
     */
    private SipDelegateConfiguration generateNewTestConfig() {
        InetSocketAddress localAddr = new InetSocketAddress(
                InetAddresses.parseNumericAddress(""1.1.1.1""), 80);
        InetSocketAddress serverAddr = new InetSocketAddress(
                InetAddresses.parseNumericAddress(""2.2.2.2""), 81);
        SipDelegateConfiguration.Builder b = new SipDelegateConfiguration.Builder(1,
                SipDelegateConfiguration.SIP_TRANSPORT_TCP, localAddr, serverAddr);
        b.setSipCompactFormEnabled(true);
        b.setSipKeepaliveEnabled(true);
        b.setMaxUdpPayloadSizeBytes(508);
        b.setPublicUserIdentifier(""test1"");
        b.setPrivateUserIdentifier(""test2"");
        b.setHomeDomain(""test.domain"");
        b.setImei(""testImei"");
        b.setSipAuthenticationHeader(""sipauth"");
        b.setSipAuthenticationNonce(""sipnonce"");
        b.setSipServiceRouteHeader(""srvroute"");
        b.setSipPathHeader(""path"");
        b.setSipUserAgentHeader(""ua"");
        b.setSipContactUserParameter(""user"");
        b.setSipPaniHeader(""pani"");
        b.setSipPlaniHeader(""plani"");
        b.setSipCniHeader(""cni"");
        b.setSipAssociatedUriHeader(""uri"");
        Uri gruuUri = Uri.parse(""sip:blah@gruu.net"");
        b.setPublicGruuUri(gruuUri);
        SipDelegateConfiguration.IpSecConfiguration ipSecConfig =
                new SipDelegateConfiguration.IpSecConfiguration(123, 124,
                        125, 126, 127, 128, ""secverify"");
        assertEquals(123, ipSecConfig.getLocalTxPort());
        assertEquals(124, ipSecConfig.getLocalRxPort());
        assertEquals(125, ipSecConfig.getLastLocalTxPort());
        assertEquals(126, ipSecConfig.getRemoteTxPort());
        assertEquals(127, ipSecConfig.getRemoteRxPort());
        assertEquals(128, ipSecConfig.getLastRemoteTxPort());
        assertEquals(""secverify"", ipSecConfig.getSipSecurityVerifyHeader());
        b.setIpSecConfiguration(ipSecConfig);
        InetSocketAddress natAddr = new InetSocketAddress(
                InetAddresses.parseNumericAddress(""3.3.3.3""), 129);
        b.setNatSocketAddress(natAddr);
        assertEquals(""3.3.3.3"", natAddr.getAddress().getHostAddress());
        assertEquals(129, natAddr.getPort());
        return b.build();
    }

    private DelegateRegistrationState getRegisteredRegistrationState(Set<String> registered) {
        return new DelegateRegistrationState.Builder().addRegisteredFeatureTags(registered).build();
    }

    private DelegateRegistrationState getDeregisteringState(Set<String> deregisterTags,
            int reason) {
        DelegateRegistrationState.Builder b = new DelegateRegistrationState.Builder();
        for (String t : deregisterTags) {
            b.addDeregisteringFeatureTag(t, reason);
        }
        return b.build();
    }

    private void connectTestImsServiceWithSipTransportAndConfig() throws Exception {
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        sServiceConnector.getCarrierService().addCapabilities(
                ImsService.CAPABILITY_SIP_DELEGATE_CREATION);
        sServiceConnector.getCarrierService().setSipTransportImplemented();
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);
    }


    private void connectTestImsServiceWithSipTransport() throws Exception {
        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        sServiceConnector.getCarrierService().addCapabilities(
                ImsService.CAPABILITY_SIP_DELEGATE_CREATION);
        sServiceConnector.getCarrierService().setSipTransportImplemented();
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);
    }

    private void verifyImsServiceState(ImsFeatureConfiguration config) {
        for (ImsFeatureConfiguration.FeatureSlotPair p : config.getServiceFeatures()) {
            switch (p.featureType) {
                case ImsFeature.FEATURE_MMTEL: {
                    sServiceConnector.getCarrierService().waitForLatchCountdown(
                            TestImsService.LATCH_CREATE_MMTEL);
                    assertNotNull(""ImsService created, but ImsService#createMmTelFeature was not ""
                            + ""called!"", sServiceConnector.getCarrierService().getMmTelFeature());
                    break;
                }
                case ImsFeature.FEATURE_RCS: {
                    sServiceConnector.getCarrierService().waitForLatchCountdown(
                            TestImsService.LATCH_CREATE_RCS);
                    assertNotNull(""ImsService created, but ImsService#createRcsFeature was not ""
                            + ""called!"", sServiceConnector.getCarrierService().getRcsFeature());
                    break;
                }
            }
        }
    }

    /**
     * Wait up to five seconds (retrying a command 1 time per second) until ImsExceptions due to the
     * ImsService not being available go away. If the ImsService never becomes available, this
     * method will return null.
     */
    private <T> T callUntilImsServiceIsAvailable(Callable<T> command) throws Exception {
        int retry = 0;
        while (retry < 5) {
            try {
                return command.call();
            } catch (ImsException e) {
                // we want to absorb only the unavailable error, as telephony may still be
                // internally setting up. Any other type of ImsException is unexpected.
                if (e.getCode() != ImsException.CODE_ERROR_SERVICE_UNAVAILABLE) {
                    throw e;
                }
            }
            Thread.sleep(1000);
            retry++;
        }
        return null;
    }

    private DelegateRequest getDefaultRequest() {
        ArraySet<String> features = new ArraySet<>(Arrays.asList(DEFAULT_FEATURE_TAGS));
        return new DelegateRequest(features);
    }

    private DelegateRequest getChatOnlyRequest() {
        ArraySet<String> features = new ArraySet<>(3);
        features.add(ONE_TO_ONE_CHAT_TAG);
        features.add(GROUP_CHAT_TAG);
        return new DelegateRequest(features);
    }

    private ImsFeatureConfiguration getConfigForMmTelAndRcs() {
        return new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_EMERGENCY_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build();
    }

    private ImsFeatureConfiguration getConfigForRcs() {
        return new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build();
    }

    private Set<FeatureTagState> getDeniedTagsForReason(Set<String> deniedTags, int reason) {
        return deniedTags.stream().map(t -> new FeatureTagState(t, reason))
                .collect(Collectors.toSet());
    }

    private static void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getInstrumentation()
                .getContext().getSystemService(CarrierConfigManager.class);
        sReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(sTestSub, bundle));
        sReceiver.waitForCarrierConfigChanged();
    }

    private static void setFeatureTagsCarrierAllowed(String[] tags) throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        bundle.putStringArray(CarrierConfigManager.Ims.KEY_RCS_FEATURE_TAG_ALLOWED_STRING_ARRAY,
                tags);
        overrideCarrierConfig(bundle);
    }

    private SipDelegateManager getSipDelegateManager() {
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        assertNotNull(imsManager);
        return imsManager.getSipDelegateManager(sTestSub);
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"getIsDefault"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void test/**
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package android.app.usage.cts;

import android.app.AppOpsManager;
import android.app.usage.NetworkStatsManager;
import android.app.usage.NetworkStats;
import android.content.Context;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TrafficStats;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.RemoteException;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.telephony.TelephonyManager;
import android.test.InstrumentationTestCase;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.UnknownHostException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Scanner;
import java.net.HttpURLConnection;

import libcore.io.IoUtils;
import libcore.io.Streams;

import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_ALL;
import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_NO;
import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_YES;
import static android.app.usage.NetworkStats.Bucket.METERED_ALL;
import static android.app.usage.NetworkStats.Bucket.METERED_YES;
import static android.app.usage.NetworkStats.Bucket.METERED_NO;
import static android.app.usage.NetworkStats.Bucket.STATE_ALL;
import static android.app.usage.NetworkStats.Bucket.STATE_DEFAULT;
import static android.app.usage.NetworkStats.Bucket.STATE_FOREGROUND;
import static android.app.usage.NetworkStats.Bucket.TAG_NONE;
import static android.app.usage.NetworkStats.Bucket.UID_ALL;

public class NetworkUsageStatsTest extends InstrumentationTestCase {
    private static final String LOG_TAG = ""NetworkUsageStatsTest"";
    private static final String APPOPS_SET_SHELL_COMMAND = ""appops set {0} {1} {2}"";
    private static final String APPOPS_GET_SHELL_COMMAND = ""appops get {0} {1}"";

    private static final long MINUTE = 1000 * 60;
    private static final int TIMEOUT_MILLIS = 15000;

    private static final String CHECK_CONNECTIVITY_URL = ""http://www.265.com/"";
    private static final int HOST_RESOLUTION_RETRIES = 4;
    private static final int HOST_RESOLUTION_INTERVAL_MS = 500;

    private static final int NETWORK_TAG = 0xf00d;
    private static final long THRESHOLD_BYTES = 2 * 1024 * 1024;  // 2 MB

    private abstract class NetworkInterfaceToTest {
        private boolean mMetered;
        private boolean mIsDefault;

        abstract int getNetworkType();
        abstract int getTransportType();

        public boolean getMetered() {
            return mMetered;
        }

        public void setMetered(boolean metered) {
            this.mMetered = metered;
        }

        public boolean getIsDefault() {
            return mIsDefault;
        }

        public void setIsDefault(boolean isDefault) {
            mIsDefault = isDefault;
        }

        abstract String getSystemFeature();
        abstract String getErrorMessage();
    }

    private final NetworkInterfaceToTest[] mNetworkInterfacesToTest =
            new NetworkInterfaceToTest[] {
                    new NetworkInterfaceToTest() {
                        @Override
                        public int getNetworkType() {
                            return ConnectivityManager.TYPE_WIFI;
                        }

                        @Override
                        public int getTransportType() {
                            return NetworkCapabilities.TRANSPORT_WIFI;
                        }

                        @Override
                        public String getSystemFeature() {
                            return PackageManager.FEATURE_WIFI;
                        }

                        @Override
                        public String getErrorMessage() {
                            return "" Please make sure you are connected to a WiFi access point."";
                        }
                    },
                    new NetworkInterfaceToTest() {
                        @Override
                        public int getNetworkType() {
                            return ConnectivityManager.TYPE_MOBILE;
                        }

                        @Override
                        public int getTransportType() {
                            return NetworkCapabilities.TRANSPORT_CELLULAR;
                        }

                        @Override
                        public String getSystemFeature() {
                            return PackageManager.FEATURE_TELEPHONY;
                        }

                        @Override
                        public String getErrorMessage() {
                            return "" Please make sure you have added a SIM card with data plan to"" +
                                    "" your phone, have enabled data over cellular and in case of"" +
                                    "" dual SIM devices, have selected the right SIM "" +
                                    ""for data connection."";
                        }
                    }
    };

    private String mPkg;
    private NetworkStatsManager mNsm;
    private ConnectivityManager mCm;
    private PackageManager mPm;
    private long mStartTime;
    private long mEndTime;

    private long mBytesRead;
    private String mWriteSettingsMode;
    private String mUsageStatsMode;

    private void exerciseRemoteHost(Network network, URL url) throws Exception {
        NetworkInfo networkInfo = mCm.getNetworkInfo(network);
        if (networkInfo == null) {
            Log.w(LOG_TAG, ""Network info is null"");
        } else {
            Log.w(LOG_TAG, ""Network: "" + networkInfo.toString());
        }
        InputStreamReader in = null;
        HttpURLConnection urlc = null;
        String originalKeepAlive = System.getProperty(""http.keepAlive"");
        System.setProperty(""http.keepAlive"", ""false"");
        try {
            TrafficStats.setThreadStatsTag(NETWORK_TAG);
            urlc = (HttpURLConnection) network.openConnection(url);
            urlc.setConnectTimeout(TIMEOUT_MILLIS);
            urlc.setUseCaches(false);
            // Disable compression so we generate enough traffic that assertWithinPercentage will
            // not be affected by the small amount of traffic (5-10kB) sent by the test harness.
            urlc.setRequestProperty(""Accept-Encoding"", ""identity"");
            urlc.connect();
            boolean ping = urlc.getResponseCode() == 200;
            if (ping) {
                in = new InputStreamReader(
                        (InputStream) urlc.getContent());

                mBytesRead = 0;
                while (in.read() != -1) ++mBytesRead;
            }
        } catch (Exception e) {
            Log.i(LOG_TAG, ""Badness during exercising remote server: "" + e);
        } finally {
            TrafficStats.clearThreadStatsTag();
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    // don't care
                }
            }
            if (urlc != null) {
                urlc.disconnect();
            }
            if (originalKeepAlive == null) {
                System.clearProperty(""http.keepAlive"");
            } else {
                System.setProperty(""http.keepAlive"", originalKeepAlive);
            }
        }
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mNsm = (NetworkStatsManager) getInstrumentation().getContext()
                .getSystemService(Context.NETWORK_STATS_SERVICE);
        mNsm.setPollForce(true);

        mCm = (ConnectivityManager) getInstrumentation().getContext()
                .getSystemService(Context.CONNECTIVITY_SERVICE);

        mPm = getInstrumentation().getContext().getPackageManager();

        mPkg = getInstrumentation().getContext().getPackageName();

        mWriteSettingsMode = getAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS);
        setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, ""allow"");
        mUsageStatsMode = getAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS);
    }

    @Override
    protected void tearDown() throws Exception {
        if (mWriteSettingsMode != null) {
            setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, mWriteSettingsMode);
        }
        if (mUsageStatsMode != null) {
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, mUsageStatsMode);
        }
        super.tearDown();
    }

    private void setAppOpsMode(String appop, String mode) throws Exception {
        final String command = MessageFormat.format(APPOPS_SET_SHELL_COMMAND, mPkg, appop, mode);
        SystemUtil.runShellCommand(command);
    }

    private String getAppOpsMode(String appop) throws Exception {
        final String command = MessageFormat.format(APPOPS_GET_SHELL_COMMAND, mPkg, appop);
        String result = SystemUtil.runShellCommand(command);
        if (result == null) {
            Log.w(LOG_TAG, ""App op "" + appop + "" could not be read."");
        }
        return result;
    }

    private boolean isInForeground() throws IOException {
        String result = SystemUtil.runShellCommand(getInstrumentation(),
                ""cmd activity get-uid-state "" + Process.myUid());
        return result.contains(""FOREGROUND"");
    }

    private class NetworkCallback extends ConnectivityManager.NetworkCallback {
        private long mTolerance;
        private URL mUrl;
        public boolean success;
        public boolean metered;
        public boolean isDefault;

        NetworkCallback(long tolerance, URL url) {
            mTolerance = tolerance;
            mUrl = url;
            success = false;
            metered = false;
            isDefault = false;
        }

        // The test host only has IPv4. So on a dual-stack network where IPv6 connects before IPv4,
        // we need to wait until IPv4 is available or the test will spuriously fail.
        private void waitForHostResolution(Network network) {
            for (int i = 0; i < HOST_RESOLUTION_RETRIES; i++) {
                try {
                    network.getAllByName(mUrl.getHost());
                    return;
                } catch (UnknownHostException e) {
                    SystemClock.sleep(HOST_RESOLUTION_INTERVAL_MS);
                }
            }
            fail(String.format(""%s could not be resolved on network %s (%d attempts %dms apart)"",
                  mUrl.getHost(), network, HOST_RESOLUTION_RETRIES, HOST_RESOLUTION_INTERVAL_MS));
        }

        @Override
        public void onAvailable(Network network) {
            try {
                mStartTime = System.currentTimeMillis() - mTolerance;
                isDefault = network.equals(mCm.getActiveNetwork());
                waitForHostResolution(network);
                exerciseRemoteHost(network, mUrl);
                mEndTime = System.currentTimeMillis() + mTolerance;
                success = true;
                metered = !mCm.getNetworkCapabilities(network)
                        .hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
                synchronized(NetworkUsageStatsTest.this) {
                    NetworkUsageStatsTest.this.notify();
                }
            } catch (Exception e) {
                Log.w(LOG_TAG, ""exercising remote host failed."", e);
                success = false;
            }
        }
    }

    private boolean shouldTestThisNetworkType(int networkTypeIndex, final long tolerance)
            throws Exception {
        boolean hasFeature = mPm.hasSystemFeature(
                mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature());
        if (!hasFeature) {
            return false;
        }
        NetworkCallback callback = new NetworkCallback(tolerance, new URL(CHECK_CONNECTIVITY_URL));
        mCm.requestNetwork(new NetworkRequest.Builder()
                .addTransportType(mNetworkInterfacesToTest[networkTypeIndex].getTransportType())
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .build(), callback);
        synchronized(this) {
            try {
                wait((int)(TIMEOUT_MILLIS * 1.2));
            } catch (InterruptedException e) {
            }
        }
        if (callback.success) {
            mNetworkInterfacesToTest[networkTypeIndex].setMetered(callback.metered);
            mNetworkInterfacesToTest[networkTypeIndex].setIsDefault(callback.isDefault);
            return true;
        }

        // This will always fail at this point as we know 'hasFeature' is true.
        assertFalse (mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature() +
                "" is a reported system feature, "" +
                ""however no corresponding connected network interface was found or the attempt "" +
                ""to connect has timed out (timeout = "" + TIMEOUT_MILLIS + ""ms)."" +
                mNetworkInterfacesToTest[networkTypeIndex].getErrorMessage(), hasFeature);
        return false;
    }

    private String getSubscriberId(int networkIndex) {
        int networkType = mNetworkInterfacesToTest[networkIndex].getNetworkType();
        if (ConnectivityManager.TYPE_MOBILE == networkType) {
            TelephonyManager tm = (TelephonyManager) getInstrumentation().getContext()
                    .getSystemService(Context.TELEPHONY_SERVICE);
            return ShellIdentityUtils.invokeMethodWithShellPermissions(tm,
                    (telephonyManager) -> telephonyManager.getSubscriberId());
        }
        return """";
    }

    @AppModeFull"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testDeviceSummary"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void testDeviceSummary() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            if (!shouldTestThisNetworkType(i, MINUTE/2)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats.Bucket bucket = null;
            try {
                bucket = mNsm.querySummaryForDevice(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
            } catch (RemoteException | SecurityException e) {
                fail(""testDeviceSummary fails with exception: "" + e.toString());
            }
            assertNotNull(bucket);
            assertTimestamps(bucket);
            assertEquals(bucket.getState(), STATE_ALL);
            assertEquals(bucket.getUid(), UID_ALL);
            assertEquals(bucket.getMetered(), METERED_ALL);
            assertEquals(bucket.getDefaultNetworkStatus(), DEFAULT_NETWORK_ALL);
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                bucket = mNsm.querySummaryForDevice(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                fail(""negative testDeviceSummary fails: no exception thrown."");
            } catch (RemoteException e) {
                fail(""testDeviceSummary fails with exception: "" + e.toString());
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testUserSummary"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void testUserSummary() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            if (!shouldTestThisNetworkType(i, MINUTE/2)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats.Bucket bucket = null;
            try {
                bucket = mNsm.querySummaryForUser(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
            } catch (RemoteException | SecurityException e) {
                fail(""testUserSummary fails with exception: "" + e.toString());
            }
            assertNotNull(bucket);
            assertTimestamps(bucket);
            assertEquals(bucket.getState(), STATE_ALL);
            assertEquals(bucket.getUid(), UID_ALL);
            assertEquals(bucket.getMetered(), METERED_ALL);
            assertEquals(bucket.getDefaultNetworkStatus(), DEFAULT_NETWORK_ALL);
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                bucket = mNsm.querySummaryForUser(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                fail(""negative testUserSummary fails: no exception thrown."");
            } catch (RemoteException e) {
                fail(""testUserSummary fails with exception: "" + e.toString());
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testAppSummary"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void testAppSummary() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Use tolerance value that large enough to make sure stats of at
            // least one bucket is included. However, this is possible that
            // the test will see data of different app but with the same UID
            // that created before testing.
            // TODO: Consider query stats before testing and use the difference to verify.
            if (!shouldTestThisNetworkType(i, MINUTE * 120)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats result = null;
            try {
                result = mNsm.querySummary(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                assertNotNull(result);
                NetworkStats.Bucket bucket = new NetworkStats.Bucket();
                long totalTxPackets = 0;
                long totalRxPackets = 0;
                long totalTxBytes = 0;
                long totalRxBytes = 0;
                boolean hasCorrectMetering = false;
                boolean hasCorrectDefaultStatus = false;
                int expectedMetering = mNetworkInterfacesToTest[i].getMetered() ?
                        METERED_YES : METERED_NO;
                int expectedDefaultStatus = mNetworkInterfacesToTest[i].getIsDefault() ?
                        DEFAULT_NETWORK_YES : DEFAULT_NETWORK_NO;
                while (result.hasNextBucket()) {
                    assertTrue(result.getNextBucket(bucket));
                    assertTimestamps(bucket);
                    hasCorrectMetering |= bucket.getMetered() == expectedMetering;
                    if (bucket.getUid() == Process.myUid()) {
                        totalTxPackets += bucket.getTxPackets();
                        totalRxPackets += bucket.getRxPackets();
                        totalTxBytes += bucket.getTxBytes();
                        totalRxBytes += bucket.getRxBytes();
                        hasCorrectDefaultStatus |=
                                bucket.getDefaultNetworkStatus() == expectedDefaultStatus;
                    }
                }
                assertFalse(result.getNextBucket(bucket));
                assertTrue(""Incorrect metering for NetworkType: "" +
                        mNetworkInterfacesToTest[i].getNetworkType(), hasCorrectMetering);
                assertTrue(""Incorrect isDefault for NetworkType: "" +
                        mNetworkInterfacesToTest[i].getNetworkType(), hasCorrectDefaultStatus);
                assertTrue(""No Rx bytes usage for uid "" + Process.myUid(), totalRxBytes > 0);
                assertTrue(""No Rx packets usage for uid "" + Process.myUid(), totalRxPackets > 0);
                assertTrue(""No Tx bytes usage for uid "" + Process.myUid(), totalTxBytes > 0);
                assertTrue(""No Tx packets usage for uid "" + Process.myUid(), totalTxPackets > 0);
            } finally {
                if (result != null) {
                    result.close();
                }
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                result = mNsm.querySummary(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                fail(""negative testAppSummary fails: no exception thrown."");
            } catch (RemoteException e) {
                fail(""testAppSummary fails with exception: "" + e.toString());
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testAppDetails"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void testAppDetails() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Relatively large tolerance to accommodate for history bucket size.
            if (!shouldTestThisNetworkType(i, MINUTE * 120)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats result = null;
            try {
                result = mNsm.queryDetails(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                long totalBytesWithSubscriberId = getTotalAndAssertNotEmpty(result);

                // Test without filtering by subscriberId
                result = mNsm.queryDetails(
                        mNetworkInterfacesToTest[i].getNetworkType(), null,
                        mStartTime, mEndTime);

                assertTrue(""More bytes with subscriberId filter than without."",
                        getTotalAndAssertNotEmpty(result) >= totalBytesWithSubscriberId);
            } catch (RemoteException | SecurityException e) {
                fail(""testAppDetails fails with exception: "" + e.toString());
            } finally {
                if (result != null) {
                    result.close();
                }
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                result = mNsm.queryDetails(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                fail(""negative testAppDetails fails: no exception thrown."");
            } catch (RemoteException e) {
                fail(""testAppDetails fails with exception: "" + e.toString());
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testUidDetails"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void testUidDetails() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Relatively large tolerance to accommodate for history bucket size.
            if (!shouldTestThisNetworkType(i, MINUTE * 120)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats result = null;
            try {
                result = mNsm.queryDetailsForUid(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime, Process.myUid());
                assertNotNull(result);
                NetworkStats.Bucket bucket = new NetworkStats.Bucket();
                long totalTxPackets = 0;
                long totalRxPackets = 0;
                long totalTxBytes = 0;
                long totalRxBytes = 0;
                while (result.hasNextBucket()) {
                    assertTrue(result.getNextBucket(bucket));
                    assertTimestamps(bucket);
                    assertEquals(bucket.getState(), STATE_ALL);
                    assertEquals(bucket.getMetered(), METERED_ALL);
                    assertEquals(bucket.getDefaultNetworkStatus(), DEFAULT_NETWORK_ALL);
                    assertEquals(bucket.getUid(), Process.myUid());
                    totalTxPackets += bucket.getTxPackets();
                    totalRxPackets += bucket.getRxPackets();
                    totalTxBytes += bucket.getTxBytes();
                    totalRxBytes += bucket.getRxBytes();
                }
                assertFalse(result.getNextBucket(bucket));
                assertTrue(""No Rx bytes usage for uid "" + Process.myUid(), totalRxBytes > 0);
                assertTrue(""No Rx packets usage for uid "" + Process.myUid(), totalRxPackets > 0);
                assertTrue(""No Tx bytes usage for uid "" + Process.myUid(), totalTxBytes > 0);
                assertTrue(""No Tx packets usage for uid "" + Process.myUid(), totalTxPackets > 0);
            } finally {
                if (result != null) {
                    result.close();
                }
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                result = mNsm.queryDetailsForUid(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime, Process.myUid());
                fail(""negative testUidDetails fails: no exception thrown."");
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testTagDetails"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void testTagDetails() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Relatively large tolerance to accommodate for history bucket size.
            if (!shouldTestThisNetworkType(i, MINUTE * 120)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats result = null;
            try {
                result = mNsm.queryDetailsForUidTag(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime, Process.myUid(), NETWORK_TAG);
                assertNotNull(result);
                NetworkStats.Bucket bucket = new NetworkStats.Bucket();
                long totalTxPackets = 0;
                long totalRxPackets = 0;
                long totalTxBytes = 0;
                long totalRxBytes = 0;
                while (result.hasNextBucket()) {
                    assertTrue(result.getNextBucket(bucket));
                    assertTimestamps(bucket);
                    assertEquals(bucket.getState(), STATE_ALL);
                    assertEquals(bucket.getMetered(), METERED_ALL);
                    assertEquals(bucket.getDefaultNetworkStatus(), DEFAULT_NETWORK_ALL);
                    assertEquals(bucket.getUid(), Process.myUid());
                    if (bucket.getTag() == NETWORK_TAG) {
                        totalTxPackets += bucket.getTxPackets();
                        totalRxPackets += bucket.getRxPackets();
                        totalTxBytes += bucket.getTxBytes();
                        totalRxBytes += bucket.getRxBytes();
                    }
                }
                assertTrue(""No Rx bytes tagged with 0x"" + Integer.toHexString(NETWORK_TAG)
                        + "" for uid "" + Process.myUid(), totalRxBytes > 0);
                assertTrue(""No Rx packets tagged with 0x"" + Integer.toHexString(NETWORK_TAG)
                        + "" for uid "" + Process.myUid(), totalRxPackets > 0);
                assertTrue(""No Tx bytes tagged with 0x"" + Integer.toHexString(NETWORK_TAG)
                        + "" for uid "" + Process.myUid(), totalTxBytes > 0);
                assertTrue(""No Tx packets tagged with 0x"" + Integer.toHexString(NETWORK_TAG)
                        + "" for uid "" + Process.myUid(), totalTxPackets > 0);
            } finally {
                if (result != null) {
                    result.close();
                }
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                result = mNsm.queryDetailsForUidTag(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime, Process.myUid(), NETWORK_TAG);
                fail(""negative testUidDetails fails: no exception thrown."");
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    class QueryResult {
        public final int tag;
        public final int state;
        public final long total;

        public QueryResult(int tag, int state, NetworkStats stats) {
            this.tag = tag;
            this.state = state;
            total = getTotalAndAssertNotEmpty(stats, tag, state);
        }

        public String toString() {
            return String.format(""QueryResult(tag=%s state=%s total=%d)"",
                    tagToString(tag), stateToString(state), total);
        }
    }

    private NetworkStats getNetworkStatsForTagState(int i, int tag, int state) {
        return mNsm.queryDetailsForUidTagState(
                mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                mStartTime, mEndTime, Process.myUid(), tag, state);
    }

    private void assertWithinPercentage(String msg, long expected, long actual, int percentage) {
        long lowerBound = expected * (100 - percentage) / 100;
        long upperBound = expected * (100 + percentage) / 100;
        msg = String.format(""%s: %d not within %d%% of %d"", msg, actual, percentage, expected);
        assertTrue(msg, lowerBound <= actual);
        assertTrue(msg, upperBound >= actual);
    }

    private void assertAlmostNoUnexpectedTraffic(NetworkStats result, int expectedTag,
            int expectedState, long maxUnexpected) {
        long total = 0;
        NetworkStats.Bucket bucket = new NetworkStats.Bucket();
        while (result.hasNextBucket()) {
            assertTrue(result.getNextBucket(bucket));
            total += bucket.getRxBytes() + bucket.getTxBytes();
        }
        if (total <= maxUnexpected) return;

        fail(String.format(""More than %d bytes of traffic when querying for ""
                + ""tag %s state %s. Last bucket: uid=%d tag=%s state=%s bytes=%d/%d"",
                maxUnexpected, tagToString(expectedTag), stateToString(expectedState),
                bucket.getUid(), tagToString(bucket.getTag()), stateToString(bucket.getState()),
                bucket.getRxBytes(), bucket.getTxBytes()));
    }

    @AppModeFull"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testUidTagStateDetails"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void testUidTagStateDetails() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Relatively large tolerance to accommodate for history bucket size.
            if (!shouldTestThisNetworkType(i, MINUTE * 120)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats result = null;
            try {
                int currentState = isInForeground() ? STATE_FOREGROUND : STATE_DEFAULT;
                int otherState = (currentState == STATE_DEFAULT) ? STATE_FOREGROUND : STATE_DEFAULT;

                int[] tagsWithTraffic = {NETWORK_TAG, TAG_NONE};
                int[] statesWithTraffic = {currentState, STATE_ALL};
                ArrayList<QueryResult> resultsWithTraffic = new ArrayList<>();

                int[] statesWithNoTraffic = {otherState};
                int[] tagsWithNoTraffic = {NETWORK_TAG + 1};
                ArrayList<QueryResult> resultsWithNoTraffic = new ArrayList<>();

                // Expect to see traffic when querying for any combination of a tag in
                // tagsWithTraffic and a state in statesWithTraffic.
                for (int tag : tagsWithTraffic) {
                    for (int state : statesWithTraffic) {
                        result = getNetworkStatsForTagState(i, tag, state);
                        resultsWithTraffic.add(new QueryResult(tag, state, result));
                        result.close();
                        result = null;
                    }
                }

                // Expect that the results are within a few percentage points of each other.
                // This is ensures that FIN retransmits after the transfer is complete don't cause
                // the test to be flaky. The test URL currently returns just over 100k so this
                // should not be too noisy. It also ensures that the traffic sent by the test
                // harness, which is untagged, won't cause a failure.
                long firstTotal = resultsWithTraffic.get(0).total;
                for (QueryResult queryResult : resultsWithTraffic) {
                    assertWithinPercentage(queryResult + """", firstTotal, queryResult.total, 10);
                }

                // Expect to see no traffic when querying for any tag in tagsWithNoTraffic or any
                // state in statesWithNoTraffic.
                for (int tag : tagsWithNoTraffic) {
                    for (int state : statesWithTraffic) {
                        result = getNetworkStatsForTagState(i, tag, state);
                        assertAlmostNoUnexpectedTraffic(result, tag, state, firstTotal / 100);
                        result.close();
                        result = null;
                    }
                }
                for (int tag : tagsWithTraffic) {
                    for (int state : statesWithNoTraffic) {
                        result = getNetworkStatsForTagState(i, tag, state);
                        assertAlmostNoUnexpectedTraffic(result, tag, state, firstTotal / 100);
                        result.close();
                        result = null;
                    }
                }
            } finally {
                if (result != null) {
                    result.close();
                }
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                result = mNsm.queryDetailsForUidTag(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime, Process.myUid(), NETWORK_TAG);
                fail(""negative testUidDetails fails: no exception thrown."");
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testCallback"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void testCallback() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Relatively large tolerance to accommodate for history bucket size.
            if (!shouldTestThisNetworkType(i, MINUTE/2)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");

            TestUsageCallback usageCallback = new TestUsageCallback();
            HandlerThread thread = new HandlerThread(""callback-thread"");
            thread.start();
            Handler handler = new Handler(thread.getLooper());
            mNsm.registerUsageCallback(mNetworkInterfacesToTest[i].getNetworkType(),
                    getSubscriberId(i), THRESHOLD_BYTES, usageCallback, handler);

            // TODO: Force traffic and check whether the callback is invoked.
            // Right now the test only covers whether the callback can be registered, but not
            // whether it is invoked upon data usage since we don't have a scalable way of
            // storing files of >2MB in CTS.

            mNsm.unregisterUsageCallback(usageCallback);
        }
    }

    private String tagToString(Integer tag) {
        if (tag == null) return ""null"";
        switch (tag) {
            case TAG_NONE:
                return ""TAG_NONE"";
            default:
                return ""0x"" + Integer.toHexString(tag);
        }
    }

    private String stateToString(Integer state) {
        if (state == null) return ""null"";
        switch (state) {
            case STATE_ALL:
                return ""STATE_ALL"";
            case STATE_DEFAULT:
                return ""STATE_DEFAULT"";
            case STATE_FOREGROUND:
                return ""STATE_FOREGROUND"";
        }
        throw new IllegalArgumentException(""Unknown state "" + state);
    }

    private long getTotalAndAssertNotEmpty(NetworkStats result, Integer expectedTag,
            Integer expectedState) {
        assertTrue(result != null);
        NetworkStats.Bucket bucket = new NetworkStats.Bucket();
        long totalTxPackets = 0;
        long totalRxPackets = 0;
        long totalTxBytes = 0;
        long totalRxBytes = 0;
        while (result.hasNextBucket()) {
            assertTrue(result.getNextBucket(bucket));
            assertTimestamps(bucket);
            if (expectedTag != null) assertEquals(bucket.getTag(), (int) expectedTag);
            if (expectedState != null) assertEquals(bucket.getState(), (int) expectedState);
            assertEquals(bucket.getMetered(), METERED_ALL);
            assertEquals(bucket.getDefaultNetworkStatus(), DEFAULT_NETWORK_ALL);
            if (bucket.getUid() == Process.myUid()) {
                totalTxPackets += bucket.getTxPackets();
                totalRxPackets += bucket.getRxPackets();
                totalTxBytes += bucket.getTxBytes();
                totalRxBytes += bucket.getRxBytes();
            }
        }
        assertFalse(result.getNextBucket(bucket));
        String msg = String.format(""uid %d tag %s state %s"",
                Process.myUid(), tagToString(expectedTag), stateToString(expectedState));
        assertTrue(""No Rx bytes usage for "" + msg, totalRxBytes > 0);
        assertTrue(""No Rx packets usage for "" + msg, totalRxPackets > 0);
        assertTrue(""No Tx bytes usage for "" + msg, totalTxBytes > 0);
        assertTrue(""No Tx packets usage for "" + msg, totalTxPackets > 0);

        return totalRxBytes + totalTxBytes;
    }

    private long getTotalAndAssertNotEmpty(NetworkStats result) {
        return getTotalAndAssertNotEmpty(result, null, STATE_ALL);
    }

    private void assertTimestamps(final NetworkStats.Bucket bucket) {
        assertTrue(""Start timestamp "" + bucket.getStartTimeStamp() + "" is less than "" +
                mStartTime, bucket.getStartTimeStamp() >= mStartTime);
        assertTrue(""End timestamp "" + bucket.getEndTimeStamp() + "" is greater than "" +
                mEndTime, bucket.getEndTimeStamp() <= mEndTime);
    }

    private static class TestUsageCallback extends NetworkStatsManager.UsageCallback {
        @Override
        public void onThresholdReached(int networkType, String subscriberId) {
            Log.v(LOG_TAG, ""Called onThresholdReached for networkType="" + networkType
                    + "" subscriberId="" + subscriberId);
        }
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.PrivilegedUpdateTests"	"isDefaultAbi"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PrivilegedUpdateTests.java"	""	"public void test/*
 *.
 */

package android.appsecurity.cts;

import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.LargeTest;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.Log;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IAbi;
import com.android.tradefed.testtype.IAbiReceiver;
import com.android.tradefed.testtype.IBuildReceiver;
import com.android.tradefed.util.AbiFormatter;

/**
 * Tests that verify intent filters.
 */
@LargeTest
@AppModeFull(reason=""Instant applications can never be system or privileged"")
public class PrivilegedUpdateTests extends DeviceTestCase implements IAbiReceiver, IBuildReceiver {
    private static final String TAG = ""PrivilegedUpdateTests"";
    private static final String SHIM_PKG = ""com.android.cts.priv.ctsshim"";
    /** Package name of the tests to be run */
    private static final String TEST_PKG = ""com.android.cts.privilegedupdate"";

    /** APK that contains the shim update; to test upgrading */
    private static final String SHIM_UPDATE_APK = ""CtsShimPrivUpgradePrebuilt.apk"";
    /** APK that contains the shim update w/ incorrect SHA; to test upgrade fails */
    private static final String SHIM_UPDATE_FAIL_APK = ""CtsShimPrivUpgradeWrongSHAPrebuilt.apk"";
    /** APK that contains individual shim test cases */
    private static final String TEST_APK = ""CtsPrivilegedUpdateTests.apk"";

    private static final String RESTRICTED_UPGRADE_FAILURE =
            ""INSTALL_FAILED_INVALID_APK:""
            + "" New package fails restrict-update check:""
            + "" com.android.cts.priv.ctsshim"";

    private IAbi mAbi;
    private CompatibilityBuildHelper mBuildHelper;

    private boolean isDefaultAbi() throws Exception {
        String defaultAbi = AbiFormatter.getDefaultAbi(getDevice(), mAbi.getBitness());
        return mAbi.getName().equals(defaultAbi);
    }

    @Override
    public void setAbi(IAbi abi) {
        mAbi = abi;
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mBuildHelper = new CompatibilityBuildHelper(buildInfo);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        Utils.prepareSingleUser(getDevice());
        assertNotNull(mAbi);
        assertNotNull(mBuildHelper);

        getDevice().uninstallPackage(SHIM_PKG);
        getDevice().uninstallPackage(TEST_PKG);

        assertNull(getDevice().installPackage(mBuildHelper.getTestFile(TEST_APK), false));
        getDevice().executeShellCommand(""pm enable "" + SHIM_PKG);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();

        getDevice().uninstallPackage(SHIM_PKG);
        getDevice().uninstallPackage(TEST_PKG);
        getDevice().executeShellCommand(""pm enable "" + SHIM_PKG);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.PrivilegedUpdateTests"	"testPrivilegedAppUpgradeRestricted"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PrivilegedUpdateTests.java"	""	"public void testPrivilegedAppUpgradeRestricted() throws Exception {
        getDevice().uninstallPackage(SHIM_PKG);
        assertEquals(RESTRICTED_UPGRADE_FAILURE, getDevice().installPackage(
                mBuildHelper.getTestFile(SHIM_UPDATE_FAIL_APK), true));
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.bootstats.cts.BootStatsHostTest"	"testBootStats"	"CtsBootStatsTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/bootstats/src/android/bootstats/cts/BootStatsHostTest.java"	""	"public void testBootStats() throws Exception {
        final int apiLevel = getDevice().getApiLevel();
        Assume.assumeFalse(""Skipping test because boot time metrics were introduced""
                + "" in Android 8.0. Current API Level "" + apiLevel,
                apiLevel < 26 /* Build.VERSION_CODES.O */);

        if (apiLevel <= 29 /* Build.VERSION_CODES.Q */) {
            testBootStatsForApiLevel29AndBelow();
            return;
        }

        // Clear buffer to make it easier to find new logs
        getDevice().executeShellCommand(""logcat --buffer=events --clear"");

        // reboot device
        getDevice().rebootUntilOnline();

        LinkedList<String> expectedAtomHeaders = new LinkedList<>();
        // example format: Atom 239->(total count)5, (error count)0
        for (int atom : ATOMS_EXPECTED) {
            expectedAtomHeaders.add(""Atom "" + atom + ""->(total count)"");
        }
        long timeoutMs = System.currentTimeMillis() + MAX_WAIT_TIME_MS;
        while (System.currentTimeMillis() < timeoutMs) {
            LinkedList<String> notExistingAtoms = checkAllExpectedAtoms(expectedAtomHeaders);
            if (notExistingAtoms.isEmpty()) {
                return;
            }
            Thread.sleep(WAIT_SLEEP_MS);
        }
        assertThat(checkAllExpectedAtoms(expectedAtomHeaders)).isEmpty();
    }

    /** Check all atoms are available and return atom headers not available */
    private LinkedList<String> checkAllExpectedAtoms(LinkedList<String> expectedAtomHeaders)
            throws Exception {
        LinkedList<String> notExistingAtoms = new LinkedList<>(expectedAtomHeaders);
        String log = getDevice().executeShellCommand(""cmd stats print-stats"");
        for (String atom : expectedAtomHeaders) {
            int atomIndex = log.indexOf(atom);
            if (atomIndex < 0) {
                continue;
            }
            int numberOfEvents = getIntValue(log, atomIndex + atom.length());
            if (numberOfEvents <= 0) {
                continue;
            }
            // valid event happened.
            notExistingAtoms.remove(atom);
        }
        return notExistingAtoms;
    }

    // extract the value from the string starting from index till ',''
    private int getIntValue(String str, int index) throws Exception {
        int lastIndex = index;
        for (int i = index; i < str.length(); i++) {
            if (str.charAt(i) == ',') {
                lastIndex = i;
                break;
            }
        }
        String valueStr = str.substring(index, lastIndex);
        int value = Integer.valueOf(valueStr);
        return value;
    }

    /** Need to keep the old version of test for api 27, 28, 29 as new version 
        of tests can be used on devices with old Android versions */
    private void testBootStatsForApiLevel29AndBelow() throws Exception {
        long startTime = System.currentTimeMillis();
        // Clear buffer to make it easier to find new logs
        getDevice().executeShellCommand(""logcat --buffer=events --clear"");

        // reboot device
        getDevice().rebootUntilOnline();
        waitForBootCompleted();
        int upperBoundSeconds = (int) ((System.currentTimeMillis() - startTime) / 1000);

        // wait for logs to post
        Thread.sleep(10000);

        // find logs and parse them
        // ex: sysui_multi_action: [757,804,799,ota_boot_complete,801,85,802,1]
        // ex: 757,804,799,counter_name,801,bucket_value,802,increment_value
        final String bucketTag = Integer.toString(MetricsEvent.RESERVED_FOR_LOGBUILDER_BUCKET);
        final String counterNameTag = Integer.toString(MetricsEvent.RESERVED_FOR_LOGBUILDER_NAME);
        final String counterNamePattern = counterNameTag + "",boot_complete,"";
        final String multiActionPattern = ""sysui_multi_action: ["";

        final String log = getDevice().executeShellCommand(""logcat --buffer=events -d"");

        int counterNameIndex = log.indexOf(counterNamePattern);
        Assert.assertTrue(""did not find boot logs"", counterNameIndex != -1);

        int multiLogStart = log.lastIndexOf(multiActionPattern, counterNameIndex);
        multiLogStart += multiActionPattern.length();
        int multiLogEnd = log.indexOf(""]"", multiLogStart);
        String[] multiLogDataStrings = log.substring(multiLogStart, multiLogEnd).split("","");

        boolean foundBucket = false;
        int bootTime = 0;
        for (int i = 0; i < multiLogDataStrings.length; i += 2) {
            if (bucketTag.equals(multiLogDataStrings[i])) {
                foundBucket = true;
                Assert.assertTrue(""histogram data was truncated"",
                        (i + 1) < multiLogDataStrings.length);
                bootTime = Integer.valueOf(multiLogDataStrings[i + 1]);
            }
        }
        Assert.assertTrue(""log line did not contain a tag "" + bucketTag, foundBucket);
        Assert.assertTrue(""reported boot time must be less than observed boot time"",
                bootTime < upperBoundSeconds);
        Assert.assertTrue(""reported boot time must be non-zero"", bootTime > 0);
    }

    private boolean isBootCompleted() throws Exception {
        return ""1"".equals(getDevice().executeShellCommand(""getprop sys.boot_completed"").trim());
    }

    private void waitForBootCompleted() throws Exception {
        for (int i = 0; i < 45; i++) {
            if (isBootCompleted()) {
                return;
            }
            Thread.sleep(1000);
        }
        throw new AssertionError(""System failed to become ready!"");
    }

    @Override
    public void setDevice(ITestDevice device) {
        mDevice = device;
    }

    @Override
    public ITestDevice getDevice() {
        return mDevice;
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyGenParameterSpecTest"	"testDefaults"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyGenParameterSpecTest.java"	""	"public void testDefaults() {
        // Set only the mandatory parameters and assert values returned by getters.

        KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(
                ""arbitrary"", KeyProperties.PURPOSE_ENCRYPT)
                .build();

        assertEquals(""arbitrary"", spec.getKeystoreAlias());
        assertEquals(KeyProperties.PURPOSE_ENCRYPT, spec.getPurposes());
        assertNull(null, spec.getAlgorithmParameterSpec());
        MoreAsserts.assertEmpty(Arrays.asList(spec.getBlockModes()));
        assertEquals(DEFAULT_CERT_NOT_BEFORE, spec.getCertificateNotBefore());
        assertEquals(DEFAULT_CERT_NOT_AFTER, spec.getCertificateNotAfter());
        assertEquals(DEFAULT_CERT_SERIAL_NUMBER, spec.getCertificateSerialNumber());
        assertEquals(DEFAULT_CERT_SUBJECT, spec.getCertificateSubject());
        assertFalse(spec.isDigestsSpecified());
        try {
            spec.getDigests();
            fail();
        } catch (IllegalStateException expected) {}
        MoreAsserts.assertEmpty(Arrays.asList(spec.getEncryptionPaddings()));
        assertEquals(-1, spec.getKeySize());
        assertNull(spec.getKeyValidityStart());
        assertNull(spec.getKeyValidityForOriginationEnd());
        assertNull(spec.getKeyValidityForConsumptionEnd());
        assertTrue(spec.isRandomizedEncryptionRequired());
        MoreAsserts.assertEmpty(Arrays.asList(spec.getSignaturePaddings()));
        assertFalse(spec.isUserAuthenticationRequired());
        assertEquals(0, spec.getUserAuthenticationValidityDurationSeconds());
        assertEquals(KeyProperties.AUTH_BIOMETRIC_STRONG, spec.getUserAuthenticationType());
        assertFalse(spec.isUnlockedDeviceRequired());
        assertEquals(KeyProperties.UNRESTRICTED_USAGE_COUNT, spec.getMaxUsageCount());
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorTestCase"	"SensorTestCase"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorTestCase.java"	""	"public void test/*
 *.
 */

package android.hardware.cts;

import android.hardware.Sensor;
import android.hardware.cts.helpers.SensorTestStateNotSupportedException;
import android.hardware.cts.helpers.TestSensorEnvironment;
import android.hardware.cts.helpers.reporting.ISensorTestNode;
import android.hardware.cts.helpers.sensoroperations.SensorOperation;
import android.test.AndroidTestCase;
import android.util.Log;

/**
 * Test Case class that handles gracefully sensors that are not available in the device.
 */
public abstract class SensorTestCase extends AndroidTestCase {
    // TODO: consolidate all log tags
    protected static final String LOG_TAG = ""TestRunner"";

    /**
     * Previously for L release, we had this flag to know if each sensor is running with multiple
     * listeners each requesting different data rates. Now before running CTS tests all sensors
     * are de-activated by putting SensorService in RESTRICTED mode. Only CTS tests can
     * activate/deactivate sensors in this mode. So we can default this flag value to false.
     */
    private volatile boolean mEmulateSensorUnderLoad = false;

    /**
     * By default the test class is the root of the test hierarchy.
     */
    private volatile ISensorTestNode mCurrentTestNode = new TestClassNode(getClass());

    protected SensorTestCase() {}

    @Override
    public void runBare() throws Throwable {
        try {
            super.runBare();
        } catch (SensorTestStateNotSupportedException e) {
            // the sensor state is not supported in the device, log a warning and skip the test
            Log.w(LOG_TAG, e.getMessage());
        }
    }

    public void setEmulateSensorUnderLoad(boolean value) {
        mEmulateSensorUnderLoad = value;
    }

    protected boolean shouldEmulateSensorUnderLoad() {
        return mEmulateSensorUnderLoad;
    }

    public void setCurrentTestNode(ISensorTestNode value) {
        mCurrentTestNode = value;
    }

    protected ISensorTestNode getCurrentTestNode() {
        return mCurrentTestNode;
    }

    private class TestClassNode implements ISensorTestNode {
        private final Class<?> mTestClass;

        public TestClassNode(Class<?> testClass) {
            mTestClass = testClass;
        }

        @Override
        public String getName() {
            return mTestClass.getSimpleName();
        }
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.theme.cts.ThemeHostTest"	"checkHardwareTypeSkipTest"	"CtsThemeHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/theme/src/android/theme/cts/ThemeHostTest.java"	""	"public void test/*
 *.
 */

package android.theme.cts;

import android.platform.test.annotations.RequiresDevice;

import com.android.ddmlib.Log;
import com.android.ddmlib.Log.LogLevel;
import com.android.tradefed.device.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.result.FileInputStreamSource;
import com.android.tradefed.result.InputStreamSource;
import com.android.tradefed.result.LogDataType;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.util.Pair;
import com.android.tradefed.util.StreamUtil;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * Test to check non-modifiable themes have not been changed.
 */
public class ThemeHostTest extends DeviceTestCase {

    private static final String LOG_TAG = ""ThemeHostTest"";
    private static final String APP_PACKAGE_NAME = ""android.theme.app"";

    private static final String GENERATED_ASSETS_ZIP = ""/sdcard/cts-theme-assets.zip"";

    /** The class name of the main activity in the APK. */
    private static final String TEST_CLASS = ""androidx.test.runner.AndroidJUnitRunner"";

    /** The command to launch the main instrumentation test. */
    private static final String START_CMD = String.format(
            ""am instrument -w --no-isolated-storage --no-window-animation %s/%s"",
            APP_PACKAGE_NAME, TEST_CLASS);

    private static final String CLEAR_GENERATED_CMD = ""rm -rf %s/*.png"";
    private static final String STOP_CMD = String.format(""am force-stop %s"", APP_PACKAGE_NAME);

    /** Shell command used to obtain current device density. */
    private static final String WM_DENSITY = ""wm density"";

    /** Overall test timeout is 30 minutes. Should only take about 5. */
    private static final int TEST_RESULT_TIMEOUT = 30 * 60 * 1000;

    /** Map of reference image names and files. */
    private Map<String, File> mReferences;

    /** A reference to the device under test. */
    private ITestDevice mDevice;

    private ExecutorService mExecutionService;

    private ExecutorCompletionService<Pair<String, File>> mCompletionService;

    // Density to which the device should be restored, or -1 if unnecessary.
    private int mRestoreDensity;


    @Override
    protected void setUp() throws Exception {
        super.setUp();

        mDevice = getDevice();
        mRestoreDensity = resetDensityIfNeeded(mDevice);
        final String density = getDensityBucketForDevice(mDevice);
        final String referenceZipAssetPath = String.format(""/%s.zip"", density);
        mReferences = extractReferenceImages(referenceZipAssetPath);

        final int numCores = Runtime.getRuntime().availableProcessors();
        mExecutionService = Executors.newFixedThreadPool(numCores * 2);
        mCompletionService = new ExecutorCompletionService<>(mExecutionService);
    }

    private Map<String, File> extractReferenceImages(String zipFile) throws Exception {
        final Map<String, File> references = new HashMap<>();
        final InputStream zipStream = ThemeHostTest.class.getResourceAsStream(zipFile);
        if (zipStream != null) {
            try (ZipInputStream in = new ZipInputStream(zipStream)) {
                final byte[] buffer = new byte[1024];
                for (ZipEntry ze; (ze = in.getNextEntry()) != null; ) {
                    final String name = ze.getName();
                    final File tmp = File.createTempFile(""ref_"" + name, "".png"");
                    tmp.deleteOnExit();
                    try (FileOutputStream out = new FileOutputStream(tmp)) {
                        for (int count; (count = in.read(buffer)) != -1; ) {
                            out.write(buffer, 0, count);
                        }
                    }

                    references.put(name, tmp);
                }
            } catch (IOException e) {
                fail(""Failed to unzip assets: "" + zipFile);
            }
        } else {
            if (checkHardwareTypeSkipTest()) {
                Log.logAndDisplay(LogLevel.WARN, LOG_TAG,
                        ""Could not obtain resources for skipped themes test: "" + zipFile);
            } else {
                fail(""Failed to get resource: "" + zipFile);
            }
        }

        return references;
    }

    @Override
    protected void tearDown() throws Exception {
        mExecutionService.shutdown();

        // Remove generated images.
        mDevice.executeShellCommand(CLEAR_GENERATED_CMD);

        restoreDensityIfNeeded(mDevice, mRestoreDensity);

        super.tearDown();
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.theme.cts.ThemeHostTest"	"testThemes"	"CtsThemeHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/theme/src/android/theme/cts/ThemeHostTest.java"	""	"public void testThemes() throws Exception {
        if (checkHardwareTypeSkipTest()) {
            Log.logAndDisplay(LogLevel.INFO, LOG_TAG, ""Skipped themes test for watch / TV / automotive"");
            return;
        }
        if (mReferences.isEmpty()) {
            Log.logAndDisplay(LogLevel.INFO, LOG_TAG,
                    ""Skipped themes test due to missing reference images"");
            return;
        }

        assertTrue(""Aborted image generation, see device log for details"", generateDeviceImages());

        // Pull ZIP file from remote device.
        final File localZip = File.createTempFile(""generated"", "".zip"");
        assertTrue(""Failed to pull generated assets from device"",
                mDevice.pullFile(GENERATED_ASSETS_ZIP, localZip));

        final int numTasks = extractGeneratedImages(localZip, mReferences);

        int failureCount = 0;
        for (int i = numTasks; i > 0; i--) {
            final Pair<String, File> comparison = mCompletionService.take().get();
            if (comparison != null) {
                InputStreamSource inputStream = new FileInputStreamSource(comparison.second);
                try{
                    // Log the diff file
                    addTestLog(comparison.first, LogDataType.PNG, inputStream);
                } finally {
                    StreamUtil.cancel(inputStream);
                }
                failureCount++;
            }
        }

        assertTrue(failureCount + "" failures in theme test"", failureCount == 0);
    }

    private int extractGeneratedImages(File localZip, Map<String, File> references)
            throws IOException {
        int numTasks = 0;

        // Extract generated images to temporary files.
        final byte[] data = new byte[8192];
        try (ZipInputStream zipInput = new ZipInputStream(new FileInputStream(localZip))) {
            for (ZipEntry entry; (entry = zipInput.getNextEntry()) != null; ) {
                final String name = entry.getName();
                final File expected = references.get(name);
                if (expected != null && expected.exists()) {
                    final File actual = File.createTempFile(""actual_"" + name, "".png"");
                    actual.deleteOnExit();

                    try (FileOutputStream pngOutput = new FileOutputStream(actual)) {
                        for (int count; (count = zipInput.read(data, 0, data.length)) != -1; ) {
                            pngOutput.write(data, 0, count);
                        }
                    }

                    final String shortName = name.substring(0, name.indexOf('.'));
                    mCompletionService.submit(new ComparisonTask(shortName, expected, actual));
                    numTasks++;
                } else {
                    Log.logAndDisplay(LogLevel.INFO, LOG_TAG,
                            ""Missing reference image for "" + name);
                }

                zipInput.closeEntry();
            }
        }

        return numTasks;
    }

    private boolean generateDeviceImages() throws Exception {
        // Stop any existing instances.
        mDevice.executeShellCommand(STOP_CMD);

        // Start instrumentation test.
        final CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        mDevice.executeShellCommand(START_CMD, receiver, TEST_RESULT_TIMEOUT,
                TimeUnit.MILLISECONDS, 0);

        return receiver.getOutput().contains(""OK "");
    }

    private static String getDensityBucketForDevice(ITestDevice device) {
        final int density;
        try {
            density = getDensityForDevice(device);
        } catch (DeviceNotAvailableException e) {
            throw new RuntimeException(""Failed to detect device density"", e);
        }
        final String bucket;
        switch (density) {
            case 120:
                bucket = ""ldpi"";
                break;
            case 160:
                bucket = ""mdpi"";
                break;
            case 213:
                bucket = ""tvdpi"";
                break;
            case 240:
                bucket = ""hdpi"";
                break;
            case 320:
                bucket = ""xhdpi"";
                break;
            case 480:
                bucket = ""xxhdpi"";
                break;
            case 640:
                bucket = ""xxxhdpi"";
                break;
            default:
                bucket = density + ""dpi"";
                break;
        }

        Log.logAndDisplay(LogLevel.INFO, LOG_TAG,
                ""Device density detected as "" + density + "" ("" + bucket + "")"");
        return bucket;
    }

    private static int resetDensityIfNeeded(ITestDevice device) throws DeviceNotAvailableException {
        final String output = device.executeShellCommand(WM_DENSITY);
         final Pattern p = Pattern.compile(""Override density: (\\d+)"");
         final Matcher m = p.matcher(output);
         if (m.find()) {
             device.executeShellCommand(WM_DENSITY + "" reset"");
             int restoreDensity = Integer.parseInt(m.group(1));
             return restoreDensity;
         }
         return -1;
    }

    private static void restoreDensityIfNeeded(ITestDevice device, int restoreDensity)
            throws DeviceNotAvailableException {
        if (restoreDensity > 0) {
            device.executeShellCommand(WM_DENSITY + "" "" + restoreDensity);
        }
    }

    private static int getDensityForDevice(ITestDevice device) throws DeviceNotAvailableException {
        final String output = device.executeShellCommand(WM_DENSITY);
        final Pattern p = Pattern.compile(""Physical density: (\\d+)"");
        final Matcher m = p.matcher(output);
        if (m.find()) {
            return Integer.parseInt(m.group(1));
        }
        throw new RuntimeException(""Failed to detect device density"");
    }

    private boolean checkHardwareTypeSkipTest() {
        try {
         if( mDevice.hasFeature(""feature:android.hardware.type.watch"")
                 || mDevice.hasFeature(""feature:android.hardware.type.television"")
                 || mDevice.hasFeature(""feature:android.hardware.type.automotive"")) {
             return true;
         }
        } catch (DeviceNotAvailableException ex) {
             return false;
        }
        return false;
    }

    private static boolean isEmulator(ITestDevice device) {
        // Expecting something like ""emulator-XXXX"" or ""EMULATORXXXX"".
        return device.getSerialNumber().toLowerCase().startsWith(""emulator"");
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.BackgroundRestrictedAlarmsTest"	"testAlarmClockNotBlocked"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/BackgroundRestrictedAlarmsTest.java"	""	"public void testAlarmClockNotBlocked() throws Exception {
        final long nowRTC = System.currentTimeMillis();
        final long waitInterval = 3_000;
        final long triggerRTC = nowRTC + waitInterval;
        scheduleAlarmClock(triggerRTC);
        Thread.sleep(waitInterval);
        assertTrue(""AlarmClock did not go off as scheduled when under restrictions"",
                waitForAlarms(1, DEFAULT_WAIT));
    }

    @After
    public void tearDown() throws Exception {
        deleteAlarmManagerConstants();
        setAppOpsMode(APP_OP_MODE_ALLOWED);
        // Cancel any leftover alarms
        final Intent cancelAlarmsIntent = new Intent(TestAlarmScheduler.ACTION_CANCEL_ALL_ALARMS);
        cancelAlarmsIntent.setComponent(mAlarmScheduler);
        mContext.sendBroadcast(cancelAlarmsIntent);
        mContext.unregisterReceiver(mAlarmStateReceiver);
        // Broadcast unregister may race with the next register in setUp
        Thread.sleep(DEFAULT_WAIT);
    }

    private void updateAlarmManagerConstants() {
        mConfigHelper.with(""min_futurity"", 0L)
                .with(""min_interval"", MIN_REPEATING_INTERVAL)
                .with(""min_window"", 0)
                .commitAndAwaitPropagation();
    }

    private void deleteAlarmManagerConstants() {
        mConfigHelper.restoreAll();
    }

    private void setAppStandbyBucket(String bucket) throws IOException {
        mUiDevice.executeShellCommand(""am set-standby-bucket "" + TEST_APP_PACKAGE + "" "" + bucket);
    }

    private void setAppOpsMode(String mode) throws IOException {
        StringBuilder commandBuilder = new StringBuilder(""appops set "")
                .append(TEST_APP_PACKAGE)
                .append("" "")
                .append(APP_OP_RUN_ANY_IN_BACKGROUND)
                .append("" "")
                .append(mode);
        mUiDevice.executeShellCommand(commandBuilder.toString());
    }

    private void makeUidIdle() throws IOException {
        mUiDevice.executeShellCommand(""cmd devideidle tempwhitelist -r "" + TEST_APP_PACKAGE);
        mUiDevice.executeShellCommand(""am make-uid-idle "" + TEST_APP_PACKAGE);
    }

    private boolean waitForAlarms(int expectedAlarms, long timeout) throws InterruptedException {
        final long deadLine = SystemClock.uptimeMillis() + timeout;
        int alarmCount;
        do {
            Thread.sleep(POLL_INTERVAL);
            alarmCount = mAlarmCount;
        } while (alarmCount < expectedAlarms && SystemClock.uptimeMillis() < deadLine);
        return alarmCount >= expectedAlarms;
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.lib.ReportUtils"	"getMetricsList"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/lib/ReportUtils.java"	""	"public void test/*
 *.
 */

package android.cts.statsdatom.lib;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import com.android.os.AtomsProto.Atom;
import com.android.os.StatsLog.ConfigMetricsReport;
import com.android.os.StatsLog.ConfigMetricsReportList;
import com.android.os.StatsLog.EventMetricData;
import com.android.os.StatsLog.GaugeBucketInfo;
import com.android.os.StatsLog.GaugeMetricData;
import com.android.os.StatsLog.StatsLogReport;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;

import com.google.protobuf.InvalidProtocolBufferException;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public final class ReportUtils {
    private static final String DUMP_REPORT_CMD = ""cmd stats dump-report"";
    private static final long NS_PER_SEC = (long) 1E+9;

    /**
     * Returns a list of event metrics, which is sorted by timestamp, from the statsd report.
     * Note: Calling this function deletes the report from statsd.
     */
    public static List<EventMetricData> getEventMetricDataList(ITestDevice device)
            throws Exception {
        ConfigMetricsReportList reportList = getReportList(device);
        return getEventMetricDataList(reportList);
    }

    /**
     * Extracts and sorts the EventMetricData from the given ConfigMetricsReportList (which must
     * contain a single report).
     */
    public static List<EventMetricData> getEventMetricDataList(ConfigMetricsReportList reportList)
            throws Exception {
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        ConfigMetricsReport report = reportList.getReports(0);

        List<EventMetricData> data = new ArrayList<>();
        for (StatsLogReport metric : report.getMetricsList()) {
            data.addAll(metric.getEventMetrics().getDataList());
        }
        data.sort(Comparator.comparing(EventMetricData::getElapsedTimestampNanos));

        CLog.d(""Get EventMetricDataList as following:\n"");
        for (EventMetricData d : data) {
            CLog.d(""Atom at "" + d.getElapsedTimestampNanos() + "":\n"" + d.getAtom().toString());
        }
        return data;
    }

    public static List<Atom> getGaugeMetricAtoms(ITestDevice device) throws Exception {
        return getGaugeMetricAtoms(device, /*checkTimestampTruncated=*/false);
    }

    /**
     * Returns a list of gauge atoms from the statsd report. Assumes that there is only one bucket
     * for the gauge metric.
     * Note: calling this function deletes the report from statsd.
     *
     * @param checkTimestampTrucated if true, checks that atom timestmaps are properly truncated
     */
    public static List<Atom> getGaugeMetricAtoms(ITestDevice device,
            boolean checkTimestampTruncated) throws Exception {
        ConfigMetricsReportList reportList = getReportList(device);
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        ConfigMetricsReport report = reportList.getReports(0);
        assertThat(report.getMetricsCount()).isEqualTo(1);

        List<Atom> atoms = new ArrayList<>();
        for (GaugeMetricData d : report.getMetrics(0).getGaugeMetrics().getDataList()) {
            assertThat(d.getBucketInfoCount()).isEqualTo(1);
            GaugeBucketInfo bucketInfo = d.getBucketInfo(0);
            atoms.addAll(bucketInfo.getAtomList());
            if (checkTimestampTruncated) {
                for (long timestampNs: bucketInfo.getElapsedTimestampNanosList()) {
                    assertTimestampIsTruncated(timestampNs);
                }
            }
        }

        CLog.d(""Got the following GaugeMetric atoms:\n"");
        for (Atom atom : atoms) {
            CLog.d(""Atom:\n"" + atom.toString());
        }
        return atoms;
    }

    /**
     * Delete all pre-existing reports corresponding to the CTS config.
     */
    public static void clearReports(ITestDevice device) throws Exception {
        getReportList(device);
    }

    /**
     * Retrieves the ConfigMetricsReports corresponding to the CTS config from statsd.
     * Note: Calling this functions deletes the report from statsd.
     */
    private static ConfigMetricsReportList getReportList(ITestDevice device) throws Exception {
        try {
            String cmd = String.join("" "", DUMP_REPORT_CMD, ConfigUtils.CONFIG_ID_STRING,
                    ""--include_current_bucket"", ""--proto"");
            ConfigMetricsReportList reportList = DeviceUtils.getShellCommandOutput(device,
                    ConfigMetricsReportList.parser(), cmd);
            return reportList;
        } catch (InvalidProtocolBufferException ex) {
            int hostUid = DeviceUtils.getHostUid(device);
            CLog.e(""Failed to fetch and parse the statsd output report. Perhaps there is not a ""
                    + ""valid statsd config for the requested uid="" + hostUid + "", id=""
                    + ConfigUtils.CONFIG_ID + ""."");
            throw ex;
        }
    }

    /**
     * Checks that a timestamp has been truncated to a multiple of 5 min.
     */
    private static void assertTimestampIsTruncated(long timestampNs) {
        long fiveMinutesInNs = NS_PER_SEC * 5 * 60;
        assertWithMessage(""Timestamp is not truncated"")
                .that(timestampNs % fiveMinutesInNs).isEqualTo(0);
    }

    private ReportUtils() {}
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.AppStandbyTests"	"setUpTests"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/AppStandbyTests.java"	""	"/*
 *.
 */

package android.alarmmanager.cts;

import static android.app.AlarmManager.ELAPSED_REALTIME_WAKEUP;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.alarmmanager.alarmtestapp.cts.TestAlarmReceiver;
import android.alarmmanager.alarmtestapp.cts.TestAlarmScheduler;
import android.alarmmanager.util.AlarmManagerDeviceConfigHelper;
import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.BatteryManager;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Log;
import android.util.LongArray;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.LargeTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AppStandbyUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BooleanSupplier;

/**
 * Tests that app standby imposes the appropriate restrictions on alarms
 */
@AppModeFull
@LargeTest
@RunWith(AndroidJUnit4.class)
public class AppStandbyTests {
    private static final String TAG = AppStandbyTests.class.getSimpleName();
    static final String TEST_APP_PACKAGE = ""android.alarmmanager.alarmtestapp.cts"";
    private static final String TEST_APP_RECEIVER = TEST_APP_PACKAGE + "".TestAlarmScheduler"";

    private static final long DEFAULT_WAIT = 2_000;
    private static final long POLL_INTERVAL = 200;

    // Tweaked alarm manager constants to facilitate testing
    private static final long MIN_FUTURITY = 1_000;

    // Not touching ACTIVE and RARE parameters for this test
    private static final int WORKING_INDEX = 0;
    private static final int FREQUENT_INDEX = 1;
    private static final int RARE_INDEX = 2;
    private static final String[] APP_BUCKET_TAGS = {
            ""working_set"",
            ""frequent"",
            ""rare"",
    };

    private static final long APP_STANDBY_WINDOW = 10_000;
    private static final long MIN_WINDOW = 100;
    private static final String[] APP_BUCKET_QUOTA_KEYS = {
            ""standby_quota_working"",
            ""standby_quota_frequent"",
            ""standby_quota_rare"",
    };
    private static final int[] APP_STANDBY_QUOTAS = {
            5,  // Working set
            3,  // Frequent
            1,  // Rare
    };

    // Save the state before running tests to restore it after we finish testing.
    private static boolean sOrigAppStandbyEnabled;
    // Test app's alarm history to help predict when a subsequent alarm is going to get deferred.
    private static TestAlarmHistory sAlarmHistory;
    private static Context sContext = InstrumentationRegistry.getTargetContext();
    private static UiDevice sUiDevice = UiDevice.getInstance(
            InstrumentationRegistry.getInstrumentation());

    private ComponentName mAlarmScheduler;
    private AtomicInteger mAlarmCount;
    private AlarmManagerDeviceConfigHelper mConfigHelper = new AlarmManagerDeviceConfigHelper();

    private final BroadcastReceiver mAlarmStateReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            mAlarmCount.getAndAdd(intent.getIntExtra(TestAlarmReceiver.EXTRA_ALARM_COUNT, 1));
            final long nowElapsed = SystemClock.elapsedRealtime();
            sAlarmHistory.addTime(nowElapsed);
            Log.d(TAG, ""No. of expirations: "" + mAlarmCount + "" elapsed: "" + nowElapsed);
        }
    };

    @BeforeClass
    public static void setUpTests() throws Exception {
        sAlarmHistory = new TestAlarmHistory();
        sOrigAppStandbyEnabled = AppStandbyUtils.isAppStandbyEnabledAtRuntime();
        if (!sOrigAppStandbyEnabled) {
            AppStandbyUtils.setAppStandbyEnabledAtRuntime(true);

            // Give system sometime to initialize itself.
            Thread.sleep(100);
        }
    }

    @Before
    public void setUp() throws Exception {
        mAlarmScheduler = new ComponentName(TEST_APP_PACKAGE, TEST_APP_RECEIVER);
        mAlarmCount = new AtomicInteger(0);
        updateAlarmManagerConstants();
        setBatteryCharging(false);
        final IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(TestAlarmReceiver.ACTION_REPORT_ALARM_EXPIRED);
        sContext.registerReceiver(mAlarmStateReceiver, intentFilter);
        assumeTrue(""App Standby not enabled on device"", AppStandbyUtils.isAppStandbyEnabled());
    }

    private void scheduleAlarm(long triggerMillis, long interval) throws InterruptedException {
        final Intent setAlarmIntent = new Intent(TestAlarmScheduler.ACTION_SET_ALARM);
        setAlarmIntent.setComponent(mAlarmScheduler);
        setAlarmIntent.putExtra(TestAlarmScheduler.EXTRA_TYPE, ELAPSED_REALTIME_WAKEUP);
        setAlarmIntent.putExtra(TestAlarmScheduler.EXTRA_TRIGGER_TIME, triggerMillis);
        setAlarmIntent.putExtra(TestAlarmScheduler.EXTRA_WINDOW_LENGTH, MIN_WINDOW);
        setAlarmIntent.putExtra(TestAlarmScheduler.EXTRA_REPEAT_INTERVAL, interval);
        setAlarmIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        final CountDownLatch resultLatch = new CountDownLatch(1);
        sContext.sendOrderedBroadcast(setAlarmIntent, null, new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                resultLatch.countDown();
            }
        }, null, Activity.RESULT_CANCELED, null, null);
        assertTrue(""Request did not complete"", resultLatch.await(10, TimeUnit.SECONDS));
    }

    public void testSimpleQuotaDeferral(int bucketIndex) throws Exception {
        setTestAppStandbyBucket(APP_BUCKET_TAGS[bucketIndex]);
        final int quota = APP_STANDBY_QUOTAS[bucketIndex];

        long startElapsed = SystemClock.elapsedRealtime();
        final long freshWindowPoint = sAlarmHistory.getLast(1) + APP_STANDBY_WINDOW;
        if (freshWindowPoint > startElapsed) {
            Thread.sleep(freshWindowPoint - startElapsed);
            startElapsed = freshWindowPoint;
            // Now we should have no alarms in the past APP_STANDBY_WINDOW
        }
        final long desiredTrigger = startElapsed + APP_STANDBY_WINDOW;
        final long firstTrigger = startElapsed + 4_000;
        assertTrue(""Quota too large for test"",
                firstTrigger + ((quota - 1) * MIN_FUTURITY) < desiredTrigger);
        for (int i = 0; i < quota; i++) {
            final long trigger = firstTrigger + (i * MIN_FUTURITY);
            scheduleAlarm(trigger, 0);
            Thread.sleep(trigger - SystemClock.elapsedRealtime());
            assertTrue(""Alarm within quota not firing as expected"", waitForAlarm());
        }

        // Now quota is reached, any subsequent alarm should get deferred.
        scheduleAlarm(desiredTrigger, 0);
        Thread.sleep(desiredTrigger - SystemClock.elapsedRealtime());
        assertFalse(""Alarm exceeding quota not deferred"", waitForAlarm());
        final long minTrigger = firstTrigger + APP_STANDBY_WINDOW;
        Thread.sleep(minTrigger - SystemClock.elapsedRealtime());
        assertTrue(""Alarm exceeding quota not delivered after expected delay"", waitForAlarm());
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.AppStandbyTests"	"testActiveQuota"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/AppStandbyTests.java"	""	"public void testActiveQuota() throws Exception {
        setTestAppStandbyBucket(""active"");
        long nextTrigger = SystemClock.elapsedRealtime() + MIN_FUTURITY;
        for (int i = 0; i < 3; i++) {
            scheduleAlarm(nextTrigger, 0);
            Thread.sleep(MIN_FUTURITY);
            assertTrue(""Alarm not received as expected when app is in active"", waitForAlarm());
            nextTrigger += MIN_FUTURITY;
        }
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.AppStandbyTests"	"testNeverQuota"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/AppStandbyTests.java"	""	"public void testNeverQuota() throws Exception {
        setTestAppStandbyBucket(""never"");
        final long expectedTrigger = SystemClock.elapsedRealtime() + MIN_FUTURITY;
        scheduleAlarm(expectedTrigger, 0);
        Thread.sleep(10_000);
        assertFalse(""Alarm received when app was in never bucket"", waitForAlarm());
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.AppStandbyTests"	"testPowerWhitelistedAlarmNotBlocked"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/AppStandbyTests.java"	""	"public void testPowerWhitelistedAlarmNotBlocked() throws Exception {
        setTestAppStandbyBucket(APP_BUCKET_TAGS[RARE_INDEX]);
        setPowerWhitelisted(true);
        final long triggerTime = SystemClock.elapsedRealtime() + MIN_FUTURITY;
        scheduleAlarm(triggerTime, 0);
        Thread.sleep(MIN_FUTURITY);
        assertTrue(""Alarm did not go off for whitelisted app in rare bucket"", waitForAlarm());
        setPowerWhitelisted(false);
    }

    @After
    public void tearDown() throws Exception {
        setPowerWhitelisted(false);
        setBatteryCharging(true);
        mConfigHelper.restoreAll();
        final Intent cancelAlarmsIntent = new Intent(TestAlarmScheduler.ACTION_CANCEL_ALL_ALARMS);
        cancelAlarmsIntent.setComponent(mAlarmScheduler);
        sContext.sendBroadcast(cancelAlarmsIntent);
        sContext.unregisterReceiver(mAlarmStateReceiver);
        // Broadcast unregister may race with the next register in setUp
        Thread.sleep(500);
    }

    @AfterClass
    public static void tearDownTests() throws Exception {
        if (!sOrigAppStandbyEnabled) {
            AppStandbyUtils.setAppStandbyEnabledAtRuntime(sOrigAppStandbyEnabled);
        }
    }

    private void updateAlarmManagerConstants() {
        mConfigHelper.with(""min_futurity"", MIN_FUTURITY)
                .with(""app_standby_window"", APP_STANDBY_WINDOW)
                .with(""min_window"", MIN_WINDOW)
                .with(""exact_alarm_deny_list"", TEST_APP_PACKAGE);
        for (int i = 0; i < APP_STANDBY_QUOTAS.length; i++) {
            mConfigHelper.with(APP_BUCKET_QUOTA_KEYS[i], APP_STANDBY_QUOTAS[i]);
        }
        mConfigHelper.commitAndAwaitPropagation();
    }

    private void setPowerWhitelisted(boolean whitelist) throws IOException {
        final StringBuffer cmd = new StringBuffer(""cmd deviceidle whitelist "");
        cmd.append(whitelist ? ""+"" : ""-"");
        cmd.append(TEST_APP_PACKAGE);
        executeAndLog(cmd.toString());
    }

    static void setTestAppStandbyBucket(String bucket) throws IOException {
        executeAndLog(""am set-standby-bucket "" + TEST_APP_PACKAGE + "" "" + bucket);
    }

    private void setBatteryCharging(final boolean charging) throws Exception {
        final BatteryManager bm = sContext.getSystemService(BatteryManager.class);
        if (charging) {
            executeAndLog(""dumpsys battery reset"");
        } else {
            executeAndLog(""dumpsys battery unplug"");
            executeAndLog(""dumpsys battery set status "" +
                    BatteryManager.BATTERY_STATUS_DISCHARGING);
            assertTrue(""Battery could not be unplugged"", waitUntil(() -> !bm.isCharging(), 5_000));
        }
    }

    private static String executeAndLog(String cmd) throws IOException {
        final String output = sUiDevice.executeShellCommand(cmd).trim();
        Log.d(TAG, ""command: ["" + cmd + ""], output: ["" + output + ""]"");
        return output;
    }

    private boolean waitForAlarm() throws InterruptedException {
        final boolean success = waitUntil(() -> (mAlarmCount.get() == 1), DEFAULT_WAIT);
        mAlarmCount.set(0);
        return success;
    }

    private boolean waitUntil(BooleanSupplier condition, long timeout) throws InterruptedException {
        final long deadLine = SystemClock.uptimeMillis() + timeout;
        while (!condition.getAsBoolean() && SystemClock.uptimeMillis() < deadLine) {
            Thread.sleep(POLL_INTERVAL);
        }
        return condition.getAsBoolean();
    }

    private static final class TestAlarmHistory {
        private LongArray mHistory = new LongArray();

        private synchronized void addTime(long timestamp) {
            mHistory.add(timestamp);
        }

        /**
         * Get the xth alarm time from the end.
         */
        private synchronized long getLast(int x) {
            if (x == 0 || x > mHistory.size()) {
                return 0;
            }
            return mHistory.get(mHistory.size() - x);
        }
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyInfoTest"	"testImmutabilityViaGetterReturnValues"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyInfoTest.java"	""	"public void testImmutabilityViaGetterReturnValues() throws Exception {
        // Assert that none of the mutable return values from getters modify the state of the
        // instance.

        Date keyValidityStartDate = new Date(System.currentTimeMillis() - 2222222);
        Date keyValidityEndDateForOrigination = new Date(System.currentTimeMillis() + 11111111);
        Date keyValidityEndDateForConsumption = new Date(System.currentTimeMillis() + 33333333);

        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"", ""AndroidKeyStore"");
        keyPairGenerator.initialize(new KeyGenParameterSpec.Builder(
                KeyInfoTest.class.getSimpleName(),
                KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_ENCRYPT)
                .setKeySize(1024) // use smaller key size to speed the test up
                .setKeyValidityStart(keyValidityStartDate)
                .setKeyValidityForOriginationEnd(keyValidityEndDateForOrigination)
                .setKeyValidityForConsumptionEnd(keyValidityEndDateForConsumption)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1,
                        KeyProperties.ENCRYPTION_PADDING_RSA_OAEP)
                .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PKCS1,
                        KeyProperties.SIGNATURE_PADDING_RSA_PSS)
                .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
                .setBlockModes(KeyProperties.BLOCK_MODE_ECB)
                .build());
        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        PrivateKey key = keyPair.getPrivate();
        KeyFactory keyFactory = KeyFactory.getInstance(key.getAlgorithm(), ""AndroidKeyStore"");
        KeyInfo info = keyFactory.getKeySpec(key, KeyInfo.class);

        Date originalKeyValidityStartDate = (Date) info.getKeyValidityStart().clone();
        info.getKeyValidityStart().setTime(1234567890L);
        assertEquals(originalKeyValidityStartDate, info.getKeyValidityStart());

        Date originalKeyValidityEndDateForOrigination =
                (Date) info.getKeyValidityForOriginationEnd().clone();
        info.getKeyValidityForOriginationEnd().setTime(1234567890L);
        assertEquals(originalKeyValidityEndDateForOrigination,
                info.getKeyValidityForOriginationEnd());

        Date originalKeyValidityEndDateForConsumption =
                (Date) info.getKeyValidityForConsumptionEnd().clone();
        info.getKeyValidityForConsumptionEnd().setTime(1234567890L);
        assertEquals(originalKeyValidityEndDateForConsumption,
                info.getKeyValidityForConsumptionEnd());

        String[] originalEncryptionPaddings = info.getEncryptionPaddings().clone();
        info.getEncryptionPaddings()[0] = null;
        assertEquals(Arrays.asList(originalEncryptionPaddings),
                Arrays.asList(info.getEncryptionPaddings()));

        String[] originalSignaturePaddings = info.getSignaturePaddings().clone();
        info.getSignaturePaddings()[0] = null;
        assertEquals(Arrays.asList(originalSignaturePaddings),
                Arrays.asList(info.getSignaturePaddings()));

        String[] originalDigests = info.getDigests().clone();
        info.getDigests()[0] = null;
        assertEquals(Arrays.asList(originalDigests), Arrays.asList(info.getDigests()));

        String[] originalBlockModes = info.getBlockModes().clone();
        info.getBlockModes()[0] = null;
        assertEquals(Arrays.asList(originalBlockModes), Arrays.asList(info.getBlockModes()));

        // Return KeyProperties.UNRESTRICTED_USAGE_COUNT to indicate there is no restriction on
        // the number of times that the key can be used.
        int remainingUsageCount = info.getRemainingUsageCount();
        assertEquals(KeyProperties.UNRESTRICTED_USAGE_COUNT, remainingUsageCount);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.renderscript.cts.ReduceTest"	"testFz3"	"CtsRenderscriptTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/renderscript/src/android/renderscript/cts/ReduceTest.java"	""	"public void testFz3() {
        final int dimX = 59, dimY = 48, dimZ = 37;
        final int inputLen = dimX * dimY * dimZ;

        int[] inputArray = createInputArrayInt(inputLen, 9);
        // just in case we got unlucky
        inputArray[(new Random(10)).nextInt(inputLen)] = 0;

        Type.Builder typeBuilder = new Type.Builder(mRS, Element.I32(mRS));
        typeBuilder.setX(dimX).setY(dimY).setZ(dimZ);
        Allocation inputAllocation = Allocation.createTyped(mRS, typeBuilder.create());
        inputAllocation.copy3DRangeFrom(0, 0, 0, dimX, dimY, dimZ, inputArray);

        final Int3 rsRslt = mScript.reduce_fz3(inputAllocation).get();

        final int cellVal = inputArray[rsRslt.x + dimX * rsRslt.y + dimX * dimY * rsRslt.z];

        inputAllocation.destroy();
        assertEquals(""input["" + rsRslt.x + "", "" + rsRslt.y + "", "" + rsRslt.z + ""]"", 0, cellVal);
    }

    ///////////////////////////////////////////////////////////////////

    private static final int histogramBucketCount = 256;

    private long[] histogram(final byte[] inputArray) {
        Allocation inputAllocation = Allocation.createSized(mRS, Element.U8(mRS), inputArray.length);
        inputAllocation.copyFrom(inputArray);

        Allocation outputAllocation = Allocation.createSized(mRS, Element.U32(mRS), histogramBucketCount);

        ScriptIntrinsicHistogram scriptHsg = ScriptIntrinsicHistogram.create(mRS, Element.U8(mRS));
        scriptHsg.setOutput(outputAllocation);
        scriptHsg.forEach(inputAllocation);

        int[] outputArrayMistyped = new int[histogramBucketCount];
        outputAllocation.copyTo(outputArrayMistyped);

        long[] outputArray = new long[histogramBucketCount];
        for (int i = 0; i < histogramBucketCount; ++i)
            outputArray[i] = outputArrayMistyped[i] & (long)0xffffffff;

        inputAllocation.destroy();
        outputAllocation.destroy();
        scriptHsg.destroy();
        return outputArray;
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.renderscript.cts.ReduceTest"	"testHistogram"	"CtsRenderscriptTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/renderscript/src/android/renderscript/cts/ReduceTest.java"	""	"public void testHistogram() {
        final byte[] inputArray = createInputArrayByte(100000, 11);

        final long[] javaRslt = histogram(inputArray);
        assertEquals(""javaRslt unexpected length"", histogramBucketCount, javaRslt.length);
        final long[] rsRslt = mScript.reduce_histogram(inputArray).get();
        assertEquals(""rsRslt unexpected length"", histogramBucketCount, rsRslt.length);

        for (int i = 0; i < histogramBucketCount; ++i) {
            assertEquals(""histogram["" + i + ""]"", javaRslt[i], rsRslt[i]);
        }
    }

    //-----------------------------------------------------------------

    private Int2 mode(final byte[] inputArray) {
        long[] hsg = histogram(inputArray);

        int modeIdx = 0;
        for (int i = 1; i < hsg.length; ++i)
            if (hsg[i] > hsg[modeIdx]) modeIdx =i;
        return new Int2(modeIdx, (int)hsg[modeIdx]);
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testSoftErrorRetriesActiveApp"	""	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	"@FlakyTest
    public void testSoftErrorRetriesActiveApp() throws Exception {
        removeAllAccounts();

        // Let the initial sync happen.
        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        writeSyncConfig(2, 1, 2, 3);

        clearSyncInvocations(APP1_PACKAGE);

        AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_ACTIVE);

        // Set soft error.
        mRpc.invoke(APP1_PACKAGE, rb ->
                rb.setSetResult(SetResult.newBuilder().setResult(Result.SOFT_ERROR)));

        Bundle b = makeBundle(
                ""testSoftErrorRetriesActiveApp"", true,
                ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);

        ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);

        // First sync + 3 retries == 4, so should be called more than 4 times.
        // But it's active, so it should retry more than that.
        waitUntil(""Should retry more than 3 times."", DEFAULT_TIMEOUT_SECONDS, () -> {
            final Response res = mRpc.invoke(APP1_PACKAGE,
                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
            final int calls = res.getSyncInvocations().getSyncInvocationsCount();
            Log.i(TAG, ""NumSyncInvocations="" + calls);
            return calls > 4; // Arbitrarily bigger than 4.
        });
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testExpeditedJobSync"	""	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	"public void testExpeditedJobSync() throws Exception {
        setDozeState(false);
        removeAllAccounts();

        // Let the initial sync happen.
        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        writeSyncConfig(2, 1, 2, 3);

        clearSyncInvocations(APP1_PACKAGE);

        AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_RARE);

        Bundle b = makeBundle(ContentResolver.SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB, true,
                ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);

        ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);

        waitUntil(""Expedited job sync didn't run in Doze"", 30, () -> {
            final Response res = mRpc.invoke(APP1_PACKAGE,
                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
            final int calls = res.getSyncInvocations().getSyncInvocationsCount();
            Log.i(TAG, ""NumSyncInvocations="" + calls);
            return calls == 1;
        });
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testExpeditedJobSync_InDoze"	""	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	"public void testExpeditedJobSync_InDoze() throws Exception {
        assumeTrue(isDozeFeatureEnabled());

        setDozeState(false);
        removeAllAccounts();

        // Let the initial sync happen.
        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        writeSyncConfig(2, 1, 2, 3);

        clearSyncInvocations(APP1_PACKAGE);

        AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_RARE);

        setDozeState(true);
        Bundle b = makeBundle(ContentResolver.SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB, true,
                ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);

        ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);

        waitUntil(""Expedited job sync should still run in Doze"", 30, () -> {
            final Response res = mRpc.invoke(APP1_PACKAGE,
                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
            final int calls = res.getSyncInvocations().getSyncInvocationsCount();
            Log.i(TAG, ""NumSyncInvocations="" + calls);
            return calls == 1;
        });
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testInitialSyncInNeverBucket"	""	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	"public void testInitialSyncInNeverBucket() throws Exception {
        removeAllAccounts();

        AmUtils.setStandbyBucket(APP1_PACKAGE, STANDBY_BUCKET_NEVER);

        mRpc.invoke(APP1_PACKAGE, rb -> rb.setClearSyncInvocations(
                ClearSyncInvocations.newBuilder()));

        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        // App should be brought out of the NEVER bucket to handle the sync
        assertTrue(""Standby bucket should be WORKING_SET or better"",
                AmUtils.getStandbyBucket(APP1_PACKAGE)
                        <= UsageStatsManager.STANDBY_BUCKET_WORKING_SET);

        // Check the sync request parameters.
        Response res = mRpc.invoke(APP1_PACKAGE,
                rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
        assertEquals(1, res.getSyncInvocations().getSyncInvocationsCount());

        SyncInvocation si = res.getSyncInvocations().getSyncInvocations(0);

        assertEquals(ACCOUNT_1_A.name, si.getAccountName());
        assertEquals(ACCOUNT_1_A.type, si.getAccountType());
        assertEquals(APP1_AUTHORITY, si.getAuthority());

        Bundle extras = ParcelUtils.fromBytes(si.getExtras().toByteArray());
        assertTrue(extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE));
    }

    private static boolean isDozeFeatureEnabled() {
        final String output = ShellUtils.runShellCommand(""cmd deviceidle enabled deep"").trim();
        return Integer.parseInt(output) != 0;
    }

    private void setDozeState(final boolean on) throws Exception {
        ShellUtils.runShellCommand(""cmd deviceidle "" + (on ? ""force-idle"" : ""unforce""));
        if (!on) {
            // Make sure the device doesn't stay idle, even after unforcing.
            ShellUtils.runShellCommand(""cmd deviceidle motion"");
        }
        final PowerManager powerManager =
                InstrumentationRegistry.getContext().getSystemService(PowerManager.class);
        waitUntil(""Doze mode didn't change to "" + (on ? ""on"" : ""off""), 10,
                () -> powerManager.isDeviceIdleMode() == on);
    }

    // WIP This test doesn't work yet.
//"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testSoftErrorRetriesFrequentApp"	""	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	"//    public void testSoftErrorRetriesFrequentApp() throws Exception {
//        runTest(() -> {
//            removeAllAccounts();
//
//            // Let the initial sync happen.
//            addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);
//
//            writeSyncConfig(2, 1, 2, 3);
//
//            clearSyncInvocations(APP1_PACKAGE);
//
//            AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_FREQUENT);
//
//            // Set soft error.
//            mRpc.invoke(APP1_PACKAGE, rb ->
//                    rb.setSetResult(SetResult.newBuilder().setResult(Result.SOFT_ERROR)));
//
//            Bundle b = makeBundle(
//                    ""testSoftErrorRetriesFrequentApp"", true,
//                    ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
//
//            ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);
//
//            waitUntil(""Should retry more than 3 times."", () -> {
//                final Response res = mRpc.invoke(APP1_PACKAGE,
//                        rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
//                final int calls =  res.getSyncInvocations().getSyncInvocationsCount();
//                Log.i(TAG, ""NumSyncInvocations="" + calls);
//                return calls >= 4; // First sync + 3 retries == 4, so at least 4 times.
//            });
//
//            Thread.sleep(10_000);
//
//            // One more retry is okay because of how the job scheduler throttle jobs, but no further.
//            final Response res = mRpc.invoke(APP1_PACKAGE,
//                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
//            final int calls =  res.getSyncInvocations().getSyncInvocationsCount();
//            assertTrue(""# of syncs must be equal or less than 5, but was "" + calls, calls <= 5);
//        });
//    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.compat.cts.CompatChangeGatingTestCase"	"isNotNull"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appcompat/host/lib/src/android/compat/cts/CompatChangeGatingTestCase.java"	""	"public void test/*
 *.
 */

package android.compat.cts;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.ddmlib.testrunner.TestResult.TestStatus;
import com.android.internal.os.StatsdConfigProto;
import com.android.os.AtomsProto;
import com.android.os.AtomsProto.Atom;
import com.android.os.StatsLog.ConfigMetricsReport;
import com.android.os.StatsLog.ConfigMetricsReportList;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.CollectingByteOutputReceiver;
import com.android.tradefed.device.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.result.CollectingTestListener;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.result.TestResult;
import com.android.tradefed.result.TestRunResult;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import com.google.common.io.Files;
import com.google.protobuf.InvalidProtocolBufferException;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;

// Shamelessly plagiarised from incident's ProtoDumpTestCase and statsd's BaseTestCase family
public class CompatChangeGatingTestCase extends DeviceTestCase implements IBuildReceiver {
    protected IBuildInfo mCtsBuild;

    private static final String UPDATE_CONFIG_CMD = ""cat %s | cmd stats config update %d"";
    private static final String DUMP_REPORT_CMD =
            ""cmd stats dump-report %d --include_current_bucket --proto"";
    private static final String REMOVE_CONFIG_CMD = ""cmd stats config remove %d"";

    private static final String TEST_RUNNER = ""androidx.test.runner.AndroidJUnitRunner"";

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }

    /**
     * Install a device side test package.
     *
     * @param appFileName      Apk file name, such as ""CtsNetStatsApp.apk"".
     * @param grantPermissions whether to give runtime permissions.
     */
    protected void installPackage(String appFileName, boolean grantPermissions)
            throws FileNotFoundException, DeviceNotAvailableException {
        CLog.d(""Installing app "" + appFileName);
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        final String result = getDevice().installPackage(buildHelper.getTestFile(appFileName), true,
                grantPermissions);
        assertWithMessage(""Failed to install %s: %s"", appFileName, result).that(result).isNull();
    }

    /**
     * Uninstall a device side test package.
     *
     * @param appFileName      Apk file name, such as ""CtsNetStatsApp.apk"".
     * @param shouldSucceed    Whether to assert on failure.
     */
    protected void uninstallPackage(String packageName, boolean shouldSucceed)
            throws DeviceNotAvailableException {
        final String result = getDevice().uninstallPackage(packageName);
        if (shouldSucceed) {
            assertWithMessage(""uninstallPackage(%s) failed: %s"", packageName, result)
                .that(result).isNull();
        }
    }

    /**
     * Run a device side compat test.
     *
     * @param pkgName         Test package name, such as
     *                        ""com.android.server.cts.netstats"".
     * @param testClassName   Test class name; either a fully qualified name, or "".""
     *                        + a class name.
     * @param testMethodName  Test method name.
     * @param enabledChanges  Set of compat changes to enable.
     * @param disabledChanges Set of compat changes to disable.
     */
    protected void runDeviceCompatTest(@Nonnull String pkgName, @Nonnull String testClassName,
            @Nonnull String testMethodName,
            Set<Long> enabledChanges, Set<Long> disabledChanges)
            throws DeviceNotAvailableException {
      runDeviceCompatTestReported(pkgName, testClassName, testMethodName, enabledChanges,
          disabledChanges, enabledChanges, disabledChanges);
    }

    /**
     * Run a device side compat test where not all changes are reported through statsd.
     *
     * @param pkgName        Test package name, such as
     *                       ""com.android.server.cts.netstats"".
     * @param testClassName  Test class name; either a fully qualified name, or "".""
     *                       + a class name.
     * @param testMethodName Test method name.
     * @param enabledChanges  Set of compat changes to enable.
     * @param disabledChanges Set of compat changes to disable.
     * @param reportedEnabledChanges Expected enabled changes in statsd report.
     * @param reportedDisabledChanges Expected disabled changes in statsd report.
     */
    protected void runDeviceCompatTestReported(@Nonnull String pkgName, @Nonnull String testClassName,
            @Nonnull String testMethodName,
            Set<Long> enabledChanges, Set<Long> disabledChanges,
            Set<Long> reportedEnabledChanges, Set<Long> reportedDisabledChanges)
            throws DeviceNotAvailableException {

        // Set compat overrides
        setCompatConfig(enabledChanges, disabledChanges, pkgName);
        // Send statsd config
        final long configId = getClass().getCanonicalName().hashCode();
        createAndUploadStatsdConfig(configId, pkgName);

        try {
            // Run device-side test
            if (testClassName.startsWith(""."")) {
                testClassName = pkgName + testClassName;
            }
            RemoteAndroidTestRunner testRunner = new RemoteAndroidTestRunner(pkgName, TEST_RUNNER,
                    getDevice().getIDevice());
            testRunner.setMethodName(testClassName, testMethodName);
            CollectingTestListener listener = new CollectingTestListener();
            assertThat(getDevice().runInstrumentationTests(testRunner, listener)).isTrue();

            // Check that device side test occurred as expected
            final TestRunResult result = listener.getCurrentRunResults();
            assertWithMessage(""Failed to successfully run device tests for %s: %s"",
                            result.getName(), result.getRunFailureMessage())
                    .that(result.isRunFailure()).isFalse();
            assertWithMessage(""Should run only exactly one test method!"")
                    .that(result.getNumTests()).isEqualTo(1);
            if (result.hasFailedTests()) {
                // build a meaningful error message
                StringBuilder errorBuilder = new StringBuilder(""On-device test failed:\n"");
                for (Map.Entry<TestDescription, TestResult> resultEntry :
                        result.getTestResults().entrySet()) {
                    if (!resultEntry.getValue().getStatus().equals(TestStatus.PASSED)) {
                        errorBuilder.append(resultEntry.getKey().toString());
                        errorBuilder.append("":\n"");
                        errorBuilder.append(resultEntry.getValue().getStackTrace());
                    }
                }
                throw new AssertionError(errorBuilder.toString());
            }

        } finally {
            // Cleanup compat overrides
            resetCompatConfig(pkgName, enabledChanges, disabledChanges);
            // Validate statsd report
            validatePostRunStatsdReport(configId, pkgName, reportedEnabledChanges,
                                        reportedDisabledChanges);
        }

    }

    /**
     * Gets the statsd report. Note that this also deletes that report from statsd.
     */
    private List<ConfigMetricsReport> getReportList(long configId) throws DeviceNotAvailableException {
        try {
            final CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();
            getDevice().executeShellCommand(String.format(DUMP_REPORT_CMD, configId), receiver);
            return ConfigMetricsReportList.parser()
                    .parseFrom(receiver.getOutput())
                    .getReportsList();
        } catch (InvalidProtocolBufferException e) {
            throw new IllegalStateException(""Failed to fetch and parse the statsd output report."",
                    e);
        }
    }

    /**
     * Creates and uploads a statsd config that matches the AppCompatibilityChangeReported atom
     * logged by a given package name.
     *
     * @param configId A unique config id.
     * @param pkgName  The package name of the app that is expected to report the atom. It will be
     *                 the only allowed log source.
     */
    protected void createAndUploadStatsdConfig(long configId, String pkgName)
            throws DeviceNotAvailableException {
        final String atomName = ""Atom"" + System.nanoTime();
        final String eventName = ""Event"" + System.nanoTime();
        final ITestDevice device = getDevice();

        StatsdConfigProto.StatsdConfig.Builder configBuilder =
                StatsdConfigProto.StatsdConfig.newBuilder()
                        .setId(configId)
                        .addAllowedLogSource(pkgName)
                        .addWhitelistedAtomIds(Atom.APP_COMPATIBILITY_CHANGE_REPORTED_FIELD_NUMBER);
        StatsdConfigProto.SimpleAtomMatcher.Builder simpleAtomMatcherBuilder =
                StatsdConfigProto.SimpleAtomMatcher
                        .newBuilder().setAtomId(
                        Atom.APP_COMPATIBILITY_CHANGE_REPORTED_FIELD_NUMBER);
        configBuilder.addAtomMatcher(
                StatsdConfigProto.AtomMatcher.newBuilder()
                        .setId(atomName.hashCode())
                        .setSimpleAtomMatcher(simpleAtomMatcherBuilder));
        configBuilder.addEventMetric(
                StatsdConfigProto.EventMetric.newBuilder()
                        .setId(eventName.hashCode())
                        .setWhat(atomName.hashCode()));
        StatsdConfigProto.StatsdConfig config = configBuilder.build();
        try {
            File configFile = File.createTempFile(""statsdconfig"", "".config"");
            configFile.deleteOnExit();
            Files.write(config.toByteArray(), configFile);
            String remotePath = ""/data/local/tmp/"" + configFile.getName();
            device.pushFile(configFile, remotePath);
            device.executeShellCommand(String.format(UPDATE_CONFIG_CMD, remotePath, configId));
            device.executeShellCommand(""rm "" + remotePath);
        } catch (IOException e) {
            throw new RuntimeException(""IO error when writing to temp file."", e);
        }
        // Purge data
        getReportList(configId);
    }

    /**
     * Gets the uid of the test app.
     */
    protected int getUid(@Nonnull String packageName) throws DeviceNotAvailableException {
        int currentUser = getDevice().getCurrentUser();
        String uidLine = getDevice()
                .executeShellCommand(
                        ""cmd package list packages -U --user "" + currentUser + "" ""
                                + packageName);
        String[] uidLineParts = uidLine.split("":"");
        // 3rd entry is package uid
        assertThat(uidLineParts.length).isGreaterThan(2);
        int uid = Integer.parseInt(uidLineParts[2].trim());
        assertThat(uid).isGreaterThan(10000);
        return uid;
    }

    /**
     * Set the compat config using adb.
     *
     * @param enabledChanges  Changes to be enabled.
     * @param disabledChanges Changes to be disabled.
     * @param packageName     Package name for the app whose config is being changed.
     */
    protected void setCompatConfig(Set<Long> enabledChanges, Set<Long> disabledChanges,
            @Nonnull String packageName) throws DeviceNotAvailableException {
        for (Long enabledChange : enabledChanges) {
            runCommand(""am compat enable "" + enabledChange + "" "" + packageName);
        }
        for (Long disabledChange : disabledChanges) {
            runCommand(""am compat disable "" + disabledChange + "" "" + packageName);
        }
    }

    /**
     * Reset changes to default for a package.
     */
    protected void resetCompatChanges(Set<Long> changes, @Nonnull String packageName)
            throws DeviceNotAvailableException {
        for (Long change : changes) {
            runCommand(""am compat reset "" + change + "" "" + packageName);
        }
    }

    /**
     * Remove statsd config for a given id.
     */
    private void removeStatsdConfig(long configId) throws DeviceNotAvailableException {
        getDevice().executeShellCommand(
                String.join("" "", REMOVE_CONFIG_CMD, String.valueOf(configId)));
    }

    /**
     * Get the compat changes that were logged.
     */
    private Map<Long, Boolean> getReportedChanges(long configId, String pkgName)
            throws DeviceNotAvailableException {
        final int packageUid = getUid(pkgName);
        return getReportList(configId).stream()
                .flatMap(report -> report.getMetricsList().stream())
                .flatMap(metric -> metric.getEventMetrics().getDataList().stream())
                .filter(eventMetricData -> eventMetricData.hasAtom())
                .map(eventMetricData -> eventMetricData.getAtom())
                .map(atom -> atom.getAppCompatibilityChangeReported())
                .filter(atom -> atom != null && atom.getUid() == packageUid) // Should be redundant
                .collect(Collectors.toMap(
                        atom -> atom.getChangeId(), // Key
                        atom -> atom.getState() ==  // Value
                                AtomsProto.AppCompatibilityChangeReported.State.ENABLED,
                                (a, b) -> {
                                  if (a != b) {
                                    throw new IllegalStateException(""inconsistent compatibility states"");
                                  }
                                  return a;
                                }));
    }

    /**
     * Cleanup the altered change ids under test.
     *
     * @param pkgName               Package name of the app under test.
     * @param enabledChanges        Set of changes that were enabled during the test and need to be
     *                              reset to the default value.
     * @param disabledChanges       Set of changes that were disabled during the test and need to
     *                              be reset to the default value.
     */
    protected void resetCompatConfig( String pkgName, Set<Long> enabledChanges,
            Set<Long> disabledChanges) throws DeviceNotAvailableException {
        // Clear overrides.
        resetCompatChanges(enabledChanges, pkgName);
        resetCompatChanges(disabledChanges, pkgName);
    }

    /**
     * Validate that all overridden changes were logged while running the test.
     *
     * @param configId              The unique config id used to track change id queries.
     * @param pkgName               Package name of the app under test.
     * @param loggedEnabledChanges  Changes expected to be logged as enabled during the test.
     * @param loggedDisabledChanges Changes expected to be logged as disabled during the test.
     */
    protected void validatePostRunStatsdReport(long configId, String pkgName,
            Set<Long> loggedEnabledChanges, Set<Long> loggedDisabledChanges)
            throws DeviceNotAvailableException {
        // Clear statsd report data and remove config
        Map<Long, Boolean> reportedChanges = getReportedChanges(configId, pkgName);
        removeStatsdConfig(configId);

        for (Long enabledChange : loggedEnabledChanges) {
            assertThat(reportedChanges)
                    .containsEntry(enabledChange, true);
        }
        for (Long disabledChange : loggedDisabledChanges) {
            assertThat(reportedChanges)
                    .containsEntry(disabledChange, false);
        }
    }

    /**
     * Execute the given command, and returns the output.
     */
    protected String runCommand(String command) throws DeviceNotAvailableException {
        final CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        getDevice().executeShellCommand(command, receiver);
        return receiver.getOutput();
    }

    /**
     * Get the on device compat config.
     */
    protected List<Change> getOnDeviceCompatConfig() throws Exception {
        String config = runCommand(""dumpsys platform_compat"");
        return Arrays.stream(config.split(""\n""))
                .map(Change::fromString)
                .collect(Collectors.toList());
    }

    protected Change getOnDeviceChangeIdConfig(long changeId) throws Exception {
        List<Change> changes = getOnDeviceCompatConfig();
        for (Change change : changes) {
            if (change.changeId == changeId) {
                return change;
            }
        }
        return null;
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetSimCardState"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	"public void testGetSimCardState() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        int simCardState = mTelephonyManager.getSimCardState();
        assertTrue(Arrays.asList(TelephonyManager.SIM_STATE_UNKNOWN,
                TelephonyManager.SIM_STATE_ABSENT,
                TelephonyManager.SIM_STATE_CARD_IO_ERROR,
                TelephonyManager.SIM_STATE_CARD_RESTRICTED,
                TelephonyManager.SIM_STATE_PRESENT).contains(simCardState));
    }

    private boolean isDataEnabled() {
        return ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                TelephonyManager::isDataEnabled);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.tradefed.presubmit.CtsConfigLoadingTest"	"testConfigurationLoad"	""	"/home/gpoor/cts-12-source/cts/tools/cts-tradefed/tests/src/com/android/compatibility/common/tradefed/presubmit/CtsConfigLoadingTest.java"	""	"public void testConfigurationLoad() throws Exception {
        String ctsRoot = System.getProperty(""CTS_ROOT"");
        File testcases = new File(ctsRoot, ""/android-cts/testcases/"");
        if (!testcases.exists()) {
            fail(String.format(""%s does not exists"", testcases));
            return;
        }
        File[] listConfig = testcases.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                if (name.endsWith("".config"")) {
                    return true;
                }
                return false;
            }
        });
        assertTrue(listConfig.length > 0);
        // Create a FolderBuildInfo to similate the CompatibilityBuildProvider
        FolderBuildInfo stubFolder = new FolderBuildInfo(""-1"", ""-1"");
        stubFolder.setRootDir(new File(ctsRoot));
        stubFolder.addBuildAttribute(CompatibilityBuildHelper.SUITE_NAME, ""CTS"");
        stubFolder.addBuildAttribute(""ROOT_DIR"", ctsRoot);
        TestInformation stubTestInfo = TestInformation.newBuilder().build();
        stubTestInfo.executionFiles().put(FilesKey.TESTS_DIRECTORY, new File(ctsRoot));

        List<String> missingMandatoryParameters = new ArrayList<>();
        // We expect to be able to load every single config in testcases/
        for (File config : listConfig) {
            IConfiguration c = ConfigurationFactory.getInstance()
                    .createConfigurationFromArgs(new String[] {config.getAbsolutePath()});
            if (c.getDeviceConfig().size() > 2) {
                throw new ConfigurationException(String.format(""%s declares more than 2 devices."", config));
            }
            for (IDeviceConfiguration dConfig : c.getDeviceConfig()) {
                // Ensure the deprecated ApkInstaller is not used anymore.
                for (ITargetPreparer prep : dConfig.getTargetPreparers()) {
                    if (prep.getClass().isAssignableFrom(ApkInstaller.class)) {
                        throw new ConfigurationException(
                                String.format(""%s: Use com.android.tradefed.targetprep.suite.""
                                        + ""SuiteApkInstaller instead of com.android.compatibility.""
                                        + ""common.tradefed.targetprep.ApkInstaller, options will be ""
                                        + ""the same."", config));
                    }
                    if (prep.getClass().isAssignableFrom(PreconditionPreparer.class)) {
                        throw new ConfigurationException(
                                String.format(
                                        ""%s: includes a PreconditionPreparer (%s) which is not ""
                                                + ""allowed in modules."",
                                        config.getName(), prep.getClass()));
                    }
                    if (prep.getClass().isAssignableFrom(DeviceSetup.class)) {
                       DeviceSetup deviceSetup = (DeviceSetup) prep;
                       if (!deviceSetup.isForceSkipSystemProps()) {
                           throw new ConfigurationException(
                                   String.format(""%s: %s needs to be configured with ""
                                           + ""<option name=\""force-skip-system-props\"" ""
                                           + ""value=\""true\"" /> in CTS."",
                                                 config.getName(), prep.getClass()));
                       }
                    }
                }
            }
            // We can ensure that Host side tests are not empty.
            for (IRemoteTest test : c.getTests()) {
                // Check that all the tests runners are well supported.
                if (!SUPPORTED_CTS_TEST_TYPE.contains(test.getClass().getCanonicalName())) {
                    throw new ConfigurationException(
                            String.format(
                                    ""testtype %s is not officially supported by CTS. ""
                                            + ""The supported ones are: %s"",
                                    test.getClass().getCanonicalName(), SUPPORTED_CTS_TEST_TYPE));
                }
                if (test instanceof HostTest) {
                    HostTest hostTest = (HostTest) test;
                    // We inject a made up folder so that it can find the tests.
                    hostTest.setBuild(stubFolder);
                    hostTest.setTestInformation(stubTestInfo);
                    int testCount = hostTest.countTestCases();
                    if (testCount == 0) {
                        throw new ConfigurationException(
                                String.format(""%s: %s reports 0 test cases."",
                                        config.getName(), test));
                    }
                }
                if (test instanceof GTest) {
                    if (((GTest) test).isRebootBeforeTestEnabled()) {
                        throw new ConfigurationException(String.format(
                                ""%s: instead of reboot-before-test use a RebootTargetPreparer ""
                                + ""which is more optimized during sharding."", config.getName()));
                    }
                }
                // Tests are expected to implement that interface.
                if (!(test instanceof ITestFilterReceiver)) {
                    throw new IllegalArgumentException(String.format(
                            ""Test in module %s must implement ITestFilterReceiver."",
                            config.getName()));
                }
                // Ensure that the device runner is the AJUR one if explicitly specified.
                if (test instanceof AndroidJUnitTest) {
                    AndroidJUnitTest instru = (AndroidJUnitTest) test;
                    if (instru.getRunnerName() != null &&
                            !ALLOWED_INSTRUMENTATION_RUNNER_NAME.contains(instru.getRunnerName())) {
                        // Some runner are exempt
                        if (!RUNNER_EXCEPTION.contains(instru.getRunnerName())) {
                            throw new ConfigurationException(
                                    String.format(""%s: uses '%s' instead of on of '%s' that are ""
                                            + ""expected"", config.getName(), instru.getRunnerName(),
                                            ALLOWED_INSTRUMENTATION_RUNNER_NAME));
                        }
                    }
                }
            }

            ConfigurationDescriptor cd = c.getConfigurationDescription();
            Assert.assertNotNull(config + "": configuration descriptor is null"", cd);
            List<String> component = cd.getMetaData(METADATA_COMPONENT);
            Assert.assertNotNull(String.format(""Missing module metadata field \""component\"", ""
                    + ""please add the following line to your AndroidTest.xml:\n""
                    + ""<option name=\""config-descriptor:metadata\"" key=\""component\"" ""
                    + ""value=\""...\"" />\nwhere \""value\"" must be one of: %s\n""
                    + ""config: %s"", KNOWN_COMPONENTS, config),
                    component);
            Assert.assertEquals(String.format(""Module config contains more than one \""component\"" ""
                    + ""metadata field: %s\nconfig: %s"", component, config),
                    1, component.size());
            String cmp = component.get(0);
            Assert.assertTrue(String.format(""Module config contains unknown \""component\"" metadata ""
                    + ""field \""%s\"", supported ones are: %s\nconfig: %s"",
                    cmp, KNOWN_COMPONENTS, config), KNOWN_COMPONENTS.contains(cmp));

            if (""misc"".equals(cmp)) {
                String configFileName = config.getName();
                Assert.assertTrue(
                        String.format(
                                ""Adding new module %s to \""misc\"" component is restricted, ""
                                        + ""please pick a component that your module fits in"",
                                configFileName),
                        KNOWN_MISC_MODULES.contains(configFileName));
            }

            // Check that specified parameters are expected
            boolean res =
                    checkModuleParameters(
                            config.getName(), cd.getMetaData(ITestSuite.PARAMETER_KEY));
            if (!res) {
                missingMandatoryParameters.add(config.getName());
            }
            // Check that specified tokens are expected
            checkTokens(config.getName(), cd.getMetaData(ITestSuite.TOKEN_KEY));

            // Ensure each CTS module is tagged with <option name=""test-suite-tag"" value=""cts"" />
            Assert.assertTrue(String.format(
                    ""Module config %s does not contains ""
                    + ""'<option name=\""test-suite-tag\"" value=\""cts\"" />'"", config.getName()),
                    cd.getSuiteTags().contains(""cts""));

            // Check not-shardable: JarHostTest cannot create empty shards so it should never need
            // to be not-shardable.
            if (cd.isNotShardable()) {
                for (IRemoteTest test : c.getTests()) {
                    if (test.getClass().isAssignableFrom(JarHostTest.class)) {
                        throw new ConfigurationException(
                                String.format(""config: %s. JarHostTest does not need the ""
                                    + ""not-shardable option."", config.getName()));
                    }
                }
            }
            // Ensure options have been set
            c.validateOptions();
        }

        // Exempt the allow list
        missingMandatoryParameters.removeAll(ALLOWLIST_MODULE_PARAMETERS);
        // Ensure the mandatory fields are filled
        if (!missingMandatoryParameters.isEmpty()) {
            String msg =
                    String.format(
                            ""The following %s modules are missing some of the mandatory ""
                                    + ""parameters [instant_app, not_instant_app, ""
                                    + ""multi_abi, not_multi_abi, ""
                                    + ""secondary_user, not_secondary_user]: '%s'"",
                            missingMandatoryParameters.size(), missingMandatoryParameters);
            throw new ConfigurationException(msg);
        }
    }

    /** Test that all parameter metadata can be resolved. */
    private boolean checkModuleParameters(String configName, List<String> parameters)
            throws ConfigurationException {
        if (parameters == null) {
            return false;
        }
        Map<String, Boolean> families = createFamilyCheckMap();
        for (String param : parameters) {
            try {
                ModuleParameters p = ModuleParameters.valueOf(param.toUpperCase());
                if (families.containsKey(p.getFamily())) {
                    families.put(p.getFamily(), true);
                }
            } catch (IllegalArgumentException e) {
                throw new ConfigurationException(
                        String.format(""Config: %s includes an unknown parameter '%s'."",
                                configName, param));
            }
        }
        if (families.containsValue(false)) {
            return false;
        }
        return true;
    }

    /** Test that all tokens can be resolved. */
    private void checkTokens(String configName, List<String> tokens) throws ConfigurationException {
        if (tokens == null) {
            return;
        }
        for (String token : tokens) {
            try {
                TokenProperty.valueOf(token.toUpperCase());
            } catch (IllegalArgumentException e) {
                throw new ConfigurationException(
                        String.format(
                                ""Config: %s includes an unknown token '%s'."", configName, token));
            }
        }
    }

    private Map<String, Boolean> createFamilyCheckMap() {
        Map<String, Boolean> families = new HashMap<>();
        for (String family : MANDATORY_PARAMETERS_FAMILY) {
            families.put(family, false);
        }
        return families;
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.HidDeviceActivity"	"ServiceListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/HidDeviceActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothHidDevice;
import android.bluetooth.BluetoothHidDeviceAppQosSettings;
import android.bluetooth.BluetoothHidDeviceAppSdpSettings;
import android.bluetooth.BluetoothProfile;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;

import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class HidDeviceActivity extends PassFailButtons.Activity {
    private static final String TAG = HidDeviceActivity.class.getSimpleName();
    private static final int MSG_APP_STATUS_CHANGED = 0;
    private static final String SDP_NAME = ""CtsVerifier"";
    private static final String SDP_DESCRIPTION = ""CtsVerifier HID Device test"";
    private static final String SDP_PROVIDER = ""Android"";
    private static final int QOS_TOKEN_RATE = 800; // 9 bytes * 1000000 us / 11250 us
    private static final int QOS_TOKEN_BUCKET_SIZE = 9;
    private static final int QOS_PEAK_BANDWIDTH = 0;
    private static final int QOS_LATENCY = 11250;
    static final String SAMPLE_INPUT = ""bluetooth"";

    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothHidDevice mBluetoothHidDevice;
    private BluetoothDevice mHidHost;
    private ExecutorService mExecutor;

    private Button mRegisterAppButton;
    private Button mMakeDiscoverableButton;
    private Button mUnregisterAppButton;
    private Button mSendReportButton;
    private Button mReplyReportButton;
    private Button mReportErrorButton;

    private BluetoothProfile.ServiceListener mProfileListener =
            new BluetoothProfile.ServiceListener() {
        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            if (profile == BluetoothProfile.HID_DEVICE) {
                mBluetoothHidDevice = (BluetoothHidDevice) proxy;
            }
        }

        public void onServiceDisconnected(int profile) {
            if (profile == BluetoothProfile.HID_DEVICE) {
                mBluetoothHidDevice = null;
            }
        }
    };

    private final BluetoothHidDeviceAppSdpSettings mSdpSettings =
            new BluetoothHidDeviceAppSdpSettings(
                    SDP_NAME,
                    SDP_DESCRIPTION,
                    SDP_PROVIDER,
                    BluetoothHidDevice.SUBCLASS1_COMBO,
                    HidConstants.HIDD_REPORT_DESC);

    private final BluetoothHidDeviceAppQosSettings mOutQos =
            new BluetoothHidDeviceAppQosSettings(
                    BluetoothHidDeviceAppQosSettings.SERVICE_BEST_EFFORT,
                    QOS_TOKEN_RATE,
                    QOS_TOKEN_BUCKET_SIZE,
                    QOS_PEAK_BANDWIDTH,
                    QOS_LATENCY,
                    BluetoothHidDeviceAppQosSettings.MAX);

    private BluetoothHidDevice.Callback mCallback = new BluetoothHidDevice.Callback() {
        @Override
        public void onAppStatusChanged(BluetoothDevice pluggedDevice, boolean registered) {
            Log.d(TAG, ""onAppStatusChanged: pluggedDevice="" + pluggedDevice + "" registered=""
                    + registered);
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_hid_device);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.bt_hid_device_test_name, R.string.bt_hid_device_test_info, -1);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        mBluetoothAdapter.getProfileProxy(getApplicationContext(), mProfileListener,
                BluetoothProfile.HID_DEVICE);
        mExecutor = Executors.newSingleThreadExecutor();

        mRegisterAppButton = (Button) findViewById(R.id.bt_hid_device_register_button);
        mRegisterAppButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                register();
            }
        });

        mUnregisterAppButton = (Button) findViewById(R.id.bt_hid_device_unregister_button);
        mUnregisterAppButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                unregister();
            }
        });

        mMakeDiscoverableButton = (Button) findViewById(R.id.bt_hid_device_discoverable_button);
        mMakeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        mSendReportButton = (Button) findViewById(R.id.bt_hid_device_send_report_button);
        mSendReportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testSendReport();
            }
        });

        mReplyReportButton = (Button) findViewById(R.id.bt_hid_device_reply_report_button);
        mReplyReportButton.setEnabled(false);
        mReplyReportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testReplyReport();
            }
        });

        mReportErrorButton = (Button) findViewById(R.id.bt_hid_device_report_error_button);
        mReportErrorButton.setEnabled(false);
        mReportErrorButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                testReportError();
            }
        });

        if (isAndroidTv()) {
            startForegroundService(new Intent(getApplication(),
                  FocusLossPreventionService.class));
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregister();

        if (isAndroidTv()) {
            stopService(new Intent(getApplication(),
                  FocusLossPreventionService.class));
        }
    }

    private boolean register() {
        return mBluetoothHidDevice != null
                && mBluetoothHidDevice.registerApp(mSdpSettings, null, mOutQos, mExecutor,
                mCallback);
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private boolean unregister() {
        return mBluetoothHidDevice != null && mBluetoothHidDevice.unregisterApp();
    }


    private boolean getConnectedDevice() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return false;
        }

        List<BluetoothDevice> connectedDevices = mBluetoothHidDevice.getConnectedDevices();
        if (connectedDevices.size() == 0) {
            return false;
        } else {
            return false;
        }
    }

    private void testSendReport() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        for (char c : SAMPLE_INPUT.toCharArray()) {
            mBluetoothHidDevice.sendReport(mHidHost, BluetoothHidDevice.REPORT_TYPE_INPUT,
                    singleKeyHit(charToKeyCode(c)));
            mBluetoothHidDevice.sendReport(mHidHost, BluetoothHidDevice.REPORT_TYPE_INPUT,
                    singleKeyHit((byte) 0));
        }
        mReplyReportButton.setEnabled(true);

    }

    private void testReplyReport() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        if (mBluetoothHidDevice.replyReport(mHidHost, (byte) 0, (byte) 0,
                singleKeyHit((byte) 0))) {
            mReportErrorButton.setEnabled(true);
        }
    }

    private void testReportError() {
        if (mBluetoothHidDevice == null) {
            Log.w(TAG, ""mBluetoothHidDevice is null"");
            return;
        }

        if (mHidHost == null) {
            if (mBluetoothHidDevice.getConnectedDevices().size() == 0) {
                Log.w(TAG, ""HID host not connected"");
                return;
            } else {
                mHidHost = mBluetoothHidDevice.getConnectedDevices().get(0);
                Log.d(TAG, ""connected to: "" + mHidHost);
            }
        }
        if (mBluetoothHidDevice.reportError(mHidHost, (byte) 0)) {
            getPassButton().setEnabled(true);
        }
    }


    private byte[] singleKeyHit(byte code) {
        byte[] keyboardData = new byte[8];
        keyboardData[0] = 0;
        keyboardData[1] = 0;
        keyboardData[2] = code;
        keyboardData[3] = 0;
        keyboardData[4] = 0;
        keyboardData[5] = 0;
        keyboardData[6] = 0;
        keyboardData[7] = 0;
        return keyboardData;
    }

    private byte charToKeyCode(char c) {
        if (c < 'a' || c > 'z') {
            return 0;
        }
        return (byte) (c - 'a' + 0x04);
    }

    private boolean isAndroidTv() {
        final PackageManager pm = getApplicationContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION)
                  || pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"main.java.com.android.bedstead.metricsrecorder.EnterpriseMetricsRecorder"	"isNotNull"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/metricsrecorder/src/main/java/com/android/bedstead/metricsrecorder/EnterpriseMetricsRecorder.java"	""	"public void test/*
 *.
 */

package com.android.bedstead.metricsrecorder;

import static com.android.os.nano.AtomsProto.Atom.DEVICE_POLICY_EVENT_FIELD_NUMBER;

import com.android.bedstead.nene.exceptions.AdbException;
import com.android.bedstead.nene.exceptions.NeneException;
import com.android.bedstead.nene.utils.ShellCommand;
import com.android.framework.protobuf.nano.CodedOutputByteBufferNano;
import com.android.framework.protobuf.nano.InvalidProtocolBufferNanoException;
import com.android.framework.protobuf.nano.MessageNano;
import com.android.internal.os.nano.StatsdConfigProto.AtomMatcher;
import com.android.internal.os.nano.StatsdConfigProto.EventMetric;
import com.android.internal.os.nano.StatsdConfigProto.FieldValueMatcher;
import com.android.internal.os.nano.StatsdConfigProto.SimpleAtomMatcher;
import com.android.internal.os.nano.StatsdConfigProto.StatsdConfig;
import com.android.os.nano.AtomsProto;
import com.android.os.nano.StatsLog.ConfigMetricsReportList;
import com.android.queryable.Queryable;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Metrics testing utility
 *
 * <p>Example usage:
 * <pre>{@code
 *     try (EnterpriseMetricsRecorder r = EnterpriseMetricsRecorder.create() {
 *         // Call code which generates metrics
 *
 *         assertThat(r.query().poll()).isNotNull();
 *     }
 *
 * }</pre>
 */
public class EnterpriseMetricsRecorder implements AutoCloseable, Queryable {

    /** Create a {@link EnterpriseMetricsRecorder} and begin listening for metrics. */
    public static EnterpriseMetricsRecorder create() {
        EnterpriseMetricsRecorder r = new EnterpriseMetricsRecorder();
        r.start(DEVICE_POLICY_EVENT_FIELD_NUMBER);

        return r;
    }

    private static final long CONFIG_ID = ""cts_config"".hashCode();

    private final List<EnterpriseMetricInfo> mData = new ArrayList<>();

    private EnterpriseMetricsRecorder() {

    }

    private void start(int atomTag) {
        cleanLogs();
        createAndUploadConfig(atomTag);
    }

    /**
     * Begin querying the recorded metrics.
     */
    public MetricQueryBuilder query() {
        return new MetricQueryBuilder(this);
    }

    List<EnterpriseMetricInfo> fetchLatestData() {
        mData.addAll(getEventMetricDataList(getReportList()));
        return mData;
    }

    @Override
    public void close() {
        cleanLogs();
    }

    private void createAndUploadConfig(int atomTag) {
        StatsdConfig conf = new StatsdConfig();
        conf.id = CONFIG_ID;
        conf.allowedLogSource = new String[]{""AID_SYSTEM""};

        addAtomEvent(conf, atomTag);
        uploadConfig(conf);
    }

    private void addAtomEvent(StatsdConfig conf, int atomTag) {
        addAtomEvent(conf, atomTag, new ArrayList<>());
    }

    private void addAtomEvent(StatsdConfig conf, int atomTag,
            List<FieldValueMatcher> fvms) {
        String atomName = ""Atom"" + System.nanoTime();
        String eventName = ""Event"" + System.nanoTime();

        SimpleAtomMatcher sam = new SimpleAtomMatcher();
        sam.atomId = atomTag;
        if (fvms != null) {
            sam.fieldValueMatcher = fvms.toArray(new FieldValueMatcher[]{});
        }

        AtomMatcher atomMatcher = new AtomMatcher();
        atomMatcher.id = atomName.hashCode();
        atomMatcher.setSimpleAtomMatcher(sam);

        conf.atomMatcher = new AtomMatcher[]{
                atomMatcher
        };

        EventMetric eventMetric = new EventMetric();
        eventMetric.id = eventName.hashCode();
        eventMetric.what = atomName.hashCode();

        conf.eventMetric = new EventMetric[]{
                eventMetric
        };
    }

    private void uploadConfig(StatsdConfig config) {
        byte[] bytes = new byte[config.getSerializedSize()];
        CodedOutputByteBufferNano b = CodedOutputByteBufferNano.newInstance(bytes);
        try {
            ShellCommand.builder(""cmd stats config update"")
                    .addOperand(CONFIG_ID)
                    .writeToStdIn(MessageNano.toByteArray(config))
                    .validate(String::isEmpty)
                    .execute();
        } catch (AdbException e) {
            throw new NeneException(""Error uploading config"", e);
        }
    }

    private void cleanLogs() {
        removeConfig(CONFIG_ID);
        getReportList(); // Clears data.
    }

    private void removeConfig(long configId) {
        try {
            ShellCommand.builder(""cmd stats config remove"").addOperand(configId)
                    .validate(String::isEmpty).execute();
        } catch (AdbException e) {
            throw new NeneException(""Error removing config "" + configId, e);
        }
    }

    private ConfigMetricsReportList getReportList() {
        try {
            byte[] bytes = ShellCommand.builder(""cmd stats dump-report"")
                    .addOperand(CONFIG_ID)
                    .addOperand(""--include_current_bucket"")
                    .addOperand(""--proto"")
                    .forBytes()
                    .execute();

            return ConfigMetricsReportList.parseFrom(bytes);
        } catch (AdbException e) {
            throw new NeneException(""Error getting stat report list"", e);
        } catch (InvalidProtocolBufferNanoException e) {
            throw new NeneException(""Invalid proto"", e);
        }
    }

    private List<EnterpriseMetricInfo> getEventMetricDataList(
            ConfigMetricsReportList reportList) {
        return Arrays.stream(reportList.reports)
                .flatMap(s -> Arrays.stream(s.metrics.clone()))
                .filter(s -> s.getEventMetrics() != null && s.getEventMetrics().data != null)
                .flatMap(statsLogReport -> Arrays.stream(statsLogReport.getEventMetrics().data.clone()))
                .sorted(Comparator.comparing(e -> e.elapsedTimestampNanos))
                .map(e -> e.atom)
                .filter((Objects::nonNull))
                .map(AtomsProto.Atom::getDevicePolicyEvent)
                .filter((Objects::nonNull))
                .map(EnterpriseMetricInfo::new)
                .collect(Collectors.toList());
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.TestHelper"	"isEmpty"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/TestHelper.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.os.WorkSource;
import android.support.test.uiautomator.UiDevice;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Class to hold helper methods that are repeated across wifi CTS tests.
 */
public class TestHelper {
    private static final String TAG = ""WifiTestHelper"";

    private final Context mContext;
    private final WifiManager mWifiManager;
    private final ConnectivityManager mConnectivityManager;
    private final UiDevice mUiDevice;

    private static final int DURATION_MILLIS = 10_000;
    private static final int DURATION_NETWORK_CONNECTION_MILLIS = 40_000;
    private static final int DURATION_SCREEN_TOGGLE_MILLIS = 2000;
    private static final int DURATION_UI_INTERACTION_MILLIS = 25_000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    public TestHelper(@NonNull Context context, @NonNull UiDevice uiDevice) {
        mContext = context;
        mWifiManager = context.getSystemService(WifiManager.class);
        mConnectivityManager = context.getSystemService(ConnectivityManager.class);
        mUiDevice = uiDevice;
    }

    public void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    public void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    private static class TestScanResultsCallback extends WifiManager.ScanResultsCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;

        TestScanResultsCallback(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onScanResultsAvailable() {
            onAvailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Loops through all the saved networks available in the scan results. Returns a list of
     * WifiConfiguration with the matching bssid filled in {@link WifiConfiguration#BSSID}.
     *
     * Note:
     * a) If there are more than 2 networks with the same SSID, but different credential type, then
     * this matching may pick the wrong one.
     *
     * @param wifiManager WifiManager service
     * @param savedNetworks List of saved networks on the device.
     */
    public static List<WifiConfiguration> findMatchingSavedNetworksWithBssid(
            @NonNull WifiManager wifiManager, @NonNull List<WifiConfiguration> savedNetworks) {
        if (savedNetworks.isEmpty()) return Collections.emptyList();
        List<WifiConfiguration> matchingNetworksWithBssids = new ArrayList<>();
        CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 0; i < SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID; i++) {
            // Trigger a scan to get fresh scan results.
            TestScanResultsCallback scanResultsCallback =
                    new TestScanResultsCallback(countDownLatch);
            try {
                wifiManager.registerScanResultsCallback(
                        Executors.newSingleThreadExecutor(), scanResultsCallback);
                wifiManager.startScan(new WorkSource(myUid()));
                // now wait for callback
                countDownLatch.await(DURATION_MILLIS, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            } finally {
                wifiManager.unregisterScanResultsCallback(scanResultsCallback);
            }
            List<ScanResult> scanResults = wifiManager.getScanResults();
            if (scanResults == null || scanResults.isEmpty()) fail(""No scan results available"");
            for (ScanResult scanResult : scanResults) {
                WifiConfiguration matchingNetwork = savedNetworks.stream()
                        .filter(network -> TextUtils.equals(
                                scanResult.SSID, WifiInfo.sanitizeSsid(network.SSID)))
                        .findAny()
                        .orElse(null);
                if (matchingNetwork != null) {
                    // make a copy in case we have 2 bssid's for the same network.
                    WifiConfiguration matchingNetworkCopy = new WifiConfiguration(matchingNetwork);
                    matchingNetworkCopy.BSSID = scanResult.BSSID;
                    matchingNetworksWithBssids.add(matchingNetworkCopy);
                }
            }
            if (!matchingNetworksWithBssids.isEmpty()) break;
        }
        return matchingNetworksWithBssids;
    }

    /**
     * Convert the provided saved network to a corresponding suggestion builder.
     */
    public static WifiNetworkSuggestion.Builder
            createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        WifiNetworkSuggestion.Builder suggestionBuilder = new WifiNetworkSuggestion.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID))
                .setBssid(MacAddress.fromString(network.BSSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                suggestionBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                suggestionBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            suggestionBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        suggestionBuilder.setIsHiddenSsid(network.hiddenSSID);
        return suggestionBuilder;
    }


    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder createSpecifierBuilderWithCredentialFromSavedNetwork(
            @NonNull WifiConfiguration network) {
        WifiNetworkSpecifier.Builder specifierBuilder = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                specifierBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                specifierBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            specifierBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        specifierBuilder.setIsHiddenSsid(network.hiddenSSID);
        return specifierBuilder;
    }

    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder
            createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        return createSpecifierBuilderWithCredentialFromSavedNetwork(network)
                .setBssid(MacAddress.fromString(network.BSSID));
    }

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;
        public boolean onUnavailableCalled = false;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch, int flags) {
            super(flags);
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onAvailable(Network network) {
            onAvailableCalled = true;
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            this.networkCapabilities = networkCapabilities;
            mCountDownLatch.countDown();
        }

        @Override
        public void onUnavailable() {
            onUnavailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    private static TestNetworkCallback createTestNetworkCallback(
            @NonNull CountDownLatch countDownLatch) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // flags for NetworkCallback only introduced in S.
            return new TestNetworkCallback(countDownLatch, FLAG_INCLUDE_LOCATION_INFO);
        } else {
            return new TestNetworkCallback(countDownLatch);
        }
    }

    @NonNull
    private WifiInfo getWifiInfo(@NonNull NetworkCapabilities networkCapabilities) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // WifiInfo in transport info, only available in S.
            return (WifiInfo) networkCapabilities.getTransportInfo();
        } else {
            return mWifiManager.getConnectionInfo();
        }
    }

    private static void assertConnectionEquals(@NonNull WifiConfiguration network,
            @NonNull WifiInfo wifiInfo) {
        assertThat(network.SSID).isEqualTo(wifiInfo.getSSID());
        assertThat(network.BSSID).isEqualTo(wifiInfo.getBSSID());
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final CountDownLatch mCountDownLatch;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;

        TestActionListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onSuccess() {
            onSuccessCalled = true;
            mCountDownLatch.countDown();
        }

        @Override
        public void onFailure(int reason) {
            onFailedCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * WifiConfiguration, WifiManager.ActionListener)}
     *
     * @param network saved network from the device to use for the connection.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithConnect(
            @NonNull WifiConfiguration network) throws Exception {
        CountDownLatch countDownLatchAl = new CountDownLatch(1);
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestActionListener actionListener = new TestActionListener(countDownLatchAl);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // File a callback for wifi network.
            mConnectivityManager.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            // Needed to ensure that the restricted concurrent connection does not
                            // match this request.
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE)
                            .build(),
                    testNetworkCallback);
            // Trigger the connection.
            mWifiManager.connect(network, actionListener);
            // now wait for action listener callback
            assertThat(countDownLatchAl.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            // check if we got the success callback
            assertThat(actionListener.onSuccessCalled).isTrue();

            // Wait for connection to complete & ensure we are connected to the saved network.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
            final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
            assertConnectionEquals(network, wifiInfo);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // User connections should always be primary.
                assertThat(wifiInfo.isPrimary()).isTrue();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            // Unregister the network callback in case of any failure (since we don't end up
            // returning the network callback to the caller).
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionWithShellIdentity(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        return testConnectionFlowWithSuggestionInternal(
                network, suggestion, executorService, restrictedNetworkCapabilities, true);
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionWithShellIdentity(
                    network, suggestion, executorService, restrictedNetworkCapabilities);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the connection failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFailureFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionInternal(
                    network, suggestion, executorService, restrictedNetworkCapabilities, false);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the entire connection success/failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     * @param expectConnectionSuccess Whether to expect connection success or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    private ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionInternal(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities,
            boolean expectConnectionSuccess) throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);
        try {
            // File a request for restricted (oem paid) wifi network.
            NetworkRequest.Builder nrBuilder = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (restrictedNetworkCapabilities.isEmpty()) {
                // If not a restricted connection, a network callback is sufficient.
                mConnectivityManager.registerNetworkCallback(
                        nrBuilder.build(), testNetworkCallback);
            } else {
                for (Integer restrictedNetworkCapability : restrictedNetworkCapabilities) {
                    nrBuilder.addCapability(restrictedNetworkCapability);
                }
                mConnectivityManager.requestNetwork(nrBuilder.build(), testNetworkCallback);
            }
            // Add wifi network suggestion.
            assertThat(mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)))
                    .isEqualTo(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS);
            // Wait for the request to reach the wifi stack before kick-start periodic scans.
            Thread.sleep(100);
            // Step: Trigger scans periodically to trigger network selection quicker.
            executorService.scheduleAtFixedRate(() -> {
                if (!mWifiManager.startScan()) {
                    Log.w(TAG, ""Failed to trigger scan"");
                }
            }, 0, DURATION_MILLIS, TimeUnit.MILLISECONDS);
            if (expectConnectionSuccess) {
                // now wait for connection to complete and wait for callback
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
                    assertThat(wifiInfo.isTrusted()).isTrue();
                    WifiInfo redact = wifiInfo
                            .makeCopy(NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION);
                    assertThat(wifiInfo.getInformationElements()).isNotNull();
                    assertThat(redact.getInformationElements()).isNull();
                    assertThat(redact.getApplicableRedactions()).isEqualTo(
                            NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION
                            | NetworkCapabilities.REDACT_FOR_LOCAL_MAC_ADDRESS
                            | NetworkCapabilities.REDACT_FOR_NETWORK_SETTINGS);
                }
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for restricted connection is supported, this should not
                    // be the primary connection.
                    if (!restrictedNetworkCapabilities.isEmpty()
                            && mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            } else {
                // now wait for connection to timeout.
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isFalse();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            executorService.shutdown();
        }
        return testNetworkCallback;
    }

    private static class TestNetworkRequestMatchCallback implements
            WifiManager.NetworkRequestMatchCallback {
        private final Object mLock;

        public boolean onRegistrationCalled = false;
        public boolean onAbortCalled = false;
        public boolean onMatchCalled = false;
        public boolean onConnectSuccessCalled = false;
        public boolean onConnectFailureCalled = false;
        public WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback = null;
        public List<ScanResult> matchedScanResults = null;

        TestNetworkRequestMatchCallback(Object lock) {
            mLock = lock;
        }

        @Override
        public void onUserSelectionCallbackRegistration(
                WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback) {
            synchronized (mLock) {
                onRegistrationCalled = true;
                this.userSelectionCallback = userSelectionCallback;
                mLock.notify();
            }
        }

        @Override
        public void onAbort() {
            synchronized (mLock) {
                onAbortCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onMatch(List<ScanResult> scanResults) {
            synchronized (mLock) {
                // This can be invoked multiple times. So, ignore after the first one to avoid
                // disturbing the rest of the test sequence.
                if (onMatchCalled) return;
                onMatchCalled = true;
                matchedScanResults = scanResults;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectSuccess(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectFailure(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectFailureCalled = true;
                mLock.notify();
            }
        }
    }

    private void handleUiInteractions(WifiConfiguration network, boolean shouldUserReject) {
        // can't use CountDownLatch since there are many callbacks expected and CountDownLatch
        // cannot be reset.
        // TODO(b/177591382): Use ArrayBlockingQueue/LinkedBlockingQueue
        Object uiLock = new Object();
        TestNetworkRequestMatchCallback networkRequestMatchCallback =
                new TestNetworkRequestMatchCallback(uiLock);
        try {
            // 1. Wait for registration callback.
            synchronized (uiLock) {
                try {
                    mWifiManager.registerNetworkRequestMatchCallback(
                            Executors.newSingleThreadExecutor(), networkRequestMatchCallback);
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            assertThat(networkRequestMatchCallback.onRegistrationCalled).isTrue();
            assertThat(networkRequestMatchCallback.userSelectionCallback).isNotNull();

            // 2. Wait for matching scan results
            synchronized (uiLock) {
                if (!networkRequestMatchCallback.onMatchCalled) {
                    try {
                        uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                    } catch (InterruptedException e) {
                    }
                }
            }
            assertThat(networkRequestMatchCallback.onMatchCalled).isTrue();
            assertThat(networkRequestMatchCallback.matchedScanResults).isNotNull();
            assertThat(networkRequestMatchCallback.matchedScanResults.size()).isAtLeast(1);

            // 3. Trigger connection to one of the matched networks or reject the request.
            if (shouldUserReject) {
                networkRequestMatchCallback.userSelectionCallback.reject();
            } else {
                networkRequestMatchCallback.userSelectionCallback.select(network);
            }

            // 4. Wait for connection success or abort.
            synchronized (uiLock) {
                try {
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            if (shouldUserReject) {
                assertThat(networkRequestMatchCallback.onAbortCalled).isTrue();
            } else {
                assertThat(networkRequestMatchCallback.onConnectSuccessCalled).isTrue();
            }
        } finally {
            mWifiManager.unregisterNetworkRequestMatchCallback(networkRequestMatchCallback);
        }
    }

    /**
     * Tests the entire connection flow using the provided specifier,
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifierWithShellIdentity(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);

        // Fork a thread to handle the UI interactions.
        Thread uiThread = new Thread(() -> {
            try {
                handleUiInteractions(network, shouldUserReject);
            } catch (Throwable e /* catch assertions & exceptions */) {
                try {
                    mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
                } catch (IllegalArgumentException ie) { }
                throw e;
            }
        });

        try {
            // File a request for wifi network.
            mConnectivityManager.requestNetwork(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            .setNetworkSpecifier(specifier)
                            .build(),
                    testNetworkCallback);
            // Wait for the request to reach the wifi stack before kick-starting the UI
            // interactions.
            Thread.sleep(1_000);
            // Start the UI interactions.
            uiThread.run();
            // now wait for callback
            assertThat(countDownLatch.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            if (shouldUserReject) {
                assertThat(testNetworkCallback.onUnavailableCalled).isTrue();
            } else {
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for local only connection is supported, this should not
                    // be the primary connection.
                    if (mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        }
        try {
            // Ensure that the UI interaction thread has completed.
            uiThread.join(DURATION_UI_INTERACTION_MILLIS);
        } catch (InterruptedException e) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            fail(""UI interaction interrupted"");
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection flow using the provided specifier.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS);
            return testConnectionFlowWithSpecifierWithShellIdentity(
                    network, specifier, shouldUserReject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Returns the number of wifi connections visible at the networking layer.
     */
    public long getNumWifiConnections() {
        Network[] networks = mConnectivityManager.getAllNetworks();
        return Arrays.stream(networks)
                .filter(n ->
                        mConnectivityManager.getNetworkCapabilities(n).hasTransport(TRANSPORT_WIFI))
                .count();
    }

    /**
     * Registers a network callback for internet connectivity via wifi and asserts that a network
     * is available within {@link #DURATION_NETWORK_CONNECTION_MILLIS}.
     *
     * @throws Exception
     */
    public void assertWifiInternetConnectionAvailable() throws Exception {
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        try {
            // File a callback for wifi network.
            NetworkRequest.Builder builder = new NetworkRequest.Builder()
                    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // Needed to ensure that the restricted concurrent connection does not
                // match this request.
                builder.addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                        .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE);
            }
            mConnectivityManager.registerNetworkCallback(builder.build(), testNetworkCallback);
            // Wait for connection to complete & ensure we are connected to some network capable
            // of providing internet access.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
        } finally {
            mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
        }
    }

    public static int getBandFromFrequency(final int freqMHz) {
        if (freqMHz < 1000) {
            return ScanResult.UNSPECIFIED;
        } else if (freqMHz < 4000) { // getFrequency is in WifiInfo.FREQUENCY_UNITS = MHz
            return ScanResult.WIFI_BAND_24_GHZ;
        } else if (freqMHz < 5900) {
            // 5GHz band stops at 5885MHz, 6GHz band starts at 5955. See android.net.wifi.ScanResult
            return ScanResult.WIFI_BAND_5_GHZ;
        } else if (freqMHz < 10_000) {
            return ScanResult.WIFI_BAND_6_GHZ;
        } else if (freqMHz < 71_000) {
            // 60 GHz band stops at 70_200
            return ScanResult.WIFI_BAND_60_GHZ;
        } else {
            return ScanResult.UNSPECIFIED;
        }
    }

}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerOnSubsystemRestart"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerOnSubsystemRestart() throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestConnectedNetworkScorerWithSessionInfo connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionInfo(countDownLatchScorer);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Clear any external scorer already active on the device.
            mWifiManager.clearWifiConnectedNetworkScorer();
            Thread.sleep(500);

            mWifiManager.setWifiConnectedNetworkScorer(
                    Executors.newSingleThreadExecutor(), connectedNetworkScorer);
            // Since we're already connected, wait for onStart to be invoked.
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            int prevSessionId = connectedNetworkScorer.startSessionId;
            WifiManager.ScoreUpdateObserver prevScoreUpdateObserver =
                    connectedNetworkScorer.scoreUpdateObserver;

            // Expect one stop followed by one start after the restart

            // Ensure that we got an onStop() for the previous connection when restart is invoked.
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);

            // Restart wifi subsystem.
            mWifiManager.restartWifiSubsystem();
            // Wait for the device to connect back.
            PollingCheck.check(
                    ""Wifi not connected"",
                    WIFI_CONNECT_TIMEOUT_MILLIS * 2,
                    () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(connectedNetworkScorer.stopSessionId).isEqualTo(prevSessionId);

            // Followed by a new onStart() after the connection.
            // Note: There is a 5 second delay between stop/start when restartWifiSubsystem() is
            // invoked, so this should not be racy.
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(connectedNetworkScorer.startSessionId).isNotEqualTo(prevSessionId);

            // Ensure that we did not get a new score update observer.
            assertThat(connectedNetworkScorer.scoreUpdateObserver).isSameInstanceAs(
                    prevScoreUpdateObserver);
        } finally {
            mWifiManager.clearWifiConnectedNetworkScorer();
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private interface ConnectionInitiator {
        /**
         * Trigger connection (using suggestion or specifier) to the provided network.
         */
        ConnectivityManager.NetworkCallback initiateConnection(
                @NonNull WifiConfiguration testNetwork,
                @NonNull ScheduledExecutorService executorService) throws Exception;
    }

    private void setWifiConnectedNetworkScorerAndInitiateConnectToSpecifierOrRestrictedSuggestion(
            @NonNull ConnectionInitiator connectionInitiator) throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestConnectedNetworkScorerWithSessionInfo connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionInfo(countDownLatchScorer);
        ConnectivityManager.NetworkCallback networkCallback = null;
        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity(
                    NETWORK_SETTINGS, WIFI_UPDATE_USABILITY_STATS_SCORE, CONNECTIVITY_INTERNAL,
                    READ_WIFI_CREDENTIAL);

            // Clear any external scorer already active on the device.
            mWifiManager.clearWifiConnectedNetworkScorer();
            Thread.sleep(500);

            savedNetworks = mWifiManager.getPrivilegedConfiguredNetworks();
            WifiConfiguration testNetwork =
                    TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks)
                            .get(0);
            // Disconnect & disable auto-join on the saved network to prevent auto-connect from
            // interfering with the test.
            for (WifiConfiguration savedNetwork : savedNetworks) {
                mWifiManager.disableNetwork(savedNetwork.networkId);
            }
            // Wait for Wifi to be disconnected.
            PollingCheck.check(
                    ""Wifi not disconnected"",
                    20000,
                    () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
            assertThat(testNetwork).isNotNull();

            // Register the external scorer.
            mWifiManager.setWifiConnectedNetworkScorer(
                    Executors.newSingleThreadExecutor(), connectedNetworkScorer);

            // Now connect using the provided connection initiator
            networkCallback = connectionInitiator.initiateConnection(testNetwork, executorService);

            // We should not receive the start
            assertThat(countDownLatchScorer.await(WAIT_DURATION, TimeUnit.MILLISECONDS)).isFalse();
            assertThat(connectedNetworkScorer.startSessionId).isNull();

            // Now disconnect from the network.
            mConnectivityManager.unregisterNetworkCallback(networkCallback);
            networkCallback = null;

            // We should not receive the stop either
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);
            assertThat(countDownLatchScorer.await(WAIT_DURATION, TimeUnit.MILLISECONDS)).isFalse();
            assertThat(connectedNetworkScorer.stopSessionId).isNull();
        } finally {
            executorService.shutdownNow();
            mWifiManager.clearWifiConnectedNetworkScorer();
            if (networkCallback != null) {
                mConnectivityManager.unregisterNetworkCallback(networkCallback);
            }
            // Re-enable the networks after the test.
            if (savedNetworks != null) {
                for (WifiConfiguration savedNetwork : savedNetworks) {
                    mWifiManager.enableNetwork(savedNetwork.networkId, false);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }
    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer is not notified for local only connections.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerForSpecifierConnection"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerForSpecifierConnection() throws Exception {
        setWifiConnectedNetworkScorerAndInitiateConnectToSpecifierOrRestrictedSuggestion(
                (testNetwork, executorService) -> {
                    // Connect using wifi network specifier.
                    WifiNetworkSpecifier specifier =
                            TestHelper.createSpecifierBuilderWithCredentialFromSavedNetwork(
                                    testNetwork)
                                    .build();
                    return mTestHelper.testConnectionFlowWithSpecifierWithShellIdentity(
                            testNetwork, specifier, false);
                }
        );
    }

    private void testSetWifiConnectedNetworkScorerForRestrictedSuggestionConnection(
            Set<Integer> restrictedNetworkCapabilities) throws Exception {
        setWifiConnectedNetworkScorerAndInitiateConnectToSpecifierOrRestrictedSuggestion(
                (testNetwork, executorService) -> {
                    // Connect using wifi network suggestion.
                    WifiNetworkSuggestion.Builder suggestionBuilder =
                            TestHelper
                                    .createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
                                    testNetwork);
                    if (restrictedNetworkCapabilities.contains(NET_CAPABILITY_OEM_PAID)) {
                        suggestionBuilder.setOemPaid(true);
                    }
                    if (restrictedNetworkCapabilities.contains(NET_CAPABILITY_OEM_PRIVATE)) {
                        suggestionBuilder.setOemPrivate(true);
                    }
                    return mTestHelper.testConnectionFlowWithSuggestionWithShellIdentity(
                            testNetwork, suggestionBuilder.build(), executorService,
                            restrictedNetworkCapabilities);
                }
        );
    }

    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer is not notified for oem paid suggestion connections.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerForOemPaidSuggestionConnection"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerForOemPaidSuggestionConnection() throws Exception {
        testSetWifiConnectedNetworkScorerForRestrictedSuggestionConnection(
                Set.of(NET_CAPABILITY_OEM_PAID));
    }

    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer is not notified for oem private suggestion connections.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerForOemPrivateSuggestionConnection"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiConnectedNetworkScorerForOemPrivateSuggestionConnection()
            throws Exception {
        testSetWifiConnectedNetworkScorerForRestrictedSuggestionConnection(
                Set.of(NET_CAPABILITY_OEM_PRIVATE));
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.PreferentialNetworkServiceTest"	"TestApis"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/PreferentialNetworkServiceTest.java"	""	"/*
 *.
 */

package android.devicepolicy.cts;

import static android.Manifest.permission.ACCESS_NETWORK_STATE;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.NetworkCapabilities.NET_CAPABILITY_ENTERPRISE;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED;

import android.app.Instrumentation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkProvider;
import android.net.NetworkScore;
import android.os.HandlerExecutor;
import android.os.HandlerThread;
import android.os.Process;
import android.util.Range;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.bedstead.harrier.BedsteadJUnit4;
import com.android.bedstead.harrier.DeviceState;
import com.android.bedstead.harrier.annotations.EnsureHasPermission;
import com.android.bedstead.harrier.annotations.Postsubmit;
import com.android.bedstead.harrier.annotations.enterprise.PositivePolicyTest;
import com.android.bedstead.harrier.policies.PreferentialNetworkService;
import com.android.bedstead.nene.TestApis;
import com.android.testutils.TestableNetworkCallback;
import com.android.testutils.TestableNetworkOfferCallback;

import org.junit.After;
import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Objects;
import java.util.Set;

// TODO(b/190797743): Move this test to to net test folder.
@RunWith(BedsteadJUnit4.class)
public class PreferentialNetworkServiceTest {
    @ClassRule @Rule
    public static final DeviceState sDeviceState = new DeviceState();

    private final long DEFAULT_TIMEOUT_MS = 30_000L;
    private final long NO_CALLBACK_TIMEOUT_MS = 100L;
    private final String TAG = PreferentialNetworkServiceTest.class.getSimpleName();

    private static final TestApis sTestApis = new TestApis();
    private static final Context sContext = sTestApis.context().instrumentedContext();
    private static final ConnectivityManager sCm =
            sContext.getSystemService(ConnectivityManager.class);
    private final HandlerThread mHandlerThread = new HandlerThread(TAG + "" handler thread"");
    private final NetworkCapabilities mEnterpriseNcFilter = new NetworkCapabilities.Builder()
            .addCapability(NET_CAPABILITY_INTERNET)
            .addCapability(NET_CAPABILITY_NOT_VCN_MANAGED)
            .addCapability(NET_CAPABILITY_ENTERPRISE)
            .removeCapability(NET_CAPABILITY_NOT_RESTRICTED)
            // Only accept requests from this uid, otherwise the provider who uses this
            // filter might see all requests of the same user if the feature is enabled.
            .setUids(Set.of(new Range(Process.myUid(), Process.myUid())))
            .build();

    @Before
    public void setUp() throws Exception {
        mHandlerThread.start();
    }

    @After
    public void tearDown() throws Exception {
        mHandlerThread.quitSafely();
    }

    /**
     * Enable PreferentialNetworkService, verify the provider that provides enterprise slice can
     * see the enterprise slice requests.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.perfetto.PerfettoTests"	"testPerfettoTriggerAtoms"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/perfetto/PerfettoTests.java"	""	"public void testPerfettoTriggerAtoms() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), DeviceUtils.FEATURE_WATCH)) return;

        StatsdConfig.Builder config = ConfigUtils.createConfigBuilder(""AID_SHELL"");
        ConfigUtils.addEventMetric(config, AtomsProto.Atom.PERFETTO_TRIGGER_FIELD_NUMBER);
        ConfigUtils.uploadConfig(getDevice(), config);

        runTriggerPerfetto();
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data).hasSize(1);
        assertThat(extractPerfettoTriggerEvents(data))
                .containsExactly(
                        PerfettoTrigger.Event.PERFETTO_TRIGGER_PERFETTO_TRIGGER);
    }

    /**
     * Returns a protobuf-encoded perfetto config that enables the kernel ftrace tracer with
     * sched_switch for 10 seconds.
     */
    private ByteString getPerfettoConfig() {
        TraceConfig.Builder builder = TraceConfig.newBuilder();

        TraceConfig.BufferConfig buffer =
                TraceConfig.BufferConfig.newBuilder().setSizeKb(128).build();
        builder.addBuffers(buffer);

        FtraceConfig ftraceConfig =
                FtraceConfig.newBuilder().addFtraceEvents(""sched/sched_switch"").build();
        DataSourceConfig dataSourceConfig =
                DataSourceConfig.newBuilder()
                        .setName(""linux.ftrace"")
                        .setTargetBuffer(0)
                        .setFtraceConfig(ftraceConfig)
                        .build();
        TraceConfig.DataSource dataSource =
                TraceConfig.DataSource.newBuilder().setConfig(dataSourceConfig).build();
        builder.addDataSources(dataSource);

        builder.setDurationMs(3000);
        builder.setAllowUserBuildTracing(true);

        TraceConfig.IncidentReportConfig incident =
                TraceConfig.IncidentReportConfig.newBuilder()
                        .setSkipIncidentd(true)
                        .build();
        builder.setIncidentReportConfig(incident);

        // To avoid being hit with guardrails firing in multiple test runs back
        // to back, we set a unique session key for each config.
        Random random = new Random();
        StringBuilder sessionNameBuilder = new StringBuilder(""statsd-cts-atom-"");
        sessionNameBuilder.append(random.nextInt() & Integer.MAX_VALUE);
        builder.setUniqueSessionName(sessionNameBuilder.toString());

        return builder.build().toByteString();
    }

    private List<PerfettoUploaded.Event> extractPerfettoUploadedEvents(
            List<EventMetricData> input) {
        List<PerfettoUploaded.Event> output = new ArrayList<>();
        for (EventMetricData data : input) {
            output.add(data.getAtom().getPerfettoUploaded().getEvent());
        }
        return output;
    }

    private List<PerfettoTrigger.Event> extractPerfettoTriggerEvents(
            List<EventMetricData> input) {
        List<PerfettoTrigger.Event> output = new ArrayList<>();
        for (EventMetricData data : input) {
            output.add(data.getAtom().getPerfettoTrigger().getEvent());
        }
        return output;
    }

    /**
     * Resets the state of the Perfetto guardrails. This avoids that the test fails if it's run too
     * close of for too many times and hits the upload limit.
     */
    private void runTriggerPerfetto() throws Exception {
        final String cmd = ""trigger_perfetto cts.test.trigger"";
        CommandResult cr = getDevice().executeShellV2Command(cmd);
        if (cr.getStatus() != CommandStatus.SUCCESS)
            throw new Exception(
                    String.format(
                            ""Error while executing %s: %s %s"",
                            cmd, cr.getStdout(), cr.getStderr()));
    }

    /**
     * Resets the state of the Perfetto guardrails. This avoids that the test fails if it's run too
     * close of for too many times and hits the upload limit.
     */
    private void resetPerfettoGuardrails() throws Exception {
        final String cmd = ""perfetto --reset-guardrails"";
        CommandResult cr = getDevice().executeShellV2Command(cmd);
        if (cr.getStatus() != CommandStatus.SUCCESS)
            throw new Exception(
                    String.format(
                            ""Error while executing %s: %s %s"",
                            cmd, cr.getStdout(), cr.getStderr()));
    }

    private void startPerfettoTrace() throws Exception {
        getDevice()
                .executeShellCommand(
                        String.format(
                                ""cmd stats log-app-breadcrumb %d %d"",
                                1, AppBreadcrumbReported.State.START.ordinal()));
    }

    private final StatsdConfig.Builder getStatsdConfig() throws Exception {
        return ConfigUtils.createConfigBuilder(""AID_NOBODY"")
                .addSubscription(
                        Subscription.newBuilder()
                                .setId(SUBSCRIPTION_ID_PERFETTO)
                                .setRuleType(Subscription.RuleType.ALERT)
                                .setRuleId(ALERT_ID)
                                .setPerfettoDetails(
                                        PerfettoDetails.newBuilder()
                                                .setTraceConfig(getPerfettoConfig())))
                .addValueMetric(
                        ValueMetric.newBuilder()
                                .setId(METRIC_ID)
                                .setWhat(APP_BREADCRUMB_REPORTED_MATCH_START_ID)
                                .setBucket(TimeUnit.ONE_MINUTE)
                                // Get the label field's value:
                                .setValueField(
                                        FieldMatcher.newBuilder()
                                                .setField(Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER)
                                                .addChild(
                                                        FieldMatcher.newBuilder()
                                                                .setField(
                                                                        AppBreadcrumbReported
                                                                                .LABEL_FIELD_NUMBER))))
                .addAtomMatcher(
                        StatsdConfigProto.AtomMatcher.newBuilder()
                                .setId(APP_BREADCRUMB_REPORTED_MATCH_START_ID)
                                .setSimpleAtomMatcher(
                                        StatsdConfigProto.SimpleAtomMatcher.newBuilder()
                                                .setAtomId(
                                                        Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER)
                                                .addFieldValueMatcher(
                                                        ConfigUtils.createFvm(
                                                                        AppBreadcrumbReported
                                                                                .STATE_FIELD_NUMBER)
                                                                .setEqInt(
                                                                        AppBreadcrumbReported.State
                                                                                .START
                                                                                .ordinal()))))
                .addAlert(
                        Alert.newBuilder()
                                .setId(ALERT_ID)
                                .setMetricId(METRIC_ID)
                                .setNumBuckets(4)
                                .setRefractoryPeriodSecs(0)
                                .setTriggerIfSumGt(0))
                .addNoReportMetric(METRIC_ID);
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.widget.cts.TextViewTest"	"testFontResourcesXml_restrictedContext"	"CtsWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	"@MediumTest
    public void testFontResourcesXml_restrictedContext()
            throws PackageManager.NameNotFoundException {
        Context restrictedContext = mActivity.createPackageContext(mActivity.getPackageName(),
                Context.CONTEXT_RESTRICTED);
        LayoutInflater layoutInflater = (LayoutInflater) restrictedContext.getSystemService(
                Context.LAYOUT_INFLATER_SERVICE);
        View root = layoutInflater.inflate(R.layout.textview_restricted_layout, null);

        mTextView = root.findViewById(R.id.textview_fontresource_fontfamily);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_fontfamily);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_nonFontReference);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontresource_style);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_style);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontresource_textAppearance);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_textAppearance);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
    }

    @UiThreadTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.host.multiuser.BaseMultiUserTest"	"TestName"	"CtsMultiUserHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/multiuser/src/android/host/multiuser/BaseMultiUserTest.java"	""	"public void test/*
 *
 */
package android.host.multiuser;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import com.android.ddmlib.Log;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import org.junit.After;
import org.junit.AssumptionViolatedException;
import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.TestName;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Scanner;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Base class for multi user tests.
 */
// Must be public because of @Rule
public abstract class BaseMultiUserTest extends BaseHostJUnit4Test {

    /** Guest flag value from android/content/pm/UserInfo.java */
    private static final int FLAG_GUEST = 0x00000004;

    /**
     * Feature flag for automotive devices
     * https://source.android.com/compatibility/android-cdd#2_5_automotive_requirements
     */
    private static final String FEATURE_AUTOMOTIVE = ""feature:android.hardware.type.automotive"";

    protected static final long LOGCAT_POLL_INTERVAL_MS = 1000;
    protected static final long USER_SWITCH_COMPLETE_TIMEOUT_MS = 360_000;

    /** Whether multi-user is supported. */
    protected int mInitialUserId;
    protected int mPrimaryUserId;

    /** Users we shouldn't delete in the tests. */
    private ArrayList<Integer> mFixedUsers;

    @Rule
    public final TestName mTestNameRule = new TestName();

    @Before
    public void setUp() throws Exception {
        mInitialUserId = getDevice().getCurrentUser();
        mPrimaryUserId = getDevice().getPrimaryUserId();

        // Test should not modify / remove any of the existing users.
        mFixedUsers = getDevice().listUsers();
    }

    @After
    public void tearDown() throws Exception {
        int currentUserId = getDevice().getCurrentUser();
        if (currentUserId != mInitialUserId) {
            CLog.w(""User changed during test (to %d). Switching back to %d"", currentUserId,
                    mInitialUserId);
            getDevice().switchUser(mInitialUserId);
        }
        // Remove the users created during this test.
        removeTestUsers();
    }

    protected String getTestName() {
        return mTestNameRule.getMethodName();
    }

    protected void assumeNotRoot() throws DeviceNotAvailableException {
        if (!getDevice().isAdbRoot()) return;

        String message = ""Cannot test "" + getTestName() + "" on rooted devices"";
        CLog.logAndDisplay(Log.LogLevel.WARN, message);
        throw new AssumptionViolatedException(message);
    }

    protected int createRestrictedProfile(int userId)
            throws DeviceNotAvailableException, IllegalStateException{
        final String command = ""pm create-user --profileOf "" + userId + "" --restricted ""
                + ""TestUser_"" + System.currentTimeMillis();
        final String output = getDevice().executeShellCommand(command);

        if (output.startsWith(""Success"")) {
            try {
                return Integer.parseInt(output.substring(output.lastIndexOf("" "")).trim());
            } catch (NumberFormatException e) {
                CLog.e(""Failed to parse result: %s"", output);
            }
        } else {
            CLog.e(""Failed to create restricted profile: %s"", output);
        }
        throw new IllegalStateException();
    }

    protected int createGuestUser() throws Exception {
        return getDevice().createUser(
                ""TestUser_"" + System.currentTimeMillis() /* name */,
                true /* guest */,
                false /* ephemeral */);
    }

    protected int getGuestUser() throws Exception {
        for (int userId : getDevice().listUsers()) {
            if ((getDevice().getUserFlags(userId) & FLAG_GUEST) != 0) {
                return userId;
            }
        }
        return -1;
    }

    protected void assumeGuestDoesNotExist() throws Exception {
        assumeTrue(""Device already has a guest user"", getGuestUser() == -1);
    }

    protected void assumeIsAutomotive() throws Exception {
        assumeTrue(""Device does not have "" + FEATURE_AUTOMOTIVE,
                getDevice().hasFeature(FEATURE_AUTOMOTIVE));
    }

    protected void assertSwitchToNewUser(int toUserId) throws Exception {
        final String exitString = ""Finished processing BOOT_COMPLETED for u"" + toUserId;
        final Set<String> appErrors = new LinkedHashSet<>();
        getDevice().executeAdbCommand(""logcat"", ""-b"", ""all"", ""-c""); // Reset log
        assertWithMessage(""Couldn't switch to user %s"", toUserId)
                .that(getDevice().switchUser(toUserId)).isTrue();
        final boolean result = waitForUserSwitchComplete(appErrors, toUserId, exitString);
        assertWithMessage(""Didn't receive BOOT_COMPLETED delivered notification. appErrors=%s"",
                appErrors).that(result).isTrue();
        if (!appErrors.isEmpty()) {
            throw new AppCrashOnBootError(appErrors);
        }
    }

    protected void assertSwitchToUser(int fromUserId, int toUserId) throws Exception {
        final String exitString = ""uc_continue_user_switch: ["" + fromUserId + "","" + toUserId + ""]"";
        final Set<String> appErrors = new LinkedHashSet<>();
        getDevice().executeAdbCommand(""logcat"", ""-b"", ""all"", ""-c""); // Reset log
        assertWithMessage(""Couldn't switch to user %s"", toUserId)
                .that(getDevice().switchUser(toUserId)).isTrue();
        final boolean result = waitForUserSwitchComplete(appErrors, toUserId, exitString);
        assertWithMessage(""Didn't reach \""Continue user switch\"" stage. appErrors=%s"", appErrors)
                .that(result).isTrue();
        if (!appErrors.isEmpty()) {
            throw new AppCrashOnBootError(appErrors);
        }
    }

    protected void assertUserNotPresent(int userId) throws Exception {
        assertWithMessage(""User ID %s should not be present"", userId)
                .that(getDevice().listUsers()).doesNotContain(userId);
    }

    protected void assertUserPresent(int userId) throws Exception {
        assertWithMessage(""User ID %s should be present"", userId)
                .that(getDevice().listUsers()).contains(userId);
    }

    /*
     * Waits for userId to removed or at removing state.
     * Returns true if user is removed or at removing state.
     * False if user is not removed by USER_SWITCH_COMPLETE_TIMEOUT_MS.
     */
    protected boolean waitForUserRemove(int userId)
            throws DeviceNotAvailableException, InterruptedException {
        // Example output from dumpsys when user is flagged for removal:
        // UserInfo{11:Driver:154} serialNo=50 <removing>  <partial>
        final String userSerialPatter = ""(.*\\{)(\\d+)(.*\\})(.*=)(\\d+)(.*)"";
        final Pattern pattern = Pattern.compile(userSerialPatter);
        long ti = System.currentTimeMillis();
        while (System.currentTimeMillis() - ti < USER_SWITCH_COMPLETE_TIMEOUT_MS) {
            if (!getDevice().listUsers().contains(userId)) {
                return true;
            }
            String commandOutput = getDevice().executeShellCommand(""dumpsys user"");
            Matcher matcher = pattern.matcher(commandOutput);
            while(matcher.find()) {
                if (Integer.parseInt(matcher.group(2)) == userId
                        && matcher.group(6).contains(""removing"")) {
                    return true;
                }
            }
            Thread.sleep(LOGCAT_POLL_INTERVAL_MS);
        }
        return false;
    }

    private boolean waitForUserSwitchComplete(Set<String> appErrors, int targetUserId,
            String exitString) throws DeviceNotAvailableException, InterruptedException {
        boolean mExitFound = false;
        long ti = System.currentTimeMillis();
        while (System.currentTimeMillis() - ti < USER_SWITCH_COMPLETE_TIMEOUT_MS) {
            String logs = getDevice().executeAdbCommand(""logcat"", ""-b"", ""all"", ""-d"",
                    ""ActivityManager:D"", ""AndroidRuntime:E"", ""*:I"");
            Scanner in = new Scanner(logs);
            while (in.hasNextLine()) {
                String line = in.nextLine();
                if (line.contains(""Showing crash dialog for package"")) {
                    appErrors.add(line);
                } else if (line.contains(exitString)) {
                    // Parse all logs in case crashes occur as a result of onUserChange callbacks
                    mExitFound = true;
                } else if (line.contains(""FATAL EXCEPTION IN SYSTEM PROCESS"")) {
                    throw new IllegalStateException(""System process crashed - "" + line);
                }
            }
            in.close();
            if (mExitFound) {
                if (!appErrors.isEmpty()) {
                    CLog.w(""App crash dialogs found: %s"", appErrors);
                }
                return true;
            }
            Thread.sleep(LOGCAT_POLL_INTERVAL_MS);
        }
        return false;
    }

    private void removeTestUsers() throws Exception {
        for (int userId : getDevice().listUsers()) {
            if (!mFixedUsers.contains(userId)) {
                getDevice().removeUser(userId);
            }
        }
    }

    static class AppCrashOnBootError extends AssertionError {
        private static final Pattern PACKAGE_NAME_PATTERN = Pattern.compile(""package ([^\\s]+)"");
        private Set<String> errorPackages;

        AppCrashOnBootError(Set<String> errorLogs) {
            super(""App error dialog(s) are present: "" + errorLogs);
            this.errorPackages = errorLogsToPackageNames(errorLogs);
        }

        private static Set<String> errorLogsToPackageNames(Set<String> errorLogs) {
            Set<String> result = new HashSet<>();
            for (String line : errorLogs) {
                Matcher matcher = PACKAGE_NAME_PATTERN.matcher(line);
                if (matcher.find()) {
                    result.add(matcher.group(1));
                } else {
                    throw new IllegalStateException(""Unrecognized line "" + line);
                }
            }
            return result;
        }
    }

    /**
     * Rule that retries the test if it failed due to {@link AppCrashOnBootError}
     */
    public static class AppCrashRetryRule implements TestRule {

        @Override
        public Statement apply(Statement base, Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    Set<String> errors = evaluateAndReturnAppCrashes(base);
                    if (errors.isEmpty()) {
                        CLog.v(""Good News, Everyone! No App crashes on %s"",
                                description.getMethodName());
                        return;
                    }
                    CLog.e(""Retrying due to app crashes: %s"", errors);
                    // Fail only if same apps are crashing in both runs
                    errors.retainAll(evaluateAndReturnAppCrashes(base));
                    assertWithMessage(""App error dialog(s) are present after 2 attempts"")
                            .that(errors).isEmpty();
                }
            };
        }

        private static Set<String> evaluateAndReturnAppCrashes(Statement base) throws Throwable {
            try {
                base.evaluate();
            } catch (AppCrashOnBootError e) {
                return e.errorPackages;
            }
            return new HashSet<>();
        }
    }

    /**
     * Rule that skips a test if device does not support more than 1 user
     */
    protected static class SupportsMultiUserRule implements TestRule {

        private final BaseHostJUnit4Test mDeviceTest;

        SupportsMultiUserRule(BaseHostJUnit4Test deviceTest) {
            mDeviceTest = deviceTest;
        }

        @Override
        public Statement apply(Statement base, Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    boolean supports = mDeviceTest.getDevice().getMaxNumberOfUsersSupported() > 1;
                    assumeTrue(""device does not support multi users"", supports);

                    base.evaluate();
                }
            };
        }
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.host.multiuser.CreateUsersPermissionTest"	"testCanCreateRestrictedUser"	"CtsMultiUserHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/multiuser/src/android/host/multiuser/CreateUsersPermissionTest.java"	""	"public void testCanCreateRestrictedUser() throws Exception {
        createRestrictedProfile(mPrimaryUserId);
    }

    @CddTest(requirement=""9.5/A-1-3"")"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.stubs.CommandReceiver"	"isAlive"	""	"/home/gpoor/cts-12-source/cts/tests/app/app/src/android/app/stubs/CommandReceiver.java"	""	"public void test/*
 *.
 */

package android.app.stubs;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.ForegroundServiceStartNotAllowedException;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Parcel;
import android.util.ArrayMap;
import android.util.Log;

import java.util.concurrent.TimeUnit;

public class CommandReceiver extends BroadcastReceiver {

    private static final String TAG = ""CommandReceiver"";

    // Requires flags and targetPackage
    public static final int COMMAND_BIND_SERVICE = 1;
    // Requires targetPackage
    public static final int COMMAND_UNBIND_SERVICE = 2;
    public static final int COMMAND_START_FOREGROUND_SERVICE = 3;
    public static final int COMMAND_STOP_FOREGROUND_SERVICE = 4;
    public static final int COMMAND_START_FOREGROUND_SERVICE_LOCATION = 5;
    public static final int COMMAND_STOP_FOREGROUND_SERVICE_LOCATION = 6;
    public static final int COMMAND_START_ALERT_SERVICE = 7;
    public static final int COMMAND_STOP_ALERT_SERVICE = 8;
    public static final int COMMAND_SELF_INDUCED_ANR = 9;
    public static final int COMMAND_START_ACTIVITY = 10;
    public static final int COMMAND_STOP_ACTIVITY = 11;
    public static final int COMMAND_CREATE_FGSL_PENDING_INTENT = 12;
    public static final int COMMAND_SEND_FGSL_PENDING_INTENT = 13;
    public static final int COMMAND_BIND_FOREGROUND_SERVICE = 14;
    public static final int COMMAND_START_CHILD_PROCESS = 15;
    public static final int COMMAND_STOP_CHILD_PROCESS = 16;
    public static final int COMMAND_WAIT_FOR_CHILD_PROCESS_GONE = 17;
    public static final int COMMAND_START_SERVICE = 18;
    public static final int COMMAND_STOP_SERVICE = 19;
    public static final int COMMAND_START_FOREGROUND_SERVICE_STICKY = 20;
    public static final int COMMAND_STOP_FOREGROUND_SERVICE_STICKY = 21;
    public static final int COMMAND_EMPTY = 22;

    public static final int RESULT_CHILD_PROCESS_STARTED = IBinder.FIRST_CALL_TRANSACTION;
    public static final int RESULT_CHILD_PROCESS_STOPPED = IBinder.FIRST_CALL_TRANSACTION + 1;
    public static final int RESULT_CHILD_PROCESS_GONE = IBinder.FIRST_CALL_TRANSACTION + 2;

    public static final String EXTRA_COMMAND = ""android.app.stubs.extra.COMMAND"";
    public static final String EXTRA_TARGET_PACKAGE = ""android.app.stubs.extra.TARGET_PACKAGE"";
    public static final String EXTRA_FLAGS = ""android.app.stubs.extra.FLAGS"";
    public static final String EXTRA_CALLBACK = ""android.app.stubs.extra.callback"";
    public static final String EXTRA_CHILD_CMDLINE = ""android.app.stubs.extra.child_cmdline"";
    public static final String EXTRA_TIMEOUT = ""android.app.stubs.extra.child_cmdline"";
    public static final String EXTRA_MESSENGER = ""android.app.stubs.extra.EXTRA_MESSENGER"";

    public static final String SERVICE_NAME = ""android.app.stubs.LocalService"";
    public static final String FG_SERVICE_NAME = ""android.app.stubs.LocalForegroundService"";
    public static final String FG_LOCATION_SERVICE_NAME =
            ""android.app.stubs.LocalForegroundServiceLocation"";
    public static final String FG_STICKY_SERVICE_NAME =
            ""android.app.stubs.LocalForegroundServiceSticky"";

    public static final String ACTIVITY_NAME = ""android.app.stubs.SimpleActivity"";

    private static ArrayMap<String,ServiceConnection> sServiceMap = new ArrayMap<>();

    // Map a packageName to a Intent that starts an Activity.
    private static ArrayMap<String, Intent> sActivityIntent = new ArrayMap<>();

    // Map a packageName to a PendingIntent.
    private static ArrayMap<String, PendingIntent> sPendingIntent = new ArrayMap<>();

    /** The child process, started via {@link #COMMAND_START_CHILD_PROCESS} */
    private static Process sChildProcess;

    /**
     * Handle the different types of binding/unbinding requests.
     * @param context The Context in which the receiver is running.
     * @param intent The Intent being received.
     */
    @Override
    public void onReceive(Context context, Intent intent) {
        // Use the application context as the receiver context could be restricted.
        context = context.getApplicationContext();
        int command = intent.getIntExtra(EXTRA_COMMAND, -1);
        Log.d(TAG + ""_"" + context.getPackageName(), ""Got command "" + command + "", intent=""
                + intent);
        switch (command) {
            case COMMAND_BIND_SERVICE:
                doBindService(context, intent, SERVICE_NAME);
                break;
            case COMMAND_UNBIND_SERVICE:
                doUnbindService(context, intent);
                break;
            case COMMAND_START_FOREGROUND_SERVICE:
                doStartForegroundService(context, intent);
                break;
            case COMMAND_START_SERVICE:
                doStartService(context, intent);
                break;
            case COMMAND_STOP_FOREGROUND_SERVICE:
            case COMMAND_STOP_SERVICE:
                doStopService(context, intent, FG_SERVICE_NAME);
                break;
            case COMMAND_START_FOREGROUND_SERVICE_LOCATION:
                doStartForegroundServiceWithType(context, intent);
                break;
            case COMMAND_STOP_FOREGROUND_SERVICE_LOCATION:
                doStopService(context, intent, FG_LOCATION_SERVICE_NAME);
                break;
            case COMMAND_START_FOREGROUND_SERVICE_STICKY:
                doStartForegroundServiceSticky(context, intent);
                break;
            case COMMAND_STOP_FOREGROUND_SERVICE_STICKY:
                doStopService(context, intent, FG_STICKY_SERVICE_NAME);
                break;
            case COMMAND_START_ALERT_SERVICE:
                doStartAlertService(context);
                break;
            case COMMAND_STOP_ALERT_SERVICE:
                doStopAlertService(context);
                break;
            case COMMAND_SELF_INDUCED_ANR:
                doSelfInducedAnr(context);
                break;
            case COMMAND_START_ACTIVITY:
                doStartActivity(context, intent);
                break;
            case COMMAND_STOP_ACTIVITY:
                doStopActivity(context, intent);
                break;
            case COMMAND_CREATE_FGSL_PENDING_INTENT:
                doCreateFgslPendingIntent(context, intent);
                break;
            case COMMAND_SEND_FGSL_PENDING_INTENT:
                doSendFgslPendingIntent(context, intent);
                break;
            case COMMAND_BIND_FOREGROUND_SERVICE:
                doBindService(context, intent, FG_LOCATION_SERVICE_NAME);
                break;
            case COMMAND_START_CHILD_PROCESS:
                doStartChildProcess(context, intent);
                break;
            case COMMAND_STOP_CHILD_PROCESS:
                doStopChildProcess(context, intent);
                break;
            case COMMAND_WAIT_FOR_CHILD_PROCESS_GONE:
                doWaitForChildProcessGone(context, intent);
                break;
            case COMMAND_EMPTY:
                break;
        }
    }

    private void doBindService(Context context, Intent commandIntent, String serviceName) {
        String targetPackage = getTargetPackage(commandIntent);
        int flags = getFlags(commandIntent);

        Intent bindIntent = new Intent();
        bindIntent.setComponent(new ComponentName(targetPackage, serviceName));

        ServiceConnection connection = addServiceConnection(targetPackage);

        context.bindService(bindIntent, connection, flags | Context.BIND_AUTO_CREATE);
    }

    private void doUnbindService(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        context.unbindService(sServiceMap.remove(targetPackage));
    }

    private void doStartForegroundService(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent fgsIntent = new Intent();
        fgsIntent.putExtras(commandIntent);
        fgsIntent.setComponent(new ComponentName(targetPackage, FG_SERVICE_NAME));
        int command = LocalForegroundService.COMMAND_START_FOREGROUND;
        fgsIntent.putExtras(LocalForegroundService.newCommand(command));
        try {
            context.startForegroundService(fgsIntent);
        } catch (ForegroundServiceStartNotAllowedException e) {
            Log.d(TAG, ""startForegroundService gets an ""
                    + "" ForegroundServiceStartNotAllowedException"", e);
        }
    }

    private void doStartService(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent fgsIntent = new Intent();
        fgsIntent.putExtras(commandIntent);
        fgsIntent.setComponent(new ComponentName(targetPackage, FG_SERVICE_NAME));
        context.startService(fgsIntent);
    }

    private void doStartForegroundServiceWithType(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent fgsIntent = new Intent();
        fgsIntent.putExtras(commandIntent); // include the fg service type if any.
        fgsIntent.setComponent(new ComponentName(targetPackage, FG_LOCATION_SERVICE_NAME));
        int command = LocalForegroundServiceLocation.COMMAND_START_FOREGROUND_WITH_TYPE;
        fgsIntent.putExtras(LocalForegroundService.newCommand(command));
        try {
            context.startForegroundService(fgsIntent);
        } catch (ForegroundServiceStartNotAllowedException e) {
            Log.d(TAG, ""startForegroundService gets an ""
                    + ""ForegroundServiceStartNotAllowedException"", e);
        }
    }

    private void doStartForegroundServiceSticky(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent fgsIntent = new Intent();
        fgsIntent.putExtras(commandIntent);
        fgsIntent.setComponent(new ComponentName(targetPackage, FG_STICKY_SERVICE_NAME));
        int command = LocalForegroundService.COMMAND_START_FOREGROUND;
        fgsIntent.putExtras(LocalForegroundService.newCommand(command));
        try {
            context.startForegroundService(fgsIntent);
        } catch (ForegroundServiceStartNotAllowedException e) {
            Log.d(TAG, ""startForegroundService gets an ""
                    + ""ForegroundServiceStartNotAllowedException"", e);
        }
    }

    private void doStopService(Context context, Intent commandIntent,
            String serviceName) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent fgsIntent = new Intent();
        fgsIntent.setComponent(new ComponentName(targetPackage, serviceName));
        context.stopService(fgsIntent);
    }

    private void doStartAlertService(Context context) {
        Intent intent = new Intent(context, LocalAlertService.class);
        intent.setAction(LocalAlertService.COMMAND_SHOW_ALERT);
        context.startService(intent);
    }

    private void doStopAlertService(Context context) {
        Intent intent = new Intent(context, LocalAlertService.class);
        intent.setAction(LocalAlertService.COMMAND_HIDE_ALERT);
        context.startService(intent);
    }

    private void doSelfInducedAnr(Context context) {
        ActivityManager am = context.getSystemService(ActivityManager.class);
        am.appNotResponding(""CTS - self induced"");
    }

    private void doStartActivity(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent activityIntent = new Intent(Intent.ACTION_MAIN);
        sActivityIntent.put(targetPackage, activityIntent);
        activityIntent.putExtras(commandIntent);
        activityIntent.setComponent(new ComponentName(targetPackage, ACTIVITY_NAME));
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(activityIntent);
    }

    private void doStopActivity(Context context, Intent commandIntent) {
        String targetPackage = getTargetPackage(commandIntent);
        Intent activityIntent = sActivityIntent.remove(targetPackage);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
        activityIntent.putExtra(""finish"", true);
        context.startActivity(activityIntent);
    }

    private void doCreateFgslPendingIntent(Context context, Intent commandIntent) {
        final String targetPackage = getTargetPackage(commandIntent);
        final Intent intent = new Intent().setComponent(
                new ComponentName(targetPackage, FG_LOCATION_SERVICE_NAME));
        int command = LocalForegroundServiceLocation.COMMAND_START_FOREGROUND_WITH_TYPE;
        intent.putExtras(LocalForegroundService.newCommand(command));
        final PendingIntent pendingIntent = PendingIntent.getForegroundService(context, 0,
                intent, PendingIntent.FLAG_IMMUTABLE);
        sPendingIntent.put(targetPackage, pendingIntent);
    }

    private void doSendFgslPendingIntent(Context context, Intent commandIntent) {
        final String targetPackage = getTargetPackage(commandIntent);
        try {
            ((PendingIntent) sPendingIntent.remove(targetPackage)).send();
        } catch (PendingIntent.CanceledException e) {
            Log.e(TAG, ""Caugtht exception:"", e);
        }
    }

    private void doStartChildProcess(Context context, Intent intent) {
        final Bundle extras = intent.getExtras();
        final IBinder callback = extras.getBinder(EXTRA_CALLBACK);
        final String[] cmdline = extras.getStringArray(EXTRA_CHILD_CMDLINE);
        final Parcel data = Parcel.obtain();
        final Parcel reply = Parcel.obtain();

        try {
            sChildProcess = Runtime.getRuntime().exec(cmdline);
            if (sChildProcess != null) {
                Log.i(TAG, ""Forked child: "" + sChildProcess);
                callback.transact(RESULT_CHILD_PROCESS_STARTED, data, reply, 0);
            } // else the remote will fail with timeout
        } catch (Exception e) {
            Log.e(TAG, ""Unable to execute command"", e);
            sChildProcess = null;
        } finally {
            data.recycle();
            reply.recycle();
        }
    }

    private void doStopChildProcess(Context context, Intent intent) {
        final Bundle extras = intent.getExtras();
        final IBinder callback = extras.getBinder(EXTRA_CALLBACK);
        final long timeout = extras.getLong(EXTRA_TIMEOUT);
        waitForChildProcessGone(true, callback, RESULT_CHILD_PROCESS_STOPPED, timeout);
    }

    private void doWaitForChildProcessGone(Context context, Intent intent) {
        final Bundle extras = intent.getExtras();
        final IBinder callback = extras.getBinder(EXTRA_CALLBACK);
        final long timeout = extras.getLong(EXTRA_TIMEOUT);
        waitForChildProcessGone(false, callback, RESULT_CHILD_PROCESS_GONE, timeout);
    }

    private static synchronized void waitForChildProcessGone(final boolean destroy,
            final IBinder callback, final int transactionCode, final long timeout) {
        if (destroy) {
            sChildProcess.destroy();
        }
        new Thread(() -> {
            final Parcel data = Parcel.obtain();
            final Parcel reply = Parcel.obtain();
            try {
                if (sChildProcess != null && sChildProcess.isAlive()) {
                    final boolean exit = sChildProcess.waitFor(timeout, TimeUnit.MILLISECONDS);
                    if (exit) {
                        Log.i(TAG, ""Child process died: "" + sChildProcess);
                        callback.transact(transactionCode, data, reply, 0);
                    } else {
                        Log.w(TAG, ""Child process is still alive: "" + sChildProcess);
                    }
                } else {
                    callback.transact(transactionCode, data, reply, 0);
                }
            } catch (Exception e) {
                Log.e(TAG, ""Error"", e);
            } finally {
                data.recycle();
                reply.recycle();
            }
        }).start();
    }

    private String getTargetPackage(Intent intent) {
        return intent.getStringExtra(EXTRA_TARGET_PACKAGE);
    }

    private int getFlags(Intent intent) {
        return intent.getIntExtra(EXTRA_FLAGS, 0);
    }

    public static void sendCommand(Context context, int command, String sourcePackage,
            String targetPackage, int flags, Bundle extras) {
        final Intent intent = makeIntent(command, sourcePackage, targetPackage, flags, extras);
        Log.d(TAG, ""Sending broadcast "" + intent);
        context.sendOrderedBroadcast(intent, null);
    }

    public static void sendCommandWithResultReceiver(Context context, int command,
            String sourcePackage, String targetPackage, int flags, Bundle extras,
            BroadcastReceiver resultReceiver) {
        final Intent intent = makeIntent(command, sourcePackage, targetPackage, flags, extras);
        Log.d(TAG, ""Sending broadcast with result receiver "" + intent);
        context.sendOrderedBroadcast(intent, null, resultReceiver, null,
                Activity.RESULT_OK, null, null);
    }

    public static void sendCommandWithBroadcastOptions(Context context, int command,
            String sourcePackage, String targetPackage, int flags, Bundle extras,
            Bundle broadcastOptions) {
        final Intent intent = makeIntent(command, sourcePackage, targetPackage, flags, extras);
        Log.d(TAG, ""Sending broadcast with BroadcastOptions "" + intent);
        context.sendOrderedBroadcast(intent, null, broadcastOptions, null, null, 0, null, null);
    }

    private static Intent makeIntent(int command, String sourcePackage,
            String targetPackage, int flags, Bundle extras) {
        Intent intent = new Intent();
        if (command == COMMAND_BIND_SERVICE || command == COMMAND_START_FOREGROUND_SERVICE) {
            intent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        }
        intent.setComponent(new ComponentName(sourcePackage, ""android.app.stubs.CommandReceiver""));
        intent.putExtra(EXTRA_COMMAND, command);
        intent.putExtra(EXTRA_FLAGS, flags);
        intent.putExtra(EXTRA_TARGET_PACKAGE, targetPackage);
        if (extras != null) {
            intent.putExtras(extras);
        }
        return intent;
    }

    private ServiceConnection addServiceConnection(final String packageName) {
        ServiceConnection connection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
            }
        };
        sServiceMap.put(packageName, connection);
        return connection;
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.telephony.cts.SubscriptionManagerTest"	"isSupported"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	"/*
 *.
 */

package android.telephony.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_CONGESTED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
import static android.telephony.TelephonyManager.SET_OPPORTUNISTIC_SUB_SUCCESS;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.annotation.Nullable;
import android.app.UiAutomation;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.Uri;
import android.os.Looper;
import android.os.ParcelUuid;
import android.os.PersistableBundle;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionInfo;
import android.telephony.SubscriptionManager;
import android.telephony.SubscriptionPlan;
import android.telephony.TelephonyManager;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsRcsManager;
import android.telephony.ims.RcsUceAdapter;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.TestThread;
import com.android.internal.util.ArrayUtils;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.time.Period;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;


public class SubscriptionManagerTest {
    private static final String TAG = ""SubscriptionManagerTest"";
    private static final String MODIFY_PHONE_STATE = ""android.permission.MODIFY_PHONE_STATE"";
    private static final List<Uri> CONTACTS = new ArrayList<>();
    static {
        CONTACTS.add(Uri.fromParts(""tel"", ""+16505551212"", null));
        CONTACTS.add(Uri.fromParts(""tel"", ""+16505552323"", null));
    }

    private int mSubId;
    private int mDefaultVoiceSubId;
    private String mPackageName;
    private SubscriptionManager mSm;

    /**
     * Callback used in testRegisterNetworkCallback that allows caller to block on
     * {@code onAvailable}.
     */
    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mAvailableLatch = new CountDownLatch(1);

        public void waitForAvailable() throws InterruptedException {
            assertTrue(""Cellular network did not come up after 5 seconds"",
                    mAvailableLatch.await(5, TimeUnit.SECONDS));
        }

        @Override
        public void onAvailable(Network network) {
            mAvailableLatch.countDown();
        }
    }

    @BeforeClass
    public static void setUpClass() throws Exception {
        if (!isSupported()) return;

        final TestNetworkCallback callback = new TestNetworkCallback();
        final ConnectivityManager cm = InstrumentationRegistry.getContext()
                .getSystemService(ConnectivityManager.class);
        cm.registerNetworkCallback(new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_CELLULAR)
                .addCapability(NET_CAPABILITY_INTERNET)
                .build(), callback);
        try {
            // Wait to get callback for availability of internet
            callback.waitForAvailable();
        } catch (InterruptedException e) {
            fail(""NetworkCallback wait was interrupted."");
        } finally {
            cm.unregisterNetworkCallback(callback);
        }
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if (!isSupported()) return;
        TelephonyUtils.flushTelephonyMetrics(InstrumentationRegistry.getInstrumentation());
    }

    @Before
    public void setUp() throws Exception {
        if (!isSupported()) return;

        mSm = InstrumentationRegistry.getContext().getSystemService(SubscriptionManager.class);
        mSubId = SubscriptionManager.getDefaultDataSubscriptionId();
        mDefaultVoiceSubId = SubscriptionManager.getDefaultVoiceSubscriptionId();
        mPackageName = InstrumentationRegistry.getContext().getPackageName();
    }

    /**
     * Correctness check that both {@link PackageManager#FEATURE_TELEPHONY} and
     * {@link NetworkCapabilities#TRANSPORT_CELLULAR} network must both be
     * either defined or undefined; you can't cross the streams.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSetAndGetD2DSharingContacts"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	"public void testSetAndGetD2DSharingContacts() {
        if (!isSupported()) return;

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity(MODIFY_PHONE_STATE);
        List<Uri> originalD2DSharingContacts = mSm.getDeviceToDeviceStatusSharingContacts(mSubId);
        mSm.setDeviceToDeviceStatusSharingContacts(mSubId, CONTACTS);
        assertEquals(CONTACTS, mSm.getDeviceToDeviceStatusSharingContacts(mSubId));
        mSm.setDeviceToDeviceStatusSharingContacts(mSubId, originalD2DSharingContacts);
        uiAutomation.dropShellPermissionIdentity();
    }

    @Nullable
    private PersistableBundle getBundleFromBackupData(byte[] data) {
        try (ByteArrayInputStream bis = new ByteArrayInputStream(data)) {
            return PersistableBundle.readFromStream(bis);
        } catch (IOException e) {
            return null;
        }
    }

    private void overrideCarrierConfig(PersistableBundle bundle, int subId) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getContext()
                .getSystemService(CarrierConfigManager.class);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(subId, bundle));
    }

    private void setPreferredDataSubId(int subId) {
        final LinkedBlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>(1);
        Executor executor = (command)-> command.run();
        Consumer<Integer> consumer = (res)-> {
            if (res == null) {
                resultQueue.offer(-1);
            } else {
                resultQueue.offer(res);
            }
        };

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSm,
                (sm) -> sm.setPreferredDataSubscriptionId(subId, false,
                        executor, consumer));
        int res = -1;
        try {
            res = resultQueue.poll(2, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            fail(""Cannot get the modem result in time"");
        }

        assertEquals(SET_OPPORTUNISTIC_SUB_SUCCESS, res);
        int getValue = executeWithShellPermissionAndDefault(-1, mSm,
                (sm) -> sm.getPreferredDataSubscriptionId());
        assertEquals(subId, getValue);
    }

    private <T, U> T executeWithShellPermissionAndDefault(T defaultValue, U targetObject,
            ShellIdentityUtils.ShellPermissionMethodHelper<T, U> helper) {
        try {
            return ShellIdentityUtils.invokeMethodWithShellPermissions(targetObject, helper);
        } catch (Exception e) {
            // do nothing, return default
        }
        return defaultValue;
    }

    private void assertOverrideSuccess(SubscriptionPlan... plans) {
        mSm.setSubscriptionPlans(mSubId, Arrays.asList(plans));
        mSm.setSubscriptionOverrideCongested(mSubId, false, 0);
    }

    private void assertOverrideFails(SubscriptionPlan... plans) {
        mSm.setSubscriptionPlans(mSubId, Arrays.asList(plans));
        try {
            mSm.setSubscriptionOverrideCongested(mSubId, false, 0);
            fail();
        } catch (SecurityException | IllegalStateException expected) {
        }
    }

    public static CountDownLatch waitForNetworkCapabilities(Network network,
            Predicate<NetworkCapabilities> predicate) {
        final CountDownLatch latch = new CountDownLatch(1);
        final ConnectivityManager cm = InstrumentationRegistry.getContext()
                .getSystemService(ConnectivityManager.class);
        cm.registerNetworkCallback(new NetworkRequest.Builder().build(),
                new NetworkCallback() {
                    @Override
                    public void onCapabilitiesChanged(Network net, NetworkCapabilities caps) {
                        if (net.equals(network) && predicate.test(caps)) {
                            latch.countDown();
                            cm.unregisterNetworkCallback(this);
                        }
                    }
                });
        return latch;
    }

    /**
     * Corresponding to findCellularNetwork()
     */
    private static CountDownLatch waitForCellularNetwork() {
        final CountDownLatch latch = new CountDownLatch(1);
        final ConnectivityManager cm = InstrumentationRegistry.getContext()
                .getSystemService(ConnectivityManager.class);
        cm.registerNetworkCallback(new NetworkRequest.Builder().build(),
                new NetworkCallback() {
                    @Override
                    public void onCapabilitiesChanged(Network net, NetworkCapabilities caps) {
                        if (caps.hasTransport(TRANSPORT_CELLULAR)
                                && caps.hasCapability(NET_CAPABILITY_INTERNET)
                                && caps.hasCapability(NET_CAPABILITY_NOT_RESTRICTED)) {
                            latch.countDown();
                            cm.unregisterNetworkCallback(this);
                        }
                    }
                });
        return latch;
    }

    private static SubscriptionPlan buildValidSubscriptionPlan(long dataUsageTime) {
        return SubscriptionPlan.Builder
                .createRecurring(ZonedDateTime.parse(""2007-03-14T00:00:00.000Z""),
                        Period.ofMonths(1))
                .setTitle(""CTS"")
                .setDataLimit(1_000_000_000, SubscriptionPlan.LIMIT_BEHAVIOR_DISABLED)
                .setDataUsage(500_000_000, dataUsageTime)
                .build();
    }

    private static @Nullable Network findCellularNetwork() {
        final ConnectivityManager cm = InstrumentationRegistry.getContext()
                .getSystemService(ConnectivityManager.class);
        for (Network net : cm.getAllNetworks()) {
            final NetworkCapabilities caps = cm.getNetworkCapabilities(net);
            if (caps != null && caps.hasTransport(TRANSPORT_CELLULAR)
                    && caps.hasCapability(NET_CAPABILITY_INTERNET)
                    && caps.hasCapability(NET_CAPABILITY_NOT_RESTRICTED)) {
                return net;
            }
        }
        return null;
    }

    private static boolean isSupported() {
        return InstrumentationRegistry.getContext().getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_TELEPHONY);
    }

    private static boolean isAutomotive() {
        return InstrumentationRegistry.getContext().getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }

    private static boolean isDSDS() {
        TelephonyManager tm = InstrumentationRegistry.getContext()
                .getSystemService(TelephonyManager.class);
        return tm != null && tm.getPhoneCount() > 1;
    }

    private static void setSubPlanOwner(int subId, String packageName) throws Exception {
        SystemUtil.runShellCommand(InstrumentationRegistry.getInstrumentation(),
                ""cmd netpolicy set sub-plan-owner "" + subId + "" "" + packageName);
    }

    private boolean isUnmetered5GSupported() {
        final CarrierConfigManager ccm = InstrumentationRegistry.getContext()
                .getSystemService(CarrierConfigManager.class);
        PersistableBundle carrierConfig = ccm.getConfigForSubId(mSubId);

        final TelephonyManager tm = InstrumentationRegistry.getContext()
                .getSystemService(TelephonyManager.class);
        int dataNetworkType = tm.getDataNetworkType(mSubId);
        long supportedRats = ShellIdentityUtils.invokeMethodWithShellPermissions(tm,
                TelephonyManager::getSupportedRadioAccessFamily);

        boolean validCarrier = carrierConfig.getBoolean(
                CarrierConfigManager.KEY_NETWORK_TEMP_NOT_METERED_SUPPORTED_BOOL);
        boolean validCapabilities = (supportedRats & TelephonyManager.NETWORK_TYPE_BITMASK_NR) != 0;
        // TODO: need to check for TelephonyDisplayInfo override for NR NSA
        boolean validNetworkType = dataNetworkType == TelephonyManager.NETWORK_TYPE_NR;

        return validCarrier && validNetworkType && validCapabilities;
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ExpeditedJobTest"	"uptimeMillis"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ExpeditedJobTest.java"	""	"/*
 *.
 */

package android.jobscheduler.cts;

import static android.jobscheduler.cts.JobThrottlingTest.setTestPackageStandbyBucket;
import static android.jobscheduler.cts.TestAppInterface.TEST_APP_PACKAGE;

import static org.junit.Assert.assertTrue;

import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.content.Context;
import android.jobscheduler.cts.jobtestapp.TestJobSchedulerReceiver;
import android.os.SystemClock;
import android.os.UserHandle;
import android.support.test.uiautomator.UiDevice;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AppOpsUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Collections;
import java.util.Map;

@RunWith(AndroidJUnit4.class)
public class ExpeditedJobTest {
    private static final long DEFAULT_WAIT_TIMEOUT_MS = 2_000;
    private static final String APP_OP_GET_USAGE_STATS = ""android:get_usage_stats"";

    private Context mContext;
    private UiDevice mUiDevice;
    private int mTestJobId;
    private TestAppInterface mTestAppInterface;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getTargetContext();
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mTestJobId = (int) (SystemClock.uptimeMillis() / 1000);
        mTestAppInterface = new TestAppInterface(mContext, mTestJobId);
        setTestPackageStandbyBucket(mUiDevice, JobThrottlingTest.Bucket.ACTIVE);
        AppOpsUtils.setOpMode(TEST_APP_PACKAGE, APP_OP_GET_USAGE_STATS,
                AppOpsManager.MODE_ALLOWED);
    }

    @After
    public void tearDown() throws Exception {
        mTestAppInterface.cleanup();
        AppOpsUtils.reset(TEST_APP_PACKAGE);
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.theme.app.GenerateImagesActivity"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/theme/app/src/android/theme/app/GenerateImagesActivity.java"	""	"public void test/*
 *.
 */

package android.theme.app;

import static android.theme.app.TestConfiguration.THEMES;

import android.app.Activity;
import android.content.Intent;
import android.os.Build.VERSION;
import android.os.Bundle;
import android.os.Environment;
import android.util.Log;
import android.view.WindowManager.LayoutParams;

import java.io.File;
import java.io.IOException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Generates images by iterating through all themes and launching instances of
 * {@link ThemeDeviceActivity}.
 */
public class GenerateImagesActivity extends Activity {
    private static final String TAG = ""GenerateImagesActivity"";

    private static final String OUT_DIR = ""cts-theme-assets"";
    private static final int REQUEST_CODE = 1;

    public static final String EXTRA_REASON = ""reason"";

    private final CountDownLatch mLatch = new CountDownLatch(1);

    private File mOutputDir;
    private File mOutputZip;

    private int mCurrentTheme;
    private String mFinishReason;
    private boolean mFinishSuccess;

    class CompressOutputThread extends Thread {
        public void run() {
            compressOutput();
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Useful for local testing. Not required for CTS harness.
        getWindow().addFlags(LayoutParams.FLAG_KEEP_SCREEN_ON);

        // Make sure the device has reasonable assets.
        String assetDensityFailureMsg = checkAssetDensity();
        if (assetDensityFailureMsg != null) {
            finish(""Failed to verify device assets: ""+ assetDensityFailureMsg, false);
        } else {
            mOutputDir = setupOutputDirectory();
            if (mOutputDir == null) {
                finish(""Failed to create output directory: "" + OUT_DIR, false);
            } else {
                generateNextImage();
            }
        }
    }

    private String checkAssetDensity() {
        AssetBucketVerifier.Result result = AssetBucketVerifier.verifyAssetBucket(this);

        String message;
        if (result.foundAtDensity.contains(result.expectedAtDensity)) {
            message = null;
        } else if (result.foundAtDensity.isEmpty()) {
            message = ""Failed to find expected device assets at any density"";
        } else {
            StringBuilder foundAtDensityStr = new StringBuilder(result.foundAtDensity.get(0));
            for (int i = 1; i < result.foundAtDensity.size(); i++) {
                foundAtDensityStr.append("", "");
                foundAtDensityStr.append(result.foundAtDensity.get(i));
            }
            message = ""Failed to find device assets at expected density (""
                    + result.expectedAtDensity + ""), but found at "" + foundAtDensityStr;
        }

        return message;
    }

    private File setupOutputDirectory() {
        mOutputDir = new File(Environment.getExternalStorageDirectory(), OUT_DIR);
        ThemeTestUtils.deleteDirectory(mOutputDir);
        mOutputDir.mkdirs();

        if (mOutputDir.exists()) {
            return mOutputDir;
        }
        return null;
    }

    /**
     * @return whether the test finished successfully
     */
    public boolean isFinishSuccess() {
        return mFinishSuccess;
    }

    /**
     * @return user-visible string explaining why the test finished, may be {@code null} if the test
     *         finished unexpectedly
     */
    public String getFinishReason() {
        return mFinishReason;
    }

    /**
     * Starts the activity to generate the next image.
     */
    private void generateNextImage() {
        // Keep trying themes until one works.
        boolean success = false;
        while (mCurrentTheme < THEMES.length && !success) {
            success = launchThemeDeviceActivity();
            mCurrentTheme++;
        }

        // If we ran out of themes, we're done.
        if (!success) {
            CompressOutputThread compressOutputThread = new CompressOutputThread();
            compressOutputThread.start();
        }
    }

    private boolean launchThemeDeviceActivity() {
        final ThemeInfo theme = THEMES[mCurrentTheme];
        if (theme.apiLevel > VERSION.SDK_INT) {
            Log.v(TAG, ""Skipping theme \"""" + theme.name
                    + ""\"" (requires API "" + theme.apiLevel + "")"");
            return false;
        }

        Log.v(TAG, ""Generating images for theme \"""" + theme.name + ""\""..."");

        final Intent intent = new Intent(this, ThemeDeviceActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
        intent.putExtra(ThemeDeviceActivity.EXTRA_THEME, mCurrentTheme);
        intent.putExtra(ThemeDeviceActivity.EXTRA_OUTPUT_DIR, mOutputDir.getAbsolutePath());
        startActivityForResult(intent, REQUEST_CODE);
        return true;
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode != RESULT_OK) {
            finish(""Failed to generate images for theme "" + mCurrentTheme + "" (""
                    + data.getStringExtra(EXTRA_REASON) + "")"", false);
            return;
        }

        generateNextImage();
    }

    private void compressOutput() {
        mOutputZip = new File(mOutputDir.getParentFile(), mOutputDir.getName() + "".zip"");

        if (mOutputZip.exists()) {
            // Remove any old test results.
            mOutputZip.delete();
        }

        try {
            ThemeTestUtils.compressDirectory(mOutputDir, mOutputZip);
            ThemeTestUtils.deleteDirectory(mOutputDir);
        } catch (IOException e) {
            e.printStackTrace();
        }
        runOnUiThread(() -> {
            finish(""Image generation complete!"", true);
        });
    }

    private void finish(String reason, boolean success) {
        mFinishSuccess = success;
        mFinishReason = reason;

        finish();
    }

    @Override
    public void finish() {
        mLatch.countDown();

        super.finish();
    }

    public File getOutputZip() {
        return mOutputZip;
    }

    public boolean waitForCompletion(long timeoutMillis) throws InterruptedException {
        return mLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.security.cts.PerfEventParanoidTest"	"testPerfEventRestricted"	"CtsSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/PerfEventParanoidTest.java"	""	"public void testPerfEventRestricted() throws DeviceNotAvailableException {
        assumeSecurityModelCompat();
        // Property set to ""1"" if init detected that the kernel has the perf_event_open SELinux
        // hooks, otherwise left unset.
        long lsmHookPropValue = mDevice.getIntProperty(PERF_EVENT_LSM_SYSPROP, 0);

        // Contents of the perf_event_paranoid sysctl procfs file.
        String paranoidCmd = ""cat "" + PERF_EVENT_PARANOID_PATH;
        String paranoidOut = mDevice.executeShellCommand(paranoidCmd);

        if (PropertyUtil.getFirstApiLevel(mDevice) >= ANDROID_R_API_LEVEL) {
            // On devices launching with Android R or above, the kernel must have the LSM hooks.
            if (lsmHookPropValue != 1) {
                fail(""\nDevices launching with Android R or above are required to have SELinux ""
                        + ""hooks for the perf_event_open(2) syscall.\n""
                        + ""Please apply the relevant patch for your kernel located here:\n""
                        + ""https://android-review.googlesource.com/q/hashtag:perf_event_lsm"");
            }
        } else {
            // Devices upgrading to Android R can have either the LSM hooks, or
            // default to perf_event_paranoid=3.
            if (lsmHookPropValue != 1 && !paranoidOut.equals(""3\n"")) {
                fail(""\nDevice required to have either:\n""
                        + "" (a) SELinux hooks for the perf_event_open(2) syscall\n""
                        + "" (b) /proc/sys/kernel/perf_event_paranoid=3\n""
                        + ""For (a), apply the relevant patch for your kernel located here:\n""
                        + ""https://android-review.googlesource.com/q/hashtag:perf_event_lsm\n""
                        + ""For (b), apply the relevant patch for your kernel located here:\n""
                        + ""https://android-review.googlesource.com/#/q/topic:CONFIG_SECURITY_PERF_EVENTS_RESTRICT\n""
                        + ""Device values: SELinux="" + lsmHookPropValue
                        + "", paranoid="" + paranoidOut);
            }
        }
    }

    private void assumeSecurityModelCompat() throws DeviceNotAvailableException {
        // This feature name check only applies to devices that first shipped with
        // SC or later.
        final int firstApiLevel = Math.min(PropertyUtil.getFirstApiLevel(mDevice),
                PropertyUtil.getVendorApiLevel(mDevice));
        if (firstApiLevel >= ANDROID_S_API_LEVEL) {
            assumeTrue(""Skipping test: FEATURE_SECURITY_MODEL_COMPATIBLE missing."",
                    getDevice().hasFeature(""feature:android.hardware.security.model.compatible""));
        }
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.HostAtomTests"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/HostAtomTests.java"	""	"public void test/*
 *.
 */
package android.cts.statsdatom.statsd;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;
import android.os.BatteryPluggedStateEnum;
import android.os.BatteryStatusEnum;
import android.os.StatsDataDumpProto;
import android.platform.test.annotations.RestrictedBuildTest;
import android.server.DeviceIdleModeEnum;
import android.view.DisplayStateEnum;
import android.telephony.NetworkTypeEnum;

import com.android.internal.os.StatsdConfigProto.StatsdConfig;
import com.android.os.AtomsProto.AppBreadcrumbReported;
import com.android.os.AtomsProto.Atom;
import com.android.os.AtomsProto.BatterySaverModeStateChanged;
import com.android.os.AtomsProto.BuildInformation;
import com.android.os.AtomsProto.ConnectivityStateChanged;
import com.android.os.AtomsProto.SimSlotState;
import com.android.os.AtomsProto.SupportedRadioAccessFamily;
import com.android.os.StatsLog.ConfigMetricsReportList;
import com.android.os.StatsLog.EventMetricData;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.log.LogUtil;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import com.google.common.collect.Range;
import com.google.protobuf.ByteString;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Statsd atom tests that are done via adb (hostside).
 */
public class HostAtomTests extends DeviceTestCase implements IBuildReceiver {

    private static final String TAG = ""Statsd.HostAtomTests"";

    private static final String DUMPSYS_STATS_CMD = ""dumpsys stats"";

    // Either file must exist to read kernel wake lock stats.
    private static final String WAKE_LOCK_FILE = ""/proc/wakelocks"";
    private static final String WAKE_SOURCES_FILE = ""/d/wakeup_sources"";

    private static final String FEATURE_AUTOMOTIVE = ""android.hardware.type.automotive"";
    private static final String FEATURE_WATCH = ""android.hardware.type.watch"";
    private static final String FEATURE_TWM = ""com.google.clockwork.hardware.traditional_watch_mode"";
    private static final String FEATURE_WIFI = ""android.hardware.wifi"";
    private static final String FEATURE_LEANBACK_ONLY = ""android.software.leanback_only"";

    private IBuildInfo mCtsBuild;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        DeviceUtils.turnBatteryStatsAutoResetOff(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        DeviceUtils.turnBatteryStatsAutoResetOn(getDevice());
        super.tearDown();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.HostAtomTests"	"testBatterySaverModeStateChangedAtom"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/HostAtomTests.java"	""	"public void testBatterySaverModeStateChangedAtom() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_TWM)) return;
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_AUTOMOTIVE)) return;
        // Setup, turn off battery saver.
        turnBatterySaverOff();
        DeviceUtils.flushBatteryStatsHandlers(getDevice());

        final int atomTag = Atom.BATTERY_SAVER_MODE_STATE_CHANGED_FIELD_NUMBER;

        Set<Integer> batterySaverOn = new HashSet<>(
                Arrays.asList(BatterySaverModeStateChanged.State.ON_VALUE));
        Set<Integer> batterySaverOff = new HashSet<>(
                Arrays.asList(BatterySaverModeStateChanged.State.OFF_VALUE));

        // Add state sets to the list in order.
        List<Set<Integer>> stateSet = Arrays.asList(batterySaverOn, batterySaverOff);

        ConfigUtils.uploadConfigForPushedAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag);

        // Trigger events in same order.
        turnBatterySaverOn();
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
        turnBatterySaverOff();
        DeviceUtils.flushBatteryStatsHandlers(getDevice());

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        // Assert that the events happened in the expected order.
        AtomTestUtils.assertStatesOccurred(stateSet, data, AtomTestUtils.WAIT_TIME_LONG,
                atom -> atom.getBatterySaverModeStateChanged().getState().getNumber());
    }

    @RestrictedBuildTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.HostAtomTests"	"testRemainingBatteryCapacity"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/HostAtomTests.java"	""	"public void testRemainingBatteryCapacity() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_WATCH)) return;
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_AUTOMOTIVE)) return;

        ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                Atom.REMAINING_BATTERY_CAPACITY_FIELD_NUMBER);

        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);

        List<Atom> data = ReportUtils.getGaugeMetricAtoms(getDevice());

        assertThat(data).isNotEmpty();
        Atom atom = data.get(0);
        assertThat(atom.getRemainingBatteryCapacity().hasChargeMicroAmpereHour()).isTrue();
        if (DeviceUtils.hasBattery(getDevice())) {
            assertThat(atom.getRemainingBatteryCapacity().getChargeMicroAmpereHour())
                    .isGreaterThan(0);
        }
    }

    @RestrictedBuildTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.net.vcn.cts.TestNetworkWrapper"	"VcnTestNetworkCallback"	"CtsVcnTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/TestNetworkWrapper.java"	""	"public void test/*
 *.
 */

package android.net.vcn.cts;

import static android.net.cts.util.CtsNetUtils.TestNetworkCallback;

import android.annotation.NonNull;
import android.content.Context;
import android.ipsec.ike.cts.IkeTunUtils;
import android.net.ConnectivityManager;
import android.net.IpPrefix;
import android.net.LinkAddress;
import android.net.LinkProperties;
import android.net.Network;
import android.net.NetworkAgent;
import android.net.NetworkAgentConfig;
import android.net.NetworkCapabilities;
import android.net.NetworkProvider;
import android.net.NetworkRequest;
import android.net.RouteInfo;
import android.net.TestNetworkInterface;
import android.net.TestNetworkManager;
import android.net.TestNetworkSpecifier;
import android.net.vcn.VcnManager;
import android.net.vcn.VcnManager.VcnNetworkPolicyChangeListener;
import android.net.vcn.VcnNetworkPolicyResult;
import android.os.Looper;
import android.os.ParcelFileDescriptor;
import android.util.CloseGuard;
import android.util.Log;

import com.android.net.module.util.NetworkStackConstants;

import java.net.Inet4Address;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InterfaceAddress;
import java.net.NetworkInterface;
import java.util.Arrays;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/** Utility class for cleanly creating and tearing down Test Networks. */
// TODO(b/188462344): compine with IKEv2's TestNetworkContext
public class TestNetworkWrapper implements AutoCloseable {
    private static final String TAG = TestNetworkWrapper.class.getSimpleName();
    private static final String NETWORK_AGENT_TAG = TestNetworkAgent.class.getSimpleName();
    private static final String POLICY_LISTENER_TAG =
            TestNetworkAgent.TestVcnNetworkPolicyChangeListener.class.getSimpleName();

    public static final int NETWORK_CB_TIMEOUT_MS = 5000;

    private static final int IP4_PREFIX_LEN = 32;
    private static final int IP6_PREFIX_LEN = 64;

    // This NetworkRequest is expected to only match with Test Networks. To do so, remove all
    // default Capabilities and specify TRANSPORT_TEST.
    private static final NetworkRequest TEST_NETWORK_REQUEST =
            new NetworkRequest.Builder()
                    .clearCapabilities()
                    .addTransportType(NetworkCapabilities.TRANSPORT_TEST)
                    .build();

    private static final String NETWORK_PROVIDER_NAME = ""TestNetworkProvider"";
    private static final int TEST_NETWORK_SCORE = 1; // Use a low, non-zero score.
    private static final Executor INLINE_EXECUTOR = Runnable::run;

    private final CloseGuard mCloseGuard = new CloseGuard();

    private final ConnectivityManager mConnectivityManager;
    private final VcnManager mVcnManager;
    private final TestNetworkManager mTestNetworkManager;

    private final TestNetworkAgent mTestNetworkAgent;

    public final VcnTestNetworkCallback vcnNetworkCallback;
    public final ParcelFileDescriptor tunFd;
    public final IkeTunUtils ikeTunUtils;
    public final Network tunNetwork;

    public TestNetworkWrapper(
            @NonNull Context context,
            int mtu,
            boolean isMetered,
            @NonNull Set<Integer> subIds,
            @NonNull InetAddress localAddress)
            throws Exception {
        mConnectivityManager = context.getSystemService(ConnectivityManager.class);
        mVcnManager = context.getSystemService(VcnManager.class);
        mTestNetworkManager = context.getSystemService(TestNetworkManager.class);

        try {
            final LinkAddress linkAddress =
                    new LinkAddress(
                            localAddress,
                            localAddress instanceof Inet4Address ? IP4_PREFIX_LEN : IP6_PREFIX_LEN);
            final TestNetworkInterface tni =
                    mTestNetworkManager.createTunInterface(Arrays.asList(linkAddress));
            tunFd = tni.getFileDescriptor();
            final String iface = tni.getInterfaceName();

            final NetworkRequest nr =
                    new NetworkRequest.Builder(TEST_NETWORK_REQUEST)
                            .setNetworkSpecifier(iface)
                            .build();
            vcnNetworkCallback = new VcnTestNetworkCallback();
            mConnectivityManager.requestNetwork(nr, vcnNetworkCallback);

            final NetworkCapabilities nc =
                    createNetworkCapabilitiesForIface(iface, isMetered, subIds);
            final LinkProperties lp = createLinkPropertiesForIface(iface, mtu);

            final VcnNetworkPolicyResult policy = mVcnManager.applyVcnNetworkPolicy(nc, lp);
            if (policy.isTeardownRequested()) {
                throw new IllegalStateException(""Restart requested in bringup"");
            }

            mTestNetworkAgent =
                    new TestNetworkAgent(
                            context, Looper.getMainLooper(), policy.getNetworkCapabilities(), lp);
            mTestNetworkAgent.register();
            mTestNetworkAgent.markConnected();

            tunNetwork = vcnNetworkCallback.waitForAvailable();
            ikeTunUtils = new IkeTunUtils(tunFd);
            mCloseGuard.open(TAG);
        } catch (Exception e) {
            Log.e(TAG, ""Failed to bring up TestNetworkWrapper"", e);
            close();
            throw e;
        }
    }

    private static NetworkCapabilities createNetworkCapabilitiesForIface(
            @NonNull String iface, boolean isMetered, Set<Integer> subIds) {
        NetworkCapabilities.Builder builder =
                NetworkCapabilities.Builder.withoutDefaultCapabilities()
                        .addTransportType(NetworkCapabilities.TRANSPORT_TEST)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_SUSPENDED)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_MMS)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_DUN)
                        .addCapability(NetworkCapabilities.NET_CAPABILITY_FOTA)
                        .setNetworkSpecifier(new TestNetworkSpecifier(iface))
                        .setSubscriptionIds(subIds);
        if (!isMetered) {
            builder.addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
        }
        return builder.build();
    }

    private static LinkProperties createLinkPropertiesForIface(@NonNull String iface, int mtu)
            throws Exception {
        final LinkProperties lp = new LinkProperties();
        lp.setInterfaceName(iface);
        lp.setMtu(mtu);

        // Find the currently assigned addresses, and add them to LinkProperties
        boolean allowIPv4 = false;
        boolean allowIPv6 = false;
        NetworkInterface netIntf = NetworkInterface.getByName(iface);
        Objects.requireNonNull(netIntf, ""No such network interface found: "" + netIntf);

        for (InterfaceAddress intfAddr : netIntf.getInterfaceAddresses()) {
            lp.addLinkAddress(
                    new LinkAddress(intfAddr.getAddress(), intfAddr.getNetworkPrefixLength()));

            if (intfAddr.getAddress() instanceof Inet6Address) {
                allowIPv6 |= !intfAddr.getAddress().isLinkLocalAddress();
            } else if (intfAddr.getAddress() instanceof Inet4Address) {
                allowIPv4 = true;
            }
        }

        // Add global routes (but as non-default, non-internet providing network). Use prefix
        // lengths of 0 to match all IP addresses.
        if (allowIPv4) {
            lp.addRoute(
                    new RouteInfo(
                            new IpPrefix(NetworkStackConstants.IPV4_ADDR_ANY, 0 /* prefixLength */),
                            null /* gateway */,
                            iface,
                            RouteInfo.RTN_UNICAST));
        }
        if (allowIPv6) {
            lp.addRoute(
                    new RouteInfo(
                            new IpPrefix(NetworkStackConstants.IPV6_ADDR_ANY, 0 /* prefixLength */),
                            null /* gateway */,
                            iface,
                            RouteInfo.RTN_UNICAST));
        }

        return lp;
    }

    @Override
    public void close() {
        mCloseGuard.close();

        if (vcnNetworkCallback != null) {
            try {
                mConnectivityManager.unregisterNetworkCallback(vcnNetworkCallback);
            } catch (Exception e) {
                Log.e(TAG, ""Failed to unregister Network CB"", e);
            }
        }

        if (mTestNetworkAgent != null) {
            synchronized (mTestNetworkAgent) {
                try {
                    mTestNetworkAgent.teardown();
                } catch (Exception e) {
                    Log.e(TAG, ""Failed to unregister TestNetworkAgent"", e);
                }
            }
        }

        if (tunNetwork != null) {
            try {
                mTestNetworkManager.teardownTestNetwork(tunNetwork);
            } catch (Exception e) {
                Log.e(TAG, ""Failed to tear down Test Network"", e);
            }
        }

        if (tunFd != null) {
            try {
                tunFd.close();
            } catch (Exception e) {
                Log.e(TAG, ""Failed to close Test Network FD"", e);
            }
        }
    }

    @Override
    public void finalize() {
        mCloseGuard.warnIfOpen();
        close();
    }

    /**
     * Test-only NetworkAgent to be used for instrumented TUN Networks.
     *
     * <p>TestNetworkAgent is NOT THREAD SAFE - all accesses should be synchronized.
     */
    private class TestNetworkAgent extends NetworkAgent {
        private final CloseGuard mCloseGuard = new CloseGuard();
        private final VcnNetworkPolicyChangeListener mPolicyListener =
                new TestVcnNetworkPolicyChangeListener();

        private final LinkProperties mLinkProperties;

        private NetworkCapabilities mNetworkCapabilities;

        private TestNetworkAgent(
                @NonNull Context context,
                @NonNull Looper looper,
                @NonNull NetworkCapabilities nc,
                @NonNull LinkProperties lp) {
            super(
                    context,
                    looper,
                    NETWORK_AGENT_TAG,
                    nc,
                    lp,
                    TEST_NETWORK_SCORE,
                    new NetworkAgentConfig.Builder().build(),
                    new NetworkProvider(context, looper, NETWORK_PROVIDER_NAME));

            mNetworkCapabilities = nc;
            mLinkProperties = lp;

            mVcnManager.addVcnNetworkPolicyChangeListener(INLINE_EXECUTOR, mPolicyListener);

            mCloseGuard.open(NETWORK_AGENT_TAG);
        }

        @Override
        public void finalize() {
            mCloseGuard.warnIfOpen();
            teardown();
        }

        @Override
        public void onNetworkUnwanted() {
            // Not guaranteed to be called from the same thread, so synchronize on this.
            synchronized (this) {
                teardown();
            }
        }

        private void teardown() {
            mCloseGuard.close();
            unregister();
            mVcnManager.removeVcnNetworkPolicyChangeListener(mPolicyListener);
        }

        private NetworkCapabilities getNetworkCapabilities() {
            return mNetworkCapabilities;
        }

        private void updateNetworkCapabilities(@NonNull NetworkCapabilities nc) {
            Objects.requireNonNull(nc, ""nc must be non-null"");

            mNetworkCapabilities = nc;
            sendNetworkCapabilities(mNetworkCapabilities);
        }

        private LinkProperties getLinkProperties() {
            return mLinkProperties;
        }

        private class TestVcnNetworkPolicyChangeListener implements VcnNetworkPolicyChangeListener {
            @Override
            public void onPolicyChanged() {
                synchronized (TestNetworkAgent.this) {
                    final VcnNetworkPolicyResult policy =
                            mVcnManager.applyVcnNetworkPolicy(
                                    mTestNetworkAgent.getNetworkCapabilities(),
                                    mTestNetworkAgent.getLinkProperties());
                    if (policy.isTeardownRequested()) {
                        Log.w(POLICY_LISTENER_TAG, ""network teardown requested on policy change"");
                        teardown();
                        return;
                    }

                    updateNetworkCapabilities(policy.getNetworkCapabilities());
                }
            }
        }
    }

    /** NetworkCallback to used for tracking test network events. */
    // TODO(b/187231331): remove once TestNetworkCallback supports tracking NetworkCapabilities
    public static class VcnTestNetworkCallback extends TestNetworkCallback {
        private final BlockingQueue<Network> mAvailableHistory = new LinkedBlockingQueue<>();
        private final BlockingQueue<Network> mLostHistory = new LinkedBlockingQueue<>();
        private final BlockingQueue<CapabilitiesChangedEvent> mCapabilitiesChangedHistory =
                new LinkedBlockingQueue<>();

        @Override
        public Network waitForAvailable() throws InterruptedException {
            return mAvailableHistory.poll(NETWORK_CB_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        }

        @Override
        public Network waitForLost() throws InterruptedException {
            return mLostHistory.poll(NETWORK_CB_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        }

        public CapabilitiesChangedEvent waitForOnCapabilitiesChanged() throws Exception {
            return waitForOnCapabilitiesChanged(NETWORK_CB_TIMEOUT_MS);
        }

        public CapabilitiesChangedEvent waitForOnCapabilitiesChanged(long timeoutMillis)
                throws Exception {
            return mCapabilitiesChangedHistory.poll(timeoutMillis, TimeUnit.MILLISECONDS);
        }

        @Override
        public void onAvailable(@NonNull Network network) {
            mAvailableHistory.offer(network);
        }

        @Override
        public void onLost(@NonNull Network network) {
            mLostHistory.offer(network);
        }

        @Override
        public void onCapabilitiesChanged(
                @NonNull Network network, @NonNull NetworkCapabilities nc) {
            mCapabilitiesChangedHistory.offer(new CapabilitiesChangedEvent(network, nc));
        }

        public class CapabilitiesChangedEvent {
            public final Network network;
            public final NetworkCapabilities networkCapabilities;

            public CapabilitiesChangedEvent(
                    @NonNull Network network, @NonNull NetworkCapabilities networkCapabilities) {
                this.network = network;
                this.networkCapabilities = networkCapabilities;
            }
        }
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.AtomTestCase"	"getReportList"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/AtomTestCase.java"	""	"public void test/*
 *.
 */
package android.cts.statsdatom.statsd;

import static android.cts.statsdatom.statsd.DeviceAtomTestCase.DEVICE_SIDE_TEST_APK;
import static android.cts.statsdatom.statsd.DeviceAtomTestCase.DEVICE_SIDE_TEST_PACKAGE;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.os.BatteryStatsProto;
import android.os.StatsDataDumpProto;
import android.service.battery.BatteryServiceDumpProto;
import android.service.batterystats.BatteryStatsServiceDumpProto;
import android.service.procstats.ProcessStatsServiceDumpProto;

import com.android.annotations.Nullable;
import com.android.internal.os.StatsdConfigProto.AtomMatcher;
import com.android.internal.os.StatsdConfigProto.EventMetric;
import com.android.internal.os.StatsdConfigProto.FieldFilter;
import com.android.internal.os.StatsdConfigProto.FieldMatcher;
import com.android.internal.os.StatsdConfigProto.FieldValueMatcher;
import com.android.internal.os.StatsdConfigProto.GaugeMetric;
import com.android.internal.os.StatsdConfigProto.Predicate;
import com.android.internal.os.StatsdConfigProto.SimpleAtomMatcher;
import com.android.internal.os.StatsdConfigProto.SimplePredicate;
import com.android.internal.os.StatsdConfigProto.StatsdConfig;
import com.android.internal.os.StatsdConfigProto.TimeUnit;
import com.android.os.AtomsProto.AppBreadcrumbReported;
import com.android.os.AtomsProto.Atom;
import com.android.os.AtomsProto.ProcessStatsPackageProto;
import com.android.os.AtomsProto.ProcessStatsProto;
import com.android.os.AtomsProto.ProcessStatsStateProto;
import com.android.os.StatsLog.ConfigMetricsReport;
import com.android.os.StatsLog.ConfigMetricsReportList;
import com.android.os.StatsLog.DurationMetricData;
import com.android.os.StatsLog.EventMetricData;
import com.android.os.StatsLog.GaugeBucketInfo;
import com.android.os.StatsLog.GaugeMetricData;
import com.android.os.StatsLog.CountMetricData;
import com.android.os.StatsLog.StatsLogReport;
import com.android.os.StatsLog.ValueMetricData;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil;
import com.android.tradefed.util.CommandResult;
import com.android.tradefed.util.CommandStatus;

import com.google.common.collect.Range;
import com.google.common.io.Files;
import com.google.protobuf.ByteString;

import perfetto.protos.PerfettoConfig.DataSourceConfig;
import perfetto.protos.PerfettoConfig.FtraceConfig;
import perfetto.protos.PerfettoConfig.TraceConfig;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Random;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Base class for testing Statsd atoms.
 * Validates reporting of statsd logging based on different events
 */
public class AtomTestCase extends BaseTestCase {

    /**
     * Run tests that are optional; they are not valid CTS tests per se, since not all devices can
     * be expected to pass them, but can be run, if desired, to ensure they work when appropriate.
     */
    public static final boolean OPTIONAL_TESTS_ENABLED = false;

    public static final String UPDATE_CONFIG_CMD = ""cmd stats config update"";
    public static final String DUMP_REPORT_CMD = ""cmd stats dump-report"";
    public static final String DUMP_BATTERY_CMD = ""dumpsys battery"";
    public static final String DUMP_BATTERYSTATS_CMD = ""dumpsys batterystats"";
    public static final String DUMPSYS_STATS_CMD = ""dumpsys stats"";
    public static final String DUMP_PROCSTATS_CMD = ""dumpsys procstats"";
    public static final String REMOVE_CONFIG_CMD = ""cmd stats config remove"";
    /** ID of the config, which evaluates to -1572883457. */
    public static final long CONFIG_ID = ""cts_config"".hashCode();

    public static final String FEATURE_AUDIO_OUTPUT = ""android.hardware.audio.output"";
    public static final String FEATURE_AUTOMOTIVE = ""android.hardware.type.automotive"";
    public static final String FEATURE_BLUETOOTH = ""android.hardware.bluetooth"";
    public static final String FEATURE_BLUETOOTH_LE = ""android.hardware.bluetooth_le"";
    public static final String FEATURE_CAMERA = ""android.hardware.camera"";
    public static final String FEATURE_CAMERA_FLASH = ""android.hardware.camera.flash"";
    public static final String FEATURE_CAMERA_FRONT = ""android.hardware.camera.front"";
    public static final String FEATURE_LOCATION_GPS = ""android.hardware.location.gps"";
    public static final String FEATURE_PC = ""android.hardware.type.pc"";
    public static final String FEATURE_PICTURE_IN_PICTURE = ""android.software.picture_in_picture"";
    public static final String FEATURE_TELEPHONY = ""android.hardware.telephony"";
    public static final String FEATURE_WATCH = ""android.hardware.type.watch"";
    public static final String FEATURE_WIFI = ""android.hardware.wifi"";

    // Telephony phone types
    public static final int PHONE_TYPE_GSM = 1;
    public static final int PHONE_TYPE_CDMA = 2;
    public static final int PHONE_TYPE_CDMA_LTE = 6;

    protected static final int WAIT_TIME_SHORT = 500;
    protected static final int WAIT_TIME_LONG = 2_000;

    protected static final long SCREEN_STATE_CHANGE_TIMEOUT = 4000;
    protected static final long SCREEN_STATE_POLLING_INTERVAL = 500;

    protected static final long NS_PER_SEC = (long) 1E+9;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        // Uninstall to clear the history in case it's still on the device.
        removeConfig(CONFIG_ID);
        getReportList(); // Clears data.
    }

    @Override
    protected void tearDown() throws Exception {
        removeConfig(CONFIG_ID);
        getDevice().uninstallPackage(DEVICE_SIDE_TEST_PACKAGE);
        super.tearDown();
    }

    /**
     * Determines whether logcat indicates that incidentd fired since the given device date.
     */
    protected boolean didIncidentdFireSince(String date) throws Exception {
        final String INCIDENTD_TAG = ""incidentd"";
        final String INCIDENTD_STARTED_STRING = ""reportIncident"";
        // TODO: Do something more robust than this in case of delayed logging.
        Thread.sleep(1000);
        String log = getLogcatSince(date, String.format(
                ""-s %s -e %s"", INCIDENTD_TAG, INCIDENTD_STARTED_STRING));
        return log.contains(INCIDENTD_STARTED_STRING);
    }

    protected boolean checkDeviceFor(String methodName) throws Exception {
        try {
            installPackage(DEVICE_SIDE_TEST_APK, true);
            runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".Checkers"", methodName);
            // Test passes, meaning that the answer is true.
            LogUtil.CLog.d(methodName + ""() indicates true."");
            return true;
        } catch (AssertionError e) {
            // Method is designed to fail if the answer is false.
            LogUtil.CLog.d(methodName + ""() indicates false."");
            return false;
        }
    }

    /**
     * Returns a protobuf-encoded perfetto config that enables the kernel
     * ftrace tracer with sched_switch for 10 seconds.
     */
    protected ByteString getPerfettoConfig() {
        TraceConfig.Builder builder = TraceConfig.newBuilder();

        TraceConfig.BufferConfig buffer = TraceConfig.BufferConfig
            .newBuilder()
            .setSizeKb(128)
            .build();
        builder.addBuffers(buffer);

        FtraceConfig ftraceConfig = FtraceConfig.newBuilder()
            .addFtraceEvents(""sched/sched_switch"")
            .build();
        DataSourceConfig dataSourceConfig = DataSourceConfig.newBuilder()
            .setName(""linux.ftrace"")
            .setTargetBuffer(0)
            .setFtraceConfig(ftraceConfig)
            .build();
        TraceConfig.DataSource dataSource = TraceConfig.DataSource
            .newBuilder()
            .setConfig(dataSourceConfig)
            .build();
        builder.addDataSources(dataSource);

        builder.setDurationMs(10000);
        builder.setAllowUserBuildTracing(true);

        // To avoid being hit with guardrails firing in multiple test runs back
        // to back, we set a unique session key for each config.
        Random random = new Random();
        StringBuilder sessionNameBuilder = new StringBuilder(""statsd-cts-"");
        sessionNameBuilder.append(random.nextInt() & Integer.MAX_VALUE);
        builder.setUniqueSessionName(sessionNameBuilder.toString());

        return builder.build().toByteString();
    }

    /**
     * Resets the state of the Perfetto guardrails. This avoids that the test fails if it's
     * run too close of for too many times and hits the upload limit.
     */
    protected void resetPerfettoGuardrails() throws Exception {
        final String cmd = ""perfetto --reset-guardrails"";
        CommandResult cr = getDevice().executeShellV2Command(cmd);
        if (cr.getStatus() != CommandStatus.SUCCESS)
            throw new Exception(String.format(""Error while executing %s: %s %s"", cmd, cr.getStdout(), cr.getStderr()));
    }

    private String probe(String path) throws Exception {
        return getDevice().executeShellCommand(""if [ -e "" + path + "" ] ; then""
                + "" cat "" + path + "" ; else echo -1 ; fi"");
    }

    /**
     * Determines whether perfetto enabled the kernel ftrace tracer.
     */
    protected boolean isSystemTracingEnabled() throws Exception {
        final String traceFsPath = ""/sys/kernel/tracing/tracing_on"";
        String tracing_on = probe(traceFsPath);
        if (tracing_on.startsWith(""0"")) return false;
        if (tracing_on.startsWith(""1"")) return true;

        // fallback to debugfs
        LogUtil.CLog.d(""Unexpected state for %s = %s. Falling back to debugfs"", traceFsPath,
                tracing_on);

        final String debugFsPath = ""/sys/kernel/debug/tracing/tracing_on"";
        tracing_on = probe(debugFsPath);
        if (tracing_on.startsWith(""0"")) return false;
        if (tracing_on.startsWith(""1"")) return true;
        throw new Exception(String.format(""Unexpected state for %s = %s"", traceFsPath, tracing_on));
    }

    protected static StatsdConfig.Builder createConfigBuilder() {
      return StatsdConfig.newBuilder()
          .setId(CONFIG_ID)
          .addAllowedLogSource(""AID_SYSTEM"")
          .addAllowedLogSource(""AID_BLUETOOTH"")
          // TODO(b/134091167): Fix bluetooth source name issue in Auto platform.
          .addAllowedLogSource(""com.android.bluetooth"")
          .addAllowedLogSource(""AID_LMKD"")
          .addAllowedLogSource(""AID_RADIO"")
          .addAllowedLogSource(""AID_ROOT"")
          .addAllowedLogSource(""AID_STATSD"")
          .addAllowedLogSource(""com.android.systemui"")
          .addAllowedLogSource(DeviceAtomTestCase.DEVICE_SIDE_TEST_PACKAGE)
          .addDefaultPullPackages(""AID_RADIO"")
          .addDefaultPullPackages(""AID_SYSTEM"")
          .addWhitelistedAtomIds(Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER);
    }

    protected void createAndUploadConfig(int atomTag) throws Exception {
        StatsdConfig.Builder conf = createConfigBuilder();
        addAtomEvent(conf, atomTag);
        uploadConfig(conf);
    }

    protected void uploadConfig(StatsdConfig.Builder config) throws Exception {
        uploadConfig(config.build());
    }

    protected void uploadConfig(StatsdConfig config) throws Exception {
        LogUtil.CLog.d(""Uploading the following config:\n"" + config.toString());
        File configFile = File.createTempFile(""statsdconfig"", "".config"");
        configFile.deleteOnExit();
        Files.write(config.toByteArray(), configFile);
        String remotePath = ""/data/local/tmp/"" + configFile.getName();
        getDevice().pushFile(configFile, remotePath);
        getDevice().executeShellCommand(
                String.join("" "", ""cat"", remotePath, ""|"", UPDATE_CONFIG_CMD,
                        String.valueOf(CONFIG_ID)));
        getDevice().executeShellCommand(""rm "" + remotePath);
    }

    protected void removeConfig(long configId) throws Exception {
        getDevice().executeShellCommand(
                String.join("" "", REMOVE_CONFIG_CMD, String.valueOf(configId)));
    }

    /** Gets the statsd report and sorts it. Note that this also deletes that report from statsd. */
    protected List<EventMetricData> getEventMetricDataList() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        return getEventMetricDataList(reportList);
    }

    /**
     *  Gets a List of sorted ConfigMetricsReports from ConfigMetricsReportList.
     */
    protected List<ConfigMetricsReport> getSortedConfigMetricsReports(
            ConfigMetricsReportList configMetricsReportList) {
        return configMetricsReportList.getReportsList().stream()
                .sorted(Comparator.comparing(ConfigMetricsReport::getCurrentReportWallClockNanos))
                .collect(Collectors.toList());
    }

    /**
     * Extracts and sorts the EventMetricData from the given ConfigMetricsReportList (which must
     * contain a single report).
     */
    protected List<EventMetricData> getEventMetricDataList(ConfigMetricsReportList reportList)
            throws Exception {
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        ConfigMetricsReport report = reportList.getReports(0);

        List<EventMetricData> data = new ArrayList<>();
        for (StatsLogReport metric : report.getMetricsList()) {
            data.addAll(metric.getEventMetrics().getDataList());
        }
        data.sort(Comparator.comparing(EventMetricData::getElapsedTimestampNanos));

        LogUtil.CLog.d(""Get EventMetricDataList as following:\n"");
        for (EventMetricData d : data) {
            LogUtil.CLog.d(""Atom at "" + d.getElapsedTimestampNanos() + "":\n"" + d.getAtom().toString());
        }
        return data;
    }

    protected List<Atom> getGaugeMetricDataList() throws Exception {
        return getGaugeMetricDataList(/*checkTimestampTruncated=*/false);
    }

    protected List<Atom> getGaugeMetricDataList(boolean checkTimestampTruncated) throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);

        // only config
        ConfigMetricsReport report = reportList.getReports(0);
        assertThat(report.getMetricsCount()).isEqualTo(1);

        List<Atom> data = new ArrayList<>();
        for (GaugeMetricData gaugeMetricData :
                report.getMetrics(0).getGaugeMetrics().getDataList()) {
            assertThat(gaugeMetricData.getBucketInfoCount()).isEqualTo(1);
            GaugeBucketInfo bucketInfo = gaugeMetricData.getBucketInfo(0);
            for (Atom atom : bucketInfo.getAtomList()) {
                data.add(atom);
            }
            if (checkTimestampTruncated) {
                for (long timestampNs: bucketInfo.getElapsedTimestampNanosList()) {
                    assertTimestampIsTruncated(timestampNs);
                }
            }
        }

        LogUtil.CLog.d(""Get GaugeMetricDataList as following:\n"");
        for (Atom d : data) {
            LogUtil.CLog.d(""Atom:\n"" + d.toString());
        }
        return data;
    }

    /**
     * Gets the statsd report and extract duration metric data.
     * Note that this also deletes that report from statsd.
     */
    protected List<DurationMetricData> getDurationMetricDataList() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        ConfigMetricsReport report = reportList.getReports(0);

        List<DurationMetricData> data = new ArrayList<>();
        for (StatsLogReport metric : report.getMetricsList()) {
            data.addAll(metric.getDurationMetrics().getDataList());
        }

        LogUtil.CLog.d(""Got DurationMetricDataList as following:\n"");
        for (DurationMetricData d : data) {
            LogUtil.CLog.d(""Duration "" + d);
        }
        return data;
    }

    /**
     * Gets the statsd report and extract count metric data.
     * Note that this also deletes that report from statsd.
     */
    protected List<CountMetricData> getCountMetricDataList() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        ConfigMetricsReport report = reportList.getReports(0);

        List<CountMetricData> data = new ArrayList<>();
        for (StatsLogReport metric : report.getMetricsList()) {
            data.addAll(metric.getCountMetrics().getDataList());
        }

        LogUtil.CLog.d(""Got CountMetricDataList as following:\n"");
        for (CountMetricData d : data) {
            LogUtil.CLog.d(""Count "" + d);
        }
        return data;
    }

    /**
     * Gets the statsd report and extract value metric data.
     * Note that this also deletes that report from statsd.
     */
    protected List<ValueMetricData> getValueMetricDataList() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        ConfigMetricsReport report = reportList.getReports(0);

        List<ValueMetricData> data = new ArrayList<>();
        for (StatsLogReport metric : report.getMetricsList()) {
            data.addAll(metric.getValueMetrics().getDataList());
        }

        LogUtil.CLog.d(""Got ValueMetricDataList as following:\n"");
        for (ValueMetricData d : data) {
            LogUtil.CLog.d(""Value "" + d);
        }
        return data;
    }

    protected StatsLogReport getStatsLogReport() throws Exception {
        ConfigMetricsReport report = getConfigMetricsReport();
        assertThat(report.hasUidMap()).isTrue();
        assertThat(report.getMetricsCount()).isEqualTo(1);
        return report.getMetrics(0);
    }

    protected ConfigMetricsReport getConfigMetricsReport() throws Exception {
        ConfigMetricsReportList reportList = getReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        return reportList.getReports(0);
    }

    /** Gets the statsd report. Note that this also deletes that report from statsd. */
    protected ConfigMetricsReportList getReportList() throws Exception {
        try {
            ConfigMetricsReportList reportList = getDump(ConfigMetricsReportList.parser(),
                    String.join("" "", DUMP_REPORT_CMD, String.valueOf(CONFIG_ID),
                            ""--include_current_bucket"", ""--proto""));
            return reportList;
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to fetch and parse the statsd output report. ""
                    + ""Perhaps there is not a valid statsd config for the requested ""
                    + ""uid="" + getHostUid() + "", id="" + CONFIG_ID + ""."");
            throw (e);
        }
    }

    protected BatteryStatsProto getBatteryStatsProto() throws Exception {
        try {
            BatteryStatsProto batteryStatsProto = getDump(BatteryStatsServiceDumpProto.parser(),
                    String.join("" "", DUMP_BATTERYSTATS_CMD,
                            ""--proto"")).getBatterystats();
            LogUtil.CLog.d(""Got batterystats:\n "" + batteryStatsProto.toString());
            return batteryStatsProto;
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump batterystats proto"");
            throw (e);
        }
    }

    protected List<ProcessStatsProto> getProcStatsProto() throws Exception {
        try {

            List<ProcessStatsProto> processStatsProtoList =
                new ArrayList<ProcessStatsProto>();
            android.service.procstats.ProcessStatsSectionProto sectionProto = getDump(
                    ProcessStatsServiceDumpProto.parser(),
                    String.join("" "", DUMP_PROCSTATS_CMD,
                            ""--proto"")).getProcstatsNow();
            for (android.service.procstats.ProcessStatsProto stats :
                    sectionProto.getProcessStatsList()) {
                ProcessStatsProto procStats = ProcessStatsProto.parser().parseFrom(
                    stats.toByteArray());
                processStatsProtoList.add(procStats);
            }
            LogUtil.CLog.d(""Got procstats:\n "");
            for (ProcessStatsProto processStatsProto : processStatsProtoList) {
                LogUtil.CLog.d(processStatsProto.toString());
            }
            return processStatsProtoList;
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump procstats proto"");
            throw (e);
        }
    }

    /*
     * Get all procstats package data in proto
     */
    protected List<ProcessStatsPackageProto> getAllProcStatsProto() throws Exception {
        try {
            android.service.procstats.ProcessStatsSectionProto sectionProto = getDump(
                    ProcessStatsServiceDumpProto.parser(),
                    String.join("" "", DUMP_PROCSTATS_CMD,
                            ""--proto"")).getProcstatsOver24Hrs();
            List<ProcessStatsPackageProto> processStatsProtoList =
                new ArrayList<ProcessStatsPackageProto>();
            for (android.service.procstats.ProcessStatsPackageProto pkgStast :
                sectionProto.getPackageStatsList()) {
              ProcessStatsPackageProto pkgAtom =
                  ProcessStatsPackageProto.parser().parseFrom(pkgStast.toByteArray());
                processStatsProtoList.add(pkgAtom);
            }
            LogUtil.CLog.d(""Got procstats:\n "");
            for (ProcessStatsPackageProto processStatsProto : processStatsProtoList) {
                LogUtil.CLog.d(processStatsProto.toString());
            }
            return processStatsProtoList;
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump procstats proto"");
            throw (e);
        }
    }

    /*
     * Get all processes' procstats statsd data in proto
     */
    protected List<android.service.procstats.ProcessStatsProto> getAllProcStatsProtoForStatsd()
            throws Exception {
        try {
            android.service.procstats.ProcessStatsSectionProto sectionProto = getDump(
                    android.service.procstats.ProcessStatsSectionProto.parser(),
                    String.join("" "", DUMP_PROCSTATS_CMD,
                            ""--statsd""));
            List<android.service.procstats.ProcessStatsProto> processStatsProtoList
                    = sectionProto.getProcessStatsList();
            LogUtil.CLog.d(""Got procstats:\n "");
            for (android.service.procstats.ProcessStatsProto processStatsProto
                    : processStatsProtoList) {
                LogUtil.CLog.d(processStatsProto.toString());
            }
            return processStatsProtoList;
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump procstats proto"");
            throw (e);
        }
    }

    protected boolean hasBattery() throws Exception {
        try {
            BatteryServiceDumpProto batteryProto = getDump(BatteryServiceDumpProto.parser(),
                    String.join("" "", DUMP_BATTERY_CMD, ""--proto""));
            LogUtil.CLog.d(""Got battery service dump:\n "" + batteryProto.toString());
            return batteryProto.getIsPresent();
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            LogUtil.CLog.e(""Failed to dump batteryservice proto"");
            throw (e);
        }
    }

    /** Creates a FieldValueMatcher.Builder corresponding to the given field. */
    protected static FieldValueMatcher.Builder createFvm(int field) {
        return FieldValueMatcher.newBuilder().setField(field);
    }

    protected void addAtomEvent(StatsdConfig.Builder conf, int atomTag) throws Exception {
        addAtomEvent(conf, atomTag, new ArrayList<FieldValueMatcher.Builder>());
    }

    /**
     * Adds an event to the config for an atom that matches the given key.
     *
     * @param conf    configuration
     * @param atomTag atom tag (from atoms.proto)
     * @param fvm     FieldValueMatcher.Builder for the relevant key
     */
    protected void addAtomEvent(StatsdConfig.Builder conf, int atomTag,
            FieldValueMatcher.Builder fvm)
            throws Exception {
        addAtomEvent(conf, atomTag, Arrays.asList(fvm));
    }

    /**
     * Adds an event to the config for an atom that matches the given keys.
     *
     * @param conf   configuration
     * @param atomId atom tag (from atoms.proto)
     * @param fvms   list of FieldValueMatcher.Builders to attach to the atom. May be null.
     */
    protected void addAtomEvent(StatsdConfig.Builder conf, int atomId,
            List<FieldValueMatcher.Builder> fvms) throws Exception {

        final String atomName = ""Atom"" + System.nanoTime();
        final String eventName = ""Event"" + System.nanoTime();

        SimpleAtomMatcher.Builder sam = SimpleAtomMatcher.newBuilder().setAtomId(atomId);
        if (fvms != null) {
            for (FieldValueMatcher.Builder fvm : fvms) {
                sam.addFieldValueMatcher(fvm);
            }
        }
        conf.addAtomMatcher(AtomMatcher.newBuilder()
                .setId(atomName.hashCode())
                .setSimpleAtomMatcher(sam));
        conf.addEventMetric(EventMetric.newBuilder()
                .setId(eventName.hashCode())
                .setWhat(atomName.hashCode()));
    }

    /**
     * Adds an atom to a gauge metric of a config
     *
     * @param conf        configuration
     * @param atomId      atom id (from atoms.proto)
     * @param gaugeMetric the gauge metric to add
     */
    protected void addGaugeAtom(StatsdConfig.Builder conf, int atomId,
            GaugeMetric.Builder gaugeMetric) throws Exception {
        final String atomName = ""Atom"" + System.nanoTime();
        final String gaugeName = ""Gauge"" + System.nanoTime();
        final String predicateName = ""APP_BREADCRUMB"";
        SimpleAtomMatcher.Builder sam = SimpleAtomMatcher.newBuilder().setAtomId(atomId);
        conf.addAtomMatcher(AtomMatcher.newBuilder()
                .setId(atomName.hashCode())
                .setSimpleAtomMatcher(sam));
        final String predicateTrueName = ""APP_BREADCRUMB_1"";
        final String predicateFalseName = ""APP_BREADCRUMB_2"";
        conf.addAtomMatcher(AtomMatcher.newBuilder()
                .setId(predicateTrueName.hashCode())
                .setSimpleAtomMatcher(SimpleAtomMatcher.newBuilder()
                        .setAtomId(Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER)
                        .addFieldValueMatcher(FieldValueMatcher.newBuilder()
                                .setField(AppBreadcrumbReported.LABEL_FIELD_NUMBER)
                                .setEqInt(1)
                        )
                )
        )
                // Used to trigger predicate
                .addAtomMatcher(AtomMatcher.newBuilder()
                        .setId(predicateFalseName.hashCode())
                        .setSimpleAtomMatcher(SimpleAtomMatcher.newBuilder()
                                .setAtomId(Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER)
                                .addFieldValueMatcher(FieldValueMatcher.newBuilder()
                                        .setField(AppBreadcrumbReported.LABEL_FIELD_NUMBER)
                                        .setEqInt(2)
                                )
                        )
                );
        conf.addPredicate(Predicate.newBuilder()
                .setId(predicateName.hashCode())
                .setSimplePredicate(SimplePredicate.newBuilder()
                        .setStart(predicateTrueName.hashCode())
                        .setStop(predicateFalseName.hashCode())
                        .setCountNesting(false)
                )
        );
        gaugeMetric
                .setId(gaugeName.hashCode())
                .setWhat(atomName.hashCode())
                .setCondition(predicateName.hashCode());
        conf.addGaugeMetric(gaugeMetric.build());
    }

    /**
     * Adds an atom to a gauge metric of a config
     *
     * @param conf      configuration
     * @param atomId    atom id (from atoms.proto)
     * @param dimension dimension is needed for most pulled atoms
     */
    protected void addGaugeAtomWithDimensions(StatsdConfig.Builder conf, int atomId,
            @Nullable FieldMatcher.Builder dimension) throws Exception {
        GaugeMetric.Builder gaugeMetric = GaugeMetric.newBuilder()
                .setGaugeFieldsFilter(FieldFilter.newBuilder().setIncludeAll(true).build())
                .setSamplingType(GaugeMetric.SamplingType.CONDITION_CHANGE_TO_TRUE)
                .setMaxNumGaugeAtomsPerBucket(10000)
                .setBucket(TimeUnit.CTS);
        if (dimension != null) {
            gaugeMetric.setDimensionsInWhat(dimension.build());
        }
        addGaugeAtom(conf, atomId, gaugeMetric);
    }

    /**
     * Asserts that each set of states in stateSets occurs at least once in data.
     * Asserts that the states in data occur in the same order as the sets in stateSets.
     *
     * @param stateSets        A list of set of states, where each set represents an equivalent
     *                         state of the device for the purpose of CTS.
     * @param data             list of EventMetricData from statsd, produced by
     *                         getReportMetricListData()
     * @param wait             expected duration (in ms) between state changes; asserts that the
     *                         actual wait
     *                         time was wait/2 <= actual_wait <= 5*wait. Use 0 to ignore this
     *                         assertion.
     * @param getStateFromAtom expression that takes in an Atom and returns the state it contains
     */
    public void assertStatesOccurred(List<Set<Integer>> stateSets, List<EventMetricData> data,
            int wait, Function<Atom, Integer> getStateFromAtom) {
        // Sometimes, there are more events than there are states.
        // Eg: When the screen turns off, it may go into OFF and then DOZE immediately.
        assertWithMessage(""Too few states found"").that(data.size()).isAtLeast(stateSets.size());
        int stateSetIndex = 0; // Tracks which state set we expect the data to be in.
        for (int dataIndex = 0; dataIndex < data.size(); dataIndex++) {
            Atom atom = data.get(dataIndex).getAtom();
            int state = getStateFromAtom.apply(atom);
            // If state is in the current state set, we do not assert anything.
            // If it is not, we expect to have transitioned to the next state set.
            if (stateSets.get(stateSetIndex).contains(state)) {
                // No need to assert anything. Just log it.
                LogUtil.CLog.i(""The following atom at dataIndex="" + dataIndex + "" is ""
                        + ""in stateSetIndex "" + stateSetIndex + "":\n""
                        + data.get(dataIndex).getAtom().toString());
            } else {
                stateSetIndex += 1;
                LogUtil.CLog.i(""Assert that the following atom at dataIndex="" + dataIndex + "" is""
                        + "" in stateSetIndex "" + stateSetIndex + "":\n""
                        + data.get(dataIndex).getAtom().toString());
                assertWithMessage(""Missed first state"").that(dataIndex).isNotEqualTo(0);
                assertWithMessage(""Too many states"").that(stateSetIndex)
                    .isLessThan(stateSets.size());
                assertWithMessage(String.format(""Is in wrong state (%d)"", state))
                    .that(stateSets.get(stateSetIndex)).contains(state);
                if (wait > 0) {
                    assertTimeDiffBetween(data.get(dataIndex - 1), data.get(dataIndex),
                            wait / 2, wait * 5);
                }
            }
        }
        assertWithMessage(""Too few states"").that(stateSetIndex).isEqualTo(stateSets.size() - 1);
    }

    /**
     * Removes all elements from data prior to the first occurrence of an element of state. After
     * this method is called, the first element of data (if non-empty) is guaranteed to be an
     * element in state.
     *
     * @param getStateFromAtom expression that takes in an Atom and returns the state it contains
     */
    public void popUntilFind(List<EventMetricData> data, Set<Integer> state,
            Function<Atom, Integer> getStateFromAtom) {
        int firstStateIdx;
        for (firstStateIdx = 0; firstStateIdx < data.size(); firstStateIdx++) {
            Atom atom = data.get(firstStateIdx).getAtom();
            if (state.contains(getStateFromAtom.apply(atom))) {
                break;
            }
        }
        if (firstStateIdx == 0) {
            // First first element already is in state, so there's nothing to do.
            return;
        }
        data.subList(0, firstStateIdx).clear();
    }

    /**
     * Removes all elements from data after to the last occurrence of an element of state. After
     * this method is called, the last element of data (if non-empty) is guaranteed to be an
     * element in state.
     *
     * @param getStateFromAtom expression that takes in an Atom and returns the state it contains
     */
    public void popUntilFindFromEnd(List<EventMetricData> data, Set<Integer> state,
        Function<Atom, Integer> getStateFromAtom) {
        int lastStateIdx;
        for (lastStateIdx = data.size() - 1; lastStateIdx >= 0; lastStateIdx--) {
            Atom atom = data.get(lastStateIdx).getAtom();
            if (state.contains(getStateFromAtom.apply(atom))) {
                break;
            }
        }
        if (lastStateIdx == data.size()-1) {
            // Last element already is in state, so there's nothing to do.
            return;
        }
        data.subList(lastStateIdx+1, data.size()).clear();
    }

    /** Returns the UID of the host, which should always either be SHELL (2000) or ROOT (0). */
    protected int getHostUid() throws DeviceNotAvailableException {
        String strUid = """";
        try {
            strUid = getDevice().executeShellCommand(""id -u"");
            return Integer.parseInt(strUid.trim());
        } catch (NumberFormatException e) {
            LogUtil.CLog.e(""Failed to get host's uid via shell command. Found "" + strUid);
            // Fall back to alternative method...
            if (getDevice().isAdbRoot()) {
                return 0; // ROOT
            } else {
                return 2000; // SHELL
            }
        }
    }

    protected String getProperty(String prop) throws Exception {
        return getDevice().executeShellCommand(""getprop "" + prop).replace(""\n"", """");
    }

    protected void turnScreenOn() throws Exception {
        getDevice().executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        getDevice().executeShellCommand(""wm dismiss-keyguard"");
    }

    protected void turnScreenOff() throws Exception {
        getDevice().executeShellCommand(""input keyevent KEYCODE_SLEEP"");
    }

    protected void setChargingState(int state) throws Exception {
        getDevice().executeShellCommand(""cmd battery set status "" + state);
    }

    protected void unplugDevice() throws Exception {
        // On batteryless devices on Android P or above, the 'unplug' command
        // alone does not simulate the really unplugged state.
        //
        // This is because charging state is left as ""unknown"". Unless a valid
        // state like 3 = BatteryManager.BATTERY_STATUS_DISCHARGING is set,
        // framework does not consider the device as running on battery.
        setChargingState(3);

        getDevice().executeShellCommand(""cmd battery unplug"");
    }

    protected void plugInAc() throws Exception {
        getDevice().executeShellCommand(""cmd battery set ac 1"");
    }

    protected void enableLooperStats() throws Exception {
        getDevice().executeShellCommand(""cmd looper_stats enable"");
    }

    protected void resetLooperStats() throws Exception {
        getDevice().executeShellCommand(""cmd looper_stats reset"");
    }

    protected void disableLooperStats() throws Exception {
        getDevice().executeShellCommand(""cmd looper_stats disable"");
    }

    protected void enableBinderStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --enable"");
    }

    protected void resetBinderStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --reset"");
    }

    protected void disableBinderStats() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --disable"");
    }

    protected void binderStatsNoSampling() throws Exception {
        getDevice().executeShellCommand(""dumpsys binder_calls_stats --no-sampling"");
    }

    public void setAppBreadcrumbPredicate() throws Exception {
        doAppBreadcrumbReportedStart(1);
    }

    public void clearAppBreadcrumbPredicate() throws Exception {
        doAppBreadcrumbReportedStart(2);
    }

    public void doAppBreadcrumbReportedStart(int label) throws Exception {
        doAppBreadcrumbReported(label, AppBreadcrumbReported.State.START.ordinal());
    }

    public void doAppBreadcrumbReportedStop(int label) throws Exception {
        doAppBreadcrumbReported(label, AppBreadcrumbReported.State.STOP.ordinal());
    }

    public void doAppBreadcrumbReported(int label) throws Exception {
        doAppBreadcrumbReported(label, AppBreadcrumbReported.State.UNSPECIFIED.ordinal());
    }

    public void doAppBreadcrumbReported(int label, int state) throws Exception {
        getDevice().executeShellCommand(String.format(
                ""cmd stats log-app-breadcrumb %d %d"", label, state));
    }

    protected void rebootDevice() throws Exception {
        getDevice().rebootUntilOnline();
    }

    /**
     * Asserts that the two events are within the specified range of each other.
     *
     * @param d0        the event that should occur first
     * @param d1        the event that should occur second
     * @param minDiffMs d0 should precede d1 by at least this amount
     * @param maxDiffMs d0 should precede d1 by at most this amount
     */
    public static void assertTimeDiffBetween(EventMetricData d0, EventMetricData d1,
            int minDiffMs, int maxDiffMs) {
        long diffMs = (d1.getElapsedTimestampNanos() - d0.getElapsedTimestampNanos()) / 1_000_000;
        assertWithMessage(""Illegal time difference"")
            .that(diffMs).isIn(Range.closed((long) minDiffMs, (long) maxDiffMs));
    }

    protected String getCurrentLogcatDate() throws Exception {
        // TODO: Do something more robust than this for getting logcat markers.
        long timestampMs = getDevice().getDeviceDate();
        return new SimpleDateFormat(""MM-dd HH:mm:ss.SSS"")
                .format(new Date(timestampMs));
    }

    protected String getLogcatSince(String date, String logcatParams) throws Exception {
        return getDevice().executeShellCommand(String.format(
                ""logcat -v threadtime -t '%s' -d %s"", date, logcatParams));
    }

    // TODO: Remove this and migrate all usages to createConfigBuilder()
    protected StatsdConfig.Builder getPulledConfig() {
        return createConfigBuilder();
    }
    /**
     * Determines if the device has the given feature.
     * Prints a warning if its value differs from requiredAnswer.
     */
    protected boolean hasFeature(String featureName, boolean requiredAnswer) throws Exception {
        final String features = getDevice().executeShellCommand(""pm list features"");
        StringTokenizer featureToken = new StringTokenizer(features, ""\n"");
        boolean hasIt = false;

        while (featureToken.hasMoreTokens()) {
            if ((""feature:"" + featureName).equals(featureToken.nextToken())) {
                 hasIt = true;
                 break;
            }
        }

        if (hasIt != requiredAnswer) {
            LogUtil.CLog.w(""Device does "" + (requiredAnswer ? ""not "" : """") + ""have feature ""
                    + featureName);
        }
        return hasIt == requiredAnswer;
    }

    // Checks that a timestamp has been truncated to be a multiple of 5 min
    protected void assertTimestampIsTruncated(long timestampNs) {
        long fiveMinutesInNs = NS_PER_SEC * 5 * 60;
        assertWithMessage(""Timestamp is not truncated"")
                .that(timestampNs % fiveMinutesInNs).isEqualTo(0);
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testBgRestrictedForegroundService"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	"public void testBgRestrictedForegroundService() throws Exception {
        final Intent activityIntent = new Intent()
                .setClassName(SIMPLE_PACKAGE_NAME,
                        SIMPLE_PACKAGE_NAME + SIMPLE_ACTIVITY_START_FG_SERVICE)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        final ServiceProcessController controller = new ServiceProcessController(mContext,
                mInstrumentation, STUB_PACKAGE_NAME, mAllProcesses, WAIT_TIME);
        final WatchUidRunner uidWatcher = controller.getUidWatcher();

        final Intent homeIntent = new Intent()
                .setAction(Intent.ACTION_MAIN)
                .addCategory(Intent.CATEGORY_HOME)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                        | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);

        final Intent serviceStartIntent = new Intent(mService3Intent)
                .setAction(ACTION_START_THEN_FG);
        activityIntent.putExtra(""service"", serviceStartIntent);
        boolean activityStarted = false;

        try {
            // First kill the process to start out in a stable state.
            controller.ensureProcessGone();

            // Do initial setup.
            controller.denyAnyInBackgroundOp();
            controller.makeUidIdle();
            controller.removeFromWhitelist();
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""allow"");

            // Start the activity, which will start the fg service as well, and wait
            // for the report that it's all up and running.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_SIMPLE_ACTIVITY_START_FG_SERVICE_RESULT);

            activityIntent.setAction(ACTION_SIMPLE_ACTIVITY_START_FG);
            mTargetContext.startActivity(activityIntent);
            activityStarted = true;

            Intent resultIntent = waiter.doWait(WAIT_TIME);
            int brCode = resultIntent.getIntExtra(""result"", Activity.RESULT_CANCELED);
            if (brCode != Activity.RESULT_FIRST_USER) {
                fail(""Failed starting service, result="" + brCode);
            }

            // activity is in front, fg service is running.  make sure that we see
            // the expected state at this point.
            uidWatcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP);

            // Switch to the home app; make sure the test app drops all the way
            // down to SERVICE, not FG_SERVICE
            mTargetContext.startActivity(homeIntent);
            uidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_SERVICE);
        } finally {
            // tear down everything and we're done
            if (activityStarted) {
                activityIntent.setAction(ACTION_FINISH_EVERYTHING);
                mTargetContext.startActivity(activityIntent);
            }

            controller.cleanup();
        }

    }

    private boolean supportsCantSaveState() {
        if (mContext.getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_CANT_SAVE_STATE)) {
            return true;
        }

        return false;
    }

    /**
     * Test that a single ""can't save state"" app has the proper process management semantics.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testDefaultAllRestrictedPermissionsWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testDefaultAllRestrictedPermissionsWhitelistedAtInstall29() throws Exception {
        // Install with no changes to whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/,
                Collections.EMPTY_SET /*grantedPermissions*/);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testSomeRestrictedPermissionsWhitelistedAtInstall29() throws Exception {
        // Whitelist only these permissions.
        final Set<String> whitelistedPermissions = new ArraySet<>(2);
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with some whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(whitelistedPermissions,
                Collections.EMPTY_SET /*grantedPermissions*/);

        // Some restricted permission should be whitelisted.
        assertRestrictedPermissionWhitelisted(whitelistedPermissions);

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testNoneRestrictedPermissionWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testNoneRestrictedPermissionWhitelistedAtInstall29() throws Exception {
        // Install with all whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(Collections.emptySet(),
                Collections.EMPTY_SET /*grantedPermissions*/);

        // No restricted permission should be whitelisted.
        assertNoRestrictedPermissionWhitelisted();

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testDefaultAllRestrictedPermissionsWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void testDefaultAllRestrictedPermissionsWhitelistedAtInstall22() throws Exception {
        // Install with no changes to whitelisted permissions
        runShellCommand(""pm install -g --force-queryable "" + APK_USES_SMS_CALL_LOG_22);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void testSomeRestrictedPermissionsWhitelistedAtInstall22() throws Exception {
        // Whitelist only these permissions.
        final Set<String> whitelistedPermissions = new ArraySet<>(2);
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with some whitelisted permissions
        installApp(APK_USES_SMS_CALL_LOG_22, whitelistedPermissions, null /*grantedPermissions*/);

        // Some restricted permission should be whitelisted.
        assertRestrictedPermissionWhitelisted(whitelistedPermissions);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testNoneRestrictedPermissionWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testNoneRestrictedPermissionWhitelistedAtInstall22() throws Exception {
        // Install with all whitelisted permissions
        installApp(APK_USES_SMS_CALL_LOG_22, Collections.emptySet(),
                null /*grantedPermissions*/);

        // No restricted permission should be whitelisted.
        assertNoRestrictedPermissionWhitelisted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionWhitelistedAtInstall29() throws Exception {
        installApp(APK_USES_LOCATION_29, null, new ArraySet<>(Arrays.asList(ACCESS_FINE_LOCATION,
                ACCESS_BACKGROUND_LOCATION)));
        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionNotWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionNotWhitelistedAtInstall29() throws Exception {
        installApp(APK_USES_LOCATION_29, Collections.emptySet(),
                Collections.singleton(ACCESS_FINE_LOCATION));
        assertNoRestrictedPermissionWhitelisted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionWhitelistedAtInstall22() throws Exception {
        installApp(APK_USES_LOCATION_22, null, new ArraySet<>(Arrays.asList(ACCESS_FINE_LOCATION,
                ACCESS_BACKGROUND_LOCATION)));
        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionNotWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionNotWhitelistedAtInstall22() throws Exception {
        installApp(APK_USES_LOCATION_22, Collections.emptySet(),
                Collections.singleton(ACCESS_FINE_LOCATION));
        assertNoRestrictedPermissionWhitelisted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsGrantedAtInstall"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void testSomeRestrictedPermissionsGrantedAtInstall() throws Exception {
        // Grant only these permissions.
        final Set<String> grantedPermissions = new ArraySet<>(1);
        grantedPermissions.add(Manifest.permission.SEND_SMS);
        grantedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with no whitelisted permissions attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/, grantedPermissions);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // Some restricted permission should be granted.
        assertRestrictedPermissionGranted(grantedPermissions);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testCanGrantSoftRestrictedNotWhitelistedPermissions"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testCanGrantSoftRestrictedNotWhitelistedPermissions() throws Exception {
        try {
            final Set<String> grantedPermissions = new ArraySet<>();
            grantedPermissions.add(Manifest.permission.READ_EXTERNAL_STORAGE);
            grantedPermissions.add(permission.WRITE_EXTERNAL_STORAGE);

            installApp(APK_USES_STORAGE_DEFAULT_29, Collections.emptySet(), grantedPermissions);

            assertRestrictedPermissionGranted(grantedPermissions);
        } finally {
            uninstallApp();
        }
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testAllRestrictedPermissionsGrantedAtInstall"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void testAllRestrictedPermissionsGrantedAtInstall() throws Exception {
        // Install with whitelisted permissions attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/,
                null);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // Some restricted permission should be granted.
        assertAllRestrictedPermissionGranted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testWhitelistAccessControl"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testWhitelistAccessControl() throws Exception {
        // Install with no whitelisted permissions not attempting to grant.
        installRestrictedPermissionUserApp(Collections.emptySet(), null);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadRestrictedPermissionsWhitelistingDefault"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void onSideLoadRestrictedPermissionsWhitelistingDefault() throws Exception {
        installRestrictedPermissionUserApp(new SessionParams(SessionParams.MODE_FULL_INSTALL));

        // All restricted permissions whitelisted on side-load by default
        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadAllRestrictedPermissionsWhitelisted"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void onSideLoadAllRestrictedPermissionsWhitelisted() throws Exception {
        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(SessionParams.RESTRICTED_PERMISSIONS_ALL);

        installRestrictedPermissionUserApp(params);

        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadWhitelistSomePermissions"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void onSideLoadWhitelistSomePermissions() throws Exception {
        Set<String> whitelistedPermissions = new ArraySet<>();
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(whitelistedPermissions);

        installRestrictedPermissionUserApp(params);

        assertRestrictedPermissionWhitelisted(whitelistedPermissions);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadWhitelistNoPermissions"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void onSideLoadWhitelistNoPermissions() throws Exception {
        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(Collections.emptySet());

        installRestrictedPermissionUserApp(params);

        assertNoRestrictedPermissionWhitelisted();
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"isTrue"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void shareUidBetweenRestrictedAndNotRestrictedApp() throws Exception {
        runShellCommand(
                ""pm install -g --force-queryable --restrict-permissions ""
                + APK_USES_SMS_RESTRICTED_SHARED_UID);
        runShellCommand(""pm install -g --force-queryable ""
                + APK_USES_SMS_NOT_RESTRICTED_SHARED_UID);

        eventually(
                () -> assertThat(isGranted(PKG_USES_SMS_RESTRICTED_SHARED_UID, READ_SMS)).isTrue());
        // The apps share a UID, hence the whitelisting is shared too
        assertThat(isGranted(PKG_USES_SMS_NOT_RESTRICTED_SHARED_UID, READ_SMS)).isTrue();
    }

    private static void installRestrictedPermissionUserApp(@NonNull SessionParams params)
            throws Exception {
        final CountDownLatch installLatch = new CountDownLatch(1);

        // Create an install result receiver.
        final BroadcastReceiver installReceiver = new BroadcastReceiver() {
            public void onReceive(Context context, Intent intent) {
                if (intent.getIntExtra(PackageInstaller.EXTRA_STATUS,
                        PackageInstaller.STATUS_FAILURE_INVALID)
                            == PackageInstaller.STATUS_SUCCESS) {
                    installLatch.countDown();
                }
            }
        };

        // Register the result receiver.
        final String action = ""android.permission2.cts.ACTION_INSTALL_COMMIT"";
        final IntentFilter intentFilter = new IntentFilter(action);
        getContext().registerReceiver(installReceiver, intentFilter);

        try {
            // Create a session.
            final PackageInstaller packageInstaller = getContext()
                    .getPackageManager().getPackageInstaller();
            final int sessionId = packageInstaller.createSession(params);
            final Session session = packageInstaller.openSession(sessionId);

            // Write the apk.
            try (
                    InputStream in = new BufferedInputStream(new FileInputStream(
                        new File(APK_USES_SMS_CALL_LOG_29)));
                    OutputStream out = session.openWrite(
                            APK_NAME_USES_SMS_CALL_LOG_29, 0, -1);
            ) {
                final byte[] buf = new byte[8192];
                int size;
                while ((size = in.read(buf)) != -1) {
                    out.write(buf, 0, size);
                }
            }

            final Intent intent = new Intent(action);
            final IntentSender intentSender = PendingIntent.getBroadcast(getContext(),
                    1, intent, PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE)
                    .getIntentSender();

            // Commit as shell to avoid confirm UI
            runWithShellPermissionIdentity(() -> {
                session.commit(intentSender);
                installLatch.await(UI_TIMEOUT, TimeUnit.MILLISECONDS);
            });
        } finally {
            getContext().unregisterReceiver(installReceiver);
        }
    }

    private void assertWeCannotReadOrWriteWhileShellCanReadAndWrite(int whitelist)
            throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        try {
            packageManager.getWhitelistedRestrictedPermissions(PKG, whitelist);
            fail();
        } catch (SecurityException expected) {
            /*ignore*/
        }
        try {
            packageManager.addWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            fail();
        } catch (SecurityException expected) {
            /*ignore*/
        }
        runWithShellPermissionIdentity(() -> {
            packageManager.addWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    whitelist)).contains(permission.SEND_SMS);
            packageManager.removeWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    whitelist)).doesNotContain(permission.SEND_SMS);
        });
    }

    private @NonNull Set<String> getPermissionsOfAppWithAnyOfFlags(int flags) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final Set<String> restrictedPermissions = new ArraySet<>();
        for (String permission : getRequestedPermissionsOfApp()) {
            PermissionInfo permInfo = packageManager.getPermissionInfo(permission, 0);

            if ((permInfo.flags & flags) != 0) {
                restrictedPermissions.add(permission);
            }
        }
        return restrictedPermissions;
    }

    private @NonNull Set<String> getRestrictedPermissionsOfApp() throws Exception {
        return getPermissionsOfAppWithAnyOfFlags(
                PermissionInfo.FLAG_HARD_RESTRICTED | PermissionInfo.FLAG_SOFT_RESTRICTED);
    }

    private @NonNull String[] getRequestedPermissionsOfApp() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(PKG,
                PackageManager.GET_PERMISSIONS);
        return packageInfo.requestedPermissions;
    }

    private void assertAllRestrictedPermissionWhitelisted() throws Exception {
        assertRestrictedPermissionWhitelisted(getRestrictedPermissionsOfApp());
    }

    private void assertNoRestrictedPermissionWhitelisted() throws Exception {
        assertRestrictedPermissionWhitelisted(
                Collections.EMPTY_SET /*expectedWhitelistedPermissions*/);
    }

    /**
     * Assert that the passed in restrictions are whitelisted and that their app-op is set
     * correctly.
     *
     * @param expectedWhitelistedPermissions The expected white listed permissions
     */
    private void assertRestrictedPermissionWhitelisted(
            @NonNull Set<String> expectedWhitelistedPermissions) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        eventually(() -> runWithShellPermissionIdentity(() -> {
            final AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final PackageInfo packageInfo = packageManager.getPackageInfo(PKG,
                    PackageManager.GET_PERMISSIONS);

            final Set<String> whitelistedPermissions = packageManager
                .getWhitelistedRestrictedPermissions(PKG,
                        PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                        | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER
                        | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE);

            assertThat(whitelistedPermissions).isNotNull();
            assertWithMessage(""Whitelisted permissions"").that(whitelistedPermissions)
                    .containsExactlyElementsIn(expectedWhitelistedPermissions);

            // Also assert that apps ops are properly set
            for (String permission : getRestrictedPermissionsOfApp()) {
                String op = AppOpsManager.permissionToOp(permission);
                ArraySet<Integer> possibleModes = new ArraySet<>();

                if (permission.equals(Manifest.permission.ACCESS_BACKGROUND_LOCATION)) {
                    op = AppOpsManager.OPSTR_FINE_LOCATION;

                    // If permission is denied app-op might be allowed/fg or ignored. It does
                    // not matter. If permission is granted, it has to be allowed/fg.
                    if (isPermissionGranted(PKG, Manifest.permission.ACCESS_FINE_LOCATION)) {
                        if (expectedWhitelistedPermissions.contains(permission)
                                && isPermissionGranted(PKG, permission)) {
                            possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        } else {
                            possibleModes.add(AppOpsManager.MODE_FOREGROUND);
                        }
                    } else {
                        possibleModes.add(AppOpsManager.MODE_IGNORED);
                        possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        possibleModes.add(AppOpsManager.MODE_FOREGROUND);
                    }
                } else {
                    if (expectedWhitelistedPermissions.contains(permission)) {
                        // If permission is denied app-op might be allowed or ignored. It does not
                        // matter. If permission is granted, it has to be allowed.
                        possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        if (!isPermissionGranted(PKG, permission)) {
                            possibleModes.add(AppOpsManager.MODE_IGNORED);
                        }
                    } else {
                        possibleModes.add(AppOpsManager.MODE_IGNORED);
                    }
                }

                assertWithMessage(op).that(appOpsManager.unsafeCheckOpRawNoThrow(op,
                        packageInfo.applicationInfo.uid, PKG)).isIn(possibleModes);
            }
        }));
    }

    private void assertAllRestrictedPermissionGranted() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(
                PKG, PackageManager.GET_PERMISSIONS);
        if (packageInfo.requestedPermissions != null) {
            final int permissionCount = packageInfo.requestedPermissions.length;
            for (int i = 0; i < permissionCount; i++) {
                final String permission = packageInfo.requestedPermissions[i];
                final PermissionInfo permissionInfo = packageManager.getPermissionInfo(
                        permission, 0);
                if ((permissionInfo.flags & PermissionInfo.FLAG_HARD_RESTRICTED) != 0) {
                    assertThat((packageInfo.requestedPermissionsFlags[i]
                            & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isNotEqualTo(0);
                }
            }
        }
    }

    private void assertNoRestrictedPermissionGranted() throws Exception {
        assertRestrictedPermissionGranted(Collections.EMPTY_SET);
    }

    private void assertRestrictedPermissionGranted(@NonNull Set<String> expectedGrantedPermissions)
            throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(
                PKG, PackageManager.GET_PERMISSIONS);
        if (packageInfo.requestedPermissions != null) {
            final int permissionCount = packageInfo.requestedPermissions.length;
            for (int i = 0; i < permissionCount; i++) {
                final String permission = packageInfo.requestedPermissions[i];
                final PermissionInfo permissionInfo = packageManager.getPermissionInfo(
                        permission, 0);
                if ((permissionInfo.flags & PermissionInfo.FLAG_HARD_RESTRICTED) != 0
                        || (permissionInfo.flags & PermissionInfo.FLAG_SOFT_RESTRICTED) != 0) {
                    if (expectedGrantedPermissions.contains(permission)) {
                        assertThat((packageInfo.requestedPermissionsFlags[i]
                                & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isNotEqualTo(0);
                    } else {
                        assertThat((packageInfo.requestedPermissionsFlags[i]
                                & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isEqualTo(0);
                    }
                }
            }
        }
    }

    /**
     * Install {@link #APK_USES_SMS_CALL_LOG_29}.
     *
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installRestrictedPermissionUserApp(@Nullable Set<String> whitelistedPermissions,
            @Nullable Set<String> grantedPermissions) throws Exception {
        installApp(APK_USES_SMS_CALL_LOG_29, whitelistedPermissions, grantedPermissions);
    }

    /**
     * Install app and grant all permission.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     */
    private void installApp(@NonNull String app, @Nullable Set<String> whitelistedPermissions)
            throws Exception {
        installApp(app, whitelistedPermissions, null /*grantedPermissions*/);
    }

    /**
     * Install an app.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installApp(@NonNull String app, @Nullable Set<String> whitelistedPermissions,
            @Nullable Set<String> grantedPermissions) throws Exception {
        // Install the app and whitelist/grant all permission if requested.
        String installResult = runShellCommand(""pm install -r --force-queryable ""
                + ""--restrict-permissions "" + app);
        assertThat(installResult.trim()).isEqualTo(""Success"");

        final Set<String> adjustedWhitelistedPermissions;
        if (whitelistedPermissions == null) {
            adjustedWhitelistedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedWhitelistedPermissions = whitelistedPermissions;
        }

        final Set<String> adjustedGrantedPermissions;
        if (grantedPermissions == null) {
            adjustedGrantedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedGrantedPermissions = grantedPermissions;
        }

        // Whitelist subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedWhitelistedPermissions) {
                packageManager.addWhitelistedRestrictedPermission(PKG, permission,
                        PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            }
        });

        // Grant subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedGrantedPermissions) {
                packageManager.grantRuntimePermission(PKG, permission,
                        getContext().getUser());
                packageManager.updatePermissionFlags(permission, PKG,
                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, 0, getContext().getUser());
            }
        });

        // Mark all permissions as reviewed as for pre-22 apps the restriction state might not be
        // applied until reviewed
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : getRequestedPermissionsOfApp()) {
                packageManager.updatePermissionFlags(permission, PKG,
                        PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED, 0,
                        getContext().getUser());
            }
        });
    }

    @After
    public void uninstallApp() {
        runShellCommand(""pm uninstall "" + PKG);
        runShellCommand(""pm uninstall "" + PKG_USES_SMS_NOT_RESTRICTED_SHARED_UID);
        runShellCommand(""pm uninstall "" + PKG_USES_SMS_RESTRICTED_SHARED_UID);
    }

    private static @NonNull Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static void runWithShellPermissionIdentity(@NonNull ThrowingRunnable command)
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity();
        try {
            command.run();
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.server.wm.MultiDisplaySecurityTests"	"testLaunchWithoutPermissionOnVirtualDisplayByOwner"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	"public void testLaunchWithoutPermissionOnVirtualDisplayByOwner() {
        // Create new virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();

        separateTestJournal();

        // Try to launch an activity and check if security exception was triggered.
        getLaunchActivityBuilder()
                .setUseBroadcastReceiver(LAUNCH_BROADCAST_RECEIVER, LAUNCH_BROADCAST_ACTION)
                .setDisplayId(newDisplay.mId)
                .setTargetActivity(TEST_ACTIVITY)
                .execute();
        assertSecurityExceptionFromActivityLauncher();
        mWmState.computeState(TEST_ACTIVITY);
        assertFalse(""Restricted activity must not be launched"",
                mWmState.containsActivity(TEST_ACTIVITY));
    }

    /**
     * Tests launching an activity on a virtual display without special permission must not be
     * allowed.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.server.wm.MultiDisplaySecurityTests"	"testLaunchWithoutPermissionOnVirtualDisplay"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	"public void testLaunchWithoutPermissionOnVirtualDisplay() {
        // Create new virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();

        separateTestJournal();

        // Try to launch an activity and check it security exception was triggered.
        getLaunchActivityBuilder()
                .setUseBroadcastReceiver(SECOND_LAUNCH_BROADCAST_RECEIVER,
                        SECOND_LAUNCH_BROADCAST_ACTION)
                .setDisplayId(newDisplay.mId)
                .setTargetActivity(TEST_ACTIVITY)
                .execute();
        assertSecurityExceptionFromActivityLauncher();
        mWmState.computeState(TEST_ACTIVITY);
        assertFalse(""Restricted activity must not be launched"",
                mWmState.containsActivity(TEST_ACTIVITY));
    }

    /**
     * Tests launching an activity on virtual display and then launching another activity that
     * doesn't allow embedding - it should fail with security exception.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.content.pm.cts.ResourcesHardeningTest"	"isEmpty"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ResourcesHardeningTest.java"	""	"/*
 *.
 */

package android.content.pm.cts;

import static android.content.pm.cts.PackageManagerShellCommandIncrementalTest.checkIncrementalDeliveryFeature;
import static android.content.pm.cts.PackageManagerShellCommandIncrementalTest.isAppInstalled;
import static android.content.pm.cts.PackageManagerShellCommandIncrementalTest.uninstallPackageSilently;

import static org.hamcrest.core.IsInstanceOf.instanceOf;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import android.app.ActivityManager;
import android.app.UiAutomation;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.platform.test.annotations.AppModeFull;
import android.util.ArrayMap;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.LargeTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.MatcherUtils;
import com.android.incfs.install.IBlockFilter;
import com.android.incfs.install.IncrementalInstallSession;
import com.android.incfs.install.PendingBlock;

import com.example.helloworld.lib.TestUtils;

import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipFile;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

@RunWith(AndroidJUnit4.class)
@AppModeFull
@LargeTest
public class ResourcesHardeningTest {
    private static final String TEST_APK_PATH = ""/data/local/tmp/cts/content/"";
    private static final String[] TEST_APKS = {
            ""HelloWorldResHardening.apk"",
            ""HelloWorldResHardening_mdpi-v4.apk"",
            ""HelloWorldResHardening_hdpi-v4.apk""
    };

    private static final String RES_TABLE_PATH = ""resources.arsc"";
    private static final int INCFS_BLOCK_SIZE = 4096;

    private final Map<String, List<RestrictedBlockRange>> mRestrictedRanges = new ArrayMap<>();

    @Before
    public void onBefore() throws Exception {
        checkIncrementalDeliveryFeature();

        // Set up the blocks that need to be restricted in order to test resource hardening.
        if (!mRestrictedRanges.isEmpty()) {
            return;
        }
        for (final String apk : TEST_APKS) {
            try (ZipFile zip = new ZipFile(TEST_APK_PATH + apk)) {
                final List<RestrictedBlockRange> infos = new ArrayList<>();
                RestrictedBlockRange info;
                info = restrictZipEntry(zip, RES_TABLE_PATH);
                if (info != null) {
                    infos.add(info);
                }
                // Restrict only the middle block of the compiled xml to test that the whole
                // file needs to be present just to open the xml file.
                info = restrictOnlyMiddleBlock(restrictZipEntry(zip, TestUtils.RES_XML_PATH));
                if (info != null) {
                    infos.add(info);
                }
                // Restrict only the middle block of this file to test that the whole file does
                // NOT need to be present just to create an input stream or fd.
                info = restrictOnlyMiddleBlock(
                        restrictZipEntry(zip, TestUtils.RES_DRAWABLE_MDPI_PATH));
                if (info != null) {
                    infos.add(info);
                }
                // Test that FileNotFoundExceptions are thrown when the file is missing.
                info = restrictZipEntry(zip, TestUtils.RES_DRAWABLE_HDPI_PATH);
                if (info != null) {
                    infos.add(info);
                }
                assertFalse(infos.isEmpty());
                mRestrictedRanges.put(apk, infos);
            }
        }
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.content.pm.cts.ResourcesHardeningTest"	"TestBlockFilter"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ResourcesHardeningTest.java"	""	"public void checkOpenFdRemote() throws Exception {
        // Failing to read missing blocks through a file descriptor using read/pread causes an
        // IOException to be thrown.
        testIncrementalOwnPackageResources(TestUtils.TEST_OPEN_FILE_FD, false /* expectCrash */);
    }

    private interface TestFunction {
        void apply(Resources res, TestUtils.AssertionType type) throws Exception;
    }

    /**
     * Installs a package incrementally and tests that retrieval of that package's resources from
     * within this process does not crash this process and instead falls back to some default
     * behavior.
     */
    private void testIncrementalForeignPackageResources(TestFunction test) throws Exception {
        try (ShellInstallSession session = startInstallSession()) {
            test.apply(session.getPackageResources(), TestUtils.AssertionType.ASSERT_SUCCESS);
        }
        try (ShellInstallSession session = startInstallSession()) {
            session.enableBlockRestrictions();
            test.apply(session.getPackageResources(), TestUtils.AssertionType.ASSERT_READ_FAILURE);
        }
    }

    /**
     * Installs a package incrementally and tests that the package crashes when it fails to retrieve
     * its own resources due to incremental installation.
     */
    private void testIncrementalOwnPackageResources(String testName, boolean expectCrash)
            throws Exception {
        try (RemoteTest session = new RemoteTest(startInstallSession(), testName)) {
            session.mSession.getPackageResources();
            session.start(true /* assertSuccess */);
        }

        try (RemoteTest session = new RemoteTest(startInstallSession(), testName)) {
            session.mSession.getPackageResources();
            session.mSession.enableBlockRestrictions();
            if (expectCrash) {
                MatcherUtils.assertThrows(instanceOf(RemoteProcessCrashedException.class),
                        () -> session.start(false /* assertSuccess */));
            } else {
                session.start(false /* assertSuccess */);
            }
        }
    }

    private void testIncrementalOwnPackageResources(String testName) throws Exception {
        testIncrementalOwnPackageResources(testName, true /* expectCrash */);
    }

    private static class RemoteProcessCrashedException extends RuntimeException {
    }

    private static class RemoteTest implements AutoCloseable {
        private static final int SPIN_SLEEP_MS = 500;
        private static final long RESPONSE_TIMEOUT_MS = 60 * 1000;

        private final ShellInstallSession mSession;
        private final String mTestName;

        RemoteTest(ShellInstallSession session, String testName) {
            mSession = session;
            mTestName = testName;
        }

        public void start(boolean assertSuccess) throws Exception {
            final AtomicInteger pid = new AtomicInteger();
            final IntentFilter statusFilter = new IntentFilter(TestUtils.TEST_STATUS_ACTION);

            final TestUtils.BroadcastDetector pidDetector = new TestUtils.BroadcastDetector(
                    getContext(), statusFilter, (Context context, Intent intent) -> {
                if (intent.hasExtra(TestUtils.PID_STATUS_PID_KEY)) {
                    pid.set(intent.getIntExtra(TestUtils.PID_STATUS_PID_KEY, -1));
                    return true;
                }
                return false;
            });

            final TestUtils.BroadcastDetector finishDetector = new TestUtils.BroadcastDetector(
                    getContext(), statusFilter, (Context context, Intent intent) -> {
                if (intent.hasExtra(TestUtils.TEST_STATUS_RESULT_KEY)) {
                    final String reason = intent.getStringExtra(TestUtils.TEST_STATUS_RESULT_KEY);
                    if (!reason.equals(TestUtils.TEST_STATUS_RESULT_SUCCESS)) {
                        throw new IllegalStateException(""Remote test failed: "" + reason);
                    }
                    return true;
                }
                return false;
            });

            // Start the test app and indicate which test to run.
            try (pidDetector; finishDetector) {
                final Intent launchIntent = new Intent(Intent.ACTION_VIEW);
                launchIntent.setClassName(TestUtils.TEST_APP_PACKAGE, TestUtils.TEST_ACTIVITY_NAME);
                launchIntent.putExtra(TestUtils.TEST_NAME_EXTRA_KEY, mTestName);
                launchIntent.putExtra(TestUtils.TEST_ASSERT_SUCCESS_EXTRA_KEY, assertSuccess);
                launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                        | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);

                getContext().startActivity(launchIntent);

                // The test app must respond with a broadcast containing its pid so this test can
                // check if the test app crashes.
                assertTrue(""Timed out while waiting for pid"",
                        pidDetector.waitForBroadcast(RESPONSE_TIMEOUT_MS, TimeUnit.MILLISECONDS));

                // Wait for the test app to finish testing or crash.
                final ActivityManager am = getActivityManager();
                final int remotePid = pid.get();
                for (int i = 0; i < (RESPONSE_TIMEOUT_MS / SPIN_SLEEP_MS); i++) {
                    if (am.getRunningAppProcesses().stream().noneMatch(
                            info -> info.pid == remotePid)) {
                        throw new RemoteProcessCrashedException();
                    }
                    if (finishDetector.waitForBroadcast(SPIN_SLEEP_MS, TimeUnit.MILLISECONDS)) {
                        return;
                    }
                }
                throw new TimeoutException(""Timed out while waiting for remote test to finish"");
            }
        }

        @Override
        public void close() throws Exception {
            mSession.close();
        }
    }

    private ShellInstallSession startInstallSession() throws IOException,
            InterruptedException {
        return startInstallSession(TEST_APKS, TestUtils.TEST_APP_PACKAGE);
    }

    private ShellInstallSession startInstallSession(String[] apks, String packageName)
            throws IOException, InterruptedException {
        final String v4SignatureSuffix = "".idsig"";
        final TestBlockFilter filter = new TestBlockFilter();
        final IncrementalInstallSession.Builder builder = new IncrementalInstallSession.Builder()
                .addExtraArgs(""-t"", ""-i"", getContext().getPackageName())
                .setLogger(new IncrementalDeviceConnection.Logger())
                .setBlockFilter(filter);
        for (final String apk : apks) {
            final String path = TEST_APK_PATH + apk;
            builder.addApk(Paths.get(path), Paths.get(path + v4SignatureSuffix));
        }

        final ShellInstallSession session = new ShellInstallSession(
                builder.build(), filter, packageName);
        session.session.start(Executors.newSingleThreadExecutor(),
                IncrementalDeviceConnection.Factory.reliable());
        session.session.waitForInstallCompleted(10, TimeUnit.SECONDS);
        assertTrue(isAppInstalled(packageName));
        return session;
    }

    /**
     * A wrapper for {@link IncrementalInstallSession} that uninstalls the installed package when
     * testing is finished.
     */
    private static class ShellInstallSession implements AutoCloseable {
        public final IncrementalInstallSession session;
        private final TestBlockFilter mFilter;
        private final String mPackageName;

        private ShellInstallSession(IncrementalInstallSession session,
                TestBlockFilter filter, String packageName) {
            this.session = session;
            this.mFilter = filter;
            this.mPackageName = packageName;
            getUiAutomation().adoptShellPermissionIdentity();
        }

        public void enableBlockRestrictions() {
            mFilter.enableBlockRestrictions();
        }

        public Resources getPackageResources() throws PackageManager.NameNotFoundException {
            return getContext().createPackageContext(mPackageName, 0).getResources();
        }

        @Override
        public void close() throws IOException {
            session.close();
            getUiAutomation().dropShellPermissionIdentity();
            uninstallPackageSilently(mPackageName);
        }
    }

    private class TestBlockFilter implements IBlockFilter {
        private final AtomicBoolean mRestrictBlocks = new AtomicBoolean(false);

        @Override
        public boolean shouldServeBlock(PendingBlock block) {
            if (!mRestrictBlocks.get() || block.getType() == PendingBlock.Type.SIGNATURE_TREE) {
                // Always send signature blocks and always send blocks when enableBlockRestrictions
                // has not been called.
                return true;
            }

            // Allow the block to be served if it does not reside in a restricted range.
            final String apkFileName = block.getPath().getFileName().toString();
            return mRestrictedRanges.get(apkFileName).stream().noneMatch(
                    info -> info.dataStartBlockIndex <= block.getBlockIndex()
                            && block.getBlockIndex() <= info.dataEndBlockIndex);
        }

        public void enableBlockRestrictions() {
            mRestrictBlocks.set(true);
        }
    }

    private static class RestrictedBlockRange {
        public final String entryName;
        public final int dataStartBlockIndex;
        public final int dataEndBlockIndex;

        RestrictedBlockRange(String zipEntryName, int dataStartBlockIndex,
                int dataEndBlockIndex) {
            this.entryName = zipEntryName;
            this.dataStartBlockIndex = dataStartBlockIndex;
            this.dataEndBlockIndex = dataEndBlockIndex;
        }
    }

    private static RestrictedBlockRange restrictZipEntry(ZipFile file, String entryFileName) {
        final ZipArchiveEntry info = file.getEntry(entryFileName);
        if (info == null) return null;
        final long headerSize = entryFileName.getBytes(StandardCharsets.UTF_8).length + 30;
        final int dataStartBlock = (int) (info.getDataOffset() - headerSize) / INCFS_BLOCK_SIZE;
        final int dataEndBlock = (int) (info.getDataOffset() + info.getCompressedSize())
                / INCFS_BLOCK_SIZE;
        return new RestrictedBlockRange(entryFileName, dataStartBlock, dataEndBlock);
    }

    private static RestrictedBlockRange restrictOnlyMiddleBlock(RestrictedBlockRange info) {
        if (info == null) return null;
        assertTrue(info.dataEndBlockIndex - info.dataStartBlockIndex > 2);
        final int middleBlock = (info.dataStartBlockIndex + info.dataEndBlockIndex) / 2;
        return new RestrictedBlockRange(info.entryName, middleBlock, middleBlock);
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static UiAutomation getUiAutomation() {
        return InstrumentationRegistry.getInstrumentation().getUiAutomation();
    }

    private static ActivityManager getActivityManager() {
        return (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.media.cts.MediaExtractorHostSideTest"	"testMediaMetricsLogSessionId"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/cts/MediaExtractorHostSideTest.java"	""	"public void testMediaMetricsLogSessionId() throws Exception {
        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, DEVICE_SIDE_TEST_CLASS, ""testLogSessionId"");
        assertThat(getMediaExtractorReportedLogSessionId()).isEqualTo(""FakeLogSessionId"");
    }

    // Internal methods.

    /** Removes any existing config with id {@link #CONFIG_ID}. */
    private void removeConfig() throws Exception {
        getDevice().executeShellCommand(""cmd stats config remove "" + CONFIG_ID);
    }

    /** Creates the statsd config and passes it to statsd. */
    private void createAndUploadConfig() throws Exception {
        StatsdConfig.Builder configBuilder =
                StatsdConfigProto.StatsdConfig.newBuilder()
                        .setId(CONFIG_ID)
                        .addAllowedLogSource(DEVICE_SIDE_TEST_PACKAGE)
                        .addWhitelistedAtomIds(
                                AtomsProto.Atom.MEDIAMETRICS_EXTRACTOR_REPORTED_FIELD_NUMBER);
        addAtomEvent(configBuilder);
        uploadConfig(configBuilder.build());
    }

    /** Writes the given config into a file and passes is to statsd via standard input. */
    private void uploadConfig(StatsdConfig config) throws Exception {
        File configFile = File.createTempFile(""statsdconfig"", "".config"");
        configFile.deleteOnExit();
        Files.write(config.toByteArray(), configFile);
        String remotePath = ""/data/local/tmp/"" + configFile.getName();
        // Make sure a config file with the same name doesn't exist already.
        getDevice().deleteFile(remotePath);
        assertThat(getDevice().pushFile(configFile, remotePath)).isTrue();
        getDevice()
                .executeShellCommand(
                        ""cat "" + remotePath + "" | cmd stats config update "" + CONFIG_ID);
        getDevice().deleteFile(remotePath);
    }

    /** Adds an event to the config in order to match MediaParser reported atoms. */
    private static void addAtomEvent(StatsdConfig.Builder config) {
        String atomName = ""Atom"" + System.nanoTime();
        String eventName = ""Event"" + System.nanoTime();
        SimpleAtomMatcher.Builder sam =
                SimpleAtomMatcher.newBuilder()
                        .setAtomId(AtomsProto.Atom.MEDIAMETRICS_EXTRACTOR_REPORTED_FIELD_NUMBER);
        config.addAtomMatcher(
                StatsdConfigProto.AtomMatcher.newBuilder()
                        .setId(atomName.hashCode())
                        .setSimpleAtomMatcher(sam));
        config.addEventMetric(
                StatsdConfigProto.EventMetric.newBuilder()
                        .setId(eventName.hashCode())
                        .setWhat(atomName.hashCode()));
    }

    /**
     * Returns all MediaParser reported metric events sorted by timestamp.
     *
     * <p>Note: Calls {@link #getAndClearReportList()} to obtain the statsd report.
     */
    private MediametricsMessage.ExtractorData.EntryPoint getMediaExtractorReportedEntryPoint()
            throws Exception {
        return getMediaExtractorReportedData().getEntryPoint();
    }

    /**
     * Asserts that a single log session id has been reported by MediaMetrics and returns it.
     *
     * <p>Note: Calls {@link #getAndClearReportList()} to obtain the statsd report.
     */
    private String getMediaExtractorReportedLogSessionId()
            throws Exception {
        return getMediaExtractorReportedData().getLogSessionId();
    }

    private MediametricsMessage.ExtractorData getMediaExtractorReportedData() throws Exception {
        ConfigMetricsReportList reportList = getAndClearReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        StatsLog.ConfigMetricsReport report = reportList.getReports(0);
        ArrayList<StatsLog.EventMetricData> data = new ArrayList<>();
        report.getMetricsList()
                .forEach(
                        statsLogReport ->
                                data.addAll(statsLogReport.getEventMetrics().getDataList()));
        List<AtomsProto.MediametricsExtractorReported> mediametricsExtractorReported =
                data.stream()
                        .map(element -> element.getAtom().getMediametricsExtractorReported())
                        .collect(Collectors.toList());
        // During device boot, services may extract media files. We ensure we only pick up metric
        // events from our device-side test.
        mediametricsExtractorReported.removeIf(
                entry -> !DEVICE_SIDE_TEST_PACKAGE.equals(entry.getPackageName()));
        assertThat(mediametricsExtractorReported).hasSize(1);
        return mediametricsExtractorReported.get(0).getExtractorData();
    }

    /** Gets a statsd report and removes it from the device. */
    private ConfigMetricsReportList getAndClearReportList() throws Exception {
        CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();
        getDevice()
                .executeShellCommand(
                        ""cmd stats dump-report "" + CONFIG_ID + "" --include_current_bucket --proto"",
                        receiver);
        return ConfigMetricsReportList.parser().parseFrom(receiver.getOutput());
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.display.cts.DisplayTest"	"testRestrictedFramebufferSize"	"CtsDisplayTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/DisplayTest.java"	""	"public void testRestrictedFramebufferSize() {
        PackageManager packageManager = mContext.getPackageManager();
        if (packageManager.hasSystemFeature(FEATURE_LEANBACK)) {
            // TV devices are allowed to restrict their framebuffer size.
            return;
        }

        // Non-TV devices are not allowed by Android CDD to restrict their framebuffer size.
        String width = SystemProperties.get(""ro.surface_flinger.max_graphics_width"");
        assertEquals("""", width);
        String height = SystemProperties.get(""ro.surface_flinger.max_graphics_height"");
        assertEquals("""", height);
    }

    /**
     * Used to force mode changes on a display.
     * <p>
     * Note that due to limitations of the Presentation class, the modes must have the same size
     * otherwise the presentation will be automatically dismissed.
     */
    private static final class TestPresentation extends Presentation {

        private final int mModeId;

        public TestPresentation(Context context, Display display, int modeId) {
            super(context, display);
            mModeId = modeId;
        }

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            View content = new View(getContext());
            content.setLayoutParams(new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
            content.setBackgroundColor(Color.RED);
            setContentView(content);

            WindowManager.LayoutParams params = getWindow().getAttributes();
            params.preferredDisplayModeId = mModeId;
            params.setTitle(""CtsTestPresentation"");
            getWindow().setAttributes(params);
        }

        @Override
        public void cancel() {
            // Ignore attempts to force cancel the presentation. This is going to happen when we
            // change the mode of the display since doing so will change the display metrics, which
            // Presentations don't yet support. Ignoring it means the Presentation will stay up and
            // the mode will stay changed until dismiss is called, preventing a race condition
            // between the test checking the mode of the display and the mode changing back to the
            // default because the requesting Presentation is no longer showing.
        }
    }

    private Activity launchScreenOnActivity() {
        Class clazz = ScreenOnActivity.class;
        String targetPackage =
                InstrumentationRegistry.getInstrumentation().getContext().getPackageName();
        Instrumentation.ActivityResult result =
                new Instrumentation.ActivityResult(0, new Intent());
        Instrumentation.ActivityMonitor monitor =
                new Instrumentation.ActivityMonitor(clazz.getName(), result, false);
        InstrumentationRegistry.getInstrumentation().addMonitor(monitor);
        launchActivity(targetPackage, clazz, null);
        return monitor.waitForActivity();
    }

    private <T extends Activity> T launchActivity(ActivityTestRule<T> activityRule) {
        final T activity = activityRule.launchActivity(null);
        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
        return activity;
    }

    /**
     * Utility method for launching an activity. Copied from InstrumentationTestCase since
     * InstrumentationRegistry does not provide these APIs anymore.
     *
     * <p>The {@link Intent} used to launch the Activity is:
     *  action = {@link Intent#ACTION_MAIN}
     *  extras = null, unless a custom bundle is provided here
     * All other fields are null or empty.
     *
     * <p><b>NOTE:</b> The parameter <i>pkg</i> must refer to the package identifier of the
     * package hosting the activity to be launched, which is specified in the AndroidManifest.xml
     * file.  This is not necessarily the same as the java package name.
     *
     * @param pkg The package hosting the activity to be launched.
     * @param activityCls The activity class to launch.
     * @param extras Optional extra stuff to pass to the activity.
     * @return The activity, or null if non launched.
     */
    private final <T extends Activity> T launchActivity(
            String pkg,
            Class<T> activityCls,
            Bundle extras) {
        Intent intent = new Intent(Intent.ACTION_MAIN);
        if (extras != null) {
            intent.putExtras(extras);
        }
        return launchActivityWithIntent(pkg, activityCls, intent);
    }

    /**
     * Utility method for launching an activity with a specific Intent.
     *
     * <p><b>NOTE:</b> The parameter <i>pkg</i> must refer to the package identifier of the
     * package hosting the activity to be launched, which is specified in the AndroidManifest.xml
     * file.  This is not necessarily the same as the java package name.
     *
     * @param pkg The package hosting the activity to be launched.
     * @param activityCls The activity class to launch.
     * @param intent The intent to launch with
     * @return The activity, or null if non launched.
     */
    @SuppressWarnings(""unchecked"")
    private final <T extends Activity> T launchActivityWithIntent(
            String pkg,
            Class<T> activityCls,
            Intent intent) {
        intent.setClassName(pkg, activityCls.getName());
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        T activity = (T) InstrumentationRegistry.getInstrumentation().startActivitySync(intent);
        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
        return activity;
    }

    /**
     * Sets the brightness via the shell cmd.
     */
    public boolean setBrightness(float value) throws Exception {
        Process process = Runtime.getRuntime().exec(""cmd display set-brightness "" + value);
        return 0 == process.waitFor();
    }

    private Point getVendorDisplaySize() {
        String value = PropertyUtil.getProperty(""vendor.display-size"");
        if (TextUtils.isEmpty(value)) {
            return null;
        }

        String[] parts = value.split(""x"");
        assertEquals(2, parts.length);
        return new Point(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]));
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.util.AppStandbyUtils"	"isAppStandbyEnabled"	""	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/AppStandbyUtils.java"	""	"public void test/*
 *.
 */

package com.android.compatibility.common.util;

import android.app.usage.UsageStatsManager;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

public class AppStandbyUtils {
    private static final String TAG = ""CtsAppStandbyUtils"";
    private static final UsageStatsManager sUsageStatsManager = InstrumentationRegistry
            .getTargetContext().getSystemService(UsageStatsManager.class);

    /**
     * Returns if app standby is enabled.
     *
     * @return true if enabled; or false if disabled.
     */
    public static boolean isAppStandbyEnabled() {
        final String result = SystemUtil.runShellCommand(
                ""dumpsys usagestats is-app-standby-enabled"").trim();
        return Boolean.parseBoolean(result);
    }

    /**
     * Sets enabled state for app standby feature for runtime switch.
     *
     * App standby feature has 2 switches. This one affects the switch at runtime. If the build
     * switch is off, enabling the runtime switch will not enable App standby.
     *
     * @param enabled if App standby is enabled.
     */
    public static void setAppStandbyEnabledAtRuntime(boolean enabled) {
        final String value = enabled ? ""1"" : ""0"";
        Log.d(TAG, ""Setting AppStandby "" + (enabled ? ""enabled"" : ""disabled"") + "" at runtime."");
        SettingsUtils.putGlobalSetting(""app_standby_enabled"", value);
    }

    /**
     * Returns if app standby is enabled at runtime. Note {@link #isAppStandbyEnabled()} may still
     * return {@code false} if this method returns {@code true}, because app standby can be disabled
     * at build time as well.
     *
     * @return true if enabled at runtime; or false if disabled at runtime.
     */
    public static boolean isAppStandbyEnabledAtRuntime() {
        final String result =
                SystemUtil.runShellCommand(""settings get global app_standby_enabled"").trim();
        final boolean boolResult = result.equals(""1"") || result.equals(""null"");
        Log.d(TAG, ""AppStandby is "" + (boolResult ? ""enabled"" : ""disabled"") + "" at runtime."");
        return boolResult;
    }

    /** Returns the current standby-bucket of the package on the device */
    public static int getAppStandbyBucket(String packageName) {
        try {
            return SystemUtil.callWithShellPermissionIdentity(
                    () -> sUsageStatsManager.getAppStandbyBucket(packageName));
        } catch (Exception e) {
            throw new RuntimeException(""Could not get standby-bucket for "" + packageName, e);
        }
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.tests.getinfo.DeviceInfoInstrument"	"DisplayMetrics"	""	"/home/gpoor/cts-12-source/cts/tools/device-setup/TestDeviceSetup/src/android/tests/getinfo/DeviceInfoInstrument.java"	""	"public void test/*
 *.
 */

package android.tests.getinfo;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.ActivityManager.MemoryInfo;
import android.app.Instrumentation;
import android.content.Context;
import android.content.Intent;
import android.content.pm.FeatureInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.UserManager;
import android.os.SystemProperties;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.WindowManager;

import com.android.compatibility.common.util.ShellIdentityUtils;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;

public class DeviceInfoInstrument extends Instrumentation implements DeviceInfoConstants {

    private static final String TAG = ""DeviceInfoInstrument"";

    private static Bundle mResults = new Bundle();

    public DeviceInfoInstrument() {
        super();
    }

    @Override
    public void onCreate(Bundle arguments) {
        start();
    }

    @Override
    public void onStart() {
        addResult(BUILD_ID, Build.ID);
        addResult(PRODUCT_NAME, Build.PRODUCT);
        addResult(BUILD_DEVICE, Build.DEVICE);
        addResult(BUILD_BOARD, Build.BOARD);
        addResult(BUILD_MANUFACTURER, Build.MANUFACTURER);
        addResult(BUILD_BRAND, Build.BRAND);
        addResult(BUILD_MODEL, Build.MODEL);
        addResult(BUILD_TYPE, Build.TYPE);
        addResult(BUILD_FINGERPRINT, Build.FINGERPRINT);
        addResult(BUILD_ABI, Build.CPU_ABI);
        addResult(BUILD_ABI2, Build.CPU_ABI2);
        addResult(BUILD_ABIS, TextUtils.join("","", Build.SUPPORTED_ABIS));
        addResult(BUILD_ABIS_32, TextUtils.join("","", Build.SUPPORTED_32_BIT_ABIS));
        addResult(BUILD_ABIS_64, TextUtils.join("","", Build.SUPPORTED_64_BIT_ABIS));
        addResult(SERIAL_NUMBER, Build.SERIAL);

        addResult(REFERENCE_BUILD_FINGERPRINT,
            SystemProperties.get(""ro.build.reference.fingerprint"", """"));

        addResult(VERSION_RELEASE, Build.VERSION.RELEASE_OR_CODENAME);
        addResult(VERSION_SDK, Build.VERSION.SDK);
        addResult(VERSION_BASE_OS, Build.VERSION.BASE_OS);
        addResult(VERSION_SECURITY_PATCH, Build.VERSION.SECURITY_PATCH);

        DisplayMetrics metrics = new DisplayMetrics();
        WindowManager wm = (WindowManager) getContext().getSystemService(
                Context.WINDOW_SERVICE);
        Display d = wm.getDefaultDisplay();
        d.getRealMetrics(metrics);
        addResult(RESOLUTION, String.format(""%sx%s"", metrics.widthPixels, metrics.heightPixels));
        addResult(SCREEN_DENSITY, metrics.density);
        addResult(SCREEN_X_DENSITY, metrics.xdpi);
        addResult(SCREEN_Y_DENSITY, metrics.ydpi);

        String screenDensityBucket = getScreenDensityBucket(metrics);
        addResult(SCREEN_DENSITY_BUCKET, screenDensityBucket);

        String screenSize = getScreenSize();
        addResult(SCREEN_SIZE, screenSize);

        Configuration configuration = getContext().getResources().getConfiguration();
        addResult(SMALLEST_SCREEN_WIDTH_DP, configuration.smallestScreenWidthDp);

        Intent intent = new Intent();
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.setClass(this.getContext(), DeviceInfoActivity.class);

        DeviceInfoActivity activity = (DeviceInfoActivity) startActivitySync(intent);
        waitForIdleSync();
        activity.waitForAcitityToFinish();

        TelephonyManager tm = (TelephonyManager) getContext().getSystemService(
                Context.TELEPHONY_SERVICE);
        // network
        String network = tm.getNetworkOperatorName();
        addResult(NETWORK, network.trim());
        // imei
        String imei = ShellIdentityUtils.invokeMethodWithShellPermissions(tm,
                (telephonyManager) -> telephonyManager.getDeviceId());
        addResult(IMEI, imei);

        // imsi
        String imsi = ShellIdentityUtils.invokeMethodWithShellPermissions(tm,
                (telephonyManager) -> telephonyManager.getSubscriberId());
        addResult(IMSI, imsi);

        // phone number
        String phoneNumber = tm.getLine1Number();
        addResult(PHONE_NUMBER, phoneNumber);

        // features
        String features = getFeatures();
        addResult(FEATURES, features);

        // processes
        String processes = getProcesses();
        addResult(PROCESSES, processes);

        // OpenGL ES version
        String openGlEsVersion = getOpenGlEsVersion();
        addResult(OPEN_GL_ES_VERSION, openGlEsVersion);

        // partitions
        String partitions = getPartitions();
        addResult(PARTITIONS, partitions);

        // System libraries
        String sysLibraries = getSystemLibraries();
        addResult(SYS_LIBRARIES, sysLibraries);

        // Storage devices
        addResult(STORAGE_DEVICES, getStorageDevices());

        // Multi-user support
        addResult(MULTI_USER, getMultiUserInfo());

        // Encrypted
        addResult(ENCRYPTED, getEncrypted());

        // Memory Info
        addResult(IS_LOW_RAM_DEVICE, isLowRamDevice());
        addResult(MEMORY_CLASS, getMemoryClass());
        addResult(LARGE_MEMORY_CLASS, getLargeMemoryClass());
        addResult(TOTAL_MEMORY, getTotalMemory());

        // CPU Info
        addResult(AVAILABLE_PROCESSORS, Runtime.getRuntime().availableProcessors());

        finish(Activity.RESULT_OK, mResults);
    }

    /**
     * Add string result.
     *
     * @param key the string of the key name.
     * @param value string value.
     */
    static void addResult(final String key, final String value){
        mResults.putString(key, value);
    }

    /**
     * Add integer result.
     *
     * @param key the string of the key name.
     * @param value integer value.
     */
    static void addResult(final String key, final int value){
        mResults.putInt(key, value);
    }

    /**
     * Add float result.
     *
     * @param key the string of the key name.
     * @param value float value.
     */
    static void addResult(final String key, final float value){
        mResults.putFloat(key, value);
    }

    private String getScreenSize() {
        Configuration config = getContext().getResources().getConfiguration();
        int screenLayout = config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;
        String screenSize = String.format(""0x%x"", screenLayout);
        switch (screenLayout) {
            case Configuration.SCREENLAYOUT_SIZE_SMALL:
                screenSize = ""small"";
                break;

            case Configuration.SCREENLAYOUT_SIZE_NORMAL:
                screenSize = ""normal"";
                break;

            case Configuration.SCREENLAYOUT_SIZE_LARGE:
                screenSize = ""large"";
                break;

            case Configuration.SCREENLAYOUT_SIZE_XLARGE:
                screenSize = ""xlarge"";
                break;

            case Configuration.SCREENLAYOUT_SIZE_UNDEFINED:
                screenSize = ""undefined"";
                break;
        }
        return screenSize;
    }

    private String getScreenDensityBucket(DisplayMetrics metrics) {
        switch (metrics.densityDpi) {
            case DisplayMetrics.DENSITY_LOW:
                return ""ldpi"";

            case DisplayMetrics.DENSITY_MEDIUM:
                return ""mdpi"";

            case DisplayMetrics.DENSITY_TV:
                return ""tvdpi"";

            case DisplayMetrics.DENSITY_HIGH:
                return ""hdpi"";

            case DisplayMetrics.DENSITY_XHIGH:
                return ""xdpi"";

            default:
                return """" + metrics.densityDpi;
        }
    }

    /**
     * Return a summary of the device's feature as a semi-colon-delimited list of colon separated
     * name and availability pairs like ""feature1:sdk:true;feature2:sdk:false;feature3:other:true;"".
     */
    private String getFeatures() {
        StringBuilder features = new StringBuilder();

        try {
            Set<String> checkedFeatures = new HashSet<String>();

            PackageManager packageManager = getContext().getPackageManager();
            for (String featureName : getPackageManagerFeatures()) {
                checkedFeatures.add(featureName);
                boolean hasFeature = packageManager.hasSystemFeature(featureName);
                addFeature(features, featureName, ""sdk"", hasFeature);
            }

            FeatureInfo[] featureInfos = packageManager.getSystemAvailableFeatures();
            if (featureInfos != null) {
                for (FeatureInfo featureInfo : featureInfos) {
                    if (featureInfo.name != null && !checkedFeatures.contains(featureInfo.name)) {
                        addFeature(features, featureInfo.name, ""other"", true);
                    }
                }
            }
        } catch (Exception exception) {
            Log.e(TAG, ""Error getting features: "" + exception.getMessage(), exception);
        }

        return features.toString();
    }

    private static void addFeature(StringBuilder features, String name, String type,
            boolean available) {
        features.append(name).append(':').append(type).append(':').append(available).append(';');
    }

    /**
     * Use reflection to get the features defined by the SDK. If there are features that do not fit
     * the convention of starting with ""FEATURE_"" then they will still be shown under the
     * ""Other Features"" section.
     *
     * @return list of feature names from sdk
     */
    private List<String> getPackageManagerFeatures() {
        try {
            List<String> features = new ArrayList<String>();
            Field[] fields = PackageManager.class.getFields();
            for (Field field : fields) {
                if (field.getName().startsWith(""FEATURE_"")) {
                    String feature = (String) field.get(null);
                    features.add(feature);
                }
            }
            return features;
        } catch (IllegalAccessException illegalAccess) {
            throw new RuntimeException(illegalAccess);
        }
    }

    /**
     * Return a semi-colon-delimited list of the root processes that were running on the phone
     * or an error message.
     */
    private static String getProcesses() {
        StringBuilder builder = new StringBuilder();

        try {
            String[] rootProcesses = RootProcessScanner.getRootProcesses();
            for (String rootProcess : rootProcesses) {
                builder.append(rootProcess).append(':').append(0).append(';');
            }
        } catch (Exception exception) {
            Log.e(TAG, ""Error getting processes: "" + exception.getMessage(), exception);
            builder.append(exception.getMessage());
        }

        return builder.toString();
    }

    /** @return a string containing the Open GL ES version number or an error message */
    private String getOpenGlEsVersion() {
        PackageManager packageManager = getContext().getPackageManager();
        FeatureInfo[] featureInfos = packageManager.getSystemAvailableFeatures();
        if (featureInfos != null && featureInfos.length > 0) {
            for (FeatureInfo featureInfo : featureInfos) {
                // Null feature name means this feature is the open gl es version feature.
                if (featureInfo.name == null) {
                    return featureInfo.getGlEsVersion();
                }
            }
        }
        return ""No feature for Open GL ES version."";
    }

    private String getPartitions() {
        try {
            StringBuilder builder = new StringBuilder();
            Process df = new ProcessBuilder(""df"").start();
            Scanner scanner = new Scanner(df.getInputStream());
            try {
                while (scanner.hasNextLine()) {
                    builder.append(scanner.nextLine()).append(';');
                }
                return builder.toString();
            } finally {
                scanner.close();
            }
        } catch (IOException e) {
            return ""Not able to run df for partition information."";
        }
    }

    private String getSystemLibraries() {
        PackageManager pm = getContext().getPackageManager();
        String list[] = pm.getSystemSharedLibraryNames();

        StringBuilder builder = new StringBuilder();
        for (String lib : list) {
            builder.append(lib);
            builder.append("";"");
        }

        return builder.toString();
    }

    private String getStorageDevices() {
        int count = 0;
        count = Math.max(count, getContext().getExternalCacheDirs().length);
        count = Math.max(count, getContext().getExternalFilesDirs(null).length);
        count = Math.max(
                count, getContext().getExternalFilesDirs(Environment.DIRECTORY_PICTURES).length);
        count = Math.max(count, getContext().getObbDirs().length);

        if (Environment.isExternalStorageEmulated()) {
            if (count == 1) {
                return ""1 emulated"";
            } else {
                return ""1 emulated, "" + (count - 1) + "" physical media"";
            }
        } else {
            return count + "" physical media"";
        }
    }

    private String getMultiUserInfo() {
        try {
            final Method method = UserManager.class.getMethod(""getMaxSupportedUsers"");
            final Integer maxUsers = (Integer) method.invoke(null);
            if (maxUsers == 1) {
                return ""single user"";
            } else {
                return maxUsers + "" users supported"";
            }
        } catch (ClassCastException e) {
        } catch (NoSuchMethodException e) {
        } catch (InvocationTargetException e) {
        } catch (IllegalAccessException e) {
        }

        return ""unknown"";
    }

    private static String getProperty(String property)
            throws IOException {
        Process process = new ProcessBuilder(""getprop"", property).start();
        Scanner scanner = null;
        String line = """";
        try {
            scanner = new Scanner(process.getInputStream());
            line = scanner.nextLine();
        } finally {
            if (scanner != null) {
                scanner.close();
            }
        }
        return line;
    }

    private int getEncrypted() {
        try {
            return ""encrypted"".equals(getProperty(""ro.crypto.state"")) ? 1 : 0;
        } catch (IOException e) {
        }

        return 0;
    }

    private String isLowRamDevice() {
        ActivityManager activityManager = (ActivityManager) getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);
        return activityManager.isLowRamDevice() ? ""true"" : ""false"";
    }

    private String getMemoryClass() {
        ActivityManager activityManager = (ActivityManager) getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);
        return String.valueOf(activityManager.getMemoryClass());
    }

    private String getLargeMemoryClass() {
        ActivityManager activityManager = (ActivityManager) getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);
        return String.valueOf(activityManager.getLargeMemoryClass());
    }

    private String getTotalMemory() {
        ActivityManager activityManager = (ActivityManager) getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);

        MemoryInfo memoryInfo = new MemoryInfo();
        activityManager.getMemoryInfo(memoryInfo);
        return String.valueOf(memoryInfo.totalMem);
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.PreserveLegacyStorageHostTest"	"testPreserveLegacy"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/PreserveLegacyStorageHostTest.java"	""	"public void testPreserveLegacy() throws Exception {
        // This was broken on R, so only run the test on S+ devices
        DeviceSdkLevel deviceSdkLevel = new DeviceSdkLevel(getDevice());
        assumeTrue(deviceSdkLevel.isDeviceAtLeastS());

        // Most of these tests are done device-side; see RestrictedStoragePermissionTest.java
        // This test is done on the host, because we want to verify preserveLegacyExternalStorage
        // is sticky across a reboot.
        installApp(LEGACY_29_APK);
        String result = getDevice().executeShellCommand(
                                    ""appops get "" + PACKAGE_NAME + "" LEGACY_STORAGE"");
        assertThat(result).contains("": allow"");

        // Upgrade to targetSdk 30 with preserveLegacyExternalStorage
        installApp(PRESERVE_30_APK);
        result = getDevice().executeShellCommand(
                                    ""appops get "" + PACKAGE_NAME + "" LEGACY_STORAGE"");

        // And make sure we still have legacy
        assertThat(result).contains("": allow"");

        // Reboot, and again make sure we have legacy
        getDevice().reboot();
        result = getDevice().executeShellCommand(
                                    ""appops get "" + PACKAGE_NAME + "" LEGACY_STORAGE"");
        assertThat(result).contains("": allow"");
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.media.mediaparser.cts.MediaParserHostSideTest"	"testVideoSize"	"CtsMediaParserHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/mediaparser/src/android/media/mediaparser/cts/MediaParserHostSideTest.java"	""	"public void testVideoSize() throws Exception {
        runDeviceTest(""testMp4"");
        MediametricsMediaParserReported reportedEvent = getSingleMediaParserReportedEvent();
        assertThat(reportedEvent.getVideoWidth()).isEqualTo(1080);
        assertThat(reportedEvent.getVideoHeight()).isEqualTo(720);
    }

    // Internal methods.

    /** Creates the statsd config and passes it to statsd. */
    private void createAndUploadConfig() throws Exception {
        StatsdConfig.Builder configBuilder =
                StatsdConfigProto.StatsdConfig.newBuilder()
                        .setId(CONFIG_ID)
                        .addAllowedLogSource(MEDIAPARSER_TEST_APP_PACKAGE)
                        .addWhitelistedAtomIds(
                                AtomsProto.Atom.MEDIAMETRICS_MEDIAPARSER_REPORTED_FIELD_NUMBER);
        addAtomEvent(configBuilder);
        uploadConfig(configBuilder.build());
    }

    /** Removes any existing config with id {@link #CONFIG_ID}. */
    private void removeConfig() throws Exception {
        getDevice().executeShellCommand(""cmd stats config remove "" + CONFIG_ID);
    }

    /** Writes the given config into a file and passes is to statsd via standard input. */
    private void uploadConfig(StatsdConfig config) throws Exception {
        File configFile = File.createTempFile(""statsdconfig"", "".config"");
        configFile.deleteOnExit();
        Files.write(config.toByteArray(), configFile);
        String remotePath = ""/data/local/tmp/"" + configFile.getName();
        // Make sure a config file with the same name doesn't exist already.
        getDevice().deleteFile(remotePath);
        assertThat(getDevice().pushFile(configFile, remotePath)).isTrue();
        getDevice()
                .executeShellCommand(
                        ""cat "" + remotePath + "" | cmd stats config update "" + CONFIG_ID);
        getDevice().deleteFile(remotePath);
    }

    /**
     * Asserts that there is only one MediaParser reported metric event, and returns it.
     *
     * <p>Note: Calls {@link #getAndClearReportList()} to obtain the statsd report.
     */
    private MediametricsMediaParserReported getSingleMediaParserReportedEvent() throws Exception {
        List<MediametricsMediaParserReported> mediaParserReportedEvents =
                getMediaParserReportedEvents();
        assertThat(mediaParserReportedEvents).hasSize(1);
        return mediaParserReportedEvents.get(0);
    }

    /**
     * Returns all MediaParser reported metric events sorted by timestamp.
     *
     * <p>Note: Calls {@link #getAndClearReportList()} to obtain the statsd report.
     */
    private List<MediametricsMediaParserReported> getMediaParserReportedEvents() throws Exception {
        ConfigMetricsReportList reportList = getAndClearReportList();
        assertThat(reportList.getReportsCount()).isEqualTo(1);
        StatsLog.ConfigMetricsReport report = reportList.getReports(0);
        ArrayList<EventMetricData> data = new ArrayList<>();
        report.getMetricsList()
                .forEach(
                        statsLogReport ->
                                data.addAll(statsLogReport.getEventMetrics().getDataList()));
        // We sort the reported events by the elapsed timestamp so as to ensure they are returned
        // in the same order as they were generated by the CTS tests.
        return data.stream()
                .sorted(Comparator.comparing(EventMetricData::getElapsedTimestampNanos))
                .map(event -> event.getAtom().getMediametricsMediaparserReported())
                .collect(Collectors.toList());
    }

    /** Gets a statsd report and removes it from the device. */
    private ConfigMetricsReportList getAndClearReportList() throws Exception {
        CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();
        getDevice()
                .executeShellCommand(
                        ""cmd stats dump-report "" + CONFIG_ID + "" --include_current_bucket --proto"",
                        receiver);
        return ConfigMetricsReportList.parser().parseFrom(receiver.getOutput());
    }

    /** Runs the test with the given name from the MediaParser CTS apk. */
    private void runDeviceTest(String testMethodName) throws DeviceNotAvailableException {
        RemoteAndroidTestRunner testRunner =
                new RemoteAndroidTestRunner(
                        MEDIAPARSER_TEST_APP_PACKAGE, TEST_RUNNER, getDevice().getIDevice());
        testRunner.setMethodName(MEDIAPARSER_TEST_CLASS_NAME, testMethodName);
        CollectingTestListener listener = new CollectingTestListener();
        assertThat(getDevice().runInstrumentationTests(testRunner, listener)).isTrue();
        TestRunResult result = listener.getCurrentRunResults();
        assertThat(result.isRunFailure()).isFalse();
        assertThat(result.getNumTests()).isEqualTo(1);
        assertThat(result.hasFailedTests()).isFalse();
    }

    /** Adds an event to the config in order to match MediaParser reported atoms. */
    private static void addAtomEvent(StatsdConfig.Builder config) {
        String atomName = ""Atom"" + System.nanoTime();
        String eventName = ""Event"" + System.nanoTime();
        SimpleAtomMatcher.Builder sam =
                SimpleAtomMatcher.newBuilder()
                        .setAtomId(AtomsProto.Atom.MEDIAMETRICS_MEDIAPARSER_REPORTED_FIELD_NUMBER);
        config.addAtomMatcher(
                AtomMatcher.newBuilder().setId(atomName.hashCode()).setSimpleAtomMatcher(sam));
        config.addEventMetric(
                StatsdConfigProto.EventMetric.newBuilder()
                        .setId(eventName.hashCode())
                        .setWhat(atomName.hashCode()));
    }
}"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.telecom.cts.ConferenceTest"	"testConferenceSetters"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConferenceTest.java"	""	"public void testConferenceSetters() {
        if (!mShouldTestTelecom) {
            return;
        }
        final Call conf = mInCallService.getLastConferenceCall();
        assertCallState(conf, Call.STATE_ACTIVE);

        placeAndVerifyCall();
        MockConnection newConnection = verifyConnectionForOutgoingCall(2);
        final Call newCall = mInCallService.getLastCall();

        ArrayList<Connection> connectionList = new ArrayList<>();
        connectionList.add(newConnection);
        ArrayList<Call> callList = new ArrayList<>();
        callList.add(newCall);

        assertFalse(conf.getDetails().can(Call.Details.CAPABILITY_MUTE));
        int capabilities = mConferenceObject.getConnectionCapabilities() |
                Connection.CAPABILITY_MUTE;
        mConferenceObject.setConnectionCapabilities(capabilities);
        assertCallCapability(conf, Call.Details.CAPABILITY_MUTE);

        assertFalse(conf.getConferenceableCalls().contains(newCall));
        mConferenceObject.setConferenceableConnections(connectionList);
        assertCallConferenceableList(conf, callList);

        // Consumed internally in Telecom; no verifiable manner to see the end point of this data
        // through public APIs.
        mConferenceObject.setConnectionTime(0);
        mConferenceObject.setConnectionStartElapsedRealtimeMillis(0);

        Bundle extras = new Bundle();
        extras.putString(TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE, ""Test"");
        assertFalse(conf.getDetails().getExtras().containsKey(
                TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE));
        mConferenceObject.setExtras(extras);
        assertCallExtras(conf, TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE, ""Test"");

        StatusHints hints = new StatusHints(""Test"", null, null);
        assertNull(conf.getDetails().getStatusHints());
        mConferenceObject.setStatusHints(hints);
        assertCallStatusHints(conf, hints);

        assertFalse(conf.getChildren().contains(newCall));
        mConferenceObject.addConnection(newConnection);
        assertCallChildrenContains(conf, newCall, true);

        assertTrue(conf.getChildren().contains(newCall));
        mConferenceObject.removeConnection(newConnection);
        assertCallChildrenContains(conf, newCall, false);

        assertVideoState(conf, VideoProfile.STATE_AUDIO_ONLY);
        final MockVideoProvider mockVideoProvider = mConnection1.getMockVideoProvider();
        mConferenceObject.setVideoProvider(mConnection1, mockVideoProvider);
        mConferenceObject.setVideoState(mConnection1, VideoProfile.STATE_BIDIRECTIONAL);
        assertVideoState(conf, VideoProfile.STATE_BIDIRECTIONAL);

        // Dialing state is unsupported for conference calls. so, the state remains active.
        mConferenceObject.setDialing();
        // just assert call state is not dialing, the state remains as previous one.
        assertTrue(conf.getState() != Call.STATE_DIALING);

        mConferenceObject.setRinging();
        assertCallState(conf, Call.STATE_RINGING);

        mConferenceObject.setOnHold();
        assertCallState(conf, Call.STATE_HOLDING);

        mConferenceObject.setActive();
        assertCallState(conf, Call.STATE_ACTIVE);

        mConferenceObject.setAddress(CONF_HANDLE, TelecomManager.PRESENTATION_ALLOWED);
        assertCallHandle(conf, CONF_HANDLE);
        // Handle presentation is set at same time as address; so no need to wait for it.
        assertEquals(TelecomManager.PRESENTATION_ALLOWED,
                conf.getDetails().getHandlePresentation());

        mConferenceObject.setAddress(null, TelecomManager.PRESENTATION_RESTRICTED);
        assertCallHandle(conf, null);
        // Handle presentation is set at same time as address; so no need to wait for it.
        assertEquals(TelecomManager.PRESENTATION_RESTRICTED,
                conf.getDetails().getHandlePresentation());

        mConferenceObject.setCallerDisplayName(TEST_CALLER_NAME,
                TelecomManager.PRESENTATION_ALLOWED);
        assertCallDisplayName(conf, TEST_CALLER_NAME);
        assertEquals(TelecomManager.PRESENTATION_ALLOWED,
                conf.getDetails().getCallerDisplayNamePresentation());

        mConferenceObject.setCallerDisplayName(null, TelecomManager.PRESENTATION_UNKNOWN);
        assertCallDisplayName(conf, null);
        assertEquals(TelecomManager.PRESENTATION_UNKNOWN,
                conf.getDetails().getCallerDisplayNamePresentation());

        // Expect no change; not calling withe correct permission.
        mConferenceObject.setConferenceState(false);
        assertCallProperties(conf, Call.Details.PROPERTY_CONFERENCE);

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        try {
            mConferenceObject.setConferenceState(false);
            assertDoesNotHaveCallProperties(conf, Call.Details.PROPERTY_CONFERENCE);

            mConferenceObject.setConferenceState(true);
            assertCallProperties(conf, Call.Details.PROPERTY_CONFERENCE);
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }

        assertFalse(mConferenceObject.isRingbackRequested());
        mConferenceObject.setRingbackRequested(true);
        assertTrue(mConferenceObject.isRingbackRequested());

        mConferenceObject.setDisconnected(new DisconnectCause(DisconnectCause.LOCAL));
        assertCallState(conf, Call.STATE_DISCONNECTED);

        // Destroy state is unsupported for conference calls. so, the state remains active.
        mConferenceObject.destroy();
        assertCallState(conf, Call.STATE_DISCONNECTED);
    }

    /**
     * Tests end to end propagation of the {@link Conference} properties to the associated
     * {@link Call}.
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"isAppStandbyEnabled"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"/**
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package android.app.usage.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.KeyguardManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.usage.EventStats;
import android.app.usage.UsageEvents;
import android.app.usage.UsageEvents.Event;
import android.app.usage.UsageStats;
import android.app.usage.UsageStatsManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.Parcel;
import android.os.SystemClock;
import android.os.UserHandle;
import android.os.UserManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AppModeInstant;
import android.provider.Settings;
import android.server.wm.WindowManagerState;
import android.server.wm.WindowManagerStateHelper;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.Until;
import android.text.format.DateUtils;
import android.util.Log;
import android.util.SparseArray;
import android.util.SparseLongArray;
import android.view.KeyEvent;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AppStandbyUtils;
import com.android.compatibility.common.util.BatteryUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.text.MessageFormat;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.function.BooleanSupplier;

/**
 * Test the UsageStats API. It is difficult to test the entire surface area
 * of the API, as a lot of the testing depends on what data is already present
 * on the device and for how long that data has been aggregating.
 *
 * These tests perform simple checks that each interval is of the correct duration,
 * and that events do appear in the event log.
 *
 * Tests to add that are difficult to add now:
 * - Invoking a device configuration change and then watching for it in the event log.
 * - Changing the system time and verifying that all data has been correctly shifted
 *   along with the new time.
 * - Proper eviction of old data.
 */
@RunWith(AndroidJUnit4.class)
public class UsageStatsTest {
    private static final boolean DEBUG = false;
    private static final String TAG = ""UsageStatsTest"";

    private static final String APPOPS_SET_SHELL_COMMAND = ""appops set {0} "" +
            AppOpsManager.OPSTR_GET_USAGE_STATS + "" {1}"";

    private static final String GET_SHELL_COMMAND = ""settings get global "";

    private static final String SET_SHELL_COMMAND = ""settings put global "";

    private static final String DELETE_SHELL_COMMAND = ""settings delete global "";

    private static final String JOBSCHEDULER_RUN_SHELL_COMMAND = ""cmd jobscheduler run"";

    private static final String TEST_APP_PKG = ""android.app.usage.cts.test1"";
    private static final String TEST_APP_CLASS = ""android.app.usage.cts.test1.SomeActivity"";
    private static final String TEST_APP_CLASS_LOCUS
            = ""android.app.usage.cts.test1.SomeActivityWithLocus"";
    private static final String TEST_APP_CLASS_SERVICE
            = ""android.app.usage.cts.test1.TestService"";
    private static final String TEST_APP2_PKG = ""android.app.usage.cts.test2"";
    private static final String TEST_APP2_CLASS_FINISHING_TASK_ROOT =
            ""android.app.usage.cts.test2.FinishingTaskRootActivity"";
    private static final String TEST_APP2_CLASS_PIP =
            ""android.app.usage.cts.test2.PipActivity"";
    private static final ComponentName TEST_APP2_PIP_COMPONENT = new ComponentName(TEST_APP2_PKG,
            TEST_APP2_CLASS_PIP);

    private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);
    private static final long MINUTE = TimeUnit.MINUTES.toMillis(1);
    private static final long DAY = TimeUnit.DAYS.toMillis(1);
    private static final long WEEK = 7 * DAY;
    private static final long MONTH = 30 * DAY;
    private static final long YEAR = 365 * DAY;
    private static final long TIME_DIFF_THRESHOLD = 200;
    private static final String CHANNEL_ID = ""my_channel"";

    private static final long TIMEOUT_BINDER_SERVICE_SEC = 2;

    private Context mContext;
    private UiDevice mUiDevice;
    private ActivityManager mAm;
    private UsageStatsManager mUsageStatsManager;
    private KeyguardManager mKeyguardManager;
    private String mTargetPackage;
    private String mCachedUsageSourceSetting;
    private String mCachedEnableRestrictedBucketSetting;
    private int mOtherUser;
    private Context mOtherUserContext;
    private UsageStatsManager mOtherUsageStats;
    private WindowManagerStateHelper mWMStateHelper;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mAm = mContext.getSystemService(ActivityManager.class);
        mUsageStatsManager = (UsageStatsManager) mContext.getSystemService(
                Context.USAGE_STATS_SERVICE);
        mKeyguardManager = mContext.getSystemService(KeyguardManager.class);
        mTargetPackage = mContext.getPackageName();

        mWMStateHelper = new WindowManagerStateHelper();

        assumeTrue(""App Standby not enabled on device"", AppStandbyUtils.isAppStandbyEnabled());
        setAppOpsMode(""allow"");
        mCachedUsageSourceSetting = getSetting(Settings.Global.APP_TIME_LIMIT_USAGE_SOURCE);
        mCachedEnableRestrictedBucketSetting = getSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET);
    }

    @After
    public void cleanUp() throws Exception {
        if (mCachedUsageSourceSetting != null &&
                !mCachedUsageSourceSetting.equals(
                    getSetting(Settings.Global.APP_TIME_LIMIT_USAGE_SOURCE))) {
            setUsageSourceSetting(mCachedUsageSourceSetting);
        }
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, mCachedEnableRestrictedBucketSetting);
        // Force stop test package to avoid any running test code from carrying over to the next run
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP2_PKG));
        mUiDevice.pressHome();
        // Destroy the other user if created
        if (mOtherUser != 0) {
            stopUser(mOtherUser, true, true);
            removeUser(mOtherUser);
            mOtherUser = 0;
        }
    }

    private static void assertLessThan(long left, long right) {
        assertTrue(""Expected "" + left + "" to be less than "" + right, left < right);
    }

    private static void assertLessThanOrEqual(long left, long right) {
        assertTrue(""Expected "" + left + "" to be less than "" + right, left <= right);
    }

    private void setAppOpsMode(String mode) throws Exception {
        executeShellCmd(MessageFormat.format(APPOPS_SET_SHELL_COMMAND, mTargetPackage, mode));
    }

    private String getSetting(String name) throws Exception {
        return executeShellCmd(GET_SHELL_COMMAND + name);
    }

    private void setSetting(String name, String setting) throws Exception {
        if (setting == null || setting.equals(""null"")) {
            executeShellCmd(DELETE_SHELL_COMMAND + name);
        } else {
            executeShellCmd(SET_SHELL_COMMAND + name + "" "" + setting);
        }
    }

    private void setUsageSourceSetting(String value) throws Exception {
        setSetting(Settings.Global.APP_TIME_LIMIT_USAGE_SOURCE, value);
        mUsageStatsManager.forceUsageSourceSettingRead();
    }

    private void launchSubActivity(Class<? extends Activity> clazz) {
        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.setClassName(mTargetPackage, clazz.getName());
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
        mUiDevice.wait(Until.hasObject(By.clazz(clazz)), TIMEOUT);
    }

    private Intent createTestActivityIntent(String pkgName, String className) {
        final Intent intent = new Intent();
        intent.setClassName(pkgName, className);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        return intent;
    }

    private void launchTestActivity(String pkgName, String className) {
        mContext.startActivity(createTestActivityIntent(pkgName, className));
        mUiDevice.wait(Until.hasObject(By.clazz(pkgName, className)), TIMEOUT);
    }

    private void launchSubActivities(Class<? extends Activity>[] activityClasses) {
        for (Class<? extends Activity> clazz : activityClasses) {
            launchSubActivity(clazz);
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testStandbyBucketChangeLog"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testStandbyBucketChangeLog() throws Exception {
        final long startTime = System.currentTimeMillis();
        setStandByBucket(mTargetPackage, ""rare"");

        final long endTime = System.currentTimeMillis();
        UsageEvents events = mUsageStatsManager.queryEvents(startTime - 1_000, endTime + 1_000);

        boolean found = false;
        // Check all the events.
        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            if (event.getEventType() == UsageEvents.Event.STANDBY_BUCKET_CHANGED) {
                found |= event.getAppStandbyBucket() == UsageStatsManager.STANDBY_BUCKET_RARE;
            }
        }

        assertTrue(found);
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testGetAppStandbyBuckets"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testGetAppStandbyBuckets() throws Exception {
        final boolean origValue = AppStandbyUtils.isAppStandbyEnabledAtRuntime();
        AppStandbyUtils.setAppStandbyEnabledAtRuntime(true);
        try {
            assumeTrue(""Skip GetAppStandby test: app standby is disabled."",
                    AppStandbyUtils.isAppStandbyEnabled());

            setStandByBucket(mTargetPackage, ""rare"");
            Map<String, Integer> bucketMap = mUsageStatsManager.getAppStandbyBuckets();
            assertTrue(""No bucket data returned"", bucketMap.size() > 0);
            final int bucket = bucketMap.getOrDefault(mTargetPackage, -1);
            assertEquals(""Incorrect bucket returned for "" + mTargetPackage, bucket,
                    UsageStatsManager.STANDBY_BUCKET_RARE);
        } finally {
            AppStandbyUtils.setAppStandbyEnabledAtRuntime(origValue);
        }
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testGetAppStandbyBucket"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testGetAppStandbyBucket() throws Exception {
        // App should be at least active, since it's running instrumentation tests
        assertLessThanOrEqual(UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket());
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testQueryEventsForSelf"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testQueryEventsForSelf() throws Exception {
        setAppOpsMode(""ignore""); // To ensure permission is not required
        // Time drifts of 2s are expected inside usage stats
        final long start = System.currentTimeMillis() - 2_000;
        setStandByBucket(mTargetPackage, ""rare"");
        Thread.sleep(100);
        setStandByBucket(mTargetPackage, ""working_set"");
        Thread.sleep(100);
        final long end = System.currentTimeMillis() + 2_000;
        final UsageEvents events = mUsageStatsManager.queryEventsForSelf(start, end);
        long rareTimeStamp = end + 1; // Initializing as rareTimeStamp > workingTimeStamp
        long workingTimeStamp = start - 1;
        int numEvents = 0;
        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            numEvents++;
            assertEquals(""Event for a different package"", mTargetPackage, event.getPackageName());
            if (event.getEventType() == Event.STANDBY_BUCKET_CHANGED) {
                if (event.getAppStandbyBucket() == UsageStatsManager.STANDBY_BUCKET_RARE) {
                    rareTimeStamp = event.getTimeStamp();
                }
                else if (event.getAppStandbyBucket() == UsageStatsManager
                        .STANDBY_BUCKET_WORKING_SET) {
                    workingTimeStamp = event.getTimeStamp();
                }
            }
        }
        assertTrue(""Only "" + numEvents + "" events returned"", numEvents >= 2);
        assertLessThan(rareTimeStamp, workingTimeStamp);
    }

    /**
     * We can't run this test because we are unable to change the system time.
     * It would be nice to add a shell command or other to allow the shell user
     * to set the time, thereby allowing this test to set the time using the UIAutomator.
     */
    @Ignore"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUserForceIntoRestricted"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUserForceIntoRestricted() throws Exception {
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");

        launchSubActivity(TaskRootActivity.class);
        assertEquals(""Activity launch didn't bring app up to ACTIVE bucket"",
                UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

        // User force shouldn't have to deal with the timeout.
        setStandByBucket(mTargetPackage, ""restricted"");
        assertEquals(""User was unable to force an ACTIVE app down into RESTRICTED bucket"",
                UsageStatsManager.STANDBY_BUCKET_RESTRICTED,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUserForceIntoRestricted_BucketDisabled"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUserForceIntoRestricted_BucketDisabled() throws Exception {
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, ""0"");

        launchSubActivity(TaskRootActivity.class);
        assertEquals(""Activity launch didn't bring app up to ACTIVE bucket"",
                UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

        // User force shouldn't have to deal with the timeout.
        setStandByBucket(mTargetPackage, ""restricted"");
        assertNotEquals(""User was able to force into RESTRICTED bucket when bucket disabled"",
                UsageStatsManager.STANDBY_BUCKET_RESTRICTED,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUserLaunchRemovesFromRestricted"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUserLaunchRemovesFromRestricted() throws Exception {
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");

        setStandByBucket(mTargetPackage, ""restricted"");
        assertEquals(""User was unable to force an app into RESTRICTED bucket"",
                UsageStatsManager.STANDBY_BUCKET_RESTRICTED,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

        launchSubActivity(TaskRootActivity.class);
        assertEquals(""Activity launch didn't bring RESTRICTED app into ACTIVE bucket"",
                UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));
    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testIsAppInactive"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testIsAppInactive() throws Exception {
        assumeTrue(""Test only works on devices with a battery"", BatteryUtils.hasBattery());

        setStandByBucket(mTargetPackage, ""rare"");

        try {
            BatteryUtils.runDumpsysBatteryUnplug();

            waitUntil(() -> mUsageStatsManager.isAppInactive(mTargetPackage), true);
            assertFalse(
                    ""App without PACKAGE_USAGE_STATS permission should always receive false for ""
                            + ""isAppInactive"",
                    isAppInactiveAsPermissionlessApp(mTargetPackage));

            launchSubActivity(Activities.ActivityOne.class);

            waitUntil(() -> mUsageStatsManager.isAppInactive(mTargetPackage), false);
            assertFalse(
                    ""App without PACKAGE_USAGE_STATS permission should always receive false for ""
                            + ""isAppInactive"",
                    isAppInactiveAsPermissionlessApp(mTargetPackage));

            mUiDevice.pressHome();
            setStandByBucket(TEST_APP_PKG, ""rare"");
            // Querying for self does not require the PACKAGE_USAGE_STATS
            waitUntil(() -> mUsageStatsManager.isAppInactive(TEST_APP_PKG), true);
            assertTrue(
                    ""App without PACKAGE_USAGE_STATS permission should be able to call ""
                            + ""isAppInactive for itself"",
                    isAppInactiveAsPermissionlessApp(TEST_APP_PKG));

            launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS);

            waitUntil(() -> mUsageStatsManager.isAppInactive(TEST_APP_PKG), false);
            assertFalse(
                    ""App without PACKAGE_USAGE_STATS permission should be able to call ""
                            + ""isAppInactive for itself"",
                    isAppInactiveAsPermissionlessApp(TEST_APP_PKG));

        } finally {
            BatteryUtils.runDumpsysBatteryReset();
        }
    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testIsAppInactive_Charging"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testIsAppInactive_Charging() throws Exception {
        assumeTrue(""Test only works on devices with a battery"", BatteryUtils.hasBattery());

        setStandByBucket(TEST_APP_PKG, ""rare"");

        try {
            BatteryUtils.runDumpsysBatteryUnplug();
            // Plug/unplug change takes a while to propagate inside the system.
            waitUntil(() -> mUsageStatsManager.isAppInactive(TEST_APP_PKG), true);

            BatteryUtils.runDumpsysBatterySetPluggedIn(true);
            BatteryUtils.runDumpsysBatterySetLevel(100);
            // Plug/unplug change takes a while to propagate inside the system.
            waitUntil(() -> mUsageStatsManager.isAppInactive(TEST_APP_PKG), false);
        } finally {
            BatteryUtils.runDumpsysBatteryReset();
        }
    }

    private static final int[] INTERACTIVE_EVENTS = new int[] {
            Event.SCREEN_INTERACTIVE,
            Event.SCREEN_NON_INTERACTIVE
    };

    private static final int[] KEYGUARD_EVENTS = new int[] {
            Event.KEYGUARD_SHOWN,
            Event.KEYGUARD_HIDDEN
    };

    private static final int[] ALL_EVENTS = new int[] {
            Event.SCREEN_INTERACTIVE,
            Event.SCREEN_NON_INTERACTIVE,
            Event.KEYGUARD_SHOWN,
            Event.KEYGUARD_HIDDEN
    };

    private static final int[] PAUSED_EVENT = new int[] {
            Event.ACTIVITY_PAUSED
    };

    private static final int[] STOPPED_EVENT = new int[] {
            Event.ACTIVITY_STOPPED
    };

    private long getEvents(int[] whichEvents, long startTime, List<Event> out, String packageName) {
        final long endTime = System.currentTimeMillis();
        if (DEBUG) {
            Log.i(TAG, ""Looking for events "" + Arrays.toString(whichEvents)
                    + "" between "" + startTime + "" and "" + endTime);
        }
        UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        long latestTime = 0;

        // Find events.
        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            final int ev = event.getEventType();
            for (int which : whichEvents) {
                if (ev == which) {
                    if (packageName != null && !packageName.equals(event.getPackageName())) {
                        break;
                    }

                    if (out != null) {
                        out.add(event);
                    }
                    if (DEBUG) Log.i(TAG, ""Next event type "" + event.getEventType()
                            + "" time="" + event.getTimeStamp());
                    if (latestTime < event.getTimeStamp()) {
                        latestTime = event.getTimeStamp();
                    }
                    break;
                }
            }
        }

        return latestTime;
    }


    private ArrayList<Event> waitForEventCount(int[] whichEvents, long startTime, int count) {
        return waitForEventCount(whichEvents, startTime, count, null);
    }

    private ArrayList<Event> waitForEventCount(int[] whichEvents, long startTime, int count,
            String packageName) {
        final ArrayList<Event> events = new ArrayList<>();
        final long endTime = SystemClock.uptimeMillis() + TIMEOUT;
        do {
            events.clear();
            getEvents(whichEvents, startTime, events, packageName);
            if (events.size() == count) {
                return events;
            }
            if (events.size() > count) {
                fail(""Found too many events: got "" + events.size() + "", expected "" + count);
                return events;
            }
            SystemClock.sleep(10);
        } while (SystemClock.uptimeMillis() < endTime);

        fail(""Timed out waiting for "" + count + "" events, only reached "" + events.size());
        return events;
    }

    private void waitUntil(BooleanSupplier condition, boolean expected) throws Exception {
        final long sleepTimeMs = 500;
        final int count = 10;
        for (int i = 0; i < count; ++i) {
            if (condition.getAsBoolean() == expected) {
                return;
            }
            Thread.sleep(sleepTimeMs);
        }
        fail(""Condition wasn't satisfied after "" + (sleepTimeMs * count) + ""ms"");
    }

    static class AggrEventData {
        final String label;
        int count;
        long duration;
        long lastEventTime;

        AggrEventData(String label) {
            this.label = label;
        }
    }

    static class AggrAllEventsData {
        final AggrEventData interactive = new AggrEventData(""Interactive"");
        final AggrEventData nonInteractive = new AggrEventData(""Non-interactive"");
        final AggrEventData keyguardShown = new AggrEventData(""Keyguard shown"");
        final AggrEventData keyguardHidden = new AggrEventData(""Keyguard hidden"");
    }

    private SparseArray<AggrAllEventsData> getAggrEventData() {
        final long endTime = System.currentTimeMillis();

        final SparseLongArray intervalLengths = new SparseLongArray();
        intervalLengths.put(UsageStatsManager.INTERVAL_DAILY, DAY);
        intervalLengths.put(UsageStatsManager.INTERVAL_WEEKLY, WEEK);
        intervalLengths.put(UsageStatsManager.INTERVAL_MONTHLY, MONTH);
        intervalLengths.put(UsageStatsManager.INTERVAL_YEARLY, YEAR);

        final SparseArray<AggrAllEventsData> allAggr = new SparseArray<>();

        final int intervalCount = intervalLengths.size();
        for (int i = 0; i < intervalCount; i++) {
            final int intervalType = intervalLengths.keyAt(i);
            final long intervalDuration = intervalLengths.valueAt(i);
            final long startTime = endTime - (2 * intervalDuration);
            List<EventStats> statsList = mUsageStatsManager.queryEventStats(intervalType,
                    startTime, endTime);
            assertFalse(statsList.isEmpty());

            final AggrAllEventsData aggr = new AggrAllEventsData();
            allAggr.put(intervalType, aggr);

            boolean foundEvent = false;
            for (EventStats stats : statsList) {
                // Verify that each period is a day long.
                //assertLessThanOrEqual(stats.getLastTimeStamp() - stats.getFirstTimeStamp(),
                //        intervalDuration);
                AggrEventData data = null;
                switch (stats.getEventType()) {
                    case Event.SCREEN_INTERACTIVE:
                        data = aggr.interactive;
                        break;
                    case Event.SCREEN_NON_INTERACTIVE:
                        data = aggr.nonInteractive;
                        break;
                    case Event.KEYGUARD_HIDDEN:
                        data = aggr.keyguardHidden;
                        break;
                    case Event.KEYGUARD_SHOWN:
                        data = aggr.keyguardShown;
                        break;
                }
                if (data != null) {
                    foundEvent = true;
                    data.count += stats.getCount();
                    data.duration += stats.getTotalTime();
                    if (data.lastEventTime < stats.getLastEventTime()) {
                        data.lastEventTime = stats.getLastEventTime();
                    }
                }
            }

            assertTrue(""Did not find event data in interval "" + intervalType,
                    foundEvent);
        }

        return allAggr;
    }

    private void verifyCount(int oldCount, int newCount, boolean larger, String label,
            int interval) {
        if (larger) {
            if (newCount <= oldCount) {
                fail(label + "" count newer "" + newCount
                        + "" expected to be larger than older "" + oldCount
                        + "" @ interval "" + interval);
            }
        } else {
            if (newCount != oldCount) {
                fail(label + "" count newer "" + newCount
                        + "" expected to be same as older "" + oldCount
                        + "" @ interval "" + interval);
            }
        }
    }

    private void verifyDuration(long oldDur, long newDur, boolean larger, String label,
            int interval) {
        if (larger) {
            if (newDur <= oldDur) {
                fail(label + "" duration newer "" + newDur
                        + "" expected to be larger than older "" + oldDur
                        + "" @ interval "" + interval);
            }
        } else {
            if (newDur != oldDur) {
                fail(label + "" duration newer "" + newDur
                        + "" expected to be same as older "" + oldDur
                        + "" @ interval "" + interval);
            }
        }
    }

    private void verifyAggrEventData(AggrEventData older, AggrEventData newer,
            boolean countLarger, boolean durationLarger, int interval) {
        verifyCount(older.count, newer.count, countLarger, older.label, interval);
        verifyDuration(older.duration, newer.duration, durationLarger, older.label, interval);
    }

    private void verifyAggrInteractiveEventData(SparseArray<AggrAllEventsData> older,
            SparseArray<AggrAllEventsData> newer, boolean interactiveLarger,
            boolean nonInteractiveLarger) {
        for (int i = 0; i < older.size(); i++) {
            AggrAllEventsData o = older.valueAt(i);
            AggrAllEventsData n = newer.valueAt(i);
            // When we are told something is larger, that means we have transitioned
            // *out* of that state -- so the duration of that state is expected to
            // increase, but the count should stay the same (and the count of the state
            // we transition to is increased).
            final int interval = older.keyAt(i);
            verifyAggrEventData(o.interactive, n.interactive, nonInteractiveLarger,
                    interactiveLarger, interval);
            verifyAggrEventData(o.nonInteractive, n.nonInteractive, interactiveLarger,
                    nonInteractiveLarger, interval);
        }
    }

    private void verifyAggrKeyguardEventData(SparseArray<AggrAllEventsData> older,
            SparseArray<AggrAllEventsData> newer, boolean hiddenLarger,
            boolean shownLarger) {
        for (int i = 0; i < older.size(); i++) {
            AggrAllEventsData o = older.valueAt(i);
            AggrAllEventsData n = newer.valueAt(i);
            // When we are told something is larger, that means we have transitioned
            // *out* of that state -- so the duration of that state is expected to
            // increase, but the count should stay the same (and the count of the state
            // we transition to is increased).
            final int interval = older.keyAt(i);
            verifyAggrEventData(o.keyguardHidden, n.keyguardHidden, shownLarger,
                    hiddenLarger, interval);
            verifyAggrEventData(o.keyguardShown, n.keyguardShown, hiddenLarger,
                    shownLarger, interval);
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testIgnoreNonexistentPackage"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testIgnoreNonexistentPackage() throws Exception {
        final String fakePackageName = ""android.fake.package.name"";
        final int defaultValue = -1;

        setStandByBucket(fakePackageName, ""rare"");
        // Verify the above does not add a new entry to the App Standby bucket map
        Map<String, Integer> bucketMap = mUsageStatsManager.getAppStandbyBuckets();
        int bucket = bucketMap.getOrDefault(fakePackageName, defaultValue);
        assertFalse(""Meaningful bucket value "" + bucket + "" returned for "" + fakePackageName
                + "" after set-standby-bucket"", bucket > 0);

        executeShellCmd(""am get-standby-bucket "" + fakePackageName);
        // Verify the above does not add a new entry to the App Standby bucket map
        bucketMap = mUsageStatsManager.getAppStandbyBuckets();
        bucket = bucketMap.getOrDefault(fakePackageName, defaultValue);
        assertFalse(""Meaningful bucket value "" + bucket + "" returned for "" + fakePackageName
                + "" after get-standby-bucket"", bucket > 0);
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testLocusIdEventsVisibility"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testLocusIdEventsVisibility() throws Exception {
        final long startTime = System.currentTimeMillis();
        startAndDestroyActivityWithLocus();
        final long endTime = System.currentTimeMillis();

        final UsageEvents restrictedEvents = mUsageStatsManager.queryEvents(startTime, endTime);
        final UsageEvents allEvents = queryEventsAsShell(startTime, endTime);
        verifyLocusIdEventVisibility(restrictedEvents, false);
        verifyLocusIdEventVisibility(allEvents, true);
    }

    private void startAndDestroyActivityWithLocus() {
        launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS_LOCUS);
        SystemClock.sleep(500);

        // Destroy the activity
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        mUiDevice.wait(Until.gone(By.clazz(TEST_APP_PKG, TEST_APP_CLASS_LOCUS)), TIMEOUT);
        SystemClock.sleep(500);
    }

    private void verifyLocusIdEventVisibility(UsageEvents events, boolean hasPermission) {
        int locuses = 0;
        while (events.hasNextEvent()) {
            final Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));

            if (TEST_APP_PKG.equals(event.getPackageName())
                    && event.mEventType == Event.LOCUS_ID_SET) {
                locuses++;
            }
        }

        if (hasPermission) {
            assertEquals(""LOCUS_ID_SET events were not visible."", 2, locuses);
        } else {
            assertEquals(""LOCUS_ID_SET events were visible."", 0, locuses);
        }
    }

    /**
     * Assert on an app or token's usage state.
     *
     * @param entity name of the app or token
     * @param expected expected usage state, true for in use, false for not in use
     */
    private void assertAppOrTokenUsed(String entity, boolean expected, long timeout)
            throws IOException {
        final long realtimeTimeout = SystemClock.elapsedRealtime() + timeout;
        String activeUsages;
        boolean found;
        do {
            activeUsages = executeShellCmd(""dumpsys usagestats apptimelimit actives"");
            final String[] actives = activeUsages.split(""\n"");
            found = Arrays.asList(actives).contains(entity);
        } while (found != expected && SystemClock.elapsedRealtime() <= realtimeTimeout);

        if (expected) {
            assertTrue(entity + "" not found in list of active activities and tokens\n""
                    + activeUsages, found);
        } else {
            assertFalse(entity + "" found in list of active activities and tokens\n""
                    + activeUsages, found);
        }
    }

    private void dismissKeyguard() throws Exception {
        if (mKeyguardManager.isKeyguardLocked()) {
            final long startTime = getEvents(KEYGUARD_EVENTS, 0, null, null) + 1;
            executeShellCmd(""wm dismiss-keyguard"");
            final ArrayList<Event> events = waitForEventCount(KEYGUARD_EVENTS, startTime, 1);
            assertEquals(Event.KEYGUARD_HIDDEN, events.get(0).getEventType());
            SystemClock.sleep(500);
        }
    }

    private void setStandByBucket(String packageName, String bucket) throws IOException {
        executeShellCmd(""am set-standby-bucket "" + packageName + "" "" + bucket);
    }

    private String executeShellCmd(String command) throws IOException {
        return mUiDevice.executeShellCommand(command);
    }

    private UsageEvents queryEventsAsShell(long start, long end) {
        return SystemUtil.runWithShellPermissionIdentity(() ->
                mUsageStatsManager.queryEvents(start, end));
    }

    private ITestReceiver bindToTestService() throws Exception {
        final TestServiceConnection connection = new TestServiceConnection();
        final Intent intent = new Intent().setComponent(
                new ComponentName(TEST_APP_PKG, TEST_APP_CLASS_SERVICE));
        mContext.bindService(intent, connection, Context.BIND_AUTO_CREATE);
        return ITestReceiver.Stub.asInterface(connection.getService());
    }

    private class TestServiceConnection implements ServiceConnection {
        private BlockingQueue<IBinder> mBlockingQueue = new LinkedBlockingQueue<>();

        public void onServiceConnected(ComponentName componentName, IBinder service) {
            mBlockingQueue.offer(service);
        }

        public void onServiceDisconnected(ComponentName componentName) {
        }

        public IBinder getService() throws Exception {
            final IBinder service = mBlockingQueue.poll(TIMEOUT_BINDER_SERVICE_SEC,
                    TimeUnit.SECONDS);
            return service;
        }
    }

    private void runJobImmediately() throws Exception {
        TestJob.schedule(mContext);
        executeShellCmd(JOBSCHEDULER_RUN_SHELL_COMMAND
                + "" "" + mContext.getPackageName()
                + "" "" + TestJob.TEST_JOB_ID);
    }

    private boolean isAppInactiveAsPermissionlessApp(String pkg) throws Exception {
        final ITestReceiver testService = bindToTestService();
        return testService.isAppInactive(pkg);
    }

    private int createUser(String name) throws Exception {
        final String output = executeShellCmd(
                ""pm create-user "" + name);
        if (output.startsWith(""Success"")) {
            return mOtherUser = Integer.parseInt(output.substring(output.lastIndexOf("" "")).trim());
        }
        throw new IllegalStateException(String.format(""Failed to create user: %s"", output));
    }

    private boolean removeUser(final int userId) throws Exception {
        final String output = executeShellCmd(String.format(""pm remove-user %s"", userId));
        if (output.startsWith(""Error"")) {
            return false;
        }
        return true;
    }

    private boolean startUser(int userId, boolean waitFlag) throws Exception {
        String cmd = ""am start-user "" + (waitFlag ? ""-w "" : """") + userId;

        final String output = executeShellCmd(cmd);
        if (output.startsWith(""Error"")) {
            return false;
        }
        if (waitFlag) {
            String state = executeShellCmd(""am get-started-user-state "" + userId);
            if (!state.contains(""RUNNING_UNLOCKED"")) {
                return false;
            }
        }
        return true;
    }

    private boolean stopUser(int userId, boolean waitFlag, boolean forceFlag)
            throws Exception {
        StringBuilder cmd = new StringBuilder(""am stop-user "");
        if (waitFlag) {
            cmd.append(""-w "");
        }
        if (forceFlag) {
            cmd.append(""-f "");
        }
        cmd.append(userId);

        final String output = executeShellCmd(cmd.toString());
        if (output.contains(""Error: Can't stop system user"")) {
            return false;
        }
        return true;
    }

    private void installExistingPackageAsUser(String packageName, int userId)
            throws Exception {
        executeShellCmd(
                String.format(""pm install-existing --user %d --wait %s"", userId, packageName));
    }

    private void sleepDevice() throws Exception {
        if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            mUiDevice.pressKeyCode(KeyEvent.KEYCODE_SLEEP);
        } else {
            mUiDevice.sleep();
        }

        waitUntil(() -> {
            try {
                return mUiDevice.isScreenOn();
            } catch(Exception e) {
                return true;
            }
        }, false);
    }
}"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.text.cts.FontResourceTest"	"testRemoteResource"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/cts/FontResourceTest.java"	""	"public void testRemoteResource() throws Exception {
        Context context = InstrumentationRegistry.getTargetContext();

        Context freeContext = context.createPackageContext(
                RESOURCE_PACKAGE, Context.CONTEXT_IGNORE_SECURITY);
        Context restrictContext = context.createPackageContext(
                RESOURCE_PACKAGE, Context.CONTEXT_RESTRICTED);

        // This expectation is for verifying the precondition of the test case. If the context
        // ignores the security, loads the custom font and TextView gives the width with it. If the
        // context is restricted, the custom font should not be loaded and TextView gives the width
        // different from the one with the custom font.
        // The custom font has 3em for ""a"" character. The text is ""aaa"", then 9em = 900px is the
        // expected width.
        assertThat(measureText(inflateWithInflator(freeContext)))
                .isEqualTo(REMOTE_FONT_TEXT_WIDTH);
        assertThat(measureText(inflateWithInflator(restrictContext)))
                .isNotEqualTo(REMOTE_FONT_TEXT_WIDTH);

        // The RemoteView should ignore the custom font files.
        assertThat(measureText(inflateWithRemoteViews(context)))
                .isNotEqualTo(REMOTE_FONT_TEXT_WIDTH);
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.provider.cts.calendar.CalendarTest"	"testBulkUpdate"	"CtsCalendarProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/calendarprovider/src/android/provider/cts/calendar/CalendarTest.java"	""	"public void testBulkUpdate() {
        String account = ""bup_account"";
        int seed = 0;

        // Clean up just in case
        CalendarHelper.deleteCalendarByAccount(mContentResolver, account);

        // Create calendar
        long calendarId = createAndVerifyCalendar(account, seed++, null);
        String calendarIdStr = String.valueOf(calendarId);

        // Create events
        ContentValues eventValues;
        eventValues = EventHelper.getNewEventValues(account, seed++, calendarId, true);
        long eventId1 = createAndVerifyEvent(account, seed, calendarId, true, eventValues);

        eventValues = EventHelper.getNewEventValues(account, seed++, calendarId, true);
        long eventId2 = createAndVerifyEvent(account, seed, calendarId, true, eventValues);

        // Update the ""description"" field in all events in this calendar.
        String newDescription = ""bulk edit"";
        ContentValues updateValues = new ContentValues();
        updateValues.put(Events.DESCRIPTION, newDescription);

        // Must be sync adapter to do a bulk update.
        Uri uri = asSyncAdapter(Events.CONTENT_URI, account, CTS_TEST_TYPE);
        int count = mContentResolver.update(uri, updateValues, SQL_WHERE_CALENDAR_ID,
                new String[] { calendarIdStr });

        // Check to see if the changes went through.
        Uri eventUri = Events.CONTENT_URI;
        Cursor c = mContentResolver.query(eventUri, new String[] { Events.DESCRIPTION },
                SQL_WHERE_CALENDAR_ID, new String[] { calendarIdStr }, null);
        assertEquals(2, c.getCount());
        while (c.moveToNext()) {
            assertEquals(newDescription, c.getString(0));
        }
        c.close();

        // delete the calendar
        removeAndVerifyCalendar(account, calendarId);
    }

    /**
     * Tests the content provider's enforcement of restrictions on who is allowed to modify
     * specific columns in a Calendar.
     * <p>
     * This attempts to create a new row in the Calendar table, specifying one restricted
     * column at a time.
     */
    @MediumTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.ExactAlarmsTest"	"removeFromWhitelists"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/ExactAlarmsTest.java"	""	"/*
 *.
 */

package android.alarmmanager.cts;

import static android.alarmmanager.cts.AppStandbyTests.setTestAppStandbyBucket;
import static android.app.usage.UsageStatsManager.STANDBY_BUCKET_ACTIVE;
import static android.app.usage.UsageStatsManager.STANDBY_BUCKET_WORKING_SET;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeFalse;

import android.alarmmanager.alarmtestapp.cts.sdk30.TestReceiver;
import android.alarmmanager.util.AlarmManagerDeviceConfigHelper;
import android.app.Activity;
import android.alarmmanager.alarmtestapp.cts.PermissionStateChangedReceiver;
import android.app.AlarmManager;
import android.app.AppOpsManager;
import android.app.PendingIntent;
import android.app.compat.CompatChanges;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.PowerWhitelistManager;
import android.os.Process;
import android.os.SystemClock;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.provider.Settings;
import android.util.Log;

import com.android.compatibility.common.util.AppOpsUtils;
import com.android.compatibility.common.util.AppStandbyUtils;
import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.ShellUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.TestUtils;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.Description;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

@AppModeFull
@RunWith(AndroidJUnit4.class)
public class ExactAlarmsTest {
    /**
     * TODO (b/182835530): Add more tests for the following:
     *
     * Pre-S apps can:
     * - use setAlarmClock freely -- no temp-allowlist
     * - use setExactAndAWI with 7 / hr quota with standby and temp-allowlist
     * - use setInexactAndAWI with 7 / hr quota with standby-bucket ""ACTIVE"" and temp-allowlist
     *
     * S+ apps with permission can:
     * - use setInexactAWI with low quota + standby and *no* temp-allowlist.
     */
    private static final String TAG = ExactAlarmsTest.class.getSimpleName();

    private static final int ALLOW_WHILE_IDLE_QUOTA = 5;
    private static final long ALLOW_WHILE_IDLE_WINDOW = 10_000;
    private static final int ALLOW_WHILE_IDLE_COMPAT_QUOTA = 3;

    /**
     * Waiting generously long for success because the system can sometimes be slow to
     * provide expected behavior.
     * A different and shorter duration should be used while waiting for no-failure, because
     * even if the system is slow to fail in some cases, it would still cause some
     * flakiness and get flagged for investigation.
     */
    private static final long DEFAULT_WAIT_FOR_SUCCESS = 30_000;

    private static final String TEST_APP_PACKAGE = ""android.alarmmanager.alarmtestapp.cts"";

    private static final Context sContext = InstrumentationRegistry.getTargetContext();
    private final AlarmManager mAlarmManager = sContext.getSystemService(AlarmManager.class);
    private final AppOpsManager mAppOpsManager = sContext.getSystemService(AppOpsManager.class);
    private final PowerWhitelistManager mWhitelistManager = sContext.getSystemService(
            PowerWhitelistManager.class);
    private final PackageManager mPackageManager = sContext.getPackageManager();
    private final ComponentName mPermissionChangeReceiver = new ComponentName(TEST_APP_PACKAGE,
            PermissionStateChangedReceiver.class.getName());

    private final AlarmManagerDeviceConfigHelper mDeviceConfigHelper =
            new AlarmManagerDeviceConfigHelper();
    private final Random mIdGenerator = new Random(6789);

    @Rule
    public DumpLoggerRule mFailLoggerRule = new DumpLoggerRule(TAG) {
        @Override
        protected void failed(Throwable e, Description description) {
            super.failed(e, description);
            AlarmReceiver.dumpState();
        }
    };

    @Before
    @After
    public void resetAppOp() throws IOException {
        AppOpsUtils.reset(sContext.getOpPackageName());
        AppOpsUtils.reset(TEST_APP_PACKAGE);
    }

    @Before
    public void updateAlarmManagerConstants() {
        mDeviceConfigHelper.with(""min_futurity"", 0L)
                .with(""allow_while_idle_quota"", ALLOW_WHILE_IDLE_QUOTA)
                .with(""allow_while_idle_compat_quota"", ALLOW_WHILE_IDLE_COMPAT_QUOTA)
                .with(""allow_while_idle_window"", ALLOW_WHILE_IDLE_WINDOW)
                .with(""crash_non_clock_apps"", true)
                .with(""kill_on_schedule_exact_alarm_revoked"", false)
                .commitAndAwaitPropagation();
    }

    @Before
    public void putDeviceToIdle() {
        SystemUtil.runShellCommandForNoOutput(""dumpsys battery reset"");
        SystemUtil.runShellCommand(""cmd deviceidle force-idle deep"");
    }

    @Before
    public void enableChange() {
        if (!CompatChanges.isChangeEnabled(AlarmManager.REQUIRE_EXACT_ALARM_PERMISSION)) {
            SystemUtil.runShellCommand(""am compat enable --no-kill REQUIRE_EXACT_ALARM_PERMISSION ""
                    + sContext.getOpPackageName(), output -> output.contains(""Enabled""));
        }
    }

    @After
    public void resetChanges() {
        // This is needed because compat persists the overrides beyond package uninstall
        SystemUtil.runShellCommand(""am compat reset --no-kill REQUIRE_EXACT_ALARM_PERMISSION ""
                + sContext.getOpPackageName());
    }

    @After
    public void removeFromWhitelists() {
        removeFromWhitelists(sContext.getOpPackageName());
    }

    private void removeFromWhitelists(String packageName) {
        SystemUtil.runWithShellPermissionIdentity(
                () -> mWhitelistManager.removeFromWhitelist(packageName));
        SystemUtil.runShellCommand(""cmd deviceidle tempwhitelist -r "" + packageName);
    }

    @After
    public void restoreBatteryState() {
        SystemUtil.runShellCommand(""cmd deviceidle unforce"");
        SystemUtil.runShellCommandForNoOutput(""dumpsys battery reset"");
    }

    @After
    public void restorePermissionReceiverState() {
        SystemUtil.runWithShellPermissionIdentity(
                () -> mPackageManager.setComponentEnabledSetting(mPermissionChangeReceiver,
                        PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,
                        PackageManager.DONT_KILL_APP));
    }

    @After
    public void restoreAlarmManagerConstants() {
        mDeviceConfigHelper.restoreAll();
    }

    private void revokeAppOp() {
        revokeAppOp(sContext.getOpPackageName());
    }

    private void revokeAppOp(String packageName) {
        setAppOp(packageName, AppOpsManager.MODE_IGNORED);
    }

    private void setAppOp(String packageName, int mode) {
        final int uid = getPackageUid(packageName);

        SystemUtil.runWithShellPermissionIdentity(
                () -> {
                    mAppOpsManager.setUidMode(AppOpsManager.OPSTR_SCHEDULE_EXACT_ALARM, uid, mode);
                    return null;
                }
        );
    }

    private int getPackageUid(String packageName) {
        try {
            return sContext.getPackageManager().getPackageUid(packageName, 0);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static PendingIntent getAlarmSender(int id, boolean quotaed) {
        final Intent alarmAction = new Intent(AlarmReceiver.ALARM_ACTION)
                .setClass(sContext, AlarmReceiver.class)
                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
                .putExtra(AlarmReceiver.EXTRA_ALARM_ID, id)
                .putExtra(AlarmReceiver.EXTRA_QUOTAED, quotaed);
        return PendingIntent.getBroadcast(sContext, 0, alarmAction,
                PendingIntent.FLAG_MUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.ExactAlarmsTest"	"exactAlarmPermissionElevatesBucket"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/ExactAlarmsTest.java"	""	"// TODO (b/185181884): Remove once standby buckets can be reliably manipulated from tests.
    @Ignore(""Cannot reliably test bucket manipulation yet"")
    public void exactAlarmPermissionElevatesBucket() throws Exception {
        mDeviceConfigHelper.without(""exact_alarm_deny_list"").commitAndAwaitPropagation();

        setTestAppStandbyBucket(""active"");
        assertEquals(STANDBY_BUCKET_ACTIVE, AppStandbyUtils.getAppStandbyBucket(TEST_APP_PACKAGE));

        setTestAppStandbyBucket(""frequent"");
        assertEquals(STANDBY_BUCKET_WORKING_SET,
                AppStandbyUtils.getAppStandbyBucket(TEST_APP_PACKAGE));

        setTestAppStandbyBucket(""rare"");
        assertEquals(STANDBY_BUCKET_WORKING_SET,
                AppStandbyUtils.getAppStandbyBucket(TEST_APP_PACKAGE));
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.ExactAlarmsTest"	"setExactAwiWithoutPermissionWithWhitelist"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/ExactAlarmsTest.java"	""	"public void setExactAwiWithoutPermissionWithWhitelist() throws Exception {
        revokeAppOp();
        whitelistTestApp();
        final long now = SystemClock.elapsedRealtime();
        // This is the user whitelist, so the app should get unrestricted alarms.
        final int numAlarms = 100;   // Number much higher than any quota.
        for (int i = 0; i < numAlarms; i++) {
            final int id = mIdGenerator.nextInt();
            mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, now,
                    getAlarmSender(id, false));
            assertTrue(""Alarm "" + id + "" not received"",
                    AlarmReceiver.waitForAlarm(id, DEFAULT_WAIT_FOR_SUCCESS));
        }
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.ExactAlarmsTest"	"setExactAwiWithPermissionAndWhitelist"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/ExactAlarmsTest.java"	""	"public void setExactAwiWithPermissionAndWhitelist() throws Exception {
        whitelistTestApp();
        final long now = SystemClock.elapsedRealtime();
        // The user whitelist takes precedence, so the app should get unrestricted alarms.
        final int numAlarms = 100;   // Number much higher than any quota.
        for (int i = 0; i < numAlarms; i++) {
            final int id = mIdGenerator.nextInt();
            mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, now,
                    getAlarmSender(id, false));
            assertTrue(""Alarm "" + id + "" not received"",
                    AlarmReceiver.waitForAlarm(id, DEFAULT_WAIT_FOR_SUCCESS));
        }
    }

    private static void reclaimQuota(int quotaToReclaim) {
        final long eligibleAt = getNextEligibleTime(quotaToReclaim);
        long now;
        while ((now = SystemClock.elapsedRealtime()) < eligibleAt) {
            try {
                Thread.sleep(eligibleAt - now);
            } catch (InterruptedException e) {
                Log.e(TAG, ""Thread interrupted while reclaiming quota!"", e);
            }
        }
    }

    private static long getNextEligibleTime(int quotaToReclaim) {
        long t = AlarmReceiver.getNthLastAlarmTime(ALLOW_WHILE_IDLE_QUOTA - quotaToReclaim + 1);
        return t + ALLOW_WHILE_IDLE_WINDOW;
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testQueryOnRedactionUri"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	"public void testQueryOnRedactionUri() throws Exception {
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        final Uri uri = MediaStore.scanFile(getContentResolver(), img);
        final Uri redactedUri = MediaStore.getRedactedUri(getContentResolver(), uri);
        final Cursor uriCursor = getContentResolver().query(uri, null, null, null);
        final String redactedUriDir = "".transforms/synthetic/redacted"";
        final String redactedUriDirAbsolutePath =
                Environment.getExternalStorageDirectory() + ""/"" + redactedUriDir;
        try {
            assertNotNull(uriCursor);
            assertThat(uriCursor.moveToFirst()).isTrue();

            final Cursor redactedUriCursor = getContentResolver().query(redactedUri, null, null,
                    null);
            assertNotNull(redactedUriCursor);
            assertThat(redactedUriCursor.moveToFirst()).isTrue();

            assertEquals(redactedUriCursor.getColumnCount(), uriCursor.getColumnCount());

            final String data = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.DATA);
            final String redactedUriDisplayName = redactedUri.getLastPathSegment() + "".jpg"";
            assertEquals(redactedUriDirAbsolutePath + ""/"" + redactedUriDisplayName, data);

            final String name = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.DISPLAY_NAME);
            assertEquals(redactedUriDisplayName, name);

            final String relativePath = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.RELATIVE_PATH);
            assertEquals(redactedUriDir, relativePath);

            final String bucketDisplayName = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.BUCKET_DISPLAY_NAME);
            assertEquals(redactedUriDir, bucketDisplayName);

            final String docId = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.DOCUMENT_ID);
            assertNull(docId);

            final String insId = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.INSTANCE_ID);
            assertNull(insId);

            final String bucId = getStringFromCursor(redactedUriCursor,
                    MediaStore.MediaColumns.BUCKET_ID);
            assertNull(bucId);

            final Collection<String> updatedCols = Arrays.asList(MediaStore.MediaColumns._ID,
                    MediaStore.MediaColumns.DISPLAY_NAME,
                    MediaStore.MediaColumns.RELATIVE_PATH,
                    MediaStore.MediaColumns.BUCKET_DISPLAY_NAME,
                    MediaStore.MediaColumns.DATA,
                    MediaStore.MediaColumns.DOCUMENT_ID,
                    MediaStore.MediaColumns.INSTANCE_ID,
                    MediaStore.MediaColumns.BUCKET_ID);
            for (String colName : uriCursor.getColumnNames()) {
                if (!updatedCols.contains(colName)) {
                    if (uriCursor.getType(uriCursor.getColumnIndex(colName)) == FIELD_TYPE_BLOB) {
                        assertThat(
                                Arrays.equals(uriCursor.getBlob(uriCursor.getColumnIndex(colName)),
                                        redactedUriCursor.getBlob(redactedUriCursor.getColumnIndex(
                                                colName)))).isTrue();
                    } else {
                        assertEquals(getStringFromCursor(uriCursor, colName),
                                getStringFromCursor(redactedUriCursor, colName));
                    }
                }
            }
        } finally {
            img.delete();
        }
    }

    /*
     * Verify that app can't open the shared redacted URI for write.
     **/"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.display.cts.BrightnessTest"	"testNoColorSampleData"	"CtsDisplayTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	"public void testNoColorSampleData() throws InterruptedException {
          // Don't run as there is no app that has permission to access slider usage.
        assumeTrue(
                numberOfSystemAppsWithPermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE) > 0);

        // Don't run as there is no app that has permission to push curves.
        assumeTrue(numberOfSystemAppsWithPermission(
                Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS) > 0);

        int previousBrightness = getSystemSetting(Settings.System.SCREEN_BRIGHTNESS);
        int previousBrightnessMode =
                getSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE);
        try {
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE,
                    Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
            int mode = getSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE);
            assertEquals(Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC, mode);

            grantPermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE);
            grantPermission(Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS);

            // Set brightness config to not sample color.
            BrightnessConfiguration config =
                    new BrightnessConfiguration.Builder(
                            new float[]{0.0f, 1000.0f},new float[]{20.0f, 500.0f})
                            .setShouldCollectColorSamples(false).build();
            mDisplayManager.setBrightnessConfiguration(config);

            // Setup and generate one slider event.
            recordSliderEvents();
            waitForFirstSliderEvent();
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, 20);
            List<BrightnessChangeEvent> newEvents = getNewEvents(1);

            // No color samples.
            assertEquals(0, newEvents.get(0).colorSampleDuration);
            assertNull(newEvents.get(0).colorValueBuckets);

            // No test for sampling color as support is optional.
        } finally {
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, previousBrightness);
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE, previousBrightnessMode);
        }
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.os.cts.BuildTest"	"testMediaPerformanceClass"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/BuildTest.java"	""	"public void testMediaPerformanceClass() {
        // media performance class value of 0 is valid
        if (Build.VERSION.MEDIA_PERFORMANCE_CLASS == 0) {
            return;
        }

        assertTrue(
                ""Media Performance Class "" + Build.VERSION.MEDIA_PERFORMANCE_CLASS
                        + "" is invalid; must be at least VERSION_CODES.R"",
                Build.VERSION.MEDIA_PERFORMANCE_CLASS >= Build.VERSION_CODES.R);
        assertTrue(
                ""Media Performance Class "" + Build.VERSION.MEDIA_PERFORMANCE_CLASS
                        + "" is invalid; must be at most VERSION.SDK_INT"",
                // we use RESOURCES_SDK_INT to account for active development versions
                Build.VERSION.MEDIA_PERFORMANCE_CLASS <= Build.VERSION.RESOURCES_SDK_INT);
    }

    static final String RO_DEBUGGABLE = ""ro.debuggable"";
    private static final String RO_SECURE = ""ro.secure"";

    /**
     * Assert that the device is a secure, not debuggable user build.
     *
     * Debuggable devices allow adb root and have the su command, allowing
     * escalations to root and unauthorized access to application data.
     *
     * Note: This test will fail on userdebug / eng devices, but should pass
     * on production (user) builds.
     */
    @RestrictedBuildTest
    @AppModeFull(reason = ""Instant apps cannot access APIs"")"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.ApexSignatureVerificationTest"	"getApexPackageList"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApexSignatureVerificationTest.java"	""	"/*
 *.
 */

package android.appsecurity.cts;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.platform.test.annotations.RestrictedBuildTest;

import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
import com.android.tradefed.util.FileUtil;
import com.android.tradefed.util.ZipUtil;

import org.hamcrest.CustomTypeSafeMatcher;
import org.hamcrest.Matcher;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ErrorCollector;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runners.model.Statement;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;

/**
 * Tests for APEX signature verification to ensure preloaded APEXes
 * DO NOT signed with well-known keys.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class ApexSignatureVerificationTest extends BaseHostJUnit4Test {

    private static final String TEST_BASE = ""ApexSignatureVerificationTest"";
    private static final String TEST_APEX_SOURCE_DIR_PREFIX = ""tests-apex_"";
    private static final String APEX_PUB_KEY_NAME = ""apex_pubkey"";

    private static final Pattern WELL_KNOWN_PUBKEY_PATTERN = Pattern.compile(
            ""^apexsigverify\\/.*.avbpubkey"");

    private static boolean mHasTestFailure;

    private static File mBasePath;
    private static File mWellKnownKeyStorePath;
    private static File mArchiveZip;

    private static Map<String, String> mPreloadedApexPathMap = new HashMap<>();
    private static Map<String, File> mLocalApexFileMap = new HashMap<>();
    private static Map<String, File> mExtractedTestDirMap = new HashMap<>();
    private static List<File> mWellKnownKeyFileList = new ArrayList<>();
    private ITestDevice mDevice;

    @Rule
    public final ErrorCollector mErrorCollector = new ErrorCollector();

    @Before
    public void setUp() throws Exception {
        mDevice = getDevice();
        if (mBasePath == null && mWellKnownKeyStorePath == null
                && mExtractedTestDirMap.size() == 0) {
            mBasePath = FileUtil.createTempDir(TEST_BASE);
            mBasePath.deleteOnExit();
            mWellKnownKeyStorePath = FileUtil.createTempDir(""wellknownsignatures"", mBasePath);
            mWellKnownKeyStorePath.deleteOnExit();
            pullWellKnownSignatures();
            getApexPackageList();
            pullApexFiles();
            extractApexFiles();
        }
    }

    @AfterClass
    public static void tearDownClass() throws IOException {
        if (mArchiveZip == null && mHasTestFailure) {
            // Archive all operation data and materials in host
            // /tmp/ApexSignatureVerificationTest.zip
            // in case the test result is not expected and need to debug.
            mArchiveZip = ZipUtil.createZip(mBasePath, mBasePath.getName());
        }
    }

    @Rule
    public final OnFailureRule mDumpOnFailureRule = new OnFailureRule() {
        @Override
        protected void onTestFailure(Statement base, Description description, Throwable t) {
            mHasTestFailure = true;
        }
    };"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.ApexSignatureVerificationTest"	"testApexIncludePubKey"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApexSignatureVerificationTest.java"	""	"public void testApexIncludePubKey() {
        for (Map.Entry<String, File> entry : mExtractedTestDirMap.entrySet()) {
            final File pubKeyFile = FileUtil.findFile(entry.getValue(), APEX_PUB_KEY_NAME);

            assertWithMessage(""apex:"" + entry.getKey() + "" do not contain pubkey"").that(
                    pubKeyFile.exists()).isTrue();
        }
    }

    /**
     * Assert that the preloaded apexes are secure, not signed with wellknown keys.
     *
     * Debuggable aosp or gsi rom could not preload official apexes module allowing.
     *
     * Note: This test will fail on userdebug / eng devices, but should pass
     * on production (user) builds.
     */
    @SuppressWarnings(""productionOnly"")
    @RestrictedBuildTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.security.cts.BannedFilesTest"	"testNoSystemCmdSocket"	"CtsSecurityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/BannedFilesTest.java"	""	"public void testNoSystemCmdSocket() {
        assertFalse(""/dev/socket/fota"", new File(""/dev/socket/fota"").exists());
    }

    @RestrictedBuildTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.security.cts.BannedFilesTest"	"testNoSu"	"CtsSecurityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/BannedFilesTest.java"	""	"public void testNoSu() {
        assertFalse(""/sbin/su"",        new File(""/sbin/su"").exists());
        assertFalse(""/system/bin/su"",  new File(""/system/bin/su"").exists());
        assertFalse(""/system/sbin/su"", new File(""/system/sbin/su"").exists());
        assertFalse(""/system/xbin/su"", new File(""/system/xbin/su"").exists());
        assertFalse(""/vendor/bin/su"",  new File(""/vendor/bin/su"").exists());
    }

    @RestrictedBuildTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.security.cts.SELinuxHostTest"	"testCollectDeviceInfo"	"CtsSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/SELinuxHostTest.java"	""	"/*
 *.
 */

package android.security.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.platform.test.annotations.RestrictedBuildTest;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.compatibility.common.tradefed.targetprep.DeviceInfoCollector;
import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
import com.android.tradefed.util.FileUtil;

import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

/**
 * Host-side SELinux tests.
 *
 * These tests analyze the policy file in use on the subject device directly or
 * run as the shell user to evaluate aspects of the state of SELinux on the test
 * device which otherwise would not be available to a normal apk.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class SELinuxHostTest extends BaseHostJUnit4Test {

    // Keep in sync with AndroidTest.xml
    private static final String DEVICE_INFO_DEVICE_DIR = ""/sdcard/device-info-files/"";
    // Keep in sync with com.android.compatibility.common.deviceinfo.VintfDeviceInfo
    private static final String VINTF_DEVICE_CLASS = ""VintfDeviceInfo"";
    // Keep in sync with
    // com.android.compatibility.common.deviceinfo.DeviceInfo#testCollectDeviceInfo()
    private static final String DEVICE_INFO_SUFFIX = "".deviceinfo.json"";
    private static final String VINTF_DEVICE_JSON = VINTF_DEVICE_CLASS + DEVICE_INFO_SUFFIX;
    // Keep in sync with com.android.compatibility.common.deviceinfo.VintfDeviceInfo
    private static final String SEPOLICY_VERSION_JSON_KEY = ""sepolicy_version"";
    private static final String PLATFORM_SEPOLICY_VERSION_JSON_KEY = ""platform_sepolicy_version"";

    private static final Map<ITestDevice, File> cachedDevicePolicyFiles = new HashMap<>(1);
    private static final Map<ITestDevice, File> cachedDevicePlatFcFiles = new HashMap<>(1);
    private static final Map<ITestDevice, File> cachedDeviceNonplatFcFiles = new HashMap<>(1);
    private static final Map<ITestDevice, File> cachedDeviceVendorManifest = new HashMap<>(1);
    private static final Map<ITestDevice, File> cachedDeviceVintfJson = new HashMap<>(1);
    private static final Map<ITestDevice, File> cachedDeviceSystemPolicy = new HashMap<>(1);

    private File sepolicyAnalyze;
    private File checkSeapp;
    private File checkFc;
    private File aospSeappFile;
    private File aospFcFile;
    private File aospPcFile;
    private File aospSvcFile;
    private File devicePolicyFile;
    private File deviceSystemPolicyFile;
    private File devicePlatSeappFile;
    private File deviceNonplatSeappFile;
    private File devicePlatFcFile;
    private File deviceNonplatFcFile;
    private File devicePcFile;
    private File deviceSvcFile;
    private File seappNeverAllowFile;
    private File libsepolwrap;
    private File libcpp;
    private File copyLibcpp;
    private File sepolicyTests;

    private IBuildInfo mBuild;

    /**
     * A reference to the device under test.
     */
    private ITestDevice mDevice;

    public static File copyResourceToTempFile(String resName) throws IOException {
        InputStream is = SELinuxHostTest.class.getResourceAsStream(resName);
        File tempFile = File.createTempFile(""SELinuxHostTest"", "".tmp"");
        FileOutputStream os = new FileOutputStream(tempFile);
        byte[] buf = new byte[1024];
        int len;

        while ((len = is.read(buf)) != -1) {
            os.write(buf, 0, len);
        }
        os.flush();
        os.close();
        tempFile.deleteOnExit();
        return tempFile;
    }

    private static void appendTo(String dest, String src) throws IOException {
        try (FileInputStream is = new FileInputStream(new File(src));
             FileOutputStream os = new FileOutputStream(new File(dest))) {
            byte[] buf = new byte[1024];
            int len;

            while ((len = is.read(buf)) != -1) {
                os.write(buf, 0, len);
            }
        }
    }

    @Before
    public void setUp() throws Exception {
        mDevice = getDevice();
        mBuild = getBuild();
        // Assumes every test in this file asserts a requirement of CDD section 9.
        assumeSecurityModelCompat();

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mBuild);
        sepolicyAnalyze = copyResourceToTempFile(""/sepolicy-analyze"");
        sepolicyAnalyze.setExecutable(true);

        devicePolicyFile = getDevicePolicyFile(mDevice);
        if (isSepolicySplit(mDevice)) {
            devicePlatFcFile = getDeviceFile(mDevice, cachedDevicePlatFcFiles,
                    ""/system/etc/selinux/plat_file_contexts"", ""plat_file_contexts"");
            if (mDevice.doesFileExist(""/vendor/etc/selinux/nonplat_file_contexts"")){
                // Old nonplat_* naming can be present if a framework-only OTA was done.
                deviceNonplatFcFile = getDeviceFile(mDevice, cachedDeviceNonplatFcFiles,
                        ""/vendor/etc/selinux/nonplat_file_contexts"", ""nonplat_file_contexts"");
            } else {
                deviceNonplatFcFile = getDeviceFile(mDevice, cachedDeviceNonplatFcFiles,
                        ""/vendor/etc/selinux/vendor_file_contexts"", ""vendor_file_contexts"");
            }
            deviceSystemPolicyFile =
                    android.security.cts.SELinuxHostTest.getDeviceSystemPolicyFile(mDevice);
        } else {
            devicePlatFcFile = getDeviceFile(mDevice, cachedDevicePlatFcFiles,
                    ""/plat_file_contexts"", ""plat_file_contexts"");
            deviceNonplatFcFile = getDeviceFile(mDevice, cachedDeviceNonplatFcFiles,
                    ""/vendor_file_contexts"", ""vendor_file_contexts"");
        }
    }

    private void assumeSecurityModelCompat() throws Exception {
        // This feature name check only applies to devices that first shipped with
        // SC or later.
        final int firstApiLevel = Math.min(PropertyUtil.getFirstApiLevel(mDevice),
                PropertyUtil.getVendorApiLevel(mDevice));
        if (firstApiLevel >= 31) {
            assumeTrue(""Skipping test: FEATURE_SECURITY_MODEL_COMPATIBLE missing."",
                    getDevice().hasFeature(""feature:android.hardware.security.model.compatible""));
        }
    }

    /*
     * IMPLEMENTATION DETAILS: We cache some host-side policy files on per-device basis (in case
     * CTS supports running against multiple devices at the same time). HashMap is used instead
     * of WeakHashMap because in the grand scheme of things, keeping ITestDevice and
     * corresponding File objects from being garbage-collected is not a big deal in CTS. If this
     * becomes a big deal, this can be switched to WeakHashMap.
     */
    private static File getDeviceFile(ITestDevice device,
            Map<ITestDevice, File> cache, String deviceFilePath,
            String tmpFileName) throws Exception {
        if (!device.doesFileExist(deviceFilePath)){
            throw new Exception();
        }
        File file;
        synchronized (cache) {
            file = cache.get(device);
        }
        if (file != null) {
            return file;
        }
        file = File.createTempFile(tmpFileName, "".tmp"");
        file.deleteOnExit();
        device.pullFile(deviceFilePath, file);
        synchronized (cache) {
            cache.put(device, file);
        }
        return file;
    }

    private static File buildSystemPolicy(ITestDevice device, Map<ITestDevice, File> cache,
            String tmpFileName) throws Exception {
        File builtPolicyFile;
        synchronized (cache) {
            builtPolicyFile = cache.get(device);
        }
        if (builtPolicyFile != null) {
            return builtPolicyFile;
        }


        builtPolicyFile = File.createTempFile(tmpFileName, "".tmp"");
        builtPolicyFile.deleteOnExit();

        File secilc = copyResourceToTempFile(""/secilc"");
        secilc.setExecutable(true);

        File systemSepolicyCilFile = File.createTempFile(""plat_sepolicy"", "".cil"");
        systemSepolicyCilFile.deleteOnExit();
        File fileContextsFile = File.createTempFile(""file_contexts"", "".txt"");
        fileContextsFile.deleteOnExit();

        assertTrue(device.pullFile(""/system/etc/selinux/plat_sepolicy.cil"", systemSepolicyCilFile));

        ProcessBuilder pb = new ProcessBuilder(
            secilc.getAbsolutePath(),
            ""-m"", ""-M"", ""true"", ""-c"", ""30"",
            ""-o"", builtPolicyFile.getAbsolutePath(),
     ""-f"", fileContextsFile.getAbsolutePath(),
            systemSepolicyCilFile.getAbsolutePath());
        pb.redirectOutput(ProcessBuilder.Redirect.PIPE);
        pb.redirectErrorStream(true);
        Process p = pb.start();
        p.waitFor();
        BufferedReader result = new BufferedReader(new InputStreamReader(p.getInputStream()));
        String line;
        StringBuilder errorString = new StringBuilder();
        while ((line = result.readLine()) != null) {
            errorString.append(line);
            errorString.append(""\n"");
        }
        assertTrue(errorString.toString(), errorString.length() == 0);

        synchronized (cache) {
            cache.put(device, builtPolicyFile);
        }
        return builtPolicyFile;
    }

    // NOTE: cts/tools/selinux depends on this method. Rename/change with caution.
    /**
     * Returns the host-side file containing the SELinux policy of the device under test.
     */
    public static File getDevicePolicyFile(ITestDevice device) throws Exception {
        return getDeviceFile(device, cachedDevicePolicyFiles, ""/sys/fs/selinux/policy"", ""sepolicy"");
    }

    // NOTE: cts/tools/selinux depends on this method. Rename/change with caution.
    /**
     * Returns the host-side file containing the system SELinux policy of the device under test.
     */
    public static File getDeviceSystemPolicyFile(ITestDevice device) throws Exception {
        return buildSystemPolicy(device, cachedDeviceSystemPolicy, ""system_sepolicy"");
    }

    // NOTE: cts/tools/selinux depends on this method. Rename/change with caution.
    /**
     * Returns the major number of sepolicy version of device's vendor implementation.
     */
    public static int getVendorSepolicyVersion(IBuildInfo build, ITestDevice device)
            throws Exception {

        // Try different methods to get vendor SEPolicy version in the following order:
        // 1. Retrieve from IBuildInfo as stored by DeviceInfoCollector (relies on #2)
        // 2. If it fails, retrieve from device info JSON file stored on the device
        //    (relies on android.os.VintfObject)
        // 3. If it fails, retrieve from raw VINTF device manifest files by guessing its path on
        //    the device
        // Usually, the method #1 should work. If it doesn't, fallback to method #2 and #3. If
        // none works, throw the error from method #1.
        Exception buildInfoEx;
        try {
            return getVendorSepolicyVersionFromBuildInfo(build);
        } catch (Exception ex) {
            CLog.e(""getVendorSepolicyVersionFromBuildInfo failed: "", ex);
            buildInfoEx = ex;
        }
        try {
            return getVendorSepolicyVersionFromDeviceJson(device);
        } catch (Exception ex) {
            CLog.e(""getVendorSepolicyVersionFromDeviceJson failed: "", ex);
        }
        try {
            return getVendorSepolicyVersionFromManifests(device);
        } catch (Exception ex) {
            CLog.e(""getVendorSepolicyVersionFromManifests failed: "", ex);
            throw buildInfoEx;
        }
    }

    /**
     * Retrieve the major number of sepolicy version from VINTF device info stored in the given
     * IBuildInfo by {@link DeviceInfoCollector}.
     */
    private static int getVendorSepolicyVersionFromBuildInfo(IBuildInfo build) throws Exception {
        File deviceInfoDir = build.getFile(DeviceInfoCollector.DEVICE_INFO_DIR);
        File vintfJson = deviceInfoDir.toPath().resolve(VINTF_DEVICE_JSON).toFile();
        return getVendorSepolicyVersionFromJsonFile(vintfJson);
    }

    /**
     * Retrieve the major number of sepolicy version from VINTF device info stored on the device by
     * VintfDeviceInfo.
     */
    private static int getVendorSepolicyVersionFromDeviceJson(ITestDevice device) throws Exception {
        File vintfJson = getDeviceFile(device, cachedDeviceVintfJson,
                DEVICE_INFO_DEVICE_DIR + VINTF_DEVICE_JSON, VINTF_DEVICE_JSON);
        return getVendorSepolicyVersionFromJsonFile(vintfJson);
    }

    /**
     * Retrieve the major number of sepolicy version from the given JSON string that contains VINTF
     * device info.
     */
    private static int getVendorSepolicyVersionFromJsonFile(File vintfJson) throws Exception {
        String content = FileUtil.readStringFromFile(vintfJson);
        JSONObject object = new JSONObject(content);
        String version = object.getString(SEPOLICY_VERSION_JSON_KEY);
        return getSepolicyVersionFromMajorMinor(version);
    }

    /**
     * Deprecated.
     * Retrieve the major number of sepolicy version from raw device manifest XML files.
     * Note that this is depends on locations of VINTF devices files at Android 10 and do not
     * search new paths, hence this may not work on devices launching Android 11 and later.
     */
    private static int getVendorSepolicyVersionFromManifests(ITestDevice device) throws Exception {
        String deviceManifestPath =
                (device.doesFileExist(""/vendor/etc/vintf/manifest.xml"")) ?
                ""/vendor/etc/vintf/manifest.xml"" :
                ""/vendor/manifest.xml"";
        File vendorManifestFile = getDeviceFile(device, cachedDeviceVendorManifest,
                deviceManifestPath, ""manifest.xml"");

        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        Document doc = db.parse(vendorManifestFile);
        Element root = doc.getDocumentElement();
        Element sepolicy = (Element) root.getElementsByTagName(""sepolicy"").item(0);
        Element version = (Element) sepolicy.getElementsByTagName(""version"").item(0);
        return getSepolicyVersionFromMajorMinor(version.getTextContent());
    }

    // NOTE: cts/tools/selinux depends on this method. Rename/change with caution.
    /**
     * Returns the major number of sepolicy version of system.
     */
    public static int getSystemSepolicyVersion(IBuildInfo build) throws Exception {
        File deviceInfoDir = build.getFile(DeviceInfoCollector.DEVICE_INFO_DIR);
        File vintfJson = deviceInfoDir.toPath().resolve(VINTF_DEVICE_JSON).toFile();
        String content = FileUtil.readStringFromFile(vintfJson);
        JSONObject object = new JSONObject(content);
        String version = object.getString(PLATFORM_SEPOLICY_VERSION_JSON_KEY);
        return getSepolicyVersionFromMajorMinor(version);
    }

    /**
     * Get the major number from an SEPolicy version string, e.g. ""27.0"" => 27.
     */
    private static int getSepolicyVersionFromMajorMinor(String version) {
        String sepolicyVersion = version.split(""\\."")[0];
        return Integer.parseInt(sepolicyVersion);
    }

    /**
     * Tests that the kernel is enforcing selinux policy globally.
     *
     * @throws Exception
     */
    @CddTest(requirement=""9.7"")"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.security.cts.SELinuxHostTest"	"testGlobalEnforcing"	"CtsSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/SELinuxHostTest.java"	""	"public void testGlobalEnforcing() throws Exception {
        CollectingOutputReceiver out = new CollectingOutputReceiver();
        mDevice.executeShellCommand(""cat /sys/fs/selinux/enforce"", out);
        assertEquals(""SELinux policy is not being enforced!"", ""1"", out.getOutput());
    }

    /**
     * Tests that all domains in the running policy file are in enforcing mode
     *
     * @throws Exception
     */
    @CddTest(requirement=""9.7"")
    @RestrictedBuildTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.security.cts.SELinuxHostTest"	"testRecoveryDomain"	"CtsSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/SELinuxHostTest.java"	""	"public void testRecoveryDomain() throws DeviceNotAvailableException {
        assertDomainEmpty(""u:r:recovery:s0"");
    }

    /*
     * Nothing should be running in this domain, cardinality test is all thats
     * needed
     */
    @CddTest(requirement=""9.7"")
    @RestrictedBuildTest"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"werePreconditionsSatisfied"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"/*
 *.
 */
package android.carrierapi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.fail;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Message;
import android.os.Parcel;
import android.os.Process;
import android.os.UserHandle;
import android.telephony.AccessNetworkConstants;
import android.telephony.CellInfo;
import android.telephony.CellInfoGsm;
import android.telephony.CellInfoLte;
import android.telephony.CellInfoWcdma;
import android.telephony.NetworkScan;
import android.telephony.NetworkScanRequest;
import android.telephony.RadioAccessSpecifier;
import android.telephony.TelephonyManager;
import android.telephony.TelephonyScanManager;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Unit tests for {@link TelephonyManager}'s network scan APIs.
 *
 * <p>Test using `atest CtsCarrierApiTestCases:NetworkScanApiTest` or `make cts -j64 && cts-tradefed
 * run cts -m CtsCarrierApiTestCases --test android.carrierapi.cts.NetworkScanApiTest`
 */
@RunWith(AndroidJUnit4.class)
public class NetworkScanApiTest extends BaseCarrierApiTest {
    private static final String TAG = ""NetworkScanApiTest"";

    private TelephonyManager mTelephonyManager;
    private int mNetworkScanStatus;
    private static final int EVENT_NETWORK_SCAN_START = 100;
    private static final int EVENT_NETWORK_SCAN_RESULTS = 200;
    private static final int EVENT_NETWORK_SCAN_RESTRICTED_RESULTS = 201;
    private static final int EVENT_NETWORK_SCAN_ERROR = 300;
    private static final int EVENT_NETWORK_SCAN_COMPLETED = 400;
    private static final int EVENT_SCAN_DENIED = 500;
    private List<CellInfo> mScanResults = null;
    private NetworkScanHandlerThread mTestHandlerThread;
    private Handler mHandler;
    private NetworkScan mNetworkScan;
    private NetworkScanRequest mNetworkScanRequest;
    private NetworkScanCallbackImpl mNetworkScanCallback;
    private static final int LOCATION_SETTING_CHANGE_WAIT_MS = 1000;
    private static final int MAX_CELLINFO_WAIT_MILLIS = 5000; // 5 seconds
    private static final int SCAN_SEARCH_TIME_SECONDS = 60;
    // Wait one second longer than the max scan search time to give the test time to receive the
    // results.
    private static final int MAX_INIT_WAIT_MS = (SCAN_SEARCH_TIME_SECONDS + 1) * 1000;
    private Object mLock = new Object();
    private boolean mReady;
    private int mErrorCode;
    /* All the following constants are used to construct NetworkScanRequest*/
    private static final int SCAN_TYPE = NetworkScanRequest.SCAN_TYPE_ONE_SHOT;
    private static final boolean INCREMENTAL_RESULTS = true;
    private static final int SEARCH_PERIODICITY_SEC = 5;
    private static final int MAX_SEARCH_TIME_SEC = 300;
    private static final int INCREMENTAL_RESULTS_PERIODICITY_SEC = 3;
    private static final ArrayList<String> MCC_MNC = new ArrayList<>();
    private static final RadioAccessSpecifier[] RADIO_ACCESS_SPECIFIERS = {
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.GERAN,
                null /* bands */,
                null /* channels */),
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.EUTRAN,
                null /* bands */,
                null /* channels */),
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.UTRAN,
                null /* bands */,
                null /* channels */)
    };

    // Needed because NETWORK_SCAN_PERMISSION is a systemapi
    public static final String NETWORK_SCAN_PERMISSION = ""android.permission.NETWORK_SCAN"";

    @Before
    public void setUp() throws Exception {
        mTelephonyManager = getContext().getSystemService(TelephonyManager.class);
        String selfPackageName = getContext().getPackageName();
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .grantRuntimePermission(selfPackageName, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .grantRuntimePermission(selfPackageName, ACCESS_BACKGROUND_LOCATION);
        mTestHandlerThread = new NetworkScanHandlerThread(TAG);
        mTestHandlerThread.start();
    }

    @After
    public void tearDown() throws Exception {
        if (!werePreconditionsSatisfied()) return;

        // Revoking runtime permissions makes ActivityManager kill our process, so we don't do it,
        // as the test harness will eventually uninstall this APK after testing completes anyway, so
        // we aren't really leaking anything long-term.
        mTestHandlerThread.quit();
    }

    private void waitUntilReady() {
        synchronized (mLock) {
            try {
                mLock.wait(MAX_INIT_WAIT_MS);
            } catch (InterruptedException ie) {
            }

            assertWithMessage(""NetworkScanApiTest failed to initialize"").that(mReady).isTrue();
        }
    }

    private void setReady(boolean ready) {
        synchronized (mLock) {
            mReady = ready;
            mLock.notifyAll();
        }
    }

    private class NetworkScanHandlerThread extends HandlerThread {

        public NetworkScanHandlerThread(String name) {
            super(name);
        }

        @Override
        public void onLooperPrepared() {
            /* create a custom handler for the Handler Thread */
            mHandler =
                    new Handler(mTestHandlerThread.getLooper()) {
                        @Override
                        public void handleMessage(Message msg) {
                            switch (msg.what) {
                                case EVENT_NETWORK_SCAN_START:
                                    Log.d(TAG, ""request network scan"");
                                    boolean useShellIdentity = (Boolean) msg.obj;
                                    if (useShellIdentity) {
                                        InstrumentationRegistry.getInstrumentation()
                                                .getUiAutomation()
                                                .adoptShellPermissionIdentity();
                                    }
                                    try {
                                        mNetworkScan =
                                                mTelephonyManager.requestNetworkScan(
                                                        mNetworkScanRequest,
                                                        AsyncTask.SERIAL_EXECUTOR,
                                                        mNetworkScanCallback);
                                        if (mNetworkScan == null) {
                                            mNetworkScanStatus = EVENT_SCAN_DENIED;
                                            setReady(true);
                                        }
                                    } catch (SecurityException e) {
                                        mNetworkScanStatus = EVENT_SCAN_DENIED;
                                        setReady(true);
                                    } finally {
                                        if (useShellIdentity) {
                                            InstrumentationRegistry.getInstrumentation()
                                                    .getUiAutomation()
                                                    .dropShellPermissionIdentity();
                                        }
                                    }
                                    break;
                                default:
                                    Log.d(TAG, ""Unknown Event "" + msg.what);
                            }
                        }
                    };
        }
    }

    private class NetworkScanCallbackImpl extends TelephonyScanManager.NetworkScanCallback {
        @Override
        public void onResults(List<CellInfo> results) {
            Log.d(TAG, ""onResults: "" + results.toString());
            mNetworkScanStatus = EVENT_NETWORK_SCAN_RESULTS;
            mScanResults = results;
        }

        @Override
        public void onComplete() {
            Log.d(TAG, ""onComplete"");
            mNetworkScanStatus = EVENT_NETWORK_SCAN_COMPLETED;
            setReady(true);
        }

        @Override
        public void onError(int error) {
            Log.d(TAG, ""onError: "" + String.valueOf(error));
            mNetworkScanStatus = EVENT_NETWORK_SCAN_ERROR;
            mErrorCode = error;
            setReady(true);
        }
    }

    private class CellInfoResultsCallback extends TelephonyManager.CellInfoCallback {
        public List<CellInfo> cellInfo;

        @Override
        public synchronized void onCellInfo(List<CellInfo> cellInfo) {
            this.cellInfo = cellInfo;
            notifyAll();
        }

        public synchronized void wait(int millis) throws InterruptedException {
            if (cellInfo == null) {
                super.wait(millis);
            }
        }
    }

    private List<RadioAccessSpecifier> getRadioAccessSpecifier(List<CellInfo> allCellInfo) {
        List<RadioAccessSpecifier> radioAccessSpecifier = new ArrayList<>();
        List<Integer> lteChannels = new ArrayList<>();
        List<Integer> wcdmaChannels = new ArrayList<>();
        List<Integer> gsmChannels = new ArrayList<>();
        for (int i = 0; i < allCellInfo.size(); i++) {
            CellInfo cellInfo = allCellInfo.get(i);
            if (cellInfo instanceof CellInfoLte) {
                lteChannels.add(((CellInfoLte) cellInfo).getCellIdentity().getEarfcn());
            } else if (cellInfo instanceof CellInfoWcdma) {
                wcdmaChannels.add(((CellInfoWcdma) cellInfo).getCellIdentity().getUarfcn());
            } else if (cellInfo instanceof CellInfoGsm) {
                gsmChannels.add(((CellInfoGsm) cellInfo).getCellIdentity().getArfcn());
            }
        }
        if (!lteChannels.isEmpty()) {
            Log.d(TAG, ""lte channels"" + lteChannels.toString());
            int ranLte = AccessNetworkConstants.AccessNetworkType.EUTRAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranLte,
                            null /* bands */,
                            lteChannels.stream().mapToInt(i -> i).toArray()));
        }
        if (!wcdmaChannels.isEmpty()) {
            Log.d(TAG, ""wcdma channels"" + wcdmaChannels.toString());
            int ranWcdma = AccessNetworkConstants.AccessNetworkType.UTRAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranWcdma,
                            null /* bands */,
                            wcdmaChannels.stream().mapToInt(i -> i).toArray()));
        }
        if (!gsmChannels.isEmpty()) {
            Log.d(TAG, ""gsm channels"" + gsmChannels.toString());
            int ranGsm = AccessNetworkConstants.AccessNetworkType.GERAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranGsm,
                            null /* bands */,
                            gsmChannels.stream().mapToInt(i -> i).toArray()));
        }
        return radioAccessSpecifier;
    }

    /** Tests that the device properly requests a network scan. */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartRetailDemoMode"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	"// Change Settings.Global.DEVICE_DEMO_MODE on device may trigger other listener and put
    // the device in undesired state, for example, the battery charge level is set to 35%
    // permanently, ignore this test for now.
    @Ignore
    public void testFgsStartRetailDemoMode() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        runWithShellPermissionIdentity(()-> {
            mOrigDeviceDemoMode = Settings.Global.getInt(mContext.getContentResolver(),
                    Settings.Global.DEVICE_DEMO_MODE, 0); });

        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            runWithShellPermissionIdentity(()-> {
                Settings.Global.putInt(mContext.getContentResolver(),
                        Settings.Global.DEVICE_DEMO_MODE, 1); });
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
            runWithShellPermissionIdentity(()-> {
                Settings.Global.putInt(mContext.getContentResolver(),
                        Settings.Global.DEVICE_DEMO_MODE, mOrigDeviceDemoMode); });
        }
    }

    // At Context.startForegroundService() or Service.startForeground() calls, if the FGS is
    // restricted by background restriction and the app's targetSdkVersion is at least S, the
    // framework throws a ForegroundServiceStartNotAllowedException with error message."	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.keystore.cts.KeyProtectionTest"	"testDefaults"	"CtsKeystoreTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyProtectionTest.java"	""	"public void testDefaults() {
        // Set only the mandatory parameters and assert values returned by getters.

        KeyProtection spec = new KeyProtection.Builder(KeyProperties.PURPOSE_ENCRYPT)
                .build();

        assertEquals(KeyProperties.PURPOSE_ENCRYPT, spec.getPurposes());
        MoreAsserts.assertEmpty(Arrays.asList(spec.getBlockModes()));
        assertFalse(spec.isDigestsSpecified());
        try {
            spec.getDigests();
            fail();
        } catch (IllegalStateException expected) {}
        MoreAsserts.assertEmpty(Arrays.asList(spec.getEncryptionPaddings()));
        assertNull(spec.getKeyValidityStart());
        assertNull(spec.getKeyValidityForOriginationEnd());
        assertNull(spec.getKeyValidityForConsumptionEnd());
        assertTrue(spec.isRandomizedEncryptionRequired());
        MoreAsserts.assertEmpty(Arrays.asList(spec.getSignaturePaddings()));
        assertFalse(spec.isUserAuthenticationRequired());
        assertEquals(0, spec.getUserAuthenticationValidityDurationSeconds());
        assertEquals(KeyProperties.AUTH_BIOMETRIC_STRONG, spec.getUserAuthenticationType());
        assertEquals(GateKeeper.INVALID_SECURE_USER_ID, spec.getBoundToSpecificSecureUserId());
        assertFalse(spec.isUnlockedDeviceRequired());
        assertEquals(KeyProperties.UNRESTRICTED_USAGE_COUNT, spec.getMaxUsageCount());
        assertEquals(spec.isStrongBoxBacked(), false);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.car.cts.CarUxRestrictionsManagerTest"	"testCarUxRestrictionsBuilder"	"CtsCarTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarUxRestrictionsManagerTest.java"	""	"public void testCarUxRestrictionsBuilder() {
        int maxContentDepth = 1;
        int maxCumulativeContentItems = 2;
        int maxStringLength = 3;
        CarUxRestrictions.Builder builder = new CarUxRestrictions.Builder(
                true, CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED, 0L);
        builder.setMaxContentDepth(maxContentDepth);
        builder.setMaxCumulativeContentItems(maxCumulativeContentItems);
        builder.setMaxStringLength(maxStringLength);

        CarUxRestrictions restrictions = builder.build();

        assertTrue(restrictions.toString(),
                restrictions.isRequiresDistractionOptimization());
        assertEquals(restrictions.toString(),
                restrictions.getActiveRestrictions(),
                CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED);
        assertEquals(restrictions.toString(),
                restrictions.getMaxContentDepth(), maxContentDepth);
        assertEquals(restrictions.toString(),
                restrictions.getMaxCumulativeContentItems(), maxCumulativeContentItems);
        assertEquals(restrictions.toString(),
                restrictions.getMaxRestrictedStringLength(), maxStringLength);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.car.cts.CarUxRestrictionsManagerTest"	"testCarUxRestrictions_CopyConstructor"	"CtsCarTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarUxRestrictionsManagerTest.java"	""	"public void testCarUxRestrictions_CopyConstructor() {
        int maxContentDepth = 1;
        int maxCumulativeContentItems = 2;
        int maxStringLength = 3;
        CarUxRestrictions.Builder builder = new CarUxRestrictions.Builder(
                true, CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED, 1L);
        builder.setMaxContentDepth(maxContentDepth);
        builder.setMaxCumulativeContentItems(maxCumulativeContentItems);
        builder.setMaxStringLength(maxStringLength);

        CarUxRestrictions restrictions = builder.build();
        CarUxRestrictions copyOfRestrictions = new CarUxRestrictions(restrictions);

        assertTrue(copyOfRestrictions.toString(),
                copyOfRestrictions.isRequiresDistractionOptimization());
        assertEquals(copyOfRestrictions.toString(),
                copyOfRestrictions.getActiveRestrictions(),
                CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED);
        assertEquals(copyOfRestrictions.toString(),
                copyOfRestrictions.getMaxContentDepth(), maxContentDepth);
        assertEquals(copyOfRestrictions.toString(),
                copyOfRestrictions.getMaxCumulativeContentItems(), maxCumulativeContentItems);
        assertEquals(copyOfRestrictions.toString(),
                copyOfRestrictions.getMaxRestrictedStringLength(), maxStringLength);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.car.cts.CarUxRestrictionsManagerTest"	"testCarUxRestrictions_isSameRestrictions"	"CtsCarTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarUxRestrictionsManagerTest.java"	""	"public void testCarUxRestrictions_isSameRestrictions() {
        CarUxRestrictions.Builder oneBuilder = new CarUxRestrictions.Builder(
                true, CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED, 0L);
        CarUxRestrictions.Builder anotherBuilder = new CarUxRestrictions.Builder(
                true, CarUxRestrictions.UX_RESTRICTIONS_FULLY_RESTRICTED, 0L);

        assertTrue(oneBuilder.build().isSameRestrictions(anotherBuilder.build()));
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.admin.ScreenLockTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/admin/ScreenLockTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.admin;

import com.android.cts.verifier.managedprovisioning.DeviceAdminTestReceiver;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.app.KeyguardManager;
import android.app.admin.DevicePolicyManager;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class ScreenLockTestActivity extends PassFailButtons.Activity {

    private static final int ADD_DEVICE_ADMIN_REQUEST_CODE = 1;

    private ScreenOffReceiver mReceiver;

    private Button mForceLockButton;

    private DevicePolicyManager mDevicePolicyManager;

    private KeyguardManager mKeyguardManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.da_screen_lock_main);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.da_screen_lock_test, R.string.da_screen_lock_info, -1);

        mDevicePolicyManager = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);
        mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);

        getPassButton().setEnabled(false);

        mForceLockButton = (Button) findViewById(R.id.da_force_lock_button);
        mForceLockButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                sendAddDeviceAdminIntent();
            }
        });

        mReceiver = new ScreenOffReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_SCREEN_OFF);
        registerReceiver(mReceiver, filter);
    }

    private void sendAddDeviceAdminIntent() {
        Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);
        intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN,
                DeviceAdminTestReceiver.getReceiverComponentName());
        startActivityForResult(intent, ADD_DEVICE_ADMIN_REQUEST_CODE);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ADD_DEVICE_ADMIN_REQUEST_CODE:
                handleAddDeviceAdminResult(resultCode, data);
                break;
        }
    }

    private void handleAddDeviceAdminResult(int resultCode, Intent data) {
        if (resultCode == RESULT_OK) {
            mDevicePolicyManager.lockNow();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mDevicePolicyManager.isAdminActive(
                DeviceAdminTestReceiver.getReceiverComponentName())) {
            mDevicePolicyManager.removeActiveAdmin(
                DeviceAdminTestReceiver.getReceiverComponentName());
        }
        unregisterReceiver(mReceiver);
    }

    private class ScreenOffReceiver extends BroadcastReceiver {

        private static final int LOCK_CHECK_DELAY = 1000;

        @Override
        public void onReceive(Context context, Intent intent) {
            mForceLockButton.postDelayed(new Runnable() {
                @Override
                public void run() {
                    boolean lockSuccess = mKeyguardManager.inKeyguardRestrictedInputMode();
                    getPassButton().setEnabled(lockSuccess);

                    int iconId = lockSuccess
                            ? android.R.drawable.ic_dialog_info
                            : android.R.drawable.ic_dialog_alert;
                    int messageId = lockSuccess
                            ? R.string.da_lock_success
                            : R.string.da_lock_error;
                    new AlertDialog.Builder(ScreenLockTestActivity.this)
                        .setTitle(R.string.da_screen_lock_test)
                        .setMessage(messageId)
                        .setIcon(iconId)
                        .setPositiveButton(android.R.string.ok, null)
                        .show();
                }
            }, LOCK_CHECK_DELAY);
        }
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.readsettingsfieldsapp.ReadSettingsFieldsTest"	"testGlobalHiddenSettingsKeysNotReadableWithoutAnnotation"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ReadSettingsFieldsApp/src/com/android/cts/readsettingsfieldsapp/ReadSettingsFieldsTest.java"	""	"public void testGlobalHiddenSettingsKeysNotReadableWithoutAnnotation() {
        final ArraySet<String> publicSettingsKeys = getNonHiddenSettingsKeys(Settings.Global.class);
        final String[] hiddenSettingsKeys = {""restricted_networking_mode"",
                ""people_space_conversation_type""};
        testHiddenSettingsKeysNotReadableWithoutAnnotation(Settings.Global.class,
                publicSettingsKeys, hiddenSettingsKeys);
    }

    // test the cases that hidden keys are marked with readable annotation but access should be
    // protected by additional permission check."	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"com.android.cts.readsettingsfieldsapp.ReadSettingsFieldsTest"	"testGlobalHiddenSettingsKeysReadableWithoutAnnotation"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ReadSettingsFieldsApp/src/com/android/cts/readsettingsfieldsapp/ReadSettingsFieldsTest.java"	""	"public void testGlobalHiddenSettingsKeysReadableWithoutAnnotation() {
        final ArraySet<String> publicSettingsKeys = getNonHiddenSettingsKeys(Settings.Global.class);
        final String[] hiddenSettingsKeys = {""restricted_networking_mode"",
                ""people_space_conversation_type""};
        testHiddenSettingsKeysReadable(Settings.Global.class, publicSettingsKeys,
                hiddenSettingsKeys);
    }
}"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.os.cts.DebugTest"	"testDumpService"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/DebugTest.java"	""	"public void testDumpService() throws Exception {
        File file = getContext().getFileStreamPath(""dump.out"");
        file.delete();
        assertFalse(file.exists());

        FileOutputStream out = getContext().openFileOutput(""dump.out"", Context.MODE_PRIVATE);
        assertFalse(Debug.dumpService(""xyzzy -- not a valid service name"", out.getFD(), null));
        out.close();

        // File was opened, but nothing was written
        assertTrue(file.exists());
        assertEquals(0, file.length());

        out = getContext().openFileOutput(""dump.out"", Context.MODE_PRIVATE);
        assertTrue(Debug.dumpService(Context.POWER_SERVICE, out.getFD(), null));
        out.close();

        // Don't require any specific content, just that something was written
        assertTrue(file.exists());
        assertTrue(file.length() > 0);
    }

    private static void checkNumber(String s) throws Exception {
        assertTrue(s != null);
        long n = Long.valueOf(s);
        assertTrue(n >= 0);
    }

    private static void checkHistogram(String s) throws Exception {
        assertTrue(s != null);
        assertTrue(s.length() > 0);
        String[] buckets = s.split("","");
        long last_key = 0;
        for (int i = 0; i < buckets.length; ++i) {
            String bucket = buckets[i];
            assertTrue(bucket.length() > 0);
            String[] kv = bucket.split("":"");
            assertTrue(kv.length == 2);
            assertTrue(kv[0].length() > 0);
            assertTrue(kv[1].length() > 0);
            long key = Long.valueOf(kv[0]);
            long value = Long.valueOf(kv[1]);
            assertTrue(key >= 0);
            assertTrue(value >= 0);
            assertTrue(key >= last_key);
            last_key = key;
        }
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.os.cts.DebugTest"	"testGetRuntimeStat"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/DebugTest.java"	""	"public void testGetRuntimeStat() throws Exception {
        // Invoke at least one GC and wait for 20 seconds or so so we get at
        // least one bucket in the histograms.
        for (int i = 0; i < 20; ++i) {
            Runtime.getRuntime().gc();
            Thread.sleep(1000L);
        }
        String gc_count = Debug.getRuntimeStat(""art.gc.gc-count"");
        String gc_time = Debug.getRuntimeStat(""art.gc.gc-time"");
        String bytes_allocated = Debug.getRuntimeStat(""art.gc.bytes-allocated"");
        String bytes_freed = Debug.getRuntimeStat(""art.gc.bytes-freed"");
        String blocking_gc_count = Debug.getRuntimeStat(""art.gc.blocking-gc-count"");
        String blocking_gc_time = Debug.getRuntimeStat(""art.gc.blocking-gc-time"");
        String gc_count_rate_histogram = Debug.getRuntimeStat(""art.gc.gc-count-rate-histogram"");
        String blocking_gc_count_rate_histogram =
            Debug.getRuntimeStat(""art.gc.blocking-gc-count-rate-histogram"");
        checkNumber(gc_count);
        checkNumber(gc_time);
        checkNumber(bytes_allocated);
        checkNumber(bytes_freed);
        checkNumber(blocking_gc_count);
        checkNumber(blocking_gc_time);
        checkHistogram(gc_count_rate_histogram);
        checkHistogram(blocking_gc_count_rate_histogram);
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.os.cts.DebugTest"	"testGetRuntimeStats"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/DebugTest.java"	""	"public void testGetRuntimeStats() throws Exception {
        // Invoke at least one GC and wait for 20 seconds or so so we get at
        // least one bucket in the histograms.
        for (int i = 0; i < 20; ++i) {
            Runtime.getRuntime().gc();
            Thread.sleep(1000L);
        }
        Map<String, String> map = Debug.getRuntimeStats();
        String gc_count = map.get(""art.gc.gc-count"");
        String gc_time = map.get(""art.gc.gc-time"");
        String bytes_allocated = map.get(""art.gc.bytes-allocated"");
        String bytes_freed = map.get(""art.gc.bytes-freed"");
        String blocking_gc_count = map.get(""art.gc.blocking-gc-count"");
        String blocking_gc_time = map.get(""art.gc.blocking-gc-time"");
        String gc_count_rate_histogram = map.get(""art.gc.gc-count-rate-histogram"");
        String blocking_gc_count_rate_histogram =
            map.get(""art.gc.blocking-gc-count-rate-histogram"");
        checkNumber(gc_count);
        checkNumber(gc_time);
        checkNumber(bytes_allocated);
        checkNumber(bytes_freed);
        checkNumber(blocking_gc_count);
        checkNumber(blocking_gc_time);
        checkHistogram(gc_count_rate_histogram);
        checkHistogram(blocking_gc_count_rate_histogram);
    }"	""	""	"bucket"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.AppSecurityTests"	"testUninstallRemovesData_instant"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testUninstallRemovesData_instant() throws Exception {
        testUninstallRemovesData(true);
    }
    private void testUninstallRemovesData(boolean instant) throws Exception {
        Log.i(LOG_TAG, ""Uninstalling app, verifying data is removed."");
        try {
            getDevice().uninstallPackage(APP_WITH_DATA_PKG);

            new InstallMultiple(instant).addFile(APP_WITH_DATA_APK).run();
            runDeviceTests(
                    APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CREATE_METHOD);

            getDevice().uninstallPackage(APP_WITH_DATA_PKG);

            new InstallMultiple(instant).addFile(APP_WITH_DATA_APK).run();
            runDeviceTests(
                    APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CHECK_NOEXIST_METHOD);
        } finally {
            getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        }
    }

    /**
     * Test that an app cannot instrument another app that is signed with different certificate.
     */
    // RestrictedBuildTest ensures the build only runs on user builds where the signature
    // verification will be performed, but JUnit4TestNotRun reports the test will not be run because
    // the method does not have the"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.AppSecurityTests"	"testInstrumentationDiffCert_full"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	"annotation.
    @SuppressWarnings(""JUnit4TestNotRun"")
    @RestrictedBuildTest
    @AppModeFull(reason = ""'full' portion of the hostside test"")
    public void testInstrumentationDiffCert_full() throws Exception {
        testInstrumentationDiffCert(false, false);
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.telephonyprovider.cts.SmsTest"	"testInsertEmoji_andVerify"	"CtsTelephonyProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephonyprovider/src/android/telephonyprovider/cts/SmsTest.java"	""	"public void testInsertEmoji_andVerify() {
        String testSmsBodyEmoji = ""\uD83D\uDE0D\uD83D\uDE02""
                + ""\uD83D\uDE1B\uD83D\uDE00\uD83D\uDE1E\uD83D\uDE1B""
                + ""\uD83D\uDE1E\uD83D\uDE0D"";

        Uri uri = mSmsTestHelper.insertTestSms(TEST_ADDRESS, testSmsBodyEmoji);

        assertThat(uri).isNotNull();

        mSmsTestHelper.assertSmsColumnEquals(Telephony.Sms.BODY, uri,
                String.valueOf(testSmsBodyEmoji));
    }

    /**
     * Verifies that subqueries are not allowed with a restricted view
     */"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.security.cts.IsolatedProcessTest"	"testGetServiceFromIsolatedService"	"CtsSecurityTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/IsolatedProcessTest.java"	""	"public void testGetServiceFromIsolatedService() throws RemoteException {
        for (String serviceName : RESTRICTED_SERVICES_TO_TEST) {
            IBinder service = mService.getSystemService(serviceName);
            Assert.assertNull(serviceName + "" should not be accessible from an isolated process"",
                    service);
        }
    }"	""	""	"RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"isWifiEnabled"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void test/*
 *.
 */
package android.jobscheduler.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;

import static com.android.compatibility.common.util.TestUtils.waitUntil;

import android.Manifest;
import android.annotation.TargetApi;
import android.app.job.JobInfo;
import android.app.job.JobParameters;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.platform.test.annotations.RequiresDevice;
import android.provider.Settings;
import android.util.Log;

import com.android.compatibility.common.util.AppStandbyUtils;
import com.android.compatibility.common.util.BatteryUtils;
import com.android.compatibility.common.util.CallbackAsserter;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import junit.framework.AssertionFailedError;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Schedules jobs with the {@link android.app.job.JobScheduler} that have network connectivity
 * constraints.
 * Requires manipulating the {@link android.net.wifi.WifiManager} to ensure an unmetered network.
 * Similarly, requires that the phone be connected to a wifi hotspot, or else the test will fail.
 */
@TargetApi(21)
@RequiresDevice // Emulators don't always have access to wifi/network
public class ConnectivityConstraintTest extends BaseJobSchedulerTest {
    private static final String TAG = ""ConnectivityConstraintTest"";
    private static final String RESTRICT_BACKGROUND_GET_CMD =
            ""cmd netpolicy get restrict-background"";
    private static final String RESTRICT_BACKGROUND_ON_CMD =
            ""cmd netpolicy set restrict-background true"";
    private static final String RESTRICT_BACKGROUND_OFF_CMD =
            ""cmd netpolicy set restrict-background false"";

    /** Unique identifier for the job scheduled by this suite of tests. */
    public static final int CONNECTIVITY_JOB_ID = ConnectivityConstraintTest.class.hashCode();
    /** Wait this long before timing out the test. */
    private static final long DEFAULT_TIMEOUT_MILLIS = 30000L; // 30 seconds.

    private WifiManager mWifiManager;
    private ConnectivityManager mCm;

    /** Whether the device running these tests supports WiFi. */
    private boolean mHasWifi;
    /** Whether the device running these tests supports telephony. */
    private boolean mHasTelephony;
    /** Track whether WiFi was enabled in case we turn it off. */
    private boolean mInitialWiFiState;
    /** Track initial WiFi metered state. */
    private String mInitialWiFiMeteredState;
    private String mInitialWiFiSSID;
    /** Track whether restrict background policy was enabled in case we turn it off. */
    private boolean mInitialRestrictBackground;
    /** Track whether airplane mode was enabled in case we toggle it. */
    private boolean mInitialAirplaneMode;
    /** Track whether the restricted bucket was enabled in case we toggle it. */
    private String mInitialRestrictedBucketEnabled;

    private JobInfo.Builder mBuilder;

    private TestAppInterface mTestAppInterface;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        mCm = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);

        PackageManager packageManager = mContext.getPackageManager();
        mHasWifi = packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI);
        mHasTelephony = packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY);
        mBuilder = new JobInfo.Builder(CONNECTIVITY_JOB_ID, kJobServiceComponent);

        if (mHasWifi) {
            mInitialWiFiState = mWifiManager.isWifiEnabled();
            ensureSavedWifiNetwork(mWifiManager);
            setWifiState(true, mCm, mWifiManager);
            mInitialWiFiSSID = getWifiSSID();
            mInitialWiFiMeteredState = getWifiMeteredStatus(mInitialWiFiSSID);
        }
        mInitialRestrictBackground = SystemUtil
                .runShellCommand(getInstrumentation(), RESTRICT_BACKGROUND_GET_CMD)
                .contains(""enabled"");
        mInitialRestrictedBucketEnabled = Settings.Global.getString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET);
        setDataSaverEnabled(false);
        mInitialAirplaneMode = isAirplaneModeOn();
        setAirplaneMode(false);
        // Force the test app out of the never bucket.
        SystemUtil.runShellCommand(""am set-standby-bucket ""
                + TestAppInterface.TEST_APP_PACKAGE + "" rare"");
    }

    @Override
    public void tearDown() throws Exception {
        if (mTestAppInterface != null) {
            mTestAppInterface.cleanup();
        }
        mJobScheduler.cancel(CONNECTIVITY_JOB_ID);

        BatteryUtils.runDumpsysBatteryReset();

        // Restore initial restrict background data usage policy
        setDataSaverEnabled(mInitialRestrictBackground);

        // Restore initial restricted bucket setting.
        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, mInitialRestrictedBucketEnabled);

        // Ensure that we leave WiFi in its previous state.
        if (mHasWifi) {
            setWifiMeteredState(mInitialWiFiSSID, mInitialWiFiMeteredState);
            if (mWifiManager.isWifiEnabled() != mInitialWiFiState) {
                try {
                    setWifiState(mInitialWiFiState, mCm, mWifiManager);
                } catch (AssertionFailedError e) {
                    // Don't fail the test just because wifi state wasn't set in tearDown.
                    Log.e(TAG, ""Failed to return wifi state to "" + mInitialWiFiState, e);
                }
            }
        }

        // Restore initial airplane mode status. Do it after setting wifi in case wifi was
        // originally metered.
        setAirplaneMode(mInitialAirplaneMode);

        super.tearDown();
    }

    // --------------------------------------------------------------------------------------------
    // Positives - schedule jobs under conditions that require them to pass.
    // --------------------------------------------------------------------------------------------

    /**
     * Schedule a job that requires a WiFi connection, and assert that it executes when the device
     * is connected to WiFi. This will fail if a wifi connection is unavailable.
     */"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testExpeditedJobExecutes_IdleApp"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void testExpeditedJobExecutes_IdleApp() throws Exception {
        if (!AppStandbyUtils.isAppStandbyEnabled()) {
            Log.d(TAG, ""App standby not enabled"");
            return;
        }
        if (mHasWifi) {
            setWifiMeteredState(true);
        } else if (checkDeviceSupportsMobileData()) {
            disconnectWifiToConnectToMobile();
        } else {
            Log.d(TAG, ""Skipping test that requires a metered network."");
            return;
        }

        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");
        SystemUtil.runShellCommand(""am set-standby-bucket ""
                + kJobServiceComponent.getPackageName() + "" restricted"");
        BatteryUtils.runDumpsysBatteryUnplug();

        kTestEnvironment.setExpectedExecutions(1);
        mJobScheduler.schedule(
                mBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
                        .setExpedited(true)
                        .build());
        runSatisfiedJob(CONNECTIVITY_JOB_ID);

        assertTrue(""Expedited job requiring connectivity did not fire when app was idle."",
                kTestEnvironment.awaitExecution());
    }

    /**
     * Schedule an expedited job that requires a network connection, and verify that it runs even
     * when Battery Saver is on.
     */"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testExpeditedJobBypassesSimultaneousFirewalls_noDataSaver"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void testExpeditedJobBypassesSimultaneousFirewalls_noDataSaver() throws Exception {
        if (!BatteryUtils.isBatterySaverSupported()) {
            Log.d(TAG, ""Skipping test that requires battery saver support"");
            return;
        }
        if (mHasWifi) {
            setWifiMeteredState(true);
        } else if (checkDeviceSupportsMobileData()) {
            disconnectWifiToConnectToMobile();
        } else {
            Log.d(TAG, ""Skipping test that requires a metered network."");
            return;
        }
        if (!AppStandbyUtils.isAppStandbyEnabled()) {
            Log.d(TAG, ""App standby not enabled"");
            return;
        }

        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");
        SystemUtil.runShellCommand(""am set-standby-bucket ""
                + kJobServiceComponent.getPackageName() + "" restricted"");
        BatteryUtils.runDumpsysBatteryUnplug();
        BatteryUtils.enableBatterySaver(true);
        setDataSaverEnabled(false);

        kTestEnvironment.setExpectedExecutions(1);
        mJobScheduler.schedule(
                mBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
                        .setExpedited(true)
                        .build());
        runSatisfiedJob(CONNECTIVITY_JOB_ID);

        assertTrue(""Expedited job requiring connectivity did not fire with multiple firewalls."",
                kTestEnvironment.awaitExecution());
    }

    // --------------------------------------------------------------------------------------------
    // Positives & Negatives - schedule jobs under conditions that require that pass initially and
    // then fail with a constraint change.
    // --------------------------------------------------------------------------------------------

    /**
     * Schedule a job with a cellular connectivity constraint, and ensure that it executes
     * on a mobile data connection and is stopped when Data Saver is turned on.
     */"	""	""	"bucket RESTRICTED"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-10"	"3.5.1/C-1-10"	"03050100.670110"	"""C-1-10] MUST NOT allow an app to be automatically placed in the RESTRICTED bucket within 2 hours of the most recent usage by a user. If device implementations extend the app restrictions that are implemented in AOSP, they:"""	""	""	"BackgroundRestricted bucket RESTRICTED backgroundRestriction"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testExpeditedJobDoesNotBypassSimultaneousFirewalls_withDataSaver"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void testExpeditedJobDoesNotBypassSimultaneousFirewalls_withDataSaver()
            throws Exception {
        if (!BatteryUtils.isBatterySaverSupported()) {
            Log.d(TAG, ""Skipping test that requires battery saver support"");
            return;
        }
        if (mHasWifi) {
            setWifiMeteredState(true);
        } else if (checkDeviceSupportsMobileData()) {
            disconnectWifiToConnectToMobile();
        } else {
            Log.d(TAG, ""Skipping test that requires a metered network."");
            return;
        }
        if (!AppStandbyUtils.isAppStandbyEnabled()) {
            Log.d(TAG, ""App standby not enabled"");
            return;
        }

        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");
        SystemUtil.runShellCommand(""am set-standby-bucket ""
                + kJobServiceComponent.getPackageName() + "" restricted"");
        BatteryUtils.runDumpsysBatteryUnplug();
        BatteryUtils.enableBatterySaver(true);
        setDataSaverEnabled(true);

        mTestAppInterface = new TestAppInterface(mContext, CONNECTIVITY_JOB_ID);

        mTestAppInterface.scheduleJob(false,  JobInfo.NETWORK_TYPE_ANY, true);
        mTestAppInterface.runSatisfiedJob();

        assertFalse(""Expedited job fired with multiple firewalls, including data saver."",
                mTestAppInterface.awaitJobStart(DEFAULT_TIMEOUT_MILLIS));
    }

    // --------------------------------------------------------------------------------------------
    // Utility methods
    // --------------------------------------------------------------------------------------------

    /**
     * Determine whether the device running these CTS tests should be subject to tests involving
     * mobile data.
     * @return True if this device will support a mobile data connection.
     */
    private boolean checkDeviceSupportsMobileData() {
        if (!mHasTelephony) {
            Log.d(TAG, ""Skipping test that requires telephony features, not supported by this"" +
                    "" device"");
            return false;
        }
        Network[] networks = mCm.getAllNetworks();
        for (Network network : networks) {
            if (mCm.getNetworkCapabilities(network)
                    .hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
                return true;
            }
        }
        Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
        return false;
    }

    private String unquoteSSID(String ssid) {
        // SSID is returned surrounded by quotes if it can be decoded as UTF-8.
        // Otherwise it's guaranteed not to start with a quote.
        if (ssid.charAt(0) == '""') {
            return ssid.substring(1, ssid.length() - 1);
        } else {
            return ssid;
        }
    }

    private String getWifiSSID() {
        final AtomicReference<String> ssid = new AtomicReference<>();
        SystemUtil.runWithShellPermissionIdentity(() -> {
            ssid.set(mWifiManager.getConnectionInfo().getSSID());
        }, Manifest.permission.ACCESS_FINE_LOCATION);
        return unquoteSSID(ssid.get());
    }

    // Returns ""true"", ""false"" or ""none""
    private String getWifiMeteredStatus(String ssid) {
        // Interestingly giving the SSID as an argument to list wifi-networks
        // only works iff the network in question has the ""false"" policy.
        // Also unfortunately runShellCommand does not pass the command to the interpreter
        // so it's not possible to | grep the ssid.
        final String command = ""cmd netpolicy list wifi-networks"";
        final String policyString = SystemUtil.runShellCommand(command);

        final Matcher m = Pattern.compile(""^"" + ssid + "";(true|false|none)$"",
                Pattern.MULTILINE | Pattern.UNIX_LINES).matcher(policyString);
        if (!m.find()) {
            fail(""Unexpected format from cmd netpolicy (when looking for "" + ssid + ""): ""
                    + policyString);
        }
        return m.group(1);
    }

    private void setWifiMeteredState(boolean metered) throws Exception {
        if (metered) {
            // Make sure unmetered cellular networks don't interfere.
            setAirplaneMode(true);
            setWifiState(true, mCm, mWifiManager);
        }
        final String ssid = getWifiSSID();
        setWifiMeteredState(ssid, metered ? ""true"" : ""false"");
    }

    // metered should be ""true"", ""false"" or ""none""
    private void setWifiMeteredState(String ssid, String metered) {
        if (metered.equals(getWifiMeteredStatus(ssid))) {
            return;
        }
        SystemUtil.runShellCommand(""cmd netpolicy set metered-network "" + ssid + "" "" + metered);
        assertEquals(getWifiMeteredStatus(ssid), metered);
    }

    /**
     * Ensure WiFi is enabled, and block until we've verified that we are in fact connected.
     */
    private void connectToWifi()
            throws InterruptedException {
        setWifiState(true, mCm, mWifiManager);
    }

    /**
     * Ensure WiFi is disabled, and block until we've verified that we are in fact disconnected.
     */
    private void disconnectFromWifi()
            throws InterruptedException {
        setWifiState(false, mCm, mWifiManager);
    }

    /** Ensures that the device has a wifi network saved. */
    static void ensureSavedWifiNetwork(WifiManager wifiManager) {
        final List<WifiConfiguration> savedNetworks =
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        wifiManager, WifiManager::getConfiguredNetworks);
        assertFalse(""Need at least one saved wifi network"", savedNetworks.isEmpty());
    }

    /**
     * Set Wifi connection to specific state, and block until we've verified
     * that we are in the state.
     * Taken from {@link android.net.http.cts.ApacheHttpClientTest}.
     */
    static void setWifiState(final boolean enable,
            final ConnectivityManager cm, final WifiManager wm) throws InterruptedException {
        if (enable != isWiFiConnected(cm, wm)) {
            NetworkRequest nr = new NetworkRequest.Builder().clearCapabilities().build();
            NetworkCapabilities nc = new NetworkCapabilities.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .build();
            NetworkTracker tracker = new NetworkTracker(nc, enable, cm);
            cm.registerNetworkCallback(nr, tracker);

            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
                //noinspection deprecation
                SystemUtil.runWithShellPermissionIdentity(wm::reconnect,
                        android.Manifest.permission.NETWORK_SETTINGS);
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }

            tracker.waitForStateChange();

            assertTrue(""Wifi must be "" + (enable ? ""connected to"" : ""disconnected from"")
                            + "" an access point for this test."",
                    enable == isWiFiConnected(cm, wm));

            cm.unregisterNetworkCallback(tracker);
        }
    }

    static boolean isWiFiConnected(final ConnectivityManager cm, final WifiManager wm) {
        if (!wm.isWifiEnabled()) {
            return false;
        }
        final Network network = cm.getActiveNetwork();
        if (network == null) {
            return false;
        }
        final NetworkCapabilities networkCapabilities = cm.getNetworkCapabilities(network);
        return networkCapabilities != null && networkCapabilities.hasTransport(TRANSPORT_WIFI);
    }

    /**
     * Disconnect from WiFi in an attempt to connect to cellular data. Worth noting that this is
     * best effort - there are no public APIs to force connecting to cell data. We disable WiFi
     * and wait for a broadcast that we're connected to cell.
     * We will not call into this function if the device doesn't support telephony.
     * @see #mHasTelephony
     * @see #checkDeviceSupportsMobileData()
     */
    private void disconnectWifiToConnectToMobile() throws Exception {
        setAirplaneMode(false);
        if (mHasWifi && mWifiManager.isWifiEnabled()) {
            NetworkRequest nr = new NetworkRequest.Builder().clearCapabilities().build();
            NetworkCapabilities nc = new NetworkCapabilities.Builder()
                    .addTransportType(TRANSPORT_CELLULAR)
                    .build();
            NetworkTracker tracker = new NetworkTracker(nc, true, mCm);
            mCm.registerNetworkCallback(nr, tracker);

            disconnectFromWifi();

            assertTrue(""Device must have access to a metered network for this test."",
                    tracker.waitForStateChange());

            mCm.unregisterNetworkCallback(tracker);
        }
    }

    /**
     * Ensures that restrict background data usage policy is turned off.
     * If the policy is on, it interferes with tests that relies on metered connection.
     */
    private void setDataSaverEnabled(boolean enabled) throws Exception {
        SystemUtil.runShellCommand(getInstrumentation(),
                enabled ? RESTRICT_BACKGROUND_ON_CMD : RESTRICT_BACKGROUND_OFF_CMD);
    }

    private boolean isAirplaneModeOn() throws Exception {
        final String output = SystemUtil.runShellCommand(getInstrumentation(),
                ""cmd connectivity airplane-mode"").trim();
        return ""enabled"".equals(output);
    }

    private void setAirplaneMode(boolean on) throws Exception {
        if (isAirplaneModeOn() == on) {
            return;
        }
        final CallbackAsserter airplaneModeBroadcastAsserter = CallbackAsserter.forBroadcast(
                new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
        SystemUtil.runShellCommand(getInstrumentation(),
                ""cmd connectivity airplane-mode "" + (on ? ""enable"" : ""disable""));
        airplaneModeBroadcastAsserter.assertCalled(""Didn't get airplane mode changed broadcast"",
                15 /* 15 seconds */);
        waitUntil(""Networks didn't change to "" + (!on ? "" on"" : "" off""), 60 /* seconds */,
                () -> {
                    if (on) {
                        return mCm.getActiveNetwork() == null
                                && (!mHasWifi || !isWiFiConnected(mCm, mWifiManager));
                    } else {
                        return mCm.getActiveNetwork() != null;
                    }
                });
        // Wait some time for the network changes to propagate. Can't use
        // waitUntil(isAirplaneModeOn() == on) because the response quickly gives the new
        // airplane mode status even though the network changes haven't propagated all the way to
        // JobScheduler.
        Thread.sleep(5000);
    }

    private static class NetworkTracker extends ConnectivityManager.NetworkCallback {
        private static final int MSG_CHECK_ACTIVE_NETWORK = 1;
        private final ConnectivityManager mCm;

        private final CountDownLatch mReceiveLatch = new CountDownLatch(1);

        private final NetworkCapabilities mExpectedCapabilities;

        private final boolean mExpectedConnected;

        private final Handler mHandler = new Handler(Looper.getMainLooper()) {
            @Override
            public void handleMessage(Message msg) {
                if (msg.what == MSG_CHECK_ACTIVE_NETWORK) {
                    checkActiveNetwork();
                }
            }
        };

        private NetworkTracker(NetworkCapabilities expectedCapabilities, boolean expectedConnected,
                ConnectivityManager cm) {
            mExpectedCapabilities = expectedCapabilities;
            mExpectedConnected = expectedConnected;
            mCm = cm;
        }

        @Override
        public void onAvailable(Network network) {
            // Available doesn't mean it's the active network. We need to check that separately.
            checkActiveNetwork();
        }

        @Override
        public void onLost(Network network) {
            checkActiveNetwork();
        }

        boolean waitForStateChange() throws InterruptedException {
            checkActiveNetwork();
            return mReceiveLatch.await(60, TimeUnit.SECONDS);
        }

        private void checkActiveNetwork() {
            mHandler.removeMessages(MSG_CHECK_ACTIVE_NETWORK);
            if (mReceiveLatch.getCount() == 0) {
                return;
            }

            Network activeNetwork = mCm.getActiveNetwork();
            if (mExpectedConnected) {
                if (activeNetwork != null && mExpectedCapabilities.satisfiedByNetworkCapabilities(
                        mCm.getNetworkCapabilities(activeNetwork))) {
                    mReceiveLatch.countDown();
                } else {
                    mHandler.sendEmptyMessageDelayed(MSG_CHECK_ACTIVE_NETWORK, 5000);
                }
            } else {
                if (activeNetwork == null
                        || !mExpectedCapabilities.satisfiedByNetworkCapabilities(
                        mCm.getNetworkCapabilities(activeNetwork))) {
                    mReceiveLatch.countDown();
                } else {
                    mHandler.sendEmptyMessageDelayed(MSG_CHECK_ACTIVE_NETWORK, 5000);
                }
            }
        }
    }
}"	""	""	"bucket RESTRICTED RESTRICTED"	""	""	""	""	""	""	""	""	""	""
