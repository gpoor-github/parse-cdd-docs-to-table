Section,section_id,req_id,Test Availability,class_def,method,module,method_text,full_key,requirement,key_as_number,search_terms,qualified_method,manual_search_terms,matched_terms,file_name,matched_files,methods_string,urls
,7.1.1.1,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.1.1/H-1-1,,07010101.720101,H-1-1 7.1.1.1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-1,,07010406.720101,H-1-1 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-2,,07010406.720102,7.1.4.6 H-1-2,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-2,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-3,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-3,,07010406.720103,7.1.4.6 H-1-3,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-3,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-4,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-4,,07010406.720104,7.1.4.6 H-1-4,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-4,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-1,,03081600.720101,H-1-1 3.8.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-2,,03081600.720102,H-1-2 3.8.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-2,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-3,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-3,,03081600.720103,H-1-3 3.8.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-3,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-4,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-4,,03081600.720104,H-1-4 3.8.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-4,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.2.3.5,C-2-6,,android.hardware.camera2.cts.HeifWriterTest,testHeif(),CtsCameraTestCases,"     public void testHeif() throws Exception {         final int NUM_SINGLE_CAPTURE_TESTED = 3;         final int NUM_HEIC_CAPTURE_TESTED = 2;         final int SESSION_WARMUP_MS = 1000;         final int HEIF_STOP_TIMEOUT = 3000 * NUM_SINGLE_CAPTURE_TESTED;          if (!canEncodeHeic()) {             MediaUtils.skipTest(""heic encoding is not supported on this device"");             return;         }          boolean sessionFailure = false;         Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,                 BlockingSessionCallback.SESSION_CONFIGURE_FAILED};         for (String id : mCameraIdsUnderTest) {             try {                 Log.v(TAG, ""Testing HEIF capture for Camera "" + id);                 openDevice(id);                  Size[] availableSizes = mStaticInfo.getAvailableSizesForFormatChecked(                         ImageFormat.PRIVATE,                         StaticMetadata.StreamDirection.Output);                  // for each resolution, test imageReader:                 for (Size sz : availableSizes) {                     HeifWriter heifWriter = null;                     OutputConfiguration outConfig = null;                     Surface latestSurface = null;                     CaptureRequest.Builder reqStill = null;                     int width = sz.getWidth();                     int height = sz.getHeight();                     for (int cap = 0; cap < NUM_HEIC_CAPTURE_TESTED; cap++) {                         if (VERBOSE) {                             Log.v(TAG, ""Testing size "" + sz.toString() + "" format PRIVATE""                                     + "" for camera "" + mCamera.getId() + "". Iteration:"" + cap);                         }                          try {                             TestConfig.Builder builder = new TestConfig.Builder(/*useGrid*/false);                             builder.setNumImages(NUM_SINGLE_CAPTURE_TESTED);                             builder.setSize(sz);                             String filename = ""Cam"" + id + ""_"" + width + ""x"" + height +                                     ""_"" + cap + "".heic"";                             builder.setOutputPath(                                     new File(mFilePath, filename).getAbsolutePath());                             TestConfig config = builder.build();                              try {                                 heifWriter = new HeifWriter.Builder(                                         config.mOutputPath,                                         width, height, INPUT_MODE_SURFACE)                                     .setGridEnabled(config.mUseGrid)                                     .setMaxImages(config.mMaxNumImages)                                     .setQuality(config.mQuality)                                     .setPrimaryIndex(config.mNumImages - 1)                                     .setHandler(mHandler)                                     .build();                             } catch (IOException e) {                                 // Continue in case the size is not supported                                 sessionFailure = true;                                 Log.i(TAG, ""Skip due to heifWriter creation failure: ""                                         + e.getMessage());                                 continue;                             }                              // First capture. Start capture session                             latestSurface = heifWriter.getInputSurface();                             outConfig = new OutputConfiguration(latestSurface);                             List<OutputConfiguration> configs =                                 new ArrayList<OutputConfiguration>();                             configs.add(outConfig);                              SurfaceTexture preview = new SurfaceTexture(/*random int*/ 1);                             Surface previewSurface = new Surface(preview);                             preview.setDefaultBufferSize(640, 480);                             configs.add(new OutputConfiguration(previewSurface));                              CaptureRequest.Builder reqPreview = mCamera.createCaptureRequest(                                     CameraDevice.TEMPLATE_PREVIEW);                             reqPreview.addTarget(previewSurface);                              reqStill = mCamera.createCaptureRequest(                                     CameraDevice.TEMPLATE_STILL_CAPTURE);                             reqStill.addTarget(previewSurface);                             reqStill.addTarget(latestSurface);                              // Start capture session and preview                             createSessionByConfigs(configs);                             int state = mCameraSessionListener.getStateWaiter().waitForAnyOfStates(                                     Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);                             if (state == BlockingSessionCallback.SESSION_CONFIGURE_FAILED) {                                 // session configuration failure. Bail out due to known issue of                                 // HeifWriter INPUT_SURFACE mode support for camera. b/79699819                                 sessionFailure = true;                                 break;                             }                             startCapture(reqPreview.build(), /*repeating*/true, null, null);                              SystemClock.sleep(SESSION_WARMUP_MS);                              heifWriter.start();                              // Start capture.                             CaptureRequest request = reqStill.build();                             SimpleCaptureCallback listener = new SimpleCaptureCallback();                              int numImages = config.mNumImages;                              for (int i = 0; i < numImages; i++) {                                 startCapture(request, /*repeating*/false, listener, mHandler);                             }                              // Validate capture result.                             CaptureResult result = validateCaptureResult(                                     ImageFormat.PRIVATE, sz, listener, numImages);                              // TODO: convert capture results into EXIF and send to heifwriter                              heifWriter.stop(HEIF_STOP_TIMEOUT);                              verifyResult(config.mOutputPath, width, height,                                     config.mRotation, config.mUseGrid,                                     Math.min(numImages, config.mMaxNumImages));                         } finally {                             if (heifWriter != null) {                                 heifWriter.close();                                 heifWriter = null;                             }                             if (!sessionFailure) {                                 stopCapture(/*fast*/false);                             }                         }                     }                      if (sessionFailure) {                         break;                     }                 }             } finally {                 closeDevice(id);             }         }     }      private static boolean canEncodeHeic() {         return MediaUtils.hasEncoder(MediaFormat.MIMETYPE_VIDEO_HEVC)             || MediaUtils.hasEncoder(MediaFormat.MIMETYPE_IMAGE_ANDROID_HEIC);     }      private static class TestConfig {         final boolean mUseGrid;         final int mMaxNumImages;         final int mNumImages;         final int mWidth;         final int mHeight;         final int mRotation;         final int mQuality;         final String mOutputPath;          TestConfig(boolean useGrid, int maxNumImages, int numImages,                    int width, int height, int rotation, int quality,                    String outputPath) {             mUseGrid = useGrid;             mMaxNumImages = maxNumImages;             mNumImages = numImages;             mWidth = width;             mHeight = height;             mRotation = rotation;             mQuality = quality;             mOutputPath = outputPath;         }          static class Builder {             final boolean mUseGrid;             int mMaxNumImages;             int mNumImages;             int mWidth;             int mHeight;             int mRotation;             final int mQuality;             String mOutputPath;              Builder(boolean useGrids) {                 mUseGrid = useGrids;                 mMaxNumImages = mNumImages = 4;                 mWidth = 1920;                 mHeight = 1080;                 mRotation = 0;                 mQuality = 100;                 mOutputPath = new File(Environment.getExternalStorageDirectory(),                         OUTPUT_FILENAME).getAbsolutePath();             }              Builder setNumImages(int numImages) {                 mMaxNumImages = mNumImages = numImages;                 return this;             }              Builder setRotation(int rotation) {                 mRotation = rotation;                 return this;             }              Builder setSize(Size sz) {                 mWidth = sz.getWidth();                 mHeight = sz.getHeight();                 return this;             }              Builder setOutputPath(String path) {                 mOutputPath = path;                 return this;             }              private void cleanupStaleOutputs() {                 File outputFile = new File(mOutputPath);                 if (outputFile.exists()) {                     outputFile.delete();                 }             }              TestConfig build() {                 cleanupStaleOutputs();                 return new TestConfig(mUseGrid, mMaxNumImages, mNumImages,                         mWidth, mHeight, mRotation, mQuality, mOutputPath);             }         }          @Override         public String toString() {             return ""TestConfig""                     + "": mUseGrid "" + mUseGrid                     + "", mMaxNumImages "" + mMaxNumImages                     + "", mNumImages "" + mNumImages                     + "", mWidth "" + mWidth                     + "", mHeight "" + mHeight                     + "", mRotation "" + mRotation                     + "", mQuality "" + mQuality                     + "", mOutputPath "" + mOutputPath;         }     }      private void verifyResult(             String filename, int width, int height, int rotation, boolean useGrid, int numImages)             throws Exception {         MediaMetadataRetriever retriever = new MediaMetadataRetriever();         retriever.setDataSource(filename);         String hasImage = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_IMAGE);         if (!""yes"".equals(hasImage)) {             throw new Exception(""No images found in file "" + filename);         }         assertEquals(""Wrong image count"", numImages,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_COUNT)));         assertEquals(""Wrong width"", width,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_WIDTH)));         assertEquals(""Wrong height"", height,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_HEIGHT)));         assertEquals(""Wrong rotation"", rotation,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_ROTATION)));         retriever.release();          if (useGrid) {             MediaExtractor extractor = new MediaExtractor();             extractor.setDataSource(filename);             MediaFormat format = extractor.getTrackFormat(0);             int tileWidth = format.getInteger(MediaFormat.KEY_TILE_WIDTH);             int tileHeight = format.getInteger(MediaFormat.KEY_TILE_HEIGHT);             int gridRows = format.getInteger(MediaFormat.KEY_GRID_ROWS);             int gridCols = format.getInteger(MediaFormat.KEY_GRID_COLUMNS);             assertTrue(""Wrong tile width or grid cols"",                     ((width + tileWidth - 1) / tileWidth) == gridCols);             assertTrue(""Wrong tile height or grid rows"",                     ((height + tileHeight - 1) / tileHeight) == gridRows);             extractor.release();         }     }      /**      * Validate capture results.      *      * @param format The format of this capture.      * @param size The capture size.      * @param listener The capture listener to get capture result callbacks.      * @return the last verified CaptureResult      */     private CaptureResult validateCaptureResult(             int format, Size size, SimpleCaptureCallback listener, int numFrameVerified) {         CaptureResult result = null;         for (int i = 0; i < numFrameVerified; i++) {             result = listener.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);             if (mStaticInfo.isCapabilitySupported(                     CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS)) {                 Long exposureTime = getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);                 Integer sensitivity = getValueNotNull(result, CaptureResult.SENSOR_SENSITIVITY);                 mCollector.expectInRange(                         String.format(                                 ""Capture for format %d, size %s exposure time is invalid."",                                 format, size.toString()),                         exposureTime,                         mStaticInfo.getExposureMinimumOrDefault(),                         mStaticInfo.getExposureMaximumOrDefault()                 );                 mCollector.expectInRange(                         String.format(""Capture for format %d, size %s sensitivity is invalid."",                                 format, size.toString()),                         sensitivity,                         mStaticInfo.getSensitivityMinimumOrDefault(),                         mStaticInfo.getSensitivityMaximumOrDefault()                 );             }             // TODO: add more key validations.         }         return result;     } } ",3.2.3.5/C-2-6,,03020305.670206,VIEW android.intent.action.SENDTO android.intent.action.VIEW ACTION_SENDTO 3.2.3.5 SENDTO C-2-6 SMS,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.HeifWriterTest:testHeif()],,VIEW,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,,
,3.2.3.5,C-5-2,,android.app.notification.legacy.cts.ConditionProviderServiceTest,testUnboundCPSMaintainsCondition_otherProviderRuleChanges(),,"     public void testUnboundCPSMaintainsCondition_otherProviderRuleChanges() throws Exception {         // make sure both services get bound         pollForConnection(LegacyConditionProviderService.class, true);         pollForConnection(SecondaryConditionProviderService.class, true);          // add rules for both         mModeReceiver.reset();          addRule(LegacyConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, true);         pollForSubscribe(LegacyConditionProviderService.getInstance());          addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_ALARMS, true);         pollForSubscribe(SecondaryConditionProviderService.getInstance());          mModeReceiver.waitFor(2/*Legacy and Secondary*/, 1000/*Limit is 1 second*/);         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // unbind one of the services         SecondaryConditionProviderService.getInstance().requestUnbind();          // verify that DND state doesn't change         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // trigger a change in the bound service's rule         addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, false);          // verify that the unbound service maintains it's DND vote         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());     }      ",3.2.3.5/C-5-2,,03020305.670502,DND android.bluetooth.adapter.action.REQUEST ACTION_REQUEST_DISCOVERABLE C-5-2 3.2.3.5 REQUEST_DISCOVERABLE,Test[None]:[android.app.notification.legacy.cts.ConditionProviderServiceTest:testUnboundCPSMaintainsCondition_otherProviderRuleChanges()],,DND,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/notificationlegacy/notificationlegacy27/src/android/app/notification/legacy/cts/ConditionProviderServiceTest.java,,
,3.2.3.5,C-6-1,,android.app.notification.legacy.cts.ConditionProviderServiceTest,testUnboundCPSMaintainsCondition_otherProviderRuleChanges(),,"     public void testUnboundCPSMaintainsCondition_otherProviderRuleChanges() throws Exception {         // make sure both services get bound         pollForConnection(LegacyConditionProviderService.class, true);         pollForConnection(SecondaryConditionProviderService.class, true);          // add rules for both         mModeReceiver.reset();          addRule(LegacyConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, true);         pollForSubscribe(LegacyConditionProviderService.getInstance());          addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_ALARMS, true);         pollForSubscribe(SecondaryConditionProviderService.getInstance());          mModeReceiver.waitFor(2/*Legacy and Secondary*/, 1000/*Limit is 1 second*/);         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // unbind one of the services         SecondaryConditionProviderService.getInstance().requestUnbind();          // verify that DND state doesn't change         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // trigger a change in the bound service's rule         addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, false);          // verify that the unbound service maintains it's DND vote         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());     }      ",3.2.3.5/C-6-1,,03020305.670601,C-6-1 DND ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS 3.2.3.5 MODE_TYPE_NORMAL,Test[None]:[android.app.notification.legacy.cts.ConditionProviderServiceTest:testUnboundCPSMaintainsCondition_otherProviderRuleChanges()],,DND,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/notificationlegacy/notificationlegacy27/src/android/app/notification/legacy/cts/ConditionProviderServiceTest.java,,
,3.2.3.5,C-8-1,,android.accessibilityservice.cts.AccessibilitySettingsTest,testAccessibilitySettingsIntentHandled(),CtsAccessibilityServiceTestCases,"     public void testAccessibilitySettingsIntentHandled() throws Throwable {         PackageManager packageManager = getContext().getPackageManager();         Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);         List<ResolveInfo> resolvedActivities = packageManager.queryIntentActivities(intent,                 PackageManager.MATCH_DEFAULT_ONLY);          // make sure accessibility settings exist         String message = ""Accessibility settings activity must be launched via Intent "" +                 ""Settings.ACTION_ACCESSIBILITY_SETTINGS"";         assertTrue(message, !resolvedActivities.isEmpty());     } }  ",3.2.3.5/C-8-1,,03020305.670801,android.settings.ACCESSIBILITY 3.2.3.5 ACTION_ACCESSIBILITY_SETTINGS ACCESSIBILITY_SETTINGS C-8-1,Test[CtsAccessibilityServiceTestCases]:[android.accessibilityservice.cts.AccessibilitySettingsTest:testAccessibilitySettingsIntentHandled()],,ACCESSIBILITY_SETTINGS,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySettingsTest.java,,
,3.2.3.5,C-11-1,,android.hardware.camera2.cts.HeifWriterTest,testHeif(),CtsCameraTestCases,"     public void testHeif() throws Exception {         final int NUM_SINGLE_CAPTURE_TESTED = 3;         final int NUM_HEIC_CAPTURE_TESTED = 2;         final int SESSION_WARMUP_MS = 1000;         final int HEIF_STOP_TIMEOUT = 3000 * NUM_SINGLE_CAPTURE_TESTED;          if (!canEncodeHeic()) {             MediaUtils.skipTest(""heic encoding is not supported on this device"");             return;         }          boolean sessionFailure = false;         Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,                 BlockingSessionCallback.SESSION_CONFIGURE_FAILED};         for (String id : mCameraIdsUnderTest) {             try {                 Log.v(TAG, ""Testing HEIF capture for Camera "" + id);                 openDevice(id);                  Size[] availableSizes = mStaticInfo.getAvailableSizesForFormatChecked(                         ImageFormat.PRIVATE,                         StaticMetadata.StreamDirection.Output);                  // for each resolution, test imageReader:                 for (Size sz : availableSizes) {                     HeifWriter heifWriter = null;                     OutputConfiguration outConfig = null;                     Surface latestSurface = null;                     CaptureRequest.Builder reqStill = null;                     int width = sz.getWidth();                     int height = sz.getHeight();                     for (int cap = 0; cap < NUM_HEIC_CAPTURE_TESTED; cap++) {                         if (VERBOSE) {                             Log.v(TAG, ""Testing size "" + sz.toString() + "" format PRIVATE""                                     + "" for camera "" + mCamera.getId() + "". Iteration:"" + cap);                         }                          try {                             TestConfig.Builder builder = new TestConfig.Builder(/*useGrid*/false);                             builder.setNumImages(NUM_SINGLE_CAPTURE_TESTED);                             builder.setSize(sz);                             String filename = ""Cam"" + id + ""_"" + width + ""x"" + height +                                     ""_"" + cap + "".heic"";                             builder.setOutputPath(                                     new File(mFilePath, filename).getAbsolutePath());                             TestConfig config = builder.build();                              try {                                 heifWriter = new HeifWriter.Builder(                                         config.mOutputPath,                                         width, height, INPUT_MODE_SURFACE)                                     .setGridEnabled(config.mUseGrid)                                     .setMaxImages(config.mMaxNumImages)                                     .setQuality(config.mQuality)                                     .setPrimaryIndex(config.mNumImages - 1)                                     .setHandler(mHandler)                                     .build();                             } catch (IOException e) {                                 // Continue in case the size is not supported                                 sessionFailure = true;                                 Log.i(TAG, ""Skip due to heifWriter creation failure: ""                                         + e.getMessage());                                 continue;                             }                              // First capture. Start capture session                             latestSurface = heifWriter.getInputSurface();                             outConfig = new OutputConfiguration(latestSurface);                             List<OutputConfiguration> configs =                                 new ArrayList<OutputConfiguration>();                             configs.add(outConfig);                              SurfaceTexture preview = new SurfaceTexture(/*random int*/ 1);                             Surface previewSurface = new Surface(preview);                             preview.setDefaultBufferSize(640, 480);                             configs.add(new OutputConfiguration(previewSurface));                              CaptureRequest.Builder reqPreview = mCamera.createCaptureRequest(                                     CameraDevice.TEMPLATE_PREVIEW);                             reqPreview.addTarget(previewSurface);                              reqStill = mCamera.createCaptureRequest(                                     CameraDevice.TEMPLATE_STILL_CAPTURE);                             reqStill.addTarget(previewSurface);                             reqStill.addTarget(latestSurface);                              // Start capture session and preview                             createSessionByConfigs(configs);                             int state = mCameraSessionListener.getStateWaiter().waitForAnyOfStates(                                     Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);                             if (state == BlockingSessionCallback.SESSION_CONFIGURE_FAILED) {                                 // session configuration failure. Bail out due to known issue of                                 // HeifWriter INPUT_SURFACE mode support for camera. b/79699819                                 sessionFailure = true;                                 break;                             }                             startCapture(reqPreview.build(), /*repeating*/true, null, null);                              SystemClock.sleep(SESSION_WARMUP_MS);                              heifWriter.start();                              // Start capture.                             CaptureRequest request = reqStill.build();                             SimpleCaptureCallback listener = new SimpleCaptureCallback();                              int numImages = config.mNumImages;                              for (int i = 0; i < numImages; i++) {                                 startCapture(request, /*repeating*/false, listener, mHandler);                             }                              // Validate capture result.                             CaptureResult result = validateCaptureResult(                                     ImageFormat.PRIVATE, sz, listener, numImages);                              // TODO: convert capture results into EXIF and send to heifwriter                              heifWriter.stop(HEIF_STOP_TIMEOUT);                              verifyResult(config.mOutputPath, width, height,                                     config.mRotation, config.mUseGrid,                                     Math.min(numImages, config.mMaxNumImages));                         } finally {                             if (heifWriter != null) {                                 heifWriter.close();                                 heifWriter = null;                             }                             if (!sessionFailure) {                                 stopCapture(/*fast*/false);                             }                         }                     }                      if (sessionFailure) {                         break;                     }                 }             } finally {                 closeDevice(id);             }         }     }      private static boolean canEncodeHeic() {         return MediaUtils.hasEncoder(MediaFormat.MIMETYPE_VIDEO_HEVC)             || MediaUtils.hasEncoder(MediaFormat.MIMETYPE_IMAGE_ANDROID_HEIC);     }      private static class TestConfig {         final boolean mUseGrid;         final int mMaxNumImages;         final int mNumImages;         final int mWidth;         final int mHeight;         final int mRotation;         final int mQuality;         final String mOutputPath;          TestConfig(boolean useGrid, int maxNumImages, int numImages,                    int width, int height, int rotation, int quality,                    String outputPath) {             mUseGrid = useGrid;             mMaxNumImages = maxNumImages;             mNumImages = numImages;             mWidth = width;             mHeight = height;             mRotation = rotation;             mQuality = quality;             mOutputPath = outputPath;         }          static class Builder {             final boolean mUseGrid;             int mMaxNumImages;             int mNumImages;             int mWidth;             int mHeight;             int mRotation;             final int mQuality;             String mOutputPath;              Builder(boolean useGrids) {                 mUseGrid = useGrids;                 mMaxNumImages = mNumImages = 4;                 mWidth = 1920;                 mHeight = 1080;                 mRotation = 0;                 mQuality = 100;                 mOutputPath = new File(Environment.getExternalStorageDirectory(),                         OUTPUT_FILENAME).getAbsolutePath();             }              Builder setNumImages(int numImages) {                 mMaxNumImages = mNumImages = numImages;                 return this;             }              Builder setRotation(int rotation) {                 mRotation = rotation;                 return this;             }              Builder setSize(Size sz) {                 mWidth = sz.getWidth();                 mHeight = sz.getHeight();                 return this;             }              Builder setOutputPath(String path) {                 mOutputPath = path;                 return this;             }              private void cleanupStaleOutputs() {                 File outputFile = new File(mOutputPath);                 if (outputFile.exists()) {                     outputFile.delete();                 }             }              TestConfig build() {                 cleanupStaleOutputs();                 return new TestConfig(mUseGrid, mMaxNumImages, mNumImages,                         mWidth, mHeight, mRotation, mQuality, mOutputPath);             }         }          @Override         public String toString() {             return ""TestConfig""                     + "": mUseGrid "" + mUseGrid                     + "", mMaxNumImages "" + mMaxNumImages                     + "", mNumImages "" + mNumImages                     + "", mWidth "" + mWidth                     + "", mHeight "" + mHeight                     + "", mRotation "" + mRotation                     + "", mQuality "" + mQuality                     + "", mOutputPath "" + mOutputPath;         }     }      private void verifyResult(             String filename, int width, int height, int rotation, boolean useGrid, int numImages)             throws Exception {         MediaMetadataRetriever retriever = new MediaMetadataRetriever();         retriever.setDataSource(filename);         String hasImage = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_IMAGE);         if (!""yes"".equals(hasImage)) {             throw new Exception(""No images found in file "" + filename);         }         assertEquals(""Wrong image count"", numImages,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_COUNT)));         assertEquals(""Wrong width"", width,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_WIDTH)));         assertEquals(""Wrong height"", height,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_HEIGHT)));         assertEquals(""Wrong rotation"", rotation,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_ROTATION)));         retriever.release();          if (useGrid) {             MediaExtractor extractor = new MediaExtractor();             extractor.setDataSource(filename);             MediaFormat format = extractor.getTrackFormat(0);             int tileWidth = format.getInteger(MediaFormat.KEY_TILE_WIDTH);             int tileHeight = format.getInteger(MediaFormat.KEY_TILE_HEIGHT);             int gridRows = format.getInteger(MediaFormat.KEY_GRID_ROWS);             int gridCols = format.getInteger(MediaFormat.KEY_GRID_COLUMNS);             assertTrue(""Wrong tile width or grid cols"",                     ((width + tileWidth - 1) / tileWidth) == gridCols);             assertTrue(""Wrong tile height or grid rows"",                     ((height + tileHeight - 1) / tileHeight) == gridRows);             extractor.release();         }     }      /**      * Validate capture results.      *      * @param format The format of this capture.      * @param size The capture size.      * @param listener The capture listener to get capture result callbacks.      * @return the last verified CaptureResult      */     private CaptureResult validateCaptureResult(             int format, Size size, SimpleCaptureCallback listener, int numFrameVerified) {         CaptureResult result = null;         for (int i = 0; i < numFrameVerified; i++) {             result = listener.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);             if (mStaticInfo.isCapabilitySupported(                     CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS)) {                 Long exposureTime = getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);                 Integer sensitivity = getValueNotNull(result, CaptureResult.SENSOR_SENSITIVITY);                 mCollector.expectInRange(                         String.format(                                 ""Capture for format %d, size %s exposure time is invalid."",                                 format, size.toString()),                         exposureTime,                         mStaticInfo.getExposureMinimumOrDefault(),                         mStaticInfo.getExposureMaximumOrDefault()                 );                 mCollector.expectInRange(                         String.format(""Capture for format %d, size %s sensitivity is invalid."",                                 format, size.toString()),                         sensitivity,                         mStaticInfo.getSensitivityMinimumOrDefault(),                         mStaticInfo.getSensitivityMaximumOrDefault()                 );             }             // TODO: add more key validations.         }         return result;     } } ",3.2.3.5/C-11-1,,03020305.671101,Settings.ACTION 3.2.3.5 C-11-1 ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SET TINGS android.hardware.camera.any,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.HeifWriterTest:testHeif()],,TINGS,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,,
,3.2.3.5,C-13-2,,android.content.cts.ClipboardManagerTest,testPrimaryClipNotAvailableWithoutFocus(),,"     public void testPrimaryClipNotAvailableWithoutFocus() throws Exception {         ClipData textData = ClipData.newPlainText(""TextLabel"", ""Text1"");         assertSetPrimaryClip(textData, ""TextLabel"",                 new String[] {ClipDescription.MIMETYPE_TEXT_PLAIN},                 new ExpectedClipItem(""Text1"", null, null));          // Press the home button to unfocus the app.         mUiDevice.pressHome();         mUiDevice.wait(Until.gone(By.clazz(MockActivity.class)), 5000);          // We should see an empty clipboard now.         assertFalse(mClipboardManager.hasPrimaryClip());         assertFalse(mClipboardManager.hasText());         assertNull(mClipboardManager.getPrimaryClip());         assertNull(mClipboardManager.getPrimaryClipDescription());          // We should be able to set the clipboard but not see the contents.         mClipboardManager.setPrimaryClip(ClipData.newPlainText(""TextLabel"", ""Text2""));         assertFalse(mClipboardManager.hasPrimaryClip());         assertFalse(mClipboardManager.hasText());         assertNull(mClipboardManager.getPrimaryClip());         assertNull(mClipboardManager.getPrimaryClipDescription());          // Launch an activity to get back in focus.         launchActivity(MockActivity.class);           // Verify clipboard access is restored.         assertNotNull(mClipboardManager.getPrimaryClip());         assertNotNull(mClipboardManager.getPrimaryClipDescription());          // Verify we were unable to change the clipboard while out of focus.         assertClipData(mClipboardManager.getPrimaryClip(),                 ""TextLabel"",                 new String[] {ClipDescription.MIMETYPE_TEXT_PLAIN},                 new ExpectedClipItem(""Text2"", null, null));     }      private void launchActivity(Class<? extends Activity> clazz) {         Intent intent = new Intent(Intent.ACTION_MAIN);         intent.setClassName(mContext.getPackageName(), clazz.getName());         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         mContext.startActivity(intent);         mUiDevice.wait(Until.hasObject(By.clazz(clazz)), 5000);     }      private class ExpectedClipItem {         CharSequence mText;         Intent mIntent;         Uri mUri;          ExpectedClipItem(CharSequence text, Intent intent, Uri uri) {             mText = text;             mIntent = intent;             mUri = uri;         }     }      private void assertSetPrimaryClip(ClipData clipData,             String expectedLabel,             String[] expectedMimeTypes,             ExpectedClipItem... expectedClipItems) {         ClipboardManager clipboardManager = mClipboardManager;          clipboardManager.setPrimaryClip(clipData);         assertTrue(clipboardManager.hasPrimaryClip());          if (expectedClipItems != null                 && expectedClipItems.length > 0                 && expectedClipItems[0].mText != null) {             assertTrue(clipboardManager.hasText());         } else {             assertFalse(clipboardManager.hasText());         }          assertNotNull(clipboardManager.getPrimaryClip());         assertNotNull(clipboardManager.getPrimaryClipDescription());          assertClipData(clipboardManager.getPrimaryClip(),                 expectedLabel, expectedMimeTypes, expectedClipItems);          assertClipDescription(clipboardManager.getPrimaryClipDescription(),                 expectedLabel, expectedMimeTypes);     }      private static void assertClipData(ClipData actualData, String expectedLabel,             String[] expectedMimeTypes, ExpectedClipItem... expectedClipItems) {         if (expectedClipItems != null) {             assertEquals(expectedClipItems.length, actualData.getItemCount());             for (int i = 0; i < expectedClipItems.length; i++) {                 assertClipItem(expectedClipItems[i], actualData.getItemAt(i));             }         } else {             throw new IllegalArgumentException(""Should have at least one expectedClipItem..."");         }          assertClipDescription(actualData.getDescription(), expectedLabel, expectedMimeTypes);     }      private static void assertClipDescription(ClipDescription description, String expectedLabel,             String... mimeTypes) {         assertEquals(expectedLabel, description.getLabel());         assertEquals(mimeTypes.length, description.getMimeTypeCount());         int mimeTypeCount = description.getMimeTypeCount();         for (int i = 0; i < mimeTypeCount; i++) {             assertEquals(mimeTypes[i], description.getMimeType(i));         }     }      private static void assertClipItem(ExpectedClipItem expectedItem, Item item) {         assertEquals(expectedItem.mText, item.getText());         if (expectedItem.mIntent != null) {             assertNotNull(item.getIntent());         } else {             assertNull(item.getIntent());         }         if (expectedItem.mUri != null) {             assertEquals(expectedItem.mUri.toString(), item.getUri().toString());         } else {             assertNull(item.getUri());         }     }      private boolean hasAutoFillFeature() {         return mContext.getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_AUTOFILL);     } } ",3.2.3.5/C-13-2,,03020305.671302,android.app.action.PROVISIONING android.app.action.ADMIN android.app.action.SET PROVISION_MANAGED_PROFILE C-13-2 android.app.action.PROVISION GET_PROVISIONING_MODE START_ENCRYPTION FEATURE_AUTOFILL PROVISION_MANAGED_DEVICE ACTION_ADMIN_POLICY_COMPLIANCE SET_NEW_PARENT_PROFILE_PASSWORD 3.2.3.5 PackageManager.html ADMIN_POLICY_COMPLIANCE ACTION_START_ENCRYPTION SET_NEW_PASSWORD android.app.action.START android.software.autofill android.app.action.GET PROVISIONING_SUCCESSFUL,Test[None]:[android.content.cts.ClipboardManagerTest:testPrimaryClipNotAvailableWithoutFocus()],,FEATURE_AUTOFILL,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ClipboardManagerTest.java,,
,3.2.3.5,C-14-1,,android.autofillservice.cts.SettingsIntentTest,testWarningShown_userRejectsByTappingBack(),CtsAutoFillServiceTestCases,"     public void testWarningShown_userRejectsByTappingBack() throws Exception {         disableService();          // Launches Settings.         mActivity.startForResult(newSettingsIntent(), MY_REQUEST_CODE);          // Asserts services are shown.         final UiObject2 object = mUiBot                 .assertShownByText(InstrumentedAutoFillService.sServiceLabel);         object.click();          // TODO(b/79615759): should assert that ""autofill_confirmation_message"" is shown, but that         // string belongs to Settings - we need to move it to frameworks/base first (and/or use         // a resource id, also on framework).         // So, for now, just asserts the service name is showing again (in the popup), and the other         // services are not showing (because the popup hides then).          final UiObject2 msgObj = mUiBot.assertShownById(""android:id/message"");         final String msg = msgObj.getText();         assertWithMessage(""Wrong warning message"").that(msg)                 .contains(InstrumentedAutoFillService.sServiceLabel);          // NOTE: assertion below is fine because it looks for the full text, not a substring         mUiBot.assertNotShowingForSure(InstrumentedAutoFillService.sServiceLabel);         mUiBot.assertNotShowingForSure(InstrumentedAutoFillServiceCompatMode.sServiceLabel);         mUiBot.assertNotShowingForSure(NoOpAutofillService.SERVICE_LABEL);         mUiBot.assertNotShowingForSure(BadAutofillService.SERVICE_LABEL);          // Finishes and asserts result.         mUiBot.pressBack();         mActivity.assertResult(Activity.RESULT_CANCELED);     }      // TODO(b/79615759): add testWarningShown_userRejectsByTappingCancel() and     // testWarningShown_userAccepts() - these tests would require adding the strings and resource     // ids to frameworks/base      private Intent newSettingsIntent() {         return new Intent(Settings.ACTION_REQUEST_SET_AUTOFILL_SERVICE)                 .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)                 .setData(Uri.parse(""package:"" + Helper.MY_PACKAGE));     } } ",3.2.3.5/C-14-1,,03020305.671401,Settings.html C-14-1 3.2.3.5 AutofillService.html android.settings.REQUEST ACTION_REQUEST_SET_AUTOFILL_SERVICE REQUEST_SET_AUTOFILL_SERVICE AutofillManager.html,Test[CtsAutoFillServiceTestCases]:[android.autofillservice.cts.SettingsIntentTest:testWarningShown_userRejectsByTappingBack()],,REQUEST_SET_AUTOFILL_SERVICE,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/SettingsIntentTest.java,,
,3.2.3.5,C-15-1,,android.hardware.camera2.cts.HeifWriterTest,testHeif(),CtsCameraTestCases,"     public void testHeif() throws Exception {         final int NUM_SINGLE_CAPTURE_TESTED = 3;         final int NUM_HEIC_CAPTURE_TESTED = 2;         final int SESSION_WARMUP_MS = 1000;         final int HEIF_STOP_TIMEOUT = 3000 * NUM_SINGLE_CAPTURE_TESTED;          if (!canEncodeHeic()) {             MediaUtils.skipTest(""heic encoding is not supported on this device"");             return;         }          boolean sessionFailure = false;         Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,                 BlockingSessionCallback.SESSION_CONFIGURE_FAILED};         for (String id : mCameraIdsUnderTest) {             try {                 Log.v(TAG, ""Testing HEIF capture for Camera "" + id);                 openDevice(id);                  Size[] availableSizes = mStaticInfo.getAvailableSizesForFormatChecked(                         ImageFormat.PRIVATE,                         StaticMetadata.StreamDirection.Output);                  // for each resolution, test imageReader:                 for (Size sz : availableSizes) {                     HeifWriter heifWriter = null;                     OutputConfiguration outConfig = null;                     Surface latestSurface = null;                     CaptureRequest.Builder reqStill = null;                     int width = sz.getWidth();                     int height = sz.getHeight();                     for (int cap = 0; cap < NUM_HEIC_CAPTURE_TESTED; cap++) {                         if (VERBOSE) {                             Log.v(TAG, ""Testing size "" + sz.toString() + "" format PRIVATE""                                     + "" for camera "" + mCamera.getId() + "". Iteration:"" + cap);                         }                          try {                             TestConfig.Builder builder = new TestConfig.Builder(/*useGrid*/false);                             builder.setNumImages(NUM_SINGLE_CAPTURE_TESTED);                             builder.setSize(sz);                             String filename = ""Cam"" + id + ""_"" + width + ""x"" + height +                                     ""_"" + cap + "".heic"";                             builder.setOutputPath(                                     new File(mFilePath, filename).getAbsolutePath());                             TestConfig config = builder.build();                              try {                                 heifWriter = new HeifWriter.Builder(                                         config.mOutputPath,                                         width, height, INPUT_MODE_SURFACE)                                     .setGridEnabled(config.mUseGrid)                                     .setMaxImages(config.mMaxNumImages)                                     .setQuality(config.mQuality)                                     .setPrimaryIndex(config.mNumImages - 1)                                     .setHandler(mHandler)                                     .build();                             } catch (IOException e) {                                 // Continue in case the size is not supported                                 sessionFailure = true;                                 Log.i(TAG, ""Skip due to heifWriter creation failure: ""                                         + e.getMessage());                                 continue;                             }                              // First capture. Start capture session                             latestSurface = heifWriter.getInputSurface();                             outConfig = new OutputConfiguration(latestSurface);                             List<OutputConfiguration> configs =                                 new ArrayList<OutputConfiguration>();                             configs.add(outConfig);                              SurfaceTexture preview = new SurfaceTexture(/*random int*/ 1);                             Surface previewSurface = new Surface(preview);                             preview.setDefaultBufferSize(640, 480);                             configs.add(new OutputConfiguration(previewSurface));                              CaptureRequest.Builder reqPreview = mCamera.createCaptureRequest(                                     CameraDevice.TEMPLATE_PREVIEW);                             reqPreview.addTarget(previewSurface);                              reqStill = mCamera.createCaptureRequest(                                     CameraDevice.TEMPLATE_STILL_CAPTURE);                             reqStill.addTarget(previewSurface);                             reqStill.addTarget(latestSurface);                              // Start capture session and preview                             createSessionByConfigs(configs);                             int state = mCameraSessionListener.getStateWaiter().waitForAnyOfStates(                                     Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);                             if (state == BlockingSessionCallback.SESSION_CONFIGURE_FAILED) {                                 // session configuration failure. Bail out due to known issue of                                 // HeifWriter INPUT_SURFACE mode support for camera. b/79699819                                 sessionFailure = true;                                 break;                             }                             startCapture(reqPreview.build(), /*repeating*/true, null, null);                              SystemClock.sleep(SESSION_WARMUP_MS);                              heifWriter.start();                              // Start capture.                             CaptureRequest request = reqStill.build();                             SimpleCaptureCallback listener = new SimpleCaptureCallback();                              int numImages = config.mNumImages;                              for (int i = 0; i < numImages; i++) {                                 startCapture(request, /*repeating*/false, listener, mHandler);                             }                              // Validate capture result.                             CaptureResult result = validateCaptureResult(                                     ImageFormat.PRIVATE, sz, listener, numImages);                              // TODO: convert capture results into EXIF and send to heifwriter                              heifWriter.stop(HEIF_STOP_TIMEOUT);                              verifyResult(config.mOutputPath, width, height,                                     config.mRotation, config.mUseGrid,                                     Math.min(numImages, config.mMaxNumImages));                         } finally {                             if (heifWriter != null) {                                 heifWriter.close();                                 heifWriter = null;                             }                             if (!sessionFailure) {                                 stopCapture(/*fast*/false);                             }                         }                     }                      if (sessionFailure) {                         break;                     }                 }             } finally {                 closeDevice(id);             }         }     }      private static boolean canEncodeHeic() {         return MediaUtils.hasEncoder(MediaFormat.MIMETYPE_VIDEO_HEVC)             || MediaUtils.hasEncoder(MediaFormat.MIMETYPE_IMAGE_ANDROID_HEIC);     }      private static class TestConfig {         final boolean mUseGrid;         final int mMaxNumImages;         final int mNumImages;         final int mWidth;         final int mHeight;         final int mRotation;         final int mQuality;         final String mOutputPath;          TestConfig(boolean useGrid, int maxNumImages, int numImages,                    int width, int height, int rotation, int quality,                    String outputPath) {             mUseGrid = useGrid;             mMaxNumImages = maxNumImages;             mNumImages = numImages;             mWidth = width;             mHeight = height;             mRotation = rotation;             mQuality = quality;             mOutputPath = outputPath;         }          static class Builder {             final boolean mUseGrid;             int mMaxNumImages;             int mNumImages;             int mWidth;             int mHeight;             int mRotation;             final int mQuality;             String mOutputPath;              Builder(boolean useGrids) {                 mUseGrid = useGrids;                 mMaxNumImages = mNumImages = 4;                 mWidth = 1920;                 mHeight = 1080;                 mRotation = 0;                 mQuality = 100;                 mOutputPath = new File(Environment.getExternalStorageDirectory(),                         OUTPUT_FILENAME).getAbsolutePath();             }              Builder setNumImages(int numImages) {                 mMaxNumImages = mNumImages = numImages;                 return this;             }              Builder setRotation(int rotation) {                 mRotation = rotation;                 return this;             }              Builder setSize(Size sz) {                 mWidth = sz.getWidth();                 mHeight = sz.getHeight();                 return this;             }              Builder setOutputPath(String path) {                 mOutputPath = path;                 return this;             }              private void cleanupStaleOutputs() {                 File outputFile = new File(mOutputPath);                 if (outputFile.exists()) {                     outputFile.delete();                 }             }              TestConfig build() {                 cleanupStaleOutputs();                 return new TestConfig(mUseGrid, mMaxNumImages, mNumImages,                         mWidth, mHeight, mRotation, mQuality, mOutputPath);             }         }          @Override         public String toString() {             return ""TestConfig""                     + "": mUseGrid "" + mUseGrid                     + "", mMaxNumImages "" + mMaxNumImages                     + "", mNumImages "" + mNumImages                     + "", mWidth "" + mWidth                     + "", mHeight "" + mHeight                     + "", mRotation "" + mRotation                     + "", mQuality "" + mQuality                     + "", mOutputPath "" + mOutputPath;         }     }      private void verifyResult(             String filename, int width, int height, int rotation, boolean useGrid, int numImages)             throws Exception {         MediaMetadataRetriever retriever = new MediaMetadataRetriever();         retriever.setDataSource(filename);         String hasImage = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_IMAGE);         if (!""yes"".equals(hasImage)) {             throw new Exception(""No images found in file "" + filename);         }         assertEquals(""Wrong image count"", numImages,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_COUNT)));         assertEquals(""Wrong width"", width,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_WIDTH)));         assertEquals(""Wrong height"", height,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_HEIGHT)));         assertEquals(""Wrong rotation"", rotation,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_ROTATION)));         retriever.release();          if (useGrid) {             MediaExtractor extractor = new MediaExtractor();             extractor.setDataSource(filename);             MediaFormat format = extractor.getTrackFormat(0);             int tileWidth = format.getInteger(MediaFormat.KEY_TILE_WIDTH);             int tileHeight = format.getInteger(MediaFormat.KEY_TILE_HEIGHT);             int gridRows = format.getInteger(MediaFormat.KEY_GRID_ROWS);             int gridCols = format.getInteger(MediaFormat.KEY_GRID_COLUMNS);             assertTrue(""Wrong tile width or grid cols"",                     ((width + tileWidth - 1) / tileWidth) == gridCols);             assertTrue(""Wrong tile height or grid rows"",                     ((height + tileHeight - 1) / tileHeight) == gridRows);             extractor.release();         }     }      /**      * Validate capture results.      *      * @param format The format of this capture.      * @param size The capture size.      * @param listener The capture listener to get capture result callbacks.      * @return the last verified CaptureResult      */     private CaptureResult validateCaptureResult(             int format, Size size, SimpleCaptureCallback listener, int numFrameVerified) {         CaptureResult result = null;         for (int i = 0; i < numFrameVerified; i++) {             result = listener.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);             if (mStaticInfo.isCapabilitySupported(                     CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS)) {                 Long exposureTime = getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);                 Integer sensitivity = getValueNotNull(result, CaptureResult.SENSOR_SENSITIVITY);                 mCollector.expectInRange(                         String.format(                                 ""Capture for format %d, size %s exposure time is invalid."",                                 format, size.toString()),                         exposureTime,                         mStaticInfo.getExposureMinimumOrDefault(),                         mStaticInfo.getExposureMaximumOrDefault()                 );                 mCollector.expectInRange(                         String.format(""Capture for format %d, size %s sensitivity is invalid."",                                 format, size.toString()),                         sensitivity,                         mStaticInfo.getSensitivityMinimumOrDefault(),                         mStaticInfo.getSensitivityMaximumOrDefault()                 );             }             // TODO: add more key validations.         }         return result;     } } ",3.2.3.5/C-15-1,,03020305.671501,USAGE android.hardware.audio.output Settings.html ACTION_USAGE_ACCESS_SETTINGS android.settings.ACTION 3.2.3.5 ACCESS ACTION SETTINGS C-15-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.HeifWriterTest:testHeif()],,SETTINGS,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,,
,3.9.2,C-2-1,,android.assist.cts.AssistTestBase,,,"/*  *.  */  package android.assist.cts;  import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;  import static com.android.compatibility.common.util.ShellUtils.runShellCommand;  import static com.google.common.truth.Truth.assertThat; import static com.google.common.truth.Truth.assertWithMessage;  import static org.junit.Assert.fail;  import android.app.ActivityManager; import android.app.assist.AssistContent; import android.app.assist.AssistStructure; import android.app.assist.AssistStructure.ViewNode; import android.assist.common.AutoResetLatch; import android.assist.common.Utils; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.graphics.Point; import android.os.Bundle; import android.os.Handler; import android.os.HandlerThread; import android.os.LocaleList; import android.os.RemoteCallback; import android.provider.Settings; import android.util.Log; import android.util.Pair; import android.view.Display; import android.view.View; import android.view.ViewGroup; import android.webkit.WebView; import android.widget.EditText; import android.widget.TextView;  import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.test.ext.junit.runners.AndroidJUnit4; import androidx.test.rule.ActivityTestRule;  import com.android.compatibility.common.util.SettingsStateChangerRule; import com.android.compatibility.common.util.SettingsStateManager; import com.android.compatibility.common.util.SettingsUtils; import com.android.compatibility.common.util.StateKeeperRule; import com.android.compatibility.common.util.ThrowingRunnable; import com.android.compatibility.common.util.Timeout;  import org.junit.After; import org.junit.Before; import org.junit.BeforeClass; import org.junit.ClassRule; import org.junit.Rule; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.HashMap; import java.util.Map; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference;  @RunWith(AndroidJUnit4.class) abstract class AssistTestBase {     private static final String TAG = ""AssistTestBase"";      protected static final String FEATURE_VOICE_RECOGNIZERS = ""android.software.voice_recognizers"";      // TODO: use constants from Settings (should be ",3.9.2/C-2-1,,03090200.670201,DevicePolicyManager.html android.content.ComponentName index.html C-2-1 DPC admin.html DevicePolicyManager.ACTION ACTION_SET_NEW_PASSWORD 3.9.2,Test[None]:[android.assist.cts.AssistTestBase:],,android.content.ComponentName,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/assist/src/android/assist/cts/AssistTestBase.java,,
,6.1,C-0-11,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testMonochromeCharacteristics(),CtsCameraTestCases,"     public void testMonochromeCharacteristics() {         for (int i = 0; i < mAllCameraIds.length; i++) {             Log.i(TAG, ""testMonochromeCharacteristics: Testing camera ID "" + mAllCameraIds[i]);              CameraCharacteristics c = mCharacteristics.get(i);             int[] capabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);             assertNotNull(""android.request.availableCapabilities must never be null"",                     capabilities);             boolean supportMonochrome = arrayContains(capabilities, MONOCHROME);              if (!supportMonochrome) {                 continue;             }              List<Key<?>> allKeys = c.getKeys();             List<CaptureRequest.Key<?>> requestKeys = c.getAvailableCaptureRequestKeys();             List<CaptureResult.Key<?>> resultKeys = c.getAvailableCaptureResultKeys();              assertTrue(""Monochrome camera must have BACKWARD_COMPATIBLE capability"",                     arrayContains(capabilities, BC));             int colorFilterArrangement = c.get(                     CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT);             assertTrue(""Monochrome camera must have either MONO or NIR color filter pattern"",                     colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO                     || colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR);              assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX1));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT1));             assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX2));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT2));              assertFalse(                     ""Monochrome capture result must not contain SENSOR_NEUTRAL_COLOR_POINT key"",                     resultKeys.contains(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT));             assertFalse(""Monochrome capture result must not contain SENSOR_GREEN_SPLIT key"",                     resultKeys.contains(CaptureResult.SENSOR_GREEN_SPLIT));              // Check that color correction tags are not available for monochrome cameras             assertTrue(""Monochrome camera must not have MANUAL_POST_PROCESSING capability"",                     !arrayContains(capabilities, MANUAL_POSTPROC));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_GAINS));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_GAINS));              // Check that awbSupportedModes only contains AUTO             int[] awbAvailableModes = c.get(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES);             assertTrue(""availableAwbModes must not be null"", awbAvailableModes != null);             assertTrue(""availableAwbModes must contain only AUTO"", awbAvailableModes.length == 1 &&                     awbAvailableModes[0] == CaptureRequest.CONTROL_AWB_MODE_AUTO);         }     }      /**      * Check that all devices available through the legacy API are also      * accessible via Camera2.      */     @CddTest(requirement=""7.5.4/C-0-11"")     ",6.1/C-0-11,,06010000.670011,C-0-11 6.1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testMonochromeCharacteristics()],/home/gpoor/aosp_platform_source/cts/hostsidetests/adbmanager/src/android/adbmanager/cts/AdbManagerHostDeviceTest.java,C-0-11,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,6.1,C-3-1,,android.hardware.cts.LowRamDeviceTest,testMinDataPartitionSize(),,"     @CddTest(requirement=""7.6.1/H-9-2,7.6.1/H-10-1"")     public void testMinDataPartitionSize() {         long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;          if (lowRam) {             assertDataPartitionMinimumSize(                     ""Application data"",                     mContext.getFilesDir(),                     MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB);         } else {             assertDataPartitionMinimumSize(                     ""Application data"", mContext.getFilesDir(), MIN_APP_DATA_PARTITION_SIZE_GB);         }     }      /**      * @return the total memory accessible by the kernel as defined by      * {@code ActivityManager.MemoryInfo}.      */     private long getTotalMemory() {         ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();         mActivityManager.getMemoryInfo(memoryInfo);         return memoryInfo.totalMem;     }      /** @return the screen size as defined in {@Configuration}. */     private int getScreenSize() {         Configuration config = mContext.getResources().getConfiguration();         return config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;     }      /** @return true iff this device supports 64 bit ABIs */     private static boolean supportsSixtyFourBit() {         return Build.SUPPORTED_64_BIT_ABIS.length > 0;     }      /** Asserts that the given values conform to the specs in CDD 7.6.1 */     private void assertMinMemoryMb(long minMb) {          long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;         boolean lowRamDevice = mActivityManager.isLowRamDevice();          Log.i(TAG, String.format(""minMb=%,d"", minMb));         Log.i(TAG, String.format(""totalMemoryMb=%,d"", totalMemoryMb));         Log.i(TAG, ""lowRam="" + lowRam);         Log.i(TAG, ""lowRamDevice="" + lowRamDevice);          assertTrue(String.format(""Does not meet minimum memory requirements (CDD 7.6.1).""                 + ""Found = %d, Minimum = %d"", totalMemoryMb, minMb), totalMemoryMb >= minMb);          assertTrue(""Device must specify low RAM property: ro.config.low_ram=true"",                 !lowRam || (lowRam && lowRamDevice));     }      private static boolean lessThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi <= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      private static boolean greaterThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi >= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      /** @return true iff the {@code array} contains the {@code target} */     private static boolean contains(int [] array, int target) {         for(int a : array) {             if (a == target) {                 return true;             }         }         return false;     }      private void assertDataPartitionMinimumSize(             String partitionName, File fileInPartition, float minPartitionSizeGb) {         StatFs statFs = new StatFs(fileInPartition.getAbsolutePath());         long size = statFs.getTotalBytes();         long minSizeBytes = (long) minPartitionSizeGb * GB_TO_BYTES_MULTIPLIER;          assertTrue(                 String.format(""%s partition size does not meet requirement. ""                         + ""Found = %d, Minimum = %d"", partitionName, size, minSizeBytes),                 size > minSizeBytes);     } } ",6.1/C-3-1,,06010000.670301,C-3-1 6.1,Test[None]:[android.hardware.cts.LowRamDeviceTest:testMinDataPartitionSize()],,6.1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/cts/LowRamDeviceTest.java,,
,6.1,C-3-2,,android.hardware.cts.LowRamDeviceTest,testMinDataPartitionSize(),,"     @CddTest(requirement=""7.6.1/H-9-2,7.6.1/H-10-1"")     public void testMinDataPartitionSize() {         long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;          if (lowRam) {             assertDataPartitionMinimumSize(                     ""Application data"",                     mContext.getFilesDir(),                     MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB);         } else {             assertDataPartitionMinimumSize(                     ""Application data"", mContext.getFilesDir(), MIN_APP_DATA_PARTITION_SIZE_GB);         }     }      /**      * @return the total memory accessible by the kernel as defined by      * {@code ActivityManager.MemoryInfo}.      */     private long getTotalMemory() {         ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();         mActivityManager.getMemoryInfo(memoryInfo);         return memoryInfo.totalMem;     }      /** @return the screen size as defined in {@Configuration}. */     private int getScreenSize() {         Configuration config = mContext.getResources().getConfiguration();         return config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;     }      /** @return true iff this device supports 64 bit ABIs */     private static boolean supportsSixtyFourBit() {         return Build.SUPPORTED_64_BIT_ABIS.length > 0;     }      /** Asserts that the given values conform to the specs in CDD 7.6.1 */     private void assertMinMemoryMb(long minMb) {          long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;         boolean lowRamDevice = mActivityManager.isLowRamDevice();          Log.i(TAG, String.format(""minMb=%,d"", minMb));         Log.i(TAG, String.format(""totalMemoryMb=%,d"", totalMemoryMb));         Log.i(TAG, ""lowRam="" + lowRam);         Log.i(TAG, ""lowRamDevice="" + lowRamDevice);          assertTrue(String.format(""Does not meet minimum memory requirements (CDD 7.6.1).""                 + ""Found = %d, Minimum = %d"", totalMemoryMb, minMb), totalMemoryMb >= minMb);          assertTrue(""Device must specify low RAM property: ro.config.low_ram=true"",                 !lowRam || (lowRam && lowRamDevice));     }      private static boolean lessThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi <= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      private static boolean greaterThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi >= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      /** @return true iff the {@code array} contains the {@code target} */     private static boolean contains(int [] array, int target) {         for(int a : array) {             if (a == target) {                 return true;             }         }         return false;     }      private void assertDataPartitionMinimumSize(             String partitionName, File fileInPartition, float minPartitionSizeGb) {         StatFs statFs = new StatFs(fileInPartition.getAbsolutePath());         long size = statFs.getTotalBytes();         long minSizeBytes = (long) minPartitionSizeGb * GB_TO_BYTES_MULTIPLIER;          assertTrue(                 String.format(""%s partition size does not meet requirement. ""                         + ""Found = %d, Minimum = %d"", partitionName, size, minSizeBytes),                 size > minSizeBytes);     } } ",6.1/C-3-2,,06010000.670302,C-3-2 6.1,Test[None]:[android.hardware.cts.LowRamDeviceTest:testMinDataPartitionSize()],,6.1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/cts/LowRamDeviceTest.java,,
,6.1,C-4-1,,android.hardware.cts.LowRamDeviceTest,testMinDataPartitionSize(),,"     @CddTest(requirement=""7.6.1/H-9-2,7.6.1/H-10-1"")     public void testMinDataPartitionSize() {         long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;          if (lowRam) {             assertDataPartitionMinimumSize(                     ""Application data"",                     mContext.getFilesDir(),                     MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB);         } else {             assertDataPartitionMinimumSize(                     ""Application data"", mContext.getFilesDir(), MIN_APP_DATA_PARTITION_SIZE_GB);         }     }      /**      * @return the total memory accessible by the kernel as defined by      * {@code ActivityManager.MemoryInfo}.      */     private long getTotalMemory() {         ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();         mActivityManager.getMemoryInfo(memoryInfo);         return memoryInfo.totalMem;     }      /** @return the screen size as defined in {@Configuration}. */     private int getScreenSize() {         Configuration config = mContext.getResources().getConfiguration();         return config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;     }      /** @return true iff this device supports 64 bit ABIs */     private static boolean supportsSixtyFourBit() {         return Build.SUPPORTED_64_BIT_ABIS.length > 0;     }      /** Asserts that the given values conform to the specs in CDD 7.6.1 */     private void assertMinMemoryMb(long minMb) {          long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;         boolean lowRamDevice = mActivityManager.isLowRamDevice();          Log.i(TAG, String.format(""minMb=%,d"", minMb));         Log.i(TAG, String.format(""totalMemoryMb=%,d"", totalMemoryMb));         Log.i(TAG, ""lowRam="" + lowRam);         Log.i(TAG, ""lowRamDevice="" + lowRamDevice);          assertTrue(String.format(""Does not meet minimum memory requirements (CDD 7.6.1).""                 + ""Found = %d, Minimum = %d"", totalMemoryMb, minMb), totalMemoryMb >= minMb);          assertTrue(""Device must specify low RAM property: ro.config.low_ram=true"",                 !lowRam || (lowRam && lowRamDevice));     }      private static boolean lessThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi <= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      private static boolean greaterThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi >= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      /** @return true iff the {@code array} contains the {@code target} */     private static boolean contains(int [] array, int target) {         for(int a : array) {             if (a == target) {                 return true;             }         }         return false;     }      private void assertDataPartitionMinimumSize(             String partitionName, File fileInPartition, float minPartitionSizeGb) {         StatFs statFs = new StatFs(fileInPartition.getAbsolutePath());         long size = statFs.getTotalBytes();         long minSizeBytes = (long) minPartitionSizeGb * GB_TO_BYTES_MULTIPLIER;          assertTrue(                 String.format(""%s partition size does not meet requirement. ""                         + ""Found = %d, Minimum = %d"", partitionName, size, minSizeBytes),                 size > minSizeBytes);     } } ",6.1/C-4-1,,06010000.670401,C-4-1 isAdbWifiSupported() 6.1,Test[None]:[android.hardware.cts.LowRamDeviceTest:testMinDataPartitionSize()],,6.1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/cts/LowRamDeviceTest.java,,
,6.1,C-5-1,,android.hardware.cts.LowRamDeviceTest,testMinDataPartitionSize(),,"     @CddTest(requirement=""7.6.1/H-9-2,7.6.1/H-10-1"")     public void testMinDataPartitionSize() {         long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;          if (lowRam) {             assertDataPartitionMinimumSize(                     ""Application data"",                     mContext.getFilesDir(),                     MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB);         } else {             assertDataPartitionMinimumSize(                     ""Application data"", mContext.getFilesDir(), MIN_APP_DATA_PARTITION_SIZE_GB);         }     }      /**      * @return the total memory accessible by the kernel as defined by      * {@code ActivityManager.MemoryInfo}.      */     private long getTotalMemory() {         ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();         mActivityManager.getMemoryInfo(memoryInfo);         return memoryInfo.totalMem;     }      /** @return the screen size as defined in {@Configuration}. */     private int getScreenSize() {         Configuration config = mContext.getResources().getConfiguration();         return config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;     }      /** @return true iff this device supports 64 bit ABIs */     private static boolean supportsSixtyFourBit() {         return Build.SUPPORTED_64_BIT_ABIS.length > 0;     }      /** Asserts that the given values conform to the specs in CDD 7.6.1 */     private void assertMinMemoryMb(long minMb) {          long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;         boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;         boolean lowRamDevice = mActivityManager.isLowRamDevice();          Log.i(TAG, String.format(""minMb=%,d"", minMb));         Log.i(TAG, String.format(""totalMemoryMb=%,d"", totalMemoryMb));         Log.i(TAG, ""lowRam="" + lowRam);         Log.i(TAG, ""lowRamDevice="" + lowRamDevice);          assertTrue(String.format(""Does not meet minimum memory requirements (CDD 7.6.1).""                 + ""Found = %d, Minimum = %d"", totalMemoryMb, minMb), totalMemoryMb >= minMb);          assertTrue(""Device must specify low RAM property: ro.config.low_ram=true"",                 !lowRam || (lowRam && lowRamDevice));     }      private static boolean lessThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi <= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      private static boolean greaterThanDpi(int actualDensityDpi, int expectedDensityDpi,             int actualScreenSize, int... expectedScreenSizes) {         return actualDensityDpi >= expectedDensityDpi &&                 contains(expectedScreenSizes, actualScreenSize);     }      /** @return true iff the {@code array} contains the {@code target} */     private static boolean contains(int [] array, int target) {         for(int a : array) {             if (a == target) {                 return true;             }         }         return false;     }      private void assertDataPartitionMinimumSize(             String partitionName, File fileInPartition, float minPartitionSizeGb) {         StatFs statFs = new StatFs(fileInPartition.getAbsolutePath());         long size = statFs.getTotalBytes();         long minSizeBytes = (long) minPartitionSizeGb * GB_TO_BYTES_MULTIPLIER;          assertTrue(                 String.format(""%s partition size does not meet requirement. ""                         + ""Found = %d, Minimum = %d"", partitionName, size, minSizeBytes),                 size > minSizeBytes);     } } ",6.1/C-5-1,,06010000.670501,C-5-1 isAdbWifiQrSupported() 6.1,Test[None]:[android.hardware.cts.LowRamDeviceTest:testMinDataPartitionSize()],,6.1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/hardware/src/android/hardware/cts/LowRamDeviceTest.java,,
,7.1.1.1,C-2-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",7.1.1.1/C-2-1,,07010101.670201,C-2-1 display(s) cs.android.com 7.1.1.1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-2-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.1.1.1,C-3-1,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.1.1.1/C-3-1,,07010101.670301,C-3-1 7.1.1.1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.1.4.2,C-1-10,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.1.4.2/C-1-10,,07010402.670110,7.1.4.2 C-1-10 EQP android.software.vulkan.deqp.level,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,7.1.4.2,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.2.3,C-3-1,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.2.3/C-3-1,,07020300.670301,KeyEvent.html C-3-1 KEYCODE_ASSIST 7.2.3,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.2.4,C-3-2,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.4/C-3-2,,07020400.670302,7.2.4 android.hardware.faketouch C-3-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,android.hardware.faketouch,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.2.4,C-3-3,,android.content.res.cts.ConfigTest,testPrecedence(),,"     public void testPrecedence() {         /**          * Check for precedence of resources selected when there are multiple          * options matching the current config.          */         TotalConfig config = makeEmptyConfig();         config.setProperty(Properties.HEIGHT, 640);         config.setProperty(Properties.WIDTH, 400);         Resources res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 640x400"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 640x400""});          config.setProperty(Properties.NAVIGATION, Configuration.NAVIGATION_NONAV);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nonav"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nonav""});          config.setProperty(Properties.KEYBOARD, Configuration.KEYBOARD_NOKEYS);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple nokeys"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag nokeys""});          config.setProperty(Properties.KEYBOARDHIDDEN, Configuration.KEYBOARDHIDDEN_NO);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple keysexposed"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag keysexposed""});          config.setProperty(Properties.TOUCHSCREEN, Configuration.TOUCHSCREEN_NOTOUCH);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple notouch"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag notouch""});          config.setProperty(Properties.DENSITY, 240);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 240dpi"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 240dpi""});          config.setProperty(Properties.ORIENTATION, Configuration.ORIENTATION_LANDSCAPE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple landscape"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag landscape""});          config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_HDR_YES);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple hdr"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag hdr""});          config.setProperty(Properties.COLOR_MODE, Configuration.COLOR_MODE_WIDE_COLOR_GAMUT_YES);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple widecg"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag widecg""});          config.setProperty(Properties.SCREENLAYOUT, Configuration.SCREENLAYOUT_SIZE_XLARGE);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xlarge"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xlarge""});          config.setProperty(Properties.HEIGHT_DP, 670);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple h670"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag h670""});          config.setProperty(Properties.WIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple 720-670"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag 720-670""});          config.setProperty(Properties.SWIDTH_DP, 720);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple sw720"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag sw720""});          config.setProperty(Properties.LANGUAGE, ""xx"");         config.setProperty(Properties.COUNTRY, ""YY"");         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag xx-rYY""});          config.setProperty(Properties.MCC, 111);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111 xx-rYY"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111 xx-rYY""});          config.setProperty(Properties.MNC, 222);         res = config.getResources();         checkValue(res, R.configVarying.simple, ""simple mcc111 mnc222"");         checkValue(res, R.configVarying.bag,                 R.styleable.TestConfig, new String[]{""bag mcc111 mnc222""});     }      ",7.2.4/C-3-3,,07020400.670303,Configuration.touchscreen TOUCHSCREEN_NOTOUCH C-3-3 7.2.4 Configuration.html,Test[None]:[android.content.res.cts.ConfigTest:testPrecedence()],,TOUCHSCREEN_NOTOUCH,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/res/cts/ConfigTest.java,,
,7.2.6.1,C-2-1,,android.assist.cts.AssistTestBase,getInstrumentation(),,"Api)     private static final String ASSIST_STRUCTURE_ENABLED = ""assist_structure_enabled"";     private static final String ASSIST_SCREENSHOT_ENABLED = ""assist_screenshot_enabled"";      private static final Timeout TIMEOUT = new Timeout(             ""AssistTestBaseTimeout"",             10000,             2F,             10000     );      private static final long SLEEP_BEFORE_RETRY_MS = 250L;      private static final Context sContext = getInstrumentation().getTargetContext();      private static final SettingsStateManager sStructureEnabledMgr = new SettingsStateManager(             sContext, SettingsUtils.NAMESPACE_SECURE, ASSIST_STRUCTURE_ENABLED);     private static final SettingsStateManager sScreenshotEnabledMgr = new SettingsStateManager(             sContext, SettingsUtils.NAMESPACE_SECURE, ASSIST_SCREENSHOT_ENABLED);      private final SettingsStateChangerRule mServiceSetterRule = new SettingsStateChangerRule(             sContext, Settings.Secure.VOICE_INTERACTION_SERVICE,             ""android.assist.service/.MainInteractionService"");     private final StateKeeperRule<String> mStructureEnabledKeeperRule = new StateKeeperRule<>(             sStructureEnabledMgr);     private final StateKeeperRule<String> mScreenshotEnabledKeeperRule = new StateKeeperRule<>(             sScreenshotEnabledMgr);     private final ActivityTestRule<TestStartActivity> mActivityTestRule =             new ActivityTestRule<>(TestStartActivity.class, false, false);      @Rule     public final RuleChain mLookAllTheseRules = RuleChain             .outerRule(mServiceSetterRule)             .around(mStructureEnabledKeeperRule)             .around(mScreenshotEnabledKeeperRule)             .around(mActivityTestRule);      protected ActivityManager mActivityManager;     private TestStartActivity mTestActivity;     protected AssistContent mAssistContent;     protected AssistStructure mAssistStructure;     protected boolean mScreenshot;     protected Bundle mAssistBundle;     protected Context mContext;     private AutoResetLatch mReadyLatch = new AutoResetLatch(1);     private AutoResetLatch mHas3pResumedLatch = new AutoResetLatch(1);     private AutoResetLatch mHasTestDestroyedLatch = new AutoResetLatch(1);     private AutoResetLatch mSessionCompletedLatch = new AutoResetLatch(1);     protected AutoResetLatch mAssistDataReceivedLatch = new AutoResetLatch();      protected ActionLatchReceiver mActionLatchReceiver;      private final RemoteCallback mRemoteCallback = new RemoteCallback((result) -> {         String action = result.getString(Utils.EXTRA_REMOTE_CALLBACK_ACTION);         mActionLatchReceiver.onAction(result, action);     });      @Nullable     protected RemoteCallback m3pActivityCallback;     private RemoteCallback m3pCallbackReceiving;      protected boolean mScreenshotMatches;     private Point mDisplaySize;     private String mTestName;     private View mView;      @BeforeClass     public static void setFeatures() {         setFeaturesEnabled(StructureEnabled.TRUE, ScreenshotEnabled.TRUE);         logContextAndScreenshotSetting();     }      @Before     public final void setUp() throws Exception {         mContext = sContext;          // reset old values         mScreenshotMatches = false;         mScreenshot = false;         mAssistStructure = null;         mAssistContent = null;         mAssistBundle = null;          mActionLatchReceiver = new ActionLatchReceiver();          prepareDevice();         registerForAsyncReceivingCallback();          customSetup();     }      /**      * Test-specific setup - doesn't need to call {@code super} neither use <code>@Before</code>.      */     protected void customSetup() throws Exception {     }      @After     public final void tearDown() throws Exception {         customTearDown();         mTestActivity.finish();         mContext.sendBroadcast(new Intent(Utils.HIDE_SESSION));           if (m3pActivityCallback != null) {             m3pActivityCallback.sendResult(Utils.bundleOfRemoteAction(Utils.ACTION_END_OF_TEST));         }          mSessionCompletedLatch.await(3, TimeUnit.SECONDS);     }      /**      * Test-specific teardown - doesn't need to call {@code super} neither use <code>@After</code>.      */     protected void customTearDown() throws Exception {     }      private void prepareDevice() throws Exception {         Log.d(TAG, ""prepareDevice()"");          // Unlock screen.         runShellCommand(""input keyevent KEYCODE_WAKEUP"");          // Dismiss keyguard, in case it's set as ""Swipe to unlock"".         runShellCommand(""wm dismiss-keyguard"");     }      private void registerForAsyncReceivingCallback() {         HandlerThread handlerThread = new HandlerThread(""AssistTestCallbackReceivingThread"");         handlerThread.start();         Handler handler = new Handler(handlerThread.getLooper());          m3pCallbackReceiving = new RemoteCallback((results) -> {             String action = results.getString(Utils.EXTRA_REMOTE_CALLBACK_ACTION);             if (action.equals(Utils.EXTRA_REMOTE_CALLBACK_RECEIVING_ACTION)) {                 m3pActivityCallback = results.getParcelable(Utils.EXTRA_REMOTE_CALLBACK_RECEIVING);             }         }, handler);     }      protected void startTest(String testName) throws Exception {         Log.i(TAG, ""Starting test activity for TestCaseType = "" + testName);         Intent intent = new Intent();         intent.putExtra(Utils.TESTCASE_TYPE, testName);         intent.setAction(""android.intent.action.START_TEST_"" + testName);         intent.putExtra(Utils.EXTRA_REMOTE_CALLBACK, mRemoteCallback);         intent.addFlags(Intent.FLAG_ACTIVITY_MATCH_EXTERNAL);          mTestActivity.startActivity(intent);         waitForTestActivityOnDestroy();     }      protected void start3pApp(String testCaseName) throws Exception {         start3pApp(testCaseName, null);     }      protected void start3pApp(String testCaseName, Bundle extras) throws Exception {         Intent intent = new Intent();         intent.putExtra(Utils.TESTCASE_TYPE, testCaseName);         Utils.setTestAppAction(intent, testCaseName);         intent.putExtra(Utils.EXTRA_REMOTE_CALLBACK, mRemoteCallback);         intent.addFlags(Intent.FLAG_ACTIVITY_MATCH_EXTERNAL);         intent.putExtra(Utils.EXTRA_REMOTE_CALLBACK_RECEIVING, m3pCallbackReceiving);         if (extras != null) {             intent.putExtras(extras);         }          mTestActivity.startActivity(intent);         waitForOnResume();     }      /**      * Starts the shim service activity      */     protected void startTestActivity(String testName) {         Intent intent = new Intent();         mTestName = testName;         intent.setAction(""android.intent.action.TEST_START_ACTIVITY_"" + testName);         intent.putExtra(Utils.TESTCASE_TYPE, testName);         intent.putExtra(Utils.EXTRA_REMOTE_CALLBACK, mRemoteCallback);         mTestActivity = mActivityTestRule.launchActivity(intent);         mActivityManager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);     }      /**      * Called when waiting for Assistant's Broadcast Receiver to be setup      */     protected void waitForAssistantToBeReady() throws Exception {         Log.i(TAG, ""waiting for assistant to be ready before continuing"");         if (!mReadyLatch.await(Utils.TIMEOUT_MS, TimeUnit.MILLISECONDS)) {             fail(""Assistant was not ready before timeout of: "" + Utils.TIMEOUT_MS + ""msec"");         }     }      private void waitForOnResume() throws Exception {         Log.i(TAG, ""waiting for onResume() before continuing"");         if (!mHas3pResumedLatch.await(Utils.ACTIVITY_ONRESUME_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {             fail(""Activity failed to resume in "" + Utils.ACTIVITY_ONRESUME_TIMEOUT_MS + ""msec"");         }     }      private void waitForTestActivityOnDestroy() throws Exception {         Log.i(TAG, ""waiting for mTestActivity onDestroy() before continuing"");         if (!mHasTestDestroyedLatch.await(Utils.ACTIVITY_ONRESUME_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {             fail(""mTestActivity failed to destroy in "" + Utils.ACTIVITY_ONRESUME_TIMEOUT_MS + ""msec"");         }     }      /**      * Send broadcast to MainInteractionService to start a session      */     protected AutoResetLatch startSession() {         return startSession(mTestName, new Bundle());     }      protected AutoResetLatch startSession(String testName, Bundle extras) {         Intent intent = new Intent(Utils.BROADCAST_INTENT_START_ASSIST);         Log.i(TAG, ""passed in class test name is: "" + testName);         intent.putExtra(Utils.TESTCASE_TYPE, testName);         addDimensionsToIntent(intent);         intent.putExtras(extras);         intent.putExtra(Utils.EXTRA_REMOTE_CALLBACK, mRemoteCallback);         intent.setPackage(""android.assist.service"");          mContext.sendBroadcast(intent);         return mAssistDataReceivedLatch;     }      /**      * Calculate display dimensions (including navbar) to pass along in the given intent.      */     private void addDimensionsToIntent(Intent intent) {         if (mDisplaySize == null) {             Display display = mTestActivity.getWindowManager().getDefaultDisplay();             mDisplaySize = new Point();             display.getRealSize(mDisplaySize);         }         intent.putExtra(Utils.DISPLAY_WIDTH_KEY, mDisplaySize.x);         intent.putExtra(Utils.DISPLAY_HEIGHT_KEY, mDisplaySize.y);     }      protected boolean waitForContext(AutoResetLatch sessionLatch) throws Exception {         if (!sessionLatch.await(Utils.getAssistDataTimeout(mTestName), TimeUnit.MILLISECONDS)) {             fail(""Fail to receive broadcast in "" + Utils.getAssistDataTimeout(mTestName) + ""msec"");         }         Log.i(TAG, ""Received broadcast with all information."");         return true;     }      /**      * Checks that the nullness of values are what we expect.      *      * @param isBundleNull True if assistBundle should be null.      * @param isStructureNull True if assistStructure should be null.      * @param isContentNull True if assistContent should be null.      * @param isScreenshotNull True if screenshot should be null.      */     protected void verifyAssistDataNullness(boolean isBundleNull, boolean isStructureNull,             boolean isContentNull, boolean isScreenshotNull) {          if ((mAssistContent == null) != isContentNull) {             fail(String.format(""Should %s have been null - AssistContent: %s"",                     isContentNull ? """" : ""not"", mAssistContent));         }          if ((mAssistStructure == null) != isStructureNull) {             fail(String.format(""Should %s have been null - AssistStructure: %s"",                     isStructureNull ? """" : ""not"", mAssistStructure));         }          if ((mAssistBundle == null) != isBundleNull) {             fail(String.format(""Should %s have been null - AssistBundle: %s"",                     isBundleNull ? """" : ""not"", mAssistBundle));         }          if (mScreenshot == isScreenshotNull) {             fail(String.format(""Should %s have been null - Screenshot: %s"",                     isScreenshotNull ? """":""not"", mScreenshot));         }     }      /**      * Sends a broadcast with the specified scroll positions to the test app.      */     protected void scrollTestApp(int scrollX, int scrollY, boolean scrollTextView,             boolean scrollScrollView) {         mTestActivity.scrollText(scrollX, scrollY, scrollTextView, scrollScrollView);         Intent intent = null;         if (scrollTextView) {             intent = new Intent(Utils.SCROLL_TEXTVIEW_ACTION);         } else if (scrollScrollView) {             intent = new Intent(Utils.SCROLL_SCROLLVIEW_ACTION);         }         intent.putExtra(Utils.SCROLL_X_POSITION, scrollX);         intent.putExtra(Utils.SCROLL_Y_POSITION, scrollY);         mContext.sendBroadcast(intent);     }      /**      * Verifies the view hierarchy of the backgroundApp matches the assist structure.      * @param backgroundApp ComponentName of app the assistant is invoked upon      * @param isSecureWindow Denotes whether the activity has FLAG_SECURE set      */     protected void verifyAssistStructure(ComponentName backgroundApp, boolean isSecureWindow) {         // Check component name matches         assertThat(mAssistStructure.getActivityComponent().flattenToString())                 .isEqualTo(backgroundApp.flattenToString());         long acquisitionStart = mAssistStructure.getAcquisitionStartTime();         long acquisitionEnd = mAssistStructure.getAcquisitionEndTime();         assertThat(acquisitionStart).isGreaterThan(0L);         assertThat(acquisitionEnd).isGreaterThan(0L);         assertThat(acquisitionEnd).isAtLeast(acquisitionStart);         Log.i(TAG, ""Traversing down structure for: "" + backgroundApp.flattenToString());         mView = mTestActivity.findViewById(android.R.id.content).getRootView();         verifyHierarchy(mAssistStructure, isSecureWindow);     }      protected static void logContextAndScreenshotSetting() {         Log.i(TAG, ""Context is: "" + sStructureEnabledMgr.get());         Log.i(TAG, ""Screenshot is: "" + sScreenshotEnabledMgr.get());     }      /**      * Recursively traverse and compare properties in the View hierarchy with the Assist Structure.      */     public void verifyHierarchy(AssistStructure structure, boolean isSecureWindow) {         Log.i(TAG, ""verifyHierarchy"");          int numWindows = structure.getWindowNodeCount();         // TODO: multiple windows?         assertWithMessage(""Number of windows don't match"").that(numWindows).isEqualTo(1);         int[] appLocationOnScreen = new int[2];         mView.getLocationOnScreen(appLocationOnScreen);          for (int i = 0; i < numWindows; i++) {             AssistStructure.WindowNode windowNode = structure.getWindowNodeAt(i);             Log.i(TAG, ""Title: "" + windowNode.getTitle());             // Verify top level window bounds are as big as the app and pinned to its top-left             // corner.             assertWithMessage(""Window left position wrong: was %s"", windowNode.getLeft())                     .that(appLocationOnScreen[0]).isEqualTo(windowNode.getLeft());             assertWithMessage(""Window top position wrong: was %s"", windowNode.getTop())                     .that(appLocationOnScreen[1]).isEqualTo(windowNode.getTop());             traverseViewAndStructure(                     mView,                     windowNode.getRootViewNode(),                     isSecureWindow);         }     }      private void traverseViewAndStructure(View parentView, ViewNode parentNode,             boolean isSecureWindow) {         ViewGroup parentGroup;          if (parentView == null && parentNode == null) {             Log.i(TAG, ""Views are null, done traversing this branch."");             return;         } else if (parentNode == null || parentView == null) {             fail(String.format(""Views don't match. View: %s, Node: %s"", parentView, parentNode));         }          // Debugging         Log.i(TAG, ""parentView is of type: "" + parentView.getClass().getName());         if (parentView instanceof ViewGroup) {             for (int childInt = 0; childInt < ((ViewGroup) parentView).getChildCount();                     childInt++) {                 Log.i(TAG,                         ""viewchild"" + childInt + "" is of type: ""                         + ((ViewGroup) parentView).getChildAt(childInt).getClass().getName());             }         }         String parentViewId = null;         if (parentView.getId() > 0) {             parentViewId = mTestActivity.getResources().getResourceEntryName(parentView.getId());             Log.i(TAG, ""View ID: "" + parentViewId);         }          Log.i(TAG, ""parentNode is of type: "" + parentNode.getClassName());         for (int nodeInt = 0; nodeInt < parentNode.getChildCount(); nodeInt++) {             Log.i(TAG,                     ""nodechild"" + nodeInt + "" is of type: ""                     + parentNode.getChildAt(nodeInt).getClassName());         }         Log.i(TAG, ""Node ID: "" + parentNode.getIdEntry());          assertWithMessage(""IDs do not match"").that(parentNode.getIdEntry()).isEqualTo(parentViewId);          int numViewChildren = 0;         int numNodeChildren = 0;         if (parentView instanceof ViewGroup) {             numViewChildren = ((ViewGroup) parentView).getChildCount();         }         numNodeChildren = parentNode.getChildCount();          if (isSecureWindow) {             assertWithMessage(""ViewNode property isAssistBlocked is false"")                     .that(parentNode.isAssistBlocked()).isTrue();             assertWithMessage(""Secure window should only traverse root node"")                     .that(numNodeChildren).isEqualTo(0);             isSecureWindow = false;         } else if (parentNode.getClassName().equals(""android.webkit.WebView"")) {             // WebView will also appear to have no children while the node does, traverse node             assertWithMessage(""AssistStructure returned a WebView where the view wasn't one"").that(                     parentView instanceof WebView).isTrue();              boolean textInWebView = false;              for (int i = numNodeChildren - 1; i >= 0; i--) {                textInWebView |= traverseWebViewForText(parentNode.getChildAt(i));             }             assertWithMessage(""Did not find expected strings inside WebView"").that(textInWebView)                     .isTrue();         } else {             assertWithMessage(""Number of children did not match"").that(numNodeChildren)                     .isEqualTo(numViewChildren);              verifyViewProperties(parentView, parentNode);              if (parentView instanceof ViewGroup) {                 parentGroup = (ViewGroup) parentView;                  // TODO: set a max recursion level                 for (int i = numNodeChildren - 1; i >= 0; i--) {                     View childView = parentGroup.getChildAt(i);                     ViewNode childNode = parentNode.getChildAt(i);                      // if isSecureWindow, should not have reached this point.                     assertThat(isSecureWindow).isFalse();                     traverseViewAndStructure(childView, childNode, isSecureWindow);                 }             }         }     }      /**      * Return true if the expected strings are found in the WebView, else fail.      */     private boolean traverseWebViewForText(ViewNode parentNode) {         boolean textFound = false;         if (parentNode.getText() != null                 && parentNode.getText().toString().equals(Utils.WEBVIEW_HTML_GREETING)) {             return true;         }         for (int i = parentNode.getChildCount() - 1; i >= 0; i--) {             textFound |= traverseWebViewForText(parentNode.getChildAt(i));         }         return textFound;     }      /**      * Return true if the expected domain is found in the WebView, else fail.      */     protected void verifyAssistStructureHasWebDomain(String domain) {         assertThat(traverse(mAssistStructure.getWindowNodeAt(0).getRootViewNode(), (n) -> {             return n.getWebDomain() != null && domain.equals(n.getWebDomain());         })).isTrue();     }      /**      * Return true if the expected LocaleList is found in the WebView, else fail.      */     protected void verifyAssistStructureHasLocaleList(LocaleList localeList) {         assertThat(traverse(mAssistStructure.getWindowNodeAt(0).getRootViewNode(), (n) -> {             return n.getLocaleList() != null && localeList.equals(n.getLocaleList());         })).isTrue();     }      interface ViewNodeVisitor {         boolean visit(ViewNode node);     }      private boolean traverse(ViewNode parentNode, ViewNodeVisitor visitor) {         if (visitor.visit(parentNode)) {             return true;         }         for (int i = parentNode.getChildCount() - 1; i >= 0; i--) {             if (traverse(parentNode.getChildAt(i), visitor)) {                 return true;             }         }         return false;     }      protected static void setFeaturesEnabled(StructureEnabled structure,             ScreenshotEnabled screenshot) {         Log.i(TAG, ""setFeaturesEnabled("" + structure + "", "" + screenshot + "")"");         sStructureEnabledMgr.set(structure.value);         sScreenshotEnabledMgr.set(screenshot.value);     }      /**      * Compare view properties of the view hierarchy with that reported in the assist structure.      */     private void verifyViewProperties(View parentView, ViewNode parentNode) {         assertWithMessage(""Left positions do not match"").that(parentNode.getLeft())                 .isEqualTo(parentView.getLeft());         assertWithMessage(""Top positions do not match"").that(parentNode.getTop())                 .isEqualTo(parentView.getTop());         assertWithMessage(""Opaque flags do not match"").that(parentNode.isOpaque())                 .isEqualTo(parentView.isOpaque());          int viewId = parentView.getId();          if (viewId > 0) {             if (parentNode.getIdEntry() != null) {                 assertWithMessage(""View IDs do not match."").that(parentNode.getIdEntry())                         .isEqualTo(mTestActivity.getResources().getResourceEntryName(viewId));             }         } else {             assertWithMessage(""View Node should not have an ID"").that(parentNode.getIdEntry())                     .isNull();         }          Log.i(TAG, ""parent text: "" + parentNode.getText());         if (parentView instanceof TextView) {             Log.i(TAG, ""view text: "" + ((TextView) parentView).getText());         }          assertWithMessage(""Scroll X does not match"").that(parentNode.getScrollX())                 .isEqualTo(parentView.getScrollX());         assertWithMessage(""Scroll Y does not match"").that(parentNode.getScrollY())                 .isEqualTo(parentView.getScrollY());         assertWithMessage(""Heights do not match"").that(parentNode.getHeight())                 .isEqualTo(parentView.getHeight());         assertWithMessage(""Widths do not match"").that(parentNode.getWidth())                 .isEqualTo(parentView.getWidth());          if (parentView instanceof TextView) {             if (parentView instanceof EditText) {               assertWithMessage(""Text selection start does not match"")                       .that(parentNode.getTextSelectionStart())                       .isEqualTo(((EditText) parentView).getSelectionStart());               assertWithMessage(""Text selection end does not match"")                 .that(parentNode.getTextSelectionEnd())                       .isEqualTo(((EditText) parentView).getSelectionEnd());             }             TextView textView = (TextView) parentView;             assertThat(parentNode.getTextSize()).isWithin(0.01F).of(textView.getTextSize());             String viewString = textView.getText().toString();             String nodeString = parentNode.getText().toString();              if (parentNode.getScrollX() == 0 && parentNode.getScrollY() == 0) {                 Log.i(TAG, ""Verifying text within TextView at the beginning"");                 Log.i(TAG, ""view string: "" + viewString);                 Log.i(TAG, ""node string: "" + nodeString);                 assertWithMessage(""String length is unexpected: original string - %s, ""                         + ""string in AssistData - %s"", viewString.length(), nodeString.length())                                 .that(viewString.length()).isAtLeast(nodeString.length());                 assertWithMessage(""Expected a longer string to be shown"").that(                         nodeString.length()).isAtLeast(Math.min(viewString.length(), 30));                 for (int x = 0; x < parentNode.getText().length(); x++) {                     assertWithMessage(""Char not equal at index: %s"", x).that(                             parentNode.getText().charAt(x)).isEqualTo(                             ((TextView) parentView).getText().toString().charAt(x));                 }             } else if (parentNode.getScrollX() == parentView.getWidth()) {              }         } else {             assertThat(parentNode.getText()).isNull();         }     }      protected void setAssistResults(Bundle assistData) {         mAssistBundle = assistData.getBundle(Utils.ASSIST_BUNDLE_KEY);         mAssistStructure = assistData.getParcelable(Utils.ASSIST_STRUCTURE_KEY);         mAssistContent = assistData.getParcelable(Utils.ASSIST_CONTENT_KEY);          mScreenshot = assistData.getBoolean(Utils.ASSIST_SCREENSHOT_KEY, false);          mScreenshotMatches = assistData.getBoolean(Utils.COMPARE_SCREENSHOT_KEY, false);     }      protected void eventuallyWithSessionClose(@NonNull ThrowingRunnable runnable) throws Throwable {         AtomicReference<Throwable> innerThrowable = new AtomicReference<>();         try {             TIMEOUT.run(getClass().getName(), SLEEP_BEFORE_RETRY_MS, () -> {                 try {                     runnable.run();                     return runnable;                 } catch (Throwable throwable) {                     // Immediately close the session so the next run can redo its action                     mContext.sendBroadcast(new Intent(Utils.HIDE_SESSION));                     mSessionCompletedLatch.await(2, TimeUnit.SECONDS);                     innerThrowable.set(throwable);                     return null;                 }             });         } catch (Throwable throwable) {             Throwable inner = innerThrowable.get();             if (inner != null) {                 throw inner;             } else {                 throw throwable;             }         }     }      protected enum StructureEnabled {         TRUE(""1""), FALSE(""0"");          private final String value;          private StructureEnabled(String value) {             this.value = value;         }          @Override         public String toString() {             return ""structure_"" + (value.equals(""1"") ? ""enabled"" : ""disabled"");         }      }      protected enum ScreenshotEnabled {         TRUE(""1""), FALSE(""0"");          private final String value;          private ScreenshotEnabled(String value) {             this.value = value;         }          @Override         public String toString() {             return ""screenshot_"" + (value.equals(""1"") ? ""enabled"" : ""disabled"");         }     }      public class ActionLatchReceiver {          private final Map<String, AutoResetLatch> entries = new HashMap<>();          protected ActionLatchReceiver(Pair<String, AutoResetLatch>... entries) {             for (Pair<String, AutoResetLatch> entry : entries) {                 if (entry.second == null) {                     throw new IllegalArgumentException(""Test cannot pass in a null latch"");                 }                 this.entries.put(entry.first, entry.second);             }              this.entries.put(Utils.HIDE_SESSION_COMPLETE, mSessionCompletedLatch);             this.entries.put(Utils.APP_3P_HASRESUMED, mHas3pResumedLatch);             this.entries.put(Utils.TEST_ACTIVITY_DESTROY, mHasTestDestroyedLatch);             this.entries.put(Utils.ASSIST_RECEIVER_REGISTERED, mReadyLatch);             this.entries.put(Utils.BROADCAST_ASSIST_DATA_INTENT, mAssistDataReceivedLatch);         }          protected ActionLatchReceiver(String action, AutoResetLatch latch) {             this(Pair.create(action, latch));         }          protected void onAction(Bundle bundle, String action) {             switch (action) {                 case Utils.BROADCAST_ASSIST_DATA_INTENT:                     AssistTestBase.this.setAssistResults(bundle);                     // fall-through                 default:                     AutoResetLatch latch = entries.get(action);                     if (latch == null) {                         Log.e(TAG, this.getClass() + "": invalid action "" + action);                     } else {                         latch.countDown();                     }                     break;             }         }     } } ",7.2.6.1/C-2-1,,07020601.670201,AXIS_Y AXIS_HAT_X4 AXIS_X KEYCODE_BUTTON_Y android.hardware.gamepad KEYCODE_BUTTON_X KEYCODE_BUTTON_R1 HID KEYCODE_BUTTON_THUMBR AXIS_RZ AXIS_HAT_Y4 KEYCODE_BUTTON_B KEYCODE_HOME AXIS_Z KEYCODE_BACK AXIS_LTRIGGER C-2-1 AXIS_RTRIGGER 7.2.6.1 KEYCODE_BUTTON_A MotionEvent.html KEYCODE_BUTTON_L1 KEYCODE_BUTTON_THUMBL,Test[None]:[android.assist.cts.AssistTestBase:getInstrumentation()],,HID,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/assist/src/android/assist/cts/AssistTestBase.java,,
,7.3,C-1-6,,android.telephony.cts.SmsManagerTest,testSmsBlocking(),,"     public void testSmsBlocking() throws Exception {         assertFalse(""[RERUN] SIM card does not provide phone number. Use a suitable SIM Card."",                 TextUtils.isEmpty(mDestAddr));          // disable suppressing blocking.         TelephonyUtils.endBlockSuppression(getInstrumentation());          String mccmnc = mTelephonyManager.getSimOperator();         // Setting default SMS App is needed to be able to block numbers.         setDefaultSmsApp(true);         blockNumber(mDestAddr);         setupBroadcastReceivers();          // single-part SMS blocking         init();         sendTextMessage(mDestAddr, String.valueOf(SystemClock.elapsedRealtimeNanos()),                 mSentIntent, mDeliveredIntent);         assertTrue(""[RERUN] Could not send SMS. Check signal."",                 mSendReceiver.waitForCalls(1, TIME_OUT));         assertTrue(""Expected no messages to be received due to number blocking."",                 mSmsReceivedReceiver.verifyNoCalls(NO_CALLS_TIMEOUT_MILLIS));         assertTrue(""Expected no messages to be delivered due to number blocking."",                 mSmsDeliverReceiver.verifyNoCalls(NO_CALLS_TIMEOUT_MILLIS));          // send data sms         if (!sendDataMessageIfSupported(mccmnc)) {             assertTrue(""[RERUN] Could not send data SMS. Check signal."",                     mSendReceiver.waitForCalls(1, TIME_OUT));             if (mDeliveryReportSupported) {                 assertTrue(""[RERUN] Data SMS message delivery notification not received. "" +                         ""Check signal."", mDeliveryReceiver.waitForCalls(1, TIME_OUT));             }             assertTrue(""Expected no messages to be delivered due to number blocking."",                     mSmsDeliverReceiver.verifyNoCalls(NO_CALLS_TIMEOUT_MILLIS));         } else {             // This GSM network doesn't support Data(binary) SMS message.             // Skip the test.         }          // multi-part SMS blocking         int numPartsSent = sendMultipartTextMessageIfSupported(mccmnc, /* addMessageId= */ false);         if (numPartsSent > 0) {             assertTrue(""[RERUN] Could not send multi part SMS. Check signal."",                     mSendReceiver.waitForCalls(numPartsSent, TIME_OUT));              assertTrue(""Expected no messages to be received due to number blocking."",                     mSmsReceivedReceiver.verifyNoCalls(NO_CALLS_TIMEOUT_MILLIS));             assertTrue(""Expected no messages to be delivered due to number blocking."",                     mSmsDeliverReceiver.verifyNoCalls(NO_CALLS_TIMEOUT_MILLIS));         } else {             // This GSM network doesn't support Multipart SMS message.             // Skip the test.         }     }      ",7.3/C-1-6,,07030000.670106,SensorEvent.html 7.3 getResolution() SystemClock.elapsedRealtimeNano elapsedRealtimeNano() C-1-6 Sensor.getResolution,Test[None]:[android.telephony.cts.SmsManagerTest:testSmsBlocking()],,SystemClock.elapsedRealtimeNano,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java,,
,7.3,C-1-7,,android.telephony.cts.CellInfoTest,testCellInfo(),,"     public void testCellInfo() throws Throwable {         if(!(mPm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY))) {             Log.d(TAG, ""Skipping test that requires FEATURE_TELEPHONY"");             return;         }          if (!isCamped()) fail(""Device is not camped to a cell"");          // Make a blocking call to requestCellInfoUpdate for results (for simplicity of test).         CellInfoResultsCallback resultsCallback = new CellInfoResultsCallback();         mTm.requestCellInfoUpdate(mSimpleExecutor, resultsCallback);         resultsCallback.wait(MAX_CELLINFO_WAIT_MILLIS);         List<CellInfo> allCellInfo = resultsCallback.cellInfo;          assertNotNull(""TelephonyManager.getAllCellInfo() returned NULL!"", allCellInfo);         assertTrue(""TelephonyManager.getAllCellInfo() returned zero-length list!"",             allCellInfo.size() > 0);          int numRegisteredCells = 0;         for (CellInfo cellInfo : allCellInfo) {             if (cellInfo.isRegistered()) {                 ++numRegisteredCells;             }             verifyBaseCellInfo(cellInfo);             verifyBaseCellIdentity(cellInfo.getCellIdentity(), cellInfo.isRegistered());             if (cellInfo instanceof CellInfoLte) {                 verifyLteInfo((CellInfoLte) cellInfo);             } else if (cellInfo instanceof CellInfoWcdma) {                 verifyWcdmaInfo((CellInfoWcdma) cellInfo);             } else if (cellInfo instanceof CellInfoGsm) {                 verifyGsmInfo((CellInfoGsm) cellInfo);             } else if (cellInfo instanceof CellInfoCdma) {                 verifyCdmaInfo((CellInfoCdma) cellInfo);             } else if (cellInfo instanceof CellInfoTdscdma) {                 verifyTdscdmaInfo((CellInfoTdscdma) cellInfo);             } else if (cellInfo instanceof CellInfoNr) {                 verifyNrInfo((CellInfoNr) cellInfo);             } else {                 fail(""Unknown CellInfo Type reported."");             }         }          //FIXME: The maximum needs to be calculated based on the number of         //       radios and the technologies used (ex SRLTE); however, we have         //       not hit any of these cases yet.         assertTrue(""None or too many registered cells : "" + numRegisteredCells,                 numRegisteredCells > 0 && numRegisteredCells <= 2);     }      private void verifyBaseCellInfo(CellInfo info) {         assertTrue(""Invalid timestamp in CellInfo: "" + info.getTimeStamp(),                 info.getTimeStamp() > 0 && info.getTimeStamp() < Long.MAX_VALUE);          long curTime = SystemClock.elapsedRealtime();         assertTrue(""Invalid timestamp in CellInfo: "" + info.getTimestampMillis(),                 info.getTimestampMillis() > 0 && info.getTimestampMillis() <= curTime);          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             // In HAL 1.2 or greater, the connection status must be reported             assertTrue(info.getCellConnectionStatus() != CellInfo.CONNECTION_UNKNOWN);         }     }      private void verifyBaseCellIdentity(CellIdentity id, boolean isRegistered) {         if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             if (isRegistered) {                 String alphaLong = (String) id.getOperatorAlphaLong();                 assertNotNull(""getOperatorAlphaLong() returns NULL!"", alphaLong);                  String alphaShort = (String) id.getOperatorAlphaShort();                 assertNotNull(""getOperatorAlphaShort() returns NULL!"", alphaShort);             }         }     }      private void verifyCdmaInfo(CellInfoCdma cdma) {         verifyCellConnectionStatus(cdma.getCellConnectionStatus());         verifyCellInfoCdmaParcelandHashcode(cdma);         verifyCellIdentityCdma(cdma.getCellIdentity(), cdma.isRegistered());         verifyCellIdentityCdmaParcel(cdma.getCellIdentity());         verifyCellSignalStrengthCdma(cdma.getCellSignalStrength());         verifyCellSignalStrengthCdmaParcel(cdma.getCellSignalStrength());     }      private void verifyCellInfoCdmaParcelandHashcode(CellInfoCdma cdma) {         Parcel p = Parcel.obtain();         cdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellInfoCdma newCi = CellInfoCdma.CREATOR.createFromParcel(p);         assertTrue(cdma.equals(newCi));         assertEquals(""hashCode() did not get right hashCode"", cdma.hashCode(), newCi.hashCode());     }      private void verifyCellIdentityCdma(CellIdentityCdma cdma, boolean isRegistered) {         int networkId = cdma.getNetworkId();         assertTrue(""getNetworkId() out of range [0,65535], networkId="" + networkId,                 networkId == Integer.MAX_VALUE || (networkId >= 0 && networkId <= NETWORK_ID));          int systemId = cdma.getSystemId();         assertTrue(""getSystemId() out of range [0,32767], systemId="" + systemId,                 systemId == Integer.MAX_VALUE || (systemId >= 0 && systemId <= SYSTEM_ID));          int basestationId = cdma.getBasestationId();         assertTrue(""getBasestationId() out of range [0,65535], basestationId="" + basestationId,                 basestationId == Integer.MAX_VALUE                         || (basestationId >= 0 && basestationId <= BASESTATION_ID));          int longitude = cdma.getLongitude();         assertTrue(""getLongitude() out of range [-2592000,2592000], longitude="" + longitude,                 longitude == Integer.MAX_VALUE                         || (longitude >= -LONGITUDE && longitude <= LONGITUDE));          int latitude = cdma.getLatitude();         assertTrue(""getLatitude() out of range [-1296000,1296000], latitude="" + latitude,                 latitude == Integer.MAX_VALUE || (latitude >= -LATITUDE && latitude <= LATITUDE));          if (isRegistered) {             assertTrue(""SID is required for registered cells"", systemId != Integer.MAX_VALUE);             assertTrue(""NID is required for registered cells"", networkId != Integer.MAX_VALUE);             assertTrue(""BSID is required for registered cells"", basestationId != Integer.MAX_VALUE);         }          verifyCellIdentityCdmaLocationSanitation(cdma);     }      private void verifyCellIdentityCdmaLocationSanitation(CellIdentityCdma cdma) {         CellIdentityCdma sanitized = cdma.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getNetworkId());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getSystemId());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getBasestationId());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getLongitude());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getLatitude());     }      private void verifyCellIdentityCdmaParcel(CellIdentityCdma cdma) {         Parcel p = Parcel.obtain();         cdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityCdma newCi = CellIdentityCdma.CREATOR.createFromParcel(p);         assertTrue(cdma.equals(newCi));     }      private void verifyCellSignalStrengthCdma(CellSignalStrengthCdma cdma) {         int level = cdma.getLevel();         assertTrue(""getLevel() out of range [0,4], level="" + level,                 level >= 0 && level <= 4);          int asuLevel = cdma.getAsuLevel();         assertTrue(""getAsuLevel() out of range [0,97] (or 99 is unknown), asuLevel="" + asuLevel,                 asuLevel == 99 || (asuLevel >= 0 && asuLevel <= 97));          int cdmaLevel = cdma.getCdmaLevel();         assertTrue(""getCdmaLevel() out of range [0,4], cdmaLevel="" + cdmaLevel,                 cdmaLevel >= 0 && cdmaLevel <= 4);          int evdoLevel = cdma.getEvdoLevel();         assertTrue(""getEvdoLevel() out of range [0,4], evdoLevel="" + evdoLevel,                 evdoLevel >= 0 && evdoLevel <= 4);          // The following four fields do not have specific limits. So just calling to verify that         // they don't crash the phone.         int cdmaDbm = cdma.getCdmaDbm();         int evdoDbm = cdma.getEvdoDbm();         cdma.getCdmaEcio();         cdma.getEvdoEcio();          int dbm = (cdmaDbm < evdoDbm) ? cdmaDbm : evdoDbm;         assertEquals(""getDbm() did not get correct value"", dbm, cdma.getDbm());          int evdoSnr = cdma.getEvdoSnr();         assertTrue(""getEvdoSnr() out of range [0,8], evdoSnr="" + evdoSnr,                 (evdoSnr == Integer.MAX_VALUE) || (evdoSnr >= 0 && evdoSnr <= 8));     }      private void verifyCellSignalStrengthCdmaParcel(CellSignalStrengthCdma cdma) {         Parcel p = Parcel.obtain();         cdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthCdma newCss = CellSignalStrengthCdma.CREATOR.createFromParcel(p);         assertEquals(cdma, newCss);     }      private static void verifyPlmnInfo(String mccStr, String mncStr, int mcc, int mnc) {         // If either int value is invalid, all values must be invalid         if (mcc == Integer.MAX_VALUE) {             assertTrue(""MNC and MNC must always be reported together."",                     mnc == Integer.MAX_VALUE && mccStr == null && mncStr == null);             return;         }          assertTrue(""getMcc() out of range [0, 999], mcc="" + mcc, (mcc >= 0 && mcc <= 999));         assertTrue(""getMnc() out of range [0, 999], mnc="" + mnc, (mnc >= 0 && mnc <= 999));         assertTrue(""MCC and MNC Strings must always be reported together."",                 (mccStr == null) == (mncStr == null));          // For legacy compatibility, it's possible to have int values without valid string values         // but not the other way around.         // mccStr is set as NULL if empty, unknown or invalid.         assertTrue(""getMccString() out of range [0, 999], mcc="" + mccStr,                 mccStr == null || mccStr.matches(""^[0-9]{3}$""));         // mccStr must either be null or match mcc integer.         assertTrue(""MccString must match Mcc Integer, str="" + mccStr + "" int="" + mcc,                 mccStr == null || mcc == Integer.parseInt(mccStr));          // mncStr is set as NULL if empty, unknown or invalid.         assertTrue(""getMncString() out of range [0, 999], mnc="" + mncStr,                 mncStr == null || mncStr.matches(""^[0-9]{2,3}$""));         // mncStr must either be null or match mnc integer.         assertTrue(""MncString must match Mnc Integer, str="" + mncStr + "" int="" + mnc,                 mncStr == null || mnc == Integer.parseInt(mncStr));     }      // Verify lte cell information is within correct range.     private void verifyLteInfo(CellInfoLte lte) {         verifyCellConnectionStatus(lte.getCellConnectionStatus());         verifyCellInfoLteParcelandHashcode(lte);         verifyCellIdentityLte(lte.getCellIdentity(), lte.isRegistered());         verifyCellIdentityLteParcel(lte.getCellIdentity());         verifyCellSignalStrengthLte(lte.getCellSignalStrength());         verifyCellSignalStrengthLteParcel(lte.getCellSignalStrength());     }      // Verify NR 5G cell information is within correct range.     private void verifyNrInfo(CellInfoNr nr) {         verifyCellConnectionStatus(nr.getCellConnectionStatus());         verifyCellIdentityNr((CellIdentityNr) nr.getCellIdentity(), nr.isRegistered());         verifyCellIdentityNrParcel((CellIdentityNr) nr.getCellIdentity());         verifyCellSignalStrengthNr((CellSignalStrengthNr) nr.getCellSignalStrength());         verifyCellSignalStrengthNrParcel((CellSignalStrengthNr) nr.getCellSignalStrength());     }      private void verifyCellSignalStrengthNrParcel(CellSignalStrengthNr nr) {         Parcel p = Parcel.obtain();         nr.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthNr newCss = CellSignalStrengthNr.CREATOR.createFromParcel(p);         assertEquals(nr, newCss);     }      private void verifyCellIdentityNrParcel(CellIdentityNr nr) {         Parcel p = Parcel.obtain();         nr.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityNr newCi = CellIdentityNr.CREATOR.createFromParcel(p);         assertEquals(nr, newCi);     }      private void verifyCellIdentityNr(CellIdentityNr nr, boolean isRegistered) {         // This class was added after numeric mcc/mncs were no longer provided, so it lacks the         // basic getMcc() and getMnc() - Dummy out those checks.         String mccStr = nr.getMccString();         String mncStr = nr.getMncString();         verifyPlmnInfo(mccStr, mncStr,                 mccStr != null ? Integer.parseInt(mccStr) : CellInfo.UNAVAILABLE,                 mncStr != null ? Integer.parseInt(mncStr) : CellInfo.UNAVAILABLE);          int pci = nr.getPci();         assertTrue(""getPci() out of range [0, 1007], pci = "" + pci, 0 <= pci && pci <= 1007);          int tac = nr.getTac();         assertTrue(""getTac() out of range [0, 16777215], tac = "" + tac,             (tac == Integer.MAX_VALUE) || (0 <= tac && tac <= 16777215));          int nrArfcn = nr.getNrarfcn();         assertTrue(""getNrarfcn() out of range [0, 3279165], nrarfcn = "" + nrArfcn,                 0 <= nrArfcn && nrArfcn <= 3279165);          for (String plmnId : nr.getAdditionalPlmns()) {             verifyPlmnId(plmnId);         }          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_5) {             int[] bands = nr.getBands();             for (int band: bands) {                 assertTrue(""getBand out of range [1, 95] or [257, 261], band = "" + band,                         (band >= BAND_FR1_MIN_NR && band <= BAND_FR1_MAX_NR)                         || (band >= BAND_FR2_MIN_NR && band <= BAND_FR2_MAX_NR));             }         }          // If the cell is reported as registered, then all the logical cell info must be reported         if (isRegistered) {             assertTrue(""TAC is required for registered cells"", tac != Integer.MAX_VALUE);             assertTrue(""MCC is required for registered cells"", nr.getMccString() != null);             assertTrue(""MNC is required for registered cells"", nr.getMncString() != null);         }          verifyCellIdentityNrLocationSanitation(nr);     }      private void verifyCellIdentityNrLocationSanitation(CellIdentityNr nr) {         CellIdentityNr sanitized = nr.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getPci());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getTac());         assertEquals(CellInfo.UNAVAILABLE_LONG, sanitized.getNci());     }      private void verifyCellSignalStrengthNr(CellSignalStrengthNr nr) {         int csiRsrp = nr.getCsiRsrp();         int csiRsrq = nr.getCsiRsrq();         int csiSinr = nr.getSsSinr();         int ssRsrp = nr.getSsRsrp();         int ssRsrq = nr.getSsRsrq();         int ssSinr = nr.getSsSinr();          assertTrue(""getCsiRsrp() out of range [-140, -44] | Integer.MAX_INTEGER, csiRsrp = ""                         + csiRsrp, -140 <= csiRsrp && csiRsrp <= -44                 || csiRsrp == Integer.MAX_VALUE);         assertTrue(""getCsiRsrq() out of range [-20, -3] | Integer.MAX_INTEGER, csiRsrq = ""                 + csiRsrq, -20 <= csiRsrq && csiRsrq <= -3 || csiRsrq == Integer.MAX_VALUE);         assertTrue(""getCsiSinr() out of range [-23, 40] | Integer.MAX_INTEGER, csiSinr = ""                 + csiSinr, -23 <= csiSinr && csiSinr <= 40 || csiSinr == Integer.MAX_VALUE);         assertTrue(""getSsRsrp() out of range [-140, -44] | Integer.MAX_INTEGER, ssRsrp = ""                         + ssRsrp, -140 <= ssRsrp && ssRsrp <= -44 || ssRsrp == Integer.MAX_VALUE);         assertTrue(""getSsRsrq() out of range [-20, -3] | Integer.MAX_INTEGER, ssRsrq = ""                 + ssRsrq, -20 <= ssRsrq && ssRsrq <= -3 || ssRsrq == Integer.MAX_VALUE);         assertTrue(""getSsSinr() out of range [-23, 40] | Integer.MAX_INTEGER, ssSinr = ""                 + ssSinr, -23 <= ssSinr && ssSinr <= 40 || ssSinr == Integer.MAX_VALUE);     }      private void verifyCellInfoLteParcelandHashcode(CellInfoLte lte) {         Parcel p = Parcel.obtain();         lte.writeToParcel(p, 0);         p.setDataPosition(0);          CellInfoLte newCi = CellInfoLte.CREATOR.createFromParcel(p);         assertTrue(lte.equals(newCi));         assertEquals(""hashCode() did not get right hashCode"", lte.hashCode(), newCi.hashCode());     }      private void verifyCellIdentityLte(CellIdentityLte lte, boolean isRegistered) {         verifyPlmnInfo(lte.getMccString(), lte.getMncString(), lte.getMcc(), lte.getMnc());          // Cell identity ranges from 0 to 268435456.         int ci = lte.getCi();         assertTrue(""getCi() out of range [0,268435456], ci="" + ci,                 (ci == Integer.MAX_VALUE) || (ci >= 0 && ci <= CI));          // Verify LTE physical cell id information.         // Only physical cell id is available for LTE neighbor.         int pci = lte.getPci();         // Physical cell id should be within [0, 503].         assertTrue(""getPci() out of range [0, 503], pci="" + pci,                 (pci== Integer.MAX_VALUE) || (pci >= 0 && pci <= PCI));          // Tracking area code ranges from 0 to 65535.         int tac = lte.getTac();         assertTrue(""getTac() out of range [0,65535], tac="" + tac,                 (tac == Integer.MAX_VALUE) || (tac >= 0 && tac <= TAC));          int bw = lte.getBandwidth();         assertTrue(""getBandwidth out of range [1400, 20000] | Integer.Max_Value, bw="",                 bw == Integer.MAX_VALUE || bw >= BANDWIDTH_LOW && bw <= BANDWIDTH_HIGH);          int earfcn = lte.getEarfcn();         // Reference 3GPP 36.101 Table 5.7.3-1         // As per NOTE 1 in the table, although 0-6 are valid channel numbers for         // LTE, the reported EARFCN is the center frequency, rendering these channels         // out of the range of the narrowest 1.4Mhz deployment.         int minEarfcn = 7;         int maxEarfcn = EARFCN_MAX - 7;         if (bw != Integer.MAX_VALUE) {             // The number of channels used by a cell is equal to the cell bandwidth divided             // by the channel raster (bandwidth of a channel). The center channel is the channel             // the n/2-th channel where n is the number of channels, and since it is the center             // channel that is reported as the channel number for a cell, we can exclude any channel             // numbers within a band that would place the bottom of a cell's bandwidth below the             // edge of the band. For channel numbers in Band 1, the EARFCN numbering starts from             // channel 0, which means that we can exclude from the valid range channels starting             // from 0 and numbered less than half the total number of channels occupied by a cell.             minEarfcn = bw / CHANNEL_RASTER_EUTRAN / 2;             maxEarfcn = EARFCN_MAX - (bw / CHANNEL_RASTER_EUTRAN / 2);         }         assertTrue(                 ""getEarfcn() out of range ["" + minEarfcn + "","" + maxEarfcn + ""], earfcn="" + earfcn,                 earfcn == Integer.MAX_VALUE || (earfcn >= minEarfcn && earfcn <= maxEarfcn));          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_5) {             int[] bands = lte.getBands();             for (int band: bands) {                 assertTrue(""getBand out of range [1, 88], band = "" + band,                         band >= BAND_MIN_LTE && band <= BAND_MAX_LTE);             }         }          String mobileNetworkOperator = lte.getMobileNetworkOperator();         assertTrue(""getMobileNetworkOperator() out of range [0, 999999], mobileNetworkOperator=""                         + mobileNetworkOperator,                 mobileNetworkOperator == null                         || mobileNetworkOperator.matches(""^[0-9]{5,6}$""));          for (String plmnId : lte.getAdditionalPlmns()) {             verifyPlmnId(plmnId);         }          verifyCsgInfo(lte.getClosedSubscriberGroupInfo());          verifyCellIdentityLteLocationSanitation(lte);          // If the cell is reported as registered, then all the logical cell info must be reported         if (isRegistered) {             assertTrue(""TAC is required for registered cells"", tac != Integer.MAX_VALUE);             assertTrue(""CID is required for registered cells"", ci != Integer.MAX_VALUE);             assertTrue(""MCC is required for registered cells"",                     lte.getMccString() != null || lte.getMcc() != Integer.MAX_VALUE);             assertTrue(""MNC is required for registered cells"",                     lte.getMncString() != null || lte.getMnc() != Integer.MAX_VALUE);         }     }      private void verifyCellIdentityLteLocationSanitation(CellIdentityLte lte) {         CellIdentityLte sanitized = lte.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getCi());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getEarfcn());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getPci());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getTac());     }      private void verifyCellIdentityLteParcel(CellIdentityLte lte) {         Parcel p = Parcel.obtain();         lte.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityLte newci = CellIdentityLte.CREATOR.createFromParcel(p);         assertEquals(lte, newci);     }      private void verifyCellSignalStrengthLte(CellSignalStrengthLte cellSignalStrengthLte) {         verifyRssiDbm(cellSignalStrengthLte.getDbm());          //Integer.MAX_VALUE indicates an unavailable field         int rsrp = cellSignalStrengthLte.getRsrp();         // RSRP is being treated as RSSI in LTE (they are similar but not quite right)         // so reusing the constants here.         assertTrue(""getRsrp() out of range, rsrp="" + rsrp, rsrp >= MIN_RSRP && rsrp <= MAX_RSRP);          int rsrq = cellSignalStrengthLte.getRsrq();         assertTrue(""getRsrq() out of range | Integer.MAX_VALUE, rsrq="" + rsrq,             rsrq == Integer.MAX_VALUE || (rsrq >= MIN_RSRQ && rsrq <= MAX_RSRQ));          int rssi = cellSignalStrengthLte.getRssi();         assertTrue(""getRssi() out of range [-113, -51] or Integer.MAX_VALUE if unknown, rssi=""                 + rssi, rssi == CellInfo.UNAVAILABLE                 || (rssi >= MIN_LTE_RSSI && rssi <= MAX_LTE_RSSI));          int rssnr = cellSignalStrengthLte.getRssnr();         assertTrue(""getRssnr() out of range | Integer.MAX_VALUE, rssnr="" + rssnr,             rssnr == Integer.MAX_VALUE || (rssnr >= MIN_RSSNR && rssnr <= MAX_RSSNR));          int cqi = cellSignalStrengthLte.getCqi();         assertTrue(""getCqi() out of range | Integer.MAX_VALUE, cqi="" + cqi,             cqi == Integer.MAX_VALUE || (cqi >= MIN_CQI && cqi <= MAX_CQI));          int ta = cellSignalStrengthLte.getTimingAdvance();         assertTrue(""getTimingAdvance() invalid [0-1282] | Integer.MAX_VALUE, ta="" + ta,                 ta == Integer.MAX_VALUE || (ta >= 0 && ta <=1282));          int level = cellSignalStrengthLte.getLevel();         assertTrue(""getLevel() out of range [0,4], level="" + level, level >= 0 && level <= 4);          int asuLevel = cellSignalStrengthLte.getAsuLevel();         assertTrue(""getAsuLevel() out of range [0,97] (or 99 is unknown), asuLevel="" + asuLevel,                 (asuLevel == 99) || (asuLevel >= 0 && asuLevel <= 97));          int timingAdvance = cellSignalStrengthLte.getTimingAdvance();         assertTrue(""getTimingAdvance() out of range [0,1282], timingAdvance="" + timingAdvance,                 timingAdvance == Integer.MAX_VALUE || (timingAdvance >= 0 && timingAdvance <= 1282));          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             assertTrue(""RSRP Must be valid for LTE"",                     cellSignalStrengthLte.getRsrp() != CellInfo.UNAVAILABLE);         }     }      private void verifyCellSignalStrengthLteParcel(CellSignalStrengthLte cellSignalStrengthLte) {         Parcel p = Parcel.obtain();         cellSignalStrengthLte.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthLte newCss = CellSignalStrengthLte.CREATOR.createFromParcel(p);         assertEquals(cellSignalStrengthLte, newCss);     }      // Verify wcdma cell information is within correct range.     private void verifyWcdmaInfo(CellInfoWcdma wcdma) {         verifyCellConnectionStatus(wcdma.getCellConnectionStatus());         verifyCellInfoWcdmaParcelandHashcode(wcdma);         verifyCellIdentityWcdma(wcdma.getCellIdentity(), wcdma.isRegistered());         verifyCellIdentityWcdmaParcel(wcdma.getCellIdentity());         verifyCellSignalStrengthWcdma(wcdma.getCellSignalStrength());         verifyCellSignalStrengthWcdmaParcel(wcdma.getCellSignalStrength());     }      private void verifyCellInfoWcdmaParcelandHashcode(CellInfoWcdma wcdma) {         Parcel p = Parcel.obtain();         wcdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellInfoWcdma newCi = CellInfoWcdma.CREATOR.createFromParcel(p);         assertTrue(wcdma.equals(newCi));         assertEquals(""hashCode() did not get right hashCode"", wcdma.hashCode(), newCi.hashCode());     }      private void verifyCellIdentityWcdma(CellIdentityWcdma wcdma, boolean isRegistered) {         verifyPlmnInfo(wcdma.getMccString(), wcdma.getMncString(), wcdma.getMcc(), wcdma.getMnc());          int lac = wcdma.getLac();         assertTrue(""getLac() out of range [0, 65535], lac="" + lac,                 (lac >= 0 && lac <= LAC) || lac == Integer.MAX_VALUE);          int cid = wcdma.getCid();         assertTrue(""getCid() out of range [0, 268435455], cid="" + cid,                 (cid >= 0 && cid <= CID_UMTS) || cid == Integer.MAX_VALUE);          // Verify wcdma primary scrambling code information.         // Primary scrambling code should be within [0, 511].         int psc = wcdma.getPsc();         assertTrue(""getPsc() out of range [0, 511], psc="" + psc,                 (psc >= 0 && psc <= PSC) || psc == Integer.MAX_VALUE);          String mobileNetworkOperator = wcdma.getMobileNetworkOperator();         assertTrue(""getMobileNetworkOperator() out of range [0, 999999], mobileNetworkOperator=""                         + mobileNetworkOperator,                 mobileNetworkOperator == null                         || mobileNetworkOperator.matches(""^[0-9]{5,6}$""));          int uarfcn = wcdma.getUarfcn();         // Reference 3GPP 25.101 Table 5.2         // From Appendix E.1, even though UARFCN is numbered from 400, the minumum         // usable channel is 412 due to the fixed bandwidth of 5Mhz         assertTrue(""getUarfcn() out of range [412,11000], uarfcn="" + uarfcn,                 uarfcn >= 412 && uarfcn <= 11000);          for (String plmnId : wcdma.getAdditionalPlmns()) {             verifyPlmnId(plmnId);         }          verifyCsgInfo(wcdma.getClosedSubscriberGroupInfo());          // If the cell is reported as registered, then all the logical cell info must be reported         if (isRegistered) {             assertTrue(""LAC is required for registered cells"", lac != Integer.MAX_VALUE);             assertTrue(""CID is required for registered cells"", cid != Integer.MAX_VALUE);             assertTrue(""MCC is required for registered cells"",                     wcdma.getMccString() != null || wcdma.getMcc() != Integer.MAX_VALUE);             assertTrue(""MNC is required for registered cells"",                     wcdma.getMncString() != null || wcdma.getMnc() != Integer.MAX_VALUE);         }          verifyCellIdentityWcdmaLocationSanitation(wcdma);     }      private void verifyCellIdentityWcdmaLocationSanitation(CellIdentityWcdma wcdma) {         CellIdentityWcdma sanitized = wcdma.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getLac());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getCid());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getPsc());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getUarfcn());     }      private void verifyCellIdentityWcdmaParcel(CellIdentityWcdma wcdma) {         Parcel p = Parcel.obtain();         wcdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityWcdma newci = CellIdentityWcdma.CREATOR.createFromParcel(p);         assertEquals(wcdma, newci);     }      private void verifyCellSignalStrengthWcdma(CellSignalStrengthWcdma wcdma) {         verifyRssiDbm(wcdma.getDbm());          // Dbm here does not have specific limits. So just calling to verify that it does not crash         // the phone         wcdma.getDbm();          int asuLevel = wcdma.getAsuLevel();         if (wcdma.getRscp() != CellInfo.UNAVAILABLE) {             assertTrue(""getAsuLevel() out of range 0..96, 255), asuLevel="" + asuLevel,                     asuLevel == 255 || (asuLevel >= 0 && asuLevel <= 96));         } else if (wcdma.getRssi() != CellInfo.UNAVAILABLE) {             assertTrue(""getAsuLevel() out of range 0..31, 99), asuLevel="" + asuLevel,                     asuLevel == 99 || (asuLevel >= 0 && asuLevel <= 31));         } else {             assertTrue(""getAsuLevel() out of range 0..96, 255), asuLevel="" + asuLevel,                     asuLevel == 255);         }          int level = wcdma.getLevel();         assertTrue(""getLevel() out of range [0,4], level="" + level, level >= 0 && level <= 4);          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             assertTrue(""RSCP Must be valid for WCDMA"", wcdma.getRscp() != CellInfo.UNAVAILABLE);         }          int ecNo = wcdma.getEcNo();         assertTrue(""getEcNo() out of range [-24,1], EcNo="" + ecNo,                 (ecNo >= -24 && ecNo <= 1) || ecNo == CellInfo.UNAVAILABLE);     }      private void verifyCellSignalStrengthWcdmaParcel(CellSignalStrengthWcdma wcdma) {         Parcel p = Parcel.obtain();         wcdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthWcdma newCss = CellSignalStrengthWcdma.CREATOR.createFromParcel(p);         assertEquals(wcdma, newCss);     }      // Verify gsm cell information is within correct range.     private void verifyGsmInfo(CellInfoGsm gsm) {         verifyCellConnectionStatus(gsm.getCellConnectionStatus());         verifyCellInfoWcdmaParcelandHashcode(gsm);         verifyCellIdentityGsm(gsm.getCellIdentity(), gsm.isRegistered());         verifyCellIdentityGsmParcel(gsm.getCellIdentity());         verifyCellSignalStrengthGsm(gsm.getCellSignalStrength());         verifyCellSignalStrengthGsmParcel(gsm.getCellSignalStrength());     }      private void verifyCellInfoWcdmaParcelandHashcode(CellInfoGsm gsm) {         Parcel p = Parcel.obtain();         gsm.writeToParcel(p, 0);         p.setDataPosition(0);          CellInfoGsm newCi = CellInfoGsm.CREATOR.createFromParcel(p);         assertTrue(gsm.equals(newCi));         assertEquals(""hashCode() did not get right hashCode"", gsm.hashCode(), newCi.hashCode());     }      private void verifyCellIdentityGsm(CellIdentityGsm gsm, boolean isRegistered) {         verifyPlmnInfo(gsm.getMccString(), gsm.getMncString(), gsm.getMcc(), gsm.getMnc());          // Local area code and cellid should be with [0, 65535].         int lac = gsm.getLac();         assertTrue(""getLac() out of range [0, 65535], lac="" + lac,                 lac == Integer.MAX_VALUE || (lac >= 0 && lac <= LAC));         int cid = gsm.getCid();         assertTrue(""getCid() out range [0, 65535], cid="" + cid,                 cid== Integer.MAX_VALUE || (cid >= 0 && cid <= CID_GSM));          int arfcn = gsm.getArfcn();         // Reference 3GPP 45.005 Table 2-2         assertTrue(""getArfcn() out of range [0,1024], arfcn="" + arfcn,                 arfcn == Integer.MAX_VALUE || (arfcn >= 0 && arfcn <= ARFCN));          String mobileNetworkOperator = gsm.getMobileNetworkOperator();         assertTrue(""getMobileNetworkOperator() out of range [0, 999999], mobileNetworkOperator=""                         + mobileNetworkOperator,                 mobileNetworkOperator == null                         || mobileNetworkOperator.matches(""^[0-9]{5,6}$""));          int bsic = gsm.getBsic();         // TODO(b/32774471) - Bsic should always be valid         //assertTrue(""getBsic() out of range [0,63]"", bsic >= 0 && bsic <=63);          for (String plmnId : gsm.getAdditionalPlmns()) {             verifyPlmnId(plmnId);         }          // If the cell is reported as registered, then all the logical cell info must be reported         if (isRegistered) {             assertTrue(""LAC is required for registered cells"", lac != Integer.MAX_VALUE);             assertTrue(""CID is required for registered cells"", cid != Integer.MAX_VALUE);             assertTrue(""MCC is required for registered cells"",                     gsm.getMccString() != null || gsm.getMcc() != Integer.MAX_VALUE);             assertTrue(""MNC is required for registered cells"",                     gsm.getMncString() != null || gsm.getMnc() != Integer.MAX_VALUE);         }          verifyCellIdentityGsmLocationSanitation(gsm);     }      private void verifyCellIdentityGsmLocationSanitation(CellIdentityGsm gms) {         CellIdentityGsm sanitized = gms.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getLac());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getCid());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getArfcn());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getBsic());     }      private void verifyCellIdentityGsmParcel(CellIdentityGsm gsm) {         Parcel p = Parcel.obtain();         gsm.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityGsm newci = CellIdentityGsm.CREATOR.createFromParcel(p);         assertEquals(gsm, newci);     }      private void verifyCellSignalStrengthGsm(CellSignalStrengthGsm gsm) {         verifyRssiDbm(gsm.getDbm());          int level = gsm.getLevel();         assertTrue(""getLevel() out of range [0,4], level="" + level, level >= 0 && level <= 4);          int ta = gsm.getTimingAdvance();         assertTrue(""getTimingAdvance() out of range [0,219] | Integer.MAX_VALUE, ta="" + ta,                 ta == Integer.MAX_VALUE || (ta >= 0 && ta <= 219));          assertEquals(gsm.getDbm(), gsm.getRssi());          int asuLevel = gsm.getAsuLevel();         assertTrue(""getLevel() out of range [0,31] (or 99 is unknown), level="" + asuLevel,                 asuLevel == 99 || (asuLevel >=0 && asuLevel <= 31));          int ber = gsm.getBitErrorRate();         assertTrue(""getBitErrorRate out of range [0,7], 99, or CellInfo.UNAVAILABLE, ber="" + ber,                 ber == 99 || ber == CellInfo.UNAVAILABLE || (ber >= 0 && ber <= 7));          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             assertTrue(""RSSI Must be valid for GSM"", gsm.getDbm() != CellInfo.UNAVAILABLE);         }     }      private void verifyCellSignalStrengthGsmParcel(CellSignalStrengthGsm gsm) {         Parcel p = Parcel.obtain();         gsm.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthGsm newCss = CellSignalStrengthGsm.CREATOR.createFromParcel(p);         assertEquals(gsm, newCss);     }      // Verify tdscdma cell information is within correct range.     private void verifyTdscdmaInfo(CellInfoTdscdma tdscdma) {         verifyCellConnectionStatus(tdscdma.getCellConnectionStatus());         verifyCellInfoTdscdmaParcelandHashcode(tdscdma);         verifyCellIdentityTdscdma(tdscdma.getCellIdentity(), tdscdma.isRegistered());         verifyCellIdentityTdscdmaParcel(tdscdma.getCellIdentity());         verifyCellSignalStrengthTdscdma(tdscdma.getCellSignalStrength());         verifyCellSignalStrengthTdscdmaParcel(tdscdma.getCellSignalStrength());     }      private void verifyCellInfoTdscdmaParcelandHashcode(CellInfoTdscdma tdscdma) {         Parcel p = Parcel.obtain();         tdscdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellInfoTdscdma newCi = CellInfoTdscdma.CREATOR.createFromParcel(p);         assertTrue(tdscdma.equals(newCi));         assertEquals(""hashCode() did not get right hashCode"", tdscdma.hashCode(), newCi.hashCode());     }      private void verifyCellIdentityTdscdma(CellIdentityTdscdma tdscdma, boolean isRegistered) {         String mccStr = tdscdma.getMccString();         String mncStr = tdscdma.getMncString();          // This class was added after numeric mcc/mncs were no longer provided, so it lacks the         // basic getMcc() and getMnc() - Dummy out those checks.         verifyPlmnInfo(tdscdma.getMccString(), tdscdma.getMncString(),                 mccStr != null ? Integer.parseInt(mccStr) : CellInfo.UNAVAILABLE,                 mncStr != null ? Integer.parseInt(mncStr) : CellInfo.UNAVAILABLE);          int lac = tdscdma.getLac();         assertTrue(""getLac() out of range [0, 65535], lac="" + lac,                 (lac >= 0 && lac <= LAC) || lac == Integer.MAX_VALUE);          int cid = tdscdma.getCid();         assertTrue(""getCid() out of range [0, 268435455], cid="" + cid,                 (cid >= 0 && cid <= CID_UMTS) || cid == Integer.MAX_VALUE);          // Verify tdscdma primary scrambling code information.         // Primary scrambling code should be within [0, 511].         int cpid = tdscdma.getCpid();         assertTrue(""getCpid() out of range [0, 127], cpid="" + cpid, (cpid >= 0 && cpid <= CPID));          String mobileNetworkOperator = tdscdma.getMobileNetworkOperator();         assertTrue(""getMobileNetworkOperator() out of range [0, 999999], mobileNetworkOperator=""                         + mobileNetworkOperator,                 mobileNetworkOperator == null                         || mobileNetworkOperator.matches(""^[0-9]{5,6}$""));          int uarfcn = tdscdma.getUarfcn();         // Reference 3GPP 25.101 Table 5.2         // From Appendix E.1, even though UARFCN is numbered from 400, the minumum         // usable channel is 412 due to the fixed bandwidth of 5Mhz         assertTrue(""getUarfcn() out of range [412,11000], uarfcn="" + uarfcn,                 uarfcn >= 412 && uarfcn <= 11000);          for (String plmnId : tdscdma.getAdditionalPlmns()) {             verifyPlmnId(plmnId);         }          verifyCsgInfo(tdscdma.getClosedSubscriberGroupInfo());          // If the cell is reported as registered, then all the logical cell info must be reported         if (isRegistered) {             assertTrue(""LAC is required for registered cells"", lac != Integer.MAX_VALUE);             assertTrue(""CID is required for registered cells"", cid != Integer.MAX_VALUE);             assertTrue(""MCC is required for registered cells"", tdscdma.getMccString() != null);             assertTrue(""MNC is required for registered cells"", tdscdma.getMncString() != null);         }          verifyCellIdentityTdscdmaLocationSanitation(tdscdma);     }      private void verifyCellIdentityTdscdmaLocationSanitation(CellIdentityTdscdma tdscdma) {         CellIdentityTdscdma sanitized = tdscdma.sanitizeLocationInfo();         assertEquals(CellInfo.UNAVAILABLE, sanitized.getLac());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getCid());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getCpid());         assertEquals(CellInfo.UNAVAILABLE, sanitized.getUarfcn());     }      private void verifyCellIdentityTdscdmaParcel(CellIdentityTdscdma tdscdma) {         Parcel p = Parcel.obtain();         tdscdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellIdentityTdscdma newci = CellIdentityTdscdma.CREATOR.createFromParcel(p);         assertEquals(tdscdma, newci);     }      private void verifyCellSignalStrengthTdscdma(CellSignalStrengthTdscdma tdscdma) {         verifyRssiDbm(tdscdma.getDbm());          // Dbm here does not have specific limits. So just calling to verify that it does not crash         // the phone         tdscdma.getDbm();          int asuLevel = tdscdma.getAsuLevel();         assertTrue(""getLevel() out of range [0,31] (or 99 is unknown), level="" + asuLevel,                 asuLevel == 99 || (asuLevel >= 0 && asuLevel <= 31));          int level = tdscdma.getLevel();         assertTrue(""getLevel() out of range [0,4], level="" + level, level >= 0 && level <= 4);          if (mRadioHalVersion >= RADIO_HAL_VERSION_1_2) {             assertTrue(""RSCP Must be valid for TDSCDMA"", tdscdma.getRscp() != CellInfo.UNAVAILABLE);         }     }      private void verifyCellSignalStrengthTdscdmaParcel(CellSignalStrengthTdscdma tdscdma) {         Parcel p = Parcel.obtain();         tdscdma.writeToParcel(p, 0);         p.setDataPosition(0);          CellSignalStrengthTdscdma newCss = CellSignalStrengthTdscdma.CREATOR.createFromParcel(p);         assertEquals(tdscdma, newCss);     }      // Rssi(in dbm) should be within [MIN_RSSI, MAX_RSSI].     private static void verifyRssiDbm(int dbm) {         assertTrue(""getCellSignalStrength().getDbm() out of range, dbm="" + dbm,                 dbm >= MIN_RSSI && dbm <= MAX_RSSI);     }      private static void verifyCellConnectionStatus(int status) {         assertTrue(""getCellConnectionStatus() invalid [0,2] | Integer.MAX_VALUE, status="",             status == CellInfo.CONNECTION_NONE                 || status == CellInfo.CONNECTION_PRIMARY_SERVING                 || status == CellInfo.CONNECTION_SECONDARY_SERVING                 || status == CellInfo.CONNECTION_UNKNOWN);     }      private static void verifyPlmnId(String plmnId) {         if (TextUtils.isEmpty(plmnId)) return;          assertTrue(""PlmnId() out of range [00000 - 999999], PLMN ID="" + plmnId,                 plmnId.matches(""^[0-9]{5,6}$""));     }      private static void verifyCsgInfo(@Nullable ClosedSubscriberGroupInfo csgInfo) {         if (csgInfo == null) return;          // This is boolean, so as long as it doesn't crash, we're good.         csgInfo.getCsgIndicator();         // This is nullable, and it's free-form so all we can do is ensure it doesn't crash.         csgInfo.getHomeNodebName();          // It might be technically possible to have a CSG ID of zero, but if that's the case         // then let someone complain about it. It's far more likely that if it's '0', then there         // is a bug.         assertTrue(""CSG Identity out of range"", csgInfo.getCsgIdentity() > 0                 && csgInfo.getCsgIdentity() <= 0x7FFFFF);     } } ",7.3/C-1-7,,07030000.670107,C-1-7 7.3,Test[None]:[android.telephony.cts.CellInfoTest:testCellInfo()],,7.3,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CellInfoTest.java,,
,7.3.6,C-2-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",7.3.6/C-2-1,,07030600.670201,7.3.6 SENSOR_TYPE_AMBIENT_TEMPERATURE TYPE_AMBIENT_TEMPERATURE C-2-1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-2-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.3.10,C-6-2,,android.security.identity.cts.IdentityApiTest,,,"/*  *.  */  package android.security.identity.cts;  import android.content.Context; import android.hardware.biometrics.BiometricPrompt.CryptoObject; import android.security.identity.AccessControlProfileId; import android.security.identity.AlreadyPersonalizedException; import android.security.identity.CipherSuiteNotSupportedException; import android.security.identity.DocTypeNotSupportedException; import android.security.identity.EphemeralPublicKeyNotFoundException; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.InvalidReaderSignatureException; import android.security.identity.InvalidRequestMessageException; import android.security.identity.MessageDecryptionException; import android.security.identity.NoAuthenticationKeyAvailableException; import android.security.identity.SessionTranscriptMismatchException; import android.security.identity.UnknownAuthenticationKeyException;  import androidx.test.InstrumentationRegistry;  import org.junit.Test; import static org.junit.Assert.assertEquals;  public class IdentityApiTest {     private static final String TAG = ""IdentityApiTest"";      ",7.3.10/C-6-2,,07031000.670602,BiometricPrompt.CryptoObject BIOMETRIC_STRONG 7.3.10 C-6-2 BiometricManager.Authenticators,Test[None]:[android.security.identity.cts.IdentityApiTest:],,BiometricPrompt.CryptoObject,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/IdentityApiTest.java,,
,7.3.10,C-3-4,,android.server.wm.AssistantStackTests,testDisallowEnterPiPFromAssistantStack(),,"     public void testDisallowEnterPiPFromAssistantStack() throws Exception {         try (final AssistantSession assistantSession = new AssistantSession()) {             assistantSession.setVoiceInteractionService(ASSISTANT_VOICE_INTERACTION_SERVICE);              launchActivityNoWait(LAUNCH_ASSISTANT_ACTIVITY_INTO_STACK,                     EXTRA_ASSISTANT_ENTER_PIP, ""true"");         }         waitForValidStateWithActivityType(ASSISTANT_ACTIVITY, ACTIVITY_TYPE_ASSISTANT);         mWmState.assertDoesNotContainStack(""Must not contain pinned stack."",                 WINDOWING_MODE_PINNED, ACTIVITY_TYPE_STANDARD);     }      ",7.3.10/C-3-4,,07031000.670304,PIN C-3-4 7.3.10,Test[None]:[android.server.wm.AssistantStackTests:testDisallowEnterPiPFromAssistantStack()],,PIN,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AssistantStackTests.java,,
,7.3.13,C-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testLegacyCameraDeviceParity(),CtsCameraTestCases,"     public void testLegacyCameraDeviceParity() {         if (mAdoptShellPerm) {             // There is no current way to determine in camera1 api if a device is a system camera             // Skip test, http://b/141496896             return;         }         if (mOverrideCameraId != null) {             // A single camera is being tested. Skip test.             return;         }         int legacyDeviceCount = Camera.getNumberOfCameras();         assertTrue(""More legacy devices: "" + legacyDeviceCount + "" compared to Camera2 devices: "" +                 mCharacteristics.size(), legacyDeviceCount <= mCharacteristics.size());          ArrayList<CameraCharacteristics> chars = new ArrayList<> (mCharacteristics);         for (int i = 0; i < legacyDeviceCount; i++) {             Camera camera = null;             Camera.Parameters legacyParams = null;             Camera.CameraInfo legacyInfo = new Camera.CameraInfo();             try {                 Camera.getCameraInfo(i, legacyInfo);                 camera = Camera.open(i);                 legacyParams = camera.getParameters();                  assertNotNull(""Camera parameters for device: "" + i + ""  must not be null"",                         legacyParams);             } finally {                 if (camera != null) {                     camera.release();                 }             }              // Camera Ids between legacy devices and Camera2 device could be             // different try to match devices by using other common traits.             CameraCharacteristics found = null;             for (CameraCharacteristics ch : chars) {                 if (matchParametersToCharacteristics(legacyParams, legacyInfo, ch)) {                     found = ch;                     break;                 }             }             assertNotNull(""No matching Camera2 device for legacy device id: "" + i, found);              chars.remove(found);         }     }      /**      * Check camera orientation against device orientation      */     @CddTest(requirement=""7.5.5/C-1-1"")     ",7.3.13/C-1-1,,07031300.670101,C-1-1 STRING_TYPE_HINGE_ANGLE 7.3.13 TYPE_HINGLE_ANGLE,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testLegacyCameraDeviceParity()],,C-1-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.3.13,C-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,getHeight(),CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import android.content.Context; import android.content.pm.PackageManager; import android.graphics.ImageFormat; import android.graphics.Rect; import android.graphics.SurfaceTexture; import android.hardware.Camera; import android.hardware.camera2.CameraCharacteristics; import android.hardware.camera2.CameraCharacteristics.Key; import android.hardware.camera2.CameraDevice; import android.hardware.camera2.CameraManager; import android.hardware.camera2.CameraMetadata; import android.hardware.camera2.CaptureRequest; import android.hardware.camera2.CaptureResult; import android.hardware.camera2.cts.helpers.CameraErrorCollector; import android.hardware.camera2.cts.helpers.StaticMetadata; import android.hardware.camera2.cts.testcases.Camera2AndroidTestCase; import android.hardware.camera2.params.BlackLevelPattern; import android.hardware.camera2.params.ColorSpaceTransform; import android.hardware.camera2.params.RecommendedStreamConfigurationMap; import android.hardware.camera2.params.StreamConfigurationMap; import android.media.CamcorderProfile; import android.media.ImageReader; import android.os.Build; import android.util.ArraySet; import android.util.DisplayMetrics; import android.util.Log; import android.util.Rational; import android.util.Range; import android.util.Size; import android.util.Pair; import android.util.Patterns; import android.view.Display; import android.view.Surface; import android.view.WindowManager;  import com.android.compatibility.common.util.CddTest;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Objects; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Set;  import org.junit.runners.Parameterized; import org.junit.runner.RunWith; import org.junit.Test;  import static android.hardware.camera2.cts.helpers.AssertHelpers.*; import static android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback; import static android.hardware.cts.helpers.CameraUtils.matchParametersToCharacteristics;  import static junit.framework.Assert.*;  import static org.mockito.Mockito.*;  /**  * Extended tests for static camera characteristics.  */ @RunWith(Parameterized.class) public class ExtendedCameraCharacteristicsTest extends Camera2AndroidTestCase {     private static final String TAG = ""ExChrsTest""; // must be short so next line doesn't throw     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);      private static final String PREFIX_ANDROID = ""android"";      /*      * Constants for static RAW metadata.      */     private static final int MIN_ALLOWABLE_WHITELEVEL = 32; // must have sensor bit depth > 5      private List<CameraCharacteristics> mCharacteristics;      private static final Size FULLHD = new Size(1920, 1080);     private static final Size FULLHD_ALT = new Size(1920, 1088);     private static final Size HD = new Size(1280, 720);     private static final Size VGA = new Size(640, 480);     private static final Size QVGA = new Size(320, 240);     private static final Size UHD = new Size(3840, 2160);     private static final Size DC4K = new Size(4096, 2160);      private static final long MIN_BACK_SENSOR_RESOLUTION = 2000000;     private static final long MIN_FRONT_SENSOR_RESOLUTION = VGA.getHeight() * VGA.getWidth();     private static final long LOW_LATENCY_THRESHOLD_MS = 200;     private static final float LATENCY_TOLERANCE_FACTOR = 1.1f; // 10% tolerance     private static final int MAX_NUM_IMAGES = 5;     private static final long PREVIEW_RUN_MS = 500;     private static final long FRAME_DURATION_30FPS_NSEC = (long) 1e9 / 30;      private static final long MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION = 12000000;     private static final long MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION = 5000000;     private static final long MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION = 4000000;      /*      * HW Levels short hand      */     private static final int LEGACY = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY;     private static final int LIMITED = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED;     private static final int FULL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL;     private static final int LEVEL_3 = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3;     private static final int EXTERNAL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL;     private static final int OPT = Integer.MAX_VALUE;  // For keys that are optional on all hardware levels.      /*      * Capabilities short hand      */     private static final int NONE = -1;     private static final int BC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE;     private static final int MANUAL_SENSOR =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR;     private static final int MANUAL_POSTPROC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING;     private static final int RAW =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW;     private static final int YUV_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING;     private static final int OPAQUE_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING;     private static final int CONSTRAINED_HIGH_SPEED =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO;     private static final int MONOCHROME =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME;     private static final int HIGH_SPEED_FPS_LOWER_MIN = 30;     private static final int HIGH_SPEED_FPS_UPPER_MIN = 120;      @Override     public void setUp() throws Exception {         super.setUp();         mCharacteristics = new ArrayList<>();         for (int i = 0; i < mAllCameraIds.length; i++) {             mCharacteristics.add(mAllStaticInfo.get(mAllCameraIds[i]).getCharacteristics());         }     }      @Override     public void tearDown() throws Exception {         super.tearDown();         mCharacteristics = null;     }      /**      * Test that the available stream configurations contain a few required formats and sizes.      */     @CddTest(requirement=""7.5.1/C-1-2"")     ",7.3.13/C-1-2,,07031300.670102,C-1-2 7.3.13,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:getHeight()],,C-1-2,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.4.5.3,C-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testLegacyCameraDeviceParity(),CtsCameraTestCases,"     public void testLegacyCameraDeviceParity() {         if (mAdoptShellPerm) {             // There is no current way to determine in camera1 api if a device is a system camera             // Skip test, http://b/141496896             return;         }         if (mOverrideCameraId != null) {             // A single camera is being tested. Skip test.             return;         }         int legacyDeviceCount = Camera.getNumberOfCameras();         assertTrue(""More legacy devices: "" + legacyDeviceCount + "" compared to Camera2 devices: "" +                 mCharacteristics.size(), legacyDeviceCount <= mCharacteristics.size());          ArrayList<CameraCharacteristics> chars = new ArrayList<> (mCharacteristics);         for (int i = 0; i < legacyDeviceCount; i++) {             Camera camera = null;             Camera.Parameters legacyParams = null;             Camera.CameraInfo legacyInfo = new Camera.CameraInfo();             try {                 Camera.getCameraInfo(i, legacyInfo);                 camera = Camera.open(i);                 legacyParams = camera.getParameters();                  assertNotNull(""Camera parameters for device: "" + i + ""  must not be null"",                         legacyParams);             } finally {                 if (camera != null) {                     camera.release();                 }             }              // Camera Ids between legacy devices and Camera2 device could be             // different try to match devices by using other common traits.             CameraCharacteristics found = null;             for (CameraCharacteristics ch : chars) {                 if (matchParametersToCharacteristics(legacyParams, legacyInfo, ch)) {                     found = ch;                     break;                 }             }             assertNotNull(""No matching Camera2 device for legacy device id: "" + i, found);              chars.remove(found);         }     }      /**      * Check camera orientation against device orientation      */     @CddTest(requirement=""7.5.5/C-1-1"")     ",7.4.5.3/C-1-1,,07040503.670101,ACTION_CAPTIVE_PORTAL_SIGN_IN 7.4.5.3 C-1-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testLegacyCameraDeviceParity()],,C-1-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.4.5.3,C-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,getHeight(),CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import android.content.Context; import android.content.pm.PackageManager; import android.graphics.ImageFormat; import android.graphics.Rect; import android.graphics.SurfaceTexture; import android.hardware.Camera; import android.hardware.camera2.CameraCharacteristics; import android.hardware.camera2.CameraCharacteristics.Key; import android.hardware.camera2.CameraDevice; import android.hardware.camera2.CameraManager; import android.hardware.camera2.CameraMetadata; import android.hardware.camera2.CaptureRequest; import android.hardware.camera2.CaptureResult; import android.hardware.camera2.cts.helpers.CameraErrorCollector; import android.hardware.camera2.cts.helpers.StaticMetadata; import android.hardware.camera2.cts.testcases.Camera2AndroidTestCase; import android.hardware.camera2.params.BlackLevelPattern; import android.hardware.camera2.params.ColorSpaceTransform; import android.hardware.camera2.params.RecommendedStreamConfigurationMap; import android.hardware.camera2.params.StreamConfigurationMap; import android.media.CamcorderProfile; import android.media.ImageReader; import android.os.Build; import android.util.ArraySet; import android.util.DisplayMetrics; import android.util.Log; import android.util.Rational; import android.util.Range; import android.util.Size; import android.util.Pair; import android.util.Patterns; import android.view.Display; import android.view.Surface; import android.view.WindowManager;  import com.android.compatibility.common.util.CddTest;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Objects; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Set;  import org.junit.runners.Parameterized; import org.junit.runner.RunWith; import org.junit.Test;  import static android.hardware.camera2.cts.helpers.AssertHelpers.*; import static android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback; import static android.hardware.cts.helpers.CameraUtils.matchParametersToCharacteristics;  import static junit.framework.Assert.*;  import static org.mockito.Mockito.*;  /**  * Extended tests for static camera characteristics.  */ @RunWith(Parameterized.class) public class ExtendedCameraCharacteristicsTest extends Camera2AndroidTestCase {     private static final String TAG = ""ExChrsTest""; // must be short so next line doesn't throw     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);      private static final String PREFIX_ANDROID = ""android"";      /*      * Constants for static RAW metadata.      */     private static final int MIN_ALLOWABLE_WHITELEVEL = 32; // must have sensor bit depth > 5      private List<CameraCharacteristics> mCharacteristics;      private static final Size FULLHD = new Size(1920, 1080);     private static final Size FULLHD_ALT = new Size(1920, 1088);     private static final Size HD = new Size(1280, 720);     private static final Size VGA = new Size(640, 480);     private static final Size QVGA = new Size(320, 240);     private static final Size UHD = new Size(3840, 2160);     private static final Size DC4K = new Size(4096, 2160);      private static final long MIN_BACK_SENSOR_RESOLUTION = 2000000;     private static final long MIN_FRONT_SENSOR_RESOLUTION = VGA.getHeight() * VGA.getWidth();     private static final long LOW_LATENCY_THRESHOLD_MS = 200;     private static final float LATENCY_TOLERANCE_FACTOR = 1.1f; // 10% tolerance     private static final int MAX_NUM_IMAGES = 5;     private static final long PREVIEW_RUN_MS = 500;     private static final long FRAME_DURATION_30FPS_NSEC = (long) 1e9 / 30;      private static final long MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION = 12000000;     private static final long MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION = 5000000;     private static final long MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION = 4000000;      /*      * HW Levels short hand      */     private static final int LEGACY = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY;     private static final int LIMITED = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED;     private static final int FULL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL;     private static final int LEVEL_3 = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3;     private static final int EXTERNAL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL;     private static final int OPT = Integer.MAX_VALUE;  // For keys that are optional on all hardware levels.      /*      * Capabilities short hand      */     private static final int NONE = -1;     private static final int BC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE;     private static final int MANUAL_SENSOR =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR;     private static final int MANUAL_POSTPROC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING;     private static final int RAW =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW;     private static final int YUV_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING;     private static final int OPAQUE_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING;     private static final int CONSTRAINED_HIGH_SPEED =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO;     private static final int MONOCHROME =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME;     private static final int HIGH_SPEED_FPS_LOWER_MIN = 30;     private static final int HIGH_SPEED_FPS_UPPER_MIN = 120;      @Override     public void setUp() throws Exception {         super.setUp();         mCharacteristics = new ArrayList<>();         for (int i = 0; i < mAllCameraIds.length; i++) {             mCharacteristics.add(mAllStaticInfo.get(mAllCameraIds[i]).getCharacteristics());         }     }      @Override     public void tearDown() throws Exception {         super.tearDown();         mCharacteristics = null;     }      /**      * Test that the available stream configurations contain a few required formats and sizes.      */     @CddTest(requirement=""7.5.1/C-1-2"")     ",7.4.5.3/C-1-2,,07040503.670102,C-1-2 7.4.5.3,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:getHeight()],,C-1-2,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.4.5.3,C-1-3,,android.net.ipsec.ike.cts.IkeSessionPskTest,testIkeSessionSetupAndChildSessionSetupWithTunnelModeV6(),,"     public void testIkeSessionSetupAndChildSessionSetupWithTunnelModeV6() throws Exception {         if (!hasTunnelsFeature()) return;          final String ikeInitResp =                 ""46B8ECA1E0D72A186F7B6C2CEB77EB9021202220000000000000011822000030""                         + ""0000002C010100040300000C0100000C800E0100030000080300000C03000008""                         + ""0200000500000008040000022800008800020000DABAA04B38B491E2403F2125""                         + ""96ECF1C8EF7B1DC19A422FDD46E1756C826BB3A16404361B775D9950577B5CDF""                         + ""6AAA1642BD1427BDA8BC55354A97C1025E19C1E2EE2DF8A0C9406E545D829F52""                         + ""75695008E3B742984B8DD1770F3514213B0DF3EE8B199416DF200D248115C057""                         + ""1C193E4F96802E5EF48DD99CAC251882A8F7CCC329000024BC6F0F1D3653C2C7""                         + ""679E02CDB6A3B32B2FEE9AF52F0326D4D9AE073D56CE8922290000080000402E""                         + ""290000100000402F00020003000400050000000800004014"";         final String ikeAuthResp =                 ""46B8ECA1E0D72A186F7B6C2CEB77EB902E202320000000010000015024000134""                         + ""4D115AFDCDAD0310760BB664EB7D405A340869AD6EDF0AAEAD0663A9253DADCB""                         + ""73EBE5CD29D4FA1CDEADE0B94391B5C4CF77BCC1596ACE3CE6A7891E44888FA5""                         + ""46632C0EF4E6193C023C9DC59142C37D1C49D6EF5CD324EC6FC35C89E1721C78""                         + ""91FDCDB723D8062709950F4AA9273D26A54C9C7E86862DBC15F7B6641D2B9BAD""                         + ""E55069008201D12968D97B537B1518FE87B0FFA03C3EE6012C06721B1E2A3F68""                         + ""92108BC4A4F7063F7F94562D8B60F291A1377A836CF12BCDA7E15C1A8F3C77BB""                         + ""6DB7F2C833CCE4CDDED7506536621A3356CE2BC1874E7B1A1A9B447D7DF6AB09""                         + ""638B8AD94A781B28BB91B514B611B24DF8E8A047A10AE27BBF15C754D3D2F792""                         + ""D3E1CCADDAE934C98AE53A8FC3419C88AFF0355564F82A629C998012DA7BB704""                         + ""5307270DF326377E3E1994476902035B"";         final String deleteIkeResp =                 ""46B8ECA1E0D72A186F7B6C2CEB77EB902E202520000000020000005000000034""                         + ""CF15C299F35688E5140A48B61C95F004121BF8236201415E5CD45BA41AAB16D4""                         + ""90B44B9E6D5D92B5B97D24196A58C73F"";          mLocalAddress = IPV6_ADDRESS_LOCAL;         mRemoteAddress = IPV6_ADDRESS_REMOTE;          // Teardown current test network that uses IPv4 address and set up new network with IPv6         // address.         tearDownTestNetwork();         setUpTestNetwork(mLocalAddress);          // Open IKE Session         IkeSession ikeSession = openIkeSessionWithTunnelModeChild(mRemoteAddress);         performSetupIkeAndFirstChildBlocking(                 ikeInitResp,                 1 /* expectedAuthReqPktCnt */,                 false /* expectedAuthUseEncap */,                 ikeAuthResp);          // Local request message ID starts from 2 because there is one IKE_INIT message and a single         // IKE_AUTH message.         int expectedMsgId = 2;          verifyIkeSessionSetupBlocking();         verifyChildSessionSetupBlocking(                 mFirstChildSessionCallback,                 Arrays.asList(TUNNEL_MODE_INBOUND_TS_V6),                 Arrays.asList(TUNNEL_MODE_OUTBOUND_TS_V6),                 Arrays.asList(EXPECTED_INTERNAL_LINK_ADDR_V6),                 Arrays.asList(EXPECTED_DNS_SERVERS_ONE, EXPECTED_DNS_SERVERS_TWO));          IpSecTransformCallRecord firstTransformRecordA =                 mFirstChildSessionCallback.awaitNextCreatedIpSecTransform();         IpSecTransformCallRecord firstTransformRecordB =                 mFirstChildSessionCallback.awaitNextCreatedIpSecTransform();         verifyCreateIpSecTransformPair(firstTransformRecordA, firstTransformRecordB);          // Close IKE Session         ikeSession.close();         performCloseIkeBlocking(expectedMsgId++, false /* expectedUseEncap */, deleteIkeResp);         verifyCloseIkeAndChildBlocking(firstTransformRecordA, firstTransformRecordB);     }      ",7.4.5.3/C-1-3,,07040503.670103,DNS 7.4.5.3 C-1-3,Test[None]:[android.net.ipsec.ike.cts.IkeSessionPskTest:testIkeSessionSetupAndChildSessionSetupWithTunnelModeV6()],,DNS,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/net/ipsec/src/android/net/ipsec/ike/cts/IkeSessionPskTest.java,,
,7.4.5.3,C-1-4,,android.media.cts.AudioRecordTest,testMediaMetrics(),,"     public void testMediaMetrics() throws Exception {         if (!hasMicrophone()) {             return;         }          AudioRecord record = null;         try {             final int RECORD_ENCODING = AudioFormat.ENCODING_PCM_16BIT;             final int RECORD_CHANNEL_MASK = AudioFormat.CHANNEL_IN_MONO;             final int RECORD_SAMPLE_RATE = 8000;             final AudioFormat format = new AudioFormat.Builder()                     .setSampleRate(RECORD_SAMPLE_RATE)                     .setChannelMask(RECORD_CHANNEL_MASK)                     .setEncoding(RECORD_ENCODING)                     .build();              // Setup a recorder             record = new AudioRecord.Builder()                 .setAudioSource(MediaRecorder.AudioSource.MIC)                 .setAudioFormat(format)                 .build();              final PersistableBundle metrics = record.getMetrics();              assertNotNull(""null metrics"", metrics);             AudioHelper.assertMetricsKeyEquals(metrics, AudioRecord.MetricsConstants.ENCODING,                     new String(""AUDIO_FORMAT_PCM_16_BIT""));             AudioHelper.assertMetricsKeyEquals(metrics, AudioRecord.MetricsConstants.SOURCE,                     new String(""AUDIO_SOURCE_MIC""));             AudioHelper.assertMetricsKeyEquals(metrics, AudioRecord.MetricsConstants.SAMPLERATE,                     new Integer(RECORD_SAMPLE_RATE));             AudioHelper.assertMetricsKeyEquals(metrics, AudioRecord.MetricsConstants.CHANNELS,                     new Integer(AudioFormat.channelCountFromInChannelMask(RECORD_CHANNEL_MASK)));              // deprecated, value ignored.             AudioHelper.assertMetricsKey(metrics, AudioRecord.MetricsConstants.LATENCY);              // TestApi:             AudioHelper.assertMetricsKeyEquals(metrics, AudioRecord.MetricsConstants.CHANNEL_MASK,                     new Long(RECORD_CHANNEL_MASK));             AudioHelper.assertMetricsKeyEquals(metrics, AudioRecord.MetricsConstants.FRAME_COUNT,                     new Integer(record.getBufferSizeInFrames()));             AudioHelper.assertMetricsKeyEquals(metrics, AudioRecord.MetricsConstants.DURATION_MS,                     new Double(0.));             AudioHelper.assertMetricsKeyEquals(metrics, AudioRecord.MetricsConstants.START_COUNT,                     new Long(0));              // TestApi: no particular value checking.             AudioHelper.assertMetricsKey(metrics, AudioRecord.MetricsConstants.PORT_ID);             AudioHelper.assertMetricsKey(metrics, AudioRecord.MetricsConstants.ATTRIBUTES);         } finally {             if (record != null) {                 record.release();             }         }     }      private void printMicrophoneInfo(MicrophoneInfo microphone) {         Log.i(TAG, ""deviceId:"" + microphone.getDescription());         Log.i(TAG, ""portId:"" + microphone.getId());         Log.i(TAG, ""type:"" + microphone.getType());         Log.i(TAG, ""address:"" + microphone.getAddress());         Log.i(TAG, ""deviceLocation:"" + microphone.getLocation());         Log.i(TAG, ""deviceGroup:"" + microphone.getGroup()             + "" index:"" + microphone.getIndexInTheGroup());         MicrophoneInfo.Coordinate3F position = microphone.getPosition();         Log.i(TAG, ""position:"" + position.x + "","" + position.y + "","" + position.z);         MicrophoneInfo.Coordinate3F orientation = microphone.getOrientation();         Log.i(TAG, ""orientation:"" + orientation.x + "","" + orientation.y + "","" + orientation.z);         Log.i(TAG, ""frequencyResponse:"" + microphone.getFrequencyResponse());         Log.i(TAG, ""channelMapping:"" + microphone.getChannelMapping());         Log.i(TAG, ""sensitivity:"" + microphone.getSensitivity());         Log.i(TAG, ""max spl:"" + microphone.getMaxSpl());         Log.i(TAG, ""min spl:"" + microphone.getMinSpl());         Log.i(TAG, ""directionality:"" + microphone.getDirectionality());         Log.i(TAG, ""******"");     }      @CddTest(requirement=""5.4.1/C-1-4"")     ",7.4.5.3/C-1-4,,07040503.670104,C-1-4 LinkProperties.html DNS 7.4.5.3 android.net.LinkProperties.isPrivateDnsActive android.net.LinkProperties.getPrivateDnsServerName,Test[None]:[android.media.cts.AudioRecordTest:testMediaMetrics()],,C-1-4,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/AudioRecordTest.java,,
,7.4.5.3,C-1-5,,android.os.cts.ParcelFileDescriptorTest,getContext(),,/*  *.  */  package android.os.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.content.Context; import android.os.Handler; import android.os.Looper; import android.os.Parcel; import android.os.ParcelFileDescriptor; import android.os.ParcelFileDescriptor.AutoCloseInputStream; import android.os.Parcelable; import android.os.cts.ParcelFileDescriptorPeer.FutureCloseListener; import android.platform.test.annotations.AppModeFull; import android.system.ErrnoException; import android.system.Os; import android.system.OsConstants; import android.test.MoreAsserts;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.google.common.util.concurrent.AbstractFuture;  import junit.framework.ComparisonFailure;  import org.junit.Test; import org.junit.runner.RunWith;  import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.TimeUnit;  @RunWith(AndroidJUnit4.class) public class ParcelFileDescriptorTest {     private static final long DURATION = 100l;      private Context getContext() {         return InstrumentationRegistry.getContext();     }      ,7.4.5.3/C-1-5,,07040503.670105,java.net.Socket C-1-5 android.net.ConnectivityManager.NetworkCallback ConnectivityManager.getActiveNetwork 7.4.5.3 ConnectivityManager.registerDefaultNetworkCallback connect(),Test[None]:[android.os.cts.ParcelFileDescriptorTest:getContext()],,java.net.Socket,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorTest.java,,
,7.4.8,C-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,getHeight(),CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import android.content.Context; import android.content.pm.PackageManager; import android.graphics.ImageFormat; import android.graphics.Rect; import android.graphics.SurfaceTexture; import android.hardware.Camera; import android.hardware.camera2.CameraCharacteristics; import android.hardware.camera2.CameraCharacteristics.Key; import android.hardware.camera2.CameraDevice; import android.hardware.camera2.CameraManager; import android.hardware.camera2.CameraMetadata; import android.hardware.camera2.CaptureRequest; import android.hardware.camera2.CaptureResult; import android.hardware.camera2.cts.helpers.CameraErrorCollector; import android.hardware.camera2.cts.helpers.StaticMetadata; import android.hardware.camera2.cts.testcases.Camera2AndroidTestCase; import android.hardware.camera2.params.BlackLevelPattern; import android.hardware.camera2.params.ColorSpaceTransform; import android.hardware.camera2.params.RecommendedStreamConfigurationMap; import android.hardware.camera2.params.StreamConfigurationMap; import android.media.CamcorderProfile; import android.media.ImageReader; import android.os.Build; import android.util.ArraySet; import android.util.DisplayMetrics; import android.util.Log; import android.util.Rational; import android.util.Range; import android.util.Size; import android.util.Pair; import android.util.Patterns; import android.view.Display; import android.view.Surface; import android.view.WindowManager;  import com.android.compatibility.common.util.CddTest;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Objects; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Set;  import org.junit.runners.Parameterized; import org.junit.runner.RunWith; import org.junit.Test;  import static android.hardware.camera2.cts.helpers.AssertHelpers.*; import static android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback; import static android.hardware.cts.helpers.CameraUtils.matchParametersToCharacteristics;  import static junit.framework.Assert.*;  import static org.mockito.Mockito.*;  /**  * Extended tests for static camera characteristics.  */ @RunWith(Parameterized.class) public class ExtendedCameraCharacteristicsTest extends Camera2AndroidTestCase {     private static final String TAG = ""ExChrsTest""; // must be short so next line doesn't throw     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);      private static final String PREFIX_ANDROID = ""android"";      /*      * Constants for static RAW metadata.      */     private static final int MIN_ALLOWABLE_WHITELEVEL = 32; // must have sensor bit depth > 5      private List<CameraCharacteristics> mCharacteristics;      private static final Size FULLHD = new Size(1920, 1080);     private static final Size FULLHD_ALT = new Size(1920, 1088);     private static final Size HD = new Size(1280, 720);     private static final Size VGA = new Size(640, 480);     private static final Size QVGA = new Size(320, 240);     private static final Size UHD = new Size(3840, 2160);     private static final Size DC4K = new Size(4096, 2160);      private static final long MIN_BACK_SENSOR_RESOLUTION = 2000000;     private static final long MIN_FRONT_SENSOR_RESOLUTION = VGA.getHeight() * VGA.getWidth();     private static final long LOW_LATENCY_THRESHOLD_MS = 200;     private static final float LATENCY_TOLERANCE_FACTOR = 1.1f; // 10% tolerance     private static final int MAX_NUM_IMAGES = 5;     private static final long PREVIEW_RUN_MS = 500;     private static final long FRAME_DURATION_30FPS_NSEC = (long) 1e9 / 30;      private static final long MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION = 12000000;     private static final long MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION = 5000000;     private static final long MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION = 4000000;      /*      * HW Levels short hand      */     private static final int LEGACY = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY;     private static final int LIMITED = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED;     private static final int FULL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL;     private static final int LEVEL_3 = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3;     private static final int EXTERNAL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL;     private static final int OPT = Integer.MAX_VALUE;  // For keys that are optional on all hardware levels.      /*      * Capabilities short hand      */     private static final int NONE = -1;     private static final int BC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE;     private static final int MANUAL_SENSOR =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR;     private static final int MANUAL_POSTPROC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING;     private static final int RAW =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW;     private static final int YUV_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING;     private static final int OPAQUE_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING;     private static final int CONSTRAINED_HIGH_SPEED =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO;     private static final int MONOCHROME =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME;     private static final int HIGH_SPEED_FPS_LOWER_MIN = 30;     private static final int HIGH_SPEED_FPS_UPPER_MIN = 120;      @Override     public void setUp() throws Exception {         super.setUp();         mCharacteristics = new ArrayList<>();         for (int i = 0; i < mAllCameraIds.length; i++) {             mCharacteristics.add(mAllStaticInfo.get(mAllCameraIds[i]).getCharacteristics());         }     }      @Override     public void tearDown() throws Exception {         super.tearDown();         mCharacteristics = null;     }      /**      * Test that the available stream configurations contain a few required formats and sizes.      */     @CddTest(requirement=""7.5.1/C-1-2"")     ",7.4.8/C-1-2,,07040800.670102,android.hardware.se.omapi.ese android.hardware.se.omapi.uicc FEATURE_SE_OMAPI_UICC FEATURE_SE_OMAPI_ESE FEATURE_SE_OMAPI_SD android.hardware.se.omapi.sd C-1-2 UICC 7.4.8,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:getHeight()],,C-1-2,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.5.4,C-0-12,,android.hardware.camera2.cts.HeifWriterTest,getSimpleName(),CtsCameraTestCases,"/*  *.  */  package android.camera.cts;  import static android.hardware.camera2.cts.CameraTestUtils.SESSION_CONFIGURE_TIMEOUT_MS; import static android.hardware.camera2.cts.CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS; import static android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback; import static android.hardware.camera2.cts.CameraTestUtils.getValueNotNull;  import static androidx.heifwriter.HeifWriter.INPUT_MODE_SURFACE;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue;  import android.graphics.ImageFormat; import android.graphics.SurfaceTexture; import android.hardware.camera2.CameraCharacteristics; import android.hardware.camera2.CameraDevice; import android.hardware.camera2.CaptureRequest; import android.hardware.camera2.CaptureResult; import android.hardware.camera2.cts.helpers.StaticMetadata; import android.hardware.camera2.cts.testcases.Camera2AndroidTestCase; import android.hardware.camera2.params.OutputConfiguration; import android.media.MediaExtractor; import android.media.MediaFormat; import android.media.MediaMetadataRetriever; import android.os.Environment; import android.os.SystemClock; import android.util.Log; import android.util.Size; import android.view.Surface;  import androidx.heifwriter.HeifWriter;  import com.android.compatibility.common.util.MediaUtils; import com.android.ex.camera2.blocking.BlockingSessionCallback;  import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.Arrays; import java.util.List;  import org.junit.runners.Parameterized; import org.junit.runner.RunWith; import org.junit.Test;  @RunWith(Parameterized.class) public class HeifWriterTest extends Camera2AndroidTestCase {     private static final String TAG = HeifWriterTest.class.getSimpleName();     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);     private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);      private String mFilePath;     private static final String OUTPUT_FILENAME = ""output.heic"";      @Override     public void setUp() throws Exception {         super.setUp();          File filesDir = mContext.getPackageManager().isInstantApp()                 ? mContext.getFilesDir()                 : mContext.getExternalFilesDir(null);          mFilePath = filesDir.getPath();     }      @Override     public void tearDown() throws Exception {         super.tearDown();     }      ",7.5.4/C-0-12,,07050400.670012,7.5.4 android.hardware.camera C-0-12 android.hardware.Camera,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.HeifWriterTest:getSimpleName()],,android.hardware.camera,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,,
,9.1,C-2-1,,android.graphics.cts.VulkanFeaturesTest,getSimpleName(),,"/*  *.  */  package android.graphics.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  import android.content.pm.FeatureInfo; import android.content.pm.PackageManager; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.PropertyUtil;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.UnsupportedEncodingException;  /**  * Test that the Vulkan loader is present, supports the required extensions, and that system  * features accurately indicate the capabilities of the Vulkan driver if one exists.  */ @SmallTest @RunWith(AndroidJUnit4.class) public class VulkanFeaturesTest {      static {         System.loadLibrary(""ctsgraphics_jni"");     }      private static final String TAG = VulkanFeaturesTest.class.getSimpleName();     private static final boolean DEBUG = false;      // Require patch version 3 for Vulkan 1.0: It was the first publicly available version,     // and there was an important bugfix relative to 1.0.2.     private static final int VULKAN_1_0 = 0x00400003; // 1.0.3     private static final int VULKAN_1_1 = 0x00401000; // 1.1.0      private static final String VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME =             ""VK_ANDROID_external_memory_android_hardware_buffer"";     private static final int VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 2;     private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 0x8;     private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 0x10;     private static final int VK_PHYSICAL_DEVICE_TYPE_CPU = 4;      private static final int API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ = 28;      private PackageManager mPm;     private FeatureInfo mVulkanHardwareLevel = null;     private FeatureInfo mVulkanHardwareVersion = null;     private FeatureInfo mVulkanHardwareCompute = null;     private JSONObject mVulkanDevices[];     private JSONObject mBestDevice = null;      @Before     public void setup() throws Throwable {         mPm = InstrumentationRegistry.getTargetContext().getPackageManager();         FeatureInfo features[] = mPm.getSystemAvailableFeatures();         if (features != null) {             for (FeatureInfo feature : features) {                 if (PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL.equals(feature.name)) {                     mVulkanHardwareLevel = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_VERSION.equals(feature.name)) {                     mVulkanHardwareVersion = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""=0x"" + Integer.toHexString(feature.version));                     }                 } else if (PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE.equals(feature.name)) {                     mVulkanHardwareCompute = feature;                     if (DEBUG) {                         Log.d(TAG, feature.name + ""="" + feature.version);                     }                 }             }         }          mVulkanDevices = getVulkanDevices();         mBestDevice = getBestDevice();     }     @CddTest(requirement = ""7.1.4.2/C-1-1,C-2-1"")     ",9.1/C-2-1,,09010000.670201,9.1 ACTION_MANAGE_OVERLAY_PERMISSION Settings.html C-2-1,Test[None]:[android.graphics.cts.VulkanFeaturesTest:getSimpleName()],,C-2-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,9.5,C-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,getHeight(),CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import android.content.Context; import android.content.pm.PackageManager; import android.graphics.ImageFormat; import android.graphics.Rect; import android.graphics.SurfaceTexture; import android.hardware.Camera; import android.hardware.camera2.CameraCharacteristics; import android.hardware.camera2.CameraCharacteristics.Key; import android.hardware.camera2.CameraDevice; import android.hardware.camera2.CameraManager; import android.hardware.camera2.CameraMetadata; import android.hardware.camera2.CaptureRequest; import android.hardware.camera2.CaptureResult; import android.hardware.camera2.cts.helpers.CameraErrorCollector; import android.hardware.camera2.cts.helpers.StaticMetadata; import android.hardware.camera2.cts.testcases.Camera2AndroidTestCase; import android.hardware.camera2.params.BlackLevelPattern; import android.hardware.camera2.params.ColorSpaceTransform; import android.hardware.camera2.params.RecommendedStreamConfigurationMap; import android.hardware.camera2.params.StreamConfigurationMap; import android.media.CamcorderProfile; import android.media.ImageReader; import android.os.Build; import android.util.ArraySet; import android.util.DisplayMetrics; import android.util.Log; import android.util.Rational; import android.util.Range; import android.util.Size; import android.util.Pair; import android.util.Patterns; import android.view.Display; import android.view.Surface; import android.view.WindowManager;  import com.android.compatibility.common.util.CddTest;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Objects; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Set;  import org.junit.runners.Parameterized; import org.junit.runner.RunWith; import org.junit.Test;  import static android.hardware.camera2.cts.helpers.AssertHelpers.*; import static android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback; import static android.hardware.cts.helpers.CameraUtils.matchParametersToCharacteristics;  import static junit.framework.Assert.*;  import static org.mockito.Mockito.*;  /**  * Extended tests for static camera characteristics.  */ @RunWith(Parameterized.class) public class ExtendedCameraCharacteristicsTest extends Camera2AndroidTestCase {     private static final String TAG = ""ExChrsTest""; // must be short so next line doesn't throw     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);      private static final String PREFIX_ANDROID = ""android"";      /*      * Constants for static RAW metadata.      */     private static final int MIN_ALLOWABLE_WHITELEVEL = 32; // must have sensor bit depth > 5      private List<CameraCharacteristics> mCharacteristics;      private static final Size FULLHD = new Size(1920, 1080);     private static final Size FULLHD_ALT = new Size(1920, 1088);     private static final Size HD = new Size(1280, 720);     private static final Size VGA = new Size(640, 480);     private static final Size QVGA = new Size(320, 240);     private static final Size UHD = new Size(3840, 2160);     private static final Size DC4K = new Size(4096, 2160);      private static final long MIN_BACK_SENSOR_RESOLUTION = 2000000;     private static final long MIN_FRONT_SENSOR_RESOLUTION = VGA.getHeight() * VGA.getWidth();     private static final long LOW_LATENCY_THRESHOLD_MS = 200;     private static final float LATENCY_TOLERANCE_FACTOR = 1.1f; // 10% tolerance     private static final int MAX_NUM_IMAGES = 5;     private static final long PREVIEW_RUN_MS = 500;     private static final long FRAME_DURATION_30FPS_NSEC = (long) 1e9 / 30;      private static final long MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION = 12000000;     private static final long MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION = 5000000;     private static final long MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION = 4000000;      /*      * HW Levels short hand      */     private static final int LEGACY = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY;     private static final int LIMITED = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED;     private static final int FULL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL;     private static final int LEVEL_3 = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3;     private static final int EXTERNAL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL;     private static final int OPT = Integer.MAX_VALUE;  // For keys that are optional on all hardware levels.      /*      * Capabilities short hand      */     private static final int NONE = -1;     private static final int BC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE;     private static final int MANUAL_SENSOR =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR;     private static final int MANUAL_POSTPROC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING;     private static final int RAW =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW;     private static final int YUV_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING;     private static final int OPAQUE_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING;     private static final int CONSTRAINED_HIGH_SPEED =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO;     private static final int MONOCHROME =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME;     private static final int HIGH_SPEED_FPS_LOWER_MIN = 30;     private static final int HIGH_SPEED_FPS_UPPER_MIN = 120;      @Override     public void setUp() throws Exception {         super.setUp();         mCharacteristics = new ArrayList<>();         for (int i = 0; i < mAllCameraIds.length; i++) {             mCharacteristics.add(mAllStaticInfo.get(mAllCameraIds[i]).getCharacteristics());         }     }      @Override     public void tearDown() throws Exception {         super.tearDown();         mCharacteristics = null;     }      /**      * Test that the available stream configurations contain a few required formats and sizes.      */     @CddTest(requirement=""7.5.1/C-1-2"")     ",9.5/C-1-2,,09050000.670102,9.5 C-1-2 permissions.html,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:getHeight()],,C-1-2,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.8.9,C-0-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testMonochromeCharacteristics(),CtsCameraTestCases,"     public void testMonochromeCharacteristics() {         for (int i = 0; i < mAllCameraIds.length; i++) {             Log.i(TAG, ""testMonochromeCharacteristics: Testing camera ID "" + mAllCameraIds[i]);              CameraCharacteristics c = mCharacteristics.get(i);             int[] capabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);             assertNotNull(""android.request.availableCapabilities must never be null"",                     capabilities);             boolean supportMonochrome = arrayContains(capabilities, MONOCHROME);              if (!supportMonochrome) {                 continue;             }              List<Key<?>> allKeys = c.getKeys();             List<CaptureRequest.Key<?>> requestKeys = c.getAvailableCaptureRequestKeys();             List<CaptureResult.Key<?>> resultKeys = c.getAvailableCaptureResultKeys();              assertTrue(""Monochrome camera must have BACKWARD_COMPATIBLE capability"",                     arrayContains(capabilities, BC));             int colorFilterArrangement = c.get(                     CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT);             assertTrue(""Monochrome camera must have either MONO or NIR color filter pattern"",                     colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO                     || colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR);              assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX1));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT1));             assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX2));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT2));              assertFalse(                     ""Monochrome capture result must not contain SENSOR_NEUTRAL_COLOR_POINT key"",                     resultKeys.contains(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT));             assertFalse(""Monochrome capture result must not contain SENSOR_GREEN_SPLIT key"",                     resultKeys.contains(CaptureResult.SENSOR_GREEN_SPLIT));              // Check that color correction tags are not available for monochrome cameras             assertTrue(""Monochrome camera must not have MANUAL_POST_PROCESSING capability"",                     !arrayContains(capabilities, MANUAL_POSTPROC));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_GAINS));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_GAINS));              // Check that awbSupportedModes only contains AUTO             int[] awbAvailableModes = c.get(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES);             assertTrue(""availableAwbModes must not be null"", awbAvailableModes != null);             assertTrue(""availableAwbModes must contain only AUTO"", awbAvailableModes.length == 1 &&                     awbAvailableModes[0] == CaptureRequest.CONTROL_AWB_MODE_AUTO);         }     }      /**      * Check that all devices available through the legacy API are also      * accessible via Camera2.      */     @CddTest(requirement=""7.5.4/C-0-11"")     ",9.8.9/C-0-1,,09080900.670001,C-0-1 9.8.9,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testMonochromeCharacteristics()],,C-0-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.8.10,C-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testLegacyCameraDeviceParity(),CtsCameraTestCases,"     public void testLegacyCameraDeviceParity() {         if (mAdoptShellPerm) {             // There is no current way to determine in camera1 api if a device is a system camera             // Skip test, http://b/141496896             return;         }         if (mOverrideCameraId != null) {             // A single camera is being tested. Skip test.             return;         }         int legacyDeviceCount = Camera.getNumberOfCameras();         assertTrue(""More legacy devices: "" + legacyDeviceCount + "" compared to Camera2 devices: "" +                 mCharacteristics.size(), legacyDeviceCount <= mCharacteristics.size());          ArrayList<CameraCharacteristics> chars = new ArrayList<> (mCharacteristics);         for (int i = 0; i < legacyDeviceCount; i++) {             Camera camera = null;             Camera.Parameters legacyParams = null;             Camera.CameraInfo legacyInfo = new Camera.CameraInfo();             try {                 Camera.getCameraInfo(i, legacyInfo);                 camera = Camera.open(i);                 legacyParams = camera.getParameters();                  assertNotNull(""Camera parameters for device: "" + i + ""  must not be null"",                         legacyParams);             } finally {                 if (camera != null) {                     camera.release();                 }             }              // Camera Ids between legacy devices and Camera2 device could be             // different try to match devices by using other common traits.             CameraCharacteristics found = null;             for (CameraCharacteristics ch : chars) {                 if (matchParametersToCharacteristics(legacyParams, legacyInfo, ch)) {                     found = ch;                     break;                 }             }             assertNotNull(""No matching Camera2 device for legacy device id: "" + i, found);              chars.remove(found);         }     }      /**      * Check camera orientation against device orientation      */     @CddTest(requirement=""7.5.5/C-1-1"")     ",9.8.10/C-1-1,,09081000.670101,9.8.10 BUGREPORT_MODE_TELEPHONY C-1-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testLegacyCameraDeviceParity()],,C-1-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.8.10,C-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,getHeight(),CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import android.content.Context; import android.content.pm.PackageManager; import android.graphics.ImageFormat; import android.graphics.Rect; import android.graphics.SurfaceTexture; import android.hardware.Camera; import android.hardware.camera2.CameraCharacteristics; import android.hardware.camera2.CameraCharacteristics.Key; import android.hardware.camera2.CameraDevice; import android.hardware.camera2.CameraManager; import android.hardware.camera2.CameraMetadata; import android.hardware.camera2.CaptureRequest; import android.hardware.camera2.CaptureResult; import android.hardware.camera2.cts.helpers.CameraErrorCollector; import android.hardware.camera2.cts.helpers.StaticMetadata; import android.hardware.camera2.cts.testcases.Camera2AndroidTestCase; import android.hardware.camera2.params.BlackLevelPattern; import android.hardware.camera2.params.ColorSpaceTransform; import android.hardware.camera2.params.RecommendedStreamConfigurationMap; import android.hardware.camera2.params.StreamConfigurationMap; import android.media.CamcorderProfile; import android.media.ImageReader; import android.os.Build; import android.util.ArraySet; import android.util.DisplayMetrics; import android.util.Log; import android.util.Rational; import android.util.Range; import android.util.Size; import android.util.Pair; import android.util.Patterns; import android.view.Display; import android.view.Surface; import android.view.WindowManager;  import com.android.compatibility.common.util.CddTest;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Objects; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Set;  import org.junit.runners.Parameterized; import org.junit.runner.RunWith; import org.junit.Test;  import static android.hardware.camera2.cts.helpers.AssertHelpers.*; import static android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback; import static android.hardware.cts.helpers.CameraUtils.matchParametersToCharacteristics;  import static junit.framework.Assert.*;  import static org.mockito.Mockito.*;  /**  * Extended tests for static camera characteristics.  */ @RunWith(Parameterized.class) public class ExtendedCameraCharacteristicsTest extends Camera2AndroidTestCase {     private static final String TAG = ""ExChrsTest""; // must be short so next line doesn't throw     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);      private static final String PREFIX_ANDROID = ""android"";      /*      * Constants for static RAW metadata.      */     private static final int MIN_ALLOWABLE_WHITELEVEL = 32; // must have sensor bit depth > 5      private List<CameraCharacteristics> mCharacteristics;      private static final Size FULLHD = new Size(1920, 1080);     private static final Size FULLHD_ALT = new Size(1920, 1088);     private static final Size HD = new Size(1280, 720);     private static final Size VGA = new Size(640, 480);     private static final Size QVGA = new Size(320, 240);     private static final Size UHD = new Size(3840, 2160);     private static final Size DC4K = new Size(4096, 2160);      private static final long MIN_BACK_SENSOR_RESOLUTION = 2000000;     private static final long MIN_FRONT_SENSOR_RESOLUTION = VGA.getHeight() * VGA.getWidth();     private static final long LOW_LATENCY_THRESHOLD_MS = 200;     private static final float LATENCY_TOLERANCE_FACTOR = 1.1f; // 10% tolerance     private static final int MAX_NUM_IMAGES = 5;     private static final long PREVIEW_RUN_MS = 500;     private static final long FRAME_DURATION_30FPS_NSEC = (long) 1e9 / 30;      private static final long MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION = 12000000;     private static final long MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION = 5000000;     private static final long MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION = 4000000;      /*      * HW Levels short hand      */     private static final int LEGACY = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY;     private static final int LIMITED = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED;     private static final int FULL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL;     private static final int LEVEL_3 = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3;     private static final int EXTERNAL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL;     private static final int OPT = Integer.MAX_VALUE;  // For keys that are optional on all hardware levels.      /*      * Capabilities short hand      */     private static final int NONE = -1;     private static final int BC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE;     private static final int MANUAL_SENSOR =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR;     private static final int MANUAL_POSTPROC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING;     private static final int RAW =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW;     private static final int YUV_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING;     private static final int OPAQUE_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING;     private static final int CONSTRAINED_HIGH_SPEED =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO;     private static final int MONOCHROME =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME;     private static final int HIGH_SPEED_FPS_LOWER_MIN = 30;     private static final int HIGH_SPEED_FPS_UPPER_MIN = 120;      @Override     public void setUp() throws Exception {         super.setUp();         mCharacteristics = new ArrayList<>();         for (int i = 0; i < mAllCameraIds.length; i++) {             mCharacteristics.add(mAllStaticInfo.get(mAllCameraIds[i]).getCharacteristics());         }     }      @Override     public void tearDown() throws Exception {         super.tearDown();         mCharacteristics = null;     }      /**      * Test that the available stream configurations contain a few required formats and sizes.      */     @CddTest(requirement=""7.5.1/C-1-2"")     ",9.8.10/C-1-2,,09081000.670102,9.8.10 C-1-2,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:getHeight()],,C-1-2,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.8.10,C-1-4,,android.net.cts.NetworkStatsBinderTest,testAccessUidStatsFromBinder(),,"     public void testAccessUidStatsFromBinder() throws Exception {         final int myUid = Process.myUid();         final List<Integer> testUidList = new ArrayList<>();          // Prepare uid list for testing.         testUidList.add(INVALID_UID);         testUidList.add(Process.ROOT_UID);         testUidList.add(Process.SYSTEM_UID);         testUidList.add(myUid);         testUidList.add(Process.LAST_APPLICATION_UID);         testUidList.add(Process.LAST_APPLICATION_UID + 1);         // If available, pick another existing uid for testing that is not already contained         // in the list above.         final int notMyUid = getFirstAppUidThat(uid -> uid >= 0 && !testUidList.contains(uid));         if (notMyUid != INVALID_UID) testUidList.add(notMyUid);          for (final int uid : testUidList) {             for (int i = 0; i < mUidStatsQueryOpArray.size(); i++) {                 final int type = mUidStatsQueryOpArray.keyAt(i);                 try {                     final long uidStatsFromBinder = getUidStatsFromBinder(uid, type);                     final long uidTrafficStats = mUidStatsQueryOpArray.get(type).apply(uid);                      // Verify that UNSUPPORTED is returned if the uid is not current app uid.                     if (uid != myUid) {                         assertEquals(uidStatsFromBinder, TrafficStats.UNSUPPORTED);                     }                     // Verify that returned result is the same with the result get from                     // TrafficStats.                     // TODO: If the test is flaky then it should instead assert that the values                     //  are approximately similar.                     assertEquals(""uidStats is not matched for query type "" + type                                     + "", uid="" + uid + "", myUid="" + myUid, uidTrafficStats,                             uidStatsFromBinder);                 } catch (IllegalAccessException e) {                     /* Java language access prevents exploitation. */                     return;                 } catch (InvocationTargetException e) {                     /* Underlying method has been changed. */                     return;                 } catch (ClassNotFoundException e) {                     /* not vulnerable if hidden API no longer available */                     return;                 } catch (NoSuchMethodException e) {                     /* not vulnerable if hidden API no longer available */                     return;                 } catch (RemoteException e) {                     return;                 }             }         }     } } ",9.8.10/C-1-4,,09081000.670104,UID 9.8.10 C-1-4,Test[None]:[android.net.cts.NetworkStatsBinderTest:testAccessUidStatsFromBinder()],,UID,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/NetworkStatsBinderTest.java,,
,9.8.11,C-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testLegacyCameraDeviceParity(),CtsCameraTestCases,"     public void testLegacyCameraDeviceParity() {         if (mAdoptShellPerm) {             // There is no current way to determine in camera1 api if a device is a system camera             // Skip test, http://b/141496896             return;         }         if (mOverrideCameraId != null) {             // A single camera is being tested. Skip test.             return;         }         int legacyDeviceCount = Camera.getNumberOfCameras();         assertTrue(""More legacy devices: "" + legacyDeviceCount + "" compared to Camera2 devices: "" +                 mCharacteristics.size(), legacyDeviceCount <= mCharacteristics.size());          ArrayList<CameraCharacteristics> chars = new ArrayList<> (mCharacteristics);         for (int i = 0; i < legacyDeviceCount; i++) {             Camera camera = null;             Camera.Parameters legacyParams = null;             Camera.CameraInfo legacyInfo = new Camera.CameraInfo();             try {                 Camera.getCameraInfo(i, legacyInfo);                 camera = Camera.open(i);                 legacyParams = camera.getParameters();                  assertNotNull(""Camera parameters for device: "" + i + ""  must not be null"",                         legacyParams);             } finally {                 if (camera != null) {                     camera.release();                 }             }              // Camera Ids between legacy devices and Camera2 device could be             // different try to match devices by using other common traits.             CameraCharacteristics found = null;             for (CameraCharacteristics ch : chars) {                 if (matchParametersToCharacteristics(legacyParams, legacyInfo, ch)) {                     found = ch;                     break;                 }             }             assertNotNull(""No matching Camera2 device for legacy device id: "" + i, found);              chars.remove(found);         }     }      /**      * Check camera orientation against device orientation      */     @CddTest(requirement=""7.5.5/C-1-1"")     ",9.8.11/C-1-1,,09081100.670101,allowSameSignatureAccess() 9.8.11 BlobStoreManager.session allowPublicAccess() allowPackageAccess() C-1-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testLegacyCameraDeviceParity()],,C-1-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.8.11,C-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,getHeight(),CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import android.content.Context; import android.content.pm.PackageManager; import android.graphics.ImageFormat; import android.graphics.Rect; import android.graphics.SurfaceTexture; import android.hardware.Camera; import android.hardware.camera2.CameraCharacteristics; import android.hardware.camera2.CameraCharacteristics.Key; import android.hardware.camera2.CameraDevice; import android.hardware.camera2.CameraManager; import android.hardware.camera2.CameraMetadata; import android.hardware.camera2.CaptureRequest; import android.hardware.camera2.CaptureResult; import android.hardware.camera2.cts.helpers.CameraErrorCollector; import android.hardware.camera2.cts.helpers.StaticMetadata; import android.hardware.camera2.cts.testcases.Camera2AndroidTestCase; import android.hardware.camera2.params.BlackLevelPattern; import android.hardware.camera2.params.ColorSpaceTransform; import android.hardware.camera2.params.RecommendedStreamConfigurationMap; import android.hardware.camera2.params.StreamConfigurationMap; import android.media.CamcorderProfile; import android.media.ImageReader; import android.os.Build; import android.util.ArraySet; import android.util.DisplayMetrics; import android.util.Log; import android.util.Rational; import android.util.Range; import android.util.Size; import android.util.Pair; import android.util.Patterns; import android.view.Display; import android.view.Surface; import android.view.WindowManager;  import com.android.compatibility.common.util.CddTest;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Objects; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Set;  import org.junit.runners.Parameterized; import org.junit.runner.RunWith; import org.junit.Test;  import static android.hardware.camera2.cts.helpers.AssertHelpers.*; import static android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback; import static android.hardware.cts.helpers.CameraUtils.matchParametersToCharacteristics;  import static junit.framework.Assert.*;  import static org.mockito.Mockito.*;  /**  * Extended tests for static camera characteristics.  */ @RunWith(Parameterized.class) public class ExtendedCameraCharacteristicsTest extends Camera2AndroidTestCase {     private static final String TAG = ""ExChrsTest""; // must be short so next line doesn't throw     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);      private static final String PREFIX_ANDROID = ""android"";      /*      * Constants for static RAW metadata.      */     private static final int MIN_ALLOWABLE_WHITELEVEL = 32; // must have sensor bit depth > 5      private List<CameraCharacteristics> mCharacteristics;      private static final Size FULLHD = new Size(1920, 1080);     private static final Size FULLHD_ALT = new Size(1920, 1088);     private static final Size HD = new Size(1280, 720);     private static final Size VGA = new Size(640, 480);     private static final Size QVGA = new Size(320, 240);     private static final Size UHD = new Size(3840, 2160);     private static final Size DC4K = new Size(4096, 2160);      private static final long MIN_BACK_SENSOR_RESOLUTION = 2000000;     private static final long MIN_FRONT_SENSOR_RESOLUTION = VGA.getHeight() * VGA.getWidth();     private static final long LOW_LATENCY_THRESHOLD_MS = 200;     private static final float LATENCY_TOLERANCE_FACTOR = 1.1f; // 10% tolerance     private static final int MAX_NUM_IMAGES = 5;     private static final long PREVIEW_RUN_MS = 500;     private static final long FRAME_DURATION_30FPS_NSEC = (long) 1e9 / 30;      private static final long MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION = 12000000;     private static final long MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION = 5000000;     private static final long MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION = 4000000;      /*      * HW Levels short hand      */     private static final int LEGACY = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY;     private static final int LIMITED = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED;     private static final int FULL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL;     private static final int LEVEL_3 = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3;     private static final int EXTERNAL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL;     private static final int OPT = Integer.MAX_VALUE;  // For keys that are optional on all hardware levels.      /*      * Capabilities short hand      */     private static final int NONE = -1;     private static final int BC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE;     private static final int MANUAL_SENSOR =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR;     private static final int MANUAL_POSTPROC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING;     private static final int RAW =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW;     private static final int YUV_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING;     private static final int OPAQUE_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING;     private static final int CONSTRAINED_HIGH_SPEED =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO;     private static final int MONOCHROME =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME;     private static final int HIGH_SPEED_FPS_LOWER_MIN = 30;     private static final int HIGH_SPEED_FPS_UPPER_MIN = 120;      @Override     public void setUp() throws Exception {         super.setUp();         mCharacteristics = new ArrayList<>();         for (int i = 0; i < mAllCameraIds.length; i++) {             mCharacteristics.add(mAllStaticInfo.get(mAllCameraIds[i]).getCharacteristics());         }     }      @Override     public void tearDown() throws Exception {         super.tearDown();         mCharacteristics = null;     }      /**      * Test that the available stream configurations contain a few required formats and sizes.      */     @CddTest(requirement=""7.5.1/C-1-2"")     ",9.8.11/C-1-2,,09081100.670102,C-1-2 9.8.11,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:getHeight()],,C-1-2,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.9.4,C-0-1,,android.hardware.camera2.cts.HeifWriterTest,testHeif(),CtsCameraTestCases,"     public void testHeif() throws Exception {         final int NUM_SINGLE_CAPTURE_TESTED = 3;         final int NUM_HEIC_CAPTURE_TESTED = 2;         final int SESSION_WARMUP_MS = 1000;         final int HEIF_STOP_TIMEOUT = 3000 * NUM_SINGLE_CAPTURE_TESTED;          if (!canEncodeHeic()) {             MediaUtils.skipTest(""heic encoding is not supported on this device"");             return;         }          boolean sessionFailure = false;         Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,                 BlockingSessionCallback.SESSION_CONFIGURE_FAILED};         for (String id : mCameraIdsUnderTest) {             try {                 Log.v(TAG, ""Testing HEIF capture for Camera "" + id);                 openDevice(id);                  Size[] availableSizes = mStaticInfo.getAvailableSizesForFormatChecked(                         ImageFormat.PRIVATE,                         StaticMetadata.StreamDirection.Output);                  // for each resolution, test imageReader:                 for (Size sz : availableSizes) {                     HeifWriter heifWriter = null;                     OutputConfiguration outConfig = null;                     Surface latestSurface = null;                     CaptureRequest.Builder reqStill = null;                     int width = sz.getWidth();                     int height = sz.getHeight();                     for (int cap = 0; cap < NUM_HEIC_CAPTURE_TESTED; cap++) {                         if (VERBOSE) {                             Log.v(TAG, ""Testing size "" + sz.toString() + "" format PRIVATE""                                     + "" for camera "" + mCamera.getId() + "". Iteration:"" + cap);                         }                          try {                             TestConfig.Builder builder = new TestConfig.Builder(/*useGrid*/false);                             builder.setNumImages(NUM_SINGLE_CAPTURE_TESTED);                             builder.setSize(sz);                             String filename = ""Cam"" + id + ""_"" + width + ""x"" + height +                                     ""_"" + cap + "".heic"";                             builder.setOutputPath(                                     new File(mFilePath, filename).getAbsolutePath());                             TestConfig config = builder.build();                              try {                                 heifWriter = new HeifWriter.Builder(                                         config.mOutputPath,                                         width, height, INPUT_MODE_SURFACE)                                     .setGridEnabled(config.mUseGrid)                                     .setMaxImages(config.mMaxNumImages)                                     .setQuality(config.mQuality)                                     .setPrimaryIndex(config.mNumImages - 1)                                     .setHandler(mHandler)                                     .build();                             } catch (IOException e) {                                 // Continue in case the size is not supported                                 sessionFailure = true;                                 Log.i(TAG, ""Skip due to heifWriter creation failure: ""                                         + e.getMessage());                                 continue;                             }                              // First capture. Start capture session                             latestSurface = heifWriter.getInputSurface();                             outConfig = new OutputConfiguration(latestSurface);                             List<OutputConfiguration> configs =                                 new ArrayList<OutputConfiguration>();                             configs.add(outConfig);                              SurfaceTexture preview = new SurfaceTexture(/*random int*/ 1);                             Surface previewSurface = new Surface(preview);                             preview.setDefaultBufferSize(640, 480);                             configs.add(new OutputConfiguration(previewSurface));                              CaptureRequest.Builder reqPreview = mCamera.createCaptureRequest(                                     CameraDevice.TEMPLATE_PREVIEW);                             reqPreview.addTarget(previewSurface);                              reqStill = mCamera.createCaptureRequest(                                     CameraDevice.TEMPLATE_STILL_CAPTURE);                             reqStill.addTarget(previewSurface);                             reqStill.addTarget(latestSurface);                              // Start capture session and preview                             createSessionByConfigs(configs);                             int state = mCameraSessionListener.getStateWaiter().waitForAnyOfStates(                                     Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);                             if (state == BlockingSessionCallback.SESSION_CONFIGURE_FAILED) {                                 // session configuration failure. Bail out due to known issue of                                 // HeifWriter INPUT_SURFACE mode support for camera. b/79699819                                 sessionFailure = true;                                 break;                             }                             startCapture(reqPreview.build(), /*repeating*/true, null, null);                              SystemClock.sleep(SESSION_WARMUP_MS);                              heifWriter.start();                              // Start capture.                             CaptureRequest request = reqStill.build();                             SimpleCaptureCallback listener = new SimpleCaptureCallback();                              int numImages = config.mNumImages;                              for (int i = 0; i < numImages; i++) {                                 startCapture(request, /*repeating*/false, listener, mHandler);                             }                              // Validate capture result.                             CaptureResult result = validateCaptureResult(                                     ImageFormat.PRIVATE, sz, listener, numImages);                              // TODO: convert capture results into EXIF and send to heifwriter                              heifWriter.stop(HEIF_STOP_TIMEOUT);                              verifyResult(config.mOutputPath, width, height,                                     config.mRotation, config.mUseGrid,                                     Math.min(numImages, config.mMaxNumImages));                         } finally {                             if (heifWriter != null) {                                 heifWriter.close();                                 heifWriter = null;                             }                             if (!sessionFailure) {                                 stopCapture(/*fast*/false);                             }                         }                     }                      if (sessionFailure) {                         break;                     }                 }             } finally {                 closeDevice(id);             }         }     }      private static boolean canEncodeHeic() {         return MediaUtils.hasEncoder(MediaFormat.MIMETYPE_VIDEO_HEVC)             || MediaUtils.hasEncoder(MediaFormat.MIMETYPE_IMAGE_ANDROID_HEIC);     }      private static class TestConfig {         final boolean mUseGrid;         final int mMaxNumImages;         final int mNumImages;         final int mWidth;         final int mHeight;         final int mRotation;         final int mQuality;         final String mOutputPath;          TestConfig(boolean useGrid, int maxNumImages, int numImages,                    int width, int height, int rotation, int quality,                    String outputPath) {             mUseGrid = useGrid;             mMaxNumImages = maxNumImages;             mNumImages = numImages;             mWidth = width;             mHeight = height;             mRotation = rotation;             mQuality = quality;             mOutputPath = outputPath;         }          static class Builder {             final boolean mUseGrid;             int mMaxNumImages;             int mNumImages;             int mWidth;             int mHeight;             int mRotation;             final int mQuality;             String mOutputPath;              Builder(boolean useGrids) {                 mUseGrid = useGrids;                 mMaxNumImages = mNumImages = 4;                 mWidth = 1920;                 mHeight = 1080;                 mRotation = 0;                 mQuality = 100;                 mOutputPath = new File(Environment.getExternalStorageDirectory(),                         OUTPUT_FILENAME).getAbsolutePath();             }              Builder setNumImages(int numImages) {                 mMaxNumImages = mNumImages = numImages;                 return this;             }              Builder setRotation(int rotation) {                 mRotation = rotation;                 return this;             }              Builder setSize(Size sz) {                 mWidth = sz.getWidth();                 mHeight = sz.getHeight();                 return this;             }              Builder setOutputPath(String path) {                 mOutputPath = path;                 return this;             }              private void cleanupStaleOutputs() {                 File outputFile = new File(mOutputPath);                 if (outputFile.exists()) {                     outputFile.delete();                 }             }              TestConfig build() {                 cleanupStaleOutputs();                 return new TestConfig(mUseGrid, mMaxNumImages, mNumImages,                         mWidth, mHeight, mRotation, mQuality, mOutputPath);             }         }          @Override         public String toString() {             return ""TestConfig""                     + "": mUseGrid "" + mUseGrid                     + "", mMaxNumImages "" + mMaxNumImages                     + "", mNumImages "" + mNumImages                     + "", mWidth "" + mWidth                     + "", mHeight "" + mHeight                     + "", mRotation "" + mRotation                     + "", mQuality "" + mQuality                     + "", mOutputPath "" + mOutputPath;         }     }      private void verifyResult(             String filename, int width, int height, int rotation, boolean useGrid, int numImages)             throws Exception {         MediaMetadataRetriever retriever = new MediaMetadataRetriever();         retriever.setDataSource(filename);         String hasImage = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_IMAGE);         if (!""yes"".equals(hasImage)) {             throw new Exception(""No images found in file "" + filename);         }         assertEquals(""Wrong image count"", numImages,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_COUNT)));         assertEquals(""Wrong width"", width,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_WIDTH)));         assertEquals(""Wrong height"", height,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_HEIGHT)));         assertEquals(""Wrong rotation"", rotation,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_ROTATION)));         retriever.release();          if (useGrid) {             MediaExtractor extractor = new MediaExtractor();             extractor.setDataSource(filename);             MediaFormat format = extractor.getTrackFormat(0);             int tileWidth = format.getInteger(MediaFormat.KEY_TILE_WIDTH);             int tileHeight = format.getInteger(MediaFormat.KEY_TILE_HEIGHT);             int gridRows = format.getInteger(MediaFormat.KEY_GRID_ROWS);             int gridCols = format.getInteger(MediaFormat.KEY_GRID_COLUMNS);             assertTrue(""Wrong tile width or grid cols"",                     ((width + tileWidth - 1) / tileWidth) == gridCols);             assertTrue(""Wrong tile height or grid rows"",                     ((height + tileHeight - 1) / tileHeight) == gridRows);             extractor.release();         }     }      /**      * Validate capture results.      *      * @param format The format of this capture.      * @param size The capture size.      * @param listener The capture listener to get capture result callbacks.      * @return the last verified CaptureResult      */     private CaptureResult validateCaptureResult(             int format, Size size, SimpleCaptureCallback listener, int numFrameVerified) {         CaptureResult result = null;         for (int i = 0; i < numFrameVerified; i++) {             result = listener.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);             if (mStaticInfo.isCapabilitySupported(                     CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS)) {                 Long exposureTime = getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);                 Integer sensitivity = getValueNotNull(result, CaptureResult.SENSOR_SENSITIVITY);                 mCollector.expectInRange(                         String.format(                                 ""Capture for format %d, size %s exposure time is invalid."",                                 format, size.toString()),                         exposureTime,                         mStaticInfo.getExposureMinimumOrDefault(),                         mStaticInfo.getExposureMaximumOrDefault()                 );                 mCollector.expectInRange(                         String.format(""Capture for format %d, size %s sensitivity is invalid."",                                 format, size.toString()),                         sensitivity,                         mStaticInfo.getSensitivityMinimumOrDefault(),                         mStaticInfo.getSensitivityMaximumOrDefault()                 );             }             // TODO: add more key validations.         }         return result;     } } ",9.9.4/C-0-1,,09090400.670001,PIN C-0-1 9.9.4 OTA RAM,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.HeifWriterTest:testHeif()],,OTA,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,,
,9.11.3,C-0-1,,android.uirendering.cts.testclasses.AlphaBlendTest,hasOverlappingRendering(),,/*  *.  */  package android.uirendering.cts.testclasses;  import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.uirendering.cts.R; import android.uirendering.cts.bitmapverifiers.ColorVerifier; import android.uirendering.cts.testinfrastructure.ActivityTestBase; import android.uirendering.cts.testinfrastructure.ViewInitializer; import android.view.View; import android.view.ViewGroup; import android.widget.FrameLayout;  import androidx.test.filters.MediumTest; import androidx.test.runner.AndroidJUnit4;  import org.junit.Test; import org.junit.runner.RunWith;  @MediumTest @RunWith(AndroidJUnit4.class) public class AlphaBlendTest extends ActivityTestBase {      class ViewWithAlpha extends View {         public ViewWithAlpha(Context context) {             super(context);         }          @Override         protected void onDraw(Canvas canvas) {             canvas.drawColor(Color.RED);             canvas.drawColor(Color.BLUE);         }          @Override         public boolean hasOverlappingRendering() {             return false;         }     }      /*      * The following test verifies that a RED and BLUE paints on a non-overlapping view with a 0.5f      * alpha blends correctly with a BLACK parent (without using an offscreen surface).      */     ,9.11.3/C-0-1,,09110300.670001,android.content.Context C-0-1 getInstance() 9.11.3,Test[None]:[android.uirendering.cts.testclasses.AlphaBlendTest:hasOverlappingRendering()],,android.content.Context,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/uirendering/src/android/uirendering/cts/testclasses/AlphaBlendTest.java,,
,9.11.3,C-0-2,,android.telephony.cts.SmsManagerTest,testSendAndReceiveMessages(),,"(timeout = 10 * 60 * 1000)     public void testSendAndReceiveMessages() throws Exception {         assertFalse(""[RERUN] SIM card does not provide phone number. Use a suitable SIM Card."",                 TextUtils.isEmpty(mDestAddr));          String mccmnc = mTelephonyManager.getSimOperator();         setupBroadcastReceivers();          // send/receive single text sms with and without messageId         sendAndReceiveSms(/* addMessageId= */ true);         sendAndReceiveSms(/* addMessageId= */ false);          // due to permission restrictions, currently there is no way to make this test app the         // default SMS app          if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA) {             // TODO: temp workaround, OCTET encoding for EMS not properly supported             return;         }          // send/receive data sms         sendDataSms(mccmnc);          // send/receive multi part text sms with and without messageId         sendAndReceiveMultipartSms(mccmnc, /* addMessageId= */ true);         sendAndReceiveMultipartSms(mccmnc, /* addMessageId= */ false);     }      ",9.11.3/C-0-2,,09110300.670002,android.security.identity 9.11.3 C-0-2 DMA,Test[None]:[android.telephony.cts.SmsManagerTest:testSendAndReceiveMessages()],,DMA,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java,,
,9.11.3,C-0-3,,android.security.identity.cts.HkdfTest,Random(),,"/*  *.  */  package android.security.identity.cts;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail;  import org.junit.Test; import org.junit.runner.RunWith; import org.junit.runners.JUnit4;  import java.security.GeneralSecurityException; import java.util.Random;  /*  * This is based on https://github.com/google/tink/blob/master/java/src/test/java/com/google  * /crypto/tink/subtle/HkdfTest.java  * which is also Copyright (c) Google and licensed under the Apache 2 license.  */ @RunWith(JUnit4.class) public class HkdfTest {      static Random sRandom = new Random();      /** Encodes a byte array to hex. */     static String hexEncode(final byte[] bytes) {         String chars = ""0123456789abcdef"";         StringBuilder result = new StringBuilder(2 * bytes.length);         for (byte b : bytes) {             // convert to unsigned             int val = b & 0xff;             result.append(chars.charAt(val / 16));             result.append(chars.charAt(val % 16));         }         return result.toString();     }      /** Decodes a hex string to a byte array. */     static byte[] hexDecode(String hex) {         if (hex.length() % 2 != 0) {             throw new IllegalArgumentException(""Expected a string of even length"");         }         int size = hex.length() / 2;         byte[] result = new byte[size];         for (int i = 0; i < size; i++) {             int hi = Character.digit(hex.charAt(2 * i), 16);             int lo = Character.digit(hex.charAt(2 * i + 1), 16);             if ((hi == -1) || (lo == -1)) {                 throw new IllegalArgumentException(""input is not hexadecimal"");             }             result[i] = (byte) (16 * hi + lo);         }         return result;     }      static byte[] randBytes(int numBytes) {         byte[] bytes = new byte[numBytes];         sRandom.nextBytes(bytes);         return bytes;     }      ",9.11.3/C-0-3,,09110300.670003,android.security.identity 9.11.3 C-0-3 createEphemeralKeyPair(),Test[None]:[android.security.identity.cts.HkdfTest:Random()],,android.security.identity,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/HkdfTest.java,,
,9.11.3,C-0-4,,android.net.cts.IpSecBaseTest,getSimpleName(),,"/*  *.  */  package android.net.cts;  import static org.junit.Assert.assertArrayEquals;  import android.content.Context; import android.net.ConnectivityManager; import android.net.IpSecAlgorithm; import android.net.IpSecManager; import android.net.IpSecTransform; import android.platform.test.annotations.AppModeFull; import android.system.Os; import android.system.OsConstants; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import java.io.FileDescriptor; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.Inet6Address; import java.net.InetAddress; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; import java.net.SocketException; import java.util.Arrays; import java.util.concurrent.atomic.AtomicInteger;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  @RunWith(AndroidJUnit4.class) public class IpSecBaseTest {      private static final String TAG = IpSecBaseTest.class.getSimpleName();      protected static final String IPV4_LOOPBACK = ""127.0.0.1"";     protected static final String IPV6_LOOPBACK = ""::1"";     protected static final String[] LOOPBACK_ADDRS = new String[] {IPV4_LOOPBACK, IPV6_LOOPBACK};     protected static final int[] DIRECTIONS =             new int[] {IpSecManager.DIRECTION_IN, IpSecManager.DIRECTION_OUT};      protected static final byte[] TEST_DATA = ""Best test data ever!"".getBytes();     protected static final int DATA_BUFFER_LEN = 4096;     protected static final int SOCK_TIMEOUT = 500;      private static final byte[] KEY_DATA = {         0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,         0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,         0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,         0x20, 0x21, 0x22, 0x23     };      protected static final byte[] AUTH_KEY = getKey(256);     protected static final byte[] CRYPT_KEY = getKey(256);      protected ConnectivityManager mCM;     protected IpSecManager mISM;      @Before     public void setUp() throws Exception {         mISM =                 (IpSecManager)                         InstrumentationRegistry.getContext()                                 .getSystemService(Context.IPSEC_SERVICE);         mCM =                 (ConnectivityManager)                         InstrumentationRegistry.getContext()                                 .getSystemService(Context.CONNECTIVITY_SERVICE);     }      protected static byte[] getKey(int bitLength) {         return Arrays.copyOf(KEY_DATA, bitLength / 8);     }      protected static int getDomain(InetAddress address) {         int domain;         if (address instanceof Inet6Address) {             domain = OsConstants.AF_INET6;         } else {             domain = OsConstants.AF_INET;         }         return domain;     }      protected static int getPort(FileDescriptor sock) throws Exception {         return ((InetSocketAddress) Os.getsockname(sock)).getPort();     }      public static interface GenericSocket extends AutoCloseable {         void send(byte[] data) throws Exception;          byte[] receive() throws Exception;          int getPort() throws Exception;          void close() throws Exception;          void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception;          void removeTransportModeTransforms(IpSecManager ism) throws Exception;     }      public static interface GenericTcpSocket extends GenericSocket {}      public static interface GenericUdpSocket extends GenericSocket {         void sendTo(byte[] data, InetAddress dstAddr, int port) throws Exception;     }      public abstract static class NativeSocket implements GenericSocket {         public FileDescriptor mFd;          public NativeSocket(FileDescriptor fd) {             mFd = fd;         }          @Override         public void send(byte[] data) throws Exception {             Os.write(mFd, data, 0, data.length);         }          @Override         public byte[] receive() throws Exception {             byte[] in = new byte[DATA_BUFFER_LEN];             AtomicInteger bytesRead = new AtomicInteger(-1);              Thread readSockThread = new Thread(() -> {                 long startTime = System.currentTimeMillis();                 while (bytesRead.get() < 0 && System.currentTimeMillis() < startTime + SOCK_TIMEOUT) {                     try {                         bytesRead.set(Os.recvfrom(mFd, in, 0, DATA_BUFFER_LEN, 0, null));                     } catch (Exception e) {                         Log.e(TAG, ""Error encountered reading from socket"", e);                     }                 }             });              readSockThread.start();             readSockThread.join(SOCK_TIMEOUT);              if (bytesRead.get() < 0) {                 throw new IOException(""No data received from socket"");             }              return Arrays.copyOfRange(in, 0, bytesRead.get());         }          @Override         public int getPort() throws Exception {             return IpSecBaseTest.getPort(mFd);         }          @Override         public void close() throws Exception {             Os.close(mFd);         }          @Override         public void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception {             ism.applyTransportModeTransform(mFd, direction, transform);         }          @Override         public void removeTransportModeTransforms(IpSecManager ism) throws Exception {             ism.removeTransportModeTransforms(mFd);         }     }      public static class NativeTcpSocket extends NativeSocket implements GenericTcpSocket {         public NativeTcpSocket(FileDescriptor fd) {             super(fd);         }     }      public static class NativeUdpSocket extends NativeSocket implements GenericUdpSocket {         public NativeUdpSocket(FileDescriptor fd) {             super(fd);         }          @Override         public void sendTo(byte[] data, InetAddress dstAddr, int port) throws Exception {             Os.sendto(mFd, data, 0, data.length, 0, dstAddr, port);         }     }      public static class JavaUdpSocket implements GenericUdpSocket {         public final DatagramSocket mSocket;          public JavaUdpSocket(InetAddress localAddr, int port) {             try {                 mSocket = new DatagramSocket(port, localAddr);                 mSocket.setSoTimeout(SOCK_TIMEOUT);             } catch (SocketException e) {                 // Fail loudly if we can't set up sockets properly. And without the timeout, we                 // could easily end up in an endless wait.                 throw new RuntimeException(e);             }         }          public JavaUdpSocket(InetAddress localAddr) {             try {                 mSocket = new DatagramSocket(0, localAddr);                 mSocket.setSoTimeout(SOCK_TIMEOUT);             } catch (SocketException e) {                 // Fail loudly if we can't set up sockets properly. And without the timeout, we                 // could easily end up in an endless wait.                 throw new RuntimeException(e);             }         }          @Override         public void send(byte[] data) throws Exception {             mSocket.send(new DatagramPacket(data, data.length));         }          @Override         public void sendTo(byte[] data, InetAddress dstAddr, int port) throws Exception {             mSocket.send(new DatagramPacket(data, data.length, dstAddr, port));         }          @Override         public int getPort() throws Exception {             return mSocket.getLocalPort();         }          @Override         public void close() throws Exception {             mSocket.close();         }          @Override         public byte[] receive() throws Exception {             DatagramPacket data = new DatagramPacket(new byte[DATA_BUFFER_LEN], DATA_BUFFER_LEN);             mSocket.receive(data);             return Arrays.copyOfRange(data.getData(), 0, data.getLength());         }          @Override         public void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception {             ism.applyTransportModeTransform(mSocket, direction, transform);         }          @Override         public void removeTransportModeTransforms(IpSecManager ism) throws Exception {             ism.removeTransportModeTransforms(mSocket);         }     }      public static class JavaTcpSocket implements GenericTcpSocket {         public final Socket mSocket;          public JavaTcpSocket(Socket socket) {             mSocket = socket;             try {                 mSocket.setSoTimeout(SOCK_TIMEOUT);             } catch (SocketException e) {                 // Fail loudly if we can't set up sockets properly. And without the timeout, we                 // could easily end up in an endless wait.                 throw new RuntimeException(e);             }         }          @Override         public void send(byte[] data) throws Exception {             mSocket.getOutputStream().write(data);         }          @Override         public byte[] receive() throws Exception {             byte[] in = new byte[DATA_BUFFER_LEN];             int bytesRead = mSocket.getInputStream().read(in);             return Arrays.copyOfRange(in, 0, bytesRead);         }          @Override         public int getPort() throws Exception {             return mSocket.getLocalPort();         }          @Override         public void close() throws Exception {             mSocket.close();         }          @Override         public void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception {             ism.applyTransportModeTransform(mSocket, direction, transform);         }          @Override         public void removeTransportModeTransforms(IpSecManager ism) throws Exception {             ism.removeTransportModeTransforms(mSocket);         }     }      public static class SocketPair<T> {         public final T mLeftSock;         public final T mRightSock;          public SocketPair(T leftSock, T rightSock) {             mLeftSock = leftSock;             mRightSock = rightSock;         }     }      protected static void applyTransformBidirectionally(             IpSecManager ism, IpSecTransform transform, GenericSocket socket) throws Exception {         for (int direction : DIRECTIONS) {             socket.applyTransportModeTransform(ism, direction, transform);         }     }      public static SocketPair<NativeUdpSocket> getNativeUdpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform, boolean connected)             throws Exception {         int domain = getDomain(localAddr);          NativeUdpSocket leftSock = new NativeUdpSocket(             Os.socket(domain, OsConstants.SOCK_DGRAM, OsConstants.IPPROTO_UDP));         NativeUdpSocket rightSock = new NativeUdpSocket(             Os.socket(domain, OsConstants.SOCK_DGRAM, OsConstants.IPPROTO_UDP));          for (NativeUdpSocket sock : new NativeUdpSocket[] {leftSock, rightSock}) {             applyTransformBidirectionally(ism, transform, sock);             Os.bind(sock.mFd, localAddr, 0);         }          if (connected) {             Os.connect(leftSock.mFd, localAddr, rightSock.getPort());             Os.connect(rightSock.mFd, localAddr, leftSock.getPort());         }          return new SocketPair<>(leftSock, rightSock);     }      public static SocketPair<NativeTcpSocket> getNativeTcpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform) throws Exception {         int domain = getDomain(localAddr);          NativeTcpSocket server = new NativeTcpSocket(                 Os.socket(domain, OsConstants.SOCK_STREAM, OsConstants.IPPROTO_TCP));         NativeTcpSocket client = new NativeTcpSocket(                 Os.socket(domain, OsConstants.SOCK_STREAM, OsConstants.IPPROTO_TCP));          Os.bind(server.mFd, localAddr, 0);          applyTransformBidirectionally(ism, transform, server);         applyTransformBidirectionally(ism, transform, client);          Os.listen(server.mFd, 10);         Os.connect(client.mFd, localAddr, server.getPort());         NativeTcpSocket accepted = new NativeTcpSocket(Os.accept(server.mFd, null));          applyTransformBidirectionally(ism, transform, accepted);         server.close();          return new SocketPair<>(client, accepted);     }      public static SocketPair<JavaUdpSocket> getJavaUdpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform, boolean connected)             throws Exception {         JavaUdpSocket leftSock = new JavaUdpSocket(localAddr);         JavaUdpSocket rightSock = new JavaUdpSocket(localAddr);          applyTransformBidirectionally(ism, transform, leftSock);         applyTransformBidirectionally(ism, transform, rightSock);          if (connected) {             leftSock.mSocket.connect(localAddr, rightSock.mSocket.getLocalPort());             rightSock.mSocket.connect(localAddr, leftSock.mSocket.getLocalPort());         }          return new SocketPair<>(leftSock, rightSock);     }      public static SocketPair<JavaTcpSocket> getJavaTcpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform) throws Exception {         JavaTcpSocket clientSock = new JavaTcpSocket(new Socket());         ServerSocket serverSocket = new ServerSocket();         serverSocket.bind(new InetSocketAddress(localAddr, 0));          // While technically the client socket does not need to be bound, the OpenJDK implementation         // of Socket only allocates an FD when bind() or connect() or other similar methods are         // called. So we call bind to force the FD creation, so that we can apply a transform to it         // prior to socket connect.         clientSock.mSocket.bind(new InetSocketAddress(localAddr, 0));          // IpSecService doesn't support serverSockets at the moment; workaround using FD         FileDescriptor serverFd = serverSocket.getImpl().getFD$();          applyTransformBidirectionally(ism, transform, new NativeTcpSocket(serverFd));         applyTransformBidirectionally(ism, transform, clientSock);          clientSock.mSocket.connect(new InetSocketAddress(localAddr, serverSocket.getLocalPort()));         JavaTcpSocket acceptedSock = new JavaTcpSocket(serverSocket.accept());          applyTransformBidirectionally(ism, transform, acceptedSock);         serverSocket.close();          return new SocketPair<>(clientSock, acceptedSock);     }      private void checkSocketPair(GenericSocket left, GenericSocket right) throws Exception {         left.send(TEST_DATA);         assertArrayEquals(TEST_DATA, right.receive());          right.send(TEST_DATA);         assertArrayEquals(TEST_DATA, left.receive());          left.close();         right.close();     }      private void checkUnconnectedUdpSocketPair(             GenericUdpSocket left, GenericUdpSocket right, InetAddress localAddr) throws Exception {         left.sendTo(TEST_DATA, localAddr, right.getPort());         assertArrayEquals(TEST_DATA, right.receive());          right.sendTo(TEST_DATA, localAddr, left.getPort());         assertArrayEquals(TEST_DATA, left.receive());          left.close();         right.close();     }      protected static IpSecTransform buildIpSecTransform(             Context context,             IpSecManager.SecurityParameterIndex spi,             IpSecManager.UdpEncapsulationSocket encapSocket,             InetAddress remoteAddr)             throws Exception {         IpSecTransform.Builder builder =                 new IpSecTransform.Builder(context)                         .setEncryption(new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY))                         .setAuthentication(                                 new IpSecAlgorithm(                                         IpSecAlgorithm.AUTH_HMAC_SHA256,                                         AUTH_KEY,                                         AUTH_KEY.length * 4));          if (encapSocket != null) {             builder.setIpv4Encapsulation(encapSocket, encapSocket.getPort());         }          return builder.buildTransportModeTransform(remoteAddr, spi);     }      private IpSecTransform buildDefaultTransform(InetAddress localAddr) throws Exception {         try (IpSecManager.SecurityParameterIndex spi =                 mISM.allocateSecurityParameterIndex(localAddr)) {             return buildIpSecTransform(InstrumentationRegistry.getContext(), spi, null, localAddr);         }     }      ",9.11.3/C-0-4,,09110300.670004,MAC C-0-4 9.11.3,Test[None]:[android.net.cts.IpSecBaseTest:getSimpleName()],,MAC,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecBaseTest.java,,
,9.16,C-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testLegacyCameraDeviceParity(),CtsCameraTestCases,"     public void testLegacyCameraDeviceParity() {         if (mAdoptShellPerm) {             // There is no current way to determine in camera1 api if a device is a system camera             // Skip test, http://b/141496896             return;         }         if (mOverrideCameraId != null) {             // A single camera is being tested. Skip test.             return;         }         int legacyDeviceCount = Camera.getNumberOfCameras();         assertTrue(""More legacy devices: "" + legacyDeviceCount + "" compared to Camera2 devices: "" +                 mCharacteristics.size(), legacyDeviceCount <= mCharacteristics.size());          ArrayList<CameraCharacteristics> chars = new ArrayList<> (mCharacteristics);         for (int i = 0; i < legacyDeviceCount; i++) {             Camera camera = null;             Camera.Parameters legacyParams = null;             Camera.CameraInfo legacyInfo = new Camera.CameraInfo();             try {                 Camera.getCameraInfo(i, legacyInfo);                 camera = Camera.open(i);                 legacyParams = camera.getParameters();                  assertNotNull(""Camera parameters for device: "" + i + ""  must not be null"",                         legacyParams);             } finally {                 if (camera != null) {                     camera.release();                 }             }              // Camera Ids between legacy devices and Camera2 device could be             // different try to match devices by using other common traits.             CameraCharacteristics found = null;             for (CameraCharacteristics ch : chars) {                 if (matchParametersToCharacteristics(legacyParams, legacyInfo, ch)) {                     found = ch;                     break;                 }             }             assertNotNull(""No matching Camera2 device for legacy device id: "" + i, found);              chars.remove(found);         }     }      /**      * Check camera orientation against device orientation      */     @CddTest(requirement=""7.5.5/C-1-1"")     ",9.16/C-1-1,,09160000.670101,C-1-1 9.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testLegacyCameraDeviceParity()],,C-1-1,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.16,C-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,getHeight(),CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import android.content.Context; import android.content.pm.PackageManager; import android.graphics.ImageFormat; import android.graphics.Rect; import android.graphics.SurfaceTexture; import android.hardware.Camera; import android.hardware.camera2.CameraCharacteristics; import android.hardware.camera2.CameraCharacteristics.Key; import android.hardware.camera2.CameraDevice; import android.hardware.camera2.CameraManager; import android.hardware.camera2.CameraMetadata; import android.hardware.camera2.CaptureRequest; import android.hardware.camera2.CaptureResult; import android.hardware.camera2.cts.helpers.CameraErrorCollector; import android.hardware.camera2.cts.helpers.StaticMetadata; import android.hardware.camera2.cts.testcases.Camera2AndroidTestCase; import android.hardware.camera2.params.BlackLevelPattern; import android.hardware.camera2.params.ColorSpaceTransform; import android.hardware.camera2.params.RecommendedStreamConfigurationMap; import android.hardware.camera2.params.StreamConfigurationMap; import android.media.CamcorderProfile; import android.media.ImageReader; import android.os.Build; import android.util.ArraySet; import android.util.DisplayMetrics; import android.util.Log; import android.util.Rational; import android.util.Range; import android.util.Size; import android.util.Pair; import android.util.Patterns; import android.view.Display; import android.view.Surface; import android.view.WindowManager;  import com.android.compatibility.common.util.CddTest;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Objects; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.Set;  import org.junit.runners.Parameterized; import org.junit.runner.RunWith; import org.junit.Test;  import static android.hardware.camera2.cts.helpers.AssertHelpers.*; import static android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback; import static android.hardware.cts.helpers.CameraUtils.matchParametersToCharacteristics;  import static junit.framework.Assert.*;  import static org.mockito.Mockito.*;  /**  * Extended tests for static camera characteristics.  */ @RunWith(Parameterized.class) public class ExtendedCameraCharacteristicsTest extends Camera2AndroidTestCase {     private static final String TAG = ""ExChrsTest""; // must be short so next line doesn't throw     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);      private static final String PREFIX_ANDROID = ""android"";      /*      * Constants for static RAW metadata.      */     private static final int MIN_ALLOWABLE_WHITELEVEL = 32; // must have sensor bit depth > 5      private List<CameraCharacteristics> mCharacteristics;      private static final Size FULLHD = new Size(1920, 1080);     private static final Size FULLHD_ALT = new Size(1920, 1088);     private static final Size HD = new Size(1280, 720);     private static final Size VGA = new Size(640, 480);     private static final Size QVGA = new Size(320, 240);     private static final Size UHD = new Size(3840, 2160);     private static final Size DC4K = new Size(4096, 2160);      private static final long MIN_BACK_SENSOR_RESOLUTION = 2000000;     private static final long MIN_FRONT_SENSOR_RESOLUTION = VGA.getHeight() * VGA.getWidth();     private static final long LOW_LATENCY_THRESHOLD_MS = 200;     private static final float LATENCY_TOLERANCE_FACTOR = 1.1f; // 10% tolerance     private static final int MAX_NUM_IMAGES = 5;     private static final long PREVIEW_RUN_MS = 500;     private static final long FRAME_DURATION_30FPS_NSEC = (long) 1e9 / 30;      private static final long MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION = 12000000;     private static final long MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION = 5000000;     private static final long MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION = 4000000;      /*      * HW Levels short hand      */     private static final int LEGACY = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY;     private static final int LIMITED = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED;     private static final int FULL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL;     private static final int LEVEL_3 = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3;     private static final int EXTERNAL = CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL;     private static final int OPT = Integer.MAX_VALUE;  // For keys that are optional on all hardware levels.      /*      * Capabilities short hand      */     private static final int NONE = -1;     private static final int BC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE;     private static final int MANUAL_SENSOR =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR;     private static final int MANUAL_POSTPROC =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING;     private static final int RAW =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_RAW;     private static final int YUV_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING;     private static final int OPAQUE_REPROCESS =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING;     private static final int CONSTRAINED_HIGH_SPEED =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO;     private static final int MONOCHROME =             CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME;     private static final int HIGH_SPEED_FPS_LOWER_MIN = 30;     private static final int HIGH_SPEED_FPS_UPPER_MIN = 120;      @Override     public void setUp() throws Exception {         super.setUp();         mCharacteristics = new ArrayList<>();         for (int i = 0; i < mAllCameraIds.length; i++) {             mCharacteristics.add(mAllStaticInfo.get(mAllCameraIds[i]).getCharacteristics());         }     }      @Override     public void tearDown() throws Exception {         super.tearDown();         mCharacteristics = null;     }      /**      * Test that the available stream configurations contain a few required formats and sizes.      */     @CddTest(requirement=""7.5.1/C-1-2"")     ",9.16/C-1-2,,09160000.670102,C-1-2 9.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:getHeight()],,C-1-2,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.16,C-1-4,,android.hardware.camera2.cts.HeifWriterTest,testHeif(),CtsCameraTestCases,"     public void testHeif() throws Exception {         final int NUM_SINGLE_CAPTURE_TESTED = 3;         final int NUM_HEIC_CAPTURE_TESTED = 2;         final int SESSION_WARMUP_MS = 1000;         final int HEIF_STOP_TIMEOUT = 3000 * NUM_SINGLE_CAPTURE_TESTED;          if (!canEncodeHeic()) {             MediaUtils.skipTest(""heic encoding is not supported on this device"");             return;         }          boolean sessionFailure = false;         Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,                 BlockingSessionCallback.SESSION_CONFIGURE_FAILED};         for (String id : mCameraIdsUnderTest) {             try {                 Log.v(TAG, ""Testing HEIF capture for Camera "" + id);                 openDevice(id);                  Size[] availableSizes = mStaticInfo.getAvailableSizesForFormatChecked(                         ImageFormat.PRIVATE,                         StaticMetadata.StreamDirection.Output);                  // for each resolution, test imageReader:                 for (Size sz : availableSizes) {                     HeifWriter heifWriter = null;                     OutputConfiguration outConfig = null;                     Surface latestSurface = null;                     CaptureRequest.Builder reqStill = null;                     int width = sz.getWidth();                     int height = sz.getHeight();                     for (int cap = 0; cap < NUM_HEIC_CAPTURE_TESTED; cap++) {                         if (VERBOSE) {                             Log.v(TAG, ""Testing size "" + sz.toString() + "" format PRIVATE""                                     + "" for camera "" + mCamera.getId() + "". Iteration:"" + cap);                         }                          try {                             TestConfig.Builder builder = new TestConfig.Builder(/*useGrid*/false);                             builder.setNumImages(NUM_SINGLE_CAPTURE_TESTED);                             builder.setSize(sz);                             String filename = ""Cam"" + id + ""_"" + width + ""x"" + height +                                     ""_"" + cap + "".heic"";                             builder.setOutputPath(                                     new File(mFilePath, filename).getAbsolutePath());                             TestConfig config = builder.build();                              try {                                 heifWriter = new HeifWriter.Builder(                                         config.mOutputPath,                                         width, height, INPUT_MODE_SURFACE)                                     .setGridEnabled(config.mUseGrid)                                     .setMaxImages(config.mMaxNumImages)                                     .setQuality(config.mQuality)                                     .setPrimaryIndex(config.mNumImages - 1)                                     .setHandler(mHandler)                                     .build();                             } catch (IOException e) {                                 // Continue in case the size is not supported                                 sessionFailure = true;                                 Log.i(TAG, ""Skip due to heifWriter creation failure: ""                                         + e.getMessage());                                 continue;                             }                              // First capture. Start capture session                             latestSurface = heifWriter.getInputSurface();                             outConfig = new OutputConfiguration(latestSurface);                             List<OutputConfiguration> configs =                                 new ArrayList<OutputConfiguration>();                             configs.add(outConfig);                              SurfaceTexture preview = new SurfaceTexture(/*random int*/ 1);                             Surface previewSurface = new Surface(preview);                             preview.setDefaultBufferSize(640, 480);                             configs.add(new OutputConfiguration(previewSurface));                              CaptureRequest.Builder reqPreview = mCamera.createCaptureRequest(                                     CameraDevice.TEMPLATE_PREVIEW);                             reqPreview.addTarget(previewSurface);                              reqStill = mCamera.createCaptureRequest(                                     CameraDevice.TEMPLATE_STILL_CAPTURE);                             reqStill.addTarget(previewSurface);                             reqStill.addTarget(latestSurface);                              // Start capture session and preview                             createSessionByConfigs(configs);                             int state = mCameraSessionListener.getStateWaiter().waitForAnyOfStates(                                     Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);                             if (state == BlockingSessionCallback.SESSION_CONFIGURE_FAILED) {                                 // session configuration failure. Bail out due to known issue of                                 // HeifWriter INPUT_SURFACE mode support for camera. b/79699819                                 sessionFailure = true;                                 break;                             }                             startCapture(reqPreview.build(), /*repeating*/true, null, null);                              SystemClock.sleep(SESSION_WARMUP_MS);                              heifWriter.start();                              // Start capture.                             CaptureRequest request = reqStill.build();                             SimpleCaptureCallback listener = new SimpleCaptureCallback();                              int numImages = config.mNumImages;                              for (int i = 0; i < numImages; i++) {                                 startCapture(request, /*repeating*/false, listener, mHandler);                             }                              // Validate capture result.                             CaptureResult result = validateCaptureResult(                                     ImageFormat.PRIVATE, sz, listener, numImages);                              // TODO: convert capture results into EXIF and send to heifwriter                              heifWriter.stop(HEIF_STOP_TIMEOUT);                              verifyResult(config.mOutputPath, width, height,                                     config.mRotation, config.mUseGrid,                                     Math.min(numImages, config.mMaxNumImages));                         } finally {                             if (heifWriter != null) {                                 heifWriter.close();                                 heifWriter = null;                             }                             if (!sessionFailure) {                                 stopCapture(/*fast*/false);                             }                         }                     }                      if (sessionFailure) {                         break;                     }                 }             } finally {                 closeDevice(id);             }         }     }      private static boolean canEncodeHeic() {         return MediaUtils.hasEncoder(MediaFormat.MIMETYPE_VIDEO_HEVC)             || MediaUtils.hasEncoder(MediaFormat.MIMETYPE_IMAGE_ANDROID_HEIC);     }      private static class TestConfig {         final boolean mUseGrid;         final int mMaxNumImages;         final int mNumImages;         final int mWidth;         final int mHeight;         final int mRotation;         final int mQuality;         final String mOutputPath;          TestConfig(boolean useGrid, int maxNumImages, int numImages,                    int width, int height, int rotation, int quality,                    String outputPath) {             mUseGrid = useGrid;             mMaxNumImages = maxNumImages;             mNumImages = numImages;             mWidth = width;             mHeight = height;             mRotation = rotation;             mQuality = quality;             mOutputPath = outputPath;         }          static class Builder {             final boolean mUseGrid;             int mMaxNumImages;             int mNumImages;             int mWidth;             int mHeight;             int mRotation;             final int mQuality;             String mOutputPath;              Builder(boolean useGrids) {                 mUseGrid = useGrids;                 mMaxNumImages = mNumImages = 4;                 mWidth = 1920;                 mHeight = 1080;                 mRotation = 0;                 mQuality = 100;                 mOutputPath = new File(Environment.getExternalStorageDirectory(),                         OUTPUT_FILENAME).getAbsolutePath();             }              Builder setNumImages(int numImages) {                 mMaxNumImages = mNumImages = numImages;                 return this;             }              Builder setRotation(int rotation) {                 mRotation = rotation;                 return this;             }              Builder setSize(Size sz) {                 mWidth = sz.getWidth();                 mHeight = sz.getHeight();                 return this;             }              Builder setOutputPath(String path) {                 mOutputPath = path;                 return this;             }              private void cleanupStaleOutputs() {                 File outputFile = new File(mOutputPath);                 if (outputFile.exists()) {                     outputFile.delete();                 }             }              TestConfig build() {                 cleanupStaleOutputs();                 return new TestConfig(mUseGrid, mMaxNumImages, mNumImages,                         mWidth, mHeight, mRotation, mQuality, mOutputPath);             }         }          @Override         public String toString() {             return ""TestConfig""                     + "": mUseGrid "" + mUseGrid                     + "", mMaxNumImages "" + mMaxNumImages                     + "", mNumImages "" + mNumImages                     + "", mWidth "" + mWidth                     + "", mHeight "" + mHeight                     + "", mRotation "" + mRotation                     + "", mQuality "" + mQuality                     + "", mOutputPath "" + mOutputPath;         }     }      private void verifyResult(             String filename, int width, int height, int rotation, boolean useGrid, int numImages)             throws Exception {         MediaMetadataRetriever retriever = new MediaMetadataRetriever();         retriever.setDataSource(filename);         String hasImage = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_IMAGE);         if (!""yes"".equals(hasImage)) {             throw new Exception(""No images found in file "" + filename);         }         assertEquals(""Wrong image count"", numImages,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_COUNT)));         assertEquals(""Wrong width"", width,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_WIDTH)));         assertEquals(""Wrong height"", height,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_HEIGHT)));         assertEquals(""Wrong rotation"", rotation,                 Integer.parseInt(retriever.extractMetadata(                     MediaMetadataRetriever.METADATA_KEY_IMAGE_ROTATION)));         retriever.release();          if (useGrid) {             MediaExtractor extractor = new MediaExtractor();             extractor.setDataSource(filename);             MediaFormat format = extractor.getTrackFormat(0);             int tileWidth = format.getInteger(MediaFormat.KEY_TILE_WIDTH);             int tileHeight = format.getInteger(MediaFormat.KEY_TILE_HEIGHT);             int gridRows = format.getInteger(MediaFormat.KEY_GRID_ROWS);             int gridCols = format.getInteger(MediaFormat.KEY_GRID_COLUMNS);             assertTrue(""Wrong tile width or grid cols"",                     ((width + tileWidth - 1) / tileWidth) == gridCols);             assertTrue(""Wrong tile height or grid rows"",                     ((height + tileHeight - 1) / tileHeight) == gridRows);             extractor.release();         }     }      /**      * Validate capture results.      *      * @param format The format of this capture.      * @param size The capture size.      * @param listener The capture listener to get capture result callbacks.      * @return the last verified CaptureResult      */     private CaptureResult validateCaptureResult(             int format, Size size, SimpleCaptureCallback listener, int numFrameVerified) {         CaptureResult result = null;         for (int i = 0; i < numFrameVerified; i++) {             result = listener.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);             if (mStaticInfo.isCapabilitySupported(                     CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS)) {                 Long exposureTime = getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);                 Integer sensitivity = getValueNotNull(result, CaptureResult.SENSOR_SENSITIVITY);                 mCollector.expectInRange(                         String.format(                                 ""Capture for format %d, size %s exposure time is invalid."",                                 format, size.toString()),                         exposureTime,                         mStaticInfo.getExposureMinimumOrDefault(),                         mStaticInfo.getExposureMaximumOrDefault()                 );                 mCollector.expectInRange(                         String.format(""Capture for format %d, size %s sensitivity is invalid."",                                 format, size.toString()),                         sensitivity,                         mStaticInfo.getSensitivityMinimumOrDefault(),                         mStaticInfo.getSensitivityMaximumOrDefault()                 );             }             // TODO: add more key validations.         }         return result;     } } ",9.16/C-1-4,,09160000.670104,AND C-1-4 9.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.HeifWriterTest:testHeif()],,AND,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,,
,9.16,C-1-5,,android.graphics.cts.VulkanFeaturesTest,testVulkan1_1Requirements(),,"     public void testVulkan1_1Requirements() throws JSONException {         if (mVulkanHardwareVersion == null || mVulkanHardwareVersion.version < VULKAN_1_1                 || !PropertyUtil.isVendorApiLevelNewerThan(                         API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ)) {             return;         }         assertTrue(""Devices with Vulkan 1.1 must support sampler YCbCr conversion"",                 mBestDevice.getJSONObject(""samplerYcbcrConversionFeatures"")                            .getInt(""samplerYcbcrConversion"") != 0);          if (hasOnlyCpuDevice()) {             return;         }         assertTrue(""Devices with Vulkan 1.1 must support "" +                 VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME +                 "" (version >= "" + VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION +                 "")"",                 hasExtension(mBestDevice,                     VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME,                     VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION));         assertTrue(""Devices with Vulkan 1.1 must support SYNC_FD external semaphores"",                 hasHandleType(mBestDevice.getJSONArray(""externalSemaphoreProperties""),                     VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,                     ""externalSemaphoreFeatures"", 0x3 /* importable + exportable */));         assertTrue(""Devices with Vulkan 1.1 must support SYNC_FD external fences"",                 hasHandleType(mBestDevice.getJSONArray(""externalFenceProperties""),                     VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,                     ""externalFenceFeatures"", 0x3 /* importable + exportable */));     }      @CddTest(requirement = ""7.9.2/C-1-5"")     ",9.16/C-1-5,,09160000.670105,C-1-5 9.16,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkan1_1Requirements()],,C-1-5,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
