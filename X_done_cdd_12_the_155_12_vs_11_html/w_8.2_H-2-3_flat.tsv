"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"2.2.7.4  . Performance"	"8.2"	"H-2-3"	"8.2/H-2-3"	"08020000.720203"	"""[8.2/H-2-3] MUST ensure a sequential read performance of at least 250 MB/s. """	""	""	"update sequential"	""	""	""	""	""	""	""	""	"android.filesystem.cts.AlmostFullTest"	"AlmostFullTest"	"CtsFileSystemTestCases"	"/home/gpoor/cts-12-source/cts/tests/filesystem/src/android/filesystem/cts/AlmostFullTest.java"	""	"/*
 *.
 */

package android.filesystem.cts;

import static androidx.test.InstrumentationRegistry.getContext;
import static androidx.test.InstrumentationRegistry.getInstrumentation;

import android.util.Log;

import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.DeviceReportLog;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

@RunWith(AndroidJUnit4.class)
public class AlmostFullTest {
    private static final String DIR_INITIAL_FILL = ""INITIAL_FILL"";
    private static final String DIR_SEQ_UPDATE = ""SEQ_UPDATE"";
    private static final String DIR_RANDOM_WR = ""RANDOM_WR"";
    private static final String DIR_RANDOM_RD = ""RANDOM_RD"";
    private static final String TAG = ""AlmostFullTest"";
    private static final String REPORT_LOG_NAME = ""CtsFileSystemTestCases"";

    private static final long FREE_SPACE_FINAL = 1000L * 1024 * 1024L;

    // test runner creates multiple instances at the begging.
    // use that to fill disk only once.
    // set as final to initialize it only once
    private static final AtomicInteger mRefCounter = new AtomicInteger(0);
    private static final AtomicBoolean mDiskFilled = new AtomicBoolean(false);

    public AlmostFullTest() {
        int currentCounter = mRefCounter.incrementAndGet();
        Log.i(TAG, ""++currentCounter: "" + currentCounter);
    }

    @Before
    public void setUp() throws Exception {
        if (mDiskFilled.compareAndSet(false, true)) {
            Log.i(TAG, ""Filling disk"");
            // initial fill done in two stage as disk can be filled by other
            // components
            long freeDisk = SystemUtil.getFreeDiskSize(getContext());
            long diskToFill = freeDisk - FREE_SPACE_FINAL;
            if (diskToFill >= 0) {
                Log.i(TAG, ""free disk "" + freeDisk + "", to fill "" + diskToFill);
            } else {
                Log.i(TAG, ""free disk "" + freeDisk + "" too small, needs "" + FREE_SPACE_FINAL);
                return;
            }
            // Ensure MAX_SIZE_TO_FILL is an integral multiple of FileUtil.BUFFER_SIZE to avoid
            // rounding errors caused by FileUtil.createNewFilledFile. See b/63535343.
            final long MAX_FILE_SIZE_TO_FILL = FileUtil.BUFFER_SIZE * 100L;
            long filled = 0;
            while (filled < diskToFill) {
                long toFill = diskToFill - filled;
                if (toFill > MAX_FILE_SIZE_TO_FILL) {
                    toFill = MAX_FILE_SIZE_TO_FILL;
                }
                Log.i(TAG, ""Generating file "" + toFill);
                FileUtil.createNewFilledFile(getContext(),
                        DIR_INITIAL_FILL, toFill);
                filled += toFill;
            }
        }
        Log.i(TAG, ""free disk "" + SystemUtil.getFreeDiskSize(getContext()));
    }

    @After
    public void tearDown() throws Exception {
        Log.i(TAG, ""tearDown free disk "" + SystemUtil.getFreeDiskSize(getContext()));
        int currentCounter = mRefCounter.decrementAndGet();
        Log.i(TAG, ""--currentCounter: "" + currentCounter);
        if (currentCounter == 0) {
            FileUtil.removeFileOrDir(getContext(), DIR_INITIAL_FILL);
        }
        FileUtil.removeFileOrDir(getContext(), DIR_SEQ_UPDATE);
        FileUtil.removeFileOrDir(getContext(), DIR_RANDOM_WR);
        FileUtil.removeFileOrDir(getContext(), DIR_RANDOM_RD);
        Log.i(TAG, ""tearDown free disk "" + SystemUtil.getFreeDiskSize(getContext()));
    }"	""	""	"update"	""	""	""	""	""	""	""	""	""	""
"2.2.7.4  . Performance"	"8.2"	"H-2-3"	"8.2/H-2-3"	"08020000.720203"	"""[8.2/H-2-3] MUST ensure a sequential read performance of at least 250 MB/s. """	""	""	"update sequential"	""	""	""	""	""	""	""	""	"android.filesystem.cts.AlmostFullTest"	"testSequentialUpdate"	"CtsFileSystemTestCases"	"/home/gpoor/cts-12-source/cts/tests/filesystem/src/android/filesystem/cts/AlmostFullTest.java"	""	"public void testSequentialUpdate() throws Exception {
        // now about freeSpaceToLeave should be left
        // and try updating exceeding the free space size
        final long FILE_SIZE = 400L * 1024L * 1024L;
        long freeDisk = SystemUtil.getFreeDiskSize(getContext());
        Log.i(TAG, ""Now free space is "" + freeDisk);
        if (freeDisk < FILE_SIZE) {
            Log.w(TAG, ""too little space: "" + freeDisk);
            return;
        }
        final int BUFFER_SIZE = 10 * 1024 * 1024;
        final int NUMBER_REPETITION = 10;
        String streamName = ""test_sequential_update"";
        FileUtil.doSequentialUpdateTest(getContext(), DIR_SEQ_UPDATE, FILE_SIZE, BUFFER_SIZE,
                NUMBER_REPETITION, REPORT_LOG_NAME, streamName);
    }

    // TODO: file size too small and caching will give wrong better result.
    // needs to flush cache by reading big files per each read."	""	""	"update sequential"	""	""	""	""	""	""	""	""	""	""
"2.2.7.4  . Performance"	"8.2"	"H-2-3"	"8.2/H-2-3"	"08020000.720203"	"""[8.2/H-2-3] MUST ensure a sequential read performance of at least 250 MB/s. """	""	""	"update sequential"	""	""	""	""	""	""	""	""	"android.filesystem.cts.AlmostFullTest"	"testRandomUpdate"	"CtsFileSystemTestCases"	"/home/gpoor/cts-12-source/cts/tests/filesystem/src/android/filesystem/cts/AlmostFullTest.java"	""	"public void testRandomUpdate() throws Exception {
        final int BUFFER_SIZE = 4 * 1024;
        final long fileSize = 256L * 1024L * 1024L;
        long freeDisk = SystemUtil.getFreeDiskSize(getContext());
        if (freeDisk < fileSize) {
            Log.w(TAG, ""too little space: "" + freeDisk);
            return;
        }
        String streamName = ""test_random_update"";
        DeviceReportLog report = new DeviceReportLog(REPORT_LOG_NAME, streamName);
        FileUtil.doRandomWriteTest(getContext(), DIR_RANDOM_WR, report, fileSize, BUFFER_SIZE);
        report.submit(getInstrumentation());
    }
}"	""	""	"update"	""	""	""	""	""	""	""	""	""	""
"2.2.7.4  . Performance"	"8.2"	"H-2-3"	"8.2/H-2-3"	"08020000.720203"	"""[8.2/H-2-3] MUST ensure a sequential read performance of at least 250 MB/s. """	""	""	"update sequential"	""	""	""	""	""	""	""	""	"android.filesystem.cts.RandomRWTest"	"testRandomUpdate"	"CtsFileSystemTestCases"	"/home/gpoor/cts-12-source/cts/tests/filesystem/src/android/filesystem/cts/RandomRWTest.java"	""	"public void testRandomUpdate() throws Exception {
        final int WRITE_BUFFER_SIZE = 4 * 1024;
        final long usableSpace = Environment.getDataDirectory().getUsableSpace();
        long fileSize = 256 * 1024 * 1024;
        while (usableSpace < fileSize) {
            fileSize = fileSize / 2;
        }
        String streamName = ""test_random_update"";
        DeviceReportLog report = new DeviceReportLog(REPORT_LOG_NAME, streamName);
        double mbps = -1;
        // this is in-fact true
        if (fileSize > FileUtil.BUFFER_SIZE) {
            mbps = FileUtil.doRandomWriteTest(getContext(), DIR_RANDOM_WR, report, fileSize,
                WRITE_BUFFER_SIZE);
        }
        report.submit(getInstrumentation());
        if (MediaPerformanceClassUtils.isPerfClass()) {
            // for performance class devices we must be able to write 256MB
            assertTrue(""measured "" + mbps + "" is less than target ("" + MIN_WRITE_MBPS + "" MBPS)"",
                       mbps >= MIN_WRITE_MBPS);
        }
    }
}"	""	""	"update"	""	""	""	""	""	""	""	""	""	""
"2.2.7.4  . Performance"	"8.2"	"H-2-3"	"8.2/H-2-3"	"08020000.720203"	"""[8.2/H-2-3] MUST ensure a sequential read performance of at least 250 MB/s. """	""	""	"update sequential"	""	""	""	""	""	""	""	""	"android.filesystem.cts.SequentialRWTest"	"isRPerfClass"	"CtsFileSystemTestCases"	"/home/gpoor/cts-12-source/cts/tests/filesystem/src/android/filesystem/cts/SequentialRWTest.java"	""	"/*
 *.
 */

package android.filesystem.cts;

import android.util.Log;

import static androidx.test.InstrumentationRegistry.getContext;
import static androidx.test.InstrumentationRegistry.getInstrumentation;

import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.DeviceReportLog;
import com.android.compatibility.common.util.MeasureRun;
import com.android.compatibility.common.util.MeasureTime;
import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;
import com.android.compatibility.common.util.Stat;

import static org.junit.Assert.assertTrue;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

@RunWith(AndroidJUnit4.class)
public class SequentialRWTest {
    private static final String TAG = ""SequentialRWTest"";

    private static final String DIR_SEQ_WR = ""SEQ_WR"";
    private static final String DIR_SEQ_UPDATE = ""SEQ_UPDATE"";
    private static final String DIR_SEQ_RD = ""SEQ_RD"";
    private static final String REPORT_LOG_NAME = ""CtsFileSystemTestCases"";
    private static final int BUFFER_SIZE = 10 * 1024 * 1024;
    private static final double MIN_READ_MBPS;
    private static final double MIN_WRITE_MBPS;

    static {
        if (MediaPerformanceClassUtils.isRPerfClass()) {
            MIN_READ_MBPS = 200;
            MIN_WRITE_MBPS = 100;
        } else {
            // Performance class Build.VERSION_CODES.S and beyond
            MIN_READ_MBPS = 250;
            MIN_WRITE_MBPS = 125;
        }
    }

    @After
    public void tearDown() throws Exception {
        FileUtil.removeFileOrDir(getContext(), DIR_SEQ_WR);
        FileUtil.removeFileOrDir(getContext(), DIR_SEQ_UPDATE);
        FileUtil.removeFileOrDir(getContext(), DIR_SEQ_RD);
    }

    @CddTest(requirement=""8.2"")"	""	""	"update sequential"	""	""	""	""	""	""	""	""	""	""
"2.2.7.4  . Performance"	"8.2"	"H-2-3"	"8.2/H-2-3"	"08020000.720203"	"""[8.2/H-2-3] MUST ensure a sequential read performance of at least 250 MB/s. """	""	""	"update sequential"	""	""	""	""	""	""	""	""	"android.filesystem.cts.SequentialRWTest"	"testSingleSequentialUpdate"	"CtsFileSystemTestCases"	"/home/gpoor/cts-12-source/cts/tests/filesystem/src/android/filesystem/cts/SequentialRWTest.java"	""	"public void testSingleSequentialUpdate() throws Exception {
        final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE);
        if (fileSize == 0) { // not enough space, give up
            return;
        }
        final int NUMBER_REPETITION = 3;
        String streamName = ""test_single_sequential_update"";
        FileUtil.doSequentialUpdateTest(getContext(), DIR_SEQ_UPDATE, fileSize, BUFFER_SIZE,
                NUMBER_REPETITION, REPORT_LOG_NAME, streamName);
    }

    @CddTest(requirement=""8.2"")"	""	""	"update sequential"	""	""	""	""	""	""	""	""	""	""
"2.2.7.4  . Performance"	"8.2"	"H-2-3"	"8.2/H-2-3"	"08020000.720203"	"""[8.2/H-2-3] MUST ensure a sequential read performance of at least 250 MB/s. """	""	""	"update sequential"	""	""	""	""	""	""	""	""	"android.filesystem.cts.SequentialRWTest"	"testSingleSequentialWrite"	"CtsFileSystemTestCases"	"/home/gpoor/cts-12-source/cts/tests/filesystem/src/android/filesystem/cts/SequentialRWTest.java"	""	"public void testSingleSequentialWrite() throws Exception {
        final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE);
        if (fileSize == 0) { // not enough space, give up
            return;
        }
        final int numberOfFiles =(int)(fileSize / BUFFER_SIZE);
        String streamName = ""test_single_sequential_write"";
        DeviceReportLog report = new DeviceReportLog(REPORT_LOG_NAME, streamName);
        report.addValue(""files"", numberOfFiles, ResultType.NEUTRAL, ResultUnit.COUNT);
        final byte[] data = FileUtil.generateRandomData(BUFFER_SIZE);
        final File[] files = FileUtil.createNewFiles(getContext(), DIR_SEQ_WR,
                numberOfFiles);
        double[] rdAmount = new double[numberOfFiles];
        double[] wrAmount = new double[numberOfFiles];
        double[] times = FileUtil.measureIO(numberOfFiles, rdAmount, wrAmount, new MeasureRun() {

            @Override
            public void run(int i) throws IOException {
                FileUtil.writeFile(files[i], data, false);
            }
        });
        double[] mbps = Stat.calcRatePerSecArray((double)BUFFER_SIZE / 1024 / 1024, times);
        report.addValues(""write_throughput"", mbps, ResultType.HIGHER_BETTER, ResultUnit.MBPS);
        report.addValues(""write_amount"", wrAmount, ResultType.NEUTRAL, ResultUnit.BYTE);
        Stat.StatResult stat = Stat.getStat(mbps);
        report.setSummary(""write_throughput_average"", stat.mAverage, ResultType.HIGHER_BETTER,
                ResultUnit.MBPS);
        Log.v(TAG, ""sequential write "" + stat.mAverage + "" MBPS"");
        report.submit(getInstrumentation());

        if (MediaPerformanceClassUtils.isPerfClass()) {
            assertTrue(""measured "" + stat.mAverage + "" is less than target ("" + MIN_WRITE_MBPS +
                       "" MBPS)"", stat.mAverage >= MIN_WRITE_MBPS);
        }
    }"	""	""	"sequential"	""	""	""	""	""	""	""	""	""	""
"2.2.7.4  . Performance"	"8.2"	"H-2-3"	"8.2/H-2-3"	"08020000.720203"	"""[8.2/H-2-3] MUST ensure a sequential read performance of at least 250 MB/s. """	""	""	"update sequential"	""	""	""	""	""	""	""	""	"android.filesystem.cts.SequentialRWTest"	"testSingleSequentialRead"	"CtsFileSystemTestCases"	"/home/gpoor/cts-12-source/cts/tests/filesystem/src/android/filesystem/cts/SequentialRWTest.java"	""	"public void testSingleSequentialRead() throws Exception {
        final long fileSize = FileUtil.getFileSizeExceedingMemory(getContext(), BUFFER_SIZE);
        if (fileSize == 0) { // not enough space, give up
            return;
        }
        long start = System.currentTimeMillis();
        final File file = FileUtil.createNewFilledFile(getContext(),
                DIR_SEQ_RD, fileSize);
        long finish = System.currentTimeMillis();
        String streamName = ""test_single_sequential_read"";
        DeviceReportLog report = new DeviceReportLog(REPORT_LOG_NAME, streamName);
        report.addValue(""file_size"", fileSize, ResultType.NEUTRAL, ResultUnit.NONE);
        report.addValue(""write_throughput"",
                Stat.calcRatePerSec((double)fileSize / 1024 / 1024, finish - start),
                ResultType.HIGHER_BETTER, ResultUnit.MBPS);

        final int NUMBER_READ = 10;

        final byte[] data = new byte[BUFFER_SIZE];
        double[] times = MeasureTime.measure(NUMBER_READ, new MeasureRun() {

            @Override
            public void run(int i) throws IOException {
                final FileInputStream in = new FileInputStream(file);
                long read = 0;
                while (read < fileSize) {
                    in.read(data);
                    read += BUFFER_SIZE;
                }
                in.close();
            }
        });
        double[] mbps = Stat.calcRatePerSecArray((double)fileSize / 1024 / 1024, times);
        report.addValues(""read_throughput"", mbps, ResultType.HIGHER_BETTER, ResultUnit.MBPS);
        Stat.StatResult stat = Stat.getStat(mbps);
        report.setSummary(""read_throughput_average"", stat.mAverage, ResultType.HIGHER_BETTER,
                ResultUnit.MBPS);
        Log.v(TAG, ""sequential read "" + stat.mAverage + "" MBPS"");
        report.submit(getInstrumentation());

        if (MediaPerformanceClassUtils.isPerfClass()) {
            assertTrue(""measured "" + stat.mAverage + "" is less than target ("" + MIN_READ_MBPS +
                       "" MBPS)"", stat.mAverage >= MIN_READ_MBPS);
        }
    }
}"	""	""	"sequential"	""	""	""	""	""	""	""	""	""	""
"2.2.7.4  . Performance"	"8.2"	"H-2-3"	"8.2/H-2-3"	"08020000.720203"	"""[8.2/H-2-3] MUST ensure a sequential read performance of at least 250 MB/s. """	""	""	"update sequential"	""	""	""	""	""	""	""	""	"android.filesystem.cts.FileUtil"	"list"	"CtsFileSystemTestCases"	"/home/gpoor/cts-12-source/cts/tests/filesystem/src/android/filesystem/cts/FileUtil.java"	""	"public void test/*
 *.
 */

package android.filesystem.cts;

import android.content.Context;
import android.util.Log;

import com.android.compatibility.common.util.DeviceReportLog;
import com.android.compatibility.common.util.MeasureRun;
import com.android.compatibility.common.util.MeasureTime;
import com.android.compatibility.common.util.ReportLog;
import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;
import com.android.compatibility.common.util.Stat;
import com.android.compatibility.common.util.SystemUtil;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.RandomAccessFile;
import java.util.Random;

public class FileUtil {
    private static final String TAG = ""FileUtil"";
    private static final Random mRandom = new Random(0);
    private static long mFileId = 0;

    public static final int BUFFER_SIZE = 10 * 1024 * 1024;
    /**
     * create array with different data per each call
     *
     * @param length
     * @param randomSeed
     * @return
     */
    public static byte[] generateRandomData(int length) {
        byte[] buffer = new byte[length];
        int val = mRandom.nextInt();
        for (int i = 0; i < length / 4; i++) {
            // in little-endian
            buffer[i * 4] = (byte)(val & 0x000000ff);
            buffer[i * 4 + 1] = (byte)((val & 0x0000ff00) >> 8);
            buffer[i * 4 + 2] = (byte)((val & 0x00ff0000) >> 16);
            buffer[i * 4 + 3] = (byte)((val & 0xff000000) >> 24);
            val++;
        }
        for (int i = (length / 4) * 4; i < length; i++) {
            buffer[i] = 0;
        }
        return buffer;
    }

    /**
     * create a new file under the given dirName.
     * Existing files will not be affected.
     * @param context
     * @param dirName
     * @return
     */
    public static File createNewFile(Context context, String dirName) {
        File topDir = new File(context.getFilesDir(), dirName);
        topDir.mkdir();
        String[] list = topDir.list();

        String newFileName;
        while (true) {
            newFileName = Long.toString(mFileId);
            boolean fileExist = false;
            for (String child : list) {
                if (child.equals(newFileName)) {
                    fileExist = true;
                    break;
                }
            }
            if (!fileExist) {
                break;
            }
            mFileId++;
        }
        mFileId++;
        //Log.i(TAG, ""filename"" + Long.toString(mFileId));
        return new File(topDir, newFileName);
    }

    /**
     * create multiple new files
     * @param context
     * @param dirName
     * @param count number of files to create
     * @return
     */
    public static File[] createNewFiles(Context context, String dirName, int count) {
        File[] files = new File[count];
        for (int i = 0; i < count; i++) {
            files[i] = createNewFile(context, dirName);
        }
        return files;
    }

    /**
     * write file with given byte array
     * @param file
     * @param data
     * @param append will append if set true. Otherwise, write from beginning
     * @throws IOException
     */
    public static void writeFile(File file, byte[] data, boolean append) throws IOException {
        final RandomAccessFile randomFile = new RandomAccessFile(file, ""rwd""); // force O_SYNC
        if (append) {
            randomFile.seek(randomFile.length());
        } else {
            randomFile.seek(0L);
        }
        randomFile.write(data);
        randomFile.close();
    }

    /**
     * create a new file with given length.
     * @param context
     * @param dirName
     * @param length
     * @return
     * @throws IOException
     */
    public static File createNewFilledFile(Context context, String dirName, long length)
            throws IOException {
        File file = createNewFile(context, dirName);
        final RandomAccessFile randomFile = new RandomAccessFile(file, ""rwd""); // force O_SYNC
        byte[] data = generateRandomData(BUFFER_SIZE);

        while (file.length() < length) {
            int toWrite = (int) Math.min(BUFFER_SIZE, length - file.length());
            randomFile.write(data, 0, toWrite);
        }

        randomFile.close();
        return file;
    }

    /**
     * remove given file or directory under the current app's files dir.
     * @param context
     * @param name
     */
    public static void removeFileOrDir(Context context, String name) {
        File entry = new File(context.getFilesDir(), name);
        if (entry.exists()) {
            removeEntry(entry);
        }
    }

    private static void removeEntry(File entry) {
        if (entry.isDirectory()) {
            String[] children = entry.list();
            for (String child : children) {
                removeEntry(new File(entry, child));
            }
        }
        Log.i(TAG, ""delete file "" + entry.getAbsolutePath());
        entry.delete();
    }

    /**
     * measure time taken for each IO run with amount R/W
     * @param count
     * @param run
     * @param readAmount returns amount of read in bytes for each interval.
     *        Value will not be written if /proc/self/io does not exist.
     * @param writeAmount returns amount of write in bytes for each interval.
     * @return time per each interval
     * @throws IOException
     */
    public static double[] measureIO(int count, double[] readAmount, double[] writeAmount,
            MeasureRun run)  throws Exception {
        double[] result = new double[count];
        File procIo = new File(""/proc/self/io"");
        boolean measureIo = procIo.exists() && procIo.canRead();
        long prev = System.currentTimeMillis();
        RWAmount prevAmount = new RWAmount();
        if (measureIo) {
            prevAmount = getRWAmount(procIo);
        }
        for (int i = 0; i < count; i++) {
            run.run(i);
            long current =  System.currentTimeMillis();
            result[i] = current - prev;
            prev = current;
            if (measureIo) {
                RWAmount currentAmount = getRWAmount(procIo);
                readAmount[i] = currentAmount.mRd - prevAmount.mRd;
                writeAmount[i] = currentAmount.mWr - prevAmount.mWr;
                prevAmount = currentAmount;
            }
        }
        return result;
    }

    private static class RWAmount {
        public double mRd = 0.0;
        public double mWr = 0.0;
    };

    private static RWAmount getRWAmount(File file) throws IOException {
        RWAmount amount = new RWAmount();

        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
        String line;
        while((line = br.readLine())!= null) {
            if (line.startsWith(""read_bytes"")) {
                amount.mRd = Double.parseDouble(line.split("" "")[1]);
            } else if (line.startsWith(""write_bytes"")) {
                amount.mWr = Double.parseDouble(line.split("" "")[1]);
            }
        }
        br.close();
        return amount;
    }

    /**
     * get file size exceeding total memory size ( 2x total memory).
     * The size is rounded in bufferSize. And the size will be bigger than 400MB.
     * @param context
     * @param bufferSize
     * @return file size or 0 if there is not enough space.
     */
    public static long getFileSizeExceedingMemory(Context context, int bufferSize) {
        long freeDisk = SystemUtil.getFreeDiskSize(context);
        long memSize = SystemUtil.getTotalMemory(context);
        long diskSizeTarget = (2 * memSize / bufferSize) * bufferSize;
        final long minimumDiskSize = (512L * 1024L * 1024L / bufferSize) * bufferSize;
        final long reservedDiskSize = (50L * 1024L * 1024L / bufferSize) * bufferSize;
        if ( diskSizeTarget < minimumDiskSize ) {
            diskSizeTarget = minimumDiskSize;
        }
        if (diskSizeTarget > freeDisk) {
            Log.i(TAG, ""Free disk size "" + freeDisk + "" too small"");
            return 0;
        }
        if ((freeDisk - diskSizeTarget) < reservedDiskSize) {
            diskSizeTarget -= reservedDiskSize;
        }
        return diskSizeTarget;
    }

    /**
     *
     * @param context
     * @param dirName
     * @param report
     * @param fileSize
     * @param bufferSize should be power of two
     * @return write throughput in MBPS
     * @throws IOException
     */
    public static double doRandomReadTest(Context context, String dirName, ReportLog report,
            long fileSize, int bufferSize) throws Exception {
        File file = FileUtil.createNewFilledFile(context,
                dirName, fileSize);

        final byte[] data = FileUtil.generateRandomData(bufferSize);
        Random random = new Random(0);
        final int totalReadCount = (int)(fileSize / bufferSize);
        final int[] readOffsets = new int[totalReadCount];
        for (int i = 0; i < totalReadCount; i++) {
            // align in buffer size
            readOffsets[i] = (int)(random.nextFloat() * (fileSize - bufferSize)) &
                    ~(bufferSize - 1);
        }
        final int runsInOneGo = 16;
        final int readsInOneMeasure = totalReadCount / runsInOneGo;

        final RandomAccessFile randomFile = new RandomAccessFile(file, ""rw""); // do not need O_SYNC
        double[] rdAmount = new double[runsInOneGo];
        double[] wrAmount = new double[runsInOneGo];
        double[] times = FileUtil.measureIO(runsInOneGo, rdAmount, wrAmount, new MeasureRun() {

            @Override
            public void run(int i) throws IOException {
                Log.i(TAG, ""starting "" + i + "" -th round"");
                int start = i * readsInOneMeasure;
                int end = (i + 1) * readsInOneMeasure;
                for (int j = start; j < end; j++) {
                    randomFile.seek(readOffsets[j]);
                    randomFile.read(data);
                }
            }
        });
        randomFile.close();
        double[] mbps = Stat.calcRatePerSecArray((double)fileSize / runsInOneGo / 1024 / 1024,
                times);
        report.addValues(""read_throughput"", mbps, ResultType.HIGHER_BETTER, ResultUnit.MBPS);
        // This is just the amount of IO returned from kernel. So this is performance neutral.
        report.addValues(""read_amount"", rdAmount, ResultType.NEUTRAL, ResultUnit.BYTE);
        Stat.StatResult stat = Stat.getStat(mbps);

        report.setSummary(""read_throughput_average"", stat.mAverage, ResultType.HIGHER_BETTER,
                ResultUnit.MBPS);
        Log.v(TAG, ""random read "" + stat.mAverage + "" MBPS"");
        return stat.mAverage;
    }

    /**
     *
     * @param context
     * @param dirName
     * @param report
     * @param fileSize
     * @param bufferSize should be power of two
     * @return write throughput in MBPS
     * @throws IOException
     */
    public static double doRandomWriteTest(Context context, String dirName, ReportLog report,
            long fileSize, int bufferSize) throws Exception {
        File file = FileUtil.createNewFilledFile(context,
                dirName, fileSize);
        final byte[] data = FileUtil.generateRandomData(bufferSize);
        Random random = new Random(0);
        final int totalWriteCount = (int)(fileSize / bufferSize);
        final int[] writeOffsets = new int[totalWriteCount];
        for (int i = 0; i < totalWriteCount; i++) {
            writeOffsets[i] = (int)(random.nextFloat() * (fileSize - bufferSize)) &
                    ~(bufferSize - 1);
        }
        final int runsInOneGo = 16;
        final int writesInOneMeasure = totalWriteCount / runsInOneGo;

        final RandomAccessFile randomFile = new RandomAccessFile(file, ""rwd""); // force O_SYNC
        double[] rdAmount = new double[runsInOneGo];
        double[] wrAmount = new double[runsInOneGo];
        double[] times = FileUtil.measureIO(runsInOneGo, rdAmount, wrAmount, new MeasureRun() {

            @Override
            public void run(int i) throws IOException {
                Log.i(TAG, ""starting "" + i + "" -th round"");
                int start = i * writesInOneMeasure;
                int end = (i + 1) * writesInOneMeasure;
                for (int j = start; j < end; j++) {
                    randomFile.seek(writeOffsets[j]);
                    randomFile.write(data);
                }
            }
        });
        randomFile.close();
        double[] mbps = Stat.calcRatePerSecArray((double)fileSize / runsInOneGo / 1024 / 1024,
                times);
        report.addValues(""write_throughput"", mbps, ResultType.HIGHER_BETTER, ResultUnit.MBPS);
        report.addValues(""write_amount"", wrAmount, ResultType.NEUTRAL, ResultUnit.BYTE);
        Stat.StatResult stat = Stat.getStat(mbps);

        report.setSummary(""write_throughput_average"", stat.mAverage, ResultType.HIGHER_BETTER,
                ResultUnit.MBPS);
        Log.v(TAG, ""random write "" + stat.mAverage + "" MBPS"");
        return stat.mAverage;
    }

    /**
     *
     * @param context
     * @param dirName
     * @param report
     * @param fileSize fileSize should be multiple of bufferSize.
     * @param bufferSize
     * @param numberRepetition
     * @throws IOException
     */
    public static void doSequentialUpdateTest(Context context, String dirName, long fileSize,
            int bufferSize, int numberRepetition, String reportName, String streamName)
            throws Exception {
        File file = FileUtil.createNewFilledFile(context,
                dirName, fileSize);
        final byte[] data = FileUtil.generateRandomData(bufferSize);
        int numberRepeatInOneRun = (int)(fileSize / bufferSize);
        double[] mbpsAll = new double[numberRepetition * numberRepeatInOneRun];
        for (int i = 0; i < numberRepetition; i++) {
            Log.i(TAG, ""starting "" + i + "" -th round"");
            DeviceReportLog report = new DeviceReportLog(reportName, streamName);
            report.addValue(""round"", i,  ResultType.NEUTRAL, ResultUnit.NONE);
            final RandomAccessFile randomFile = new RandomAccessFile(file, ""rwd"");  // force O_SYNC
            randomFile.seek(0L);
            double[] times = MeasureTime.measure(numberRepeatInOneRun, new MeasureRun() {

                @Override
                public void run(int i) throws IOException {
                    randomFile.write(data);
                }
            });
            randomFile.close();
            double[] mbps = Stat.calcRatePerSecArray((double)bufferSize / 1024 / 1024,
                    times);
            report.addValues(""throughput"", mbps, ResultType.HIGHER_BETTER, ResultUnit.MBPS);
            int offset = i * numberRepeatInOneRun;
            for (int j = 0; j < mbps.length; j++) {
                mbpsAll[offset + j] = mbps[j];
            }
            report.submit();
        }
        Stat.StatResult stat = Stat.getStat(mbpsAll);
        DeviceReportLog report = new DeviceReportLog(reportName, String.format(""%s_average"",
                streamName));
        report.addValue(""update_throughput"", stat.mAverage, ResultType.HIGHER_BETTER,
                ResultUnit.MBPS);
        report.submit();
    }
}"	""	""	"update sequential sequential"	""	""	""	""	""	""	""	""	""	""
