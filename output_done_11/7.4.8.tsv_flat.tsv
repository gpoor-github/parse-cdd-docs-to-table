"Section"	"section_id"	"req_id"	"Test Availability"	"class_def"	"method"	"module"	"method_text"	"full_key"	"requirement"	"key_as_number"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"matched_terms"	"search_roots"	"qualified_method"	"max_matches"	"file_name"	"matched_files"	"methods_string"	"urls"	"protected"	"Area"	"Shortened"	"Test Level"
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.accesscontrol2.cts.AccessControlTest"	"OnConnectedListener"	"CtsSecureElementAccessControlTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"SD"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/access_control/AccessControlApp2/src/android/omapi/accesscontrol2/cts/AccessControlTest.java"	""	"/*
 *.
 */

/* Contributed by Orange */

package android.omapi.accesscontrol2.cts;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.os.Build;
import android.se.omapi.Channel;
import android.se.omapi.Reader;
import android.se.omapi.SEService;
import android.se.omapi.SEService.OnConnectedListener;
import android.se.omapi.Session;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeoutException;

public class AccessControlTest {
    private final static String UICC_READER_PREFIX = ""SIM"";
    private final static String ESE_READER_PREFIX = ""eSE"";
    private final static String SD_READER_PREFIX = ""SD"";

    private final static byte[] AID_40 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x40 };
    private final static byte[] AID_41 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x41 };
    private final static byte[] AID_42 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x42 };
    private final static byte[] AID_43 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x43 };
    private final static byte[] AID_44 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x44 };
    private final static byte[] AID_45 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x45 };
    private final static byte[] AID_46 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x46 };
    private final static byte[] AID_47 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x47 };
    private final static byte[] AID_48 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x48 };
    private final static byte[] AID_49 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x49 };
    private final static byte[] AID_4A = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4A };
    private final static byte[] AID_4B = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4B };
    private final static byte[] AID_4C = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4C };
    private final static byte[] AID_4D = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4D };
    private final static byte[] AID_4E = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4E };
    private final static byte[] AID_4F = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4F };

    private final static byte[][] AUTHORIZED_AID = new byte[][] { AID_40,
        AID_41, AID_43, AID_45, AID_46 };
    private final static byte[][] UNAUTHORIZED_AID = new byte[][] { AID_42,
        AID_44, AID_47, AID_48, AID_49, AID_4A, AID_4B, AID_4C, AID_4D, AID_4E, AID_4F};

    /* Authorized APDU for AID_40 */
    private final static byte[][] AUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0xA0, 0x06, 0x00, 0x00 },};
    /* Unauthorized APDU for AID_40 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, 0x06, 0x00, 0x00, 0x00 }, };

    /* Authorized APDU for AID_41 */
    private final static byte[][] AUTHORIZED_APDU_AID_41 = new byte[][] {
        { (byte) 0x94, 0x06, 0x00, 0x00 },
        { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA } };
    /* Unauthorized APDU for AID_41 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_41 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x06, 0x00, 0x00 },
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
    };

    private final long SERVICE_CONNECTION_TIME_OUT = 3000;
    private SEService seService;
    private Object serviceMutex = new Object();
    private Timer connectionTimer;
    private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();
    private boolean connected = false;

    private final OnConnectedListener mListener = new OnConnectedListener() {
        public void onConnected() {
            synchronized (serviceMutex) {
                connected = true;
                serviceMutex.notify();
            }
        }
    };

    class SynchronousExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        boolean lowRamDevice = PropertyUtil.propertyEquals(""ro.config.low_ram"", ""true"");
        return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")
                || hasSecureElementPackage(pm);
    }

    private boolean hasSecureElementPackage(PackageManager pm) {
        try {
            pm.getPackageInfo(""com.android.se"", 0 /* flags*/);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    private boolean supportOMAPIReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));
    }

    @Before
    public void setUp() throws Exception {
        assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);
        assumeTrue(supportsHardware());
        assumeTrue(supportOMAPIReaders());
        seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);
        connectionTimer = new Timer();
        connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);
    }

    @After
    public void tearDown() throws Exception {
        if (seService != null && seService.isConnected()) {
            seService.shutdown();
            connected = false;
        }
    }

    private void waitForConnection() throws TimeoutException {
        synchronized (serviceMutex) {
            if (!connected) {
                try {
                    serviceMutex.wait();
                 } catch (InterruptedException e) {
                    e.printStackTrace();
                 }
            }
            if (!connected) {
                throw new TimeoutException(
                    ""Service could not be connected after ""
                    + SERVICE_CONNECTION_TIME_OUT + "" ms"");
            }
            if (connectionTimer != null) {
                connectionTimer.cancel();
            }
        }
    }"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.accesscontrol2.cts.AccessControlTest"	"OnConnectedListener"	"CtsSecureElementAccessControlTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"UICC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/access_control/AccessControlApp2/src/android/omapi/accesscontrol2/cts/AccessControlTest.java"	""	"/*
 *.
 */

/* Contributed by Orange */

package android.omapi.accesscontrol2.cts;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.os.Build;
import android.se.omapi.Channel;
import android.se.omapi.Reader;
import android.se.omapi.SEService;
import android.se.omapi.SEService.OnConnectedListener;
import android.se.omapi.Session;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeoutException;

public class AccessControlTest {
    private final static String UICC_READER_PREFIX = ""SIM"";
    private final static String ESE_READER_PREFIX = ""eSE"";
    private final static String SD_READER_PREFIX = ""SD"";

    private final static byte[] AID_40 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x40 };
    private final static byte[] AID_41 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x41 };
    private final static byte[] AID_42 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x42 };
    private final static byte[] AID_43 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x43 };
    private final static byte[] AID_44 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x44 };
    private final static byte[] AID_45 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x45 };
    private final static byte[] AID_46 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x46 };
    private final static byte[] AID_47 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x47 };
    private final static byte[] AID_48 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x48 };
    private final static byte[] AID_49 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x49 };
    private final static byte[] AID_4A = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4A };
    private final static byte[] AID_4B = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4B };
    private final static byte[] AID_4C = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4C };
    private final static byte[] AID_4D = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4D };
    private final static byte[] AID_4E = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4E };
    private final static byte[] AID_4F = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4F };

    private final static byte[][] AUTHORIZED_AID = new byte[][] { AID_40,
        AID_41, AID_43, AID_45, AID_46 };
    private final static byte[][] UNAUTHORIZED_AID = new byte[][] { AID_42,
        AID_44, AID_47, AID_48, AID_49, AID_4A, AID_4B, AID_4C, AID_4D, AID_4E, AID_4F};

    /* Authorized APDU for AID_40 */
    private final static byte[][] AUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0xA0, 0x06, 0x00, 0x00 },};
    /* Unauthorized APDU for AID_40 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, 0x06, 0x00, 0x00, 0x00 }, };

    /* Authorized APDU for AID_41 */
    private final static byte[][] AUTHORIZED_APDU_AID_41 = new byte[][] {
        { (byte) 0x94, 0x06, 0x00, 0x00 },
        { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA } };
    /* Unauthorized APDU for AID_41 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_41 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x06, 0x00, 0x00 },
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
    };

    private final long SERVICE_CONNECTION_TIME_OUT = 3000;
    private SEService seService;
    private Object serviceMutex = new Object();
    private Timer connectionTimer;
    private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();
    private boolean connected = false;

    private final OnConnectedListener mListener = new OnConnectedListener() {
        public void onConnected() {
            synchronized (serviceMutex) {
                connected = true;
                serviceMutex.notify();
            }
        }
    };

    class SynchronousExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        boolean lowRamDevice = PropertyUtil.propertyEquals(""ro.config.low_ram"", ""true"");
        return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")
                || hasSecureElementPackage(pm);
    }

    private boolean hasSecureElementPackage(PackageManager pm) {
        try {
            pm.getPackageInfo(""com.android.se"", 0 /* flags*/);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    private boolean supportOMAPIReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));
    }

    @Before
    public void setUp() throws Exception {
        assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);
        assumeTrue(supportsHardware());
        assumeTrue(supportOMAPIReaders());
        seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);
        connectionTimer = new Timer();
        connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);
    }

    @After
    public void tearDown() throws Exception {
        if (seService != null && seService.isConnected()) {
            seService.shutdown();
            connected = false;
        }
    }

    private void waitForConnection() throws TimeoutException {
        synchronized (serviceMutex) {
            if (!connected) {
                try {
                    serviceMutex.wait();
                 } catch (InterruptedException e) {
                    e.printStackTrace();
                 }
            }
            if (!connected) {
                throw new TimeoutException(
                    ""Service could not be connected after ""
                    + SERVICE_CONNECTION_TIME_OUT + "" ms"");
            }
            if (connectionTimer != null) {
                connectionTimer.cancel();
            }
        }
    }"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.accesscontrol3.cts.AccessControlTest"	"OnConnectedListener"	"CtsSecureElementAccessControlTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"SD"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/access_control/AccessControlApp3/src/android/omapi/accesscontrol3/cts/AccessControlTest.java"	""	"/*
 *.
 */

/* Contributed by Orange */

package android.omapi.accesscontrol3.cts;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.os.Build;
import android.se.omapi.Channel;
import android.se.omapi.Reader;
import android.se.omapi.SEService;
import android.se.omapi.SEService.OnConnectedListener;
import android.se.omapi.Session;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeoutException;

public class AccessControlTest {
    private final static String UICC_READER_PREFIX = ""SIM"";
    private final static String ESE_READER_PREFIX = ""eSE"";
    private final static String SD_READER_PREFIX = ""SD"";

    private final static byte[] AID_40 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x40 };
    private final static byte[] AID_41 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x41 };
    private final static byte[] AID_42 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x42 };
    private final static byte[] AID_43 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x43 };
    private final static byte[] AID_44 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x44 };
    private final static byte[] AID_45 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x45 };
    private final static byte[] AID_46 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x46 };
    private final static byte[] AID_47 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x47 };
    private final static byte[] AID_48 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x48 };
    private final static byte[] AID_49 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x49 };
    private final static byte[] AID_4A = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4A };
    private final static byte[] AID_4B = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4B };
    private final static byte[] AID_4C = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4C };
    private final static byte[] AID_4D = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4D };
    private final static byte[] AID_4E = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4E };
    private final static byte[] AID_4F = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4F };

    private final static byte[][] AUTHORIZED_AID = new byte[][] { AID_40,
        AID_41, AID_45, AID_46 };
    private final static byte[][] UNAUTHORIZED_AID = new byte[][] { AID_42,
        AID_43, AID_44, AID_47, AID_48, AID_49, AID_4A, AID_4B, AID_4C, AID_4D, AID_4E,
        AID_4F };

    /* Authorized APDU for AID_40 */
    private final static byte[][] AUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x06, 0x00, 0x00 },
        { (byte) 0x94, 0x06, 0x00, 0x00 },
        { 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },
        { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 }};

    /* Authorized APDU for AID_41 */
    private final static byte[][] AUTHORIZED_APDU_AID_41 = new byte[][] {
        { (byte) 0x94, 0x06, 0x00, 0x00 },
        { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA } };
    /* Unauthorized APDU for AID_41 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_41 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x06, 0x00, 0x00 },
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
    };

    private final long SERVICE_CONNECTION_TIME_OUT = 3000;
    private SEService seService;
    private Object serviceMutex = new Object();
    private Timer connectionTimer;
    private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();
    private boolean connected = false;

    private final OnConnectedListener mListener = new OnConnectedListener() {
        @Override
        public void onConnected() {
            synchronized (serviceMutex) {
                connected = true;
                serviceMutex.notify();
            }
        }
    };

    class SynchronousExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        boolean lowRamDevice = PropertyUtil.propertyEquals(""ro.config.low_ram"", ""true"");
        return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")
                || hasSecureElementPackage(pm);
    }

    private boolean hasSecureElementPackage(PackageManager pm) {
        try {
            pm.getPackageInfo(""com.android.se"", 0 /* flags*/);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    private boolean supportOMAPIReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));
    }

    @Before
    public void setUp() throws Exception {
        assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);
        assumeTrue(supportsHardware());
        assumeTrue(supportOMAPIReaders());
        seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);
        connectionTimer = new Timer();
        connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);
    }

    @After
    public void tearDown() throws Exception {
        if (seService != null && seService.isConnected()) {
            seService.shutdown();
            connected = false;
        }
    }

    private void waitForConnection() throws TimeoutException {
        synchronized (serviceMutex) {
            if (!connected) {
                try {
                    serviceMutex.wait();
                 } catch (InterruptedException e) {
                    e.printStackTrace();
                 }
            }
            if (!connected) {
                throw new TimeoutException(
                    ""Service could not be connected after ""
                    + SERVICE_CONNECTION_TIME_OUT + "" ms"");
            }
            if (connectionTimer != null) {
                connectionTimer.cancel();
            }
        }
    }"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.accesscontrol3.cts.AccessControlTest"	"OnConnectedListener"	"CtsSecureElementAccessControlTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"UICC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/access_control/AccessControlApp3/src/android/omapi/accesscontrol3/cts/AccessControlTest.java"	""	"/*
 *.
 */

/* Contributed by Orange */

package android.omapi.accesscontrol3.cts;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.os.Build;
import android.se.omapi.Channel;
import android.se.omapi.Reader;
import android.se.omapi.SEService;
import android.se.omapi.SEService.OnConnectedListener;
import android.se.omapi.Session;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeoutException;

public class AccessControlTest {
    private final static String UICC_READER_PREFIX = ""SIM"";
    private final static String ESE_READER_PREFIX = ""eSE"";
    private final static String SD_READER_PREFIX = ""SD"";

    private final static byte[] AID_40 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x40 };
    private final static byte[] AID_41 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x41 };
    private final static byte[] AID_42 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x42 };
    private final static byte[] AID_43 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x43 };
    private final static byte[] AID_44 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x44 };
    private final static byte[] AID_45 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x45 };
    private final static byte[] AID_46 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x46 };
    private final static byte[] AID_47 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x47 };
    private final static byte[] AID_48 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x48 };
    private final static byte[] AID_49 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x49 };
    private final static byte[] AID_4A = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4A };
    private final static byte[] AID_4B = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4B };
    private final static byte[] AID_4C = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4C };
    private final static byte[] AID_4D = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4D };
    private final static byte[] AID_4E = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4E };
    private final static byte[] AID_4F = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4F };

    private final static byte[][] AUTHORIZED_AID = new byte[][] { AID_40,
        AID_41, AID_45, AID_46 };
    private final static byte[][] UNAUTHORIZED_AID = new byte[][] { AID_42,
        AID_43, AID_44, AID_47, AID_48, AID_49, AID_4A, AID_4B, AID_4C, AID_4D, AID_4E,
        AID_4F };

    /* Authorized APDU for AID_40 */
    private final static byte[][] AUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x06, 0x00, 0x00 },
        { (byte) 0x94, 0x06, 0x00, 0x00 },
        { 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },
        { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 }};

    /* Authorized APDU for AID_41 */
    private final static byte[][] AUTHORIZED_APDU_AID_41 = new byte[][] {
        { (byte) 0x94, 0x06, 0x00, 0x00 },
        { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA } };
    /* Unauthorized APDU for AID_41 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_41 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x06, 0x00, 0x00 },
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
    };

    private final long SERVICE_CONNECTION_TIME_OUT = 3000;
    private SEService seService;
    private Object serviceMutex = new Object();
    private Timer connectionTimer;
    private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();
    private boolean connected = false;

    private final OnConnectedListener mListener = new OnConnectedListener() {
        @Override
        public void onConnected() {
            synchronized (serviceMutex) {
                connected = true;
                serviceMutex.notify();
            }
        }
    };

    class SynchronousExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        boolean lowRamDevice = PropertyUtil.propertyEquals(""ro.config.low_ram"", ""true"");
        return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")
                || hasSecureElementPackage(pm);
    }

    private boolean hasSecureElementPackage(PackageManager pm) {
        try {
            pm.getPackageInfo(""com.android.se"", 0 /* flags*/);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    private boolean supportOMAPIReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));
    }

    @Before
    public void setUp() throws Exception {
        assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);
        assumeTrue(supportsHardware());
        assumeTrue(supportOMAPIReaders());
        seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);
        connectionTimer = new Timer();
        connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);
    }

    @After
    public void tearDown() throws Exception {
        if (seService != null && seService.isConnected()) {
            seService.shutdown();
            connected = false;
        }
    }

    private void waitForConnection() throws TimeoutException {
        synchronized (serviceMutex) {
            if (!connected) {
                try {
                    serviceMutex.wait();
                 } catch (InterruptedException e) {
                    e.printStackTrace();
                 }
            }
            if (!connected) {
                throw new TimeoutException(
                    ""Service could not be connected after ""
                    + SERVICE_CONNECTION_TIME_OUT + "" ms"");
            }
            if (connectionTimer != null) {
                connectionTimer.cancel();
            }
        }
    }"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.accesscontrol1.cts.AccessControlTest"	"OnConnectedListener"	"CtsSecureElementAccessControlTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"SD"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/access_control/AccessControlApp1/src/android/omapi/accesscontrol1/cts/AccessControlTest.java"	""	"/*
 *.
 */

/* Contributed by Orange */

package android.omapi.accesscontrol1.cts;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.os.Build;
import android.se.omapi.Channel;
import android.se.omapi.Reader;
import android.se.omapi.SEService;
import android.se.omapi.SEService.OnConnectedListener;
import android.se.omapi.Session;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeoutException;

public class AccessControlTest {
    private final static String UICC_READER_PREFIX = ""SIM"";
    private final static String ESE_READER_PREFIX = ""eSE"";
    private final static String SD_READER_PREFIX = ""SD"";

    private final static byte[] AID_40 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x40 };
    private final static byte[] AID_41 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x41 };
    private final static byte[] AID_42 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x42 };
    private final static byte[] AID_43 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x43 };
    private final static byte[] AID_44 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x44 };
    private final static byte[] AID_45 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x45 };
    private final static byte[] AID_46 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x46 };
    private final static byte[] AID_47 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x47 };
    private final static byte[] AID_48 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x48 };
    private final static byte[] AID_49 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x49 };
    private final static byte[] AID_4A = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4A };
    private final static byte[] AID_4B = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4B };
    private final static byte[] AID_4C = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4C };
    private final static byte[] AID_4D = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4D };
    private final static byte[] AID_4E = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4E };
    private final static byte[] AID_4F = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4F };

    private final static byte[][] AUTHORIZED_AID = new byte[][] { AID_40,
        AID_41, AID_42, AID_44, AID_45, AID_47, AID_48, AID_49, AID_4A,
        AID_4B, AID_4C, AID_4D, AID_4E, AID_4F };
    private final static byte[][] UNAUTHORIZED_AID = new byte[][] { AID_43,
        AID_46 };

    /* Authorized APDU for AID_40 */
    private final static byte[][] AUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0xA0, 0x06, 0x00, 0x00 },};
    /* Unauthorized APDU for AID_40 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, 0x06, 0x00, 0x00, 0x00 }, };

    /* Authorized APDU for AID_41 */
    private final static byte[][] AUTHORIZED_APDU_AID_41 = new byte[][] {
        { (byte) 0x94, 0x06, 0x00, 0x00 },
        { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA } };
    /* Unauthorized APDU for AID_41 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_41 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x06, 0x00, 0x00 },
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
    };

    private final long SERVICE_CONNECTION_TIME_OUT = 3000;
    private SEService seService;
    private Object serviceMutex = new Object();
    private Timer connectionTimer;
    private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();
    private boolean connected = false;

    private final OnConnectedListener mListener = new OnConnectedListener() {
        public void onConnected() {
            synchronized (serviceMutex) {
                connected = true;
                serviceMutex.notify();
            }
        }
    };

    class SynchronousExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        boolean lowRamDevice = PropertyUtil.propertyEquals(""ro.config.low_ram"", ""true"");
        return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")
                || hasSecureElementPackage(pm);
    }

    private boolean hasSecureElementPackage(PackageManager pm) {
        try {
            pm.getPackageInfo(""com.android.se"", 0 /* flags*/);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    private boolean supportOMAPIReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));
    }

    @Before
    public void setUp() throws Exception {
        assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);
        assumeTrue(supportsHardware());
        assumeTrue(supportOMAPIReaders());
        seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);
        connectionTimer = new Timer();
        connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);
    }

    @After
    public void tearDown() throws Exception {
        if (seService != null && seService.isConnected()) {
            seService.shutdown();
            connected = false;
        }
    }

    private void waitForConnection() throws TimeoutException {
        synchronized (serviceMutex) {
            if (!connected) {
                try {
                    serviceMutex.wait();
                 } catch (InterruptedException e) {
                    e.printStackTrace();
                 }
            }
            if (!connected) {
                throw new TimeoutException(
                    ""Service could not be connected after ""
                    + SERVICE_CONNECTION_TIME_OUT + "" ms"");
            }
            if (connectionTimer != null) {
                connectionTimer.cancel();
            }
        }
    }"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.accesscontrol1.cts.AccessControlTest"	"OnConnectedListener"	"CtsSecureElementAccessControlTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"UICC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/access_control/AccessControlApp1/src/android/omapi/accesscontrol1/cts/AccessControlTest.java"	""	"/*
 *.
 */

/* Contributed by Orange */

package android.omapi.accesscontrol1.cts;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.os.Build;
import android.se.omapi.Channel;
import android.se.omapi.Reader;
import android.se.omapi.SEService;
import android.se.omapi.SEService.OnConnectedListener;
import android.se.omapi.Session;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeoutException;

public class AccessControlTest {
    private final static String UICC_READER_PREFIX = ""SIM"";
    private final static String ESE_READER_PREFIX = ""eSE"";
    private final static String SD_READER_PREFIX = ""SD"";

    private final static byte[] AID_40 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x40 };
    private final static byte[] AID_41 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x41 };
    private final static byte[] AID_42 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x42 };
    private final static byte[] AID_43 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x43 };
    private final static byte[] AID_44 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x44 };
    private final static byte[] AID_45 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x45 };
    private final static byte[] AID_46 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x46 };
    private final static byte[] AID_47 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x47 };
    private final static byte[] AID_48 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x48 };
    private final static byte[] AID_49 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x49 };
    private final static byte[] AID_4A = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4A };
    private final static byte[] AID_4B = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4B };
    private final static byte[] AID_4C = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4C };
    private final static byte[] AID_4D = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4D };
    private final static byte[] AID_4E = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4E };
    private final static byte[] AID_4F = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4F };

    private final static byte[][] AUTHORIZED_AID = new byte[][] { AID_40,
        AID_41, AID_42, AID_44, AID_45, AID_47, AID_48, AID_49, AID_4A,
        AID_4B, AID_4C, AID_4D, AID_4E, AID_4F };
    private final static byte[][] UNAUTHORIZED_AID = new byte[][] { AID_43,
        AID_46 };

    /* Authorized APDU for AID_40 */
    private final static byte[][] AUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0xA0, 0x06, 0x00, 0x00 },};
    /* Unauthorized APDU for AID_40 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, 0x06, 0x00, 0x00, 0x00 }, };

    /* Authorized APDU for AID_41 */
    private final static byte[][] AUTHORIZED_APDU_AID_41 = new byte[][] {
        { (byte) 0x94, 0x06, 0x00, 0x00 },
        { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA } };
    /* Unauthorized APDU for AID_41 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_41 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x06, 0x00, 0x00 },
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
    };

    private final long SERVICE_CONNECTION_TIME_OUT = 3000;
    private SEService seService;
    private Object serviceMutex = new Object();
    private Timer connectionTimer;
    private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();
    private boolean connected = false;

    private final OnConnectedListener mListener = new OnConnectedListener() {
        public void onConnected() {
            synchronized (serviceMutex) {
                connected = true;
                serviceMutex.notify();
            }
        }
    };

    class SynchronousExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        boolean lowRamDevice = PropertyUtil.propertyEquals(""ro.config.low_ram"", ""true"");
        return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")
                || hasSecureElementPackage(pm);
    }

    private boolean hasSecureElementPackage(PackageManager pm) {
        try {
            pm.getPackageInfo(""com.android.se"", 0 /* flags*/);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    private boolean supportOMAPIReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));
    }

    @Before
    public void setUp() throws Exception {
        assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);
        assumeTrue(supportsHardware());
        assumeTrue(supportOMAPIReaders());
        seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);
        connectionTimer = new Timer();
        connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);
    }

    @After
    public void tearDown() throws Exception {
        if (seService != null && seService.isConnected()) {
            seService.shutdown();
            connected = false;
        }
    }

    private void waitForConnection() throws TimeoutException {
        synchronized (serviceMutex) {
            if (!connected) {
                try {
                    serviceMutex.wait();
                 } catch (InterruptedException e) {
                    e.printStackTrace();
                 }
            }
            if (!connected) {
                throw new TimeoutException(
                    ""Service could not be connected after ""
                    + SERVICE_CONNECTION_TIME_OUT + "" ms"");
            }
            if (connectionTimer != null) {
                connectionTimer.cancel();
            }
        }
    }"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.cts.OmapiTest"	"OnConnectedListener"	"CtsOmapiTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"SD"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/omapi/src/android/omapi/cts/OmapiTest.java"	""	"/*
 *.
 */

/* Contributed by Orange */

package android.omapi.cts;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.os.Build;
import android.os.SystemProperties;
import android.se.omapi.Channel;
import android.se.omapi.Reader;
import android.se.omapi.SEService;
import android.se.omapi.SEService.OnConnectedListener;
import android.se.omapi.Session;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeoutException;

public class OmapiTest {

    private final static String UICC_READER_PREFIX = ""SIM"";
    private final static String ESE_READER_PREFIX = ""eSE"";
    private final static String SD_READER_PREFIX = ""SD"";
    private final static byte[] SELECTABLE_AID =
            new byte[]{(byte) 0xA0, 0x00, 0x00, 0x04, 0x76, 0x41, 0x6E, 0x64,
                    0x72, 0x6F, 0x69, 0x64, 0x43, 0x54, 0x53, 0x31};
    private final static byte[] LONG_SELECT_RESPONSE_AID =
            new byte[]{(byte) 0xA0, 0x00, 0x00, 0x04, 0x76, 0x41, 0x6E, 0x64,
                    0x72, 0x6F, 0x69, 0x64, 0x43, 0x54, 0x53, 0x32};
    private final static byte[] NON_SELECTABLE_AID =
            new byte[]{(byte) 0xA0, 0x00, 0x00, 0x04, 0x76, 0x41, 0x6E, 0x64,
                    0x72, 0x6F, 0x69, 0x64, 0x43, 0x54, 0x53, (byte) 0xFF};

    /* MANAGE open/close and SELECT AID */
    private final static byte[][] ILLEGAL_COMMANDS_TRANSMIT = new byte[][]{{0x00, 0x70, 0x00, 0x00},
            {0x00, 0x70, (byte) 0x80, 0x00},
            {0x00, (byte) 0xA4, 0x04, 0x04, 0x10, 0x4A, 0x53,
                    0x52, 0x31, 0x37, 0x37, 0x54, 0x65, 0x73,
                    0x74, 0x65, 0x72, 0x20, 0x31, 0x2E, 0x30}
    };

    /* OMAPI APDU Test case 1 and 3 */
    private final static byte[][] NO_DATA_APDU = new byte[][]{{0x00, 0x06, 0x00, 0x00},
            {(byte) 0x80, 0x06, 0x00, 0x00},
            {(byte) 0xA0, 0x06, 0x00, 0x00},
            {(byte) 0x94, 0x06, 0x00, 0x00},
            {0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA},
            {(byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA},
            {(byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA},
            {(byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA}
    };
    /* OMAPI APDU Test case 2 and 4 */
    private final static byte[][] DATA_APDU = new byte[][]{{0x00, 0x08, 0x00, 0x00, 0x00},
            {(byte) 0x80, 0x08, 0x00, 0x00, 0x00},
            {(byte) 0xA0, 0x08, 0x00, 0x00, 0x00},
            {(byte) 0x94, 0x08, 0x00, 0x00, 0x00},
            {0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00},
            {(byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00},
            {(byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00},
            {(byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00}
    };

    /* Case 2 APDU command expects the P2 received in the SELECT command as 1-byte outgoing data */
    private static final byte[] CHECK_SELECT_P2_APDU = new byte[] {
            0x00, (byte) 0xF4, 0x00, 0x00, 0x00
    };

    /* OMAPI APDU Test case 1 and 3 */
    private final static byte[][] SW_62xx_NO_DATA_APDU =
            new byte[][]{{0x00, (byte) 0xF3, 0x00, 0x06},
                    {0x00, (byte) 0xF3, 0x00, 0x0A, 0x01, (byte) 0xAA}
            };
    /* OMAPI APDU Test case 2 and 4 */
    private final static byte[] SW_62xx_DATA_APDU = new byte[]{0x00, (byte) 0xF3, 0x00, 0x08, 0x00};
    private final static byte[] SW_62xx_VALIDATE_DATA_APDU =
            new byte[]{0x00, (byte) 0xF3, 0x00, 0x0C, 0x01, (byte) 0xAA, 0x00};
    private final static byte[][] SW_62xx =
            new byte[][]{{0x62, 0x00}, {0x62, (byte) 0x81}, {0x62, (byte) 0x82},
                    {0x62, (byte) 0x83},
                    {0x62, (byte) 0x85}, {0x62, (byte) 0xF1}, {0x62, (byte) 0xF2},
                    {0x63, (byte) 0xF1},
                    {0x63, (byte) 0xF2}, {0x63, (byte) 0xC2}, {0x62, 0x02}, {0x62, (byte) 0x80},
                    {0x62, (byte) 0x84}, {0x62, (byte) 0x86}, {0x63, 0x00}, {0x63, (byte) 0x81}
            };
    private final static byte[][] SEGMENTED_RESP_APDU = new byte[][]{
            //Get response Case2 61FF+61XX with answer length (P1P2) of 0x0800, 2048 bytes
            {0x00, (byte) 0xC2, 0x08, 0x00, 0x00},
            //Get response Case4 61FF+61XX with answer length (P1P2) of 0x0800, 2048 bytes
            {0x00, (byte) 0xC4, 0x08, 0x00, 0x02, 0x12, 0x34, 0x00},
            //Get response Case2 6100+61XX with answer length (P1P2) of 0x0800, 2048 bytes
            {0x00, (byte) 0xC6, 0x08, 0x00, 0x00},
            //Get response Case4 6100+61XX with answer length (P1P2) of 0x0800, 2048 bytes
            {0x00, (byte) 0xC8, 0x08, 0x00, 0x02, 0x12, 0x34, 0x00},
            //Test device buffer capacity 7FFF data
            {0x00, (byte) 0xC2, (byte) 0x7F, (byte) 0xFF, 0x00},
            //Get response 6CFF+61XX with answer length (P1P2) of 0x0800, 2048 bytes
            {0x00, (byte) 0xCF, 0x08, 0x00, 0x00},
            //Get response with another CLA  with answer length (P1P2) of 0x0800, 2048 bytes
            {(byte) 0x94, (byte) 0xC2, 0x08, 0x00, 0x00}
    };
    private final long SERVICE_CONNECTION_TIME_OUT = 3000;
    private SEService seService;
    private Object serviceMutex = new Object();
    private Timer connectionTimer;
    private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();
    private boolean connected = false;
    private final OnConnectedListener mListener = new OnConnectedListener() {
                @Override
                public void onConnected() {
                    synchronized (serviceMutex) {
                        connected = true;
                        serviceMutex.notify();
                    }
                }
            };

    class SynchronousExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        boolean lowRamDevice = SystemProperties.getBoolean(""ro.config.low_ram"", false);
        return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")
                || hasSecureElementPackage(pm);
    }

    private boolean hasSecureElementPackage(PackageManager pm) {
        try {
            pm.getPackageInfo(""com.android.se"", 0 /* flags*/);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    private boolean supportUICCReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC);
    }

    private boolean supportESEReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE);
    }

    private boolean supportSDReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD);
    }

    private boolean supportOMAPIReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));
    }


    private void assertGreaterOrEqual(long greater, long lesser) {
        assertTrue("""" + greater + "" expected to be greater than or equal to "" + lesser,
                greater >= lesser);
    }

    @Before
    public void setUp() throws Exception {
        assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);
        assumeTrue(supportsHardware());
        seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);
        connectionTimer = new Timer();
        connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);
    }

    @After
    public void tearDown() throws Exception {
        if (seService != null && seService.isConnected()) {
            seService.shutdown();
            connected = false;
        }
    }

    private void waitForConnection() throws TimeoutException {
        synchronized (serviceMutex) {
            if (!connected) {
                try {
                    serviceMutex.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (!connected) {
                throw new TimeoutException(
                        ""Service could not be connected after "" + SERVICE_CONNECTION_TIME_OUT
                                + "" ms"");
            }
            if (connectionTimer != null) {
                connectionTimer.cancel();
            }
        }
    }

    /** Tests getReaders API */"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.cts.OmapiTest"	"testGetReaders"	"CtsOmapiTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"SD"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/omapi/src/android/omapi/cts/OmapiTest.java"	""	"public void testGetReaders() {
        try {
            waitForConnection();
            Reader[] readers = seService.getReaders();
            ArrayList<Reader> uiccReaders = new ArrayList<Reader>();
            ArrayList<Reader> eseReaders = new ArrayList<Reader>();
            ArrayList<Reader> sdReaders = new ArrayList<Reader>();

            for (Reader reader : readers) {
                assertTrue(reader.isSecureElementPresent());
                String name = reader.getName();
                if (!(name.startsWith(UICC_READER_PREFIX) || name.startsWith(ESE_READER_PREFIX)
                        || name.startsWith(SD_READER_PREFIX))) {
                    fail(""Incorrect Reader name"");
                }
                assertNotNull(""getseService returned null"", reader.getSEService());

                if (reader.getName().startsWith(UICC_READER_PREFIX)) {
                    uiccReaders.add(reader);
                }
                if (reader.getName().startsWith(ESE_READER_PREFIX)) {
                    eseReaders.add(reader);
                }
                if (reader.getName().startsWith(SD_READER_PREFIX)) {
                    sdReaders.add(reader);
                }
            }

            if (supportUICCReaders()) {
                assertGreaterOrEqual(uiccReaders.size(), 1);
                // Test API getUiccReader(int slotNumber)
                // The result should be the same as getReaders() with UICC reader prefix
                for (int i = 1; i <= uiccReaders.size(); i++) {
                    try {
                        Reader uiccReader = seService.getUiccReader(i);
                        if (!uiccReaders.contains(uiccReader))
                            fail(""Incorrect reader object - getUiccReader("" + i + "")"");
                    } catch (IllegalArgumentException e) {
                        fail(""Fail to get Reader object by calling getUiccReader("" + i + "")"");
                    }
                }
            } else {
                assertTrue(uiccReaders.size() == 0);
            }

            if (supportESEReaders()) {
                assertGreaterOrEqual(eseReaders.size(), 1);
            } else {
                assertTrue(eseReaders.size() == 0);
            }

            if (supportSDReaders()) {
                assertGreaterOrEqual(eseReaders.size(), 1);
            } else {
                assertTrue(sdReaders.size() == 0);
            }
        } catch (Exception e) {
            fail(""Unexpected Exception "" + e);
        }
    }

    /** Tests getATR API */"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.cts.OmapiTest"	"OnConnectedListener"	"CtsOmapiTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"UICC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/omapi/src/android/omapi/cts/OmapiTest.java"	""	"/*
 *.
 */

/* Contributed by Orange */

package android.omapi.cts;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.os.Build;
import android.os.SystemProperties;
import android.se.omapi.Channel;
import android.se.omapi.Reader;
import android.se.omapi.SEService;
import android.se.omapi.SEService.OnConnectedListener;
import android.se.omapi.Session;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeoutException;

public class OmapiTest {

    private final static String UICC_READER_PREFIX = ""SIM"";
    private final static String ESE_READER_PREFIX = ""eSE"";
    private final static String SD_READER_PREFIX = ""SD"";
    private final static byte[] SELECTABLE_AID =
            new byte[]{(byte) 0xA0, 0x00, 0x00, 0x04, 0x76, 0x41, 0x6E, 0x64,
                    0x72, 0x6F, 0x69, 0x64, 0x43, 0x54, 0x53, 0x31};
    private final static byte[] LONG_SELECT_RESPONSE_AID =
            new byte[]{(byte) 0xA0, 0x00, 0x00, 0x04, 0x76, 0x41, 0x6E, 0x64,
                    0x72, 0x6F, 0x69, 0x64, 0x43, 0x54, 0x53, 0x32};
    private final static byte[] NON_SELECTABLE_AID =
            new byte[]{(byte) 0xA0, 0x00, 0x00, 0x04, 0x76, 0x41, 0x6E, 0x64,
                    0x72, 0x6F, 0x69, 0x64, 0x43, 0x54, 0x53, (byte) 0xFF};

    /* MANAGE open/close and SELECT AID */
    private final static byte[][] ILLEGAL_COMMANDS_TRANSMIT = new byte[][]{{0x00, 0x70, 0x00, 0x00},
            {0x00, 0x70, (byte) 0x80, 0x00},
            {0x00, (byte) 0xA4, 0x04, 0x04, 0x10, 0x4A, 0x53,
                    0x52, 0x31, 0x37, 0x37, 0x54, 0x65, 0x73,
                    0x74, 0x65, 0x72, 0x20, 0x31, 0x2E, 0x30}
    };

    /* OMAPI APDU Test case 1 and 3 */
    private final static byte[][] NO_DATA_APDU = new byte[][]{{0x00, 0x06, 0x00, 0x00},
            {(byte) 0x80, 0x06, 0x00, 0x00},
            {(byte) 0xA0, 0x06, 0x00, 0x00},
            {(byte) 0x94, 0x06, 0x00, 0x00},
            {0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA},
            {(byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA},
            {(byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA},
            {(byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA}
    };
    /* OMAPI APDU Test case 2 and 4 */
    private final static byte[][] DATA_APDU = new byte[][]{{0x00, 0x08, 0x00, 0x00, 0x00},
            {(byte) 0x80, 0x08, 0x00, 0x00, 0x00},
            {(byte) 0xA0, 0x08, 0x00, 0x00, 0x00},
            {(byte) 0x94, 0x08, 0x00, 0x00, 0x00},
            {0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00},
            {(byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00},
            {(byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00},
            {(byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00}
    };

    /* Case 2 APDU command expects the P2 received in the SELECT command as 1-byte outgoing data */
    private static final byte[] CHECK_SELECT_P2_APDU = new byte[] {
            0x00, (byte) 0xF4, 0x00, 0x00, 0x00
    };

    /* OMAPI APDU Test case 1 and 3 */
    private final static byte[][] SW_62xx_NO_DATA_APDU =
            new byte[][]{{0x00, (byte) 0xF3, 0x00, 0x06},
                    {0x00, (byte) 0xF3, 0x00, 0x0A, 0x01, (byte) 0xAA}
            };
    /* OMAPI APDU Test case 2 and 4 */
    private final static byte[] SW_62xx_DATA_APDU = new byte[]{0x00, (byte) 0xF3, 0x00, 0x08, 0x00};
    private final static byte[] SW_62xx_VALIDATE_DATA_APDU =
            new byte[]{0x00, (byte) 0xF3, 0x00, 0x0C, 0x01, (byte) 0xAA, 0x00};
    private final static byte[][] SW_62xx =
            new byte[][]{{0x62, 0x00}, {0x62, (byte) 0x81}, {0x62, (byte) 0x82},
                    {0x62, (byte) 0x83},
                    {0x62, (byte) 0x85}, {0x62, (byte) 0xF1}, {0x62, (byte) 0xF2},
                    {0x63, (byte) 0xF1},
                    {0x63, (byte) 0xF2}, {0x63, (byte) 0xC2}, {0x62, 0x02}, {0x62, (byte) 0x80},
                    {0x62, (byte) 0x84}, {0x62, (byte) 0x86}, {0x63, 0x00}, {0x63, (byte) 0x81}
            };
    private final static byte[][] SEGMENTED_RESP_APDU = new byte[][]{
            //Get response Case2 61FF+61XX with answer length (P1P2) of 0x0800, 2048 bytes
            {0x00, (byte) 0xC2, 0x08, 0x00, 0x00},
            //Get response Case4 61FF+61XX with answer length (P1P2) of 0x0800, 2048 bytes
            {0x00, (byte) 0xC4, 0x08, 0x00, 0x02, 0x12, 0x34, 0x00},
            //Get response Case2 6100+61XX with answer length (P1P2) of 0x0800, 2048 bytes
            {0x00, (byte) 0xC6, 0x08, 0x00, 0x00},
            //Get response Case4 6100+61XX with answer length (P1P2) of 0x0800, 2048 bytes
            {0x00, (byte) 0xC8, 0x08, 0x00, 0x02, 0x12, 0x34, 0x00},
            //Test device buffer capacity 7FFF data
            {0x00, (byte) 0xC2, (byte) 0x7F, (byte) 0xFF, 0x00},
            //Get response 6CFF+61XX with answer length (P1P2) of 0x0800, 2048 bytes
            {0x00, (byte) 0xCF, 0x08, 0x00, 0x00},
            //Get response with another CLA  with answer length (P1P2) of 0x0800, 2048 bytes
            {(byte) 0x94, (byte) 0xC2, 0x08, 0x00, 0x00}
    };
    private final long SERVICE_CONNECTION_TIME_OUT = 3000;
    private SEService seService;
    private Object serviceMutex = new Object();
    private Timer connectionTimer;
    private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();
    private boolean connected = false;
    private final OnConnectedListener mListener = new OnConnectedListener() {
                @Override
                public void onConnected() {
                    synchronized (serviceMutex) {
                        connected = true;
                        serviceMutex.notify();
                    }
                }
            };

    class SynchronousExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        boolean lowRamDevice = SystemProperties.getBoolean(""ro.config.low_ram"", false);
        return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")
                || hasSecureElementPackage(pm);
    }

    private boolean hasSecureElementPackage(PackageManager pm) {
        try {
            pm.getPackageInfo(""com.android.se"", 0 /* flags*/);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    private boolean supportUICCReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC);
    }

    private boolean supportESEReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE);
    }

    private boolean supportSDReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD);
    }

    private boolean supportOMAPIReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));
    }


    private void assertGreaterOrEqual(long greater, long lesser) {
        assertTrue("""" + greater + "" expected to be greater than or equal to "" + lesser,
                greater >= lesser);
    }

    @Before
    public void setUp() throws Exception {
        assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);
        assumeTrue(supportsHardware());
        seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);
        connectionTimer = new Timer();
        connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);
    }

    @After
    public void tearDown() throws Exception {
        if (seService != null && seService.isConnected()) {
            seService.shutdown();
            connected = false;
        }
    }

    private void waitForConnection() throws TimeoutException {
        synchronized (serviceMutex) {
            if (!connected) {
                try {
                    serviceMutex.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (!connected) {
                throw new TimeoutException(
                        ""Service could not be connected after "" + SERVICE_CONNECTION_TIME_OUT
                                + "" ms"");
            }
            if (connectionTimer != null) {
                connectionTimer.cancel();
            }
        }
    }

    /** Tests getReaders API */"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.cts.OmapiTest"	"testGetReaders"	"CtsOmapiTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"UICC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/omapi/src/android/omapi/cts/OmapiTest.java"	""	"public void testGetReaders() {
        try {
            waitForConnection();
            Reader[] readers = seService.getReaders();
            ArrayList<Reader> uiccReaders = new ArrayList<Reader>();
            ArrayList<Reader> eseReaders = new ArrayList<Reader>();
            ArrayList<Reader> sdReaders = new ArrayList<Reader>();

            for (Reader reader : readers) {
                assertTrue(reader.isSecureElementPresent());
                String name = reader.getName();
                if (!(name.startsWith(UICC_READER_PREFIX) || name.startsWith(ESE_READER_PREFIX)
                        || name.startsWith(SD_READER_PREFIX))) {
                    fail(""Incorrect Reader name"");
                }
                assertNotNull(""getseService returned null"", reader.getSEService());

                if (reader.getName().startsWith(UICC_READER_PREFIX)) {
                    uiccReaders.add(reader);
                }
                if (reader.getName().startsWith(ESE_READER_PREFIX)) {
                    eseReaders.add(reader);
                }
                if (reader.getName().startsWith(SD_READER_PREFIX)) {
                    sdReaders.add(reader);
                }
            }

            if (supportUICCReaders()) {
                assertGreaterOrEqual(uiccReaders.size(), 1);
                // Test API getUiccReader(int slotNumber)
                // The result should be the same as getReaders() with UICC reader prefix
                for (int i = 1; i <= uiccReaders.size(); i++) {
                    try {
                        Reader uiccReader = seService.getUiccReader(i);
                        if (!uiccReaders.contains(uiccReader))
                            fail(""Incorrect reader object - getUiccReader("" + i + "")"");
                    } catch (IllegalArgumentException e) {
                        fail(""Fail to get Reader object by calling getUiccReader("" + i + "")"");
                    }
                }
            } else {
                assertTrue(uiccReaders.size() == 0);
            }

            if (supportESEReaders()) {
                assertGreaterOrEqual(eseReaders.size(), 1);
            } else {
                assertTrue(eseReaders.size() == 0);
            }

            if (supportSDReaders()) {
                assertGreaterOrEqual(eseReaders.size(), 1);
            } else {
                assertTrue(sdReaders.size() == 0);
            }
        } catch (Exception e) {
            fail(""Unexpected Exception "" + e);
        }
    }

    /** Tests getATR API */"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.cts.OmapiTest"	"testATR"	"CtsOmapiTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"UICC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/omapi/src/android/omapi/cts/OmapiTest.java"	""	"public void testATR() {
        assumeTrue(supportOMAPIReaders());
        try {
            waitForConnection();
            Reader[] readers = seService.getReaders();
            ArrayList<Reader> uiccReaders = new ArrayList<Reader>();
            if (readers != null && readers.length > 0) {
                for (int i = 0; i < readers.length; i++) {
                    if (readers[i].getName().startsWith(UICC_READER_PREFIX)) {
                        uiccReaders.add(readers[i]);
                    }
                }

                for (Reader reader : uiccReaders) {
                    Session session = null;
                    try {
                        session = reader.openSession();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    assertNotNull(""Could not open session"", session);
                    byte[] atr = session.getATR();
                    session.close();
                    assertNotNull(""ATR is Null"", atr);
                }
            }
        } catch (Exception e) {
            fail(""Unexpected Exception "" + e);
        }
    }

    /** Tests OpenBasicChannel API when aid is null */"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.cts.OmapiTest"	"testOpenBasicChannelNullAid"	"CtsOmapiTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"UICC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/omapi/src/android/omapi/cts/OmapiTest.java"	""	"public void testOpenBasicChannelNullAid() {
        assumeTrue(supportOMAPIReaders());
        try {
            waitForConnection();
            Reader[] readers = seService.getReaders();

            for (Reader reader : readers) {
                Session session = null;
                Channel channel = null;
                try {
                    session = reader.openSession();
                    assertNotNull(""Could not open session"", session);
                    channel = session.openBasicChannel(null, (byte) 0x00);
                } finally {
                    if (channel != null) channel.close();
                    if (session != null) session.close();
                }
                if (reader.getName().startsWith(UICC_READER_PREFIX)) {
                    assertNull(""Basic channel on UICC can be opened"", channel);
                } else {
                    assertNotNull(""Basic Channel cannot be opened"", channel);
                }
            }
        } catch (Exception e) {
            fail(""Unexpected Exception "" + e);
        }
    }

    /** Tests OpenBasicChannel API when aid is provided */"	""	""	""	""	""
"207:635317) 7.4.8  . Secure Elements"	"7.4.8"	"C-1-2"	""	"android.omapi.cts.OmapiTest"	"testOpenBasicChannelNonNullAid"	"CtsOmapiTestCases"	""	"7.4.8/C-1-2"	"""C-1-2] MUST declare the correct feature flags via android.hardware.se.omapi.uicc for the device with UICC-based secure elements, android.hardware.se.omapi.ese for the device with eSE-based secure elements and android.hardware.se.omapi.sd for the device with SD-based secure elements. <h3 id="""	""	"SD android.hardware.se.omapi.sd android.hardware.se.omapi.ese android.hardware.se.omapi.uicc UICC re_tag:SD&UICC"	""	""	""	"UICC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/secure_element/omapi/src/android/omapi/cts/OmapiTest.java"	""	"public void testOpenBasicChannelNonNullAid() {
        assumeTrue(supportOMAPIReaders());
        try {
            waitForConnection();
            Reader[] readers = seService.getReaders();

            for (Reader reader : readers) {
                Session session = null;
                Channel channel = null;
                try {
                    session = reader.openSession();
                    assertNotNull(""Could not open session"", session);
                    channel = session.openBasicChannel(SELECTABLE_AID, (byte) 0x00);
                } finally {
                    if (channel != null) channel.close();
                    if (session != null) session.close();
                }
                if (reader.getName().startsWith(UICC_READER_PREFIX)) {
                    assertNull(""Basic channel on UICC can be opened"", channel);
                } else {
                    assertNotNull(""Basic Channel cannot be opened"", channel);
                }
            }
        } catch (Exception e) {
            fail(""Unexpected Exception "" + e);
        }
    }

    /** Tests Select API */"	""	""	""	""	""
