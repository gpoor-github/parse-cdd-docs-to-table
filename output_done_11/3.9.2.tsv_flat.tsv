"Section"	"section_id"	"req_id"	"Test Availability"	"class_def"	"method"	"module"	"method_text"	"full_key"	"requirement"	"key_as_number"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"matched_terms"	"search_roots"	"qualified_method"	"max_matches"	"file_name"	"matched_files"	"methods_string"	"urls"	"protected"	"Area"	"Shortened"	"Test Level"
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.jdwptunnel.cts.JdwpTunnelTest"	"startupTest"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/jdwptunnel/src/android/jdwptunnel/cts/JdwpTunnelTest.java"	""	"/*  *.  */  package android.jdwptunnel.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import com.android.tradefed.device.DeviceNotAvailableException; import com.android.tradefed.device.ITestDevice; import com.android.tradefed.testtype.DeviceJUnit4ClassRunner; import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;  import com.sun.jdi.Bootstrap; import com.sun.jdi.ReferenceType; import com.sun.jdi.VirtualMachine; import com.sun.jdi.VirtualMachineManager; import com.sun.jdi.connect.AttachingConnector; import com.sun.jdi.connect.Connector; import com.sun.jdi.event.ClassPrepareEvent; import com.sun.jdi.request.BreakpointRequest; import com.sun.jdi.request.ClassPrepareRequest; import com.sun.jdi.request.EventRequest; import com.sun.jdi.request.EventRequestManager;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.time.Instant; import java.util.Map;  /**  * Host-side tests for setting up a JDWP connection to an app.  *  * <p>This test ensures that it is possible to attach a debugger to an app using 'adb' and perform  * at least some basic debugging actions.  *  * <p>The {@link SampleDeviceActivity} is the activity we are debugging.  *  * <p>We will start that activity with 'wait-for-debugger', set a breakpoint on the first line of  * the {@code onCreate} method and wait for the breakpoint to be hit.  *  * <p>Run with: atest CtsJdwpTunnelHostTestCases  */ @RunWith(DeviceJUnit4ClassRunner.class) public class JdwpTunnelTest extends BaseHostJUnit4Test {     private static final String TEST_APP_PACKAGE_NAME = ""android.jdwptunnel.sampleapp"";     private static final String TEST_APP_ACTIVITY_CLASS_NAME = ""SampleDeviceActivity"";     private final static String TEST_APP_FULL_CLASS_NAME =             TEST_APP_PACKAGE_NAME + ""."" + TEST_APP_ACTIVITY_CLASS_NAME;      private ITestDevice mDevice;      @Before     public void setUp() throws Exception {         installPackage(""CtsJdwpTunnelSampleApp.apk"");         mDevice = getDevice();     }      private void moveToHomeScreen() throws Exception {         // Wakeup the device if it is on the lockscreen and move it to the home screen.         mDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");         mDevice.executeShellCommand(""wm dismiss-keyguard"");         mDevice.executeShellCommand(""input keyevent KEYCODE_HOME"");     }      private VirtualMachine getDebuggerConnection(String port) throws Exception {         VirtualMachineManager vmm = Bootstrap.virtualMachineManager();         AttachingConnector conn =                 vmm.attachingConnectors().stream()                         .filter((x) -> x.transport().name().equals(""dt_socket""))                         .findFirst()                         .orElseThrow(                                 () -> new Error(""Could not find dt_socket connector!""));         Map<String, Connector.Argument> params = conn.defaultArguments();         params.get(""port"").setValue(port);         params.get(""hostname"").setValue(""localhost"");         // Timeout after 1 minute         params.get(""timeout"").setValue(""60000"");         return conn.attach(params);     }      private String forwardJdwp(String pid) throws Exception {         // Try to have adb figure out the port number.         String result = mDevice.executeAdbCommand(""forward"", ""tcp:0"", ""jdwp:"" + pid);         if (result != null) {             return result.trim();         }         // We might be using an ancient adb. Try using a static port number instead. Number chosen         // arbitrarially. '15002' does not appear in any file as anything resembling a port number         // as far as I can tell.         final String port = ""15002"";         result = mDevice.executeAdbCommand(""forward"", ""tcp:"" + port, ""jdwp:"" + pid);         assertTrue(result != null);         return port;     }      private VirtualMachine startupTest() throws Exception {         moveToHomeScreen();         mDevice.executeShellCommand(""cmd activity start-activity -D -W -n "" +                 TEST_APP_PACKAGE_NAME + ""/."" + TEST_APP_ACTIVITY_CLASS_NAME);         // Don't keep trying after a minute.         final Instant deadline = Instant.now().plusSeconds(60);         String pid = """";         while ((pid = mDevice.executeShellCommand(                     ""pidof "" + TEST_APP_PACKAGE_NAME).trim()).equals("""")) {             if (Instant.now().isAfter(deadline)) {                 fail(""Unable to find PID of "" + TEST_APP_PACKAGE_NAME + "" process!"");             }             // Wait 1 second and try again.             Thread.sleep(1000);         }         String port = forwardJdwp(pid);         assertTrue(!"""".equals(port));         return getDebuggerConnection(port);     }      /**      * Tests that we can attach a debugger and perform basic debugging functions.      *      * We start the app with Wait-for-debugger. Wait for the ClassPrepare of the activity class and      * put and wait for a breakpoint on the onCreate function.      *      * TODO: We should expand this to more functions.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.inputmethodservice.cts.devicetest.InputMethodServiceDeviceTest"	"testImeVisibilityAfterImeSwitching"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/inputmethodservice/deviceside/devicetest/src/android/inputmethodservice/cts/devicetest/InputMethodServiceDeviceTest.java"	""	"public void testImeVisibilityAfterImeSwitching() throws Throwable {         final TestHelper helper = new TestHelper();          helper.launchActivity(EditTextAppConstants.PACKAGE, EditTextAppConstants.CLASS,                 EditTextAppConstants.URI);          helper.findUiObject(EditTextAppConstants.EDIT_TEXT_RES_NAME).click();          InputMethodVisibilityVerifier.assertIme1Visible(TIMEOUT);          // Switch IME from CtsInputMethod1 to CtsInputMethod2.         helper.shell(ShellCommandUtils.broadcastIntent(                 ACTION_IME_COMMAND, Ime1Constants.PACKAGE,                 ""-e"", EXTRA_COMMAND, COMMAND_SWITCH_INPUT_METHOD,                 ""-e"", EXTRA_ARG_STRING1, Ime2Constants.IME_ID));          InputMethodVisibilityVerifier.assertIme2Visible(TIMEOUT);          // Switch IME from CtsInputMethod2 to CtsInputMethod1.         helper.shell(ShellCommandUtils.broadcastIntent(                 ACTION_IME_COMMAND, Ime2Constants.PACKAGE,                 ""-e"", EXTRA_COMMAND, COMMAND_SWITCH_INPUT_METHOD,                 ""-e"", EXTRA_ARG_STRING1, Ime1Constants.IME_ID));          InputMethodVisibilityVerifier.assertIme1Visible(TIMEOUT);          // Switch IME from CtsInputMethod1 to CtsInputMethod2.         helper.shell(ShellCommandUtils.broadcastIntent(                 ACTION_IME_COMMAND, Ime1Constants.PACKAGE,                 ""-e"", EXTRA_COMMAND, COMMAND_SWITCH_INPUT_METHOD,                 ""-e"", EXTRA_ARG_STRING1, Ime2Constants.IME_ID));          InputMethodVisibilityVerifier.assertIme2Visible(TIMEOUT);          if (helper.shell(""pm list features"").contains(FEATURE_WATCH)) {             // Skip if running on Wear devices because those devices will go through an activity             // change during screen off/on cycle due to Ambient mode. Activity change will cause             // EditText to retain focus but not show IME.             // We also do not use ""assumeFalse"" because this test is executed as part of             // host-side tests, and throwing AssumptionViolatedException would not give us             // better understanding about what is happening.             // TODO(b/188662291): Remove this while introducing a dedicated test for b/b/160391516.             return;         }          // Make sure the IME switch UI still works after device screen off / on with focusing         // same Editor.         turnScreenOff(helper);         turnScreenOn(helper);         helper.shell(ShellCommandUtils.unlockScreen());         assertTrue(helper.findUiObject(EditTextAppConstants.EDIT_TEXT_RES_NAME).isFocused());          // Switch IME from CtsInputMethod2 to CtsInputMethod1.         showInputMethodPicker(helper);         helper.shell(ShellCommandUtils.broadcastIntent(                 ACTION_IME_COMMAND, Ime2Constants.PACKAGE,                 ""-e"", EXTRA_COMMAND, COMMAND_SWITCH_INPUT_METHOD,                 ""-e"", EXTRA_ARG_STRING1, Ime1Constants.IME_ID));          InputMethodVisibilityVerifier.assertIme1Visible(TIMEOUT);          // Switch IME from CtsInputMethod1 to CtsInputMethod2.         showInputMethodPicker(helper);         helper.shell(ShellCommandUtils.broadcastIntent(                 ACTION_IME_COMMAND, Ime1Constants.PACKAGE,                 ""-e"", EXTRA_COMMAND, COMMAND_SWITCH_INPUT_METHOD,                 ""-e"", EXTRA_ARG_STRING1, Ime2Constants.IME_ID));          InputMethodVisibilityVerifier.assertIme2Visible(TIMEOUT);     }      /**      * Build stream collector of {@link DeviceEvent} collecting sequence that elements have      * specified types.      *      * @param types {@link DeviceEventType}s that elements of sequence should have.      * @return {@link java.util.stream.Collector} that corrects the sequence.      */     private static Collector<DeviceEvent, ?, MatchResult<DeviceEvent>> sequenceOfTypes(             final DeviceEventType... types) {         final IntFunction<Predicate<DeviceEvent>[]> arraySupplier = Predicate[]::new;         return SequenceMatcher.of(Arrays.stream(types)                 .map(DeviceEvent::isType)                 .toArray(arraySupplier));     }      /**      * Call a command to turn screen On.      *      * This method will wait until the power state is interactive with {@link      * PowerManager#isInteractive()}.      */     private static void turnScreenOn(TestHelper helper) throws Exception {         final Context context = InstrumentationRegistry.getInstrumentation().getContext();         final PowerManager pm = context.getSystemService(PowerManager.class);         helper.shell(ShellCommandUtils.wakeUp());         pollingCheck(() -> pm != null && pm.isInteractive(), TIMEOUT,                 ""Device does not wake up within the timeout period"");     }      /**      * Call a command to turn screen off.      *      * This method will wait until the power state is *NOT* interactive with      * {@link PowerManager#isInteractive()}.      * Note that {@link PowerManager#isInteractive()} may not return {@code true} when the device      * enables Aod mode, recommend to add (@link DisableScreenDozeRule} in the test to disable Aod      * for making power state reliable.      */     private static void turnScreenOff(TestHelper helper) throws Exception {         final Context context = InstrumentationRegistry.getInstrumentation().getContext();         final PowerManager pm = context.getSystemService(PowerManager.class);         helper.shell(ShellCommandUtils.sleepDevice());         pollingCheck(() -> pm != null && !pm.isInteractive(), TIMEOUT,                 ""Device does not sleep within the timeout period"");     }      private static void showInputMethodPicker(TestHelper helper) throws Exception {         // Test InputMethodManager#showInputMethodPicker() works as expected.         final Context context = InstrumentationRegistry.getInstrumentation().getContext();         final InputMethodManager imm = context.getSystemService(InputMethodManager.class);         helper.shell(ShellCommandUtils.showImePicker());         pollingCheck(() -> imm.isInputMethodPickerShown(), TIMEOUT,                 ""InputMethod picker should be shown"");     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.view.inputmethod.cts.NavigationBarColorTest"	"getSystemUiVisibility"	"CtsInputMethodTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/NavigationBarColorTest.java"	""	"/*  *.  */  package android.view.inputmethod.cts;  import static android.view.View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR; import static android.view.WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM; import static android.view.WindowManager.LayoutParams.FLAG_DIM_BEHIND; import static android.view.WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS; import static android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; import static android.view.inputmethod.cts.util.LightNavigationBarVerifier.expectLightNavigationBarNotSupported; import static android.view.inputmethod.cts.util.LightNavigationBarVerifier.expectLightNavigationBarSupported; import static android.view.inputmethod.cts.util.NavigationBarColorVerifier.expectNavigationBarColorNotSupported; import static android.view.inputmethod.cts.util.NavigationBarColorVerifier.expectNavigationBarColorSupported; import static android.view.inputmethod.cts.util.TestUtils.getOnMainSync;  import static com.android.cts.mockime.ImeEventStreamTestUtils.expectBindInput; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEvent; import static com.android.cts.mockime.ImeEventStreamTestUtils.waitForInputViewLayoutStable;  import static org.junit.Assert.assertNotNull; import static org.junit.Assume.assumeTrue;  import android.app.Activity; import android.app.AlertDialog; import android.app.UiAutomation; import android.graphics.Bitmap; import android.graphics.Color; import android.os.Process; import android.text.TextUtils; import android.view.View; import android.view.ViewGroup; import android.view.inputmethod.EditorInfo; import android.view.inputmethod.cts.util.EndToEndImeTestBase; import android.view.inputmethod.cts.util.NavigationBarInfo; import android.view.inputmethod.cts.util.TestActivity; import android.view.inputmethod.cts.util.UnlockScreenRule; import android.widget.LinearLayout; import android.widget.TextView;  import androidx.annotation.ColorInt; import androidx.annotation.NonNull; import androidx.test.filters.FlakyTest; import androidx.test.filters.MediumTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.ImeAwareEditText; import com.android.cts.mockime.ImeEventStream; import com.android.cts.mockime.ImeLayoutInfo; import com.android.cts.mockime.ImeSettings; import com.android.cts.mockime.MockImeSession;  import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.concurrent.TimeUnit;  @MediumTest @RunWith(AndroidJUnit4.class) public class NavigationBarColorTest extends EndToEndImeTestBase {     private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);     private static final long LAYOUT_STABLE_THRESHOLD = TimeUnit.SECONDS.toMillis(3);      private static final String TEST_MARKER = ""android.view.inputmethod.cts.NavigationBarColorTest"";      @Rule     public final UnlockScreenRule mUnlockScreenRule = new UnlockScreenRule();      private static void updateSystemUiVisibility(@NonNull View view, int flags, int mask) {         final int currentFlags = view.getSystemUiVisibility();         final int newFlags = (currentFlags & ~mask) | (flags & mask);         if (currentFlags != newFlags) {             view.setSystemUiVisibility(newFlags);         }     }      @BeforeClass     public static void initializeNavigationBarInfo() throws Exception {         // Make sure that NavigationBarInfo is initialized before         // EndToEndImeTestBase#showStateInitializeActivity().         NavigationBarInfo.getInstance();     }      // TODO(b/37502066): Merge this back to initializeNavigationBarInfo() once b/37502066 is fixed.     @Before     public void checkNavigationBar() throws Exception {         assumeTrue(""This test does not make sense if there is no navigation bar"",                 NavigationBarInfo.getInstance().hasBottomNavigationBar());          assumeTrue(""This test does not make sense if custom navigation bar color is not supported""                         + "" even for typical Activity"",                 NavigationBarInfo.getInstance().supportsNavigationBarColor());     }      /**      * Represents test scenarios regarding how a {@link android.view.Window} that has      * {@link android.view.WindowManager.LayoutParams#FLAG_DIM_BEHIND} interacts with a different      * {@link android.view.Window} that has      * {@link android.view.View#SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR}.      */     private enum DimmingTestMode {         /**          * No {@link AlertDialog} is shown when testing.          */         NO_DIMMING_DIALOG,         /**          * An {@link AlertDialog} that has dimming effect is shown above the IME window.          */         DIMMING_DIALOG_ABOVE_IME,         /**          * An {@link AlertDialog} that has dimming effect is shown behind the IME window.          */         DIMMING_DIALOG_BEHIND_IME,     }      @NonNull     public TestActivity launchTestActivity(@ColorInt int navigationBarColor,             boolean lightNavigationBar, @NonNull DimmingTestMode dimmingTestMode) {         return TestActivity.startSync(activity -> {             final View contentView;             switch (dimmingTestMode) {                 case NO_DIMMING_DIALOG:                 case DIMMING_DIALOG_ABOVE_IME: {                     final LinearLayout layout = new LinearLayout(activity);                     layout.setOrientation(LinearLayout.VERTICAL);                     final ImeAwareEditText editText = new ImeAwareEditText(activity);                     editText.setPrivateImeOptions(TEST_MARKER);                     editText.setHint(""editText"");                     editText.requestFocus();                     editText.scheduleShowSoftInput();                     layout.addView(editText);                     contentView = layout;                     break;                 }                 case DIMMING_DIALOG_BEHIND_IME: {                     final View view = new View(activity);                     view.setLayoutParams(new ViewGroup.LayoutParams(                             ViewGroup.LayoutParams.MATCH_PARENT,                             ViewGroup.LayoutParams.MATCH_PARENT));                     contentView = view;                     break;                 }                 default:                     throw new IllegalStateException(""unknown mode="" + dimmingTestMode);             }             activity.getWindow().setNavigationBarColor(navigationBarColor);             updateSystemUiVisibility(contentView,                     lightNavigationBar ? SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR : 0,                     SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR);             return contentView;         });     }      private AutoCloseable showDialogIfNecessary(             @NonNull Activity activity, @NonNull DimmingTestMode dimmingTestMode) {         switch (dimmingTestMode) {             case NO_DIMMING_DIALOG:                 // Dialog is not necessary.                 return () -> { };             case DIMMING_DIALOG_ABOVE_IME: {                 final AlertDialog alertDialog = getOnMainSync(() -> {                     final TextView textView = new TextView(activity);                     textView.setText(""Dummy"");                     textView.requestFocus();                     final AlertDialog dialog = new AlertDialog.Builder(activity)                             .setView(textView)                             .create();                     dialog.getWindow().setFlags(FLAG_DIM_BEHIND | FLAG_ALT_FOCUSABLE_IM,                             FLAG_DIM_BEHIND | FLAG_NOT_FOCUSABLE | FLAG_ALT_FOCUSABLE_IM);                     dialog.show();                     return dialog;                 });                 // Note: Dialog#dismiss() is a thread safe method so we don't need to call this from                 // the UI thread.                 return () -> alertDialog.dismiss();             }             case DIMMING_DIALOG_BEHIND_IME: {                 final AlertDialog alertDialog = getOnMainSync(() -> {                     final ImeAwareEditText editText = new ImeAwareEditText(activity);                     editText.setPrivateImeOptions(TEST_MARKER);                     editText.setHint(""editText"");                     editText.requestFocus();                     editText.scheduleShowSoftInput();                     final AlertDialog dialog = new AlertDialog.Builder(activity)                             .setView(editText)                             .create();                     dialog.getWindow().setFlags(FLAG_DIM_BEHIND,                             FLAG_DIM_BEHIND | FLAG_NOT_FOCUSABLE | FLAG_ALT_FOCUSABLE_IM);                     dialog.show();                     return dialog;                 });                 // Note: Dialog#dismiss() is a thread safe method so we don't need to call this from                 // the UI thread.                 return () -> alertDialog.dismiss();             }             default:                 throw new IllegalStateException(""unknown mode="" + dimmingTestMode);         }     }      @NonNull     private ImeSettings.Builder imeSettingForSolidNavigationBar(@ColorInt int navigationBarColor,             boolean lightNavigationBar) {         final ImeSettings.Builder builder = new ImeSettings.Builder();         builder.setNavigationBarColor(navigationBarColor);         if (lightNavigationBar) {             builder.setInputViewSystemUiVisibility(SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR);         }         return builder;     }      @NonNull     private ImeSettings.Builder imeSettingForFloatingIme(@ColorInt int navigationBarColor,             boolean lightNavigationBar) {         final ImeSettings.Builder builder = new ImeSettings.Builder();         builder.setWindowFlags(0, FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);         // As documented, Window#setNavigationBarColor() is actually ignored when the IME window         // does not have FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS.  We are calling setNavigationBarColor()         // to ensure it.         builder.setNavigationBarColor(navigationBarColor);         if (lightNavigationBar) {             // As documented, SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR is actually ignored when the IME             // window does not have FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS.  We set this flag just to             // ensure it.             builder.setInputViewSystemUiVisibility(SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR);         }         return builder;     }      @NonNull     private Bitmap getNavigationBarBitmap(@NonNull ImeSettings.Builder builder,             @ColorInt int appNavigationBarColor, boolean appLightNavigationBar,             int navigationBarHeight, @NonNull DimmingTestMode dimmingTestMode)             throws Exception {         final UiAutomation uiAutomation =                 InstrumentationRegistry.getInstrumentation().getUiAutomation();         try (MockImeSession imeSession = MockImeSession.create(                 InstrumentationRegistry.getInstrumentation().getContext(), uiAutomation, builder)) {             final ImeEventStream stream = imeSession.openEventStream();              final TestActivity activity = launchTestActivity(                     appNavigationBarColor, appLightNavigationBar, dimmingTestMode);              // Show AlertDialog if necessary, based on the dimming test mode.             try (AutoCloseable dialogCloser = showDialogIfNecessary(                     activity, dimmingTestMode)) {                 // Wait until the MockIme gets bound to the TestActivity.                 expectBindInput(stream, Process.myPid(), TIMEOUT);                  // Wait until ""onStartInput"" gets called for the EditText.                 expectEvent(stream, event -> {                     if (!TextUtils.equals(""onStartInputView"", event.getEventName())) {                         return false;                     }                     final EditorInfo editorInfo = event.getArguments().getParcelable(""editorInfo"");                     return TextUtils.equals(TEST_MARKER, editorInfo.privateImeOptions);                 }, TIMEOUT);                  // Wait until MockIme's layout becomes stable.                 final ImeLayoutInfo lastLayout =                         waitForInputViewLayoutStable(stream, LAYOUT_STABLE_THRESHOLD);                 assertNotNull(lastLayout);                  final Bitmap bitmap = uiAutomation.takeScreenshot();                 return Bitmap.createBitmap(bitmap, 0, bitmap.getHeight() - navigationBarHeight,                         bitmap.getWidth(), navigationBarHeight);             }         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.telephony.embms.cts.MbmsDownloadCallbackTest"	"testFullCallback"	"CtsTelephonyTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/embms/cts/MbmsDownloadCallbackTest.java"	""	"public void testFullCallback() throws Exception {         int sampleInt = 10;         TestDSCallback statusCallback = new TestDSCallback();         TestDPCallback progressCallback = new TestDPCallback();         DownloadRequest request = downloadRequestTemplate.build();         mDownloadSession.addStatusListener(request, mCallbackExecutor, statusCallback);         mDownloadSession.addProgressListener(request, mCallbackExecutor, progressCallback);         mMiddlewareControl.fireOnProgressUpdated(request, CtsDownloadService.FILE_INFO_1,                 sampleInt, sampleInt, sampleInt, sampleInt);         SomeArgs progressArgs = progressCallback.waitOnProgressUpdated(ASYNC_TIMEOUT);         assertEquals(request, progressArgs.arg1);         assertEquals(CtsDownloadService.FILE_INFO_1, progressArgs.arg2);         assertEquals(sampleInt, progressArgs.arg3);         assertEquals(sampleInt, progressArgs.arg4);         assertEquals(sampleInt, progressArgs.arg5);         assertEquals(sampleInt, progressArgs.arg6);          mMiddlewareControl.fireOnStateUpdated(request, CtsDownloadService.FILE_INFO_1, sampleInt);         SomeArgs stateArgs = statusCallback.waitOnStatusUpdated(ASYNC_TIMEOUT);         assertEquals(request, stateArgs.arg1);         assertEquals(CtsDownloadService.FILE_INFO_1, stateArgs.arg2);         assertEquals(sampleInt, stateArgs.arg3);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.telephony.embms.cts.MbmsDownloadCallbackTest"	"testDeregistration"	"CtsTelephonyTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/embms/cts/MbmsDownloadCallbackTest.java"	""	"public void testDeregistration() throws Exception {         TestDSCallback statusCallback = new TestDSCallback();         TestDPCallback progressCallback = new TestDPCallback();         DownloadRequest request = downloadRequestTemplate.build();         mDownloadSession.addProgressListener(request, mCallbackExecutor, progressCallback);         mDownloadSession.addStatusListener(request, mCallbackExecutor, statusCallback);         mDownloadSession.removeProgressListener(request, progressCallback);         mDownloadSession.removeStatusListener(request, statusCallback);          mMiddlewareControl.fireOnStateUpdated(null, null, 0);         assertNull(statusCallback.waitOnStatusUpdated(SHORT_TIMEOUT));         mMiddlewareControl.fireOnProgressUpdated(null, null, 0, 0, 0, 0);         assertNull(progressCallback.waitOnProgressUpdated(SHORT_TIMEOUT));     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.permission.cts.FileSystemPermissionTest"	"testAllOtherDirectoriesNotWritable"	"CtsPermissionTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	"public void testAllOtherDirectoriesNotWritable() throws Exception {         File start = new File(""/"");         Set<File> writableDirs = getWritableDirectoriesAndSubdirectoriesOf(start);          assertTrue(""Found writable directories: "" + writableDirs.toString(),                 writableDirs.isEmpty());     }      private static final Set<String> OTHER_RANDOM_DIRECTORIES = new HashSet<String>(             Arrays.asList(                     ""/app-cache"",                     ""/app-cache/ciq/socket"",                     ""/cache/fotapkg"",                     ""/cache/fotapkg/tmp"",                     ""/data/_SamsungBnR_"",                     ""/data/_SamsungBnR_/BR"",                     ""/data/2nd-init"",                     ""/data/amit"",                     ""/data/anr"",                     ""/data/app"",                     ""/data/app-private"",                     ""/data/backup"",                     ""/data/battd"",                     ""/data/bootlogo"",                     ""/data/btips"",                     ""/data/btips/TI"",                     ""/data/btips/TI/opp"",                     ""/data/cache"",                     ""/data/calibration"",                     ""/data/clipboard"",                     ""/data/clp"",                     ""/data/dalvik-cache"",                     ""/data/data"",                     ""/data/data/.drm"",                     ""/data/data/.drm/.wmdrm"",                     ""/data/data/cw"",                     ""/data/data/com.android.htcprofile"",                     ""/data/data/com.android.providers.drm/rights"",                     ""/data/data/com.htc.android.qxdm2sd"",                     ""/data/data/com.htc.android.qxdm2sd/bin"",                     ""/data/data/com.htc.android.qxdm2sd/data"",                     ""/data/data/com.htc.android.qxdm2sd/tmp"",                     ""/data/data/com.htc.android.netlogger/data"",                     ""/data/data/com.htc.messagecs/att"",                     ""/data/data/com.htc.messagecs/pdu"",                     ""/data/data/com.htc.loggers/bin"",                     ""/data/data/com.htc.loggers/data"",                     ""/data/data/com.htc.loggers/htclog"",                     ""/data/data/com.htc.loggers/tmp"",                     ""/data/data/com.htc.loggers/htcghost"",                     ""/data/data/com.lge.ers/android"",                     ""/data/data/com.lge.ers/arm9"",                     ""/data/data/com.lge.ers/kernel"",                     ""/data/data/com.lge.wmc"",                     ""/data/data/com.redbend.vdmc/lib"",                     ""/data/data/recovery"",                     ""/data/data/recovery/HTCFOTA"",                     ""/data/data/recovery/OMADM"",                     ""/data/data/shared"",                     ""/data/diag_logs"",                     ""/data/dontpanic"",                     ""/data/drm"",                     ""/data/drm/fwdlock"",                     ""/data/drm/IDM"",                     ""/data/drm/IDM/HTTP"",                     ""/data/drm/rights"",                     ""/data/dump"",                     ""/data/efslog"",                     ""/data/emt"",                     ""/data/factory"",                     ""/data/fics"",                     ""/data/fics/dev"",                     ""/data/fota"",                     ""/data/gps"",                     ""/data/gps/log"",                     ""/data/gps/var"",                     ""/data/gps/var/run"",                     ""/data/gpscfg"",                     ""/data/hwvefs"",                     ""/data/htcfs"",                     ""/data/img"",                     ""/data/install"",                     ""/data/internal-device"",                     ""/data/internal-device/DCIM"",                     ""/data/last_alog"",                     ""/data/last_klog"",                     ""/data/local"",                     ""/data/local/logs"",                     ""/data/local/logs/kernel"",                     ""/data/local/logs/logcat"",                     ""/data/local/logs/resetlog"",                     ""/data/local/logs/smem"",                     ""/data/local/mono"",                     ""/data/local/mono/pulse"",                     ""/data/local/purple"",                     ""/data/local/purple/sound"",                     ""/data/local/rights"",                     ""/data/local/rwsystag"",                     ""/data/local/skel"",                     ""/data/local/skel/default"",                     ""/data/local/skel/defualt"", // Mispelled ""defualt"" is intentional                     ""/data/local/tmp"",                     ""/data/local/tmp/com.nuance.android.vsuite.vsuiteapp"",                     ""/data/log"",                     ""/data/logger"",                     ""/data/logs"",                     ""/data/logs/core"",                     ""/data/lost+found"",                     ""/data/mdl"",                     ""/data/misc"",                     ""/data/misc/bluetooth"",                     ""/data/misc/bluetooth/logs"",                     ""/data/misc/dhcp"",                     ""/data/misc/lockscreen"",                     ""/data/misc/sensor"",                     ""/data/misc/webwidgets"",                     ""/data/misc/webwidgets/chess"",                     ""/data/misc/widgets"",                     ""/data/misc/wifi"",                     ""/data/misc/wifi/sockets"",                     ""/data/misc/wimax"",                     ""/data/misc/wimax/sockets"",                     ""/data/misc/wminput"",                     ""/data/misc/wpa_supplicant"",                     ""/data/nv"",                     ""/data/nvcam"",                     ""/data/panic"",                     ""/data/panicreports"",                     ""/data/preinstall_md5"",                     ""/data/property"",                     ""/data/radio"",                     ""/data/secure"",                     ""/data/security"",                     ""/data/sensors"",                     ""/data/shared"",                     ""/data/simcom"",                     ""/data/simcom/btadd"",                     ""/data/simcom/simlog"",                     ""/data/system"",                     ""/data/tmp"",                     ""/data/tombstones"",                     ""/data/tombstones/ramdump"",                     ""/data/tpapi"",                     ""/data/tpapi/etc"",                     ""/data/tpapi/etc/tpa"",                     ""/data/tpapi/etc/tpa/persistent"",                     ""/data/tpapi/user.bin"",                     ""/data/vpnch"",                     ""/data/wapi"",                     ""/data/wifi"",                     ""/data/wimax"",                     ""/data/wimax/log"",                     ""/data/wiper"",                     ""/data/wpstiles"",                     ""/data/xt9"",                     ""/dbdata/databases"",                     ""/efs/.android"",                     ""/mnt/sdcard"",                     ""/mnt/usbdrive"",                     ""/mnt_ext"",                     ""/mnt_ext/badablk2"",                     ""/mnt_ext/badablk3"",                     ""/mnt_ext/cache"",                     ""/mnt_ext/data"",                     ""/system/etc/security/drm"",                     ""/synthesis/hades"",                     ""/synthesis/chimaira"",                     ""/synthesis/shdisp"",                     ""/synthesis/hdmi"",                     ""/tmp""             )     );      /**      * Verify that directories not discoverable by      * testAllOtherDirectoriesNotWritable are not writable.  An application      * should only be able to write to it's own home directory. World      * writable directories are a security hole because they enable a      * number of different attacks.      * <ul>      *   <li><a href=""http://en.wikipedia.org/wiki/Symlink_race"">Symlink Races</a></li>      *   <li>Data destruction by deleting or renaming files you don't own</li>      *   <li>Data substitution by replacing trusted files with untrusted files</li>      * </ul>      *      * Because /data and /data/data are not readable, we blindly try to      * poke around in there looking for bad directories.  There has to be      * a better way...      */     @LargeTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.app.cts.NotificationManagerTest"	"testCreateChannel"	"CtsAndroidAppTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	"public void testCreateChannel() throws Exception {         final NotificationChannel channel =                 new NotificationChannel(mId, ""name"", IMPORTANCE_DEFAULT);         channel.setDescription(""bananas"");         channel.enableVibration(true);         channel.setVibrationPattern(new long[] {5, 8, 2, 1});         channel.setSound(new Uri.Builder().scheme(""test"").build(),                 new AudioAttributes.Builder().setUsage(                         AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_DELAYED).build());         channel.enableLights(true);         channel.setBypassDnd(true);         channel.setLockscreenVisibility(Notification.VISIBILITY_SECRET);         mNotificationManager.createNotificationChannel(channel);         final NotificationChannel createdChannel =                 mNotificationManager.getNotificationChannel(mId);         compareChannels(channel, createdChannel);         // Lockscreen Visibility and canBypassDnd no longer settable.         assertTrue(createdChannel.getLockscreenVisibility() != Notification.VISIBILITY_SECRET);         assertFalse(createdChannel.canBypassDnd());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testProvisioningNotAllowedWithDeviceOwner"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testProvisioningNotAllowedWithDeviceOwner() throws Exception {         if (!mHasFeature) {             return;         }          assertProvisionManagedProfileNotAllowed(COMP_DPC_PKG);     }      /**      * Both device owner and profile are the same package ({@link #COMP_DPC_PKG}), as setup      * by createAndManagedUser.      */     @FlakyTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testBindDeviceAdminServiceAsUser_secondaryUser"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testBindDeviceAdminServiceAsUser_secondaryUser() throws Exception {         if (!mHasFeature || !canCreateAdditionalUsers(1)) {             return;         }         int secondaryUserId = setupManagedSecondaryUser();          installAppAsUser(COMP_DPC_APK2, mPrimaryUserId);         installAppAsUser(COMP_DPC_APK2, secondaryUserId);          // Shouldn't be possible to bind to each other, as they are not affiliated.         verifyBindDeviceAdminServiceAsUserFails(secondaryUserId);          // Set the same affiliation ids, and check that DO and PO can now bind to each other.         setSameAffiliationId(secondaryUserId);         verifyBindDeviceAdminServiceAsUser(secondaryUserId);     }      @FlakyTest(bugId = 141161038)"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testNetworkAndSecurityLoggingAvailableIfAffiliated"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testNetworkAndSecurityLoggingAvailableIfAffiliated() throws Exception {         if (!mHasFeature) {             return;         }          if (!canCreateAdditionalUsers(2)) {             return;         }         // If secondary users are allowed, create an affiliated one, to check that this still         // works if having both an affiliated user and an affiliated managed profile.         final int secondaryUserId = setupManagedSecondaryUser();          runDeviceTestsAsUser(                 COMP_DPC_PKG,                 DEVICE_WIDE_LOGGING_TEST,                 ""testEnablingNetworkAndSecurityLogging"",                 mPrimaryUserId);         try {             // No affiliation ids have been set on the profile, the features shouldn't be available.             runDeviceTestsAsUser(                     COMP_DPC_PKG,                     DEVICE_WIDE_LOGGING_TEST,                     ""testRetrievingLogsThrowsSecurityException"",                     mPrimaryUserId);              // Affiliate the DO and the secondary user.             setSameAffiliationId(secondaryUserId);             runDeviceTestsAsUser(                     COMP_DPC_PKG,                     DEVICE_WIDE_LOGGING_TEST,                     ""testRetrievingLogsDoesNotThrowException"",                     mPrimaryUserId);              setDifferentAffiliationId(secondaryUserId);             runDeviceTestsAsUser(                     COMP_DPC_PKG,                     DEVICE_WIDE_LOGGING_TEST,                     ""testRetrievingLogsThrowsSecurityException"",                     mPrimaryUserId);         } finally {             runDeviceTestsAsUser(                 COMP_DPC_PKG,                 DEVICE_WIDE_LOGGING_TEST,                 ""testDisablingNetworkAndSecurityLogging"",                 mPrimaryUserId);         }     }      @FlakyTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testRequestBugreportAvailableIfAffiliated"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testRequestBugreportAvailableIfAffiliated() throws Exception {         if (!mHasFeature) {             return;         }          if (!canCreateAdditionalUsers(2)) {             return;         }          final int secondaryUserId = setupManagedSecondaryUser();          // No affiliation ids have been set on the secondary user, the feature shouldn't be         // available.         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 DEVICE_WIDE_LOGGING_TEST,                 ""testRequestBugreportThrowsSecurityException"",                 mPrimaryUserId);          // Affiliate the DO and the secondary user.         setSameAffiliationId(secondaryUserId);         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 DEVICE_WIDE_LOGGING_TEST,                 ""testRequestBugreportDoesNotThrowException"",                 mPrimaryUserId);          setDifferentAffiliationId(secondaryUserId, COMP_DPC_PKG);         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 DEVICE_WIDE_LOGGING_TEST,                 ""testRequestBugreportThrowsSecurityException"",                 mPrimaryUserId);     }      private void verifyBindDeviceAdminServiceAsUser(int profileOwnerUserId) throws Exception {         // Installing a non managing app (neither device owner nor profile owner).         installAppAsUser(COMP_DPC_APK2, mPrimaryUserId);         installAppAsUser(COMP_DPC_APK2, profileOwnerUserId);          // Testing device owner -> profile owner.         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 BIND_DEVICE_ADMIN_SERVICE_GOOD_SETUP_TEST,                 mPrimaryUserId);         // Testing profile owner -> device owner.         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 BIND_DEVICE_ADMIN_SERVICE_GOOD_SETUP_TEST,                 profileOwnerUserId);     }      private void verifyBindDeviceAdminServiceAsUserFails(int profileOwnerUserId) throws Exception {         // Installing a non managing app (neither device owner nor profile owner).         installAppAsUser(COMP_DPC_APK2, mPrimaryUserId);         installAppAsUser(COMP_DPC_APK2, profileOwnerUserId);          // Testing device owner -> profile owner.         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 BIND_DEVICE_ADMIN_SERVICE_FAILS_TEST,                 mPrimaryUserId);         // Testing profile owner -> device owner.         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 BIND_DEVICE_ADMIN_SERVICE_FAILS_TEST,                 profileOwnerUserId);     }      private void setSameAffiliationId(             int profileOwnerUserId, String profileOwnerPackage) throws Exception {         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 AFFILIATION_TEST,                 ""testSetAffiliationId1"",                 mPrimaryUserId);         runDeviceTestsAsUser(                 profileOwnerPackage,                 AFFILIATION_TEST,                 ""testSetAffiliationId1"",                 profileOwnerUserId);     }      private void setSameAffiliationId(int profileOwnerUserId) throws Exception {         setSameAffiliationId(profileOwnerUserId, COMP_DPC_PKG);     }      private void setDifferentAffiliationId(             int profileOwnerUserId, String profileOwnerPackage) throws Exception {         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 AFFILIATION_TEST,                 ""testSetAffiliationId1"",                 mPrimaryUserId);         runDeviceTestsAsUser(                 profileOwnerPackage,                 AFFILIATION_TEST,                 ""testSetAffiliationId2"",                 profileOwnerUserId);     }      private void setDifferentAffiliationId(int profileOwnerUserId) throws Exception {         setDifferentAffiliationId(profileOwnerUserId, COMP_DPC_PKG);     }      private void assertProvisionManagedProfileNotAllowed(String packageName) throws Exception {         runDeviceTestsAsUser(                 packageName,                 MANAGEMENT_TEST,                 ""testProvisionManagedProfileNotAllowed"",                 mPrimaryUserId);     }      /** Returns the user id of the newly created managed profile */     private int setupManagedProfile(String apkName, String packageName,             String adminReceiverClassName) throws Exception {         final int userId = createManagedProfile(mPrimaryUserId);         installAppAsUser(apkName, userId);         setProfileOwnerOrFail(adminReceiverClassName, userId);         startUserAndWait(userId);         runDeviceTestsAsUser(                 packageName,                 MANAGEMENT_TEST,                 ""testIsManagedProfile"",                 userId);         return userId;     }      /** Returns the user id of the newly created secondary user */     private int setupManagedSecondaryUser() throws Exception {         assertTrue(canCreateAdditionalUsers(1));          runDeviceTestsAsUser(                 COMP_DPC_PKG,                 MANAGEMENT_TEST,                 ""testCreateSecondaryUser"",                 mPrimaryUserId);         List<Integer> newUsers = getUsersCreatedByTests();         assertEquals(1, newUsers.size());         int secondaryUserId = newUsers.get(0);         getDevice().startUser(secondaryUserId, /* waitFlag= */ true);         return secondaryUserId;     }      /** Returns the user id of the newly created secondary user */     private int provisionCorpOwnedManagedProfile() throws Exception {         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 MANAGED_PROFILE_PROVISIONING_TEST,                 ""testProvisioningCorpOwnedManagedProfile"",                 mPrimaryUserId);         return getFirstManagedProfileUserId();     }      /**      * Add {@link android.os.UserManager#DISALLOW_REMOVE_USER}.      */     private void addDisallowRemoveUserRestriction() throws Exception {         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 USER_RESTRICTION_TEST,                 ""testAddDisallowRemoveUserRestriction"",                 mPrimaryUserId);     }      /**      * Clear {@link android.os.UserManager#DISALLOW_REMOVE_USER}.      */     private void clearDisallowRemoveUserRestriction() throws Exception {         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 USER_RESTRICTION_TEST,                 ""testClearDisallowRemoveUserRestriction"",                 mPrimaryUserId);     }      private void assertOtherProfilesEqualsBindTargetUsers(int otherProfileUserId) throws Exception {         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 MANAGEMENT_TEST,                 ""testOtherProfilesEqualsBindTargetUsers"",                 mPrimaryUserId);         runDeviceTestsAsUser(                 COMP_DPC_PKG,                 MANAGEMENT_TEST,                 ""testOtherProfilesEqualsBindTargetUsers"",                 otherProfileUserId);     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testAddUserRestrictionDisallowConfigDateTime_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testAddUserRestrictionDisallowConfigDateTime_onParent() {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         assertNotNull(parentDevicePolicyManager);          parentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,                 UserManager.DISALLOW_CONFIG_DATE_TIME);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testAddUserRestrictionDisallowAddUser_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testAddUserRestrictionDisallowAddUser_onParent() {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         assertNotNull(parentDevicePolicyManager);          parentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,                 UserManager.DISALLOW_ADD_USER);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testClearUserRestrictionDisallowAddUser"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testClearUserRestrictionDisallowAddUser() {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);          parentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,                 UserManager.DISALLOW_ADD_USER);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testAddUserRestrictionCameraDisabled_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testAddUserRestrictionCameraDisabled_onParent() {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         parentDevicePolicyManager.setCameraDisabled(ADMIN_RECEIVER_COMPONENT, true);         boolean actualDisabled =                 parentDevicePolicyManager.getCameraDisabled(ADMIN_RECEIVER_COMPONENT);          assertThat(actualDisabled).isTrue();     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testRemoveUserRestrictionCameraEnabled_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testRemoveUserRestrictionCameraEnabled_onParent() {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         parentDevicePolicyManager.setCameraDisabled(ADMIN_RECEIVER_COMPONENT, false);         boolean actualDisabled =                 parentDevicePolicyManager.getCameraDisabled(ADMIN_RECEIVER_COMPONENT);          assertThat(actualDisabled).isFalse();     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testPerProfileUserRestriction_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testPerProfileUserRestriction_onParent() throws Settings.SettingNotFoundException {         mUiAutomation.adoptShellPermissionIdentity(                 ""android.permission.INTERACT_ACROSS_USERS_FULL"",                 ""android.permission.CREATE_USERS"");          DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         assertNotNull(parentDevicePolicyManager);          int locationMode = Settings.Secure.getIntForUser(mContentResolver,                 Settings.Secure.LOCATION_MODE, UserHandle.USER_SYSTEM);          for (String restriction : PROFILE_OWNER_ORGANIZATION_OWNED_LOCAL_RESTRICTIONS) {             try {                 boolean hasRestrictionOnManagedProfile = mUserManager.hasUserRestriction(                         restriction);                  parentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);                 // Assert user restriction on personal profile has been added                 assertThat(hasUserRestriction(restriction)).isTrue();                 // Assert user restriction on managed profile has not changed                 assertThat(mUserManager.hasUserRestriction(restriction)).isEqualTo(                         hasRestrictionOnManagedProfile);             } finally {                 parentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,                         restriction);                 assertThat(hasUserRestriction(restriction)).isFalse();             }         }          // Restore the location mode setting after adding and removing the         // DISALLOW_SHARE_LOCATION user restriction. This is because, modifying this user         // restriction causes the location mode setting to be turned off.         Settings.Secure.putIntForUser(mContentResolver, Settings.Secure.LOCATION_MODE, locationMode,                 UserHandle.USER_SYSTEM);     }      private static final Set<String> PROFILE_OWNER_ORGANIZATION_OWNED_GLOBAL_RESTRICTIONS =             ImmutableSet.of(                     UserManager.DISALLOW_CONFIG_PRIVATE_DNS,                     UserManager.DISALLOW_CONFIG_DATE_TIME,                     UserManager.DISALLOW_AIRPLANE_MODE             );"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testPerDeviceUserRestriction_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testPerDeviceUserRestriction_onParent() {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         assertNotNull(parentDevicePolicyManager);          for (String restriction : PROFILE_OWNER_ORGANIZATION_OWNED_GLOBAL_RESTRICTIONS) {             try {                 parentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);                 // Assert user restriction on personal profile has been added                 assertThat(hasUserRestriction(restriction)).isTrue();                 // Assert user restriction on managed profile has been added                 assertThat(mUserManager.hasUserRestriction(restriction)).isTrue();             } finally {                 parentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,                         restriction);                 assertThat(hasUserRestriction(restriction)).isFalse();                 assertThat(mUserManager.hasUserRestriction(restriction)).isFalse();             }         }     }      private boolean hasUserRestriction(String key) {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         Bundle userRestrictions =                 parentDevicePolicyManager.getUserRestrictions(ADMIN_RECEIVER_COMPONENT);         return userRestrictions.getBoolean(key);     }      /**      * Starts a background thread and its {@link Handler}.      */     private void startBackgroundThread() {         mBackgroundThread = new HandlerThread(""CameraBackground"");         mBackgroundThread.start();         mBackgroundHandler = new Handler(mBackgroundThread.getLooper());     }      /**      * Stops the background thread and its {@link Handler}.      */     private void stopBackgroundThread() {         mBackgroundThread.quitSafely();         try {             mBackgroundThread.join();             mBackgroundThread = null;             mBackgroundHandler = null;         } catch (InterruptedException e) {             Log.e(TAG, ""Interrupted exception thrown while stopping background thread."");         }     }  }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.keystore.cts.CipherTest"	"isDeviceLocked"	"CtsKeystoreTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/keystore/src/android/keystore/cts/CipherTest.java"	""	"public void test/*  *.  */  package android.keystore.cts;  import android.app.KeyguardManager; import android.content.Context; import android.content.pm.PackageManager; import android.os.SystemClock; import android.platform.test.annotations.Presubmit; import android.security.keystore.KeyProperties; import android.security.keystore.KeyProtection; import android.server.wm.ActivityManagerTestBase; import android.test.AndroidTestCase; import android.test.MoreAsserts;  import com.google.common.collect.ObjectArrays;  import java.security.AlgorithmParameters; import java.security.InvalidKeyException; import java.security.Key; import java.security.KeyStoreException; import java.security.Provider; import java.security.Security; import java.security.spec.AlgorithmParameterSpec; import java.security.spec.MGF1ParameterSpec; import java.security.Provider.Service; import java.util.Arrays; import java.util.Collection; import java.util.Date; import java.util.HashSet; import java.util.Locale; import java.util.Map; import java.util.Set; import java.util.TreeMap;  import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.spec.GCMParameterSpec; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.OAEPParameterSpec; import javax.crypto.spec.PSource; import javax.crypto.spec.SecretKeySpec;  /**  * Tests for algorithm-agnostic functionality of {@code Cipher} implementations backed by Android  * Keystore.  */ public class CipherTest extends AndroidTestCase {      private static final String EXPECTED_PROVIDER_NAME = TestUtils.EXPECTED_CRYPTO_OP_PROVIDER_NAME;      private static final String[] BASE_EXPECTED_ALGORITHMS = {         ""AES/ECB/NoPadding"",         ""AES/ECB/PKCS7Padding"",         ""AES/CBC/NoPadding"",         ""AES/CBC/PKCS7Padding"",         ""AES/CTR/NoPadding"",         ""AES/GCM/NoPadding"",         ""RSA/ECB/NoPadding"",         ""RSA/ECB/PKCS1Padding"",         ""RSA/ECB/OAEPPadding"",         ""RSA/ECB/OAEPWithSHA-1AndMGF1Padding"",         ""RSA/ECB/OAEPWithSHA-224AndMGF1Padding"",         ""RSA/ECB/OAEPWithSHA-256AndMGF1Padding"",         ""RSA/ECB/OAEPWithSHA-384AndMGF1Padding"",         ""RSA/ECB/OAEPWithSHA-512AndMGF1Padding""     };      private static final String[] DESEDE_ALGORITHMS = {         ""DESede/CBC/NoPadding"",         ""DESede/CBC/PKCS7Padding"",         ""DESede/ECB/NoPadding"",         ""DESede/ECB/PKCS7Padding"",     };      private static String[] EXPECTED_ALGORITHMS = BASE_EXPECTED_ALGORITHMS;      static {       if (TestUtils.supports3DES()) {         EXPECTED_ALGORITHMS = ObjectArrays             .concat(BASE_EXPECTED_ALGORITHMS, DESEDE_ALGORITHMS, String.class);       }     }      private static class KatVector {         private final byte[] plaintext;         private final byte[] ciphertext;         private final AlgorithmParameterSpec params;          private KatVector(String plaintextHex, String ciphertextHex) {             this(plaintextHex, null, ciphertextHex);         }          private KatVector(String plaintextHex, AlgorithmParameterSpec params,                 String ciphertextHex) {             this(HexEncoding.decode(plaintextHex), params, HexEncoding.decode(ciphertextHex));         }          private KatVector(byte[] plaintext, byte[] ciphertext) {             this(plaintext, null, ciphertext);         }          private KatVector(byte[] plaintext, AlgorithmParameterSpec params, byte[] ciphertext) {             this.plaintext = plaintext;             this.ciphertext = ciphertext;             this.params = params;         }     }     private static final Map<String, KatVector> KAT_VECTORS =             new TreeMap<String, KatVector>(String.CASE_INSENSITIVE_ORDER);     static {         // From RI         KAT_VECTORS.put(""AES/ECB/NoPadding"", new KatVector(                 ""0383911bb1519d58e6656f3fd35639c502dbeb2196cea937fca272666cb4a80b"",                 ""6574c5065283b89e0c930019e4655d8516b98170db6516cd83e589bd9c5e5adc""));         KAT_VECTORS.put(""AES/ECB/PKCS7Padding"", new KatVector(                 ""1ad3d73a3cfa66dac78a51a95c2cb2125ea701e6e9ecbca2415b436f0258e2ba7439b67545"",                 ""920f873f2f9e91bac4c9c948d66496a21b8b2606850490dac7abecae83317488ee550b9973ac5cd142""                 + ""f387d7d2a12752""));         KAT_VECTORS.put(""AES/CBC/NoPadding"", new KatVector(                 ""1dffe21c8f18276c3a39ed0c53ab257b84efcedab60095c4cadd131143058cf7"",                 new IvParameterSpec(HexEncoding.decode(""10b3eea6cc8a7d6f48337e9b6987d28c"")),                 ""47ab115bfadca91eaebec73ab942a06f3121fdd5aa55d223bd2cbcc3855e1ef8""));         KAT_VECTORS.put(""AES/CBC/PKCS7Padding"", new KatVector(                 ""9d49fb970b23bfe742ae7c45a773ada9faad84708c8858a06e4a192e0a90e2f6083548e0bf3f67"",                 new IvParameterSpec(HexEncoding.decode(""ecd87bf9c49f37dcd2294e309192289a"")),                 ""aeb64f48ec18a086eda7ee080948651a50b6f582ab54aac5454c9ab0a4de5b4a4abac526a4307011d1""                 + ""2881f1849c32ae""));         KAT_VECTORS.put(""AES/CTR/NoPadding"", new KatVector(                 ""b4e786cab9df48d2fce0c7872651314db1318d1f31a1b10a2c334d2555b4117668"",                 new IvParameterSpec(HexEncoding.decode(""94d9f7a6d16f58018819b668020b68cc"")),                 ""022e74572a70be57a0b65b2fb5bc9b803ce48973b6163f528bbe1fd001e29d330a""));         KAT_VECTORS.put(""AES/GCM/NoPadding"", new KatVector(                 ""03889a6ca811e3fd7e78467e3dae587d2110e80e98edbc9dfe17afba238c4c493186"",                 new GCMParameterSpec(128, HexEncoding.decode(""f67aaf97cdec65b12188315e"")),                 ""159eb1ffc86589b38f18097c32db646c7de3525b603876c3ae671bc2ca52a5395a374b377a915c9ed1""                 + ""a349abf9fc54c9ca81""));         KAT_VECTORS.put(""RSA/ECB/NoPadding"", new KatVector(                 ""50c499d558c38fd48ea76832887db2abc76e4e153a98fd4323ccb8006d34f11724a5692fb101b0eb96""                 + ""060eb9d15222"",                 ""349b1d5061e98d0ab3f2327680bbc0cbb1b8ef8ee26148d7c67cf535223e3f78d822d369592ede29b1""                 + ""654aab25e6ae5e098318e55c13dc405f5ba27e5cc69ced32778592a51e6293a03f95e14ed17099fb""                 + ""0ac585e41297b87c3432953df0d98be7e505dc7de7bfe9d9ec750f475afeba4cc2dd78838c0d4399""                 + ""d8de02b07f00b292dc3d32d2a2f98ea5a5dac1a0fec4d01e5c3aea8c56eeff264896fb6cf2144401""                 + ""278c6663417bc00aafbb9eb97c056573cdec88d6ac6fd6c333d131337b16031da229029e3b6fe6f8""                 + ""ee427f2e90041e9636d67cddac75845914ce4be56092eed7188fe7e2bb33769efdeed86a7acbe15d""                 + ""debf92d9fbaaddede206acfa650697""));         KAT_VECTORS.put(""RSA/ECB/PKCS1Padding"", new KatVector(                 ""aed8cd94f35b2a54cdd3ed771482bd87e256b995408558fb82e5d475d1ee54711472f899ad6cbb6847""                 + ""99e52ff1d57cbc39f4"",                 ""64148dee294dd3ea31d2b595ea661318cf90c89f71393cf6559087d6e8993e73eb1e6b5f4d3cfde3cb""                 + ""267938c5eca522b95a2df02df9c703dbe3103c157af0d2ed5b70da51cb4caa49061319420d0ea433""                 + ""f24b727530c162226bc806b7f39079cd494a5c8a242737413d27063f9fb74aadd20f521211316719""                 + ""c628fd4351d0608928949b6f59f351d9ccec4c596514335010834fcabd53a2cbb2642e0f83c4f89c""                 + ""199ee2c68ace9182cf484d99e86b0b2213c1cc113d24891958e5a0774b7486abae1475e46a939a94""                 + ""5d6491b98ad7979fd6e752b47e43e960557a0c0589d7d0444b011d75c9f5b143da6e1dcf7b678a2e""                 + ""f82fbe37a74df3e20fb1a9dbfd5978""));         KAT_VECTORS.put(""RSA/ECB/OAEPPadding"", new KatVector(                 ""c219f4e3e37eae2315f0fa4ebc4b46ef0c6befbb43a51ceda07435fc88a9"",                 ""7a9bcfd0d02b6434025bbf5ba09c2dad118a4a3bca7cced8b404bc0fc2f17ddee13de82c8324294bf2""                 + ""60ad6e5171c2c3728a0c0fab20dd60e4e56cfef3e66239439ed2eddcc83ac8eeaedfd970e9966de3""                 + ""94ad1df0df503a0a640a49e10885b3a4115c3e94e893fff87bf9a5808350f957d6bc556ca6b08f81""                 + ""bf697704a3eb3db774797f883af0dcdc9bd9196d7595bab5e87d3187eb45b5771abe4e4dc70c25fa""                 + ""b9e3cddb6ae453a1d8e517d000779472e1376e5848b1654a51a9e90be4a4a6d0f6b8723c6e93c471""                 + ""313ea94f24504ca377b502057331355965a7e0b9c3b1d1fbd24ab5a4167f721d1ddac4d3c094d5c9""                 + ""0d2e277e9b5617cbf2770186323e89""));         KAT_VECTORS.put(""RSA/ECB/OAEPWithSHA-1AndMGF1Padding"", new KatVector(                 ""bb2854620bb0e361d1384703dda12acee1fefc22024bcfc40a86390d5342c693aab8c7ed6517d8da86""                 + ""04492c9d"",                 ""77033c578f24ef0ed93bfe6dc6f7c3f9f0505e7562f67ce987a269cabaa8a3ae7dd5e567a8b37db42d""                 + ""a79aa86ea2e189af5b9560b39407ff86f2785cdaf660fc7c93649bc24a818de564cb0d03e7681fa8""                 + ""f3cd42b3bfc58c49d3f049e0c98b07aff95876f05ddc45ebaa7127a198f27ae0cfd161c5598ac795""                 + ""8ed386d98b13d45730e6dc16313fe012af27d7be0e45215040bbfb07f2d35e34291fe4335a68175a""                 + ""46be99a15c1ccf673659157e1f52105de5a0a6f8c9d946740216eefe2a01a37b0ab144a44ff0d800""                 + ""be713b5b44acf4fcb1a60d5db977af4d77fa77bdb8594032b2f5bbdd49346b08e0e98ab1051b462e""                 + ""160c1bff62b927cd26c936948b723a""));         KAT_VECTORS.put(""RSA/ECB/OAEPWithSHA-224AndMGF1Padding"", new KatVector(                 ""1bae19434be6599d1987b1ed866dd6b684dcd908bd98d797250be545eafea46d05ebdf9018"",                 ""0f18b4a1153c6f8821e18a4275e4b570d540c8ad86bfc99146e5475238a43ecbe63bc81368cd64b9a2""                 + ""ab3ccd586e6afaad054c9d7bdc986adf022ec86335d110c53ebd5f2f2bd49d48d6da9541312c9b1b""                 + ""cc299ca4f59475869e4ec2253c91b137eae274a245fc9ee6262f74754bbda55d8bd25bfa4c1698f3""                 + ""a22d2d8d7fc6e9fbb56d828e61912b3085d82cceaeb1d2da425871575e7ba31a3d47b1b7d7df0bda""                 + ""81d62c75a9887bbc528fc6bb51db09884bb513b4cc94ca4a5fe0b370ca548dcdf60eebbf61e7efe7""                 + ""630fc47256d6d617fc1c2c774405f385650898abea03502cfbdcb53579fd18d896490e67aecdb7c7""                 + ""b7b950dc7ddba5c64188494c1a177b""));         KAT_VECTORS.put(""RSA/ECB/OAEPWithSHA-256AndMGF1Padding"", new KatVector(                 ""332c2f2fc066fb29ec0928a52b5111ce6965546ce73927340c42d33b56b6ba547b77ac361ac0d13316""                 + ""345ca953840023d892fa4ff1aa32cc66d5aa88b79867"",                 ""942c0ba1c67a34a7e116d9281b1df5084c66bc1458faf1b26d4f0f63a57307a9addcd3e5d2f3320071""                 + ""5a3d95ae84fb40a8dfe4cb0a28873fd5883ff8ee6efbfe38c460c755577b34fcf05bb2077afec7b2""                 + ""203799022be6a0903915e01e94abc51efe9c5548eb86bbbb4fd7f3bfc7b86f388128b6df1e6ce651""                 + ""230c6bc18bbf55b029f1e31da880c27d947ff97519df66a57ead6db791c4978f1d62edec0d89bb16""                 + ""83d237213f3f24271ddb8c4b50a82527954f0e49ae44d3acd8ddd3a57cfbfa456dd40675d5d75542""                 + ""31c6b79c7fb3500b1631be1d100e67d85ce423845fdc7c7f45e346a8ba573f5d11de9009069468dd""                 + ""8d517ad4adb1509dd5173ee1862d74""));         KAT_VECTORS.put(""RSA/ECB/OAEPWithSHA-384AndMGF1Padding"", new KatVector(                 ""f51f158cbad4dbab38403b839c724f09a480c49be29c0e72615539dbe57ec86143f31f19392f419b5b""                 + ""e4ba9e3c6f1e870d307a7cf1a9e2"",                 ""944243f35f534e7a273e94986b6835a4f5cdc5bc4efb9970d4760986599a02f652a848fcae333ff25a""                 + ""64108c9b900aaf002688398ad9fc17c73be52726306af9c13540df9d1765336b6f09ba4cb8a54d72""                 + ""5a4e45854bfa3802cfb110a6d7f7054e6072440ec00da62828cb75fe2566ec5be79eb8a3d1fbe2c2""                 + ""4439c107e5018e445e201ad80725755543c00dec50bb464c6ca897600eb3cda51fcef8161ac13d75""                 + ""a3eb30d385a1e718a61ae1b5d47aadb966fc007becc84db397d0b3cd983121872f9975995153e869""                 + ""9e24554a3c5e885f0ed8cd03e916da5ed541f1598da9bd6209447301d00f086153da353deff9d045""                 + ""8976ff7570410f0bdcfb3f56b782f5""));         KAT_VECTORS.put(""RSA/ECB/OAEPWithSHA-512AndMGF1Padding"", new KatVector(                 ""d45f6ccc7e663957f234c237c1f09bf7791f6f5c1b9ef4fefb16e55ded0d96112e590f1bb08a60f85c""                 + ""2d0d2533f1d69792dfd8d647d880b18f87cfe32488c73613a3d535da7d776d90d9a4ba6a0311f456""                 + ""8511da49107c"",                 ""5a037df3e5d6f3f703541e2db2aef7c69985e513bdff67c8ade6a09f50e27267bfb444f6c69b40a77a""                 + ""9136a27b29876af9d2bf4e7099863445d35b188d31f376b89fbd196059667ca657e10b9454c2b25f""                 + ""046fc9f7b42506e382e6b6fd99409cf97e865e65f8dce5d14a06b8aa8833c4bc72c8764467758f2d""                 + ""7960243161dce4ca8231e91bfcd3c933a80bc703ceab976224c876b1f550f91a6c2a0332d4377bd8""                 + ""dfe4b1283ab114e517b7b9e4a6e0bf166d5b506e7a3b7328078e12cb23b1d938760767dc9b3c3eb0""                 + ""848ddda101792aca9273ad414314c13fc511ffa0358a8f4c5f38edded3a2dc111fa62c80e6032c32""                 + ""ae04aeac7729f16a6310f1f6785c27""));           KAT_VECTORS.put(""DESede/CBC/NoPadding"",                 new KatVector(""eac1b7959e1e23c11dc4a0e233eedd99e5bf5dd391a5f107d006133a9af3e385"",                         new IvParameterSpec(HexEncoding.decode(""ecd87bf9c49f37dc"")),                         ""632511c46680d60883a228e62cd31244ad61b987e8df7901dae0eb220c839689""));         KAT_VECTORS.put(""DESede/CBC/PKCS7Padding"",                 new KatVector(""31323334353637383132333435363738"",                         new IvParameterSpec(HexEncoding.decode(""DFCA366848DEA6BB"")),                         ""e70bb5761d796d7b0eb40b5b60deb6a9726f72d97cf2ada4""));         KAT_VECTORS.put(""DESede/ECB/NoPadding"",                 new KatVector(""31323334353637383132333435363738"",                         ""ade119f9e35ab3e9ade119f9e35ab3e9""));         KAT_VECTORS.put(""DESede/ECB/PKCS7Padding"",                 new KatVector(""31323334353637383132333435363738"",                         ""ade119f9e35ab3e9ade119f9e35ab3e94bcb01bbc0d05526""));     }      private static final long DAY_IN_MILLIS = TestUtils.DAY_IN_MILLIS;      private static final byte[] AES128_KAT_KEY_BYTES =             HexEncoding.decode(""7d9f11a0da111e9d8bdd14f04648ed91"");      private static final byte[] AES192_KAT_KEY_BYTES =             HexEncoding.decode(""69ef2c44a48d3dc4d5744a281f7ebb5ca976c2202f91e10c"");      private static final byte[] AES256_KAT_KEY_BYTES =             HexEncoding.decode(""cf601cc10aaf434d1f01747136aff222af7fb426d101901712214c3fea18125f"");      private static final byte[] DESede_KAT_KEY_BYTES = HexEncoding.decode(             ""5EBE2294ECD0E0F08EAB7690D2A6EE6926AE5CC854E36B6B"");      private class DeviceLockSession  extends ActivityManagerTestBase implements AutoCloseable {          private LockScreenSession mLockCredential;          public DeviceLockSession() throws Exception {             setUp();             mLockCredential = new LockScreenSession();             mLockCredential.setLockCredential();         }          public void performDeviceLock() {             mLockCredential.sleepDevice();             KeyguardManager keyguardManager = (KeyguardManager)getContext().getSystemService(Context.KEYGUARD_SERVICE);             for (int i = 0; i < 25 && !keyguardManager.isDeviceLocked(); i++) {                 SystemClock.sleep(200);             }         }          public void performDeviceUnlock() throws Exception {             mLockCredential.gotoKeyguard();             mLockCredential.enterAndConfirmLockCredential();             launchHomeActivity();             KeyguardManager keyguardManager = (KeyguardManager)getContext().getSystemService(                     Context.KEYGUARD_SERVICE);             for (int i = 0; i < 25 && keyguardManager.isDeviceLocked(); i++) {                 SystemClock.sleep(200);             }             assertFalse(keyguardManager.isDeviceLocked());         }          @Override         public void close() throws Exception {             mLockCredential.close();             tearDown();         }          public boolean supportsLockAndUnlock() {             return supportsInsecureLock();         }     }      @Presubmit"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.jvmti.cts.JvmtiAttachingHostTest"	"testJvmtiAgentAppExternal"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/jvmti/attaching/host/src/android/jvmti/cts/JvmtiAttachingHostTest.java"	""	"public void testJvmtiAgentAppExternal() throws Exception {         runJvmtiAgentLoadTest((ITestDevice device, String pkg, String apk, String abiName) -> {             try {                 String pwd = getPwd(device, pkg);                 // Give it a different name, so we do not have ""contamination"" from                 // the test APK.                 String libInDataData = AGENT.substring(0, AGENT.length() - "".so"".length())                         + ""2.so"";                 String agentInDataData =                         installLibToDataData(device, pkg, abiName, apk, pwd, AGENT,                                 libInDataData);                  String setAgentAppCmd = ""cmd activity set-agent-app "" + pkg + "" "" + agentInDataData;                 device.executeShellCommand(setAgentAppCmd);             } catch (Exception e) {                 throw new RuntimeException(""Failed running set-agent-app"", e);             }              try {                 runAttachTestCmd(device, pkg, """");                  // And again.                 runAttachTestCmd(device, pkg, """");             } catch (Exception e) {                 throw new RuntimeException(""Failed agent-app attaching"", e);             }         });     }      private String getPwd(ITestDevice device, String pkg) throws Exception {         String pwd = device.executeShellCommand(                 ""run-as "" + pkg + "" --user "" + mCurrentUser + "" pwd"");         if (pwd == null) {             throw new RuntimeException(""pwd failed"");         }         pwd = pwd.trim();         if (pwd.isEmpty()) {             throw new RuntimeException(""pwd failed"");         }         return pwd;     }      private void runJvmtiAgentLoadTest(TestRun runner) throws Exception {         final ITestDevice device = getDevice();          String testingArch = AbiUtils.getBaseArchForAbi(mAbi.getName());         String deviceArch = getDeviceBaseArch(device);          //Only bypass if Base Archs are different         if (!testingArch.equals(deviceArch)) {             CLog.d(                     ""Bypass as testing Base Arch:""                             + testingArch                             + "" is different from DUT Base Arch:""                             + deviceArch);             return;         }          if (mTestApk == null || mTestPackageName == null) {             throw new IllegalStateException(""Incorrect configuration"");         }          // Wakeup the device if it is on the lockscreen and move it to the home screen.         device.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");         device.executeShellCommand(""wm dismiss-keyguard"");         device.executeShellCommand(""input keyevent KEYCODE_HOME"");          runner.run(device, mTestPackageName, mTestApk, mAbi.getName());     }      private String getDeviceBaseArch(ITestDevice device) throws Exception {         String abi = device.executeShellCommand(""getprop ro.product.cpu.abi"").replace(""\n"", """");         CLog.d(""DUT abi:"" + abi);         return AbiUtils.getBaseArchForAbi(abi);     }      private static void runAttachTestCmd(ITestDevice device, String pkg, String agentParams)             throws Exception {         // Get a reverse socket setup         try (final ServerSocket ss = new ServerSocket(0)) {             device.executeAdbCommand(                     ""reverse"", ""localabstract:"" + REMOTE_SOCKET_NAME, ""tcp:"" + ss.getLocalPort());             String attachCmd = ""cmd activity start -S "" + agentParams + "" -n "" + pkg                     + ""/android.jvmti.JvmtiActivity"";              // Don't try to parse the output. We'll get data from the socket or a timeout if it             // didn't start. For some reason this command sometimes fails. Retry up to ten times to             // make the test less flaky.             device.executeShellCommand(attachCmd, NullOutputReceiver.getReceiver(), 10,                   TimeUnit.SECONDS, 10);             // Wait for startup up to 30 seconds.             ss.setSoTimeout(30000);             try (Socket s = ss.accept()) {                 DataInputStream dis = new DataInputStream(s.getInputStream());                 String res = dis.readUTF();                 s.shutdownInput();                 if (!res.trim().equals(""SUCCESS"")) {                     throw new RuntimeException(""Failed test due to remote error: "" + res);                 }             } catch (Exception e) {                 throw new RuntimeException(""Failed to read output"", e);             }         } finally {             device.executeAdbCommand(""reverse"", ""--remove"", ""localabstract:"" + REMOTE_SOCKET_NAME);         }     }      private String installLibToDataData(ITestDevice device, String pkg, String abiName,             String apk, String dataData, String library, String newLibName) throws Exception {         ZipFile zf = null;         File tmpFile = null;         String libInTmp = null;         try {             String libInDataData = dataData + ""/"" + newLibName;              File apkFile = mBuildHelper.getTestFile(apk);             zf = new ZipFile(apkFile);              String libPathInApk = ""lib/"" + abiName + ""/"" + library;             tmpFile = ZipUtil.extractFileFromZip(zf, libPathInApk);              libInTmp = ""/data/local/tmp/"" + tmpFile.getName();             if (!device.pushFile(tmpFile, libInTmp)) {                 throw new RuntimeException(""Could not push library "" + library + "" to device"");             }              String runAsCp = device.executeShellCommand(                     ""run-as "" + pkg + "" --user "" + mCurrentUser +                             "" cp "" + libInTmp + "" "" + libInDataData);             if (runAsCp != null && !runAsCp.trim().isEmpty()) {                 throw new RuntimeException(runAsCp.trim());             }              String runAsChmod = device.executeShellCommand(                     ""run-as "" + pkg + "" --user "" + mCurrentUser + "" chmod a+x "" + libInDataData);             if (runAsChmod != null && !runAsChmod.trim().isEmpty()) {                 throw new RuntimeException(runAsChmod.trim());             }              return libInDataData;         } finally {             FileUtil.deleteFile(tmpFile);             ZipUtil.closeZip(zf);             if (libInTmp != null) {                 try {                     device.executeShellCommand(""rm "" + libInTmp);                 } catch (Exception e) {                     CLog.e(""Failed cleaning up library on device"");                 }             }         }     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.view.inputmethod.cts.PackageVisibilityTest"	"getTestMarker"	"CtsInputMethodTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/PackageVisibilityTest.java"	""	"/*  *.  */  package android.view.inputmethod.cts;  import static com.android.compatibility.common.util.SystemUtil.runShellCommand; import static com.android.cts.mockime.ImeEventStreamTestUtils.editorMatcher; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectCommand; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEvent;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.content.ComponentName; import android.content.Intent; import android.content.pm.ApplicationInfo; import android.content.pm.PackageManager; import android.net.Uri; import android.os.SystemClock; import android.platform.test.annotations.AppModeFull; import android.platform.test.annotations.AppModeInstant; import android.view.inputmethod.cts.util.EndToEndImeTestBase; import android.view.inputmethod.cts.util.UnlockScreenRule;  import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.test.filters.MediumTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4; import androidx.test.uiautomator.By; import androidx.test.uiautomator.UiDevice; import androidx.test.uiautomator.Until;  import com.android.cts.mockime.ImeCommand; import com.android.cts.mockime.ImeEvent; import com.android.cts.mockime.ImeEventStream; import com.android.cts.mockime.ImeSettings; import com.android.cts.mockime.MockImeSession;  import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.security.InvalidParameterException; import java.util.concurrent.TimeUnit;  @MediumTest @RunWith(AndroidJUnit4.class) public final class PackageVisibilityTest extends EndToEndImeTestBase {     static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);      @Rule     public final UnlockScreenRule mUnlockScreenRule = new UnlockScreenRule();      private static final ComponentName TEST_ACTIVITY = new ComponentName(             ""android.view.inputmethod.ctstestapp"",             ""android.view.inputmethod.ctstestapp.MainActivity"");      private static final Uri TEST_ACTIVITY_URI =             Uri.parse(""https://example.com/android/view/inputmethod/ctstestapp"");      private static final String EXTRA_KEY_PRIVATE_IME_OPTIONS =             ""android.view.inputmethod.ctstestapp.EXTRA_KEY_PRIVATE_IME_OPTIONS"";      private static final String TEST_MARKER_PREFIX =             ""android.view.inputmethod.cts.PackageVisibilityTest"";      private static String getTestMarker() {         return TEST_MARKER_PREFIX + ""/""  + SystemClock.elapsedRealtimeNanos();     }      @NonNull     private static Uri formatStringIntentParam(@NonNull Uri uri, @NonNull String key,             @Nullable String value) {         if (value == null) {             return uri;         }         return uri.buildUpon().appendQueryParameter(key, value).build();     }      @NonNull     private static String formatStringIntentParam(@NonNull String key, @Nullable String value) {         if (key.matches(""[ \""']"")) {             throw new InvalidParameterException(""Unsupported character(s) in key="" + key);         }         if (value.matches(""[ \""']"")) {             throw new InvalidParameterException(""Unsupported character(s) in value="" + value);         }         return value != null ? String.format("" --es %s %s"", key, value) : """";     }      /**      * Launch the standalone version of the test {@link android.app.Activity} then wait for      * completions of launch.      *      * <p>Note: this method does not use      * {@link android.app.Instrumentation#startActivitySync(Intent)} because it does not work when      * both the calling process and the target process run under the instant app mode. Instead this      * method relies on adb command {@code adb shell am start} to work around that limitation.</p>      *      * @param instant {@code true} if the caller and the target is installed as instant apps.      * @param privateImeOptions If not {@code null},      *                          {@link android.view.inputmethod.EditorInfo#privateImeOptions} will      *                          in the test {@link android.app.Activity} will be set to this value.      * @param timeout timeout in milliseconds.      */     private void launchTestActivity(boolean instant, @Nullable String privateImeOptions,             long timeout) {         final String command;         if (instant) {             final Uri uri = formatStringIntentParam(                     TEST_ACTIVITY_URI, EXTRA_KEY_PRIVATE_IME_OPTIONS, privateImeOptions);             command = String.format(""am start -a %s -c %s %s"",                     Intent.ACTION_VIEW, Intent.CATEGORY_BROWSABLE, uri.toString());         } else {             command = String.format(""am start -n %s"",                     TEST_ACTIVITY.flattenToShortString())                     + formatStringIntentParam(EXTRA_KEY_PRIVATE_IME_OPTIONS, privateImeOptions);         }         runShellCommand(command);         UiDevice.getInstance(InstrumentationRegistry.getInstrumentation())                 .wait(Until.hasObject(By.pkg(TEST_ACTIVITY.getPackageName()).depth(0)), timeout);     }      @AppModeFull"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.app.usage.cts.UsageReportingTest"	"testSplitscreenSameTokenOneMissedStop"	"CtsUsageStatsTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testSplitscreenSameTokenOneMissedStop() throws Exception {         if (!supportsSplitScreenMultiWindow()) {             // Skipping test: no multi-window support             return;         }          launchActivitiesInSplitScreen(                 getLaunchActivityBuilder().setTargetActivity(                         new ComponentName(mTargetPackage,                                 Activities.ActivityOne.class.getName())),                 getLaunchActivityBuilder().setTargetActivity(                         new ComponentName(mTargetPackage,                                 Activities.ActivityTwo.class.getName())));         Thread.sleep(500);          Activity activity0;         Activity activity1;         synchronized ( Activities.startedActivities) {             activity0 = Activities.startedActivities.valueAt(0);             activity1 = Activities.startedActivities.valueAt(1);         }          mUsageStatsManager.reportUsageStart(activity0, TOKEN_0);         mUsageStatsManager.reportUsageStart(activity1, TOKEN_0);         assertAppOrTokenUsed(mFullToken0, true);          mUsageStatsManager.reportUsageStop(activity0, TOKEN_0);         assertAppOrTokenUsed(mFullToken0, true);          // Send the device to keyguard to get onStop called for the token reporting activities.         try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             lockScreenSession.gotoKeyguard();             Thread.sleep(1000);             assertAppOrTokenUsed(mFullToken0, false);         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.app.usage.cts.UsageReportingTest"	"testSplitscreenSameTokenTwoMissedStop"	"CtsUsageStatsTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testSplitscreenSameTokenTwoMissedStop() throws Exception {         if (!supportsSplitScreenMultiWindow()) {             // Skipping test: no multi-window support             return;         }          launchActivitiesInSplitScreen(                 getLaunchActivityBuilder().setTargetActivity(                         new ComponentName(mTargetPackage,                                 Activities.ActivityOne.class.getName())),                 getLaunchActivityBuilder().setTargetActivity(                         new ComponentName(mTargetPackage,                                 Activities.ActivityTwo.class.getName())));         Thread.sleep(500);          Activity activity0;         Activity activity1;         synchronized ( Activities.startedActivities) {             activity0 = Activities.startedActivities.valueAt(0);             activity1 = Activities.startedActivities.valueAt(1);         }          mUsageStatsManager.reportUsageStart(activity0, TOKEN_0);         mUsageStatsManager.reportUsageStart(activity1, TOKEN_0);         assertAppOrTokenUsed(mFullToken0, true);          // Send the device to keyguard to get onStop called for the token reporting activities.         try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             lockScreenSession.gotoKeyguard();             Thread.sleep(1000);             assertAppOrTokenUsed(mFullToken0, false);         }     }      private void assertAppOrTokenUsed(String entity, boolean expected) throws Exception {         final String failMessage;         if (expected) {             failMessage = entity + "" not found in list of active activities and tokens"";         } else {             failMessage = entity + "" found in list of active activities and tokens"";         }          TestUtils.waitUntil(failMessage, ASSERT_TIMEOUT_SECONDS, () -> {             final String activeUsages =                     mUiDevice.executeShellCommand(""dumpsys usagestats apptimelimit actives"");             final String[] actives = activeUsages.split(""\n"");             boolean found = false;              for (String active: actives) {                 if (active.equals(entity)) {                     found = true;                     break;                 }             }             return found == expected;         });     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testLockAndUnlock"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testLockAndUnlock() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential().gotoKeyguard();          assertTrue(mKeyguardManager.isKeyguardLocked());         assertTrue(mKeyguardManager.isDeviceLocked());         assertTrue(mKeyguardManager.isDeviceSecure());         assertTrue(mKeyguardManager.isKeyguardSecure());         mWmState.assertKeyguardShowingAndNotOccluded();          lockScreenSession.unlockDevice().enterAndConfirmLockCredential();          mWmState.waitAndAssertKeyguardGone();         assertFalse(mKeyguardManager.isDeviceLocked());         assertFalse(mKeyguardManager.isKeyguardLocked());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testDisableKeyguard_thenSettingCredential_reenablesKeyguard_b119322269"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testDisableKeyguard_thenSettingCredential_reenablesKeyguard_b119322269() {         final KeyguardManager.KeyguardLock keyguardLock = mContext.getSystemService(                 KeyguardManager.class).newKeyguardLock(""KeyguardLockedTests"");          try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             lockScreenSession.gotoKeyguard();             keyguardLock.disableKeyguard();              lockScreenSession.setLockCredential();             lockScreenSession.gotoKeyguard();              mWmState.waitForKeyguardShowingAndNotOccluded();             mWmState.assertKeyguardShowingAndNotOccluded();             assertTrue(mKeyguardManager.isKeyguardLocked());             assertTrue(mKeyguardManager.isDeviceLocked());             assertTrue(mKeyguardManager.isDeviceSecure());             assertTrue(mKeyguardManager.isKeyguardSecure());         } finally {             keyguardLock.reenableKeyguard();         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testDismissKeyguard"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testDismissKeyguard() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential().gotoKeyguard();          mWmState.assertKeyguardShowingAndNotOccluded();         launchActivity(DISMISS_KEYGUARD_ACTIVITY);         lockScreenSession.enterAndConfirmLockCredential();          mWmState.waitAndAssertKeyguardGone();         mWmState.assertVisibility(DISMISS_KEYGUARD_ACTIVITY, true);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testDismissKeyguard_whileOccluded"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testDismissKeyguard_whileOccluded() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential().gotoKeyguard();          mWmState.assertKeyguardShowingAndNotOccluded();         launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);          launchActivity(DISMISS_KEYGUARD_ACTIVITY);         lockScreenSession.enterAndConfirmLockCredential();         mWmState.waitAndAssertKeyguardGone();         mWmState.computeState(DISMISS_KEYGUARD_ACTIVITY);          final boolean isDismissTranslucent = mWmState                 .isActivityTranslucent(DISMISS_KEYGUARD_ACTIVITY);         mWmState.assertVisibility(DISMISS_KEYGUARD_ACTIVITY, true);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, isDismissTranslucent);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testDismissKeyguard_fromShowWhenLocked_notAllowed"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testDismissKeyguard_fromShowWhenLocked_notAllowed() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential().gotoKeyguard();          mWmState.assertKeyguardShowingAndNotOccluded();         launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         mBroadcastActionTrigger.dismissKeyguardByFlag();         lockScreenSession.enterAndConfirmLockCredential();          // Make sure we stay on Keyguard.         mWmState.assertKeyguardShowingAndOccluded();         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testDismissKeyguardActivity_method"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testDismissKeyguardActivity_method() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential();         separateTestJournal();          lockScreenSession.gotoKeyguard();         mWmState.computeState();         assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);          launchActivity(DISMISS_KEYGUARD_METHOD_ACTIVITY);         lockScreenSession.enterAndConfirmLockCredential();         mWmState.waitForKeyguardGone();         mWmState.computeState(DISMISS_KEYGUARD_METHOD_ACTIVITY);         mWmState.assertVisibility(DISMISS_KEYGUARD_METHOD_ACTIVITY, true);         assertFalse(mWmState.getKeyguardControllerState().keyguardShowing);         assertOnDismissSucceeded(DISMISS_KEYGUARD_METHOD_ACTIVITY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testDismissKeyguardActivity_method_cancelled"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testDismissKeyguardActivity_method_cancelled() {         // Pressing the back button does not cancel Keyguard in AAOS.         assumeFalse(isCar());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential();         separateTestJournal();          lockScreenSession.gotoKeyguard();         mWmState.computeState();         assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);          launchActivity(DISMISS_KEYGUARD_METHOD_ACTIVITY);         pressBackButton();         assertOnDismissCancelled(DISMISS_KEYGUARD_METHOD_ACTIVITY);         mWmState.computeState();         mWmState.assertVisibility(DISMISS_KEYGUARD_METHOD_ACTIVITY, false);         assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testDismissKeyguardAttrActivity_method_turnScreenOn_withSecureKeyguard"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testDismissKeyguardAttrActivity_method_turnScreenOn_withSecureKeyguard() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential().sleepDevice();         mWmState.computeState();         assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);          launchActivity(TURN_SCREEN_ON_ATTR_DISMISS_KEYGUARD_ACTIVITY);         mWmState.waitForKeyguardShowingAndNotOccluded();         mWmState.assertVisibility(TURN_SCREEN_ON_ATTR_DISMISS_KEYGUARD_ACTIVITY, false);         assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);         assertTrue(isDisplayOn(DEFAULT_DISPLAY));     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testEnterPipOverKeyguard"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testEnterPipOverKeyguard() {         assumeTrue(supportsPip());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential();          // Show the PiP activity in fullscreen.         launchActivity(PIP_ACTIVITY, EXTRA_SHOW_OVER_KEYGUARD, ""true"");          // Lock the screen and ensure that the PiP activity showing over the LockScreen.         lockScreenSession.gotoKeyguard(PIP_ACTIVITY);         mWmState.waitForKeyguardShowingAndOccluded();         mWmState.assertKeyguardShowingAndOccluded();          // Request that the PiP activity enter picture-in-picture mode (ensure it does not).         mBroadcastActionTrigger.doAction(ACTION_ENTER_PIP);         waitForEnterPip(PIP_ACTIVITY);         mWmState.assertDoesNotContainStack(""Must not contain pinned stack."",                 WINDOWING_MODE_PINNED, ACTIVITY_TYPE_STANDARD);          // Enter the credentials and ensure that the activity actually entered picture-in-picture.         lockScreenSession.enterAndConfirmLockCredential();         mWmState.waitAndAssertKeyguardGone();         waitForEnterPip(PIP_ACTIVITY);         mWmState.assertContainsStack(""Must contain pinned stack."", WINDOWING_MODE_PINNED,                 ACTIVITY_TYPE_STANDARD);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testShowWhenLockedActivityAndPipActivity"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testShowWhenLockedActivityAndPipActivity() {         assumeTrue(supportsPip());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential();          // Show an activity in PIP.         launchActivity(PIP_ACTIVITY, EXTRA_ENTER_PIP, ""true"");         waitForEnterPip(PIP_ACTIVITY);         mWmState.assertContainsStack(""Must contain pinned stack."", WINDOWING_MODE_PINNED,                 ACTIVITY_TYPE_STANDARD);         mWmState.assertVisibility(PIP_ACTIVITY, true);          // Show an activity that will keep above the keyguard.         launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);          // Lock the screen and ensure that the fullscreen activity showing over the lockscreen         // is visible, but not the PiP activity.         lockScreenSession.gotoKeyguard(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState();         mWmState.assertKeyguardShowingAndOccluded();         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         mWmState.assertVisibility(PIP_ACTIVITY, false);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testShowWhenLockedPipActivity"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testShowWhenLockedPipActivity() {         assumeFalse(""Skip test: Keyguard cannot be dismissed in Automotive"",                 FeatureUtil.isAutomotive());         assumeTrue(supportsPip());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential();          // Show an activity in PIP.         launchActivity(PIP_ACTIVITY, EXTRA_ENTER_PIP, ""true"", EXTRA_SHOW_OVER_KEYGUARD, ""true"");         waitForEnterPip(PIP_ACTIVITY);         mWmState.assertContainsStack(""Must contain pinned stack."", WINDOWING_MODE_PINNED,                 ACTIVITY_TYPE_STANDARD);         mWmState.assertVisibility(PIP_ACTIVITY, true);          // Lock the screen and ensure the PiP activity is not visible on the lockscreen even         // though it's marked as showing over the lockscreen itself.         lockScreenSession.gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();         mWmState.assertVisibility(PIP_ACTIVITY, false);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testDismissKeyguardPipActivity"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testDismissKeyguardPipActivity() {         assumeFalse(""Skip test: Keyguard cannot be dismissed in Automotive"",                 FeatureUtil.isAutomotive());         assumeTrue(supportsPip());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         // Show an activity in PIP.         launchActivity(PIP_ACTIVITY, EXTRA_ENTER_PIP, ""true"", EXTRA_DISMISS_KEYGUARD, ""true"");         waitForEnterPip(PIP_ACTIVITY);         mWmState.assertContainsStack(""Must contain pinned stack."", WINDOWING_MODE_PINNED,                 ACTIVITY_TYPE_STANDARD);         mWmState.assertVisibility(PIP_ACTIVITY, true);          // Lock the screen and ensure the PiP activity is not visible on the lockscreen even         // though it's marked as dismiss keyguard.         lockScreenSession.gotoKeyguard();         mWmState.computeState();         mWmState.assertKeyguardShowingAndNotOccluded();         mWmState.assertVisibility(PIP_ACTIVITY, false);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testShowWhenLockedAttrImeActivityAndShowSoftInput"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testShowWhenLockedAttrImeActivityAndShowSoftInput() throws Exception {         assumeTrue(MSG_NO_MOCK_IME, supportsInstallableIme());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final MockImeSession mockImeSession = createManagedMockImeSession(this);          lockScreenSession.setLockCredential().gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();         launchActivity(SHOW_WHEN_LOCKED_ATTR_IME_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ATTR_IME_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_IME_ACTIVITY, true);          // Make sure the activity has been called showSoftInput & IME window is visible.         final ImeEventStream stream = mockImeSession.openEventStream();         expectEvent(stream, event -> ""showSoftInput"".equals(event.getEventName()),                 TIMEOUT_IME);         // Assert the IME is shown on the expected display.         mWmState.waitAndAssertImeWindowShownOnDisplay(DEFAULT_DISPLAY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testShowWhenLockedImeActivityAndShowSoftInput"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testShowWhenLockedImeActivityAndShowSoftInput() throws Exception {         assumeTrue(MSG_NO_MOCK_IME, supportsInstallableIme());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final MockImeSession mockImeSession = createManagedMockImeSession(this);         final TestActivitySession<ShowWhenLockedImeActivity> imeTestActivitySession =                 createManagedTestActivitySession();          lockScreenSession.setLockCredential().gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();         imeTestActivitySession.launchTestActivityOnDisplaySync(ShowWhenLockedImeActivity.class,                 DEFAULT_DISPLAY);          // Make sure the activity has been called showSoftInput & IME window is visible.         final ImeEventStream stream = mockImeSession.openEventStream();         expectEvent(stream, event -> ""showSoftInput"".equals(event.getEventName()),                 TIMEOUT_IME);         // Assert the IME is shown on the expected display.         mWmState.waitAndAssertImeWindowShownOnDisplay(DEFAULT_DISPLAY);      }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardLockedTests"	"testImeShowsAfterLockScreenOnEditorTap"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardLockedTests.java"	""	"public void testImeShowsAfterLockScreenOnEditorTap() throws Exception {         assumeTrue(MSG_NO_MOCK_IME, supportsInstallableIme());          final MockImeSession mockImeSession = createManagedMockImeSession(this);         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final TestActivitySession<ShowImeAfterLockscreenActivity> imeTestActivitySession =                 createManagedTestActivitySession();         imeTestActivitySession.launchTestActivityOnDisplaySync(ShowImeAfterLockscreenActivity.class,                 DEFAULT_DISPLAY);          final ShowImeAfterLockscreenActivity activity = imeTestActivitySession.getActivity();         final View rootView = activity.getWindow().getDecorView();          CtsTouchUtils.emulateTapOnViewCenter(getInstrumentation(), null, activity.mEditor);         PollingCheck.waitFor(                 TIMEOUT_IME,                 () -> rootView.getRootWindowInsets().isVisible(ime()));          lockScreenSession.setLockCredential().gotoKeyguard();         assertTrue(""Keyguard is showing"", mWmState.getKeyguardControllerState().keyguardShowing);         lockScreenSession.unlockDevice().enterAndConfirmLockCredential();         mWmState.waitAndAssertKeyguardGone();          final ImeEventStream stream = mockImeSession.openEventStream();          CtsTouchUtils.emulateTapOnViewCenter(getInstrumentation(), null, activity.mEditor);          // Make sure the activity has been called showSoftInput & IME window is visible.         expectEvent(stream, event -> ""showSoftInput"".equals(event.getEventName()),                 TimeUnit.SECONDS.toMillis(5) /* eventTimeout */);         // Assert the IME is shown event on the expected display.         mWmState.waitAndAssertImeWindowShownOnDisplay(DEFAULT_DISPLAY);         // Check if IME is actually visible.         PollingCheck.waitFor(                 TIMEOUT_IME,                 () -> rootView.getRootWindowInsets().isVisible(ime()));     }      public static class ShowImeAfterLockscreenActivity extends Activity {          EditText mEditor;          @Override         protected void onCreate(Bundle icicle) {             super.onCreate(icicle);             mEditor = createViews(this, false /* showWhenLocked */);         }     }      public static class ShowWhenLockedImeActivity extends Activity {          @Override         protected void onCreate(Bundle icicle) {             super.onCreate(icicle);             createViews(this, true /* showWhenLocked */);         }     }      private static EditText createViews(             Activity activity, boolean showWhenLocked /* showWhenLocked */) {         EditText editor = new EditText(activity);         // Set private IME option for editorMatcher to identify which TextView received         // onStartInput event.         editor.setPrivateImeOptions(                 activity.getClass().getName()                         + ""/"" + Long.toString(SystemClock.elapsedRealtimeNanos()));         final LinearLayout layout = new LinearLayout(activity);         layout.setOrientation(LinearLayout.VERTICAL);         layout.addView(editor);         activity.setContentView(layout);          if (showWhenLocked) {             // Set showWhenLocked as true & request focus for showing soft input.             activity.setShowWhenLocked(true);             activity.getWindow().setSoftInputMode(SOFT_INPUT_STATE_ALWAYS_VISIBLE);         }         editor.requestFocus();         return editor;     }      /**      * Waits until the given activity has entered picture-in-picture mode (allowing for the      * subsequent animation to start).      */     private void waitForEnterPip(ComponentName activityName) {         mWmState.waitForValidState(new WaitForValidActivityState.Builder(activityName)                 .setWindowingMode(WINDOWING_MODE_PINNED)                 .setActivityType(ACTIVITY_TYPE_STANDARD)                 .build());     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.view.inputmethod.cts.OnScreenPositionTest"	"launchTestActivity"	"CtsInputMethodTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/OnScreenPositionTest.java"	""	"/*  *.  */  package android.view.inputmethod.cts;  import static com.android.cts.mockime.ImeEventStreamTestUtils.expectBindInput; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEvent; import static com.android.cts.mockime.ImeEventStreamTestUtils.waitForInputViewLayoutStable;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import android.graphics.Rect; import android.os.Process; import android.text.TextUtils; import android.view.inputmethod.EditorInfo; import android.view.inputmethod.cts.util.EndToEndImeTestBase; import android.view.inputmethod.cts.util.TestActivity; import android.view.inputmethod.cts.util.UnlockScreenRule; import android.widget.EditText; import android.widget.LinearLayout;  import androidx.test.filters.MediumTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CtsTouchUtils; import com.android.cts.mockime.ImeEventStream; import com.android.cts.mockime.ImeLayoutInfo; import com.android.cts.mockime.ImeSettings; import com.android.cts.mockime.MockImeSession;  import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference;  @MediumTest @RunWith(AndroidJUnit4.class) public class OnScreenPositionTest extends EndToEndImeTestBase {     private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);     private static final long LAYOUT_STABLE_THRESHOLD = TimeUnit.SECONDS.toMillis(3);      private static final String TEST_MARKER = ""android.view.inputmethod.cts.OnScreenPositionTest"";      @Rule     public final UnlockScreenRule mUnlockScreenRule = new UnlockScreenRule();      public EditText launchTestActivity() {         final AtomicReference<EditText> editTextRef = new AtomicReference<>();         TestActivity.startSync(activity -> {             final LinearLayout layout = new LinearLayout(activity);             layout.setOrientation(LinearLayout.VERTICAL);              final EditText editText = new EditText(activity);             editText.setPrivateImeOptions(TEST_MARKER);             editText.setHint(""editText"");             editText.requestFocus();             editTextRef.set(editText);              layout.addView(editText);             return layout;         });         return editTextRef.get();     }      private static final int EXPECTED_KEYBOARD_HEIGHT = 100;      /**      * Regression test for Bug 33308065.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.PreManagedProfileTest"	"testIsProvisioningAllowedTrue"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DevicePolicyManager.ACTION"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/PreManagedProfileTest.java"	""	"public void testIsProvisioningAllowedTrue() {         assertTrue(mDevicePolicyManager                 .isProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE));     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.PreManagedProfileTest"	"testIsProvisioningAllowedFalse"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DevicePolicyManager.ACTION"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/PreManagedProfileTest.java"	""	"public void testIsProvisioningAllowedFalse() {         assertFalse(mDevicePolicyManager                 .isProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE));     }  }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfileTimeoutTest"	"testWorkProfileTimeoutBackground"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTimeoutTest.java"	""	"public void testWorkProfileTimeoutBackground() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         setUpWorkProfileTimeout();          startDummyActivity(mPrimaryUserId, true);         simulateUserInteraction(PROFILE_TIMEOUT_DELAY_MS);          verifyOnlyProfileLocked(true);     }      /** Profile should get locked if it is in foreground but with no user activity. */     @LargeTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfileTimeoutTest"	"testWorkProfileTimeoutIdleActivity"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTimeoutTest.java"	""	"public void testWorkProfileTimeoutIdleActivity() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         setUpWorkProfileTimeout();          startDummyActivity(mProfileUserId, false);         Thread.sleep(PROFILE_TIMEOUT_DELAY_MS);          verifyOnlyProfileLocked(true);     }      /** User activity in profile should prevent it from locking. */     @FlakyTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfileTimeoutTest"	"testWorkProfileTimeoutUserActivity"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTimeoutTest.java"	""	"public void testWorkProfileTimeoutUserActivity() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         setUpWorkProfileTimeout();          startDummyActivity(mProfileUserId, false);         simulateUserInteraction(PROFILE_TIMEOUT_DELAY_MS);          verifyOnlyProfileLocked(false);     }      /** Keep screen on window flag in the profile should prevent it from locking. */     @FlakyTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfileTimeoutTest"	"testWorkProfileTimeoutKeepScreenOnWindow"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTimeoutTest.java"	""	"public void testWorkProfileTimeoutKeepScreenOnWindow() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         setUpWorkProfileTimeout();          startDummyActivity(mProfileUserId, true);         Thread.sleep(PROFILE_TIMEOUT_DELAY_MS);          verifyOnlyProfileLocked(false);     }      private void setUpWorkProfileTimeout() throws DeviceNotAvailableException {         // Set separate challenge.         changeUserCredential(TEST_PASSWORD, null, mProfileUserId);          // Make sure the profile is not prematurely locked.         verifyUserCredential(TEST_PASSWORD, mProfileUserId);         verifyOnlyProfileLocked(false);         // Set profile timeout to 5 seconds.         runProfileTimeoutTest(""testSetWorkProfileTimeout"", mProfileUserId);     }      private void verifyOnlyProfileLocked(boolean locked) throws DeviceNotAvailableException {         final String expectedResultTest = locked ? ""testDeviceLocked"" : ""testDeviceNotLocked"";         runProfileTimeoutTest(expectedResultTest, mProfileUserId);         // Primary profile shouldn't be locked.         runProfileTimeoutTest(""testDeviceNotLocked"", mPrimaryUserId);     }      private void simulateUserInteraction(int timeMs) throws Exception {         final long endTime = System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(timeMs);         final UserActivityEmulator helper = new UserActivityEmulator(getDevice());         while (System.nanoTime() < endTime) {             helper.tapScreenCenter();             // Just in case to prevent busy loop.             Thread.sleep(100);         }     }      private void runProfileTimeoutTest(String method, int userId)             throws DeviceNotAvailableException {         runDeviceTestsAsUser(MANAGED_PROFILE_PKG, MANAGED_PROFILE_PKG + "".ProfileTimeoutTestHelper"",                 method, userId);     }      private void startDummyActivity(int profileUserId, boolean keepScreenOn) throws Exception {         getDevice().executeShellCommand(String.format(                 ""am start-activity -W --user %d --ez keep_screen_on %s %s/.TimeoutActivity"",                 profileUserId, keepScreenOn, MANAGED_PROFILE_PKG));     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.encryptionapp.EncryptionAppTest"	"testLockScreen"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/test-apps/EncryptionApp/src/com/android/cts/encryptionapp/EncryptionAppTest.java"	""	"public void testLockScreen() throws Exception {         summonKeyguard();     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.encryptionapp.EncryptionAppTest"	"testUnlockScreen"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/test-apps/EncryptionApp/src/com/android/cts/encryptionapp/EncryptionAppTest.java"	""	"public void testUnlockScreen() throws Exception {         dismissKeyguard();     }      public void doBootCountBefore() throws Exception {         final int thisCount = getBootCount();         mDe.getSharedPreferences(KEY_BOOT, 0).edit().putInt(KEY_BOOT, thisCount).commit();     }      public void doBootCountAfter() throws Exception {         final int lastCount = mDe.getSharedPreferences(KEY_BOOT, 0).getInt(KEY_BOOT, -1);         final int thisCount = getBootCount();         assertTrue(""Current boot count "" + thisCount + "" not greater than last "" + lastCount,                 thisCount > lastCount);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.KeyManagementTest"	"testCanSetKeyPairCertChain"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/KeyManagementTest.java"	""	"public void testCanSetKeyPairCertChain() throws Exception {         final String alias = ""com.android.test.set-ec-2"";         try {             KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(                     alias,                     KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_VERIFY)                     .setDigests(KeyProperties.DIGEST_SHA256)                     .build();              AttestedKeyPair generated =                     mDevicePolicyManager.generateKeyPair(getWho(), ""EC"", spec, 0);             assertThat(generated).isNotNull();             List<Certificate> chain = loadCertificateChain(""user-cert-chain.crt"");             mDevicePolicyManager.setKeyPairCertificate(getWho(), alias, chain, true);             // Make sure that the alias can now be obtained.             assertThat(new KeyChainAliasFuture(alias).get()).isEqualTo(alias);             // And can be retrieved from KeyChain             X509Certificate[] fetchedCerts = KeyChain.getCertificateChain(mActivity, alias);             assertThat(fetchedCerts.length).isEqualTo(chain.size());             for (int i = 0; i < chain.size(); i++) {                 assertThat(fetchedCerts[i].getEncoded()).isEqualTo(chain.get(i).getEncoded());             }         } finally {             assertThat(mDevicePolicyManager.removeKeyPair(getWho(), alias)).isTrue();         }     }      private void assertGranted(String alias, boolean expected)             throws InterruptedException, KeyChainException {         boolean granted = (KeyChain.getPrivateKey(mActivity, alias) != null);         assertWithMessage(""Grant for alias: \"""" + alias + ""\"""").that(granted).isEqualTo(expected);     }      private static PrivateKey getPrivateKey(final byte[] key, String type)             throws NoSuchAlgorithmException, InvalidKeySpecException {         return KeyFactory.getInstance(type).generatePrivate(                 new PKCS8EncodedKeySpec(key));     }      private static Certificate getCertificate(byte[] cert) throws CertificateException {         return CertificateFactory.getInstance(""X.509"").generateCertificate(                 new ByteArrayInputStream(cert));     }      private Collection<Certificate> loadCertificatesFromAsset(String assetName) {         try {             final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");             AssetManager am = mActivity.getAssets();             InputStream is = am.open(assetName);             return (Collection<Certificate>) certFactory.generateCertificates(is);         } catch (IOException | CertificateException e) {             e.printStackTrace();         }         return null;     }      private PrivateKey loadPrivateKeyFromAsset(String assetName) {         try {             AssetManager am = mActivity.getAssets();             InputStream is = am.open(assetName);             ByteArrayOutputStream output = new ByteArrayOutputStream();             int length;             byte[] buffer = new byte[4096];             while ((length = is.read(buffer, 0, buffer.length)) != -1) {               output.write(buffer, 0, length);             }             return getPrivateKey(output.toByteArray(), ""RSA"");         } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {             e.printStackTrace();         }         return null;     }      private class KeyChainAliasFuture implements KeyChainAliasCallback {         private final CountDownLatch mLatch = new CountDownLatch(1);         private String mChosenAlias = null;          @Override         public void alias(final String chosenAlias) {             mChosenAlias = chosenAlias;             mLatch.countDown();         }          public KeyChainAliasFuture(String alias)                 throws UnsupportedEncodingException {             /* Pass the alias as a GET to an imaginary server instead of explicitly asking for it,              * to make sure the DPC actually has to do some work to grant the cert.              */             final Uri uri =                     Uri.parse(""https://example.org/?alias="" + URLEncoder.encode(alias, ""UTF-8""));             KeyChain.choosePrivateKeyAlias(mActivity, this,                     null /* keyTypes */, null /* issuers */, uri, null /* alias */);         }          public String get() throws InterruptedException {             assertWithMessage(""Chooser timeout"")                     .that(mLatch.await(KEYCHAIN_TIMEOUT_MINS, TimeUnit.MINUTES))                     .isTrue();             return mChosenAlias;         }     }      protected ComponentName getWho() {         return ADMIN_RECEIVER_COMPONENT;     }      boolean hasStrongBox() {         return mActivity.getPackageManager()             .hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE);     }      boolean isUniqueDeviceAttestationSupported() {         return mDevicePolicyManager.isUniqueDeviceAttestationSupported();     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testApplicationRestrictions"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testApplicationRestrictions() throws Exception {         if (!mHasFeature) {             return;         }          installAppAsUser(DELEGATE_APP_APK, mUserId);         installAppAsUser(APP_RESTRICTIONS_TARGET_APP_APK, mUserId);          try {             // Only the DPC can manage app restrictions by default.             executeDeviceTestClass("".ApplicationRestrictionsTest"");             executeAppRestrictionsManagingPackageTest(""testCannotAccessApis"");              // Letting the DELEGATE_APP_PKG manage app restrictions too.             changeApplicationRestrictionsManagingPackage(DELEGATE_APP_PKG);             executeAppRestrictionsManagingPackageTest(""testCanAccessApis"");             runDeviceTestsAsUser(DELEGATE_APP_PKG, "".GeneralDelegateTest"",                     ""testSettingAdminComponentNameThrowsException"", mUserId);              // The DPC should still be able to manage app restrictions normally.             executeDeviceTestClass("".ApplicationRestrictionsTest"");              // The app shouldn't be able to manage app restrictions for other users.             int parentUserId = getPrimaryUser();             if (parentUserId != mUserId) {                 installAppAsUser(DELEGATE_APP_APK, parentUserId);                 installAppAsUser(APP_RESTRICTIONS_TARGET_APP_APK, parentUserId);                 runDeviceTestsAsUser(DELEGATE_APP_PKG, "".AppRestrictionsDelegateTest"",                         ""testCannotAccessApis"", parentUserId);             }              // Revoking the permission for DELEGAYE_APP_PKG to manage restrictions.             changeApplicationRestrictionsManagingPackage(null);             executeAppRestrictionsManagingPackageTest(""testCannotAccessApis"");              // The DPC should still be able to manage app restrictions normally.             executeDeviceTestClass("".ApplicationRestrictionsTest"");              if (isStatsdEnabled(getDevice())) {                 assertMetricsLogged(getDevice(), () -> {                     executeDeviceTestMethod("".ApplicationRestrictionsTest"",                             ""testSetApplicationRestrictions"");                 }, new DevicePolicyEventWrapper.Builder(EventId.SET_APPLICATION_RESTRICTIONS_VALUE)                         .setAdminPackageName(DEVICE_ADMIN_PKG)                         .setStrings(APP_RESTRICTIONS_TARGET_APP_PKG)                         .build());             }         } finally {             changeApplicationRestrictionsManagingPackage(null);         }     }      /**      * Returns a list of delegation tests that should run. Add delegations tests applicable to both      * device owner and profile owners to this method directly. DO or PO specific tests should be      * added to {@link #getAdditionalDelegationTests} in the subclass.      */     private Map<String, DevicePolicyEventWrapper[]> getDelegationTests() {         final Map<String, DevicePolicyEventWrapper[]> result = new HashMap<>();         result.put("".AppRestrictionsDelegateTest"", null);         result.put("".CertInstallDelegateTest"", null);         result.put("".BlockUninstallDelegateTest"", null);         result.put("".PermissionGrantDelegateTest"", null);         result.put("".PackageAccessDelegateTest"", null);         result.put("".EnableSystemAppDelegateTest"", null);         result.putAll(getAdditionalDelegationTests());         return result;     }      Map<String, DevicePolicyEventWrapper[]> getAdditionalDelegationTests() {         return Collections.<String, DevicePolicyEventWrapper[]>emptyMap();     }      /**      * Returns a list of delegation scopes that are needed to run delegation tests. Add scopes      * which are applicable to both device owner and profile owners to this method directly.      * DO or PO specific scopes should be added to {@link #getAdditionalDelegationScopes}      * in the subclass.      */     private List<String> getDelegationScopes() {         final List<String> result = new ArrayList<>(Arrays.asList(                 DELEGATION_APP_RESTRICTIONS,                 DELEGATION_CERT_INSTALL,                 DELEGATION_BLOCK_UNINSTALL,                 DELEGATION_PERMISSION_GRANT,                 DELEGATION_PACKAGE_ACCESS,                 DELEGATION_ENABLE_SYSTEM_APP,                 // CERT_SELECTION scope is in the list so it still participates GeneralDelegateTest.                 // But its main functionality test is driven by testDelegationCertSelection() and                 // hence missing from getDelegationTests() on purpose.                 DELEGATION_CERT_SELECTION                 ));         result.addAll(getAdditionalDelegationScopes());         return result;     }      List<String> getAdditionalDelegationScopes() {         return Collections.<String>emptyList();     }      /**      * General instructions to add a new delegation test:      * 1. Test primary delegation functionalitiy      *    Implment the delegate's positive/negate functionaility tests in a new test class      *    in CtsDelegateApp.apk. Main entry point are {@code testCanAccessApis} and      *    {@code testCannotAccessApis}. Once implemented, add the delegation scope and the test      *    class name to {@link #getDelegationScopes}, {@link #getDelegationTests} to make the test      *    run on DO/PO/PO on primary user.  If the test should only run on a subset of these      *    combinations, add them to the subclass's {@link #getAdditionalDelegationScopes} and      *    {@link #getDelegationScopes} intead.      *    <p>Alternatively, create a separate hostside method to drive the test, similar to      *    {@link #testDelegationCertSelection}. This is preferred if the delegated functionalities      *    already exist in another app.      * 2. Test access control of DO-only delegation      *    Add the delegation scope to      *    {@code DelegationTest#testDeviceOwnerOnlyDelegationsOnlyPossibleToBeSetByDeviceOwner} to      *    test that only DO can delegate this scope.      * 3. Test behaviour of exclusive delegation      *    Add the delegation scope to {@code DelegationTest#testExclusiveDelegations} to test that      *    the scope can only be delegatd to one app at a time.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testTrustAgentInfo"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testTrustAgentInfo() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         executeDeviceTestClass("".TrustAgentInfoTest"");     }      @FlakyTest(bugId = 141161038)"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testRequiredStrongAuthTimeout"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testRequiredStrongAuthTimeout() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         executeDeviceTestClass("".RequiredStrongAuthTimeoutTest"");     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testResetPasswordDeprecated"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testResetPasswordDeprecated() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         executeDeviceTestMethod("".ResetPasswordTest"", ""testResetPasswordDeprecated"");     }      @LockSettingsTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testResetPasswordWithToken"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testResetPasswordWithToken() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         // If ResetPasswordWithTokenTest for managed profile is executed before device owner and         // primary user profile owner tests, password reset token would have been disabled for         // the primary user, so executing ResetPasswordWithTokenTest on user 0 would fail. We allow         // this and do not fail the test in this case.         // This is the default test for MixedDeviceOwnerTest and MixedProfileOwnerTest,         // MixedManagedProfileOwnerTest overrides this method to execute the same test more strictly         // without allowing failures.         executeResetPasswordWithTokenTests(true);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testGetCurrentFailedPasswordAttempts"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testGetCurrentFailedPasswordAttempts() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         final String wrongPassword = TEST_PASSWORD + ""5"";          changeUserCredential(TEST_PASSWORD, null /*oldCredential*/, mUserId);         try {             // Test that before trying an incorrect password there are 0 failed attempts.             executeDeviceTestMethod("".GetCurrentFailedPasswordAttemptsTest"",                     ""testNoFailedPasswordAttempts"");             // Try an incorrect password.             assertFalse(verifyUserCredentialIsCorrect(wrongPassword, mUserId));             // Test that now there is one failed attempt.             executeDeviceTestMethod("".GetCurrentFailedPasswordAttemptsTest"",                     ""testOneFailedPasswordAttempt"");             // Try an incorrect password.             assertFalse(verifyUserCredentialIsCorrect(wrongPassword, mUserId));             // Test that now there are two failed attempts.             executeDeviceTestMethod("".GetCurrentFailedPasswordAttemptsTest"",                     ""testTwoFailedPasswordAttempts"");             // TODO: re-enable the test below when b/110945754 is fixed.             // Try the correct password and check the failed attempts number has been reset to 0.             // assertTrue(verifyUserCredentialIsCorrect(testPassword, mUserId));             // executeDeviceTestMethod("".GetCurrentFailedPasswordAttemptsTest"",             //         ""testNoFailedPasswordAttempts"");         } finally {             changeUserCredential(null /*newCredential*/, TEST_PASSWORD, mUserId);         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPasswordExpiration"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testPasswordExpiration() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         executeDeviceTestClass("".PasswordExpirationTest"");     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testGetPasswordExpiration"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testGetPasswordExpiration() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         executeDeviceTestMethod("".GetPasswordExpirationTest"",                 ""testGetPasswordExpiration"");         try {             executeDeviceTestMethod("".GetPasswordExpirationTest"",                     ""testGetPasswordExpirationUpdatedAfterPasswordReset_beforeReset"");             // Wait for 20 seconds so we can make sure that the expiration date is refreshed later.             Thread.sleep(20000);             changeUserCredential(TEST_PASSWORD, null, mUserId);             executeDeviceTestMethod("".GetPasswordExpirationTest"",                     ""testGetPasswordExpirationUpdatedAfterPasswordReset_afterReset"");         } finally {             changeUserCredential(null, TEST_PASSWORD, mUserId);         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPasswordQualityWithoutSecureLockScreen"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testPasswordQualityWithoutSecureLockScreen() throws Exception {         if (!mHasFeature || mHasSecureLockScreen) {             return;         }          runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".UnavailableSecureLockScreenTest"", mUserId);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSecondaryLockscreen"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testSecondaryLockscreen() throws Exception {         if (!mHasFeature) {             return;         }         executeDeviceTestClass("".SecondaryLockscreenTest"");     }      private String getLaunchableSystemPackage() throws DeviceNotAvailableException {         final List<String> enabledSystemPackageNames = getEnabledSystemPackageNames();         for (String enabledSystemPackage : enabledSystemPackageNames) {             final String result = getDevice().executeShellCommand(                     String.format(RESOLVE_ACTIVITY_CMD, enabledSystemPackage));             if (!result.contains(""No activity found"")) {                 return enabledSystemPackage;             }         }         return null;     }      private List<String> getEnabledSystemPackageNames() throws DeviceNotAvailableException {         final String commandResult =                 getDevice().executeShellCommand(""pm list packages -e -s --user "" + mUserId);         final int prefixLength = ""package:"".length();         return new ArrayList<>(Arrays.asList(commandResult.split(""\n"")))                 .stream()                 .map(line -> line.substring(prefixLength))                 .collect(Collectors.toList());     }      /**      * Executes a test class on device. Prior to running, turn off background data usage      * restrictions, and restore the original restrictions after the test.      */     private void executeDeviceTestClassNoRestrictBackground(String className) throws Exception {         boolean originalRestriction = ensureRestrictBackgroundPolicyOff();         try {             executeDeviceTestClass(className);         } catch (Exception e) {             throw e;         } finally {             // if the test throws exception, still restore the policy             restoreRestrictBackgroundPolicyTo(originalRestriction);         }     }      protected void executeDeviceTestMethod(String className, String testName) throws Exception {         runDeviceTestsAsUser(DEVICE_ADMIN_PKG, className, testName, mUserId);     }      protected void executeDeviceTestMethod(String className, String testName,             Map<String, String> params) throws Exception {         runDeviceTestsAsUser(DEVICE_ADMIN_PKG, className, testName, mUserId, params);     }      protected void installAppPermissionAppAsUser()             throws FileNotFoundException, DeviceNotAvailableException {         installAppAsUser(PERMISSIONS_APP_APK, false, mUserId);     }      private void executeSuspendPackageTestMethod(String testName) throws Exception {         runDeviceTestsAsUser(INTENT_SENDER_PKG, "".SuspendPackageTest"",                 testName, mUserId);     }      private void executeAccountTest(String testName) throws DeviceNotAvailableException {         runDeviceTestsAsUser(ACCOUNT_MANAGEMENT_PKG, "".AccountManagementTest"",                 testName, mUserId);         // Send a home intent to dismiss an error dialog.         String command = ""am start -a android.intent.action.MAIN""                 + "" -c android.intent.category.HOME"";         CLog.i(""Output for command "" + command + "": "" + getDevice().executeShellCommand(command));     }      private void executeAppRestrictionsManagingPackageTest(String testName) throws Exception {         runDeviceTestsAsUser(DELEGATE_APP_PKG,                 "".AppRestrictionsDelegateTest"", testName, mUserId);     }      private void executeDelegationTests(Map<String, DevicePolicyEventWrapper[]> delegationTests,             boolean positive)             throws Exception {         for (Map.Entry<String, DevicePolicyEventWrapper[]> entry : delegationTests.entrySet()) {             final String delegationTestClass = entry.getKey();             final DevicePolicyEventWrapper[] expectedMetrics = entry.getValue();             final DevicePolicyEventLogVerifier.Action testRun = () -> {                 runDeviceTestsAsUser(DELEGATE_APP_PKG, delegationTestClass,                         positive ? ""testCanAccessApis"" : ""testCannotAccessApis"", mUserId);             };             if (expectedMetrics != null && positive) {                 assertMetricsLogged(getDevice(), testRun, expectedMetrics);             } else {                 testRun.apply();             }         }     }      private void changeUserRestrictionOrFail(String key, boolean value, int userId)             throws DeviceNotAvailableException {         changeUserRestrictionOrFail(key, value, userId, DEVICE_ADMIN_PKG);     }      private void changeAccountManagement(String command, String accountType, int userId)             throws DeviceNotAvailableException {         changePolicyOrFail(command, ""--es extra-account-type "" + accountType, userId);     }      private void changeApplicationRestrictionsManagingPackage(String packageName)             throws DeviceNotAvailableException {         String packageNameExtra = (packageName != null)                 ? ""--es extra-package-name "" + packageName : """";         changePolicyOrFail(""set-app-restrictions-manager"", packageNameExtra, mUserId);     }      protected void setDelegatedScopes(String packageName, List<String> scopes)             throws DeviceNotAvailableException {         final String packageNameExtra = ""--es extra-package-name "" + packageName;         String scopesExtra = """";         if (scopes != null && scopes.size() > 0) {             scopesExtra = ""--esa extra-scopes-list "" + scopes.get(0);             for (int i = 1; i < scopes.size(); ++i) {                 scopesExtra += "","" + scopes.get(i);             }         }         final String extras = packageNameExtra + "" "" + scopesExtra;          changePolicyOrFail(""set-delegated-scopes"", extras, mUserId);     }      private void setInstallPackageAppOps(String packageName, boolean allowed, int userId)             throws DeviceNotAvailableException {         String command = ""appops set --user "" + userId + "" "" + packageName + "" "" +                 ""REQUEST_INSTALL_PACKAGES ""                 + (allowed ? ""allow"" : ""default"");         CLog.d(""Output for command "" + command + "": "" + getDevice().executeShellCommand(command));     }      private void changePolicyOrFail(String command, String extras, int userId)             throws DeviceNotAvailableException {         changePolicyOrFail(command, extras, userId, DEVICE_ADMIN_PKG);     }      /**      * Start SimpleActivity synchronously in a particular user.      */     protected void startSimpleActivityAsUser(int userId) throws Exception {         installAppAsUser(TEST_APP_APK, /* grantPermissions */ true, /* dontKillApp */ true, userId);         startActivityAsUser(userId, TEST_APP_PKG, TEST_APP_PKG + "".SimpleActivity"");     }      protected void setScreenCaptureDisabled(int userId, boolean disabled) throws Exception {         String testMethodName = disabled                 ? ""testSetScreenCaptureDisabled_true""                 : ""testSetScreenCaptureDisabled_false"";         executeDeviceTestMethod("".ScreenCaptureDisabledTest"", testMethodName);          testMethodName = disabled                 ? ""testScreenCaptureImpossible""                 : ""testScreenCapturePossible"";          startSimpleActivityAsUser(userId);         executeDeviceTestMethod("".ScreenCaptureDisabledTest"", testMethodName);         forceStopPackageForUser(TEST_APP_PKG, userId);     }      protected void setScreenCaptureDisabled_assist(int userId, boolean disabled) throws Exception {         // Set the policy.         String testMethodName = disabled                 ? ""testSetScreenCaptureDisabled_true""                 : ""testSetScreenCaptureDisabled_false"";         executeDeviceTestMethod("".ScreenCaptureDisabledTest"", testMethodName);         testMethodName = disabled                 ? ""testScreenCaptureImpossible_assist""                 : ""testScreenCapturePossible_assist"";          // Check whether the VoiceInteractionService can retrieve the screenshot.         installAppAsUser(DEVICE_ADMIN_APK, mPrimaryUserId);          if (userId == mPrimaryUserId) {             // If testing for user-0, also make sure the existing screen can't be captured.             runDeviceTestsAsUser(                     DEVICE_ADMIN_PKG,                     "".AssistScreenCaptureDisabledTest"",                     testMethodName,                     mPrimaryUserId);         }          // Make sure the foreground activity is from the target user.         startSimpleActivityAsUser(userId);          runDeviceTestsAsUser(                 DEVICE_ADMIN_PKG,                 "".AssistScreenCaptureDisabledTest"",                 testMethodName,                 mPrimaryUserId);     }      /**      * Allows packageName to manage notification policy configuration, which      * includes toggling zen mode.      */     private void allowNotificationPolicyAccess(String packageName, int userId)             throws DeviceNotAvailableException {         List<String> enabledPackages = getEnabledNotificationPolicyPackages(userId);         if (!enabledPackages.contains(packageName)) {             enabledPackages.add(packageName);             setEnabledNotificationPolicyPackages(enabledPackages, userId);         }     }      /**      * Disallows packageName to manage notification policy configuration, which      * includes toggling zen mode.      */     private void disallowNotificationPolicyAccess(String packageName, int userId)             throws DeviceNotAvailableException {         List<String> enabledPackages = getEnabledNotificationPolicyPackages(userId);         if (enabledPackages.contains(packageName)) {             enabledPackages.remove(packageName);             setEnabledNotificationPolicyPackages(enabledPackages, userId);         }     }      private void setEnabledNotificationPolicyPackages(List<String> packages, int userId)             throws DeviceNotAvailableException {         getDevice().setSetting(userId, ""secure"", ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES,                 String.join("":"", packages));     }      private List<String> getEnabledNotificationPolicyPackages(int userId)             throws DeviceNotAvailableException {         String settingValue = getDevice().getSetting(userId, ""secure"",                 ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES);         if (settingValue == null) {             return new ArrayList<String>();         }         return new ArrayList<String>(Arrays.asList(settingValue.split("":|\n"")));     }      protected void setVoiceInteractionService(String componentName)             throws DeviceNotAvailableException {         getDevice().setSetting(                 mPrimaryUserId, ""secure"", ""voice_interaction_service"", componentName);         getDevice().setSetting(mPrimaryUserId, ""secure"", ""assist_structure_enabled"", ""1"");         getDevice().setSetting(mPrimaryUserId, ""secure"", ""assist_screenshot_enabled"", ""1"");     }      protected void clearVoiceInteractionService() throws DeviceNotAvailableException {         getDevice().executeShellCommand(""settings delete secure voice_interaction_service"");     }      /**      * Ensure that restrict background policy is off.      * Returns the original status of restrict background policy.      */     private boolean ensureRestrictBackgroundPolicyOff() throws Exception {         String restriction = getDevice().executeShellCommand(RESTRICT_BACKGROUND_GET_CMD);         if (restriction.contains(""enabled"")) {             getDevice().executeShellCommand(RESTRICT_BACKGROUND_OFF_CMD);             return true;         }         return false;     }      private void restoreRestrictBackgroundPolicyTo(boolean restricted) throws Exception {         getDevice().executeShellCommand(                 restricted ? RESTRICT_BACKGROUND_ON_CMD : RESTRICT_BACKGROUND_OFF_CMD);     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.ApplicationHiddenParentTest"	"isNotNull"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationHiddenParentTest.java"	""	"public void test/*  *.  */  package com.android.cts.deviceandprofileowner;  import static com.google.common.truth.Truth.assertThat;  import static org.testng.Assert.assertThrows;  import android.app.admin.DevicePolicyManager; import android.content.pm.PackageManager;  public class ApplicationHiddenParentTest extends BaseDeviceAdminTest {      private DevicePolicyManager mParentDevicePolicyManager;     private PackageManager mPackageManager;      private static final String SYSTEM_PACKAGE_TO_HIDE = ""com.android.keychain"";     private static final String NON_SYSTEM_NON_INSTALLED_PACKAGE = ""com.android.cts.permissionapp"";     private static final String NON_SYSTEM_INSTALLED_PACKAGE =             ""com.android.cts.deviceandprofileowner"";      @Override     protected void setUp() throws Exception {         super.setUp();         mParentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         mPackageManager = mContext.getPackageManager();         assertThat(mParentDevicePolicyManager).isNotNull();          assertThat(mDevicePolicyManager.isProfileOwnerApp(ADMIN_RECEIVER_COMPONENT.getPackageName())).isTrue();         assertThat(mDevicePolicyManager.isOrganizationOwnedDeviceWithManagedProfile()).isTrue();     }      @Override     protected void tearDown() throws Exception {         mParentDevicePolicyManager.setApplicationHidden(ADMIN_RECEIVER_COMPONENT,                 SYSTEM_PACKAGE_TO_HIDE, false);         super.tearDown();     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceowner.PreDeviceOwnerTest"	"testIsProvisioningAllowedFalse"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DevicePolicyManager.ACTION"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/PreDeviceOwnerTest.java"	""	"public void testIsProvisioningAllowedFalse() {         assertFalse(mDevicePolicyManager.isProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE));     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceowner.PreDeviceOwnerTest"	"testIsProvisioningNotAllowedForManagedProfileAction"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DevicePolicyManager.ACTION"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/PreDeviceOwnerTest.java"	""	"public void testIsProvisioningNotAllowedForManagedProfileAction() {         assertFalse(mDevicePolicyManager                 .isProvisioningAllowed(DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE));     }  }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayKeyguardTests"	"testDismissKeyguardActivity_secondaryDisplay"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayKeyguardTests.java"	""	"public void testDismissKeyguardActivity_secondaryDisplay() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();          lockScreenSession.gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();         launchActivityOnDisplay(DISMISS_KEYGUARD_ACTIVITY, newDisplay.mId);         mWmState.waitForKeyguardShowingAndNotOccluded();         mWmState.assertKeyguardShowingAndNotOccluded();         mWmState.assertVisibility(DISMISS_KEYGUARD_ACTIVITY, true);     }      /**      * Tests keyguard dialog shows on secondary display.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayKeyguardTests"	"testShowKeyguardDialogOnSecondaryDisplay"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayKeyguardTests.java"	""	"public void testShowKeyguardDialogOnSecondaryDisplay() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final DisplayContent publicDisplay = createManagedVirtualDisplaySession()                 .setPublicDisplay(true)                 .createDisplay();          lockScreenSession.gotoKeyguard();         mWmState.waitAndAssertKeyguardShownOnSecondaryDisplay(publicDisplay.mId);          // Keyguard dialog mustn't be removed when press back key         pressBackButton();         mWmState.computeState();         mWmState.assertKeyguardShownOnSecondaryDisplay(publicDisplay.mId);     }      /**      * Tests keyguard dialog should exist after secondary display changed.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayKeyguardTests"	"testShowKeyguardDialogSecondaryDisplayChange"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayKeyguardTests.java"	""	"public void testShowKeyguardDialogSecondaryDisplayChange() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final VirtualDisplaySession virtualDisplaySession = createManagedVirtualDisplaySession();          final DisplayContent publicDisplay = virtualDisplaySession                 .setPublicDisplay(true)                 .createDisplay();          lockScreenSession.gotoKeyguard();         mWmState.waitAndAssertKeyguardShownOnSecondaryDisplay(publicDisplay.mId);          // By default, a Presentation object should be dismissed if the DisplayMetrics changed.         // But this rule should not apply to KeyguardPresentation.         virtualDisplaySession.resizeDisplay();         mWmState.computeState();         mWmState.waitAndAssertKeyguardShownOnSecondaryDisplay(publicDisplay.mId);     }      /**      * Tests keyguard dialog should exist after default display changed.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayKeyguardTests"	"testShowKeyguardDialogDefaultDisplayChange"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayKeyguardTests.java"	""	"public void testShowKeyguardDialogDefaultDisplayChange() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final VirtualDisplaySession virtualDisplaySession = createManagedVirtualDisplaySession();         final DisplayMetricsSession displayMetricsSession =                 createManagedDisplayMetricsSession(DEFAULT_DISPLAY);          // Use simulate display instead of virtual display, because VirtualDisplayActivity will         // relaunch after configuration change.         final DisplayContent publicDisplay = virtualDisplaySession                 .setSimulateDisplay(true)                 .createDisplay();          lockScreenSession.gotoKeyguard();         mWmState.waitAndAssertKeyguardShownOnSecondaryDisplay(publicDisplay.mId);          // Unlock then lock again, to ensure the display metrics has updated.         lockScreenSession.wakeUpDevice().unlockDevice();         // Overriding the display metrics on the default display should not affect Keyguard to show         // on secondary display.         final ReportedDisplayMetrics originalDisplayMetrics =                 displayMetricsSession.getInitialDisplayMetrics();         final Size overrideSize = new Size(                 (int) (originalDisplayMetrics.physicalSize.getWidth() * 1.5),                 (int) (originalDisplayMetrics.physicalSize.getHeight() * 1.5));         final Integer overrideDensity = (int) (originalDisplayMetrics.physicalDensity * 1.1);         displayMetricsSession.overrideDisplayMetrics(overrideSize, overrideDensity);          lockScreenSession.gotoKeyguard();         mWmState.waitAndAssertKeyguardShownOnSecondaryDisplay(publicDisplay.mId);     }      /**      * Tests keyguard dialog cannot be shown on private display.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayKeyguardTests"	"testNoKeyguardDialogOnPrivateDisplay"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayKeyguardTests.java"	""	"public void testNoKeyguardDialogOnPrivateDisplay() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final VirtualDisplaySession virtualDisplaySession = createManagedVirtualDisplaySession();          final DisplayContent privateDisplay =                 virtualDisplaySession.setPublicDisplay(false).createDisplay();         final DisplayContent publicDisplay =                 virtualDisplaySession.setPublicDisplay(true).createDisplay();          lockScreenSession.gotoKeyguard();         mWmState.waitAndAssertKeyguardShownOnSecondaryDisplay(publicDisplay.mId);         mWmState.assertKeyguardGoneOnSecondaryDisplay(privateDisplay.mId);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayKeyguardTests"	"testUnlockScreen_secondDisplayChanged_dismissesKeyguardOnUnlock"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayKeyguardTests.java"	""	"public void testUnlockScreen_secondDisplayChanged_dismissesKeyguardOnUnlock() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final VirtualDisplaySession virtualDisplaySession = createManagedVirtualDisplaySession();         lockScreenSession.setLockCredential();          // Create second screen         final DisplayContent secondDisplay = virtualDisplaySession                 .setPublicDisplay(true)                 .createDisplay();         final int secondDisplayId = secondDisplay.mId;          // Lock screen. Keyguard should be shown on the second display         lockScreenSession.gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();         mWmState.waitAndAssertKeyguardShownOnSecondaryDisplay(secondDisplayId);          // Change second display. Keyguard should still be shown on the second display         virtualDisplaySession.resizeDisplay();         mWmState.computeState();         mWmState.waitAndAssertKeyguardShownOnSecondaryDisplay(secondDisplayId);          // Unlock device. Keyguard should be dismissed on the second display         lockScreenSession.unlockDevice();         lockScreenSession.enterAndConfirmLockCredential();         mWmState.waitAndAssertKeyguardGone();         mWmState.waitAndAssertKeyguardGoneOnSecondaryDisplay(secondDisplayId);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayKeyguardTests"	"testUnlockScreen_decoredSystemDisplayChanged_dismissesKeyguardOnUnlock"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayKeyguardTests.java"	""	"public void testUnlockScreen_decoredSystemDisplayChanged_dismissesKeyguardOnUnlock() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final VirtualDisplaySession virtualDisplaySession = createManagedVirtualDisplaySession();         lockScreenSession.setLockCredential();          // Create decored system screen         final DisplayContent decoredSystemDisplay = virtualDisplaySession                 .setSimulateDisplay(true)                 .setShowSystemDecorations(true)                 .createDisplay();         final int decoredSystemDisplayId = decoredSystemDisplay.mId;          // Lock screen. Keyguard should be shown on the decored system display         lockScreenSession.gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();         mWmState.waitAndAssertKeyguardShownOnSecondaryDisplay(decoredSystemDisplayId);          // Change decored display. Keyguard should still be shown on the decored system display         virtualDisplaySession.resizeDisplay();         mWmState.computeState();         mWmState.waitAndAssertKeyguardShownOnSecondaryDisplay(decoredSystemDisplayId);          // Unlock device. Keyguard should be dismissed on the decored system display         lockScreenSession.unlockDevice();         lockScreenSession.enterAndConfirmLockCredential();         mWmState.waitAndAssertKeyguardGone();         mWmState.waitAndAssertKeyguardGoneOnSecondaryDisplay(decoredSystemDisplayId);     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.lifecycle.ActivityLifecycleKeyguardTests"	"testSingleLaunch"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java"	""	"public void testSingleLaunch() throws Exception {         assumeTrue(supportsSecureLock());         try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             lockScreenSession.setLockCredential().gotoKeyguard();              new Launcher(FirstActivity.class)                     .setExpectedState(ON_STOP)                     .setNoInstance()                     .launch();             LifecycleVerifier.assertLaunchAndStopSequence(FirstActivity.class, getLifecycleLog());         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.lifecycle.ActivityLifecycleKeyguardTests"	"testKeyguardShowHide"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java"	""	"public void testKeyguardShowHide() throws Exception {         assumeTrue(supportsSecureLock());          // Launch first activity and wait for resume         final Activity activity = launchActivityAndWait(FirstActivity.class);          // Show and hide lock screen         try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             lockScreenSession.setLockCredential().gotoKeyguard();             waitAndAssertActivityStates(state(activity, ON_STOP));              LifecycleVerifier.assertLaunchAndStopSequence(FirstActivity.class, getLifecycleLog());             getLifecycleLog().clear();         } // keyguard hidden          // Verify that activity was resumed         waitAndAssertActivityStates(state(activity, ON_RESUME));         LifecycleVerifier.assertRestartAndResumeSequence(FirstActivity.class, getLifecycleLog());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.lifecycle.ActivityLifecycleKeyguardTests"	"testKeyguardShowHideOverSplitScreen"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java"	""	"public void testKeyguardShowHideOverSplitScreen() throws Exception {         assumeTrue(supportsSecureLock());         assumeTrue(supportsSplitScreenMultiWindow());          // TODO(b/149338177): Fix test to pass with organizer API.         mUseTaskOrganizer = false;          final Activity firstActivity = launchActivityAndWait(FirstActivity.class);          // Enter split screen         moveTaskToPrimarySplitScreenAndVerify(firstActivity);          // Launch second activity to side         final Activity secondActivity = new Launcher(SecondActivity.class)                 .setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK)                 .launch();          // Show and hide lock screen         getLifecycleLog().clear();         try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             lockScreenSession.setLockCredential().gotoKeyguard();             waitAndAssertActivityStates(state(firstActivity, ON_STOP));             waitAndAssertActivityStates(state(secondActivity, ON_STOP));              LifecycleVerifier.assertResumeToStopSequence(FirstActivity.class, getLifecycleLog());             LifecycleVerifier.assertResumeToStopSequence(SecondActivity.class, getLifecycleLog());             getLifecycleLog().clear();         } // keyguard hidden          waitAndAssertActivityStates(state(firstActivity, ON_RESUME),                 state(secondActivity, ON_RESUME));         LifecycleVerifier.assertRestartAndResumeSequence(FirstActivity.class, getLifecycleLog());         LifecycleVerifier.assertRestartAndResumeSequence(SecondActivity.class, getLifecycleLog());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.lifecycle.ActivityLifecycleKeyguardTests"	"testKeyguardShowHideOverPip"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java"	""	"public void testKeyguardShowHideOverPip() throws Exception {         assumeTrue(supportsSecureLock());         if (!supportsPip()) {             // Skipping test: no Picture-In-Picture support             return;         }          // Launch first activity         final Activity firstActivity = launchActivityAndWait(FirstActivity.class);          // Clear the log before launching to Pip         getLifecycleLog().clear();          // Launch Pip-capable activity and enter Pip immediately         new Launcher(PipActivity.class)                 .setExpectedState(ON_PAUSE)                 .setExtraFlags(EXTRA_ENTER_PIP)                 .launch();          // Wait and assert lifecycle         waitAndAssertActivityStates(state(firstActivity, ON_RESUME));          // Show and hide lock screen         getLifecycleLog().clear();         try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             lockScreenSession.setLockCredential().gotoKeyguard();             waitAndAssertActivityStates(state(firstActivity, ON_STOP));             waitAndAssertActivityStates(state(PipActivity.class, ON_STOP));              LifecycleVerifier.assertResumeToStopSequence(FirstActivity.class, getLifecycleLog());             LifecycleVerifier.assertSequence(PipActivity.class, getLifecycleLog(),                     Arrays.asList(ON_STOP), ""keyguardShown"");             getLifecycleLog().clear();         } // keyguard hidden          // Wait and assert lifecycle         waitAndAssertActivityStates(state(firstActivity, ON_RESUME),                 state(PipActivity.class, ON_PAUSE));         LifecycleVerifier.assertRestartAndResumeSequence(FirstActivity.class, getLifecycleLog());         LifecycleVerifier.assertSequence(PipActivity.class, getLifecycleLog(),                 Arrays.asList(ON_RESTART, ON_START, ON_RESUME, ON_PAUSE), ""keyguardGone"");     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.SecondaryLockscreenTest"	"testSetSecondaryLockscreenEnabled"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SecondaryLockscreenTest.java"	""	"public void testSetSecondaryLockscreenEnabled() throws Exception {         try {             mDevicePolicyManager.setSecondaryLockscreenEnabled(ADMIN_RECEIVER_COMPONENT, true);             assertTrue(mDevicePolicyManager.isSecondaryLockscreenEnabled(Process.myUserHandle()));             enterKeyguardPin();             assertTrue(""Lockscreen title not shown"",                     mUiDevice.wait(Until.hasObject(By.text(SimpleKeyguardService.TITLE_LABEL)),                             UI_AUTOMATOR_WAIT_TIME_MILLIS));              mDevicePolicyManager.setSecondaryLockscreenEnabled(ADMIN_RECEIVER_COMPONENT, false);              // Verify that the lockscreen is dismissed after disabling the feature             assertFalse(mDevicePolicyManager.isSecondaryLockscreenEnabled(Process.myUserHandle()));             verifyHomeLauncherIsShown();         } catch (SecurityException expected) {             assertThat(expected.getMessage()).contains(""default supervision component"");         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.SecondaryLockscreenTest"	"testHomeButton"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SecondaryLockscreenTest.java"	""	"public void testHomeButton() throws Exception {         try {             mDevicePolicyManager.setSecondaryLockscreenEnabled(ADMIN_RECEIVER_COMPONENT, true);             assertTrue(mDevicePolicyManager.isSecondaryLockscreenEnabled(Process.myUserHandle()));             enterKeyguardPin();             assertTrue(""Lockscreen title not shown"",                     mUiDevice.wait(Until.hasObject(By.text(SimpleKeyguardService.TITLE_LABEL)),                             UI_AUTOMATOR_WAIT_TIME_MILLIS));              // Verify that pressing home does not dismiss the lockscreen             mUiDevice.pressHome();             verifySecondaryLockscreenIsShown();         } catch (SecurityException expected) {             assertThat(expected.getMessage()).contains(""default supervision component"");         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.SecondaryLockscreenTest"	"testDismiss"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SecondaryLockscreenTest.java"	""	"public void testDismiss() throws Exception {         try {             mDevicePolicyManager.setSecondaryLockscreenEnabled(ADMIN_RECEIVER_COMPONENT, true);             assertTrue(mDevicePolicyManager.isSecondaryLockscreenEnabled(Process.myUserHandle()));             enterKeyguardPin();             assertTrue(""Lockscreen title not shown"",                     mUiDevice.wait(Until.hasObject(By.text(SimpleKeyguardService.TITLE_LABEL)),                             UI_AUTOMATOR_WAIT_TIME_MILLIS));              mUiDevice.findObject(By.text(SimpleKeyguardService.DISMISS_BUTTON_LABEL)).click();             verifyHomeLauncherIsShown();              // Verify that the feature is not disabled after dismissal             enterKeyguardPin();             assertTrue(mUiDevice.wait(Until.hasObject(By.text(SimpleKeyguardService.TITLE_LABEL)),                     UI_AUTOMATOR_WAIT_TIME_MILLIS));             verifySecondaryLockscreenIsShown();         } catch (SecurityException expected) {             assertThat(expected.getMessage()).contains(""default supervision component"");         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.SecondaryLockscreenTest"	"testSetSecondaryLockscreen_ineligibleAdmin_throwsSecurityException"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SecondaryLockscreenTest.java"	""	"public void testSetSecondaryLockscreen_ineligibleAdmin_throwsSecurityException() {         final ComponentName badAdmin = new ComponentName(""com.foo.bar"", "".NonProfileOwnerReceiver"");         assertThrows(SecurityException.class,                 () -> mDevicePolicyManager.setSecondaryLockscreenEnabled(badAdmin, true));     }      private void enterKeyguardPin() throws Exception {         final PowerManager pm = mContext.getSystemService(PowerManager.class);         runShellCommand(""input keyevent KEYCODE_SLEEP"");         waitUntil(""Device still interactive"", 5,                 () -> pm != null && !pm.isInteractive());         runShellCommand(""input keyevent KEYCODE_WAKEUP"");         waitUntil(""Device still not interactive"", 5,                 () -> pm.isInteractive());         runShellCommand(""wm dismiss-keyguard"");         mUiDevice.wait(Until.hasObject(By.res(""com.android.systemui"", ""pinEntry"")),                 UI_AUTOMATOR_WAIT_TIME_MILLIS);         runShellCommand(""input text 1234"");         runShellCommand(""input keyevent KEYCODE_ENTER"");     }      private void verifyHomeLauncherIsShown() {         String launcherPackageName = getLauncherPackageName();         assertTrue(""Lockscreen title is unexpectedly shown"",                 mUiDevice.wait(Until.gone(By.text(SimpleKeyguardService.TITLE_LABEL)),                         UI_AUTOMATOR_WAIT_TIME_MILLIS));         assertTrue(String.format(""Launcher (%s) is not shown"", launcherPackageName),                 mUiDevice.wait(Until.hasObject(By.pkg(launcherPackageName)),                         UI_AUTOMATOR_WAIT_TIME_MILLIS));     }      private void verifySecondaryLockscreenIsShown() {         String launcherPackageName = getLauncherPackageName();         assertTrue(""Lockscreen title is unexpectedly not shown"",                 mUiDevice.wait(Until.hasObject(By.text(SimpleKeyguardService.TITLE_LABEL)),                         UI_AUTOMATOR_WAIT_TIME_MILLIS));         assertTrue(String.format(""Launcher (%s) is unexpectedly shown"", launcherPackageName),                 mUiDevice.wait(Until.gone(By.pkg(launcherPackageName)),                         UI_AUTOMATOR_WAIT_TIME_MILLIS));     }      private String getLauncherPackageName() {         Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);         List<ResolveInfo> resolveInfos = mContext.getPackageManager().queryIntentActivities(                 homeIntent, 0);         StringBuilder sb = new StringBuilder();         for (ResolveInfo resolveInfo : resolveInfos) {             sb.append(resolveInfo.activityInfo.packageName).append(""/"").append(                     resolveInfo.activityInfo.name).append("", "");         }         return resolveInfos.isEmpty() ? null : resolveInfos.get(0).activityInfo.packageName;     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.view.inputmethod.cts.ImeInsetsVisibilityTest"	"getTestMarker"	"CtsInputMethodTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/ImeInsetsVisibilityTest.java"	""	"/*  *.  */  package android.view.inputmethod.cts;  import static android.content.Intent.ACTION_CLOSE_SYSTEM_DIALOGS; import static android.content.Intent.FLAG_RECEIVER_FOREGROUND; import static android.view.WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM; import static android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE; import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION; import static android.view.inputmethod.cts.util.InputMethodVisibilityVerifier.expectImeInvisible; import static android.view.inputmethod.cts.util.InputMethodVisibilityVerifier.expectImeVisible;  import static com.android.cts.mockime.ImeEventStreamTestUtils.editorMatcher; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEvent; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEventWithKeyValue; import static com.android.cts.mockime.ImeEventStreamTestUtils.notExpectEvent;  import static org.junit.Assert.assertTrue;  import android.app.Activity; import android.content.Context; import android.content.Intent; import android.content.pm.PackageManager; import android.content.res.Configuration; import android.graphics.PixelFormat; import android.graphics.Point; import android.os.SystemClock; import android.platform.test.annotations.AppModeFull; import android.util.Pair; import android.view.Gravity; import android.view.View; import android.view.WindowInsets; import android.view.WindowInsetsController; import android.view.WindowManager; import android.view.inputmethod.InputMethodManager; import android.view.inputmethod.cts.util.EndToEndImeTestBase; import android.view.inputmethod.cts.util.TestActivity; import android.view.inputmethod.cts.util.TestUtils; import android.view.inputmethod.cts.util.UnlockScreenRule; import android.widget.EditText; import android.widget.LinearLayout; import android.widget.TextView;  import androidx.annotation.NonNull;  import com.android.compatibility.common.util.CtsTouchUtils; import com.android.compatibility.common.util.PollingCheck; import com.android.cts.mockime.ImeEventStream; import com.android.cts.mockime.ImeSettings; import com.android.cts.mockime.MockImeSession;  import androidx.test.filters.MediumTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.Arrays; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference;  @MediumTest @RunWith(AndroidJUnit4.class) public class ImeInsetsVisibilityTest extends EndToEndImeTestBase {     private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);     private static final int NEW_KEYBOARD_HEIGHT = 300;      private static final String TEST_MARKER_PREFIX =             ""android.view.inputmethod.cts.ImeInsetsVisibilityTest"";      private static String getTestMarker() {         return TEST_MARKER_PREFIX + ""/""  + SystemClock.elapsedRealtimeNanos();     }      @Rule     public final UnlockScreenRule mUnlockScreenRule = new UnlockScreenRule();"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"testQuietMode_defaultForegroundLauncher"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	"public void testQuietMode_defaultForegroundLauncher() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         // Add a lockscreen to test the case that profile with unified challenge can still         // be turned on without asking the user to enter the lockscreen password.         changeUserCredential(/* newCredential= */ TEST_PASSWORD, /* oldCredential= */ null,                 mPrimaryUserId);         try {             runDeviceTestsAsUser(                     TEST_PACKAGE,                     TEST_CLASS,                     ""testTryEnableQuietMode_defaultForegroundLauncher"",                     mPrimaryUserId,                     createParams(mProfileId));         } finally {             changeUserCredential(/* newCredential= */ null, /* oldCredential= */ TEST_PASSWORD,                     mPrimaryUserId);         }     }      @LargeTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"testQuietMode_noCredentialRequest"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	"public void testQuietMode_noCredentialRequest() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         // Set a separate work challenge so turning on the profile requires entering the         // separate challenge.         changeUserCredential(/* newCredential= */ TEST_PASSWORD, /* oldCredential= */ null,                 mProfileId);         runDeviceTestsAsUser(                 TEST_PACKAGE,                 TEST_CLASS,                 ""testTryEnableQuietMode_noCredentialRequest"",                 mPrimaryUserId,                 createParams(mProfileId));     }      private void createAndStartManagedProfile() throws Exception {         mProfileId = createManagedProfile(mPrimaryUserId);         switchUser(mPrimaryUserId);         startUser(mProfileId);     }      private void uninstallRequiredApps()             throws DeviceNotAvailableException {         getDevice().uninstallPackage(TEST_PACKAGE);         getDevice().uninstallPackage(ENABLED_TEST_PACKAGE);         getDevice().uninstallPackage(USER_ENABLED_TEST_PACKAGE);         getDevice().uninstallPackage(ENABLED_NO_PERMS_TEST_PACKAGE);         getDevice().uninstallPackage(NOT_ENABLED_TEST_PACKAGE);         getDevice().uninstallPackage(QUIET_MODE_ENABLED_TEST_PACKAGE);     }      private void installCrossProfileApps()             throws FileNotFoundException, DeviceNotAvailableException {         installCrossProfileApp(ENABLED_TEST_APK, /* grantPermissions= */ true);         installCrossProfileApp(USER_ENABLED_TEST_APK, /* grantPermissions= */ true);         installCrossProfileApp(NOT_ENABLED_TEST_APK, /* grantPermissions= */ true);         installCrossProfileApp(ENABLED_NO_PERMS_TEST_APK, /* grantPermissions= */  false);         installCrossProfileApp(QUIET_MODE_ENABLED_TEST_APK, /* grantPermissions= */  true);     }      private void enableCrossProfileAppsOp() throws DeviceNotAvailableException {         enableCrossProfileAppsOp(ENABLED_NO_PERMS_TEST_PACKAGE, mPrimaryUserId);     }      private void installCrossProfileApp(String apkName, boolean grantPermissions)             throws FileNotFoundException, DeviceNotAvailableException {         installAppAsUser(apkName, grantPermissions, mPrimaryUserId);         installAppAsUser(apkName, grantPermissions, mProfileId);     }      private void enableCrossProfileAppsOp(String packageName, int userId)             throws DeviceNotAvailableException {         getDevice().executeShellCommand(                 String.format(""appops set --user %s %s android:interact_across_profiles 0"",                         userId, packageName));         assertThat(getDevice().executeShellCommand(                 String.format(""appops get --user %s %s android:interact_across_profiles"",                         userId, packageName))).contains(""INTERACT_ACROSS_PROFILES: allow"");     }      private Map<String, String> createParams(int targetUserId) throws Exception {         Map<String, String> params = new HashMap<>();         params.put(PARAM_TARGET_USER, Integer.toString(getUserSerialNumber(targetUserId)));         params.put(PARAM_ORIGINAL_DEFAULT_LAUNCHER, mOriginalLauncher);         return params;     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTestApi25"	"testResetPasswordDeprecated"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTestApi25.java"	""	"public void testResetPasswordDeprecated() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         executeDeviceTestMethod("".ResetPasswordTest"", ""testResetPasswordDeprecated"");     }      protected void executeDeviceTestClass(String className) throws Exception {         runDeviceTestsAsUser(DEVICE_ADMIN_PKG, className, mUserId);     }      protected void executeDeviceTestMethod(String className, String testName) throws Exception {         runDeviceTestsAsUser(DEVICE_ADMIN_PKG, className, testName, mUserId);     }      /**      * Start SimpleActivity synchronously in a particular user.      */     protected void startSimpleActivityAsUser(int userId) throws Exception {         installAppAsUser(TEST_APP_APK, userId);         String command = ""am start -W --user "" + userId + "" "" + TEST_APP_PKG + ""/""                 + TEST_APP_PKG + "".SimpleActivity"";         getDevice().executeShellCommand(command);     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTransitionTests"	"testUnlock"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTransitionTests.java"	""	"public void testUnlock() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(TEST_ACTIVITY);         lockScreenSession.gotoKeyguard().unlockDevice();         mWmState.computeState(TEST_ACTIVITY);         assertEquals(""Picked wrong transition"", TRANSIT_KEYGUARD_GOING_AWAY,                 mWmState.getDefaultDisplayLastTransition());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTransitionTests"	"testUnlockWallpaper"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTransitionTests.java"	""	"public void testUnlockWallpaper() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(WALLPAPAER_ACTIVITY);         lockScreenSession.gotoKeyguard().unlockDevice();         mWmState.computeState(WALLPAPAER_ACTIVITY);         assertEquals(""Picked wrong transition"", TRANSIT_KEYGUARD_GOING_AWAY_ON_WALLPAPER,                 mWmState.getDefaultDisplayLastTransition());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTransitionTests"	"testOcclude"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTransitionTests.java"	""	"public void testOcclude() {         createManagedLockScreenSession().gotoKeyguard();         launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);         assertEquals(""Picked wrong transition"", TRANSIT_KEYGUARD_OCCLUDE,                 mWmState.getDefaultDisplayLastTransition());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTransitionTests"	"testUnocclude"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTransitionTests.java"	""	"public void testUnocclude() {         createManagedLockScreenSession().gotoKeyguard();         launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         launchActivity(TEST_ACTIVITY);         mWmState.waitForKeyguardShowingAndNotOccluded();         mWmState.computeState();         assertEquals(""Picked wrong transition"", TRANSIT_KEYGUARD_UNOCCLUDE,                 mWmState.getDefaultDisplayLastTransition());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTransitionTests"	"testNewActivityDuringOccluded"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTransitionTests.java"	""	"public void testNewActivityDuringOccluded() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         lockScreenSession.gotoKeyguard(SHOW_WHEN_LOCKED_ACTIVITY);         launchActivity(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY);         assertEquals(""Picked wrong transition"", TRANSIT_ACTIVITY_OPEN,                 mWmState.getDefaultDisplayLastTransition());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTransitionTests"	"testOccludeManifestAttr"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTransitionTests.java"	""	"public void testOccludeManifestAttr() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.gotoKeyguard();         separateTestJournal();         launchActivity(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         assertEquals(""Picked wrong transition"", TRANSIT_KEYGUARD_OCCLUDE,                 mWmState.getDefaultDisplayLastTransition());         assertSingleLaunch(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTransitionTests"	"testOccludeAttrRemove"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTransitionTests.java"	""	"public void testOccludeAttrRemove() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.gotoKeyguard();         separateTestJournal();         launchActivity(SHOW_WHEN_LOCKED_ATTR_REMOVE_ATTR_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ATTR_REMOVE_ATTR_ACTIVITY);         assertEquals(""Picked wrong transition"", TRANSIT_KEYGUARD_OCCLUDE,                 mWmState.getDefaultDisplayLastTransition());         assertSingleLaunch(SHOW_WHEN_LOCKED_ATTR_REMOVE_ATTR_ACTIVITY);          // Waiting for the standard keyguard since         // {@link SHOW_WHEN_LOCKED_ATTR_REMOVE_ATTR_ACTIVITY} called         // {@link Activity#showWhenLocked(boolean)} and removed the attribute.         lockScreenSession.gotoKeyguard();         separateTestJournal();         // Waiting for {@link SHOW_WHEN_LOCKED_ATTR_REMOVE_ATTR_ACTIVITY} stopped since it         // already lost show-when-locked attribute.         launchActivityNoWait(SHOW_WHEN_LOCKED_ATTR_REMOVE_ATTR_ACTIVITY);         mWmState.waitForActivityState(SHOW_WHEN_LOCKED_ATTR_REMOVE_ATTR_ACTIVITY, STATE_STOPPED);         assertSingleStartAndStop(SHOW_WHEN_LOCKED_ATTR_REMOVE_ATTR_ACTIVITY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTransitionTests"	"testNewActivityDuringOccludedWithAttr"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTransitionTests.java"	""	"public void testNewActivityDuringOccludedWithAttr() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         lockScreenSession.gotoKeyguard(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         launchActivity(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY);         assertEquals(""Picked wrong transition"", TRANSIT_ACTIVITY_OPEN,                 mWmState.getDefaultDisplayLastTransition());     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.admin.cts.DevicePolicyManagerTest"	"testSetResetPasswordToken_failIfNotDeviceOrProfileOwner"	"CtsAdminTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testSetResetPasswordToken_failIfNotDeviceOrProfileOwner() {         if (!mDeviceAdmin || !mHasSecureLockScreen) {             Log.w(TAG, ""Skipping testSetResetPasswordToken_failIfNotDeviceOwner"");             return;         }         try {             mDevicePolicyManager.setResetPasswordToken(mComponent, new byte[32]);             fail(""did not throw expected SecurityException"");         } catch (SecurityException e) {             assertProfileOwnerMessage(e.getMessage());         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.admin.cts.DevicePolicyManagerTest"	"testClearResetPasswordToken_failIfNotDeviceOrProfileOwner"	"CtsAdminTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testClearResetPasswordToken_failIfNotDeviceOrProfileOwner() {         if (!mDeviceAdmin || !mHasSecureLockScreen) {             Log.w(TAG, ""Skipping testClearResetPasswordToken_failIfNotDeviceOwner"");             return;         }         try {             mDevicePolicyManager.clearResetPasswordToken(mComponent);             fail(""did not throw expected SecurityException"");         } catch (SecurityException e) {             assertProfileOwnerMessage(e.getMessage());         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.admin.cts.DevicePolicyManagerTest"	"testIsResetPasswordTokenActive_failIfNotDeviceOrProfileOwner"	"CtsAdminTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testIsResetPasswordTokenActive_failIfNotDeviceOrProfileOwner() {         if (!mDeviceAdmin || !mHasSecureLockScreen) {             Log.w(TAG, ""Skipping testIsResetPasswordTokenActive_failIfNotDeviceOwner"");             return;         }         try {             mDevicePolicyManager.isResetPasswordTokenActive(mComponent);             fail(""did not throw expected SecurityException"");         } catch (SecurityException e) {             assertProfileOwnerMessage(e.getMessage());         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.admin.cts.DevicePolicyManagerTest"	"testResetPasswordWithToken_failIfNotDeviceOrProfileOwner"	"CtsAdminTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testResetPasswordWithToken_failIfNotDeviceOrProfileOwner() {         if (!mDeviceAdmin || !mHasSecureLockScreen) {             Log.w(TAG, ""Skipping testResetPasswordWithToken_failIfNotDeviceOwner"");             return;         }         try {             mDevicePolicyManager.resetPasswordWithToken(mComponent, ""1234"", new byte[32], 0);             fail(""did not throw expected SecurityException"");         } catch (SecurityException e) {             assertProfileOwnerMessage(e.getMessage());         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.admin.cts.DevicePolicyManagerTest"	"testIsUsingUnifiedPassword_failIfNotProfileOwner"	"CtsAdminTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	"public void testIsUsingUnifiedPassword_failIfNotProfileOwner() {         if (!mDeviceAdmin || !mHasSecureLockScreen) {             Log.w(TAG, ""Skipping testIsUsingUnifiedPassword_failIfNotProfileOwner"");             return;         }         try {             mDevicePolicyManager.isUsingUnifiedPassword(mComponent);             fail(""did not throw expected SecurityException"");         } catch (SecurityException e) {             assertProfileOwnerMessage(e.getMessage());         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.SecurityLoggingTest"	"testVerifyGeneratedLogs"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SecurityLoggingTest.java"	""	"public void testVerifyGeneratedLogs() throws Exception {         final List<SecurityEvent> events = getEvents();         verifyAutomaticEventsPresent(events);         verifyKeystoreEventsPresent(events);         verifyKeyChainEventsPresent(events);         verifyAdminEventsPresent(events);         verifyAdbShellCommand(events); // Event generated from host side logic         if (mDevicePolicyManager.isOrganizationOwnedDeviceWithManagedProfile()) {             verifyEventsRedacted(events);         }     }      private void verifyAutomaticEventsPresent(List<SecurityEvent> events) {         verifyOsStartupEventPresent(events);         verifyLoggingStartedEventPresent(events);         verifyCryptoSelfTestEventPresent(events);     }      private void verifyKeyChainEventsPresent(List<SecurityEvent> events) {         verifyCertInstalledEventPresent(events);         verifyCertUninstalledEventPresent(events);     }      private void verifyKeystoreEventsPresent(List<SecurityEvent> events) {         verifyKeyGeneratedEventPresent(events, GENERATED_KEY_ALIAS);         verifyKeyDeletedEventPresent(events, GENERATED_KEY_ALIAS);         verifyKeyImportedEventPresent(events, IMPORTED_KEY_ALIAS);         verifyKeyDeletedEventPresent(events, IMPORTED_KEY_ALIAS);     }      private void verifyAdminEventsPresent(List<SecurityEvent> events) {         if (mHasSecureLockScreen) {             verifyPasswordComplexityEventsPresent(events);         }         verifyLockingPolicyEventsPresent(events);         verifyUserRestrictionEventsPresent(events);         verifyCameraPolicyEvents(events);     }     private void verifyAdbShellCommand(List<SecurityEvent> events) {         // Won't be able to locate the command on org-owned devices, as it will be redacted.         if (!mDevicePolicyManager.isOrganizationOwnedDeviceWithManagedProfile()) {             findEvent(""adb command"", events,                     e -> e.getTag() == TAG_ADB_SHELL_CMD &&                             e.getData().equals(""whoami""));          }     }      private void verifyEventsRedacted(List<SecurityEvent> events) {         final int userId = Process.myUserHandle().getIdentifier();         for (SecurityEvent event : events) {             switch (event.getTag()) {                 case TAG_ADB_SHELL_CMD:                     assertTrue(TextUtils.isEmpty((String) event.getData()));                     break;                 case TAG_APP_PROCESS_START:                 case TAG_KEY_GENERATED:                 case TAG_KEY_IMPORT:                 case TAG_KEY_DESTRUCTION:                     assertEquals(userId, UserHandle.getUserId(getInt(event, UID_INDEX)));                     break;                 case TAG_CERT_AUTHORITY_INSTALLED:                 case TAG_CERT_AUTHORITY_REMOVED:                     assertEquals(userId, getInt(event, USERID_INDEX));                     break;                 case TAG_KEY_INTEGRITY_VIOLATION:                     assertEquals(userId, UserHandle.getUserId(getInt(event, 1)));                     break;             }         }     }      /**      * Generates events for positive test cases.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.SecurityLoggingTest"	"testGenerateLogs"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SecurityLoggingTest.java"	""	"public void testGenerateLogs() throws Exception {         generateKeystoreEvents();         generateKeyChainEvents();         generateAdminEvents();     }      private void generateKeyChainEvents() {         installCaCert();         uninstallCaCert();     }      private void generateKeystoreEvents() throws Exception {         generateKey(GENERATED_KEY_ALIAS);         deleteKey(GENERATED_KEY_ALIAS);         importKey(IMPORTED_KEY_ALIAS);         deleteKey(IMPORTED_KEY_ALIAS);     }      private void generateAdminEvents() {         if (mHasSecureLockScreen) {             generatePasswordComplexityEvents();         }         generateLockingPolicyEvents();         generateUserRestrictionEvents();         generateCameraPolicyEvents();     }      /**      * Fetches and sanity-checks the events.      */     private List<SecurityEvent> getEvents() throws Exception {         List<SecurityEvent> events = null;         // Retry once after seeping for 1 second, in case ""dpm force-security-logs"" hasn't taken         // effect just yet.         for (int i = 0; i < 2 && events == null; i++) {             events = mDevicePolicyManager.retrieveSecurityLogs(ADMIN_RECEIVER_COMPONENT);             if (events == null) Thread.sleep(1000);         }         try {             verifySecurityLogs(events);         } catch (AssertionFailedError e) {             dumpSecurityLogs(events);             throw e;         }          return events;     }      private void dumpSecurityLogs(List<SecurityEvent> events) {         Log.d(TAG, ""Security events dump:"");         for (SecurityEvent event : events) {             Log.d(TAG, event.toString());         }     }      /**      * Test: check that there are no gaps between ids in two consecutive batches. Shared preference      * is used to store these numbers between test invocations.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.SecurityLoggingTest"	"testSecurityLoggingRetrievalRateLimited"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SecurityLoggingTest.java"	""	"public void testSecurityLoggingRetrievalRateLimited() {         final List<SecurityEvent> logs = mDevicePolicyManager.retrieveSecurityLogs(                 ADMIN_RECEIVER_COMPONENT);         // if logs is null it means that that attempt was rate limited => test PASS         if (logs != null) {             assertNull(mDevicePolicyManager.retrieveSecurityLogs(ADMIN_RECEIVER_COMPONENT));             assertNull(mDevicePolicyManager.retrieveSecurityLogs(ADMIN_RECEIVER_COMPONENT));         }     }      private void generateKey(String keyAlias) throws Exception {         final KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"", ""AndroidKeyStore"");         generator.initialize(                 new KeyGenParameterSpec.Builder(keyAlias, KeyProperties.PURPOSE_SIGN).build());         final KeyPair keyPair = generator.generateKeyPair();         assertNotNull(keyPair);     }      private void verifyKeyGeneratedEventPresent(List<SecurityEvent> events, String alias) {         findEvent(""key generated"", events,                 e -> e.getTag() == TAG_KEY_GENERATED                         && getInt(e, SUCCESS_INDEX) == SUCCESS_VALUE                         && getString(e, ALIAS_INDEX).contains(alias)                         && getInt(e, UID_INDEX) == Process.myUid());     }      private void importKey(String alias) throws Exception{         final KeyStore ks = KeyStore.getInstance(""AndroidKeyStore"");         ks.load(null);         ks.setEntry(alias, new KeyStore.SecretKeyEntry(new SecretKeySpec(new byte[32], ""AES"")),                 new KeyProtection.Builder(KeyProperties.PURPOSE_ENCRYPT).build());     }      private void verifyKeyImportedEventPresent(List<SecurityEvent> events, String alias) {         findEvent(""key imported"", events,                 e -> e.getTag() == TAG_KEY_IMPORT                         && getInt(e, SUCCESS_INDEX) == SUCCESS_VALUE                         && getString(e, ALIAS_INDEX).contains(alias)                         && getInt(e, UID_INDEX) == Process.myUid());     }      private void deleteKey(String keyAlias) throws Exception {         final KeyStore ks = KeyStore.getInstance(""AndroidKeyStore"");         ks.load(null);         ks.deleteEntry(keyAlias);     }      private void verifyKeyDeletedEventPresent(List<SecurityEvent> events, String alias) {         findEvent(""key deleted"", events,                 e -> e.getTag() == TAG_KEY_DESTRUCTION                         && getInt(e, SUCCESS_INDEX) == SUCCESS_VALUE                         && getString(e, ALIAS_INDEX).contains(alias)                         && getInt(e, UID_INDEX) == Process.myUid());     }      private void installCaCert() {         assertTrue(                 mDevicePolicyManager.installCaCert(ADMIN_RECEIVER_COMPONENT, TEST_CA.getBytes()));     }      private void verifyCertInstalledEventPresent(List<SecurityEvent> events) {         findEvent(""cert authority installed"", events,                 e -> e.getTag() == TAG_CERT_AUTHORITY_INSTALLED                         && getInt(e, SUCCESS_INDEX) == SUCCESS_VALUE                         && getString(e, SUBJECT_INDEX).equals(TEST_CA_SUBJECT));     }      private void uninstallCaCert() {         mDevicePolicyManager.uninstallCaCert(ADMIN_RECEIVER_COMPONENT, TEST_CA.getBytes());     }      private void verifyCertUninstalledEventPresent(List<SecurityEvent> events) {         findEvent(""cert authority removed"", events,                 e -> e.getTag() == TAG_CERT_AUTHORITY_REMOVED                         && getInt(e, SUCCESS_INDEX) == SUCCESS_VALUE                         && getString(e, SUBJECT_INDEX).equals(TEST_CA_SUBJECT));     }      private void generatePasswordComplexityEvents() {         mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_COMPLEX);         mDevicePolicyManager.setPasswordMinimumLength(ADMIN_RECEIVER_COMPONENT, TEST_PWD_LENGTH);         mDevicePolicyManager.setPasswordMinimumLetters(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);         mDevicePolicyManager.setPasswordMinimumNonLetter(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);         mDevicePolicyManager.setPasswordMinimumUpperCase(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);         mDevicePolicyManager.setPasswordMinimumLowerCase(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);         mDevicePolicyManager.setPasswordMinimumNumeric(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);         mDevicePolicyManager.setPasswordMinimumSymbols(ADMIN_RECEIVER_COMPONENT, TEST_PWD_CHARS);     }      private void verifyPasswordComplexityEventsPresent(List<SecurityEvent> events) {         final int userId = Process.myUserHandle().getIdentifier();         // This reflects default values for password complexity event payload fields.         final Object[] expectedPayload = new Object[] {                 ADMIN_RECEIVER_COMPONENT.getPackageName(), // admin package                 userId,                    // admin user                 userId,                    // target user                 0,                         // default password length                 0,                         // default password quality                 1,                         // default min letters                 0,                         // default min non-letters                 1,                         // default min numeric                 0,                         // default min uppercase                 0,                         // default min lowercase                 1,                         // default min symbols         };          // The order should be consistent with the order in generatePasswordComplexityEvents(), so         // that the expected values change in the same sequence as when setting password policies.         expectedPayload[PWD_QUALITY_INDEX] = PASSWORD_QUALITY_COMPLEX;         findPasswordComplexityEvent(""set pwd quality"", events, expectedPayload);         expectedPayload[PWD_LEN_INDEX] = TEST_PWD_LENGTH;         findPasswordComplexityEvent(""set pwd length"", events, expectedPayload);         expectedPayload[LETTERS_INDEX] = TEST_PWD_CHARS;         findPasswordComplexityEvent(""set pwd min letters"", events, expectedPayload);         expectedPayload[NON_LETTERS_INDEX] = TEST_PWD_CHARS;         findPasswordComplexityEvent(""set pwd min non-letters"", events, expectedPayload);         expectedPayload[UPPERCASE_INDEX] = TEST_PWD_CHARS;         findPasswordComplexityEvent(""set pwd min uppercase"", events, expectedPayload);         expectedPayload[LOWERCASE_INDEX] = TEST_PWD_CHARS;         findPasswordComplexityEvent(""set pwd min lowercase"", events, expectedPayload);         expectedPayload[NUMERIC_INDEX] = TEST_PWD_CHARS;         findPasswordComplexityEvent(""set pwd min numeric"", events, expectedPayload);         expectedPayload[SYMBOLS_INDEX] = TEST_PWD_CHARS;         findPasswordComplexityEvent(""set pwd min symbols"", events, expectedPayload);     }      private void generateLockingPolicyEvents() {         if (mHasSecureLockScreen) {             mDevicePolicyManager.setPasswordExpirationTimeout(ADMIN_RECEIVER_COMPONENT,                     TEST_PWD_EXPIRATION_TIMEOUT);             mDevicePolicyManager.setPasswordHistoryLength(ADMIN_RECEIVER_COMPONENT,                     TEST_PWD_HISTORY_LENGTH);             mDevicePolicyManager.setMaximumFailedPasswordsForWipe(ADMIN_RECEIVER_COMPONENT,                     TEST_PWD_MAX_ATTEMPTS);         }         mDevicePolicyManager.setKeyguardDisabledFeatures(ADMIN_RECEIVER_COMPONENT,                 KEYGUARD_DISABLE_FINGERPRINT);         mDevicePolicyManager.setMaximumTimeToLock(ADMIN_RECEIVER_COMPONENT, TEST_MAX_TIME_TO_LOCK);         mDevicePolicyManager.lockNow();     }      private void verifyLockingPolicyEventsPresent(List<SecurityEvent> events) {         final int userId = Process.myUserHandle().getIdentifier();         final String packageName = ADMIN_RECEIVER_COMPONENT.getPackageName();         if (mHasSecureLockScreen) {             findEvent(""set password expiration"", events,                     e -> e.getTag() == TAG_PASSWORD_EXPIRATION_SET &&                             getString(e, ADMIN_PKG_INDEX).equals(packageName) &&                             getInt(e, ADMIN_USER_INDEX) == userId &&                             getInt(e, TARGET_USER_INDEX) == userId &&                             getLong(e, PWD_EXPIRATION_INDEX) == TEST_PWD_EXPIRATION_TIMEOUT);              findEvent(""set password history length"", events,                     e -> e.getTag() == TAG_PASSWORD_HISTORY_LENGTH_SET &&                             getString(e, ADMIN_PKG_INDEX).equals(packageName) &&                             getInt(e, ADMIN_USER_INDEX) == userId &&                             getInt(e, TARGET_USER_INDEX) == userId &&                             getInt(e, PWD_HIST_LEN_INDEX) == TEST_PWD_HISTORY_LENGTH);              findEvent(""set password attempts"", events,                     e -> e.getTag() == TAG_MAX_PASSWORD_ATTEMPTS_SET &&                             getString(e, ADMIN_PKG_INDEX).equals(packageName) &&                             getInt(e, ADMIN_USER_INDEX) == userId &&                             getInt(e, TARGET_USER_INDEX) == userId &&                             getInt(e, MAX_PWD_ATTEMPTS_INDEX) == TEST_PWD_MAX_ATTEMPTS);         }          findEvent(""set keyguard disabled features"", events,                 e -> e.getTag() == TAG_KEYGUARD_DISABLED_FEATURES_SET &&                         getString(e, ADMIN_PKG_INDEX).equals(packageName) &&                         getInt(e, ADMIN_USER_INDEX) == userId &&                         getInt(e, TARGET_USER_INDEX) == userId &&                         getInt(e, KEYGUARD_FEATURES_INDEX) == KEYGUARD_DISABLE_FINGERPRINT);          findEvent(""set screen lock timeout"", events,                 e -> e.getTag() == TAG_MAX_SCREEN_LOCK_TIMEOUT_SET &&                         getString(e, ADMIN_PKG_INDEX).equals(packageName) &&                         getInt(e, ADMIN_USER_INDEX) == userId &&                         getInt(e, TARGET_USER_INDEX) == userId &&                         getLong(e, MAX_SCREEN_TIMEOUT_INDEX) == TEST_MAX_TIME_TO_LOCK);          findEvent(""set screen lock timeout"", events,                 e -> e.getTag() == TAG_REMOTE_LOCK &&                         getString(e, ADMIN_PKG_INDEX).equals(packageName) &&                         getInt(e, ADMIN_USER_INDEX) == userId);     }      private void findPasswordComplexityEvent(             String description, List<SecurityEvent> events, Object[] expectedPayload) {         findEvent(description, events,                 e -> e.getTag() == TAG_PASSWORD_COMPLEXITY_SET &&                         Arrays.equals((Object[]) e.getData(), expectedPayload));     }      private void generateUserRestrictionEvents() {         mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,                 UserManager.DISALLOW_PRINTING);         mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,                 UserManager.DISALLOW_PRINTING);     }      private void verifyUserRestrictionEventsPresent(List<SecurityEvent> events) {         findUserRestrictionEvent(""set user restriction"", events, TAG_USER_RESTRICTION_ADDED);         findUserRestrictionEvent(""clear user restriction"", events, TAG_USER_RESTRICTION_REMOVED);     }      private void findUserRestrictionEvent(String description, List<SecurityEvent> events, int tag) {         final int userId = Process.myUserHandle().getIdentifier();         findEvent(description, events,                 e -> e.getTag() == tag &&                         getString(e, ADMIN_PKG_INDEX).equals(                                 ADMIN_RECEIVER_COMPONENT.getPackageName()) &&                         getInt(e, ADMIN_USER_INDEX) == userId &&                         UserManager.DISALLOW_PRINTING.equals(getString(e, USER_RESTRICTION_INDEX)));     }      private void generateCameraPolicyEvents() {         mDevicePolicyManager.setCameraDisabled(ADMIN_RECEIVER_COMPONENT, true);         mDevicePolicyManager.setCameraDisabled(ADMIN_RECEIVER_COMPONENT, false);     }      private void verifyCameraPolicyEvents(List<SecurityEvent> events) {         final int userId = Process.myUserHandle().getIdentifier();          findEvent(""set camera disabled"", events,                 e -> e.getTag() == TAG_CAMERA_POLICY_SET &&                         getString(e, ADMIN_PKG_INDEX).equals(                                 ADMIN_RECEIVER_COMPONENT.getPackageName()) &&                         getInt(e, ADMIN_USER_INDEX) == userId &&                         getInt(e, TARGET_USER_INDEX) == userId &&                         getInt(e, CAMERA_DISABLED_INDEX) == 1);          findEvent(""set camera enabled"", events,                 e -> e.getTag() == TAG_CAMERA_POLICY_SET &&                         getString(e, ADMIN_PKG_INDEX).equals(                                 ADMIN_RECEIVER_COMPONENT.getPackageName()) &&                         getInt(e, ADMIN_USER_INDEX) == userId &&                         getInt(e, TARGET_USER_INDEX) == userId &&                         getInt(e, CAMERA_DISABLED_INDEX) == 0);     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.LockScreenInfoTest"	"testLockInfoIsNull"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/LockScreenInfoTest.java"	""	"public void testLockInfoIsNull() {         assertNull(mDevicePolicyManager.getDeviceOwnerLockScreenInfo());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.LockScreenInfoTest"	"testEmptyStringClearsLockInfo"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/LockScreenInfoTest.java"	""	"public void testEmptyStringClearsLockInfo() {         final String message = """";         mDevicePolicyManager.setDeviceOwnerLockScreenInfo(getWho(), message);         assertNull(mDevicePolicyManager.getDeviceOwnerLockScreenInfo());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.LockScreenInfoTest"	"testSetLockInfoWithNullAdminFails"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/LockScreenInfoTest.java"	""	"public void testSetLockInfoWithNullAdminFails() {         final String message = ""nulladmin"";          // Set message         try {             mDevicePolicyManager.setDeviceOwnerLockScreenInfo(null, message);             fail(""Exception should have been thrown for null admin ComponentName"");         } catch (NullPointerException expected) {         }     }      /**      * Sets device owner lock screen info on behalf of the current device owner admin.      *      * @throws AssertionError if the setting did not take effect.      */     private void setLockInfo(String message) {         mDevicePolicyManager.setDeviceOwnerLockScreenInfo(getWho(), message);         assertEquals(message, mDevicePolicyManager.getDeviceOwnerLockScreenInfo());     }      protected ComponentName getWho() {         return ADMIN_RECEIVER_COMPONENT;     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.media.mediaparser.cts.MediaParserTest"	"testWavWithImaAdpcm"	"CtsMediaParserTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/mediaparser/src/android/media/mediaparser/cts/MediaParserTest.java"	""	"public void testWavWithImaAdpcm() throws IOException {         testAssetExtraction(""wav/sample_ima_adpcm.wav"");     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.view.inputmethod.cts.ImeInsetsControllerTest"	"launchTestActivity"	"CtsInputMethodTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/ImeInsetsControllerTest.java"	""	"/*  *.  */  package android.view.inputmethod.cts;  import static android.view.WindowInsets.CONSUMED; import static android.view.WindowInsets.Type.ime;  import static com.android.cts.mockime.ImeEventStreamTestUtils.expectBindInput; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectCommand;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse;  import android.graphics.Point; import android.os.Process; import android.os.SystemClock; import android.util.Pair; import android.view.View; import android.view.Window; import android.view.WindowInsets; import android.view.WindowInsetsAnimationControlListener; import android.view.WindowInsetsAnimationController; import android.view.WindowInsetsController; import android.view.WindowInsetsController.OnControllableInsetsChangedListener; import android.view.inputmethod.cts.util.EndToEndImeTestBase; import android.view.inputmethod.cts.util.TestActivity; import android.view.inputmethod.cts.util.UnlockScreenRule; import android.widget.EditText; import android.widget.LinearLayout;  import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.test.filters.MediumTest; import androidx.test.platform.app.InstrumentationRegistry;  import com.android.cts.mockime.ImeEventStream; import com.android.cts.mockime.ImeSettings; import com.android.cts.mockime.MockImeSession;  import org.junit.Rule; import org.junit.Test;  import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference;  @MediumTest public class ImeInsetsControllerTest extends EndToEndImeTestBase {     private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);      private static final String TEST_MARKER = ""android.view.inputmethod.cts.InsetsControllerTest"";      @Rule     public final UnlockScreenRule mUnlockScreenRule = new UnlockScreenRule();      public Pair<EditText, Window> launchTestActivity() {         final AtomicReference<EditText> editTextRef = new AtomicReference<>();         final AtomicReference<Window> windowRef = new AtomicReference<>();         TestActivity.startSync(activity -> {             final LinearLayout layout = new LinearLayout(activity);             layout.setOrientation(LinearLayout.VERTICAL);              final EditText editText = new EditText(activity);             editText.setPrivateImeOptions(TEST_MARKER);             editText.setHint(""editText"");             editText.requestFocus();             editTextRef.set(editText);              windowRef.set(activity.getWindow());              layout.addView(editText);             return layout;         });         return new Pair<>(editTextRef.get(), windowRef.get());     }      private static final int INITIAL_KEYBOARD_HEIGHT = 200;     private static final int NEW_KEYBOARD_HEIGHT = 300;"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.profileowner.ManagementTest"	"testProvisionManagedProfileNotAllowed"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DevicePolicyManager.ACTION"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ProfileOwner/src/com/android/cts/profileowner/ManagementTest.java"	""	"public void testProvisionManagedProfileNotAllowed() {         DevicePolicyManager dpm = (DevicePolicyManager)                 mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);         assertFalse(dpm.isProvisioningAllowed(                 DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE));     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.admin.cts.DeviceAdminActivationTest"	"testActivateBrokenReceiver5Fails"	"CtsAdminTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DevicePolicyManager.ACTION"	""	""	""	"/home/gpoor/cts-source/cts/tests/admin/src/android/admin/cts/DeviceAdminActivationTest.java"	""	"public void testActivateBrokenReceiver5Fails() throws Exception {         if (!mDeviceAdmin) {             Log.w(TAG, ""Skipping testActivateBrokenReceiver5Fails"");             return;         }         assertDeviceAdminDeactivated(CtsDeviceAdminBrokenReceiver5.class);         startAddDeviceAdminActivityForResult(CtsDeviceAdminBrokenReceiver5.class);         assertWithTimeoutOnActivityResultInvokedWithResultCode(Activity.RESULT_CANCELED);         assertDeviceAdminDeactivated(CtsDeviceAdminBrokenReceiver5.class);     }      private void startAddDeviceAdminActivityForResult(Class<?> receiverClass) {         getActivity().startActivityForResult(                 getAddDeviceAdminIntent(receiverClass),                 REQUEST_CODE_ACTIVATE_ADMIN);     }      private Intent getAddDeviceAdminIntent(Class<?> receiverClass) {         return new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN)             .putExtra(                     DevicePolicyManager.EXTRA_DEVICE_ADMIN,                     new ComponentName(                             getInstrumentation().getTargetContext(),                             receiverClass));     }      private void assertWithTimeoutOnActivityResultNotInvoked() {         SystemClock.sleep(UI_EFFECT_TIMEOUT_MILLIS);         Mockito.verify(mMockOnActivityResultListener, Mockito.never())                 .onActivityResult(                         Mockito.eq(REQUEST_CODE_ACTIVATE_ADMIN),                         Mockito.anyInt(),                         Mockito.nullable(Intent.class));     }      private void assertWithTimeoutOnActivityResultInvokedWithResultCode(int expectedResultCode) {         ArgumentCaptor<Integer> resultCodeCaptor = ArgumentCaptor.forClass(int.class);         Mockito.verify(mMockOnActivityResultListener, Mockito.timeout(UI_EFFECT_TIMEOUT_MILLIS))                 .onActivityResult(                         Mockito.eq(REQUEST_CODE_ACTIVATE_ADMIN),                         resultCodeCaptor.capture(),                         Mockito.nullable(Intent.class));         assertEquals(expectedResultCode, (int) resultCodeCaptor.getValue());     }      private void finishActivateDeviceAdminActivity() {         getActivity().finishActivity(REQUEST_CODE_ACTIVATE_ADMIN);     }      private void assertDeviceAdminDeactivated(Class<?> receiverClass) {         DevicePolicyManager devicePolicyManager =                 (DevicePolicyManager) getActivity().getSystemService(                         Context.DEVICE_POLICY_SERVICE);         assertFalse(devicePolicyManager.isAdminActive(                 new ComponentName(getInstrumentation().getTargetContext(), receiverClass)));     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.media.tv.tuner.cts.TunerFrontendTest"	"testAtsc3FrontendSettings"	"CtsTvTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/tv/src/android/media/tv/tuner/cts/TunerFrontendTest.java"	""	"@Ignore(""b/188004782"")     // Disable Tuner CTS cases on Android 11.     public void testAtsc3FrontendSettings() throws Exception {         if (!hasTuner()) return;          Atsc3PlpSettings plp1 =                 Atsc3PlpSettings                         .builder()                         .setPlpId(1)                         .setModulation(Atsc3FrontendSettings.MODULATION_MOD_QPSK)                         .setInterleaveMode(Atsc3FrontendSettings.TIME_INTERLEAVE_MODE_AUTO)                         .setCodeRate(Atsc3FrontendSettings.CODERATE_6_15)                         .setFec(Atsc3FrontendSettings.FEC_BCH_LDPC_64K)                         .build();          Atsc3PlpSettings plp2 =                 Atsc3PlpSettings                         .builder()                         .setPlpId(2)                         .setModulation(Atsc3FrontendSettings.MODULATION_MOD_QPSK)                         .setInterleaveMode(Atsc3FrontendSettings.TIME_INTERLEAVE_MODE_HTI)                         .setCodeRate(Atsc3FrontendSettings.CODERATE_UNDEFINED)                         .setFec(Atsc3FrontendSettings.FEC_LDPC_16K)                         .build();          Atsc3FrontendSettings settings =                 Atsc3FrontendSettings                         .builder()                         .setFrequency(2)                         .setBandwidth(Atsc3FrontendSettings.BANDWIDTH_BANDWIDTH_6MHZ)                         .setDemodOutputFormat(Atsc3FrontendSettings.MODULATION_MOD_QPSK)                         .setPlpSettings(new Atsc3PlpSettings[] {plp1, plp2})                         .build();          assertEquals(FrontendSettings.TYPE_ATSC3, settings.getType());         assertEquals(2, settings.getFrequency());         assertEquals(Atsc3FrontendSettings.BANDWIDTH_BANDWIDTH_6MHZ, settings.getBandwidth());         assertEquals(Atsc3FrontendSettings.MODULATION_MOD_QPSK, settings.getDemodOutputFormat());          Atsc3PlpSettings[] plps = settings.getPlpSettings();         assertEquals(2, plps.length);          assertEquals(1, plps[0].getPlpId());         assertEquals(Atsc3FrontendSettings.MODULATION_MOD_QPSK, plps[0].getModulation());         assertEquals(Atsc3FrontendSettings.TIME_INTERLEAVE_MODE_AUTO, plps[0].getInterleaveMode());         assertEquals(Atsc3FrontendSettings.CODERATE_6_15, plps[0].getCodeRate());         assertEquals(Atsc3FrontendSettings.FEC_BCH_LDPC_64K, plps[0].getFec());          assertEquals(2, plps[1].getPlpId());         assertEquals(Atsc3FrontendSettings.MODULATION_MOD_QPSK, plps[1].getModulation());         assertEquals(Atsc3FrontendSettings.TIME_INTERLEAVE_MODE_HTI, plps[1].getInterleaveMode());         assertEquals(Atsc3FrontendSettings.CODERATE_UNDEFINED, plps[1].getCodeRate());         assertEquals(Atsc3FrontendSettings.FEC_LDPC_16K, plps[1].getFec());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.AccountManagementParentTest"	"testEnableAccountManagement"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AccountManagementParentTest.java"	""	"public void testEnableAccountManagement() {         DevicePolicyManager parentDevicePolicyManager = getParentInstance();          parentDevicePolicyManager.setAccountManagementDisabled(ADMIN_RECEIVER_COMPONENT,                 SOME_ACCOUNT_TYPE, false);         assertThat(parentDevicePolicyManager.getAccountTypesWithManagementDisabled()).isEmpty();     }      private DevicePolicyManager getParentInstance() {         assertThat(mDevicePolicyManager.isAdminActive(ADMIN_RECEIVER_COMPONENT)).isTrue();         assertThat(mDevicePolicyManager.isProfileOwnerApp(                 ADMIN_RECEIVER_COMPONENT.getPackageName())).isTrue();         assertThat(mDevicePolicyManager.isOrganizationOwnedDeviceWithManagedProfile()).isTrue();          DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         assertThat(parentDevicePolicyManager).isNotNull();          return parentDevicePolicyManager;     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.DelegatedCertInstallerTest"	"testInstallKeyPair"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/DelegatedCertInstallerTest.java"	""	"public void testInstallKeyPair() throws InterruptedException, KeyChainException {         final String alias = ""delegated-cert-installer-test-key"";          // Clear delegated cert installer.         mDpm.setCertInstallerPackage(ADMIN_RECEIVER_COMPONENT, null);         // The app is not the cert installer , it shouldn't have have privilege to call         // installKeyPair().         installKeyPair(TEST_KEY, TEST_CERT, alias);         assertResult(""installKeyPair"", false);          // Set the app to be cert installer.         mDpm.setCertInstallerPackage(ADMIN_RECEIVER_COMPONENT, CERT_INSTALLER_PACKAGE);         assertEquals(CERT_INSTALLER_PACKAGE,                 mDpm.getCertInstallerPackage(ADMIN_RECEIVER_COMPONENT));          // Exercise installKeyPair()         installKeyPair(TEST_KEY, TEST_CERT, alias);         assertResult(""installKeyPair"", true);     }      /**      * If DPC is targeting N+, @{link IllegalArgumentException } should be thrown if the package      * is missing.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceadmin.DeviceAdminWithEnterprisePoliciesBlockedTest"	"testPasswordHistoryLength"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAdmin/src/com.android.cts.deviceadmin/DeviceAdminWithEnterprisePoliciesBlockedTest.java"	""	"public void testPasswordHistoryLength() {         if (!mHasSecureLockScreen) {             return;         }         int originalValue = dpm.getPasswordHistoryLength(mAdminComponent);         assertSecurityException(() -> dpm.setPasswordHistoryLength(mAdminComponent, 3));         assertEquals(originalValue, dpm.getPasswordHistoryLength(mAdminComponent));     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceadmin.DeviceAdminWithEnterprisePoliciesBlockedTest"	"testPasswordExpirationTimeout"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAdmin/src/com.android.cts.deviceadmin/DeviceAdminWithEnterprisePoliciesBlockedTest.java"	""	"public void testPasswordExpirationTimeout() {         if (!mHasSecureLockScreen) {             return;         }         long originalValue = dpm.getPasswordExpirationTimeout(mAdminComponent);         assertSecurityException(() -> dpm.setPasswordExpirationTimeout(mAdminComponent, 1234L));         assertEquals(originalValue, dpm.getPasswordExpirationTimeout(mAdminComponent));     }      private void assertSecurityException(Runnable r) {         boolean securityExceptionThrown = false;         try {             r.run();         } catch (SecurityException e) {             securityExceptionThrown = true;         }          assertTrue(""Expected SecurityException was not thrown"", securityExceptionThrown);     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.transferowner.TransferDeviceOwnerIncomingTest"	"testTransferPoliciesAreRetainedAfterTransfer"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/TransferOwnerIncomingApp/src/com/android/cts/transferowner/TransferDeviceOwnerIncomingTest.java"	""	"public void testTransferPoliciesAreRetainedAfterTransfer() {         assertTrue(mDevicePolicyManager.isAdminActive(mIncomingComponentName));         assertTrue(mDevicePolicyManager.isDeviceOwnerApp(mIncomingComponentName.getPackageName()));         assertTrue(mDevicePolicyManager.getCameraDisabled(mIncomingComponentName));         assertEquals(Collections.singletonList(""test.package""),                 mDevicePolicyManager.getKeepUninstalledPackages(mIncomingComponentName));         assertEquals(                 DevicePolicyManager.PASSWORD_QUALITY_NUMERIC,                 mDevicePolicyManager.getPasswordQuality(mIncomingComponentName));         assertEquals(123, mDevicePolicyManager.getPasswordMinimumLength(mIncomingComponentName));         assertSystemPoliciesEqual(SystemUpdatePolicy.createPostponeInstallPolicy(),                 mDevicePolicyManager.getSystemUpdatePolicy());         assertThrows(SecurityException.class, () -> {             mDevicePolicyManager.getParentProfileInstance(mIncomingComponentName);         });     }      private void assertSystemPoliciesEqual(SystemUpdatePolicy policy1, SystemUpdatePolicy policy2) {         assertTrue(policy1.getPolicyType() == policy2.getPolicyType()                 && policy1.getInstallWindowStart() == policy2.getInstallWindowStart()                 && policy1.getInstallWindowEnd() == policy2.getInstallWindowEnd());     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testResetPasswordWithToken"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	"public void testResetPasswordWithToken() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         // Execute the test method that's guaranteed to succeed. See also test in base class         // which are tolerant to failure and executed by MixedDeviceOwnerTest and         // MixedProfileOwnerTest         executeResetPasswordWithTokenTests(false);     }      @Override"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testSecondaryLockscreen"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	"public void testSecondaryLockscreen() throws Exception {         // Managed profiles cannot have secondary lockscreens set.     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.SuspendPackageTest"	"testSetPackagesNotSuspended"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SuspendPackageTest.java"	""	"public void testSetPackagesNotSuspended() throws NameNotFoundException {         String[] notHandledPackages = mDevicePolicyManager.setPackagesSuspended(                 ADMIN_RECEIVER_COMPONENT,                 new String[] {INTENT_RECEIVER_PKG},                 false);         // all packages should be handled.         assertEquals(0, notHandledPackages.length);         // test isPackageSuspended         boolean isSuspended =                 mDevicePolicyManager.isPackageSuspended(                         ADMIN_RECEIVER_COMPONENT, INTENT_RECEIVER_PKG);         assertFalse(isSuspended);     }      /**      * Verify that we cannot suspend launcher and dpc app.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.SuspendPackageTest"	"testSuspendNotSuspendablePackages"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SuspendPackageTest.java"	""	"public void testSuspendNotSuspendablePackages() {         String launcherPackage = getLauncherPackage();         String dpcPackage = ADMIN_RECEIVER_COMPONENT.getPackageName();         String[] unsuspendablePackages = new String[] {launcherPackage, dpcPackage};         String[] notHandledPackages = mDevicePolicyManager.setPackagesSuspended(                 ADMIN_RECEIVER_COMPONENT,                 unsuspendablePackages,                 true);         // no package should be handled.         assertArrayEqualIgnoreOrder(unsuspendablePackages, notHandledPackages);     }      /**      * @return the package name of launcher.      */     private String getLauncherPackage() {         Intent intent = new Intent(Intent.ACTION_MAIN);         intent.addCategory(Intent.CATEGORY_HOME);         ResolveInfo resolveInfo = mContext.getPackageManager().resolveActivity(intent,                 PackageManager.MATCH_DEFAULT_ONLY);         return resolveInfo.activityInfo.packageName;     }      private static <T> void assertArrayEqualIgnoreOrder(T[] a, T[] b) {         assertEquals(a.length, b.length);         assertTrue(new HashSet(Arrays.asList(a)).containsAll(new HashSet(Arrays.asList(b))));     }  }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.DisplayTests"	"testForceDisplayMetrics"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayTests.java"	""	"public void testForceDisplayMetrics() {         assumeTrue(supportsLockScreen());          launchHomeActivity();          final DisplayMetricsSession displayMetricsSession =                 createManagedDisplayMetricsSession(DEFAULT_DISPLAY);         final LockScreenSession lockScreenSession = createManagedLockScreenSession();          // Read initial sizes.         final ReportedDisplayMetrics originalDisplayMetrics =                 displayMetricsSession.getInitialDisplayMetrics();          // Apply new override values that don't match the physical metrics.         final Size overrideSize = new Size(                 (int) (originalDisplayMetrics.physicalSize.getWidth() * 1.5),                 (int) (originalDisplayMetrics.physicalSize.getHeight() * 1.5));         final Integer overrideDensity = (int) (originalDisplayMetrics.physicalDensity * 1.1);         displayMetricsSession.overrideDisplayMetrics(overrideSize, overrideDensity);          // Check if overrides applied correctly.         ReportedDisplayMetrics displayMetrics = displayMetricsSession.getDisplayMetrics();         assertEquals(overrideSize, displayMetrics.overrideSize);         assertEquals(overrideDensity, displayMetrics.overrideDensity);          // Lock and unlock device. This will cause a DISPLAY_CHANGED event to be triggered and         // might update the metrics.         lockScreenSession.sleepDevice()                 .wakeUpDevice()                 .unlockDevice();         mWmState.waitForHomeActivityVisible();          // Check if overrides are still applied.         displayMetrics = displayMetricsSession.getDisplayMetrics();         assertEquals(overrideSize, displayMetrics.overrideSize);         assertEquals(overrideDensity, displayMetrics.overrideDensity);     }      private Configuration getDisplayResourcesConfiguration(int displayWidth, int displayHeight)             throws Exception  {         final Context context = getInstrumentation().getContext();          try (final VirtualDisplaySession virtualDisplaySession = new VirtualDisplaySession()) {             final DisplayContent displayContent = virtualDisplaySession                     .setSimulateDisplay(true)                     .setSimulationDisplaySize(displayWidth, displayHeight)                     .createDisplay();             final Display display = mDm.getDisplay(displayContent.mId);             Configuration config = context.createDisplayContext(display)                     .getResources().getConfiguration();             return config;         }     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.comp.BindDeviceAdminServiceFailsTest"	"testCannotBind"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/BindDeviceAdminServiceFailsTest.java"	""	"public void testCannotBind() throws Exception {         UserHandle otherProfile = Utils.getOtherProfile(mContext);         if (otherProfile != null) {             checkCannotBind(AdminReceiver.COMP_DPC_PACKAGE_NAME, otherProfile);             checkCannotBind(AdminReceiver.COMP_DPC_2_PACKAGE_NAME, otherProfile);         }     }      private void checkCannotBind(String targetPackageName, UserHandle otherProfile) {         try {             final Intent serviceIntent = new Intent();             serviceIntent.setClassName(targetPackageName, ProtectedCrossUserService.class.getName());             bind(serviceIntent, EMPTY_SERVICE_CONNECTION, otherProfile);             fail(""SecurityException should be thrown"");         } catch (SecurityException ex) {             MoreAsserts.assertContainsRegex(                     ""Not allowed to bind to target user id"", ex.getMessage());         }     }      private boolean bind(Intent serviceIntent, ServiceConnection serviceConnection,             UserHandle userHandle) {         return mDpm.bindDeviceAdminServiceAsUser(AdminReceiver.getComponentName(mContext),                 serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE, userHandle);     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.AlwaysOnVpnTest"	"testSetNonVpnAlwaysOn"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AlwaysOnVpnTest.java"	""	"public void testSetNonVpnAlwaysOn() throws Exception {         // Treat this CTS DPC as an non-vpn app, since it doesn't register         // android.net.VpnService intent filter in AndroidManifest.xml.         try {             mDevicePolicyManager.setAlwaysOnVpnPackage(                     ADMIN_RECEIVER_COMPONENT, mPackageName, true);             fail(""setAlwaysOnVpnPackage should not accept non-vpn package"");         } catch (UnsupportedOperationException e) {             // success         }         assertNull(mDevicePolicyManager.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));     }      private void assertConnectivity(boolean shouldHaveConnectivity, String message) {         try {             new Socket(CONNECTIVITY_CHECK_HOST, 80);             if (!shouldHaveConnectivity) {                 fail(""Connectivity available while not expected: "" + message);             }         } catch (IOException e) {             if (shouldHaveConnectivity) {                 Log.e(TAG, ""Connectivity check failed"", e);                 fail(""Connectivity isn't available while expected: "" + message);             }         }     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.BaseDeviceAdminHostSideTest"	"testResetPasswordDeprecated"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/BaseDeviceAdminHostSideTest.java"	""	"public void testResetPasswordDeprecated() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }          runTests(getDeviceAdminApkPackage(), ""DeviceAdminPasswordTest"",                         ""testResetPasswordDeprecated"");     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.view.inputmethod.cts.FocusHandlingTest"	"getTestMarker"	"CtsInputMethodTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/FocusHandlingTest.java"	""	"/*  *.  */  package android.view.inputmethod.cts;  import static android.view.WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM; import static android.view.WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE; import static android.view.inputmethod.cts.util.InputMethodVisibilityVerifier.expectImeInvisible; import static android.view.inputmethod.cts.util.InputMethodVisibilityVerifier.expectImeVisible; import static android.view.inputmethod.cts.util.TestUtils.runOnMainSync; import static android.widget.PopupWindow.INPUT_METHOD_NEEDED; import static android.widget.PopupWindow.INPUT_METHOD_NOT_NEEDED;  import static com.android.cts.mockime.ImeEventStreamTestUtils.editorMatcher; import static com.android.cts.mockime.ImeEventStreamTestUtils.editorMatcherRestartingFalse; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectBindInput; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectCommand; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEvent; import static com.android.cts.mockime.ImeEventStreamTestUtils.notExpectEvent;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.app.Instrumentation; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.os.Build; import android.os.IBinder; import android.os.Process; import android.os.SystemClock; import android.platform.test.annotations.AppModeFull; import android.text.TextUtils; import android.view.View; import android.view.ViewTreeObserver; import android.view.WindowManager; import android.view.inputmethod.EditorInfo; import android.view.inputmethod.InputMethodManager; import android.view.inputmethod.cts.util.EndToEndImeTestBase; import android.view.inputmethod.cts.util.TestActivity; import android.view.inputmethod.cts.util.TestUtils; import android.view.inputmethod.cts.util.UnlockScreenRule; import android.view.inputmethod.cts.util.WindowFocusHandleService; import android.view.inputmethod.cts.util.WindowFocusStealer; import android.widget.EditText; import android.widget.LinearLayout; import android.widget.PopupWindow; import android.widget.TextView;  import androidx.annotation.NonNull; import androidx.test.filters.FlakyTest; import androidx.test.filters.MediumTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CtsTouchUtils; import com.android.cts.mockime.ImeCommand; import com.android.cts.mockime.ImeEvent; import com.android.cts.mockime.ImeEventStream; import com.android.cts.mockime.ImeSettings; import com.android.cts.mockime.MockImeSession;  import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicReference;  @MediumTest @RunWith(AndroidJUnit4.class) public class FocusHandlingTest extends EndToEndImeTestBase {     static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);     static final long NOT_EXPECT_TIMEOUT = TimeUnit.SECONDS.toMillis(1);      @Rule     public final UnlockScreenRule mUnlockScreenRule = new UnlockScreenRule();      private static final String TEST_MARKER_PREFIX =             ""android.view.inputmethod.cts.FocusHandlingTest"";      public EditText launchTestActivity(String marker) {         final AtomicReference<EditText> editTextRef = new AtomicReference<>();         TestActivity.startSync(activity-> {             final LinearLayout layout = new LinearLayout(activity);             layout.setOrientation(LinearLayout.VERTICAL);              final EditText editText = new EditText(activity);             editText.setPrivateImeOptions(marker);             editText.setHint(""editText"");             editText.requestFocus();             editTextRef.set(editText);              layout.addView(editText);             return layout;         });         return editTextRef.get();     }      public EditText launchTestActivity(String marker,             @NonNull AtomicBoolean outEditHasWindowFocusRef) {         final EditText editText = launchTestActivity(marker);         editText.post(() -> {             final ViewTreeObserver observerForEditText = editText.getViewTreeObserver();             observerForEditText.addOnWindowFocusChangeListener((hasFocus) ->                     outEditHasWindowFocusRef.set(editText.hasWindowFocus()));             outEditHasWindowFocusRef.set(editText.hasWindowFocus());         });         return editText;     }      private static String getTestMarker() {         return TEST_MARKER_PREFIX + ""/""  + SystemClock.elapsedRealtimeNanos();     }      @FlakyTest(bugId = 149246840)"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.comp.BindDeviceAdminServiceGoodSetupTest"	"testCannotBind_unprotectedCrossUserService"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/BindDeviceAdminServiceGoodSetupTest.java"	""	"public void testCannotBind_unprotectedCrossUserService() throws Exception {         final Intent serviceIntent = new Intent(mContext, UnprotectedCrossUserService.class);         for (UserHandle targetUser : mTargetUsers) {             try {                 bind(serviceIntent, EMPTY_SERVICE_CONNECTION, targetUser);                 fail(""SecurityException should be thrown for target user "" + targetUser);             } catch (SecurityException ex) {                 MoreAsserts.assertContainsRegex(                         ""must be protected by BIND_DEVICE_ADMIN"", ex.getMessage());             }         }     }      /**      * Talk to a DPC package that is neither device owner nor profile owner.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.comp.BindDeviceAdminServiceGoodSetupTest"	"testCheckCannotBind_nonManagingPackage"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/BindDeviceAdminServiceGoodSetupTest.java"	""	"public void testCheckCannotBind_nonManagingPackage() throws Exception {         final Intent serviceIntent = new Intent();         serviceIntent.setClassName(NON_MANAGING_PACKAGE, ProtectedCrossUserService.class.getName());         for (UserHandle targetUser : mTargetUsers) {             try {                 bind(serviceIntent, EMPTY_SERVICE_CONNECTION, targetUser);                 fail(""SecurityException should be thrown for target user "" + targetUser);             } catch (SecurityException ex) {                 MoreAsserts.assertContainsRegex(""Only allow to bind service"", ex.getMessage());             }         }     }      /**      * Talk to the same DPC in same user, that is talking to itself.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"getTestMarker"	"CtsInputMethodTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	"/*  *.  */  package android.view.inputmethod.cts;  import static android.view.WindowInsets.Type.ime; import static android.view.WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS; import static android.view.inputmethod.cts.util.InputMethodVisibilityVerifier.expectImeInvisible; import static android.view.inputmethod.cts.util.InputMethodVisibilityVerifier.expectImeVisible; import static android.view.inputmethod.cts.util.TestUtils.getOnMainSync; import static android.view.inputmethod.cts.util.TestUtils.runOnMainSync;  import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEvent; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEventWithKeyValue; import static com.android.cts.mockime.ImeEventStreamTestUtils.notExpectEvent;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.app.AlertDialog; import android.app.Instrumentation; import android.content.pm.PackageManager; import android.graphics.Color; import android.os.SystemClock; import android.support.test.uiautomator.UiObject2; import android.text.TextUtils; import android.util.Pair; import android.view.KeyEvent; import android.view.View; import android.view.WindowInsetsController; import android.view.inputmethod.EditorInfo; import android.view.inputmethod.InputMethod; import android.view.inputmethod.InputMethodManager; import android.view.inputmethod.cts.util.EndToEndImeTestBase; import android.view.inputmethod.cts.util.TestActivity; import android.view.inputmethod.cts.util.TestUtils; import android.view.inputmethod.cts.util.TestWebView; import android.view.inputmethod.cts.util.UnlockScreenRule; import android.widget.EditText; import android.widget.LinearLayout;  import androidx.annotation.ColorInt; import androidx.annotation.NonNull; import androidx.test.filters.MediumTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.cts.mockime.ImeEvent; import com.android.cts.mockime.ImeEventStream; import com.android.cts.mockime.ImeSettings; import com.android.cts.mockime.MockImeSession;  import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicReference; import java.util.function.Predicate;  @MediumTest @RunWith(AndroidJUnit4.class) public class KeyboardVisibilityControlTest extends EndToEndImeTestBase {     private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);      @Rule     public final UnlockScreenRule mUnlockScreenRule = new UnlockScreenRule();      private static final String TEST_MARKER_PREFIX =             ""android.view.inputmethod.cts.KeyboardVisibilityControlTest"";      private static String getTestMarker() {         return TEST_MARKER_PREFIX + ""/""  + SystemClock.elapsedRealtimeNanos();     }      private static Predicate<ImeEvent> editorMatcher(             @NonNull String eventName, @NonNull String marker) {         return event -> {             if (!TextUtils.equals(eventName, event.getEventName())) {                 return false;             }             final EditorInfo editorInfo = event.getArguments().getParcelable(""editorInfo"");             return TextUtils.equals(marker, editorInfo.privateImeOptions);         };     }      private static Predicate<ImeEvent> showSoftInputMatcher(int requiredFlags) {         return event -> {             if (!TextUtils.equals(""showSoftInput"", event.getEventName())) {                 return false;             }             final int flags = event.getArguments().getInt(""flags"");             return (flags & requiredFlags) == requiredFlags;         };     }      private static Predicate<ImeEvent> hideSoftInputMatcher() {         return event -> TextUtils.equals(""hideSoftInput"", event.getEventName());     }      private static Predicate<ImeEvent> onFinishInputViewMatcher(boolean expectedFinishingInput) {         return event -> {             if (!TextUtils.equals(""onFinishInputView"", event.getEventName())) {                 return false;             }             final boolean finishingInput = event.getArguments().getBoolean(""finishingInput"");             return finishingInput == expectedFinishingInput;         };     }      private Pair<EditText, EditText> launchTestActivity(@NonNull String focusedMarker,             @NonNull String nonFocusedMarker) {         final AtomicReference<EditText> focusedEditTextRef = new AtomicReference<>();         final AtomicReference<EditText> nonFocusedEditTextRef = new AtomicReference<>();         TestActivity.startSync(activity -> {             final LinearLayout layout = new LinearLayout(activity);             layout.setOrientation(LinearLayout.VERTICAL);              final EditText focusedEditText = new EditText(activity);             focusedEditText.setHint(""focused editText"");             focusedEditText.setPrivateImeOptions(focusedMarker);             focusedEditText.requestFocus();             focusedEditTextRef.set(focusedEditText);             layout.addView(focusedEditText);              final EditText nonFocusedEditText = new EditText(activity);             nonFocusedEditText.setPrivateImeOptions(nonFocusedMarker);             nonFocusedEditText.setHint(""target editText"");             nonFocusedEditTextRef.set(nonFocusedEditText);             layout.addView(nonFocusedEditText);             return layout;         });         return new Pair<>(focusedEditTextRef.get(), nonFocusedEditTextRef.get());     }      private EditText launchTestActivity(@NonNull String marker) {         return launchTestActivity(marker, getTestMarker()).first;     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.view.inputmethod.cts.InputMethodStartInputLifecycleTest"	"DisableScreenDozeRule"	"CtsInputMethodTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/InputMethodStartInputLifecycleTest.java"	""	"/*  *.  */  package android.view.inputmethod.cts;  import static android.view.View.SCREEN_STATE_OFF; import static android.view.View.SCREEN_STATE_ON; import static android.view.View.VISIBLE;  import static com.android.cts.mockime.ImeEventStreamTestUtils.editorMatcher; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectBindInput; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectCommand; import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEvent; import static com.android.cts.mockime.ImeEventStreamTestUtils.notExpectEvent;  import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.app.Instrumentation; import android.content.Context; import android.content.pm.PackageManager; import android.inputmethodservice.InputMethodService; import android.os.IBinder; import android.os.Process; import android.os.SystemClock; import android.text.TextUtils; import android.view.inputmethod.EditorInfo; import android.view.inputmethod.InputMethodManager; import android.view.inputmethod.cts.util.DisableScreenDozeRule; import android.view.inputmethod.cts.util.EndToEndImeTestBase; import android.view.inputmethod.cts.util.TestActivity; import android.view.inputmethod.cts.util.TestUtils; import android.view.inputmethod.cts.util.UnlockScreenRule; import android.view.inputmethod.cts.util.WindowFocusStealer; import android.widget.EditText; import android.widget.LinearLayout;  import androidx.test.filters.MediumTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CtsTouchUtils; import com.android.cts.mockime.ImeCommand; import com.android.cts.mockime.ImeEvent; import com.android.cts.mockime.ImeEventStream; import com.android.cts.mockime.ImeSettings; import com.android.cts.mockime.MockImeSession;  import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.atomic.AtomicReference; import java.util.function.Predicate;  @MediumTest @RunWith(AndroidJUnit4.class) public class InputMethodStartInputLifecycleTest extends EndToEndImeTestBase {     @Rule     public final DisableScreenDozeRule mDisableScreenDozeRule = new DisableScreenDozeRule();     @Rule     public final UnlockScreenRule mUnlockScreenRule = new UnlockScreenRule();      private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.view.inputmethod.cts.InputMethodStartInputLifecycleTest"	"testInputConnectionStateWhenScreenStateChanges"	"CtsInputMethodTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/InputMethodStartInputLifecycleTest.java"	""	"public void testInputConnectionStateWhenScreenStateChanges() throws Exception {         final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();         final Context context = instrumentation.getTargetContext();         final InputMethodManager imManager = context.getSystemService(InputMethodManager.class);         assumeTrue(context.getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_INPUT_METHODS));         final AtomicReference<EditText> focusedEditTextRef = new AtomicReference<>();          try (MockImeSession imeSession = MockImeSession.create(                 context, instrumentation.getUiAutomation(), new ImeSettings.Builder())) {             final ImeEventStream stream = imeSession.openEventStream();              final String marker = InputMethodManagerTest.class.getName() + ""/""                     + SystemClock.elapsedRealtimeNanos();             final AtomicInteger screenStateCallbackRef = new AtomicInteger(-1);             TestActivity.startSync(activity -> {                 final LinearLayout layout = new LinearLayout(activity);                 layout.setOrientation(LinearLayout.VERTICAL);                  final EditText focusedEditText = new EditText(activity) {                     @Override                     public void onScreenStateChanged(int screenState) {                         super.onScreenStateChanged(screenState);                         screenStateCallbackRef.set(screenState);                     }                 };                 focusedEditText.setPrivateImeOptions(marker);                 focusedEditText.setHint(""editText"");                 layout.addView(focusedEditText);                 focusedEditText.requestFocus();                 focusedEditTextRef.set(focusedEditText);                  final EditText nonFocusedEditText = new EditText(activity);                 layout.addView(nonFocusedEditText);                  return layout;             });              // Expected onStartInput when TestActivity launched.             final EditText editText = focusedEditTextRef.get();             expectEvent(stream, editorMatcher(""onStartInput"", marker), TIMEOUT);              // Expected text commit will not work when turnScreenOff.             TestUtils.turnScreenOff();             TestUtils.waitOnMainUntil(() -> screenStateCallbackRef.get() == SCREEN_STATE_OFF                             && editText.getWindowVisibility() != VISIBLE, TIMEOUT);             expectEvent(stream, onFinishInputMatcher(), TIMEOUT);             final ImeCommand commit = imeSession.callCommitText(""Hi!"", 1);             expectCommand(stream, commit, TIMEOUT);             TestUtils.waitOnMainUntil(() -> !TextUtils.equals(editText.getText(), ""Hi!""), TIMEOUT,                     ""InputMethodService#commitText should not work after screen off"");              // Expected text commit will work when turnScreenOn.             TestUtils.turnScreenOn();             TestUtils.unlockScreen();             TestUtils.waitOnMainUntil(() -> screenStateCallbackRef.get() == SCREEN_STATE_ON                             && editText.getWindowVisibility() == VISIBLE, TIMEOUT);             CtsTouchUtils.emulateTapOnViewCenter(instrumentation, null, editText);             expectEvent(stream, editorMatcher(""onStartInput"", marker), TIMEOUT);             assertTrue(TestUtils.getOnMainSync(                     () -> imManager.isActive(editText) && imManager.isAcceptingText()));             final ImeCommand commit1 = imeSession.callCommitText(""Hello!"", 1);             expectCommand(stream, commit1, TIMEOUT);             TestUtils.waitOnMainUntil(() -> TextUtils.equals(editText.getText(), ""Hello!""), TIMEOUT,                     ""InputMethodService#commitText should work after screen on"");         }     }      /**      * Test case for Bug 158624922 and Bug 152373385.      *      * Test {@link android.inputmethodservice.InputMethodService#onStartInput(EditorInfo, boolean)}      * and {@link InputMethodService#onFinishInput()} won't be called and the input connection      * remains active, even when a non-IME focusable window hosted by a different process      * temporarily becomes the focused window.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testLockScreenInfo"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	"public void testLockScreenInfo() throws Exception {         if (!mHasFeature) {             return;         }          runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".LockScreenInfoTest"", mUserId);          if (isStatsdEnabled(getDevice())) {             assertMetricsLogged(getDevice(), () -> {                 executeDeviceTestMethod("".LockScreenInfoTest"", ""testSetAndGetLockInfo"");             }, new DevicePolicyEventWrapper.Builder(EventId.SET_DEVICE_OWNER_LOCK_SCREEN_INFO_VALUE)                     .setAdminPackageName(DEVICE_ADMIN_PKG)                     .build());         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.transferowner.TransferProfileOwnerOutgoingTest"	"testTransferWithPoliciesOutgoing"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/TransferOwnerOutgoingApp/src/com/android/cts/transferowner/TransferProfileOwnerOutgoingTest.java"	""	"public void testTransferWithPoliciesOutgoing() throws Throwable {         int passwordLength = 123;         int passwordExpirationTimeout = 456;         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(mOutgoingComponentName);         mDevicePolicyManager.setCameraDisabled(mOutgoingComponentName, true);         mDevicePolicyManager.setPasswordQuality(                 mOutgoingComponentName, DevicePolicyManager.PASSWORD_QUALITY_NUMERIC);         mDevicePolicyManager.setPasswordMinimumLength(mOutgoingComponentName, passwordLength);         mDevicePolicyManager.setCrossProfileCallerIdDisabled(mOutgoingComponentName, true);         parentDevicePolicyManager.setPasswordExpirationTimeout(                 mOutgoingComponentName, passwordExpirationTimeout);          PersistableBundle b = new PersistableBundle();         mDevicePolicyManager.transferOwnership(mOutgoingComponentName, INCOMING_COMPONENT_NAME, b);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.transferowner.TransferProfileOwnerIncomingTest"	"testTransferPoliciesAreRetainedAfterTransfer"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/TransferOwnerIncomingApp/src/com/android/cts/transferowner/TransferProfileOwnerIncomingTest.java"	""	"public void testTransferPoliciesAreRetainedAfterTransfer() {         int passwordLength = 123;         int passwordExpirationTimeout = 456;         assertTrue(mDevicePolicyManager.isAdminActive(mIncomingComponentName));         assertTrue(mDevicePolicyManager.isProfileOwnerApp(mIncomingComponentName.getPackageName()));         assertTrue(mDevicePolicyManager.getCameraDisabled(mIncomingComponentName));         assertTrue(mDevicePolicyManager.getCrossProfileCallerIdDisabled(mIncomingComponentName));         assertEquals(                 DevicePolicyManager.PASSWORD_QUALITY_NUMERIC,                 mDevicePolicyManager.getPasswordQuality(mIncomingComponentName));         assertEquals(                 passwordLength,                 mDevicePolicyManager.getPasswordMinimumLength(mIncomingComponentName));           DevicePolicyManager targetParentProfileInstance =                 mDevicePolicyManager.getParentProfileInstance(mIncomingComponentName);         if (mHasSecureLockScreen) {             assertEquals(                     passwordExpirationTimeout,                     targetParentProfileInstance.getPasswordExpirationTimeout(mIncomingComponentName));         }     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.transferowner.TransferProfileOwnerIncomingTest"	"testTransferPoliciesAreRetainedAfterTransfer"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/TransferOwnerIncomingApp/src/com/android/cts/transferowner/TransferProfileOwnerIncomingTest.java"	""	"public void testTransferPoliciesAreRetainedAfterTransfer() {         int passwordLength = 123;         int passwordExpirationTimeout = 456;         assertTrue(mDevicePolicyManager.isAdminActive(mIncomingComponentName));         assertTrue(mDevicePolicyManager.isProfileOwnerApp(mIncomingComponentName.getPackageName()));         assertTrue(mDevicePolicyManager.getCameraDisabled(mIncomingComponentName));         assertTrue(mDevicePolicyManager.getCrossProfileCallerIdDisabled(mIncomingComponentName));         assertEquals(                 DevicePolicyManager.PASSWORD_QUALITY_NUMERIC,                 mDevicePolicyManager.getPasswordQuality(mIncomingComponentName));         assertEquals(                 passwordLength,                 mDevicePolicyManager.getPasswordMinimumLength(mIncomingComponentName));           DevicePolicyManager targetParentProfileInstance =                 mDevicePolicyManager.getParentProfileInstance(mIncomingComponentName);         if (mHasSecureLockScreen) {             assertEquals(                     passwordExpirationTimeout,                     targetParentProfileInstance.getPasswordExpirationTimeout(mIncomingComponentName));         }     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayPolicyTests"	"testStackFocusSwitchOnStackEmptiedInSleeping"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayPolicyTests.java"	""	"public void testStackFocusSwitchOnStackEmptiedInSleeping() {         assumeTrue(supportsLockScreen());          validateStackFocusSwitchOnStackEmptied(createManagedVirtualDisplaySession(),                 createManagedLockScreenSession());     }      /**      * Tests launching activities on secondary display and then finishing it to see if stack focus      * is moved correctly.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayPolicyTests"	"testStackFocusSwitchOnStackEmptied"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayPolicyTests.java"	""	"public void testStackFocusSwitchOnStackEmptied() {         validateStackFocusSwitchOnStackEmptied(createManagedVirtualDisplaySession(),                 null /* lockScreenSession */);     }      private void validateStackFocusSwitchOnStackEmptied(VirtualDisplaySession virtualDisplaySession,             LockScreenSession lockScreenSession) {         // Create new virtual display.         final DisplayContent newDisplay = virtualDisplaySession.createDisplay();         mWmState.assertVisibility(VIRTUAL_DISPLAY_ACTIVITY, true /* visible */);          // Launch activity on new secondary display.         launchActivityOnDisplay(BROADCAST_RECEIVER_ACTIVITY, newDisplay.mId);         waitAndAssertActivityStateOnDisplay(BROADCAST_RECEIVER_ACTIVITY, STATE_RESUMED,                 newDisplay.mId,""Top activity must be on secondary display"");          if (lockScreenSession != null) {             // Lock the device, so that activity containers will be detached.             lockScreenSession.sleepDevice();         }          // Finish activity on secondary display.         mBroadcastActionTrigger.finishBroadcastReceiverActivity();          if (lockScreenSession != null) {             // Unlock and check if the focus is switched back to primary display.             lockScreenSession.wakeUpDevice().unlockDevice();         }          waitAndAssertTopResumedActivity(VIRTUAL_DISPLAY_ACTIVITY, DEFAULT_DISPLAY,                 ""Top activity must be switched back to primary display"");     }      /**      * Tests that input events on the primary display take focus from the virtual display.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayPolicyTests"	"testStackFocusSwitchOnTouchEventAfterKeyguard"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayPolicyTests.java"	""	"public void testStackFocusSwitchOnTouchEventAfterKeyguard() {         assumeFalse(perDisplayFocusEnabled());         assumeTrue(supportsLockScreen());          // Launch something on the primary display so we know there is a resumed activity there         launchActivity(RESIZEABLE_ACTIVITY);         waitAndAssertTopResumedActivity(RESIZEABLE_ACTIVITY, DEFAULT_DISPLAY,                 ""Activity launched on primary display must be resumed"");          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.sleepDevice();          // Make sure there is no resumed activity when the primary display is off         waitAndAssertActivityState(RESIZEABLE_ACTIVITY, STATE_STOPPED,                 ""Activity launched on primary display must be stopped after turning off"");         assertEquals(""Unexpected resumed activity"",                 0, mWmState.getResumedActivitiesCount());          final DisplayContent newDisplay = createManagedExternalDisplaySession()                 .setCanShowWithInsecureKeyguard(true).createVirtualDisplay();          launchActivityOnDisplay(TEST_ACTIVITY, newDisplay.mId);          // Unlock the device and tap on the middle of the primary display         lockScreenSession.wakeUpDevice();         executeShellCommand(""wm dismiss-keyguard"");         mWmState.waitForKeyguardGone();         mWmState.waitForValidState(RESIZEABLE_ACTIVITY, TEST_ACTIVITY);          // Check that the test activity is resumed on the external display and is on top         waitAndAssertActivityStateOnDisplay(TEST_ACTIVITY, STATE_RESUMED, newDisplay.mId,                 ""Activity on external display must be resumed"");         assertBothDisplaysHaveResumedActivities(pair(DEFAULT_DISPLAY, RESIZEABLE_ACTIVITY),                 pair(newDisplay.mId, TEST_ACTIVITY));          tapOnDisplayCenter(DEFAULT_DISPLAY);          // Check that the activity on the primary display is the topmost resumed         waitAndAssertTopResumedActivity(RESIZEABLE_ACTIVITY, DEFAULT_DISPLAY,                 ""Activity on primary display must be resumed and on top"");         assertBothDisplaysHaveResumedActivities(pair(DEFAULT_DISPLAY, RESIZEABLE_ACTIVITY),                 pair(newDisplay.mId, TEST_ACTIVITY));     }      /**      * Tests that showWhenLocked works on a secondary display.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayPolicyTests"	"testSecondaryDisplayShowWhenLocked"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayPolicyTests.java"	""	"public void testSecondaryDisplayShowWhenLocked() {         assumeTrue(supportsSecureLock());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential();          launchActivity(TEST_ACTIVITY);          final DisplayContent newDisplay = createManagedExternalDisplaySession()                 .createVirtualDisplay();         launchActivityOnDisplay(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, newDisplay.mId);          lockScreenSession.gotoKeyguard();          waitAndAssertActivityState(TEST_ACTIVITY, STATE_STOPPED,                 ""Expected stopped activity on default display"");         waitAndAssertActivityStateOnDisplay(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, STATE_RESUMED,                 newDisplay.mId, ""Expected resumed activity on secondary display"");     }      /**      * Tests tap and set focus between displays.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.DevicePolicyManagerParentSupportTest"	"testSetAndGetPasswordHistoryLength_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DevicePolicyManagerParentSupportTest.java"	""	"public void testSetAndGetPasswordHistoryLength_onParent() {         if (!mHasSecureLockScreen) {             return;         }         final int passwordHistoryLength = 5;          mParentDevicePolicyManager.setPasswordHistoryLength(                 ADMIN_RECEIVER_COMPONENT, passwordHistoryLength);         final int actualPasswordHistoryLength =                 mParentDevicePolicyManager.getPasswordHistoryLength(ADMIN_RECEIVER_COMPONENT);          assertThat(actualPasswordHistoryLength).isEqualTo(passwordHistoryLength);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.DevicePolicyManagerParentSupportTest"	"testGetPasswordComplexity_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DevicePolicyManagerParentSupportTest.java"	""	"public void testGetPasswordComplexity_onParent() {         if (!mHasSecureLockScreen) {             return;         }          final int actualPasswordComplexity =                 mParentDevicePolicyManager.getPasswordComplexity();         assertThat(actualPasswordComplexity).isEqualTo(                 DevicePolicyManager.PASSWORD_COMPLEXITY_NONE);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.DevicePolicyManagerParentSupportTest"	"testSetAndGetPasswordExpirationTimeout_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DevicePolicyManagerParentSupportTest.java"	""	"public void testSetAndGetPasswordExpirationTimeout_onParent() {         if (!mHasSecureLockScreen) {             return;         }         final int passwordExpirationTimeout = 432000000;          mParentDevicePolicyManager.setPasswordExpirationTimeout(                 ADMIN_RECEIVER_COMPONENT, passwordExpirationTimeout);         final long actualPasswordExpirationTimeout =                 mParentDevicePolicyManager.getPasswordExpirationTimeout(ADMIN_RECEIVER_COMPONENT);          assertThat(actualPasswordExpirationTimeout).isEqualTo(passwordExpirationTimeout);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.DevicePolicyManagerParentSupportTest"	"testGetPasswordExpiration_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DevicePolicyManagerParentSupportTest.java"	""	"public void testGetPasswordExpiration_onParent() {         if (!mHasSecureLockScreen) {             return;         }         final long passwordExpirationTimeout = 432000000;         final long currentTime = System.currentTimeMillis();          mParentDevicePolicyManager.setPasswordExpirationTimeout(                 ADMIN_RECEIVER_COMPONENT, passwordExpirationTimeout);         final long actualPasswordExpiration =                 mParentDevicePolicyManager.getPasswordExpiration(ADMIN_RECEIVER_COMPONENT);          assertThat(actualPasswordExpiration).isAtLeast(passwordExpirationTimeout + currentTime);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.DevicePolicyManagerParentSupportTest"	"testGetMaximumPasswordLength_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DevicePolicyManagerParentSupportTest.java"	""	"public void testGetMaximumPasswordLength_onParent() {         if (!mHasSecureLockScreen) {             return;         }         final int actualMaximumPasswordLength =                 mParentDevicePolicyManager.getPasswordMaximumLength(                         PASSWORD_QUALITY_NUMERIC_COMPLEX);         assertThat(actualMaximumPasswordLength).isGreaterThan(0);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.DevicePolicyManagerParentSupportTest"	"testSetAndGetMaximumFailedPasswordsForWipe_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DevicePolicyManagerParentSupportTest.java"	""	"public void testSetAndGetMaximumFailedPasswordsForWipe_onParent() {         if (!mHasSecureLockScreen) {             return;         }         final int maximumFailedPasswordsForWipe = 15;          mParentDevicePolicyManager.setMaximumFailedPasswordsForWipe(                 ADMIN_RECEIVER_COMPONENT, maximumFailedPasswordsForWipe);         final int actualMaximumFailedPasswordsForWipe =                 mParentDevicePolicyManager.getMaximumFailedPasswordsForWipe(                         ADMIN_RECEIVER_COMPONENT);          assertThat(actualMaximumFailedPasswordsForWipe).isEqualTo(maximumFailedPasswordsForWipe);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.DevicePolicyManagerParentSupportTest"	"testSetAndGetTrustAgentConfiguration_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DevicePolicyManagerParentSupportTest.java"	""	"public void testSetAndGetTrustAgentConfiguration_onParent() {         if (!mHasSecureLockScreen) {             return;         }         final PersistableBundle configuration = new PersistableBundle();         final String key = ""key"";         final String value = ""value"";         configuration.putString(key, value);          mParentDevicePolicyManager.setTrustAgentConfiguration(                 ADMIN_RECEIVER_COMPONENT, FAKE_COMPONENT, configuration);         final PersistableBundle actualConfiguration =                 mParentDevicePolicyManager.getTrustAgentConfiguration(                         ADMIN_RECEIVER_COMPONENT, FAKE_COMPONENT).get(0);          assertThat(actualConfiguration.get(key)).isEqualTo(value);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.DevicePolicyManagerParentSupportTest"	"testSetAndGetRequiredStrongAuthTimeout_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DevicePolicyManagerParentSupportTest.java"	""	"public void testSetAndGetRequiredStrongAuthTimeout_onParent() {         if (!mHasSecureLockScreen) {             return;         }         final int requiredStrongAuthTimeout = 4600000;          mParentDevicePolicyManager.setRequiredStrongAuthTimeout(                 ADMIN_RECEIVER_COMPONENT, requiredStrongAuthTimeout);         final long actualRequiredStrongAuthTimeout =                 mParentDevicePolicyManager.getRequiredStrongAuthTimeout(ADMIN_RECEIVER_COMPONENT);          assertThat(actualRequiredStrongAuthTimeout).isEqualTo(requiredStrongAuthTimeout);     }      public abstract class FakeComponent extends BroadcastReceiver {} }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testCanRelinquishControlOverDevice"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testCanRelinquishControlOverDevice() throws Exception {         if (!mHasFeature) {             return;         }         runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".LockScreenInfoTest"", ""testSetAndGetLockInfo"",                 mUserId);          removeOrgOwnedProfile();         assertHasNoUser(mUserId);          try {             installAppAsUser(DEVICE_ADMIN_APK, mPrimaryUserId);             assertTrue(setDeviceOwner(DEVICE_ADMIN_COMPONENT_FLATTENED,                     mPrimaryUserId, /*expectFailure*/false));             runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".LockScreenInfoTest"", ""testLockInfoIsNull"",                     mPrimaryUserId);         } finally {             removeAdmin(DEVICE_ADMIN_COMPONENT_FLATTENED, mPrimaryUserId);             getDevice().uninstallPackage(DEVICE_ADMIN_PKG);         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testLockScreenInfo"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testLockScreenInfo() throws Exception {         if (!mHasFeature) {             return;         }         runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".LockScreenInfoTest"", mUserId);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfileTest"	"testTrustAgentInfo"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTest.java"	""	"public void testTrustAgentInfo() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         // Set and get trust agent config using child dpm instance.         runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".TrustAgentInfoTest"",                 ""testSetAndGetTrustAgentConfiguration_child"",                 mProfileUserId);         // Set and get trust agent config using parent dpm instance.         runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".TrustAgentInfoTest"",                 ""testSetAndGetTrustAgentConfiguration_parent"",                 mProfileUserId);         // Unified case         runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".TrustAgentInfoTest"",                 ""testSetTrustAgentConfiguration_bothHaveTrustAgentConfigAndUnified"",                 mProfileUserId);         // Non-unified case         try {             changeUserCredential(TEST_PASSWORD, null, mProfileUserId);             runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".TrustAgentInfoTest"",                     ""testSetTrustAgentConfiguration_bothHaveTrustAgentConfigAndNonUnified"",                     mProfileUserId);         } finally {             changeUserCredential(null, TEST_PASSWORD, mProfileUserId);         }     }      // TODO(b/149580605): Fix this flaky test."	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayLockedKeyguardTests"	"supportsMultiDisplay"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayLockedKeyguardTests.java"	""	"/*  *  */  package android.server.wm;  import static android.server.wm.WindowManagerState.STATE_RESUMED; import static android.server.wm.WindowManagerState.STATE_STOPPED; import static android.server.wm.ActivityManagerTestBase.LockScreenSession.FLAG_REMOVE_ACTIVITIES_ON_CLOSE; import static android.server.wm.app.Components.DISMISS_KEYGUARD_ACTIVITY; import static android.server.wm.app.Components.SHOW_WHEN_LOCKED_ACTIVITY; import static android.server.wm.app.Components.TEST_ACTIVITY; import static android.server.wm.app.Components.VIRTUAL_DISPLAY_ACTIVITY;  import static org.junit.Assume.assumeTrue;  import android.platform.test.annotations.Presubmit; import android.server.wm.WindowManagerState.DisplayContent;  import androidx.test.filters.FlakyTest;  import org.junit.Before; import org.junit.Test;  /**  * Display tests that require a locked keyguard.  *  * <p>Build/Install/Run:  *     atest CtsWindowManagerDeviceTestCases:MultiDisplayLockedKeyguardTests  */ @Presubmit @android.server.wm.annotation.Group3 public class MultiDisplayLockedKeyguardTests extends MultiDisplayTestBase {      @Before     @Override     public void setUp() throws Exception {         super.setUp();          assumeTrue(supportsMultiDisplay());         assumeTrue(supportsSecureLock());     }      /**      * Test that virtual display content is hidden when device is locked.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayLockedKeyguardTests"	"testVirtualDisplayHidesContentWhenLocked"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayLockedKeyguardTests.java"	""	"public void testVirtualDisplayHidesContentWhenLocked() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential();          // Create new usual virtual display.         final DisplayContent newDisplay = createManagedVirtualDisplaySession()                 .setPublicDisplay(true)                 .createDisplay();         mWmState.assertVisibility(VIRTUAL_DISPLAY_ACTIVITY, true /* visible */);          // Launch activity on new secondary display.         launchActivityOnDisplay(TEST_ACTIVITY, newDisplay.mId);         mWmState.assertVisibility(TEST_ACTIVITY, true /* visible */);          // Lock the device.         lockScreenSession.gotoKeyguard();         waitAndAssertActivityState(TEST_ACTIVITY, STATE_STOPPED,                 ""Expected stopped activity on secondary display "");         mWmState.assertVisibility(TEST_ACTIVITY, false /* visible */);          // Unlock and check if visibility is back.         lockScreenSession.unlockDevice();          lockScreenSession.enterAndConfirmLockCredential();         mWmState.waitAndAssertKeyguardGone();         waitAndAssertActivityState(TEST_ACTIVITY, STATE_RESUMED,                 ""Expected resumed activity on secondary display"");         mWmState.assertVisibility(TEST_ACTIVITY, true /* visible */);     }      /**      * Tests that private display cannot show content while device locked.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayLockedKeyguardTests"	"testPrivateDisplayHideContentWhenLocked"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayLockedKeyguardTests.java"	""	"public void testPrivateDisplayHideContentWhenLocked() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential();          final DisplayContent newDisplay = createManagedVirtualDisplaySession()                 .setPublicDisplay(false)                 .createDisplay();         launchActivityOnDisplay(TEST_ACTIVITY, newDisplay.mId);          lockScreenSession.gotoKeyguard();          waitAndAssertActivityState(TEST_ACTIVITY, STATE_STOPPED,                 ""Expected stopped activity on private display"");         mWmState.assertVisibility(TEST_ACTIVITY, false /* visible */);     }      /**      * Tests whether a FLAG_DISMISS_KEYGUARD activity on a secondary display dismisses the keyguard.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayLockedKeyguardTests"	"testDismissKeyguard_secondaryDisplay"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayLockedKeyguardTests.java"	""	"public void testDismissKeyguard_secondaryDisplay() {         final LockScreenSession lockScreenSession =                 mObjectTracker.manage(new LockScreenSession(FLAG_REMOVE_ACTIVITIES_ON_CLOSE));         lockScreenSession.setLockCredential();          final DisplayContent newDisplay = createManagedVirtualDisplaySession()                 .setPublicDisplay(true)                 .createDisplay();          lockScreenSession.gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();         getLaunchActivityBuilder().setUseInstrumentation()                 .setTargetActivity(DISMISS_KEYGUARD_ACTIVITY).setNewTask(true)                 .setMultipleTask(true).setDisplayId(newDisplay.mId)                 .setWaitForLaunched(false).execute();         waitAndAssertActivityState(DISMISS_KEYGUARD_ACTIVITY, STATE_STOPPED,                 ""Expected stopped activity on secondary display"");         lockScreenSession.enterAndConfirmLockCredential();         mWmState.waitAndAssertKeyguardGone();         mWmState.assertVisibility(DISMISS_KEYGUARD_ACTIVITY, true);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.MultiDisplayLockedKeyguardTests"	"testDismissKeyguard_whileOccluded_secondaryDisplay"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayLockedKeyguardTests.java"	""	"public void testDismissKeyguard_whileOccluded_secondaryDisplay() {         final LockScreenSession lockScreenSession =                 mObjectTracker.manage(new LockScreenSession(FLAG_REMOVE_ACTIVITIES_ON_CLOSE));         lockScreenSession.setLockCredential();          final DisplayContent newDisplay = createManagedVirtualDisplaySession()                 .setPublicDisplay(true)                 .createDisplay();          lockScreenSession.gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();         launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         getLaunchActivityBuilder().setUseInstrumentation()                 .setTargetActivity(DISMISS_KEYGUARD_ACTIVITY).setNewTask(true)                 .setMultipleTask(true).setDisplayId(newDisplay.mId)                 .setWaitForLaunched(false).execute();         waitAndAssertActivityState(DISMISS_KEYGUARD_ACTIVITY, STATE_STOPPED,                 ""Expected stopped activity on secondary display"");         lockScreenSession.enterAndConfirmLockCredential();         mWmState.waitAndAssertKeyguardGone();         mWmState.computeState(DISMISS_KEYGUARD_ACTIVITY);         mWmState.assertVisibility(DISMISS_KEYGUARD_ACTIVITY, true);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.KeyguardDisabledFeaturesTest"	"testSetKeyguardDisabledFeatures_onParentSilentIgnoreWhenCallerIsNotOrgOwnedPO"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/KeyguardDisabledFeaturesTest.java"	""	"public void testSetKeyguardDisabledFeatures_onParentSilentIgnoreWhenCallerIsNotOrgOwnedPO() {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);          parentDevicePolicyManager.setKeyguardDisabledFeatures(ADMIN_RECEIVER_COMPONENT,                 DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA);          assertThat(mDevicePolicyManager.getKeyguardDisabledFeatures(                 ADMIN_RECEIVER_COMPONENT)).isEqualTo(0);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.KeyguardDisabledFeaturesTest"	"testSetKeyguardDisabledFeatures_onParent"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/KeyguardDisabledFeaturesTest.java"	""	"public void testSetKeyguardDisabledFeatures_onParent() {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);          parentDevicePolicyManager.setKeyguardDisabledFeatures(ADMIN_RECEIVER_COMPONENT,                 DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA);          // Check if the admin has disabled the camera specifically for the keyguard         assertThat(parentDevicePolicyManager.getKeyguardDisabledFeatures(                 ADMIN_RECEIVER_COMPONENT)).isEqualTo(                 DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA);          removeKeyguardDisableFeatures(parentDevicePolicyManager);         parentDevicePolicyManager.setKeyguardDisabledFeatures(ADMIN_RECEIVER_COMPONENT,                 DevicePolicyManager.KEYGUARD_DISABLE_SECURE_NOTIFICATIONS);          // Check if the admin has disabled notifications specifically for the keyguard         assertThat(parentDevicePolicyManager.getKeyguardDisabledFeatures(                 ADMIN_RECEIVER_COMPONENT)).isEqualTo(                 DevicePolicyManager.KEYGUARD_DISABLE_SECURE_NOTIFICATIONS);         removeKeyguardDisableFeatures(parentDevicePolicyManager);     }      private void removeKeyguardDisableFeatures(DevicePolicyManager devicePolicyManager) {         devicePolicyManager.setKeyguardDisabledFeatures(ADMIN_RECEIVER_COMPONENT,                 DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_NONE);     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.SplitScreenTests"	"testRotationWhenDockedWhileLocked"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/SplitScreenTests.java"	""	"public void testRotationWhenDockedWhileLocked() {         launchActivitiesInSplitScreen(                 getLaunchActivityBuilder().setTargetActivity(LAUNCHING_ACTIVITY),                 getLaunchActivityBuilder().setTargetActivity(TEST_ACTIVITY));         mWmState.assertSanity();         mWmState.assertContainsStack(""Must contain fullscreen stack."",                 WINDOWING_MODE_SPLIT_SCREEN_SECONDARY, ACTIVITY_TYPE_STANDARD);         mWmState.assertContainsStack(""Must contain docked stack."",                 WINDOWING_MODE_SPLIT_SCREEN_PRIMARY, ACTIVITY_TYPE_STANDARD);          final RotationSession rotationSession = createManagedRotationSession();         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         for (int i = 0; i < 4; i++) {             lockScreenSession.sleepDevice();             // The display may not be rotated while device is locked.             rotationSession.set(i, false /* waitDeviceRotation */);             lockScreenSession.wakeUpDevice()                     .unlockDevice();             mWmState.computeState(LAUNCHING_ACTIVITY, TEST_ACTIVITY);         }     }      /**      * Verify split screen mode visibility after stack resize occurs.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.ActivityVisibilityTests"	"testTurnScreenOnActivity"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityVisibilityTests.java"	""	"public void testTurnScreenOnActivity() {         assumeTrue(supportsLockScreen());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final ActivitySessionClient activityClient = createManagedActivityClientSession();         testTurnScreenOnActivity(lockScreenSession, activityClient, true /* useWindowFlags */);         testTurnScreenOnActivity(lockScreenSession, activityClient, false /* useWindowFlags */);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.ActivityVisibilityTests"	"testTurnScreenOnActivity_slowLaunch"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityVisibilityTests.java"	""	"public void testTurnScreenOnActivity_slowLaunch() {         assumeTrue(supportsLockScreen());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final ActivitySessionClient activityClient = createManagedActivityClientSession();         // The activity will be paused first because the flags turn-screen-on and show-when-locked         // haven't been applied from relayout. And if it is slow, the ensure-visibility from pause         // timeout should still notify the client activity to be visible. Then the relayout can         // send the visible request to apply the flags and turn on screen.         testTurnScreenOnActivity(lockScreenSession, activityClient, true /* useWindowFlags */,                 1000 /* sleepMsInOnCreate */);     }      private void testTurnScreenOnActivity(LockScreenSession lockScreenSession,             ActivitySessionClient activitySessionClient, boolean useWindowFlags) {         testTurnScreenOnActivity(lockScreenSession, activitySessionClient, useWindowFlags,                 0 /* sleepMsInOnCreate */);     }      private void testTurnScreenOnActivity(LockScreenSession lockScreenSession,             ActivitySessionClient activitySessionClient, boolean useWindowFlags,             int sleepMsInOnCreate) {         lockScreenSession.sleepDevice();          final ActivitySession activity = activitySessionClient.startActivity(                 getLaunchActivityBuilder().setUseInstrumentation().setIntentExtra(extra -> {                     extra.putBoolean(Components.TurnScreenOnActivity.EXTRA_USE_WINDOW_FLAGS,                             useWindowFlags);                     extra.putLong(Components.TurnScreenOnActivity.EXTRA_SLEEP_MS_IN_ON_CREATE,                             sleepMsInOnCreate);                 }).setTargetActivity(TURN_SCREEN_ON_ACTIVITY));          mWmState.assertVisibility(TURN_SCREEN_ON_ACTIVITY, true);         assertTrue(""Display turns on by "" + (useWindowFlags ? ""flags"" : ""APIs""),                 isDisplayOn(DEFAULT_DISPLAY));          activity.finish();     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.ActivityVisibilityTests"	"testTurnScreenOnAttrNoLockScreen"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityVisibilityTests.java"	""	"public void testTurnScreenOnAttrNoLockScreen() {         assumeTrue(supportsLockScreen());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.disableLockScreen().sleepDevice();         separateTestJournal();         launchActivity(TURN_SCREEN_ON_ATTR_ACTIVITY);         mWmState.assertVisibility(TURN_SCREEN_ON_ATTR_ACTIVITY, true);         assertTrue(""Display turns on"", isDisplayOn(DEFAULT_DISPLAY));         assertSingleLaunch(TURN_SCREEN_ON_ATTR_ACTIVITY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.ActivityVisibilityTests"	"testTurnScreenOnAttrWithLockScreen"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityVisibilityTests.java"	""	"public void testTurnScreenOnAttrWithLockScreen() {         assumeTrue(supportsSecureLock());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.setLockCredential().sleepDevice();         separateTestJournal();         launchActivityNoWait(TURN_SCREEN_ON_ATTR_ACTIVITY);         // Wait for the activity stopped because lock screen prevent showing the activity.         mWmState.waitForActivityState(TURN_SCREEN_ON_ATTR_ACTIVITY, STATE_STOPPED);         assertFalse(""Display keeps off"", isDisplayOn(DEFAULT_DISPLAY));         assertSingleLaunchAndStop(TURN_SCREEN_ON_ATTR_ACTIVITY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.ActivityVisibilityTests"	"testTurnScreenOnShowOnLockAttr"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityVisibilityTests.java"	""	"public void testTurnScreenOnShowOnLockAttr() {         assumeTrue(supportsLockScreen());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.sleepDevice();         mWmState.waitForAllStoppedActivities();         separateTestJournal();         launchActivity(TURN_SCREEN_ON_SHOW_ON_LOCK_ACTIVITY);         mWmState.assertVisibility(TURN_SCREEN_ON_SHOW_ON_LOCK_ACTIVITY, true);         assertTrue(""Display turns on"", isDisplayOn(DEFAULT_DISPLAY));         assertSingleLaunch(TURN_SCREEN_ON_SHOW_ON_LOCK_ACTIVITY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.ActivityVisibilityTests"	"testTurnScreenOnAttrRemove"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityVisibilityTests.java"	""	"public void testTurnScreenOnAttrRemove() {         assumeTrue(supportsLockScreen());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.sleepDevice();         mWmState.waitForAllStoppedActivities();         separateTestJournal();         launchActivity(TURN_SCREEN_ON_ATTR_REMOVE_ATTR_ACTIVITY);         assertTrue(""Display turns on"", isDisplayOn(DEFAULT_DISPLAY));         assertSingleLaunch(TURN_SCREEN_ON_ATTR_REMOVE_ATTR_ACTIVITY);          lockScreenSession.sleepDevice();         mWmState.waitForAllStoppedActivities();         separateTestJournal();         launchActivity(TURN_SCREEN_ON_ATTR_REMOVE_ATTR_ACTIVITY);         mWmState.waitForActivityState(TURN_SCREEN_ON_ATTR_REMOVE_ATTR_ACTIVITY, STATE_STOPPED);         // Display should keep off, because setTurnScreenOn(false) has been called at         // {@link TURN_SCREEN_ON_ATTR_REMOVE_ATTR_ACTIVITY}'s onStop.         assertFalse(""Display keeps off"", isDisplayOn(DEFAULT_DISPLAY));         assertSingleStartAndStop(TURN_SCREEN_ON_ATTR_REMOVE_ATTR_ACTIVITY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.ActivityVisibilityTests"	"testTurnScreenOnSingleTask"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityVisibilityTests.java"	""	"public void testTurnScreenOnSingleTask() {         assumeTrue(supportsLockScreen());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.sleepDevice();         separateTestJournal();         launchActivity(TURN_SCREEN_ON_SINGLE_TASK_ACTIVITY, WINDOWING_MODE_FULLSCREEN);         mWmState.assertVisibility(TURN_SCREEN_ON_SINGLE_TASK_ACTIVITY, true);         assertTrue(""Display turns on"", isDisplayOn(DEFAULT_DISPLAY));         assertSingleLaunch(TURN_SCREEN_ON_SINGLE_TASK_ACTIVITY);          lockScreenSession.sleepDevice();         // We should make sure test activity stopped to prevent a false alarm stop state         // included in the lifecycle count.         waitAndAssertActivityState(TURN_SCREEN_ON_SINGLE_TASK_ACTIVITY, STATE_STOPPED,                 ""Activity should be stopped"");         separateTestJournal();         launchActivity(TURN_SCREEN_ON_SINGLE_TASK_ACTIVITY);         mWmState.assertVisibility(TURN_SCREEN_ON_SINGLE_TASK_ACTIVITY, true);         // Wait more for display state change since turning the display ON may take longer         // and reported after the activity launch.         waitForDefaultDisplayState(true /* wantOn */);         assertTrue(""Display turns on"", isDisplayOn(DEFAULT_DISPLAY));         assertSingleStart(TURN_SCREEN_ON_SINGLE_TASK_ACTIVITY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.ActivityVisibilityTests"	"testTurnScreenOnActivity_withRelayout"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityVisibilityTests.java"	""	"public void testTurnScreenOnActivity_withRelayout() {         assumeTrue(supportsLockScreen());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.sleepDevice();         launchActivity(TURN_SCREEN_ON_WITH_RELAYOUT_ACTIVITY);         mWmState.assertVisibility(TURN_SCREEN_ON_WITH_RELAYOUT_ACTIVITY, true);          lockScreenSession.sleepDevice();         waitAndAssertActivityState(TURN_SCREEN_ON_WITH_RELAYOUT_ACTIVITY, STATE_STOPPED,                 ""Activity should be stopped"");         assertFalse(""Display keeps off"", isDisplayOn(DEFAULT_DISPLAY));     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testKeyguardHidesActivity"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testKeyguardHidesActivity() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(TEST_ACTIVITY);         mWmState.computeState(TEST_ACTIVITY);         mWmState.assertVisibility(TEST_ACTIVITY, true);         lockScreenSession.gotoKeyguard();         mWmState.computeState();         mWmState.assertKeyguardShowingAndNotOccluded();         assertTrue(mKeyguardManager.isKeyguardLocked());         mWmState.assertVisibility(TEST_ACTIVITY, false);          mObjectTracker.close(lockScreenSession);         assertFalse(mKeyguardManager.isKeyguardLocked());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testShowWhenLockedActivity"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"@FlakyTest(bugId = 110276714)     public void testShowWhenLockedActivity() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         lockScreenSession.gotoKeyguard(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState();         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         mWmState.assertKeyguardShowingAndOccluded();     }      /**      * Tests whether dialogs from SHOW_WHEN_LOCKED activities are also visible if Keyguard is      * showing.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testShowWhenLockedActivity_withDialog"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testShowWhenLockedActivity_withDialog() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY, true);         lockScreenSession.gotoKeyguard(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY);         mWmState.waitFor((wmState) -> wmState.allWindowSurfacesShown(                 getWindowName(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY)),                 ""Wait for all windows visible for "" + SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY, true);         assertTrue(mWmState.allWindowSurfacesShown(                 getWindowName(SHOW_WHEN_LOCKED_WITH_DIALOG_ACTIVITY)));         mWmState.assertKeyguardShowingAndOccluded();     }      /**      * Tests whether multiple SHOW_WHEN_LOCKED activities are shown if the topmost is translucent.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testMultipleShowWhenLockedActivities"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testMultipleShowWhenLockedActivities() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         launchActivity(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY,                 SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY, true);         lockScreenSession.gotoKeyguard(                 SHOW_WHEN_LOCKED_ACTIVITY, SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY);         mWmState.computeState();         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY, true);         mWmState.assertKeyguardShowingAndOccluded();     }      /**      * Tests that when top SHOW_WHEN_LOCKED activity is finishing and the next one is also      * SHOW_WHEN_LOCKED, it should be able to resume next SHOW_WHEN_LOCKED activity.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testFinishMultipleShowWhenLockedActivities"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testFinishMultipleShowWhenLockedActivities() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final ActivitySessionClient activitySession = createManagedActivityClientSession();          launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         final ActivitySession showWhenLockedActivitySession =                 activitySession.startActivity(getLaunchActivityBuilder()                         .setUseInstrumentation()                         .setNewTask(true)                         .setMultipleTask(true)                         .setTargetActivity(SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY));          mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY, SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY, true);         mWmState.assertFocusedActivity(""Launching Activity must be focused"",                 SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY);         lockScreenSession.gotoKeyguard(SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY);          mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY, true);         mWmState.assertFocusedActivity(""Top activity stay un-change"",                 SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY);         mWmState.assertKeyguardShowingAndOccluded();          showWhenLockedActivitySession.finish();         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         mWmState.assertFocusedActivity(""ShowWhenLocked activity must occludes keyguard"",                 SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.assertKeyguardShowingAndOccluded();     }      /**      * If we have a translucent SHOW_WHEN_LOCKED_ACTIVITY, the wallpaper should also be showing.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testTranslucentShowWhenLockedActivity"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testTranslucentShowWhenLockedActivity() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY, true);         lockScreenSession.gotoKeyguard(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY);         mWmState.computeState();         mWmState.assertVisibility(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY, true);         assertWallpaperShowing();         mWmState.assertKeyguardShowingAndOccluded();     }      /**      * If we have a translucent SHOW_WHEN_LOCKED activity, the activity behind should not be shown.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testTranslucentDoesntRevealBehind"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"@FlakyTest     public void testTranslucentDoesntRevealBehind() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(TEST_ACTIVITY);         launchActivity(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY);         mWmState.computeState(TEST_ACTIVITY, SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY);         mWmState.assertVisibility(TEST_ACTIVITY, true);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY, true);         lockScreenSession.gotoKeyguard(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY);         mWmState.computeState();         mWmState.assertVisibility(SHOW_WHEN_LOCKED_TRANSLUCENT_ACTIVITY, true);         mWmState.assertVisibility(TEST_ACTIVITY, false);         mWmState.assertKeyguardShowingAndOccluded();     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testDialogShowWhenLockedActivity"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testDialogShowWhenLockedActivity() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_DIALOG_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_DIALOG_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_DIALOG_ACTIVITY, true);         lockScreenSession.gotoKeyguard();         mWmState.computeState();         mWmState.assertVisibility(SHOW_WHEN_LOCKED_DIALOG_ACTIVITY, true);         assertWallpaperShowing();         mWmState.assertKeyguardShowingAndOccluded();     }      /**      * Test that showWhenLocked activity is fullscreen when shown over keyguard      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testShowWhenLockedActivityWhileSplit"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"@Presubmit     public void testShowWhenLockedActivityWhileSplit() {         assumeTrue(supportsSplitScreenMultiWindow());          final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivitiesInSplitScreen(                 getLaunchActivityBuilder().setTargetActivity(LAUNCHING_ACTIVITY),                 getLaunchActivityBuilder().setTargetActivity(SHOW_WHEN_LOCKED_ACTIVITY)                         .setRandomData(true)                         .setMultipleTask(false));         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         lockScreenSession.gotoKeyguard(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         mWmState.assertKeyguardShowingAndOccluded();         mWmState.assertDoesNotContainStack(""Activity must be full screen."",                 WINDOWING_MODE_SPLIT_SCREEN_PRIMARY, ACTIVITY_TYPE_STANDARD);     }      /**      * Tests whether an activity that has called setInheritShowWhenLocked(true) above a      * SHOW_WHEN_LOCKED activity is visible if Keyguard is locked.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testInheritShowWhenLockedAdd"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"@FlakyTest     public void testInheritShowWhenLockedAdd() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, true);          launchActivity(INHERIT_SHOW_WHEN_LOCKED_ADD_ACTIVITY);         mWmState.computeState(                 SHOW_WHEN_LOCKED_ATTR_ACTIVITY, INHERIT_SHOW_WHEN_LOCKED_ADD_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, false);         mWmState.assertVisibility(INHERIT_SHOW_WHEN_LOCKED_ADD_ACTIVITY, true);          lockScreenSession.gotoKeyguard();         mWmState.computeState();         mWmState.assertKeyguardShowingAndOccluded();         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, false);         mWmState.assertVisibility(INHERIT_SHOW_WHEN_LOCKED_ADD_ACTIVITY, true);     }      /**      * Tests whether an activity that has the manifest attribute inheritShowWhenLocked but then      * calls setInheritShowWhenLocked(false) above a SHOW_WHEN_LOCKED activity is invisible if      * Keyguard is locked.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testInheritShowWhenLockedRemove"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"@FlakyTest     public void testInheritShowWhenLockedRemove() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, true);          launchActivity(INHERIT_SHOW_WHEN_LOCKED_REMOVE_ACTIVITY);         mWmState.computeState(                 SHOW_WHEN_LOCKED_ATTR_ACTIVITY, INHERIT_SHOW_WHEN_LOCKED_REMOVE_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, false);         mWmState.assertVisibility(INHERIT_SHOW_WHEN_LOCKED_REMOVE_ACTIVITY, true);          lockScreenSession.gotoKeyguard();         mWmState.computeState();         mWmState.assertKeyguardShowingAndNotOccluded();         assertTrue(mKeyguardManager.isKeyguardLocked());         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, false);         mWmState.assertVisibility(INHERIT_SHOW_WHEN_LOCKED_REMOVE_ACTIVITY, false);     }      /**      * Tests whether an activity that has the manifest attribute inheritShowWhenLocked above a      * SHOW_WHEN_LOCKED activity is visible if Keyguard is locked.      * */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testInheritShowWhenLockedAttr"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"@FlakyTest     public void testInheritShowWhenLockedAttr() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, true);          launchActivity(INHERIT_SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         mWmState.computeState(                 SHOW_WHEN_LOCKED_ATTR_ACTIVITY, INHERIT_SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, false);         mWmState.assertVisibility(INHERIT_SHOW_WHEN_LOCKED_ATTR_ACTIVITY, true);          lockScreenSession.gotoKeyguard();         mWmState.computeState();         mWmState.assertKeyguardShowingAndOccluded();         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, false);         mWmState.assertVisibility(INHERIT_SHOW_WHEN_LOCKED_ATTR_ACTIVITY, true);     }      /**      * Tests whether an activity that doesn't have the manifest attribute inheritShowWhenLocked      * above a SHOW_WHEN_LOCKED activity is invisible if Keyguard is locked.      * */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testNoInheritShowWhenLocked"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"@FlakyTest     public void testNoInheritShowWhenLocked() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         launchActivity(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, true);          launchActivity(NO_INHERIT_SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         mWmState.computeState(                 SHOW_WHEN_LOCKED_ATTR_ACTIVITY, NO_INHERIT_SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, false);         mWmState.assertVisibility(NO_INHERIT_SHOW_WHEN_LOCKED_ATTR_ACTIVITY, true);          lockScreenSession.gotoKeyguard();         mWmState.computeState();         mWmState.assertKeyguardShowingAndNotOccluded();         assertTrue(mKeyguardManager.isKeyguardLocked());         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, false);         mWmState.assertVisibility(NO_INHERIT_SHOW_WHEN_LOCKED_ATTR_ACTIVITY, false);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testNoTransientConfigurationWhenShowWhenLockedRequestsOrientation"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testNoTransientConfigurationWhenShowWhenLockedRequestsOrientation() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final ActivitySessionClient activitySession = createManagedActivityClientSession();          final ActivitySession showWhenLockedActivitySession =                 activitySession.startActivity(getLaunchActivityBuilder()                         .setUseInstrumentation()                         .setTargetActivity(SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY));         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY, true);          lockScreenSession.gotoKeyguard(SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY);          separateTestJournal();          final int displayId = mWmState                 .getDisplayByActivity(SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY);         WindowManagerState.DisplayContent display = mWmState                 .getDisplay(displayId);         final int origDisplayOrientation = display.mFullConfiguration.orientation;         final int orientation = origDisplayOrientation == Configuration.ORIENTATION_LANDSCAPE                 ? SCREEN_ORIENTATION_PORTRAIT                 : SCREEN_ORIENTATION_LANDSCAPE;         showWhenLockedActivitySession.requestOrientation(orientation);          mWmState.waitForActivityOrientation(SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY,                 orientation == SCREEN_ORIENTATION_LANDSCAPE                         ? Configuration.ORIENTATION_LANDSCAPE                         : Configuration.ORIENTATION_PORTRAIT);          display = mWmState.getDisplay(displayId);          // If the window is a non-fullscreen window (e.g. a freeform window) or the display is         // squared, there won't be activity lifecycle.         if (display.mFullConfiguration.orientation != origDisplayOrientation) {             assertActivityLifecycle(SHOW_WHEN_LOCKED_ATTR_ROTATION_ACTIVITY,                     false /* relaunched */);         }     }      /**      * Test that when a normal activity finished and an existing FLAG_DISMISS_KEYGUARD activity      * becomes the top activity, it should be resumed.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testResumeShowWhenLockedActivityFromBackground"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testResumeShowWhenLockedActivityFromBackground() {         testResumeOccludingActivityFromBackground(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);     }      private void testResumeOccludingActivityFromBackground(ComponentName occludingActivity) {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();          // Launch an activity which is able to occlude keyguard.         getLaunchActivityBuilder().setUseInstrumentation()                 .setTargetActivity(occludingActivity).execute();          // Launch an activity without SHOW_WHEN_LOCKED and finish it.         getLaunchActivityBuilder().setUseInstrumentation()                 .setMultipleTask(true)                 // Don't wait for activity visible because keyguard will show.                 .setWaitForLaunched(false)                 .setTargetActivity(BROADCAST_RECEIVER_ACTIVITY).execute();         mWmState.waitForKeyguardShowingAndNotOccluded();         mWmState.assertKeyguardShowingAndNotOccluded();          mBroadcastActionTrigger.finishBroadcastReceiverActivity();         mWmState.waitForKeyguardShowingAndOccluded();          // The occluding activity should be resumed because it becomes the top activity.         mWmState.computeState(occludingActivity);         mWmState.assertVisibility(occludingActivity, true);         assertTrue(occludingActivity + "" must be resumed."",                 mWmState.hasActivityState(occludingActivity,                         WindowManagerState.STATE_RESUMED));     }      /**      * Tests whether a FLAG_DISMISS_KEYGUARD activity occludes Keyguard.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testDismissKeyguardActivity"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testDismissKeyguardActivity() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.gotoKeyguard();         mWmState.computeState();         assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);         launchActivity(DISMISS_KEYGUARD_ACTIVITY);         mWmState.waitForKeyguardShowingAndOccluded();         mWmState.computeState(DISMISS_KEYGUARD_ACTIVITY);         mWmState.assertVisibility(DISMISS_KEYGUARD_ACTIVITY, true);         mWmState.assertKeyguardShowingAndOccluded();     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testDismissKeyguardActivity_method"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testDismissKeyguardActivity_method() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         separateTestJournal();         lockScreenSession.gotoKeyguard();         mWmState.computeState();         assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);         launchActivity(DISMISS_KEYGUARD_METHOD_ACTIVITY);         mWmState.waitForKeyguardGone();         mWmState.computeState(DISMISS_KEYGUARD_METHOD_ACTIVITY);         mWmState.assertVisibility(DISMISS_KEYGUARD_METHOD_ACTIVITY, true);         assertFalse(mWmState.getKeyguardControllerState().keyguardShowing);         assertOnDismissSucceeded(DISMISS_KEYGUARD_METHOD_ACTIVITY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testDismissKeyguardActivity_method_notTop"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testDismissKeyguardActivity_method_notTop() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         separateTestJournal();         lockScreenSession.gotoKeyguard();         mWmState.computeState();         assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);         launchActivity(BROADCAST_RECEIVER_ACTIVITY);         launchActivity(TEST_ACTIVITY);         mBroadcastActionTrigger.dismissKeyguardByMethod();         assertOnDismissError(BROADCAST_RECEIVER_ACTIVITY);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testDismissKeyguardActivity_method_turnScreenOn"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testDismissKeyguardActivity_method_turnScreenOn() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         separateTestJournal();         lockScreenSession.sleepDevice();         mWmState.computeState();         assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);         launchActivity(TURN_SCREEN_ON_DISMISS_KEYGUARD_ACTIVITY);         mWmState.waitForKeyguardGone();         mWmState.computeState(TURN_SCREEN_ON_DISMISS_KEYGUARD_ACTIVITY);         mWmState.assertVisibility(TURN_SCREEN_ON_DISMISS_KEYGUARD_ACTIVITY, true);         assertFalse(mWmState.getKeyguardControllerState().keyguardShowing);         assertOnDismissSucceeded(TURN_SCREEN_ON_DISMISS_KEYGUARD_ACTIVITY);         assertTrue(isDisplayOn(DEFAULT_DISPLAY));     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testDismissKeyguard_fromShowWhenLocked_notAllowed"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testDismissKeyguard_fromShowWhenLocked_notAllowed() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();         launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);         mWmState.assertKeyguardShowingAndOccluded();         mBroadcastActionTrigger.dismissKeyguardByFlag();         mWmState.assertKeyguardShowingAndOccluded();         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testKeyguardLock"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testKeyguardLock() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();         launchActivity(KEYGUARD_LOCK_ACTIVITY);         mWmState.computeState(KEYGUARD_LOCK_ACTIVITY);         mWmState.assertVisibility(KEYGUARD_LOCK_ACTIVITY, true);         mBroadcastActionTrigger.finishBroadcastReceiverActivity();         mWmState.waitForKeyguardShowingAndNotOccluded();         mWmState.assertKeyguardShowingAndNotOccluded();     }       /**      * Turn on keyguard, and launch an activity on top of the keyguard.      * Next, change the orientation of the device to rotate the activity.      * The activity should still remain above keyguard at this point.      * Send the 'finish' broadcast to dismiss the activity.      * Ensure that the activity is gone, and the keyguard is visible.      */"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testUnoccludedRotationChange"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testUnoccludedRotationChange() {         // Go home now to make sure Home is behind Keyguard.         launchHomeActivity();         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final RotationSession rotationSession = createManagedRotationSession();         lockScreenSession.gotoKeyguard();         mWmState.assertKeyguardShowingAndNotOccluded();          launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);         mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);          rotationSession.set(ROTATION_90);         mBroadcastActionTrigger.finishBroadcastReceiverActivity();         mWmState.waitForKeyguardShowingAndNotOccluded();         mWmState.waitForDisplayUnfrozen();         mWmState.waitForAppTransitionIdleOnDisplay(DEFAULT_DISPLAY);         mWmState.assertSanity();         mWmState.assertHomeActivityVisible(false);         mWmState.assertKeyguardShowingAndNotOccluded();         // The {@link SHOW_WHEN_LOCKED_ACTIVITY} has gone because of the 'finish' broadcast.         mWmState.waitAndAssertActivityRemoved(SHOW_WHEN_LOCKED_ACTIVITY);     }      private void assertWallpaperShowing() {         WindowState wallpaper =                 mWmState.findFirstWindowWithType(TYPE_WALLPAPER);         assertNotNull(wallpaper);         assertTrue(wallpaper.isSurfaceShown());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testDismissKeyguardAttrActivity_method_turnScreenOn"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testDismissKeyguardAttrActivity_method_turnScreenOn() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         lockScreenSession.sleepDevice();          separateTestJournal();         mWmState.computeState();         assertTrue(mWmState.getKeyguardControllerState().keyguardShowing);         launchActivity(TURN_SCREEN_ON_ATTR_DISMISS_KEYGUARD_ACTIVITY);         mWmState.waitForKeyguardGone();         mWmState.assertVisibility(TURN_SCREEN_ON_ATTR_DISMISS_KEYGUARD_ACTIVITY, true);         assertFalse(mWmState.getKeyguardControllerState().keyguardShowing);         assertOnDismissSucceeded(TURN_SCREEN_ON_ATTR_DISMISS_KEYGUARD_ACTIVITY);         assertTrue(isDisplayOn(DEFAULT_DISPLAY));     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testScreenOffWhileOccludedStopsActivityAod"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testScreenOffWhileOccludedStopsActivityAod() {         try (final AodSession aodSession = new AodSession()) {             assumeTrue(aodSession.isAodAvailable());             aodSession.setAodEnabled(true);             testScreenOffWhileOccludedStopsActivity(true /* assertAod */);         }     }      /**      * @param assertAod {@code true} to check AOD status, {@code false} otherwise. Note that when      *        AOD is disabled for the default display, AOD status shouldn't be checked.      */     private void testScreenOffWhileOccludedStopsActivity(boolean assertAod) {         try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             separateTestJournal();             lockScreenSession.gotoKeyguard();             mWmState.assertKeyguardShowingAndNotOccluded();             launchActivity(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);             waitAndAssertTopResumedActivity(SHOW_WHEN_LOCKED_ATTR_ACTIVITY, DEFAULT_DISPLAY,                     ""Activity with showWhenLocked attribute should be resumed."");             mWmState.assertKeyguardShowingAndOccluded();             if (assertAod) {                 mWmState.assertAodNotShowing();             }             lockScreenSession.sleepDevice();             if (assertAod) {                 mWmState.assertAodShowing();             }             mWmState.waitForAllStoppedActivities();             assertSingleLaunchAndStop(SHOW_WHEN_LOCKED_ATTR_ACTIVITY);         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardTests"	"testScreenOffCausesSingleStopAod"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardTests.java"	""	"public void testScreenOffCausesSingleStopAod() {         try (final AodSession aodSession = new AodSession()) {             assumeTrue(aodSession.isAodAvailable());             aodSession.setAodEnabled(true);             testScreenOffCausesSingleStop();         }     }      private void testScreenOffCausesSingleStop() {         try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             separateTestJournal();             launchActivity(TEST_ACTIVITY);             mWmState.assertVisibility(TEST_ACTIVITY, true);             lockScreenSession.sleepDevice();             mWmState.waitForAllStoppedActivities();             assertSingleLaunchAndStop(TEST_ACTIVITY);         }      }  }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.ScreenCaptureDisabledTest"	"testSetScreenCaptureDisabledOnParent_false"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ScreenCaptureDisabledTest.java"	""	"public void testSetScreenCaptureDisabledOnParent_false() {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         parentDevicePolicyManager.setScreenCaptureDisabled(ADMIN_RECEIVER_COMPONENT, false);         assertFalse(parentDevicePolicyManager.getScreenCaptureDisabled(ADMIN_RECEIVER_COMPONENT));         assertFalse(parentDevicePolicyManager.getScreenCaptureDisabled(null /* any admin */));     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceandprofileowner.ScreenCaptureDisabledTest"	"testSetScreenCaptureDisabledOnParent_true"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"getParentProfileInstance"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ScreenCaptureDisabledTest.java"	""	"public void testSetScreenCaptureDisabledOnParent_true() {         DevicePolicyManager parentDevicePolicyManager =                 mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);         parentDevicePolicyManager.setScreenCaptureDisabled(ADMIN_RECEIVER_COMPONENT, true);         assertTrue(parentDevicePolicyManager.getScreenCaptureDisabled(ADMIN_RECEIVER_COMPONENT));         assertTrue(parentDevicePolicyManager.getScreenCaptureDisabled(null /* any admin */));     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.appsecurity.cts.ResumeOnRebootHostTest"	"isSupportedDevice"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ResumeOnRebootHostTest.java"	""	"public void resumeOnReboot_TwoUsers_BothUserUnlock_Success() throws Exception {         if (!isSupportedDevice()) {             CLog.v(TAG, ""Device not supported; skipping test"");             return;         }          if (!mSupportsMultiUser) {             CLog.v(TAG, ""Device doesn't support multi-user; skipping test"");             return;         }          int[] users = Utils.prepareMultipleUsers(getDevice(), 2);         int initialUser = users[0];         int secondaryUser = users[1];          try {             installTestPackages();              switchUser(secondaryUser);             deviceSetup(secondaryUser);              switchUser(initialUser);             deviceSetup(initialUser);              deviceRequestLskf();              deviceLock(initialUser);             deviceEnterLskf(initialUser);              switchUser(secondaryUser);             deviceEnterLskf(secondaryUser);              deviceRebootAndApply();              // Try to start early to calm down broadcast storms.             getDevice().startUser(secondaryUser);              runDeviceTestsAsUser(""testVerifyUnlockedAndDismiss"", initialUser);              switchUser(secondaryUser);             runDeviceTestsAsUser(""testVerifyUnlockedAndDismiss"", secondaryUser);         } finally {             try {                 // Remove secure lock screens and tear down test app                 switchUser(secondaryUser);                 runDeviceTestsAsUser(""testTearDown"", secondaryUser);                 switchUser(initialUser);                 runDeviceTestsAsUser(""testTearDown"", initialUser);                  deviceClearLskf();             } finally {                 removeTestPackages();                  getDevice().rebootUntilOnline();                 getDevice().waitForDeviceAvailable();             }         }     }      private void deviceSetup(int userId) throws Exception {         // To receive boot broadcasts, kick our other app out of stopped state         getDevice().executeShellCommand(""am start -a android.intent.action.MAIN""                 + "" --user "" + userId                 + "" -c android.intent.category.LAUNCHER com.android.cts.splitapp/.MyActivity"");          // Give enough time for PackageManager to persist stopped state         Thread.sleep(15000);          runDeviceTestsAsUser(""testSetUp"", userId);          // Give enough time for vold to update keys         Thread.sleep(15000);     }      private void deviceRequestLskf() throws Exception {         String res = getDevice().executeShellCommand(""cmd recovery request-lskf cts-test1"");         if (res == null || !res.contains(""success"")) {             fail(""could not set up recovery request-lskf"");         }     }      private void deviceClearLskf() throws Exception {         String res = getDevice().executeShellCommand(""cmd recovery clear-lskf"");         if (res == null || !res.contains(""success"")) {             fail(""could not clear-lskf"");         }     }      private void deviceLock(int userId) throws Exception {         int retriesLeft = 3;         boolean retry = false;         do {             if (retry) {                 CLog.i(""Retrying to summon lockscreen..."");                 try {                     Thread.sleep(500);                 } catch (InterruptedException ignored) {}             }             runDeviceTestsAsUser(""testLockScreen"", userId);             retry = !LockScreenInspector.newInstance(getDevice()).isDisplayedAndNotOccluded();         } while (retriesLeft-- > 0 && retry);          if (retry) {             CLog.e(""Could not summon lockscreen..."");             fail(""Device could not be locked"");         }     }      private void deviceEnterLskf(int userId) throws Exception {         runDeviceTestsAsUser(""testUnlockScreen"", userId);     }      private void deviceRebootAndApply() throws Exception {         String res = getDevice().executeShellCommand(""cmd recovery reboot-and-apply cts-test1 cts-test"");         if (res != null && res.contains(""failure"")) {             fail(""could not call reboot-and-apply"");         }          getDevice().waitForDeviceNotAvailable(SHUTDOWN_TIME_MS);         getDevice().waitForDeviceOnline(120000);          waitForBootCompleted(getDevice());     }      private void installTestPackages() throws Exception {         new InstallMultiple().addFile(APK).run();         new InstallMultiple().addFile(OTHER_APK).run();     }      private void removeTestPackages() throws DeviceNotAvailableException {         getDevice().uninstallPackage(PKG);         getDevice().uninstallPackage(OTHER_PKG);     }      private ArrayList<Integer> listUsers() throws DeviceNotAvailableException {         return getDevice().listUsers();     }      /**      * Calls switch-user, but without trying to dismiss the keyguard.      */     private void switchUser(int userId) throws Exception {         getDevice().switchUser(userId);         HostSideTestUtils.waitUntil(""Could not switch users"", 5,                 () -> getDevice().getCurrentUser() == userId);         Thread.sleep(USER_SWITCH_WAIT);     }      private void stopUserAsync(int userId) throws Exception {         String stopUserCommand = ""am stop-user -f "" + userId;         CLog.d(""starting command \"""" + stopUserCommand);         CLog.d(""Output for command "" + stopUserCommand + "": ""                 + getDevice().executeShellCommand(stopUserCommand));     }      private void removeUser(int userId) throws Exception  {         if (listUsers().contains(userId) && userId != USER_SYSTEM) {             // Don't log output, as tests sometimes set no debug user restriction, which             // causes this to fail, we should still continue and remove the user.             String stopUserCommand = ""am stop-user -w -f "" + userId;             CLog.d(""stopping and removing user "" + userId);             getDevice().executeShellCommand(stopUserCommand);             // Ephemeral users may have already been removed after being stopped.             if (listUsers().contains(userId)) {                 assertThat(""Couldn't remove user"", getDevice().removeUser(userId), is(true));             }         }     }      private int createManagedProfile(int parentUserId) throws DeviceNotAvailableException {         String commandOutput = getCreateManagedProfileCommandOutput(parentUserId);         return getUserIdFromCreateUserCommandOutput(commandOutput);     }      private int getUserIdFromCreateUserCommandOutput(String commandOutput) {         // Extract the id of the new user.         String[] tokens = commandOutput.split(""\\s+"");         assertThat(commandOutput + "" expected to have format \""Success: {USER_ID}\"""",                 tokens.length, greaterThan(0));         assertThat(""Command output should start with \""Success\"""" + commandOutput, tokens[0],                 is(""Success:""));         return Integer.parseInt(tokens[tokens.length - 1]);     }      private String getCreateManagedProfileCommandOutput(int parentUserId)             throws DeviceNotAvailableException {         String command = ""pm create-user --profileOf "" + parentUserId + "" --managed ""                 + ""TestProfile_"" + System.currentTimeMillis();         CLog.d(""Starting command "" + command);         String commandOutput = getDevice().executeShellCommand(command);         CLog.d(""Output for command "" + command + "": "" + commandOutput);         return commandOutput;     }      private void runDeviceTestsAsUser(String testMethodName, int userId)             throws DeviceNotAvailableException {         Utils.runDeviceTestsAsCurrentUser(getDevice(), PKG, CLASS, testMethodName);     }      private boolean isSupportedDevice() throws Exception {         return getDevice().hasFeature(FEATURE_DEVICE_ADMIN) && getDevice().hasFeature(FEATURE_REBOOT_ESCROW);     }      private class InstallMultiple extends BaseInstallMultiple<InstallMultiple> {         public InstallMultiple() {             super(getDevice(), getBuild(), getAbi());         }     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.lifecycle.ActivityLifecycleTopResumedStateTests"	"testTopPositionLaunchedBehindLockScreen"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleTopResumedStateTests.java"	""	"public void testTopPositionLaunchedBehindLockScreen() throws Exception {         assumeTrue(supportsSecureLock());          try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             lockScreenSession.setLockCredential().gotoKeyguard();              new Launcher(CallbackTrackingActivity.class)                     .setExpectedState(ON_STOP)                     .setNoInstance()                     .launch();             LifecycleVerifier.assertLaunchAndStopSequence(CallbackTrackingActivity.class,                     getLifecycleLog(), true /* onTop */);              getLifecycleLog().clear();         }          // Lock screen removed - activity should be on top now         waitAndAssertActivityStates(state(CallbackTrackingActivity.class, ON_TOP_POSITION_GAINED));         LifecycleVerifier.assertStopToResumeSequence(CallbackTrackingActivity.class,                 getLifecycleLog());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.lifecycle.ActivityLifecycleTopResumedStateTests"	"testTopPositionRemovedBehindLockScreen"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleTopResumedStateTests.java"	""	"public void testTopPositionRemovedBehindLockScreen() throws Exception {         assumeTrue(supportsSecureLock());          final Activity activity = launchActivityAndWait(CallbackTrackingActivity.class);          getLifecycleLog().clear();         try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             lockScreenSession.setLockCredential().gotoKeyguard();              waitAndAssertActivityStates(state(activity, ON_STOP));             LifecycleVerifier.assertResumeToStopSequence(CallbackTrackingActivity.class,                     getLifecycleLog());              getLifecycleLog().clear();         }          // Lock screen removed - activity should be on top now         waitAndAssertActivityStates(state(activity, ON_TOP_POSITION_GAINED));         LifecycleVerifier.assertStopToResumeSequence(CallbackTrackingActivity.class,                 getLifecycleLog());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.lifecycle.ActivityLifecycleTopResumedStateTests"	"testTopPositionLaunchedOnTopOfLockScreen"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleTopResumedStateTests.java"	""	"public void testTopPositionLaunchedOnTopOfLockScreen() throws Exception {         assumeTrue(supportsSecureLock());          final Activity showWhenLockedActivity;         try (final LockScreenSession lockScreenSession = new LockScreenSession()) {             lockScreenSession.setLockCredential().gotoKeyguard();              showWhenLockedActivity =                     launchActivityAndWait(ShowWhenLockedCallbackTrackingActivity.class);              // TODO(b/123432490): Fix extra pause/resume             LifecycleVerifier.assertSequence(ShowWhenLockedCallbackTrackingActivity.class,                     getLifecycleLog(),                     Arrays.asList(                             PRE_ON_CREATE, ON_CREATE, ON_START, ON_POST_CREATE, ON_RESUME,                             ON_TOP_POSITION_GAINED, ON_TOP_POSITION_LOST, ON_PAUSE, ON_RESUME,                             ON_TOP_POSITION_GAINED),                     ""launchAboveKeyguard"");              getLifecycleLog().clear();         }          // Lock screen removed, but nothing should change.         // Wait for something here, but don't expect anything to happen.         waitAndAssertActivityStates(state(showWhenLockedActivity, ON_DESTROY));         LifecycleVerifier.assertResumeToDestroySequence(                 ShowWhenLockedCallbackTrackingActivity.class, getLifecycleLog());     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.security.identity.cts.UserAuthTest"	"isDeviceLocked"	"CtsIdentityTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/UserAuthTest.java"	""	"/*  *.  */  package android.security.identity.cts;  import static android.security.identity.IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256;  import android.security.identity.AccessControlProfile; import android.security.identity.AccessControlProfileId; import android.security.identity.AlreadyPersonalizedException; import android.security.identity.PersonalizationData; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.WritableIdentityCredential; import android.security.identity.ResultData;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.content.Context; import android.os.SystemClock; import android.util.Log;  import androidx.test.InstrumentationRegistry;  import android.app.KeyguardManager; import android.server.wm.ActivityManagerTestBase;  import org.junit.Test;  import java.io.ByteArrayOutputStream; import java.io.IOException; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.KeyPair; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.Signature; import java.security.SignatureException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.util.Arrays; import java.util.ArrayList; import java.util.Collection; import java.util.LinkedHashMap; import java.util.LinkedList; import java.util.Map;  import co.nstant.in.cbor.CborBuilder; import co.nstant.in.cbor.CborEncoder; import co.nstant.in.cbor.CborException;  import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.PrivateKey; import java.security.UnrecoverableEntryException;  import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.spec.GCMParameterSpec;  import android.security.keystore.KeyGenParameterSpec; import android.security.keystore.KeyProperties; import android.security.keystore.UserNotAuthenticatedException;   public class UserAuthTest {     private static final String TAG = ""UserAuthTest"";      private class DeviceLockSession extends ActivityManagerTestBase implements AutoCloseable {          private LockScreenSession mLockCredential;          public DeviceLockSession() throws Exception {             mLockCredential = new LockScreenSession();             mLockCredential.setLockCredential();         }          public void performDeviceLock() {             mLockCredential.sleepDevice();             Context appContext = InstrumentationRegistry.getTargetContext();             KeyguardManager keyguardManager = (KeyguardManager)appContext.                                               getSystemService(Context.KEYGUARD_SERVICE);             for (int i = 0; i < 25 && !keyguardManager.isDeviceLocked(); i++) {                 SystemClock.sleep(200);             }         }          public void performDeviceUnlock() throws Exception {             mLockCredential.gotoKeyguard();             mLockCredential.enterAndConfirmLockCredential();             launchHomeActivity();         }          @Override         public void close() throws Exception {             mLockCredential.close();         }     }      private boolean checkAuthBoundKey(String alias) {         // Unfortunately there are no APIs to tell if a key needs user authentication to work so         // we check if the key is available by simply trying to encrypt some data.         try {             KeyStore ks = KeyStore.getInstance(""AndroidKeyStore"");             ks.load(null);             KeyStore.Entry entry = ks.getEntry(alias, null);             SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();              Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");             cipher.init(Cipher.ENCRYPT_MODE, secretKey);             byte[] clearText = {0x01, 0x02};             byte[] cipherText = cipher.doFinal(clearText);             return true;         } catch (UserNotAuthenticatedException e) {             return false;         } catch (Exception e) {             throw new RuntimeException(""Failed!"", e);         }     }      void createAuthBoundKey(String alias, int timeoutSeconds) {         try {             KeyGenerator kg = KeyGenerator.getInstance(                 KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");             KeyGenParameterSpec.Builder builder =                     new KeyGenParameterSpec.Builder(                         alias,                         KeyProperties.PURPOSE_ENCRYPT| KeyProperties.PURPOSE_DECRYPT)                             .setBlockModes(KeyProperties.BLOCK_MODE_GCM)                             .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)                             .setUserAuthenticationRequired(true)                             .setUserAuthenticationValidityDurationSeconds(timeoutSeconds)                             .setKeySize(128);             kg.init(builder.build());             kg.generateKey();         } catch (InvalidAlgorithmParameterException                 | NoSuchAlgorithmException                 | NoSuchProviderException e) {             throw new RuntimeException(""Error creating auth-bound key"", e);         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.server.wm.KeyguardInputTests"	"testReceiveKeysOnTopOfKeyguard"	"CtsWindowManagerDeviceTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/KeyguardInputTests.java"	""	"public void testReceiveKeysOnTopOfKeyguard() {         final LockScreenSession lockScreenSession = createManagedLockScreenSession();         final ComponentName KEY_EVENT_ACTIVITY = new ComponentName(""android.server.wm.cts"",                 ""android.server.wm.KeyEventActivity"");         lockScreenSession.gotoKeyguard(KEY_EVENT_ACTIVITY);         pressBackButton();         assertReceivedKey(KeyEvent.KEYCODE_BACK);         assertNoMoreEvents();     }      private void assertReceivedKey(int keycode) {         KeyEvent event = mActivity.popKey();         assertNotNull(event);         assertEquals(keycode, event.getKeyCode());         assertEquals(KeyEvent.ACTION_DOWN, event.getAction());         event = mActivity.popKey();         assertNotNull(event);         assertEquals(keycode, event.getKeyCode());         assertEquals(KeyEvent.ACTION_UP, event.getAction());     }      private void assertNoMoreEvents() {         KeyEvent event = mActivity.popKey();         assertNull(event);     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.net.ipsec.ike.cts.IkeSessionParamsTest"	"testSetPcscfConfigRequests"	"CtsIkeTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/ipsec/src/android/net/ipsec/ike/cts/IkeSessionParamsTest.java"	""	"public void testSetPcscfConfigRequests() throws Exception {         IkeSessionParams sessionParams =                 createIkeParamsBuilderMinimum()                         .setRetransmissionTimeoutsMillis(RETRANS_TIMEOUT_MS_LIST)                         .addPcscfServerRequest(AF_INET)                         .addPcscfServerRequest(PCSCF_IPV4_ADDRESS_1)                         .addPcscfServerRequest(PCSCF_IPV6_ADDRESS_1)                         .addPcscfServerRequest(AF_INET6)                         .addPcscfServerRequest(PCSCF_IPV4_ADDRESS_2)                         .addPcscfServerRequest(PCSCF_IPV6_ADDRESS_2)                         .build();          verifyIkeParamsMinimum(sessionParams);         verifyConfigRequestTypes(EXPECTED_REQ_COUNT, sessionParams.getConfigurationRequests());          Set<InetAddress> resultAddresses = new HashSet<>();         for (IkeConfigRequest req : sessionParams.getConfigurationRequests()) {             if (req instanceof ConfigRequestIpv4PcscfServer                     && ((ConfigRequestIpv4PcscfServer) req).getAddress() != null) {                 resultAddresses.add(((ConfigRequestIpv4PcscfServer) req).getAddress());             } else if (req instanceof ConfigRequestIpv6PcscfServer                     && ((ConfigRequestIpv6PcscfServer) req).getAddress() != null) {                 resultAddresses.add(((ConfigRequestIpv6PcscfServer) req).getAddress());             }         }         assertEquals(EXPECTED_PCSCF_SERVERS, resultAddresses);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"android.media.cts.DecoderTest"	"testTrackSelectionMkv"	"CtsMediaTestCases"	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DPC"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testTrackSelectionMkv() throws Exception {         Log.d(TAG, ""testTrackSelectionMkv!!!!!! "");         testTrackSelection(R.raw.mkv_avc_adpcm_ima);         Log.d(TAG, ""mkv_avc_adpcm_ima finished!!!!!! "");         testTrackSelection(R.raw.mkv_avc_adpcm_ms);         Log.d(TAG, ""mkv_avc_adpcm_ms finished!!!!!! "");         testTrackSelection(R.raw.mkv_avc_wma);         Log.d(TAG, ""mkv_avc_wma finished!!!!!! "");         testTrackSelection(R.raw.mkv_avc_mp2);         Log.d(TAG, ""mkv_avc_mp2 finished!!!!!! "");     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.DisallowSharingIntoProfileTest"	"testDisableSharingIntoProfile"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DevicePolicyManager.ACTION"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DisallowSharingIntoProfileTest.java"	""	"public void testDisableSharingIntoProfile() throws Exception {         setSharingEnabled(false);     }      private void setSharingEnabled(boolean enabled) throws InterruptedException {         final CountDownLatch latch = new CountDownLatch(1);         BroadcastReceiver receiver = new BroadcastReceiver() {             @Override             public void onReceive(Context context, Intent intent) {                 latch.countDown();             }         };         IntentFilter filter = new IntentFilter();         filter.addAction(DevicePolicyManager.ACTION_DATA_SHARING_RESTRICTION_APPLIED);         mContext.registerReceiver(receiver, filter);         try {             if (enabled) {                 mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,                         UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE);             } else {                 mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT,                         UserManager.DISALLOW_SHARE_INTO_MANAGED_PROFILE);             }             // Wait for the restriction to apply             assertTrue(""Restriction not applied after 60 seconds"", latch.await(60, SECONDS));         } finally {             mContext.unregisterReceiver(receiver);         }     }      private void assertCrossProfileIntentsResolvability(List<Intent> intents,             ResolveInfo expectedForwarder, boolean expectForwardable) {         for (Intent intent : intents) {             List<ResolveInfo> resolveInfoList = mContext.getPackageManager().queryIntentActivities(                     intent,                     PackageManager.MATCH_DEFAULT_ONLY);             if (expectForwardable) {                 assertTrue(""Expect "" + intent + "" to be forwardable, but resolve list""                         + "" does not contain expected intent forwarder "" + expectedForwarder,                         containsResolveInfo(resolveInfoList, expectedForwarder));             } else {                 assertFalse(""Expect "" + intent + "" not to be forwardable, but resolve list ""                         + ""contains intent forwarder "" + expectedForwarder,                         containsResolveInfo(resolveInfoList, expectedForwarder));             }         }     }      private ResolveInfo getIntentForwarder(Intent intent) {         List<ResolveInfo> result = mContext.getPackageManager().queryIntentActivities(intent,                 PackageManager.MATCH_DEFAULT_ONLY);         assertEquals(""Expect only one resolve result for "" + intent, 1, result.size());         return result.get(0);     }      private boolean containsResolveInfo(List<ResolveInfo> list, ResolveInfo info) {         for (ResolveInfo entry : list) {             if (entry.activityInfo.packageName.equals(info.activityInfo.packageName)                     && entry.activityInfo.name.equals(info.activityInfo.name)) {                 return true;             }         }         return false;     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.deviceowner.DeviceOwnerProvisioningTest"	"getSystemPackageNameList"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DevicePolicyManager.ACTION"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/DeviceOwnerProvisioningTest.java"	""	"public void test/*  *.  */ package com.android.cts.deviceowner;  import static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED; import static android.content.pm.PackageManager.MATCH_SYSTEM_ONLY; import static java.util.stream.Collectors.toList;  import android.app.admin.DevicePolicyManager; import android.content.Intent; import android.content.pm.ApplicationInfo; import android.content.pm.PackageManager; import android.util.Log;  import com.android.compatibility.common.util.devicepolicy.provisioning.SilentProvisioningTestManager; import java.util.ArrayList; import java.util.List;   public class DeviceOwnerProvisioningTest extends BaseDeviceOwnerTest {     private static final String TAG = ""DeviceOwnerProvisioningTest"";      private List<String> mEnabledAppsBeforeTest;     private PackageManager mPackageManager;     private DevicePolicyManager mDpm;      @Override     protected void setUp() throws Exception {         super.setUp();          mPackageManager = getContext().getPackageManager();         mDpm = getContext().getSystemService(DevicePolicyManager.class);         mEnabledAppsBeforeTest = getSystemPackageNameList();     }      @Override     protected void tearDown() throws Exception {         enableUninstalledApp();         super.tearDown();     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.managedprofile.ProvisioningTest"	"PersistableBundle"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"DevicePolicyManager.ACTION"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ProvisioningTest.java"	""	"/*  *.  */ package com.android.cts.managedprofile;  import static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_SKIP_ENCRYPTION;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.accounts.Account; import android.accounts.AccountManager; import android.app.admin.DeviceAdminReceiver; import android.app.admin.DevicePolicyManager; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.SharedPreferences; import android.os.PersistableBundle; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest;  import com.android.compatibility.common.util.devicepolicy.provisioning.SilentProvisioningTestManager;  import org.junit.Before; import org.junit.Test;  @SmallTest public class ProvisioningTest {     private static final String TAG = ProvisioningTest.class.getSimpleName();      private static final String SHARED_PREFERENCE_FILE_NAME = ""shared-preferences-file-name"";      private static final PersistableBundle ADMIN_EXTRAS_BUNDLE = new PersistableBundle();     private static final String ADMIN_EXTRAS_BUNDLE_KEY_1 = ""KEY_1"";     private static final String ADMIN_EXTRAS_BUNDLE_VALUE_1 = ""VALUE_1"";     static {         ADMIN_EXTRAS_BUNDLE.putString(ADMIN_EXTRAS_BUNDLE_KEY_1, ADMIN_EXTRAS_BUNDLE_VALUE_1);     }      public static final String KEY_PROVISIONING_SUCCESSFUL_RECEIVED =             ""key-provisioning-successful-received"";      private static final ComponentName ADMIN_RECEIVER_COMPONENT = new ComponentName(             ProvisioningAdminReceiver.class.getPackage().getName(),             ProvisioningAdminReceiver.class.getName());      public static class ProvisioningAdminReceiver extends DeviceAdminReceiver {         @Override         public void onProfileProvisioningComplete(Context context, Intent intent) {             super.onProfileProvisioningComplete(context, intent);             // Enabled profile             getManager(context).setProfileName(ADMIN_RECEIVER_COMPONENT, ""Managed Profile"");             getManager(context).setProfileEnabled(ADMIN_RECEIVER_COMPONENT);             Log.i(TAG, ""onProfileProvisioningComplete"");              saveBundle(context, intent.getParcelableExtra(EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE));         }     }      private Context mContext;     private DevicePolicyManager mDpm;      @Before     public void setUp() {         mContext = InstrumentationRegistry.getTargetContext();         mDpm = mContext.getSystemService(DevicePolicyManager.class);     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.PasswordComplexityTest"	"testGetPasswordComplexity"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/PasswordComplexityTest.java"	""	"public void testGetPasswordComplexity() throws Exception {         if (!mHasSecureLockScreen) {             return;         }          assertMetricsLogged(                 getDevice(),                 () -> runDeviceTestsAsUser(PKG, CLS, mCurrentUserId),                 new DevicePolicyEventWrapper                         .Builder(EventId.GET_USER_PASSWORD_COMPLEXITY_LEVEL_VALUE)                         .setStrings(""notCalledFromParent"", PKG).build());     } }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfilePasswordTest"	"testLockNowWithKeyEviction"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfilePasswordTest.java"	""	"public void testLockNowWithKeyEviction() throws Exception {         if (!mHasFeature || !mSupportsFbe || !mHasSecureLockScreen) {             return;         }         changeUserCredential(TEST_PASSWORD, null, mProfileUserId);         lockProfile();     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfilePasswordTest"	"testPasswordMinimumRestrictions"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfilePasswordTest.java"	""	"public void testPasswordMinimumRestrictions() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".PasswordMinimumRestrictionsTest"",                 mProfileUserId);     }      @FlakyTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfilePasswordTest"	"testResetPasswordWithTokenBeforeUnlock"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfilePasswordTest.java"	""	"public void testResetPasswordWithTokenBeforeUnlock() throws Exception {         if (!mHasFeature || !mSupportsFbe || !mHasSecureLockScreen) {             return;         }          runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".ResetPasswordWithTokenTest"",                 ""testSetupWorkProfile"", mProfileUserId);         lockProfile();         runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".ResetPasswordWithTokenTest"",                 ""testResetPasswordBeforeUnlock"", mProfileUserId);         // Password needs to be in sync with ResetPasswordWithTokenTest.PASSWORD1         verifyUserCredential(RESET_PASSWORD_TEST_DEFAULT_PASSWORD, mProfileUserId);     }      @FlakyTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfilePasswordTest"	"testClearPasswordWithTokenBeforeUnlock"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfilePasswordTest.java"	""	"public void testClearPasswordWithTokenBeforeUnlock() throws Exception {         if (!mHasFeature || !mSupportsFbe || !mHasSecureLockScreen) {             return;         }          runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".ResetPasswordWithTokenTest"",                 ""testSetupWorkProfile"", mProfileUserId);         lockProfile();         runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".ResetPasswordWithTokenTest"",                 ""testClearPasswordBeforeUnlock"", mProfileUserId);         // Make sure profile has no password         verifyUserCredential("""", mProfileUserId);     }      /**      * Test password reset token is still functional after the primary user clears and      * re-adds back its device lock. This is to detect a regression where the work profile      * undergoes an untrusted credential reset (causing synthetic password to change, invalidating      * existing password reset token) if it has unified work challenge and the primary user clears      * the device lock.      */     @FlakyTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfilePasswordTest"	"testResetPasswordTokenUsableAfterClearingLock"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfilePasswordTest.java"	""	"public void testResetPasswordTokenUsableAfterClearingLock() throws Exception {         if (!mHasFeature || !mSupportsFbe || !mHasSecureLockScreen) {             return;         }         final String devicePassword = TEST_PASSWORD;          runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".ResetPasswordWithTokenTest"",                 ""testSetResetPasswordToken"", mProfileUserId);         try {             changeUserCredential(devicePassword, null, mParentUserId);             changeUserCredential(null, devicePassword, mParentUserId);             changeUserCredential(devicePassword, null, mParentUserId);             lockProfile();             runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".ResetPasswordWithTokenTest"",                     ""testResetPasswordBeforeUnlock"", mProfileUserId);             verifyUserCredential(RESET_PASSWORD_TEST_DEFAULT_PASSWORD, mProfileUserId);         } finally {             changeUserCredential(null, devicePassword, mParentUserId);             // Cycle the device screen to flush stale password information from keyguard,             // otherwise it will still ask for the non-existent password.             // return screen to be on for cts test runs             executeShellCommand(""input keyevent KEYCODE_WAKEUP"");             executeShellCommand(""input keyevent KEYCODE_SLEEP"");             executeShellCommand(""input keyevent KEYCODE_WAKEUP"");         }     }      @LockSettingsTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfilePasswordTest"	"testIsUsingUnifiedPassword"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfilePasswordTest.java"	""	"public void testIsUsingUnifiedPassword() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }          // Freshly created profile has no separate challenge.         verifyUnifiedPassword(true);          // Set separate challenge and verify that the API reports it correctly.         changeUserCredential(                 TEST_PASSWORD /* newCredential */, null /* oldCredential */, mProfileUserId);         verifyUnifiedPassword(false);     }      @FlakyTest     @LargeTest     @LockSettingsTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfilePasswordTest"	"testUnlockWorkProfile_deviceWidePassword"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfilePasswordTest.java"	""	"public void testUnlockWorkProfile_deviceWidePassword() throws Exception {         if (!mHasFeature || !mSupportsFbe || !mHasSecureLockScreen) {             return;         }         try {             // Add a device password after the work profile has been created.             changeUserCredential(TEST_PASSWORD, /* oldCredential= */ null, mPrimaryUserId);             // Lock the profile with key eviction.             lockProfile();             // Turn on work profile, by unlocking the profile with the device password.             verifyUserCredential(TEST_PASSWORD, mPrimaryUserId);              // Verify profile user is running unlocked by running a sanity test on the work profile.             installAppAsUser(SIMPLE_APP_APK, mProfileUserId);             runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".SanityTest"", mProfileUserId);         } finally {             // Clean up             changeUserCredential(/* newCredential= */ null, TEST_PASSWORD, mPrimaryUserId);         }     }      @FlakyTest     @LargeTest     @LockSettingsTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfilePasswordTest"	"testRebootDevice_unifiedPassword"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfilePasswordTest.java"	""	"public void testRebootDevice_unifiedPassword() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         // Waiting before rebooting prevents flakiness.         waitForBroadcastIdle();         changeUserCredential(TEST_PASSWORD, /* oldCredential= */ null, mPrimaryUserId);         try {             rebootAndWaitUntilReady();             verifyUserCredential(TEST_PASSWORD, mPrimaryUserId);             waitForUserUnlock(mProfileUserId);             installAppAsUser(SIMPLE_APP_APK, mProfileUserId);             runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".SanityTest"", mProfileUserId);         } finally {             changeUserCredential(/* newCredential= */ null, TEST_PASSWORD, mPrimaryUserId);             // Work-around for http://b/113866275 - password prompt being erroneously shown at the             // end.             pressPowerButton();         }     }      @LargeTest     @LockSettingsTest"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfilePasswordTest"	"testRebootDevice_separatePasswords"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfilePasswordTest.java"	""	"public void testRebootDevice_separatePasswords() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen) {             return;         }         // Waiting before rebooting prevents flakiness.         waitForBroadcastIdle();         final String profilePassword = ""profile"";         final String primaryPassword = TEST_PASSWORD;         int managedProfileUserId = getFirstManagedProfileUserId();         changeUserCredential(                 profilePassword, /* oldCredential= */ null, managedProfileUserId);         changeUserCredential(primaryPassword, /* oldCredential= */ null, mPrimaryUserId);         try {             rebootAndWaitUntilReady();             verifyUserCredential(profilePassword, managedProfileUserId);             verifyUserCredential(primaryPassword, mPrimaryUserId);             installAppAsUser(SIMPLE_APP_APK, mProfileUserId);             runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".SanityTest"", mProfileUserId);         } finally {             changeUserCredential(                     /* newCredential= */ null, profilePassword, managedProfileUserId);             changeUserCredential(/* newCredential= */ null, primaryPassword, mPrimaryUserId);             // Work-around for http://b/113866275 - password prompt being erroneously shown at the             // end.             pressPowerButton();         }     }"	""	""	""	""	""
"3.9.2"	"3.9.2"	"C-2-1"	""	"com.android.cts.devicepolicy.ManagedProfilePasswordTest"	"testCreateSeparateChallengeChangedLogged"	""	""	"3.9.2/C-2-1"	"""C-2-1] MUST support the ability to specify a separate lock screen meeting the following requirements to grant access to apps running in a managed profile only. Device implementations MUST honor the DevicePolicyManager.ACTION_SET_NEW_PASSWORD intent and show an interface to configure a separate lock screen credential for the managed profile. The lock screen credentials of the managed profile MUST use the same credential storage and management mechanisms as the parent profile, as documented on the Android Open Source Project Site. The DPC password policies MUST apply to only the managed profile's lock screen credentials unless called upon the DevicePolicyManager instance returned by getParentProfileInstance. When contacts from the managed profile are displayed in the preinstalled call log, in-call UI, in-progress and missed-call notifications, contacts and messaging apps they SHOULD be badged with the same badge used to indicate managed profile applications. <h4 id="""	""	"DevicePolicyManager.ACTION DPC lockscreen ACTION_SET_NEW_PASSWORD getParentProfileInstance"	""	""	""	"lockscreen"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfilePasswordTest.java"	""	"public void testCreateSeparateChallengeChangedLogged() throws Exception {         if (!mHasFeature || !mHasSecureLockScreen || !isStatsdEnabled(getDevice())) {             return;         }         assertMetricsLogged(getDevice(), () -> {             changeUserCredential(                     TEST_PASSWORD /* newCredential */, null /* oldCredential */, mProfileUserId);         }, new DevicePolicyEventWrapper.Builder(EventId.SEPARATE_PROFILE_CHALLENGE_CHANGED_VALUE)                 .setBoolean(true)                 .build());     }      private void verifyUnifiedPassword(boolean unified) throws DeviceNotAvailableException {         final String testMethod =                 unified ? ""testUsingUnifiedPassword"" : ""testNotUsingUnifiedPassword"";         runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".IsUsingUnifiedPasswordTest"",                 testMethod, mProfileUserId);     }      private void lockProfile() throws Exception {         final String cmd = ""am broadcast --receiver-foreground --user "" + mProfileUserId                 + "" -a com.android.cts.managedprofile.LOCK_PROFILE""                 + "" com.android.cts.managedprofile/.LockProfileReceiver"";         getDevice().executeShellCommand(cmd);         waitUntilProfileLocked();     }      private void waitUntilProfileLocked() throws Exception {         final String cmd = String.format(""am get-started-user-state %d"", mProfileUserId);         tryWaitForSuccess(                 () -> getDevice().executeShellCommand(cmd).startsWith(USER_STATE_LOCKED),                 ""The managed profile has not been locked after calling ""                         + ""lockNow(FLAG_SECURE_USER_DATA)"",                 TIMEOUT_USER_LOCKED_MILLIS);     } }"	""	""	""	""	""
