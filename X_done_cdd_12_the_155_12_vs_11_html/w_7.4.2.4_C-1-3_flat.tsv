"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.TestBase"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/TestBase.java"	""	"public void test/*
 *.
 */

package android.net.wifi.rtt.cts;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiManager;
import android.net.wifi.cts.WifiJUnit3TestBase;
import android.net.wifi.rtt.RangingResult;
import android.net.wifi.rtt.RangingResultCallback;
import android.net.wifi.rtt.WifiRttManager;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
 * Base class for Wi-Fi RTT CTS test cases. Provides a uniform configuration and event management
 * facility.
 */
public class TestBase extends WifiJUnit3TestBase {
    protected static final String TAG = ""WifiRttCtsTests"";

    // wait for Wi-Fi RTT to become available
    private static final int WAIT_FOR_RTT_CHANGE_SECS = 10;

    // wait for Wi-Fi scan results to become available
    private static final int WAIT_FOR_SCAN_RESULTS_SECS = 20;

    // wait for network selection and connection finish
    private static final int WAIT_FOR_CONNECTION_FINISH_MS = 30_000;

    // Interval between failure scans
    private static final int INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS = 5_000;

    // 5GHz Frequency band
    private static final int FREQUENCY_OF_5GHZ_BAND_IN_MHZ = 5_000;

    protected WifiRttManager mWifiRttManager;
    protected WifiManager mWifiManager;
    private LocationManager mLocationManager;
    private WifiManager.WifiLock mWifiLock;

    private final HandlerThread mHandlerThread = new HandlerThread(""SingleDeviceTest"");
    protected final Executor mExecutor;
    private Boolean mWasVerboseLoggingEnabled;

    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    /**
     * Returns a flag indicating whether or not Wi-Fi RTT should be tested. Wi-Fi RTT
     * should be tested if the feature is supported on the current device.
     */
    static boolean shouldTestWifiRtt(Context context) {
        final PackageManager pm = context.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_WIFI_RTT);
    }

    /**
     * Returns a flag indicating whether or not Wi-Fi Aware should be tested. Wi-Fi Aware
     * should be tested if the feature is supported on the current device.
     */
    static boolean shouldTestWifiAware(Context context) {
        final PackageManager pm = context.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        if (!shouldTestWifiRtt(getContext())) {
            return;
        }

        mLocationManager = (LocationManager) getContext().getSystemService(
                Context.LOCATION_SERVICE);
        assertTrue(""RTT testing requires Location to be enabled"",
                mLocationManager.isLocationEnabled());

        mWifiRttManager = (WifiRttManager) getContext().getSystemService(
                Context.WIFI_RTT_RANGING_SERVICE);
        assertNotNull(""Wi-Fi RTT Manager"", mWifiRttManager);

        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(""Wi-Fi Manager"", mWifiManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        if (!mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable"");
            // Turn on Wi-Fi may trigger connection. Wait connection state stable.
            scanAps();
            Thread.sleep(WAIT_FOR_CONNECTION_FINISH_MS);
        }
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiRttManager.ACTION_WIFI_RTT_STATE_CHANGED);
        WifiRttBroadcastReceiver receiver = new WifiRttBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);
        if (!mWifiRttManager.isAvailable()) {
            assertTrue(""Timeout waiting for Wi-Fi RTT to change status"",
                    receiver.waitForStateChange());
            assertTrue(""Wi-Fi RTT is not available (should be)"", mWifiRttManager.isAvailable());
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (!shouldTestWifiRtt(getContext())) {
            super.tearDown();
            return;
        }

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));

        super.tearDown();
    }

    class WifiRttBroadcastReceiver extends BroadcastReceiver {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiRttManager.ACTION_WIFI_RTT_STATE_CHANGED.equals(intent.getAction())) {
                mBlocker.countDown();
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_RTT_CHANGE_SECS, TimeUnit.SECONDS);
        }
    }

    class WifiScansBroadcastReceiver extends BroadcastReceiver {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiManager.SCAN_RESULTS_AVAILABLE_ACTION.equals(intent.getAction())) {
                mBlocker.countDown();
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_SCAN_RESULTS_SECS, TimeUnit.SECONDS);
        }
    }

    class ResultCallback extends RangingResultCallback {
        private CountDownLatch mBlocker = new CountDownLatch(1);
        private int mCode; // 0: success, otherwise RangingResultCallback STATUS_CODE_*.
        private List<RangingResult> mResults;

        @Override
        public void onRangingFailure(int code) {
            mCode = code;
            mResults = null; // not necessary since intialized to null - but for completeness
            mBlocker.countDown();
        }

        @Override
        public void onRangingResults(List<RangingResult> results) {
            mCode = 0; // not necessary since initialized to 0 - but for completeness
            mResults = results;
            mBlocker.countDown();
        }

        /**
         * Waits for the listener callback to be called - or an error (timeout, interruption).
         * Returns true on callback called, false on error (timeout, interruption).
         */
        boolean waitForCallback() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_RTT_CHANGE_SECS, TimeUnit.SECONDS);
        }

        /**
         * Returns the code of the callback operation. Will be 0 for success (onRangingResults
         * called), else (if onRangingFailure called) will be one of the STATUS_CODE_* values.
         */
        int getCode() {
            return mCode;
        }

        /**
         * Returns the list of ranging results. In cases of error (getCode() != 0) will return null.
         */
        List<RangingResult> getResults() {
            return mResults;
        }
    }

    /**
     * Start a scan and return a list of observed ScanResults (APs).
     */
    protected List<ScanResult> scanAps() throws InterruptedException {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        WifiScansBroadcastReceiver receiver = new WifiScansBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);

        mWifiManager.startScan();
        receiver.waitForStateChange();
        mContext.unregisterReceiver(receiver);
        return mWifiManager.getScanResults();
    }

    /**
     * Start a scan and return a test AP which supports IEEE 802.11mc and which has the highest
     * RSSI. Will perform N (parameterized) scans and get the best AP across both scans.
     *
     * Returns null if test AP is not found in the specified number of scans.
     *
     * @param numScanRetries Maximum number of scans retries (in addition to first scan).
     */
    protected ScanResult scanForTest11mcCapableAp(int numScanRetries)
            throws InterruptedException {
        int scanCount = 0;
        ScanResult bestTestAp = null;
        while (scanCount <= numScanRetries) {
            for (ScanResult scanResult : scanAps()) {
                if (!scanResult.is80211mcResponder()) {
                    continue;
                }
                if (bestTestAp == null || scanResult.level > bestTestAp.level) {
                    bestTestAp = scanResult;
                }
            }
            if (bestTestAp == null) {
                // Ongoing connection may cause scan failure, wait for a while before next scan.
                Thread.sleep(INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS);
            }
            scanCount++;
        }
        return bestTestAp;
    }

    /**
     * Start a scan and return a test AP which does NOT support IEEE 802.11mc, with a BSS in the
     * 5GHz band, and which has the highest RSSI. Will perform N (parameterized) scans and get
     * the best AP across all scan results.
     *
     * Returns null if test AP is not found in the specified number of scans.
     *
     * @param numScanRetries Maximum number of scans retries (in addition to first scan).
     */
    protected ScanResult scanForTestNon11mcCapableAp(int numScanRetries)
            throws InterruptedException {
        int scanCount = 0;
        ScanResult bestTestAp = null;
        while (scanCount <= numScanRetries) {
            for (ScanResult scanResult : scanAps()) {
                // Ensure using a 5GHz or greater channel
                if (scanResult.is80211mcResponder()
                        || scanResult.centerFreq0 < FREQUENCY_OF_5GHZ_BAND_IN_MHZ) {
                    continue;
                }
                if (bestTestAp == null || scanResult.level > bestTestAp.level) {
                    bestTestAp = scanResult;
                }
            }
            if (bestTestAp == null) {
                // Ongoing connection may cause scan failure, wait for a while before next scan.
                Thread.sleep(INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS);
            }
            scanCount++;
        }
        return bestTestAp;
    }
}"	""	""	"IEEE select"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"testWifiInfoProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void testWifiInfoProperties() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected - Please ensure there is a saved network in range of this ""
                        + ""device"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        // this test case should in Wifi environment
        WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

        testWifiInfoPropertiesWhileConnected(wifiInfo);

        setWifiEnabled(false);

        PollingCheck.check(""getNetworkId not -1"", 20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);

        PollingCheck.check(""getWifiState not disabled"", 20000,
                () -> mWifiManager.getWifiState() == WifiManager.WIFI_STATE_DISABLED);
    }

    private void testWifiInfoPropertiesWhileConnected(WifiInfo wifiInfo) {
        assertThat(wifiInfo).isNotNull();
        assertThat(wifiInfo.toString()).isNotNull();
        SupplicantState.isValidState(wifiInfo.getSupplicantState());
        WifiInfo.getDetailedStateOf(SupplicantState.DISCONNECTED);
        String ssid = wifiInfo.getSSID();
        if (!ssid.startsWith(""0x"") && !ssid.equals(WifiManager.UNKNOWN_SSID)) {
            // Non-hex string should be quoted
            assertThat(ssid).startsWith(""\"""");
            assertThat(ssid).endsWith(""\"""");
        }

        assertThat(wifiInfo.getBSSID()).isNotNull();
        assertThat(wifiInfo.getFrequency()).isGreaterThan(0);
        assertThat(wifiInfo.getMacAddress()).isNotNull();

        wifiInfo.getRssi();
        wifiInfo.getIpAddress();
        wifiInfo.getHiddenSSID();
        wifiInfo.getScore();

        // null for saved networks
        assertThat(wifiInfo.getRequestingPackageName()).isNull();
        assertThat(wifiInfo.getPasspointFqdn()).isNull();
        assertThat(wifiInfo.getPasspointProviderFriendlyName()).isNull();

        // false for saved networks
        assertThat(wifiInfo.isEphemeral()).isFalse();
        assertThat(wifiInfo.isOsuAp()).isFalse();
        assertThat(wifiInfo.isPasspointAp()).isFalse();

        assertThat(wifiInfo.getWifiStandard()).isAnyOf(
                ScanResult.WIFI_STANDARD_UNKNOWN,
                ScanResult.WIFI_STANDARD_LEGACY,
                ScanResult.WIFI_STANDARD_11N,
                ScanResult.WIFI_STANDARD_11AC,
                ScanResult.WIFI_STANDARD_11AX
        );

        assertThat(wifiInfo.getLostTxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getRetriedTxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getSuccessfulRxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getSuccessfulTxPacketsPerSecond()).isAtLeast(0.0);

        // Can be -1 if link speed is unknown
        assertThat(wifiInfo.getLinkSpeed()).isAtLeast(-1);
        assertThat(wifiInfo.getTxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getRxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getMaxSupportedTxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getMaxSupportedRxLinkSpeedMbps()).isAtLeast(-1);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            assertThat(wifiInfo.getCurrentSecurityType()).isNotEqualTo(
                    WifiInfo.SECURITY_TYPE_UNKNOWN);
        }
    }

    /**
     * Test that the WifiInfo Builder returns the same values that was set, and that
     * calling build multiple times returns different instances.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.testcase.DataPathInBandTestCase"	"executeTest"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/testcase/DataPathInBandTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware.testcase;

import static com.android.cts.verifier.wifiaware.CallbackUtils.CALLBACK_TIMEOUT_SEC;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.aware.PublishDiscoverySession;
import android.net.wifi.aware.WifiAwareNetworkInfo;
import android.net.wifi.aware.WifiAwareNetworkSpecifier;
import android.util.Log;
import android.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifiaware.CallbackUtils;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Inet6Address;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Arrays;

/**
 * Test case for data-path, in-band test cases:
 * open/passphrase * solicited/unsolicited * publish/subscribe.
 *
 * Subscribe test sequence:
 * 1. Attach
 *    wait for results (session)
 * 2. Subscribe
 *    wait for results (subscribe session)
 * 3. Wait for discovery (possibly with ranging)
 * 4. Send message
 *    Wait for success
 * 5. Wait for rx message
 * 6. Request network
 *    Wait for network
 * 7. Create socket and bind to server
 * 8. Send/receive data to validate connection
 * 9. Destroy session
 *
 * Publish test sequence:
 * 1. Attach
 *    wait for results (session)
 * 2. Publish
 *    wait for results (publish session)
 * 3. Wait for rx message
 * 4. Start a ServerSocket
 * 5. Request network
 * 6. Send message
 *    Wait for success
 * 7. Wait for network
 * 8. Receive/Send data to validate connection
 * 9. Destroy session
 */
public class DataPathInBandTestCase extends DiscoveryBaseTestCase {
    private static final String TAG = ""DataPathInBandTestCase"";
    private static final boolean DBG = true;

    private static final byte[] MSG_PUB_TO_SUB = ""Ready"".getBytes();
    private static final String PASSPHRASE = ""Some super secret password"";
    private static final byte[] PMK = ""01234567890123456789012345678901"".getBytes();

    private static final byte[] MSG_CLIENT_TO_SERVER = ""GET SOME BYTES"".getBytes();
    private static final byte[] MSG_SERVER_TO_CLIENT = ""PUT SOME OTHER BYTES"".getBytes();

    private boolean mIsSecurityOpen;
    private boolean mUsePmk;
    private boolean mIsPublish;
    private boolean mIsAcceptAny;
    private Thread mClientServerThread;
    private ConnectivityManager mCm;
    private CallbackUtils.NetworkCb mNetworkCb;

    private static int sSDKLevel = android.os.Build.VERSION.SDK_INT;

    public DataPathInBandTestCase(Context context, boolean isSecurityOpen, boolean isPublish,
            boolean isUnsolicited, boolean usePmk, boolean acceptAny) {
        super(context, isUnsolicited, false);

        mIsSecurityOpen = isSecurityOpen;
        mUsePmk = usePmk;
        mIsPublish = isPublish;
        mIsAcceptAny = acceptAny;
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (DBG) {
            Log.d(TAG,
                    ""executeTest: mIsSecurityOpen="" + mIsSecurityOpen + "", mIsPublish="" + mIsPublish
                            + "", mIsUnsolicited="" + mIsUnsolicited);
        }

        mCm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
        mClientServerThread = null;
        mNetworkCb = null;

        boolean success;
        if (mIsPublish) {
            success = executeTestPublisher();
        } else {
            success = executeTestSubscriber();
        }
        if (!success) {
            return false;
        }

        // destroy session
        mWifiAwareDiscoverySession.close();
        mWifiAwareDiscoverySession = null;

        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_lifecycle_ok));
        return true;
    }

    @Override
    protected void tearDown() {
        if (mClientServerThread != null) {
            mClientServerThread.interrupt();
        }
        if (mNetworkCb != null) {
            mCm.unregisterNetworkCallback(mNetworkCb);
        }
        super.tearDown();
    }


    private boolean executeTestSubscriber() throws InterruptedException {
        if (DBG) Log.d(TAG, ""executeTestSubscriber"");
        if (!executeSubscribe()) {
            return false;
        }

        // 5. wait to receive message
        CallbackUtils.DiscoveryCb.CallbackData callbackData = mDiscoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_RECEIVED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_receive_timeout));
                Log.e(TAG, ""executeTestSubscriber: receive message TIMEOUT"");
                return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_received));
        if (DBG) Log.d(TAG, ""executeTestSubscriber: received message"");

        //    validate that received the expected message
        if (!Arrays.equals(MSG_PUB_TO_SUB, callbackData.serviceSpecificInfo)) {
            setFailureReason(mContext.getString(R.string.aware_status_receive_failure));
            Log.e(TAG, ""executeTestSubscriber: receive message message content mismatch: rx='""
                    + new String(callbackData.serviceSpecificInfo) + ""'"");
            return false;
        }

        // 6. request network
        WifiAwareNetworkSpecifier.Builder nsBuilder =
                new WifiAwareNetworkSpecifier.Builder(mWifiAwareDiscoverySession, mPeerHandle);
        if (!mIsSecurityOpen) {
            if (mUsePmk) {
                nsBuilder.setPmk(PMK);
            } else {
                nsBuilder.setPskPassphrase(PASSPHRASE);
            }
        }
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                nsBuilder.build()).build();
        mNetworkCb = new CallbackUtils.NetworkCb();
        mCm.requestNetwork(nr, mNetworkCb, CALLBACK_TIMEOUT_SEC * 1000);
        mListener.onTestMsgReceived(
                mContext.getString(R.string.aware_status_network_requested));
        if (DBG) Log.d(TAG, ""executeTestSubscriber: requested network"");

        // 7. wait for network
        Pair<Network, NetworkCapabilities> info = mNetworkCb.waitForNetworkCapabilities();
        if (info == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestSubscriber: network request rejected or timed-out"");
            return false;
        }
        if (info.first == null || info.second == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestSubscriber: received a null Network or NetworkCapabilities!?"");
            return false;
        }
        if (sSDKLevel <= android.os.Build.VERSION_CODES.P) {
            if (info.second.getNetworkSpecifier() != null) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed_leak));
                Log.e(TAG, ""executeTestSubscriber: network request accepted - but leaks NS!"");
                return false;
            }
        }

        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_success));
        if (DBG) Log.d(TAG, ""executeTestSubscriber: network request granted - AVAILABLE"");

        if (!mIsSecurityOpen) {
            if (!(info.second.getTransportInfo() instanceof WifiAwareNetworkInfo)) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed));
                Log.e(TAG, ""executeTestSubscriber: did not get WifiAwareNetworkInfo from peer!?"");
                return false;
            }
            WifiAwareNetworkInfo peerAwareInfo =
                    (WifiAwareNetworkInfo) info.second.getTransportInfo();
            Inet6Address peerIpv6 = peerAwareInfo.getPeerIpv6Addr();
            int peerPort = peerAwareInfo.getPort();
            int peerTransportProtocol = peerAwareInfo.getTransportProtocol();
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.aware_status_socket_server_info_rx,
                            peerIpv6.toString(),
                            peerPort));
            if (DBG) {
                Log.d(TAG,
                        ""executeTestPublisher: rx peer info IPv6="" + peerIpv6 + "", port="" + peerPort
                                + "", transportProtocol="" + peerTransportProtocol);
            }
            if (peerTransportProtocol != 6) { // 6 == TCP: hard coded at peer
                setFailureReason(mContext.getString(R.string.aware_status_network_failed));
                Log.e(TAG, ""executeTestSubscriber: Got incorrect transport protocol from peer"");
                return false;
            }
            if (peerPort <= 0) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed));
                Log.e(TAG, ""executeTestSubscriber: Got invalid port from peer (<=0)"");
                return false;
            }

            // 8. send/receive - can happen inline here - no need for another thread
            String currentMethod = """";
            try {
                currentMethod = ""createSocket"";
                Socket socket = info.first.getSocketFactory().createSocket(peerIpv6, peerPort);

                // simple interaction: write X bytes, read Y bytes
                currentMethod = ""getOutputStream()"";
                OutputStream os = socket.getOutputStream();
                currentMethod = ""write()"";
                os.write(MSG_CLIENT_TO_SERVER, 0, MSG_CLIENT_TO_SERVER.length);

                byte[] buffer = new byte[1024];
                currentMethod = ""getInputStream()"";
                InputStream is = socket.getInputStream();
                currentMethod = ""read()"";
                int numBytes = is.read(buffer, 0, MSG_SERVER_TO_CLIENT.length);

                mListener.onTestMsgReceived(
                        mContext.getString(R.string.aware_status_socket_server_message_from_peer,
                                new String(buffer, 0, numBytes)));

                if (numBytes != MSG_SERVER_TO_CLIENT.length) {
                    setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                    Log.e(TAG,
                            ""executeTestSubscriber: didn't read expected number of bytes - only ""
                                    + ""got -- "" + numBytes);
                    return false;
                }
                if (!Arrays.equals(MSG_SERVER_TO_CLIENT,
                        Arrays.copyOf(buffer, MSG_SERVER_TO_CLIENT.length))) {
                    setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                    Log.e(TAG, ""executeTestSubscriber: did not get expected message from server."");
                    return false;
                }
                // Sleep 3 second for transmit and receive.
                Thread.sleep(3000);
                currentMethod = ""close()"";
                os.close();
            } catch (IOException e) {
                setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                Log.e(TAG, ""executeTestSubscriber: failure while executing "" + currentMethod);
                return false;
            }
        }

        return true;
    }

    private boolean executeTestPublisher() throws InterruptedException {
        if (DBG) Log.d(TAG, ""executeTestPublisher"");
        if (!executePublish()) {
            return false;
        }

        // 4. create a ServerSocket
        int port = 0;
        if (!mIsSecurityOpen) {
            ServerSocket server;
            try {
                server = new ServerSocket(0);
            } catch (IOException e) {
                setFailureReason(
                        mContext.getString(R.string.aware_status_socket_failure));
                Log.e(TAG, ""executeTestPublisher: failure creating a ServerSocket -- "" + e);
                return false;
            }
            port = server.getLocalPort();
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.aware_status_socket_server_socket_started, port));
            if (DBG) Log.d(TAG, ""executeTestPublisher: server socket started on port="" + port);

            // accept connections on the server socket - has to be done in a separate thread!
            mClientServerThread = new Thread(() -> {
                String currentMethod = """";

                try {
                    currentMethod = ""accept()"";
                    Socket socket = server.accept();
                    currentMethod = ""getInputStream()"";
                    InputStream is = socket.getInputStream();

                    // simple interaction: read X bytes, write Y bytes
                    byte[] buffer = new byte[1024];
                    currentMethod = ""read()"";
                    int numBytes = is.read(buffer, 0, MSG_CLIENT_TO_SERVER.length);

                    mListener.onTestMsgReceived(mContext.getString(
                            R.string.aware_status_socket_server_message_from_peer,
                            new String(buffer, 0, numBytes)));

                    if (numBytes != MSG_CLIENT_TO_SERVER.length) {
                        setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                        Log.e(TAG,
                                ""executeTestPublisher: didn't read expected number of bytes - only ""
                                        + ""got -- "" + numBytes);
                        return;
                    }
                    if (!Arrays.equals(MSG_CLIENT_TO_SERVER,
                            Arrays.copyOf(buffer, MSG_CLIENT_TO_SERVER.length))) {
                        setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                        Log.e(TAG,
                                ""executeTestPublisher: did not get expected message from client."");
                        return;
                    }

                    currentMethod = ""getOutputStream()"";
                    OutputStream os = socket.getOutputStream();
                    currentMethod = ""write()"";
                    os.write(MSG_SERVER_TO_CLIENT, 0, MSG_SERVER_TO_CLIENT.length);
                    // Sleep 3 second for transmit and receive.
                    Thread.sleep(3000);
                    currentMethod = ""close()"";
                    os.close();
                } catch (IOException | InterruptedException e) {
                    setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                    Log.e(TAG, ""executeTestPublisher: failure while executing "" + currentMethod);
                    return;
                }
            });
            mClientServerThread.start();
        }

        // 5. Request network
        WifiAwareNetworkSpecifier.Builder nsBuilder;
        if (mIsAcceptAny) {
            nsBuilder = new WifiAwareNetworkSpecifier
                    .Builder((PublishDiscoverySession) mWifiAwareDiscoverySession);
        } else {
            nsBuilder = new WifiAwareNetworkSpecifier
                    .Builder(mWifiAwareDiscoverySession, mPeerHandle);
        }
        if (!mIsSecurityOpen) {
            if (mUsePmk) {
                nsBuilder.setPmk(PMK);
            } else {
                nsBuilder.setPskPassphrase(PASSPHRASE);
            }
            nsBuilder.setPort(port).setTransportProtocol(6); // 6 == TCP
        }
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                nsBuilder.build()).build();
        mNetworkCb = new CallbackUtils.NetworkCb();
        mCm.requestNetwork(nr, mNetworkCb, CALLBACK_TIMEOUT_SEC * 1000);
        mListener.onTestMsgReceived(
                mContext.getString(R.string.aware_status_network_requested));
        if (DBG) Log.d(TAG, ""executeTestPublisher: requested network"");

        // 6. send message & wait for send status
        mWifiAwareDiscoverySession.sendMessage(mPeerHandle, MESSAGE_ID, MSG_PUB_TO_SUB);
        CallbackUtils.DiscoveryCb.CallbackData callbackData = mDiscoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_SUCCEEDED
                        | CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_send_timeout));
                Log.e(TAG, ""executeTestPublisher: send message TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_send_failed));
                Log.e(TAG, ""executeTestPublisher: send message ON_MESSAGE_SEND_FAILED"");
                return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_send_success));
        if (DBG) Log.d(TAG, ""executeTestPublisher: send message succeeded"");

        if (callbackData.messageId != MESSAGE_ID) {
            setFailureReason(mContext.getString(R.string.aware_status_send_fail_parameter));
            Log.e(TAG, ""executeTestPublisher: send message succeeded but message ID mismatch : ""
                    + callbackData.messageId);
            return false;
        }

        // 7. wait for network
        Pair<Network, NetworkCapabilities> info = mNetworkCb.waitForNetworkCapabilities();
        if (info == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestPublisher: request network rejected - ON_UNAVAILABLE"");
            return false;
        }
        if (info.first == null || info.second == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestPublisher: received a null Network or NetworkCapabilities!?"");
            return false;
        }
        if (sSDKLevel <= android.os.Build.VERSION_CODES.P) {
            if (info.second.getNetworkSpecifier() != null) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed_leak));
                Log.e(TAG, ""executeTestSubscriber: network request accepted - but leaks NS!"");
                return false;
            }
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_success));
        if (DBG) Log.d(TAG, ""executeTestPublisher: network request granted - AVAILABLE"");

        // 8. Send/Receive data to validate connection - happens on thread above
        if (!mIsSecurityOpen) {
            mClientServerThread.join(CALLBACK_TIMEOUT_SEC * 1000);
            if (mClientServerThread.isAlive()) {
                setFailureReason(mContext.getString(R.string.aware_status_socket_failure));
                Log.e(TAG,
                        ""executeTestPublisher: failure while waiting for client-server thread to ""
                                + ""finish"");
                return false;
            }
        }

        return true;
    }
}"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"waitForListener"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.aware.cts;

import static org.junit.Assert.assertNotEquals;
import static org.mockito.Mockito.mock;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.WifiManager;
import android.net.wifi.aware.AttachCallback;
import android.net.wifi.aware.AwareResources;
import android.net.wifi.aware.Characteristics;
import android.net.wifi.aware.DiscoverySession;
import android.net.wifi.aware.DiscoverySessionCallback;
import android.net.wifi.aware.IdentityChangedListener;
import android.net.wifi.aware.ParcelablePeerHandle;
import android.net.wifi.aware.PeerHandle;
import android.net.wifi.aware.PublishConfig;
import android.net.wifi.aware.PublishDiscoverySession;
import android.net.wifi.aware.SubscribeConfig;
import android.net.wifi.aware.SubscribeDiscoverySession;
import android.net.wifi.aware.WifiAwareManager;
import android.net.wifi.aware.WifiAwareNetworkSpecifier;
import android.net.wifi.aware.WifiAwareSession;
import android.net.wifi.cts.WifiBuildCompat;
import android.net.wifi.cts.WifiJUnit3TestBase;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Parcel;
import android.platform.test.annotations.AppModeFull;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Wi-Fi Aware CTS test suite: single device testing. Performs tests on a single
 * device to validate Wi-Fi Aware.
 */
@AppModeFull(reason = ""Cannot get WifiAwareManager in instant app mode"")
public class SingleDeviceTest extends WifiJUnit3TestBase {
    private static final String TAG = ""WifiAwareCtsTests"";

    // wait for Wi-Fi Aware state changes & network requests callbacks
    private static final int WAIT_FOR_AWARE_CHANGE_SECS = 15; // 15 seconds
    private static final int WAIT_FOR_NETWORK_STATE_CHANGE_SECS = 25; // 25 seconds
    private static final int INTERVAL_BETWEEN_TESTS_SECS = 3; // 3 seconds
    private static final int WAIT_FOR_AWARE_INTERFACE_CREATION_SEC = 3; // 3 seconds
    private static final int MIN_DISTANCE_MM = 1 * 1000;
    private static final int MAX_DISTANCE_MM = 3 * 1000;
    private static final byte[] PMK_VALID = ""01234567890123456789012345678901"".getBytes();
    private static final int AVAILABLE_DATA_PATH_COUNT = 2;
    private static final int AVAILABLE_PUBLISH_SESSION_COUNT = 8;
    private static final int AVAILABLE_SUBSCRIBE_SESSION_COUNT = 8;

    private final Object mLock = new Object();
    private final HandlerThread mHandlerThread = new HandlerThread(""SingleDeviceTest"");
    private final Handler mHandler;
    private Boolean mWasVerboseLoggingEnabled;

    {
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
    }

    private WifiAwareManager mWifiAwareManager;
    private WifiManager mWifiManager;
    private WifiManager.WifiLock mWifiLock;
    private ConnectivityManager mConnectivityManager;

    // used to store any WifiAwareSession allocated during tests - will clean-up after tests
    private List<WifiAwareSession> mSessions = new ArrayList<>();

    private class WifiAwareBroadcastReceiver extends BroadcastReceiver {
        private final Object mLock = new Object();
        private CountDownLatch mBlocker = new CountDownLatch(1);
        private int mCountNumber = 0;

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED.equals(intent.getAction())) {
                synchronized(mLock) {
                    mCountNumber += 1;
                    mBlocker.countDown();
                    mBlocker = new CountDownLatch(1);
                }
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            CountDownLatch blocker;
            synchronized (mLock) {
                mCountNumber--;
                if (mCountNumber >= 0) {
                    return true;
                }
                blocker = mBlocker;
            }
            return blocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS);
        }
    }

    private class AttachCallbackTest extends AttachCallback {
        static final int ATTACHED = 0;
        static final int ATTACH_FAILED = 1;
        static final int ERROR = 2; // no callback: timeout, interruption

        private CountDownLatch mBlocker = new CountDownLatch(1);
        private int mCallbackCalled = ERROR; // garbage init
        private WifiAwareSession mSession = null;

        @Override
        public void onAttached(WifiAwareSession session) {
            mCallbackCalled = ATTACHED;
            mSession = session;
            synchronized (mLock) {
                mSessions.add(session);
            }
            mBlocker.countDown();
        }

        @Override
        public void onAttachFailed() {
            mCallbackCalled = ATTACH_FAILED;
            mBlocker.countDown();
        }

        /**
         * Waits for any of the callbacks to be called - or an error (timeout, interruption).
         * Returns one of the ATTACHED, ATTACH_FAILED, or ERROR values.
         */
        int waitForAnyCallback() {
            try {
                boolean noTimeout = mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS);
                if (noTimeout) {
                    return mCallbackCalled;
                } else {
                    return ERROR;
                }
            } catch (InterruptedException e) {
                return ERROR;
            }
        }

        /**
         * Access the session created by a callback. Only useful to be called after calling
         * waitForAnyCallback() and getting the ATTACHED code back.
         */
        WifiAwareSession getSession() {
            return mSession;
        }
    }

    private class IdentityChangedListenerTest extends IdentityChangedListener {
        private CountDownLatch mBlocker = new CountDownLatch(1);
        private byte[] mMac = null;

        @Override
        public void onIdentityChanged(byte[] mac) {
            mMac = mac;
            mBlocker.countDown();
        }

        /**
         * Waits for the listener callback to be called - or an error (timeout, interruption).
         * Returns true on callback called, false on error (timeout, interruption).
         */
        boolean waitForListener() {
            try {
                return mBlocker.await(WAIT_FOR_AWARE_CHANGE_SECS, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                return false;
            }
        }

        /**
         * Returns the MAC address of the discovery interface supplied to the triggered callback.
         */
        byte[] getMac() {
            return mMac;
        }
    }

    private class DiscoverySessionCallbackTest extends DiscoverySessionCallback {
        static final int ON_PUBLISH_STARTED = 0;
        static final int ON_SUBSCRIBE_STARTED = 1;
        static final int ON_SESSION_CONFIG_UPDATED = 2;
        static final int ON_SESSION_CONFIG_FAILED = 3;
        static final int ON_SESSION_TERMINATED = 4;
        static final int ON_SERVICE_DISCOVERED = 5;
        static final int ON_MESSAGE_SEND_SUCCEEDED = 6;
        static final int ON_MESSAGE_SEND_FAILED = 7;
        static final int ON_MESSAGE_RECEIVED = 8;
        static final int ON_SESSION_DISCOVERED_LOST = 9;

        private final Object mLocalLock = new Object();

        private CountDownLatch mBlocker;
        private int mCurrentWaitForCallback;
        private ArrayDeque<Integer> mCallbackQueue = new ArrayDeque<>();

        private PublishDiscoverySession mPublishDiscoverySession;
        private SubscribeDiscoverySession mSubscribeDiscoverySession;

        private void processCallback(int callback) {
            synchronized (mLocalLock) {
                if (mBlocker != null && mCurrentWaitForCallback == callback) {
                    mBlocker.countDown();
                } else {
                    mCallbackQueue.addLast(callback);
                }
            }
        }

        @Override
        public void onPublishStarted(PublishDiscoverySession session) {
            mPublishDiscoverySession = session;
            processCallback(ON_PUBLISH_STARTED);
        }

        @Override
        public void onSubscribeStarted(SubscribeDiscoverySession session) {
            mSubscribeDiscoverySession = session;
            processCallback(ON_SUBSCRIBE_STARTED);
        }

        @Override
        public void onSessionConfigUpdated() {
            processCallback(ON_SESSION_CONFIG_UPDATED);
        }

        @Override
        public void onSessionConfigFailed() {
            processCallback(ON_SESSION_CONFIG_FAILED);
        }

        @Override
        public void onSessionTerminated() {
            processCallback(ON_SESSION_TERMINATED);
        }

        @Override
        public void onServiceDiscovered(PeerHandle peerHandle, byte[] serviceSpecificInfo,
                List<byte[]> matchFilter) {
            processCallback(ON_SERVICE_DISCOVERED);
        }

        @Override
        public void onMessageSendSucceeded(int messageId) {
            processCallback(ON_MESSAGE_SEND_SUCCEEDED);
        }

        @Override
        public void onMessageSendFailed(int messageId) {
            processCallback(ON_MESSAGE_SEND_FAILED);
        }

        @Override
        public void onMessageReceived(PeerHandle peerHandle, byte[] message) {
            processCallback(ON_MESSAGE_RECEIVED);
        }

        @Override
        public void onServiceLost(PeerHandle peerHandle, int reason) {
            processCallback(ON_SESSION_DISCOVERED_LOST);
        }

        /**
         * Wait for the specified callback - any of the ON_* constants. Returns a true
         * on success (specified callback triggered) or false on failure (timed-out or
         * interrupted while waiting for the requested callback).
         *
         * Note: other callbacks happening while while waiting for the specified callback will
         * be queued.
         */
        boolean waitForCallback(int callback) {
            return waitForCallback(callback, WAIT_FOR_AWARE_CHANGE_SECS);
        }

        /**
         * Wait for the specified callback - any of the ON_* constants. Returns a true
         * on success (specified callback triggered) or false on failure (timed-out or
         * interrupted while waiting for the requested callback).
         *
         * Same as waitForCallback(int callback) execpt that allows specifying a custom timeout.
         * The default timeout is a short value expected to be sufficient for all behaviors which
         * should happen relatively quickly. Specifying a custom timeout should only be done for
         * those cases which are known to take a specific longer period of time.
         *
         * Note: other callbacks happening while while waiting for the specified callback will
         * be queued.
         */
        boolean waitForCallback(int callback, int timeoutSec) {
            synchronized (mLocalLock) {
                boolean found = mCallbackQueue.remove(callback);
                if (found) {
                    return true;
                }

                mCurrentWaitForCallback = callback;
                mBlocker = new CountDownLatch(1);
            }

            try {
                return mBlocker.await(timeoutSec, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                return false;
            }
        }

        /**
         * Indicates whether the specified callback (any of the ON_* constants) has already
         * happened and in the queue. Useful when the order of events is important.
         */
        boolean hasCallbackAlreadyHappened(int callback) {
            synchronized (mLocalLock) {
                return mCallbackQueue.contains(callback);
            }
        }

        /**
         * Returns the last created publish discovery session.
         */
        PublishDiscoverySession getPublishDiscoverySession() {
            PublishDiscoverySession session = mPublishDiscoverySession;
            mPublishDiscoverySession = null;
            return session;
        }

        /**
         * Returns the last created subscribe discovery session.
         */
        SubscribeDiscoverySession getSubscribeDiscoverySession() {
            SubscribeDiscoverySession session = mSubscribeDiscoverySession;
            mSubscribeDiscoverySession = null;
            return session;
        }
    }

    private class NetworkCallbackTest extends ConnectivityManager.NetworkCallback {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onUnavailable() {
            mBlocker.countDown();
        }

        /**
         * Wait for the onUnavailable() callback to be triggered. Returns true if triggered,
         * otherwise (timed-out, interrupted) returns false.
         */
        boolean waitForOnUnavailable() {
            try {
                return mBlocker.await(WAIT_FOR_NETWORK_STATE_CHANGE_SECS, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                return false;
            }
        }
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        assertTrue(""Wi-Fi Aware requires Location to be Enabled"",
                ((LocationManager) getContext().getSystemService(
                        Context.LOCATION_SERVICE)).isLocationEnabled());

        mWifiAwareManager = (WifiAwareManager) getContext().getSystemService(
                Context.WIFI_AWARE_SERVICE);
        assertNotNull(""Wi-Fi Aware Manager"", mWifiAwareManager);

        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(""Wi-Fi Manager"", mWifiManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        // Turn on Wi-Fi
        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        if (!mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable"");
        }

        mConnectivityManager = (ConnectivityManager) getContext().getSystemService(
                Context.CONNECTIVITY_SERVICE);
        assertNotNull(""Connectivity Manager"", mConnectivityManager);

        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED);
        WifiAwareBroadcastReceiver receiver = new WifiAwareBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);
        if (!mWifiAwareManager.isAvailable()) {
            assertTrue(""Timeout waiting for Wi-Fi Aware to change status"",
                    receiver.waitForStateChange());
            assertTrue(""Wi-Fi Aware is not available (should be)"", mWifiAwareManager.isAvailable());
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            super.tearDown();
            return;
        }

        synchronized (mLock) {
            for (WifiAwareSession session : mSessions) {
                // no damage from destroying twice (i.e. ok if test cleaned up after itself already)
                session.close();
            }
            mSessions.clear();
        }

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));

        super.tearDown();
        Thread.sleep(INTERVAL_BETWEEN_TESTS_SECS * 1000);
    }

    /**
     * Validate:
     * - Characteristics are available
     * - Characteristics values are legitimate. Not in the CDD. However, the tested values are
     *   based on the Wi-Fi Aware protocol.
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testAttachDiscoveryAddressChanges"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testAttachDiscoveryAddressChanges() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final int numIterations = 10;
        Set<TestUtils.MacWrapper> macs = new HashSet<>();

        for (int i = 0; i < numIterations; ++i) {
            AttachCallbackTest attachCb = new AttachCallbackTest();
            IdentityChangedListenerTest identityL = new IdentityChangedListenerTest();
            mWifiAwareManager.attach(attachCb, identityL, mHandler);
            assertEquals(""Wi-Fi Aware attach: iteration "" + i, AttachCallbackTest.ATTACHED,
                    attachCb.waitForAnyCallback());
            assertTrue(""Wi-Fi Aware attach: iteration "" + i, identityL.waitForListener());

            WifiAwareSession session = attachCb.getSession();
            assertNotNull(""Wi-Fi Aware session: iteration "" + i, session);

            byte[] mac = identityL.getMac();
            assertNotNull(""Wi-Fi Aware discovery MAC: iteration "" + i, mac);

            session.close();

            macs.add(new TestUtils.MacWrapper(mac));
        }

        assertEquals("""", numIterations, macs.size());
    }

    /**
     * Validate a successful publish discovery session lifetime: publish, update publish, destroy.
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testPublishDiscoverySuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testPublishDiscoverySuccess() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final String serviceName = ""ValidName"";

        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                serviceName).build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        int numOfAllPublishSessions = 0;
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            numOfAllPublishSessions = mWifiAwareManager
                    .getAvailableAwareResources().getAvailablePublishSessionsCount();
        }

        // 1. publish
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        PublishDiscoverySession discoverySession = discoveryCb.getPublishDiscoverySession();
        assertNotNull(""Publish session"", discoverySession);
        assertFalse(discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SERVICE_DISCOVERED));
        assertFalse(discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_DISCOVERED_LOST));
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(numOfAllPublishSessions - 1, mWifiAwareManager
                    .getAvailableAwareResources().getAvailablePublishSessionsCount());
        }
        // 2. update-publish
        publishConfig = new PublishConfig.Builder().setServiceName(
                serviceName).setServiceSpecificInfo(""extras"".getBytes()).build();
        discoverySession.updatePublish(publishConfig);
        assertTrue(""Publish update"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));

        // 3. destroy
        assertFalse(""Publish not terminated"", discoveryCb.hasCallbackAlreadyHappened(
                DiscoverySessionCallbackTest.ON_SESSION_TERMINATED));
        discoverySession.close();

        // 4. try update post-destroy: should time-out waiting for cb
        discoverySession.updatePublish(publishConfig);
        assertFalse(""Publish update post destroy"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(numOfAllPublishSessions, mWifiAwareManager
                    .getAvailableAwareResources().getAvailablePublishSessionsCount());
        }
        session.close();
    }

    /**
     * Validate that publish with a Time To Live (TTL) setting expires within the specified
     * time (and validates that the terminate callback is triggered).
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testPublishLimitedTtlSuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testPublishLimitedTtlSuccess() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final String serviceName = ""ValidName"";
        final int ttlSec = 5;

        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                serviceName).setTtlSec(ttlSec).setTerminateNotificationEnabled(true).build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();

        // 1. publish
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        PublishDiscoverySession discoverySession = discoveryCb.getPublishDiscoverySession();
        assertNotNull(""Publish session"", discoverySession);

        // 2. wait for terminate within 'ttlSec'.
        assertTrue(""Publish terminated"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SESSION_TERMINATED,
                        ttlSec + 5));

        // 3. try update post-termination: should time-out waiting for cb
        publishConfig = new PublishConfig.Builder().setServiceName(
                serviceName).setServiceSpecificInfo(""extras"".getBytes()).build();
        discoverySession.updatePublish(publishConfig);
        assertFalse(""Publish update post terminate"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));

        session.close();
    }

    /**
     * Validate a successful subscribe discovery session lifetime: subscribe, update subscribe,
     * destroy.
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testSubscribeDiscoverySuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testSubscribeDiscoverySuccess() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final String serviceName = ""ValidName"";

        WifiAwareSession session = attachAndGetSession();

        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName(
                serviceName).build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        int numOfAllSubscribeSessions = 0;
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            numOfAllSubscribeSessions = mWifiAwareManager
                    .getAvailableAwareResources().getAvailableSubscribeSessionsCount();
        }
        // 1. subscribe
        session.subscribe(subscribeConfig, discoveryCb, mHandler);
        assertTrue(""Subscribe started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED));
        SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession();
        assertNotNull(""Subscribe session"", discoverySession);
        assertFalse(discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SERVICE_DISCOVERED));
        assertFalse(discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_DISCOVERED_LOST));
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(numOfAllSubscribeSessions - 1, mWifiAwareManager
                    .getAvailableAwareResources().getAvailableSubscribeSessionsCount());
        }

        // 2. update-subscribe
        boolean rttSupported = getContext().getPackageManager().hasSystemFeature(
                    PackageManager.FEATURE_WIFI_RTT);
        SubscribeConfig.Builder builder = new SubscribeConfig.Builder().setServiceName(
                    serviceName).setServiceSpecificInfo(""extras"".getBytes());

        if (rttSupported) {
            builder.setMinDistanceMm(MIN_DISTANCE_MM);
        }
        subscribeConfig = builder.build();

        discoverySession.updateSubscribe(subscribeConfig);
        assertTrue(""Subscribe update"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));

        // 3. destroy
        assertFalse(""Subscribe not terminated"", discoveryCb.hasCallbackAlreadyHappened(
                DiscoverySessionCallbackTest.ON_SESSION_TERMINATED));
        discoverySession.close();

        // 4. try update post-destroy: should time-out waiting for cb
        discoverySession.updateSubscribe(subscribeConfig);
        assertFalse(""Subscribe update post destroy"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(numOfAllSubscribeSessions, mWifiAwareManager
                    .getAvailableAwareResources().getAvailableSubscribeSessionsCount());
        }
        session.close();
    }

    /**
     * Validate that subscribe with a Time To Live (TTL) setting expires within the specified
     * time (and validates that the terminate callback is triggered).
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testSubscribeLimitedTtlSuccess"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testSubscribeLimitedTtlSuccess() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        final String serviceName = ""ValidName"";
        final int ttlSec = 5;

        WifiAwareSession session = attachAndGetSession();

        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName(
                serviceName).setTtlSec(ttlSec).setTerminateNotificationEnabled(true).build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();

        // 1. subscribe
        session.subscribe(subscribeConfig, discoveryCb, mHandler);
        assertTrue(""Subscribe started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SUBSCRIBE_STARTED));
        SubscribeDiscoverySession discoverySession = discoveryCb.getSubscribeDiscoverySession();
        assertNotNull(""Subscribe session"", discoverySession);

        // 2. wait for terminate within 'ttlSec'.
        assertTrue(""Subscribe terminated"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_SESSION_TERMINATED,
                        ttlSec + 5));

        // 3. try update post-termination: should time-out waiting for cb
        subscribeConfig = new SubscribeConfig.Builder().setServiceName(
                serviceName).setServiceSpecificInfo(""extras"".getBytes()).build();
        discoverySession.updateSubscribe(subscribeConfig);
        assertFalse(""Subscribe update post terminate"", discoveryCb.waitForCallback(
                DiscoverySessionCallbackTest.ON_SESSION_CONFIG_UPDATED));

        session.close();
    }

    /**
     * Test the send message flow. Since testing single device cannot send to a real peer -
     * validate that sending to a bogus peer fails.
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testSendMessageFail"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testSendMessageFail() {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }

        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                ""ValidName"").build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();

        // 1. publish
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        PublishDiscoverySession discoverySession = discoveryCb.getPublishDiscoverySession();
        assertNotNull(""Publish session"", discoverySession);

        // 2. send a message with a null peer-handle - expect exception
        try {
            discoverySession.sendMessage(null, -1290, ""some message"".getBytes());
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException e) {
            // empty
        }

        discoverySession.close();
        session.close();
    }

    /**
     * Request an Aware data-path (open) as a Responder with an arbitrary peer MAC address. Validate
     * that receive an onUnavailable() callback.
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testDataPathOpenOutOfBandFail"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testDataPathOpenOutOfBandFail() throws InterruptedException {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }
        MacAddress mac = MacAddress.fromString(""00:01:02:03:04:05"");

        // 1. initialize Aware: only purpose is to make sure it is available for OOB data-path
        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                ""ValidName"").build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        Thread.sleep(WAIT_FOR_AWARE_INTERFACE_CREATION_SEC * 1000);

        // 2. request an AWARE network
        NetworkCallbackTest networkCb = new NetworkCallbackTest();
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                session.createNetworkSpecifierOpen(
                        WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR,
                        mac.toByteArray())).build();
        mConnectivityManager.requestNetwork(nr, networkCb);
        assertTrue(""OnUnavailable not received"", networkCb.waitForOnUnavailable());

        session.close();
    }

    /**
     * Request an Aware data-path (encrypted with Passphrase) as a Responder with an arbitrary peer
     * MAC address.
     * Validate that receive an onUnavailable() callback.
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testDataPathPassphraseOutOfBandFail"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testDataPathPassphraseOutOfBandFail() throws InterruptedException {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }
        MacAddress mac = MacAddress.fromString(""00:01:02:03:04:05"");

        // 1. initialize Aware: only purpose is to make sure it is available for OOB data-path
        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                ""ValidName"").build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        Thread.sleep(WAIT_FOR_AWARE_INTERFACE_CREATION_SEC * 1000);

        // 2. request an AWARE network
        NetworkCallbackTest networkCb = new NetworkCallbackTest();
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                session.createNetworkSpecifierPassphrase(
                        WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR, mac.toByteArray(),
                        ""abcdefghihk"")).build();
        mConnectivityManager.requestNetwork(nr, networkCb);
        assertTrue(""OnUnavailable not received"", networkCb.waitForOnUnavailable());

        session.close();
    }

    /**
     * Request an Aware data-path (encrypted with PMK) as a Responder with an arbitrary peer MAC
     * address.
     * Validate that receive an onUnavailable() callback.
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testDataPathPmkOutOfBandFail"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testDataPathPmkOutOfBandFail() throws InterruptedException {
        if (!TestUtils.shouldTestWifiAware(getContext())) {
            return;
        }
        MacAddress mac = MacAddress.fromString(""00:01:02:03:04:05"");

        // 1. initialize Aware: only purpose is to make sure it is available for OOB data-path
        WifiAwareSession session = attachAndGetSession();

        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                ""ValidName"").build();
        DiscoverySessionCallbackTest discoveryCb = new DiscoverySessionCallbackTest();
        session.publish(publishConfig, discoveryCb, mHandler);
        assertTrue(""Publish started"",
                discoveryCb.waitForCallback(DiscoverySessionCallbackTest.ON_PUBLISH_STARTED));
        Thread.sleep(WAIT_FOR_AWARE_INTERFACE_CREATION_SEC * 1000);

        // 2. request an AWARE network
        NetworkCallbackTest networkCb = new NetworkCallbackTest();
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                session.createNetworkSpecifierPmk(
                        WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR, mac.toByteArray(),
                        PMK_VALID)).build();
        mConnectivityManager.requestNetwork(nr, networkCb);
        assertTrue(""OnUnavailable not received"", networkCb.waitForOnUnavailable());

        session.close();
    }

    /**
     * Test WifiAwareNetworkSpecifier.
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"testWifiAwareNetworkSpecifier"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	"public void testWifiAwareNetworkSpecifier() {
        DiscoverySession session = mock(DiscoverySession.class);
        PeerHandle handle = mock(PeerHandle.class);
        WifiAwareNetworkSpecifier networkSpecifier =
                new WifiAwareNetworkSpecifier.Builder(session, handle).build();
        assertFalse(networkSpecifier.canBeSatisfiedBy(null));
        assertTrue(networkSpecifier.canBeSatisfiedBy(networkSpecifier));

        WifiAwareNetworkSpecifier anotherNetworkSpecifier =
                new WifiAwareNetworkSpecifier.Builder(session, handle).setPmk(PMK_VALID).build();
        assertFalse(networkSpecifier.canBeSatisfiedBy(anotherNetworkSpecifier));
    }

    /**
     * Test ParcelablePeerHandle parcel.
     */"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.TestHelper"	"isEmpty"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/TestHelper.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.os.WorkSource;
import android.support.test.uiautomator.UiDevice;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Class to hold helper methods that are repeated across wifi CTS tests.
 */
public class TestHelper {
    private static final String TAG = ""WifiTestHelper"";

    private final Context mContext;
    private final WifiManager mWifiManager;
    private final ConnectivityManager mConnectivityManager;
    private final UiDevice mUiDevice;

    private static final int DURATION_MILLIS = 10_000;
    private static final int DURATION_NETWORK_CONNECTION_MILLIS = 40_000;
    private static final int DURATION_SCREEN_TOGGLE_MILLIS = 2000;
    private static final int DURATION_UI_INTERACTION_MILLIS = 25_000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    public TestHelper(@NonNull Context context, @NonNull UiDevice uiDevice) {
        mContext = context;
        mWifiManager = context.getSystemService(WifiManager.class);
        mConnectivityManager = context.getSystemService(ConnectivityManager.class);
        mUiDevice = uiDevice;
    }

    public void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    public void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    private static class TestScanResultsCallback extends WifiManager.ScanResultsCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;

        TestScanResultsCallback(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onScanResultsAvailable() {
            onAvailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Loops through all the saved networks available in the scan results. Returns a list of
     * WifiConfiguration with the matching bssid filled in {@link WifiConfiguration#BSSID}.
     *
     * Note:
     * a) If there are more than 2 networks with the same SSID, but different credential type, then
     * this matching may pick the wrong one.
     *
     * @param wifiManager WifiManager service
     * @param savedNetworks List of saved networks on the device.
     */
    public static List<WifiConfiguration> findMatchingSavedNetworksWithBssid(
            @NonNull WifiManager wifiManager, @NonNull List<WifiConfiguration> savedNetworks) {
        if (savedNetworks.isEmpty()) return Collections.emptyList();
        List<WifiConfiguration> matchingNetworksWithBssids = new ArrayList<>();
        CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 0; i < SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID; i++) {
            // Trigger a scan to get fresh scan results.
            TestScanResultsCallback scanResultsCallback =
                    new TestScanResultsCallback(countDownLatch);
            try {
                wifiManager.registerScanResultsCallback(
                        Executors.newSingleThreadExecutor(), scanResultsCallback);
                wifiManager.startScan(new WorkSource(myUid()));
                // now wait for callback
                countDownLatch.await(DURATION_MILLIS, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            } finally {
                wifiManager.unregisterScanResultsCallback(scanResultsCallback);
            }
            List<ScanResult> scanResults = wifiManager.getScanResults();
            if (scanResults == null || scanResults.isEmpty()) fail(""No scan results available"");
            for (ScanResult scanResult : scanResults) {
                WifiConfiguration matchingNetwork = savedNetworks.stream()
                        .filter(network -> TextUtils.equals(
                                scanResult.SSID, WifiInfo.sanitizeSsid(network.SSID)))
                        .findAny()
                        .orElse(null);
                if (matchingNetwork != null) {
                    // make a copy in case we have 2 bssid's for the same network.
                    WifiConfiguration matchingNetworkCopy = new WifiConfiguration(matchingNetwork);
                    matchingNetworkCopy.BSSID = scanResult.BSSID;
                    matchingNetworksWithBssids.add(matchingNetworkCopy);
                }
            }
            if (!matchingNetworksWithBssids.isEmpty()) break;
        }
        return matchingNetworksWithBssids;
    }

    /**
     * Convert the provided saved network to a corresponding suggestion builder.
     */
    public static WifiNetworkSuggestion.Builder
            createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        WifiNetworkSuggestion.Builder suggestionBuilder = new WifiNetworkSuggestion.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID))
                .setBssid(MacAddress.fromString(network.BSSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                suggestionBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                suggestionBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            suggestionBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        suggestionBuilder.setIsHiddenSsid(network.hiddenSSID);
        return suggestionBuilder;
    }


    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder createSpecifierBuilderWithCredentialFromSavedNetwork(
            @NonNull WifiConfiguration network) {
        WifiNetworkSpecifier.Builder specifierBuilder = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                specifierBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                specifierBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            specifierBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        specifierBuilder.setIsHiddenSsid(network.hiddenSSID);
        return specifierBuilder;
    }

    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder
            createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        return createSpecifierBuilderWithCredentialFromSavedNetwork(network)
                .setBssid(MacAddress.fromString(network.BSSID));
    }

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;
        public boolean onUnavailableCalled = false;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch, int flags) {
            super(flags);
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onAvailable(Network network) {
            onAvailableCalled = true;
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            this.networkCapabilities = networkCapabilities;
            mCountDownLatch.countDown();
        }

        @Override
        public void onUnavailable() {
            onUnavailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    private static TestNetworkCallback createTestNetworkCallback(
            @NonNull CountDownLatch countDownLatch) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // flags for NetworkCallback only introduced in S.
            return new TestNetworkCallback(countDownLatch, FLAG_INCLUDE_LOCATION_INFO);
        } else {
            return new TestNetworkCallback(countDownLatch);
        }
    }

    @NonNull
    private WifiInfo getWifiInfo(@NonNull NetworkCapabilities networkCapabilities) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // WifiInfo in transport info, only available in S.
            return (WifiInfo) networkCapabilities.getTransportInfo();
        } else {
            return mWifiManager.getConnectionInfo();
        }
    }

    private static void assertConnectionEquals(@NonNull WifiConfiguration network,
            @NonNull WifiInfo wifiInfo) {
        assertThat(network.SSID).isEqualTo(wifiInfo.getSSID());
        assertThat(network.BSSID).isEqualTo(wifiInfo.getBSSID());
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final CountDownLatch mCountDownLatch;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;

        TestActionListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onSuccess() {
            onSuccessCalled = true;
            mCountDownLatch.countDown();
        }

        @Override
        public void onFailure(int reason) {
            onFailedCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * WifiConfiguration, WifiManager.ActionListener)}
     *
     * @param network saved network from the device to use for the connection.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithConnect(
            @NonNull WifiConfiguration network) throws Exception {
        CountDownLatch countDownLatchAl = new CountDownLatch(1);
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestActionListener actionListener = new TestActionListener(countDownLatchAl);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // File a callback for wifi network.
            mConnectivityManager.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            // Needed to ensure that the restricted concurrent connection does not
                            // match this request.
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE)
                            .build(),
                    testNetworkCallback);
            // Trigger the connection.
            mWifiManager.connect(network, actionListener);
            // now wait for action listener callback
            assertThat(countDownLatchAl.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            // check if we got the success callback
            assertThat(actionListener.onSuccessCalled).isTrue();

            // Wait for connection to complete & ensure we are connected to the saved network.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
            final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
            assertConnectionEquals(network, wifiInfo);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // User connections should always be primary.
                assertThat(wifiInfo.isPrimary()).isTrue();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            // Unregister the network callback in case of any failure (since we don't end up
            // returning the network callback to the caller).
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionWithShellIdentity(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        return testConnectionFlowWithSuggestionInternal(
                network, suggestion, executorService, restrictedNetworkCapabilities, true);
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionWithShellIdentity(
                    network, suggestion, executorService, restrictedNetworkCapabilities);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the connection failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFailureFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionInternal(
                    network, suggestion, executorService, restrictedNetworkCapabilities, false);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the entire connection success/failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     * @param expectConnectionSuccess Whether to expect connection success or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    private ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionInternal(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities,
            boolean expectConnectionSuccess) throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);
        try {
            // File a request for restricted (oem paid) wifi network.
            NetworkRequest.Builder nrBuilder = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (restrictedNetworkCapabilities.isEmpty()) {
                // If not a restricted connection, a network callback is sufficient.
                mConnectivityManager.registerNetworkCallback(
                        nrBuilder.build(), testNetworkCallback);
            } else {
                for (Integer restrictedNetworkCapability : restrictedNetworkCapabilities) {
                    nrBuilder.addCapability(restrictedNetworkCapability);
                }
                mConnectivityManager.requestNetwork(nrBuilder.build(), testNetworkCallback);
            }
            // Add wifi network suggestion.
            assertThat(mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)))
                    .isEqualTo(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS);
            // Wait for the request to reach the wifi stack before kick-start periodic scans.
            Thread.sleep(100);
            // Step: Trigger scans periodically to trigger network selection quicker.
            executorService.scheduleAtFixedRate(() -> {
                if (!mWifiManager.startScan()) {
                    Log.w(TAG, ""Failed to trigger scan"");
                }
            }, 0, DURATION_MILLIS, TimeUnit.MILLISECONDS);
            if (expectConnectionSuccess) {
                // now wait for connection to complete and wait for callback
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
                    assertThat(wifiInfo.isTrusted()).isTrue();
                    WifiInfo redact = wifiInfo
                            .makeCopy(NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION);
                    assertThat(wifiInfo.getInformationElements()).isNotNull();
                    assertThat(redact.getInformationElements()).isNull();
                    assertThat(redact.getApplicableRedactions()).isEqualTo(
                            NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION
                            | NetworkCapabilities.REDACT_FOR_LOCAL_MAC_ADDRESS
                            | NetworkCapabilities.REDACT_FOR_NETWORK_SETTINGS);
                }
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for restricted connection is supported, this should not
                    // be the primary connection.
                    if (!restrictedNetworkCapabilities.isEmpty()
                            && mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            } else {
                // now wait for connection to timeout.
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isFalse();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            executorService.shutdown();
        }
        return testNetworkCallback;
    }

    private static class TestNetworkRequestMatchCallback implements
            WifiManager.NetworkRequestMatchCallback {
        private final Object mLock;

        public boolean onRegistrationCalled = false;
        public boolean onAbortCalled = false;
        public boolean onMatchCalled = false;
        public boolean onConnectSuccessCalled = false;
        public boolean onConnectFailureCalled = false;
        public WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback = null;
        public List<ScanResult> matchedScanResults = null;

        TestNetworkRequestMatchCallback(Object lock) {
            mLock = lock;
        }

        @Override
        public void onUserSelectionCallbackRegistration(
                WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback) {
            synchronized (mLock) {
                onRegistrationCalled = true;
                this.userSelectionCallback = userSelectionCallback;
                mLock.notify();
            }
        }

        @Override
        public void onAbort() {
            synchronized (mLock) {
                onAbortCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onMatch(List<ScanResult> scanResults) {
            synchronized (mLock) {
                // This can be invoked multiple times. So, ignore after the first one to avoid
                // disturbing the rest of the test sequence.
                if (onMatchCalled) return;
                onMatchCalled = true;
                matchedScanResults = scanResults;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectSuccess(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectFailure(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectFailureCalled = true;
                mLock.notify();
            }
        }
    }

    private void handleUiInteractions(WifiConfiguration network, boolean shouldUserReject) {
        // can't use CountDownLatch since there are many callbacks expected and CountDownLatch
        // cannot be reset.
        // TODO(b/177591382): Use ArrayBlockingQueue/LinkedBlockingQueue
        Object uiLock = new Object();
        TestNetworkRequestMatchCallback networkRequestMatchCallback =
                new TestNetworkRequestMatchCallback(uiLock);
        try {
            // 1. Wait for registration callback.
            synchronized (uiLock) {
                try {
                    mWifiManager.registerNetworkRequestMatchCallback(
                            Executors.newSingleThreadExecutor(), networkRequestMatchCallback);
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            assertThat(networkRequestMatchCallback.onRegistrationCalled).isTrue();
            assertThat(networkRequestMatchCallback.userSelectionCallback).isNotNull();

            // 2. Wait for matching scan results
            synchronized (uiLock) {
                if (!networkRequestMatchCallback.onMatchCalled) {
                    try {
                        uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                    } catch (InterruptedException e) {
                    }
                }
            }
            assertThat(networkRequestMatchCallback.onMatchCalled).isTrue();
            assertThat(networkRequestMatchCallback.matchedScanResults).isNotNull();
            assertThat(networkRequestMatchCallback.matchedScanResults.size()).isAtLeast(1);

            // 3. Trigger connection to one of the matched networks or reject the request.
            if (shouldUserReject) {
                networkRequestMatchCallback.userSelectionCallback.reject();
            } else {
                networkRequestMatchCallback.userSelectionCallback.select(network);
            }

            // 4. Wait for connection success or abort.
            synchronized (uiLock) {
                try {
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            if (shouldUserReject) {
                assertThat(networkRequestMatchCallback.onAbortCalled).isTrue();
            } else {
                assertThat(networkRequestMatchCallback.onConnectSuccessCalled).isTrue();
            }
        } finally {
            mWifiManager.unregisterNetworkRequestMatchCallback(networkRequestMatchCallback);
        }
    }

    /**
     * Tests the entire connection flow using the provided specifier,
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifierWithShellIdentity(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);

        // Fork a thread to handle the UI interactions.
        Thread uiThread = new Thread(() -> {
            try {
                handleUiInteractions(network, shouldUserReject);
            } catch (Throwable e /* catch assertions & exceptions */) {
                try {
                    mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
                } catch (IllegalArgumentException ie) { }
                throw e;
            }
        });

        try {
            // File a request for wifi network.
            mConnectivityManager.requestNetwork(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            .setNetworkSpecifier(specifier)
                            .build(),
                    testNetworkCallback);
            // Wait for the request to reach the wifi stack before kick-starting the UI
            // interactions.
            Thread.sleep(1_000);
            // Start the UI interactions.
            uiThread.run();
            // now wait for callback
            assertThat(countDownLatch.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            if (shouldUserReject) {
                assertThat(testNetworkCallback.onUnavailableCalled).isTrue();
            } else {
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for local only connection is supported, this should not
                    // be the primary connection.
                    if (mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        }
        try {
            // Ensure that the UI interaction thread has completed.
            uiThread.join(DURATION_UI_INTERACTION_MILLIS);
        } catch (InterruptedException e) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            fail(""UI interaction interrupted"");
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection flow using the provided specifier.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS);
            return testConnectionFlowWithSpecifierWithShellIdentity(
                    network, specifier, shouldUserReject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Returns the number of wifi connections visible at the networking layer.
     */
    public long getNumWifiConnections() {
        Network[] networks = mConnectivityManager.getAllNetworks();
        return Arrays.stream(networks)
                .filter(n ->
                        mConnectivityManager.getNetworkCapabilities(n).hasTransport(TRANSPORT_WIFI))
                .count();
    }

    /**
     * Registers a network callback for internet connectivity via wifi and asserts that a network
     * is available within {@link #DURATION_NETWORK_CONNECTION_MILLIS}.
     *
     * @throws Exception
     */
    public void assertWifiInternetConnectionAvailable() throws Exception {
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        try {
            // File a callback for wifi network.
            NetworkRequest.Builder builder = new NetworkRequest.Builder()
                    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // Needed to ensure that the restricted concurrent connection does not
                // match this request.
                builder.addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                        .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE);
            }
            mConnectivityManager.registerNetworkCallback(builder.build(), testNetworkCallback);
            // Wait for connection to complete & ensure we are connected to some network capable
            // of providing internet access.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
        } finally {
            mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
        }
    }

    public static int getBandFromFrequency(final int freqMHz) {
        if (freqMHz < 1000) {
            return ScanResult.UNSPECIFIED;
        } else if (freqMHz < 4000) { // getFrequency is in WifiInfo.FREQUENCY_UNITS = MHz
            return ScanResult.WIFI_BAND_24_GHZ;
        } else if (freqMHz < 5900) {
            // 5GHz band stops at 5885MHz, 6GHz band starts at 5955. See android.net.wifi.ScanResult
            return ScanResult.WIFI_BAND_5_GHZ;
        } else if (freqMHz < 10_000) {
            return ScanResult.WIFI_BAND_6_GHZ;
        } else if (freqMHz < 71_000) {
            // 60 GHz band stops at 70_200
            return ScanResult.WIFI_BAND_60_GHZ;
        } else {
            return ScanResult.UNSPECIFIED;
        }
    }

}"	""	""	"select"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiEnterpriseConfig.Eap.AKA;
import static android.net.wifi.WifiEnterpriseConfig.Eap.WAPI_CERT;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class WifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiNetworkSuggestionTest"";

    private static final String TEST_SSID = ""testSsid"";
    private static final String TEST_BSSID = ""00:df:aa:bc:12:23"";
    private static final String TEST_PASSPHRASE = ""testPassword"";
    private static final int TEST_PRIORITY = 5;
    private static final int TEST_PRIORITY_GROUP = 1;
    private static final int TEST_SUB_ID = 1;

    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private static Context sContext;
    private static WifiManager sWifiManager;
    private static ConnectivityManager sConnectivityManager;
    private static UiDevice sUiDevice;
    private static WifiConfiguration sTestNetwork;
    private static ConnectivityManager.NetworkCallback sNsNetworkCallback;
    private static TestHelper sTestHelper;

    private ScheduledExecutorService mExecutorService;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        sContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(sContext)) return;
        // skip the test if location is not supported
        if (!sContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION)) return;
        // skip if the location is disabled
        if (!sContext.getSystemService(LocationManager.class).isLocationEnabled()) return;

        sWifiManager = sContext.getSystemService(WifiManager.class);
        assertThat(sWifiManager).isNotNull();
        sConnectivityManager = sContext.getSystemService(ConnectivityManager.class);
        sUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        sTestHelper = new TestHelper(sContext, sUiDevice);

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isWifiEnabled());
        if (!sWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> sWifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> sWifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.getPrivilegedConfiguredNetworks());
        if (savedNetworks.isEmpty()) {
            return;
        }
        // Pick any network in range.

        List<WifiConfiguration> networks = TestHelper.findMatchingSavedNetworksWithBssid(
                sWifiManager, savedNetworks);
        if (!networks.isEmpty()) {
            sTestNetwork = networks.get(0);
        }

        // Disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        sWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                });
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if (!WifiFeature.isWifiSupported(sContext)) return;

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setWifiEnabled(sWasWifiEnabled));

        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : sWifiManager.getConfiguredNetworks()) {
                        sWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
    }

    @Before
    public void setUp() throws Exception {
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        // turn screen on
        sTestHelper.turnScreenOn();

        // Disconnect current network if any.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.disconnect());

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> sWifiManager.getConnectionInfo().getNetworkId() == -1);

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> sWifiManager.removeAppState(myUid(), sContext.getPackageName()));
        }
    }

    @After
    public void tearDown() throws Exception {
        // Release the requests after the test.
        if (sNsNetworkCallback != null) {
            sConnectivityManager.unregisterNetworkCallback(sNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> sWifiManager.removeAppState(myUid(), sContext.getPackageName()));
        }
        sTestHelper.turnScreenOff();
    }

    private static final String CA_SUITE_B_RSA3072_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIEnTCCAwWgAwIBAgIUD87Y8fFLzLr1HQ/64aEnjNq2R/4wDQYJKoZIhvcNAQEM\n""
                    + ""BQAwXjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAO\n""
                    + ""BgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0\n""
                    + ""Q0EwHhcNMjAwNzIxMDIxNzU0WhcNMzAwNTMwMDIxNzU0WjBeMQswCQYDVQQGEwJV\n""
                    + ""UzELMAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEO\n""
                    + ""MAwGA1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTCCAaIwDQYJKoZIhvcN\n""
                    + ""AQEBBQADggGPADCCAYoCggGBAMtrsT0otlxh0QS079KpRRbU1PQjCihSoltXnrxF\n""
                    + ""sTWZs2weVEeYVyYU5LaauCDDgISCMtjtfbfylMBeYjpWB5hYzYQOiTzo0anWhMyb\n""
                    + ""Ngb7gpMVZuIl6lwMYRyVRKwHWnTo2EUg1ZzW5rGe5fs/KHj6//hoNFm+3Oju0TQd\n""
                    + ""nraQULpoERPF5B7p85Cssk8uNbviBfZXvtCuJ4N6w7PNceOY/9bbwc1mC+pPZmzV\n""
                    + ""SOAg0vvbIQRzChm63C3jBC3xmxSOOZVrKN4zKDG2s8P0oCNGt0NlgRMrgbPRekzg\n""
                    + ""4avkbA0vTuc2AyriTEYkdea/Mt4EpRg9XuOb43U/GJ/d/vQv2/9fsxhXmsZrn8kr\n""
                    + ""Qo5MMHJFUd96GgHmvYSU3Mf/5r8gF626lvqHioGuTAuHUSnr02ri1WUxZ15LDRgY\n""
                    + ""quMjDCFZfucjJPDAdtiHcFSej/4SLJlN39z8oKKNPn3aL9Gv49oAKs9S8tfDVzMk\n""
                    + ""fDLROQFHFuW715GnnMgEAoOpRwIDAQABo1MwUTAdBgNVHQ4EFgQUeVuGmSVN4ARs\n""
                    + ""mesUMWSJ2qWLbxUwHwYDVR0jBBgwFoAUeVuGmSVN4ARsmesUMWSJ2qWLbxUwDwYD\n""
                    + ""VR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQwFAAOCAYEAit1Lo/hegZpPuT9dlWZJ\n""
                    + ""bC8JvAf95O8lnn6LFb69pgYOHCLgCIlvYXu9rdBUJgZo+V1MzJJljiO6RxWRfKbQ\n""
                    + ""8WBYkoqR1EqriR3Kn8q/SjIZCdFSaznTyU1wQMveBQ6RJWXSUhYVfE9RjyFTp7B4\n""
                    + ""UyH2uCluR/0T06HQNGfH5XpIYQqCk1Zgng5lmEmheLDPoJpa92lKeQFJMC6eYz9g\n""
                    + ""lF1GHxPxkPfbMJ6ZDp5X6Yopu6Q6uEXhVKM/iQVcgzRkx9rid+xTYl+nOKyK/XfC\n""
                    + ""z8P0/TFIoPTW02DLge5wKagdoCpy1B7HdrAXyUjoH4B8MsUkq3kYPFSjPzScuTtV\n""
                    + ""kUuDw5ipCNeXCRnhbYqRDk6PX5GUu2cmN9jtaH3tbgm3fKNOsd/BO1fLIl7qjXlR\n""
                    + ""27HHbC0JXjNvlm2DLp23v4NTxS7WZGYsxyUj5DZrxBxqCsTXu/01w1BrQKWKh9FM\n""
                    + ""aVrlA8omfVODK2CSuw+KhEMHepRv/AUgsLl4L4+RMoa+\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CA_SUITE_B_RSA3072_CERT =
            loadCertificate(CA_SUITE_B_RSA3072_CERT_STRING);

    private static final String CA_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIICTzCCAdSgAwIBAgIUdnLttwNPnQzFufplGOr9bTrGCqMwCgYIKoZIzj0EAwMw\n""
                    + ""XjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNV\n""
                    + ""BAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0Q0Ew\n""
                    + ""HhcNMjAwNzIxMDIyNDA1WhcNMzAwNTMwMDIyNDA1WjBeMQswCQYDVQQGEwJVUzEL\n""
                    + ""MAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEOMAwG\n""
                    + ""A1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTB2MBAGByqGSM49AgEGBSuB\n""
                    + ""BAAiA2IABFmntXwk9icqhDQFUP1xy04WyEpaGW4q6Q+8pujlSl/X3iotPZ++GZfp\n""
                    + ""Mfv3YDHDBl6sELPQ2BEjyPXmpsKjOUdiUe69e88oGEdeqT2xXiQ6uzpTfJD4170i\n""
                    + ""O/TwLrQGKKNTMFEwHQYDVR0OBBYEFCjptsX3g4g5W0L4oEP6N3gfyiZXMB8GA1Ud\n""
                    + ""IwQYMBaAFCjptsX3g4g5W0L4oEP6N3gfyiZXMA8GA1UdEwEB/wQFMAMBAf8wCgYI\n""
                    + ""KoZIzj0EAwMDaQAwZgIxAK61brUYRbLmQKiaEboZgrHtnPAcGo7Yzx3MwHecx3Dm\n""
                    + ""5soIeLVYc8bPYN1pbhXW1gIxALdEe2sh03nBHyQH4adYoZungoCwt8mp/7sJFxou\n""
                    + ""9UnRegyBgGzf74ROWdpZHzh+Pg==\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CA_SUITE_B_ECDSA_CERT =
            loadCertificate(CA_SUITE_B_ECDSA_CERT_STRING);

    private static final String CLIENT_SUITE_B_RSA3072_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIERzCCAq8CFDopjyNgaj+c2TN2k06h7okEWpHJMA0GCSqGSIb3DQEBDAUAMF4x\n""
                    + ""CzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQK\n""
                    + ""DAdBbmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4X\n""
                    + ""DTIwMDcyMTAyMjkxMVoXDTMwMDUzMDAyMjkxMVowYjELMAkGA1UEBhMCVVMxCzAJ\n""
                    + ""BgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNV\n""
                    + ""BAsMBVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MIIBojANBgkqhkiG9w0B\n""
                    + ""AQEFAAOCAY8AMIIBigKCAYEAwSK3C5K5udtCKTnE14e8z2cZvwmB4Xe+a8+7QLud\n""
                    + ""Hooc/lQzClgK4MbVUC0D3FE+U32C78SxKoTaRWtvPmNm+UaFT8KkwyUno/dv+2XD\n""
                    + ""pd/zARQ+3FwAfWopAhEyCVSxwsCa+slQ4juRIMIuUC1Mm0NaptZyM3Tj/ICQEfpk\n""
                    + ""o9qVIbiK6eoJMTkY8EWfAn7RTFdfR1OLuO0mVOjgLW9/+upYv6hZ19nAMAxw4QTJ\n""
                    + ""x7lLwALX7B+tDYNEZHDqYL2zyvQWAj2HClere8QYILxkvktgBg2crEJJe4XbDH7L\n""
                    + ""A3rrXmsiqf1ZbfFFEzK9NFqovL+qGh+zIP+588ShJFO9H/RDnDpiTnAFTWXQdTwg\n""
                    + ""szSS0Vw2PB+JqEABAa9DeMvXT1Oy+NY3ItPHyy63nQZVI2rXANw4NhwS0Z6DF+Qs\n""
                    + ""TNrj+GU7e4SG/EGR8SvldjYfQTWFLg1l/UT1hOOkQZwdsaW1zgKyeuiFB2KdMmbA\n""
                    + ""Sq+Ux1L1KICo0IglwWcB/8nnAgMBAAEwDQYJKoZIhvcNAQEMBQADggGBAMYwJkNw\n""
                    + ""BaCviKFmReDTMwWPRy4AMNViEeqAXgERwDEKwM7efjsaj5gctWfKsxX6UdLzkhgg\n""
                    + ""6S/T6PxVWKzJ6l7SoOuTa6tMQOZp+h3R1mdfEQbw8B5cXBxZ+batzAai6Fiy1FKS\n""
                    + ""/ka3INbcGfYuIYghfTrb4/NJKN06ZaQ1bpPwq0e4gN7800T2nbawvSf7r+8ZLcG3\n""
                    + ""6bGCjRMwDSIipNvOwoj3TG315XC7TccX5difQ4sKOY+d2MkVJ3RiO0Ciw2ZbEW8d\n""
                    + ""1FH5vUQJWnBUfSFznosGzLwH3iWfqlP+27jNE+qB2igEwCRFgVAouURx5ou43xuX\n""
                    + ""qf6JkdI3HTJGLIWxkp7gOeln4dEaYzKjYw+P0VqJvKVqQ0IXiLjHgE0J9p0vgyD6\n""
                    + ""HVVcP7U8RgqrbIjL1QgHU4KBhGi+WSUh/mRplUCNvHgcYdcHi/gHpj/j6ubwqIGV\n""
                    + ""z4iSolAHYTmBWcLyE0NgpzE6ntp+53r2KaUJA99l2iGVzbWTwqPSm0XAVw==\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CLIENT_SUITE_B_RSA3072_CERT =
            loadCertificate(CLIENT_SUITE_B_RSA3072_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_RSA3072_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x82, (byte) 0x06, (byte) 0xfe, (byte) 0x02, (byte) 0x01,
            (byte) 0x00, (byte) 0x30, (byte) 0x0d, (byte) 0x06, (byte) 0x09, (byte) 0x2a,
            (byte) 0x86, (byte) 0x48, (byte) 0x86, (byte) 0xf7, (byte) 0x0d, (byte) 0x01,
            (byte) 0x01, (byte) 0x01, (byte) 0x05, (byte) 0x00, (byte) 0x04, (byte) 0x82,
            (byte) 0x06, (byte) 0xe8, (byte) 0x30, (byte) 0x82, (byte) 0x06, (byte) 0xe4,
            (byte) 0x02, (byte) 0x01, (byte) 0x00, (byte) 0x02, (byte) 0x82, (byte) 0x01,
            (byte) 0x81, (byte) 0x00, (byte) 0xc1, (byte) 0x22, (byte) 0xb7, (byte) 0x0b,
            (byte) 0x92, (byte) 0xb9, (byte) 0xb9, (byte) 0xdb, (byte) 0x42, (byte) 0x29,
            (byte) 0x39, (byte) 0xc4, (byte) 0xd7, (byte) 0x87, (byte) 0xbc, (byte) 0xcf,
            (byte) 0x67, (byte) 0x19, (byte) 0xbf, (byte) 0x09, (byte) 0x81, (byte) 0xe1,
            (byte) 0x77, (byte) 0xbe, (byte) 0x6b, (byte) 0xcf, (byte) 0xbb, (byte) 0x40,
            (byte) 0xbb, (byte) 0x9d, (byte) 0x1e, (byte) 0x8a, (byte) 0x1c, (byte) 0xfe,
            (byte) 0x54, (byte) 0x33, (byte) 0x0a, (byte) 0x58, (byte) 0x0a, (byte) 0xe0,
            (byte) 0xc6, (byte) 0xd5, (byte) 0x50, (byte) 0x2d, (byte) 0x03, (byte) 0xdc,
            (byte) 0x51, (byte) 0x3e, (byte) 0x53, (byte) 0x7d, (byte) 0x82, (byte) 0xef,
            (byte) 0xc4, (byte) 0xb1, (byte) 0x2a, (byte) 0x84, (byte) 0xda, (byte) 0x45,
            (byte) 0x6b, (byte) 0x6f, (byte) 0x3e, (byte) 0x63, (byte) 0x66, (byte) 0xf9,
            (byte) 0x46, (byte) 0x85, (byte) 0x4f, (byte) 0xc2, (byte) 0xa4, (byte) 0xc3,
            (byte) 0x25, (byte) 0x27, (byte) 0xa3, (byte) 0xf7, (byte) 0x6f, (byte) 0xfb,
            (byte) 0x65, (byte) 0xc3, (byte) 0xa5, (byte) 0xdf, (byte) 0xf3, (byte) 0x01,
            (byte) 0x14, (byte) 0x3e, (byte) 0xdc, (byte) 0x5c, (byte) 0x00, (byte) 0x7d,
            (byte) 0x6a, (byte) 0x29, (byte) 0x02, (byte) 0x11, (byte) 0x32, (byte) 0x09,
            (byte) 0x54, (byte) 0xb1, (byte) 0xc2, (byte) 0xc0, (byte) 0x9a, (byte) 0xfa,
            (byte) 0xc9, (byte) 0x50, (byte) 0xe2, (byte) 0x3b, (byte) 0x91, (byte) 0x20,
            (byte) 0xc2, (byte) 0x2e, (byte) 0x50, (byte) 0x2d, (byte) 0x4c, (byte) 0x9b,
            (byte) 0x43, (byte) 0x5a, (byte) 0xa6, (byte) 0xd6, (byte) 0x72, (byte) 0x33,
            (byte) 0x74, (byte) 0xe3, (byte) 0xfc, (byte) 0x80, (byte) 0x90, (byte) 0x11,
            (byte) 0xfa, (byte) 0x64, (byte) 0xa3, (byte) 0xda, (byte) 0x95, (byte) 0x21,
            (byte) 0xb8, (byte) 0x8a, (byte) 0xe9, (byte) 0xea, (byte) 0x09, (byte) 0x31,
            (byte) 0x39, (byte) 0x18, (byte) 0xf0, (byte) 0x45, (byte) 0x9f, (byte) 0x02,
            (byte) 0x7e, (byte) 0xd1, (byte) 0x4c, (byte) 0x57, (byte) 0x5f, (byte) 0x47,
            (byte) 0x53, (byte) 0x8b, (byte) 0xb8, (byte) 0xed, (byte) 0x26, (byte) 0x54,
            (byte) 0xe8, (byte) 0xe0, (byte) 0x2d, (byte) 0x6f, (byte) 0x7f, (byte) 0xfa,
            (byte) 0xea, (byte) 0x58, (byte) 0xbf, (byte) 0xa8, (byte) 0x59, (byte) 0xd7,
            (byte) 0xd9, (byte) 0xc0, (byte) 0x30, (byte) 0x0c, (byte) 0x70, (byte) 0xe1,
            (byte) 0x04, (byte) 0xc9, (byte) 0xc7, (byte) 0xb9, (byte) 0x4b, (byte) 0xc0,
            (byte) 0x02, (byte) 0xd7, (byte) 0xec, (byte) 0x1f, (byte) 0xad, (byte) 0x0d,
            (byte) 0x83, (byte) 0x44, (byte) 0x64, (byte) 0x70, (byte) 0xea, (byte) 0x60,
            (byte) 0xbd, (byte) 0xb3, (byte) 0xca, (byte) 0xf4, (byte) 0x16, (byte) 0x02,
            (byte) 0x3d, (byte) 0x87, (byte) 0x0a, (byte) 0x57, (byte) 0xab, (byte) 0x7b,
            (byte) 0xc4, (byte) 0x18, (byte) 0x20, (byte) 0xbc, (byte) 0x64, (byte) 0xbe,
            (byte) 0x4b, (byte) 0x60, (byte) 0x06, (byte) 0x0d, (byte) 0x9c, (byte) 0xac,
            (byte) 0x42, (byte) 0x49, (byte) 0x7b, (byte) 0x85, (byte) 0xdb, (byte) 0x0c,
            (byte) 0x7e, (byte) 0xcb, (byte) 0x03, (byte) 0x7a, (byte) 0xeb, (byte) 0x5e,
            (byte) 0x6b, (byte) 0x22, (byte) 0xa9, (byte) 0xfd, (byte) 0x59, (byte) 0x6d,
            (byte) 0xf1, (byte) 0x45, (byte) 0x13, (byte) 0x32, (byte) 0xbd, (byte) 0x34,
            (byte) 0x5a, (byte) 0xa8, (byte) 0xbc, (byte) 0xbf, (byte) 0xaa, (byte) 0x1a,
            (byte) 0x1f, (byte) 0xb3, (byte) 0x20, (byte) 0xff, (byte) 0xb9, (byte) 0xf3,
            (byte) 0xc4, (byte) 0xa1, (byte) 0x24, (byte) 0x53, (byte) 0xbd, (byte) 0x1f,
            (byte) 0xf4, (byte) 0x43, (byte) 0x9c, (byte) 0x3a, (byte) 0x62, (byte) 0x4e,
            (byte) 0x70, (byte) 0x05, (byte) 0x4d, (byte) 0x65, (byte) 0xd0, (byte) 0x75,
            (byte) 0x3c, (byte) 0x20, (byte) 0xb3, (byte) 0x34, (byte) 0x92, (byte) 0xd1,
            (byte) 0x5c, (byte) 0x36, (byte) 0x3c, (byte) 0x1f, (byte) 0x89, (byte) 0xa8,
            (byte) 0x40, (byte) 0x01, (byte) 0x01, (byte) 0xaf, (byte) 0x43, (byte) 0x78,
            (byte) 0xcb, (byte) 0xd7, (byte) 0x4f, (byte) 0x53, (byte) 0xb2, (byte) 0xf8,
            (byte) 0xd6, (byte) 0x37, (byte) 0x22, (byte) 0xd3, (byte) 0xc7, (byte) 0xcb,
            (byte) 0x2e, (byte) 0xb7, (byte) 0x9d, (byte) 0x06, (byte) 0x55, (byte) 0x23,
            (byte) 0x6a, (byte) 0xd7, (byte) 0x00, (byte) 0xdc, (byte) 0x38, (byte) 0x36,
            (byte) 0x1c, (byte) 0x12, (byte) 0xd1, (byte) 0x9e, (byte) 0x83, (byte) 0x17,
            (byte) 0xe4, (byte) 0x2c, (byte) 0x4c, (byte) 0xda, (byte) 0xe3, (byte) 0xf8,
            (byte) 0x65, (byte) 0x3b, (byte) 0x7b, (byte) 0x84, (byte) 0x86, (byte) 0xfc,
            (byte) 0x41, (byte) 0x91, (byte) 0xf1, (byte) 0x2b, (byte) 0xe5, (byte) 0x76,
            (byte) 0x36, (byte) 0x1f, (byte) 0x41, (byte) 0x35, (byte) 0x85, (byte) 0x2e,
            (byte) 0x0d, (byte) 0x65, (byte) 0xfd, (byte) 0x44, (byte) 0xf5, (byte) 0x84,
            (byte) 0xe3, (byte) 0xa4, (byte) 0x41, (byte) 0x9c, (byte) 0x1d, (byte) 0xb1,
            (byte) 0xa5, (byte) 0xb5, (byte) 0xce, (byte) 0x02, (byte) 0xb2, (byte) 0x7a,
            (byte) 0xe8, (byte) 0x85, (byte) 0x07, (byte) 0x62, (byte) 0x9d, (byte) 0x32,
            (byte) 0x66, (byte) 0xc0, (byte) 0x4a, (byte) 0xaf, (byte) 0x94, (byte) 0xc7,
            (byte) 0x52, (byte) 0xf5, (byte) 0x28, (byte) 0x80, (byte) 0xa8, (byte) 0xd0,
            (byte) 0x88, (byte) 0x25, (byte) 0xc1, (byte) 0x67, (byte) 0x01, (byte) 0xff,
            (byte) 0xc9, (byte) 0xe7, (byte) 0x02, (byte) 0x03, (byte) 0x01, (byte) 0x00,
            (byte) 0x01, (byte) 0x02, (byte) 0x82, (byte) 0x01, (byte) 0x80, (byte) 0x04,
            (byte) 0xb1, (byte) 0xcc, (byte) 0x53, (byte) 0x3a, (byte) 0xb0, (byte) 0xcb,
            (byte) 0x04, (byte) 0xba, (byte) 0x59, (byte) 0xf8, (byte) 0x2e, (byte) 0x81,
            (byte) 0xb2, (byte) 0xa9, (byte) 0xf3, (byte) 0x3c, (byte) 0xa5, (byte) 0x52,
            (byte) 0x90, (byte) 0x6f, (byte) 0x98, (byte) 0xc4, (byte) 0x69, (byte) 0x5b,
            (byte) 0x83, (byte) 0x84, (byte) 0x20, (byte) 0xb1, (byte) 0xae, (byte) 0xc3,
            (byte) 0x04, (byte) 0x46, (byte) 0x6a, (byte) 0x24, (byte) 0x2f, (byte) 0xcd,
            (byte) 0x6b, (byte) 0x90, (byte) 0x70, (byte) 0x20, (byte) 0x45, (byte) 0x25,
            (byte) 0x1a, (byte) 0xc3, (byte) 0x02, (byte) 0x42, (byte) 0xf3, (byte) 0x49,
            (byte) 0xe2, (byte) 0x3e, (byte) 0x21, (byte) 0x87, (byte) 0xdd, (byte) 0x6a,
            (byte) 0x94, (byte) 0x2a, (byte) 0x1e, (byte) 0x0f, (byte) 0xdb, (byte) 0x77,
            (byte) 0x5f, (byte) 0xc1, (byte) 0x2c, (byte) 0x03, (byte) 0xfb, (byte) 0xcf,
            (byte) 0x91, (byte) 0x82, (byte) 0xa1, (byte) 0xbf, (byte) 0xb0, (byte) 0x73,
            (byte) 0xfa, (byte) 0xda, (byte) 0xbc, (byte) 0xf8, (byte) 0x9f, (byte) 0x45,
            (byte) 0xd3, (byte) 0xe8, (byte) 0xbb, (byte) 0x38, (byte) 0xfb, (byte) 0xc2,
            (byte) 0x2d, (byte) 0x76, (byte) 0x51, (byte) 0x96, (byte) 0x18, (byte) 0x03,
            (byte) 0x15, (byte) 0xd9, (byte) 0xea, (byte) 0x82, (byte) 0x25, (byte) 0x83,
            (byte) 0xff, (byte) 0x5c, (byte) 0x85, (byte) 0x06, (byte) 0x09, (byte) 0xb2,
            (byte) 0x46, (byte) 0x12, (byte) 0x64, (byte) 0x02, (byte) 0x74, (byte) 0x4f,
            (byte) 0xbc, (byte) 0x9a, (byte) 0x25, (byte) 0x18, (byte) 0x01, (byte) 0x07,
            (byte) 0x17, (byte) 0x25, (byte) 0x55, (byte) 0x7c, (byte) 0xdc, (byte) 0xe1,
            (byte) 0xd1, (byte) 0x5a, (byte) 0x2f, (byte) 0x25, (byte) 0xaf, (byte) 0xf6,
            (byte) 0x8f, (byte) 0xa4, (byte) 0x9a, (byte) 0x5a, (byte) 0x3a, (byte) 0xfe,
            (byte) 0x2e, (byte) 0x93, (byte) 0x24, (byte) 0xa0, (byte) 0x27, (byte) 0xac,
            (byte) 0x07, (byte) 0x75, (byte) 0x33, (byte) 0x01, (byte) 0x54, (byte) 0x23,
            (byte) 0x0f, (byte) 0xe8, (byte) 0x9f, (byte) 0xfa, (byte) 0x36, (byte) 0xe6,
            (byte) 0x3a, (byte) 0xd5, (byte) 0x78, (byte) 0xb0, (byte) 0xe4, (byte) 0x6a,
            (byte) 0x16, (byte) 0x50, (byte) 0xbd, (byte) 0x0f, (byte) 0x9f, (byte) 0x32,
            (byte) 0xa1, (byte) 0x6b, (byte) 0xf5, (byte) 0xa4, (byte) 0x34, (byte) 0x58,
            (byte) 0xb6, (byte) 0xa4, (byte) 0xb3, (byte) 0xc3, (byte) 0x83, (byte) 0x08,
            (byte) 0x18, (byte) 0xc7, (byte) 0xef, (byte) 0x95, (byte) 0xe2, (byte) 0x1b,
            (byte) 0xba, (byte) 0x35, (byte) 0x61, (byte) 0xa3, (byte) 0xb4, (byte) 0x30,
            (byte) 0xe0, (byte) 0xd1, (byte) 0xc1, (byte) 0xa2, (byte) 0x3a, (byte) 0xc6,
            (byte) 0xb4, (byte) 0xd2, (byte) 0x80, (byte) 0x5a, (byte) 0xaf, (byte) 0xa4,
            (byte) 0x54, (byte) 0x3c, (byte) 0x66, (byte) 0x5a, (byte) 0x1c, (byte) 0x4d,
            (byte) 0xe1, (byte) 0xd9, (byte) 0x98, (byte) 0x44, (byte) 0x01, (byte) 0x1b,
            (byte) 0x8c, (byte) 0xe9, (byte) 0x80, (byte) 0x54, (byte) 0x83, (byte) 0x3d,
            (byte) 0x96, (byte) 0x25, (byte) 0x41, (byte) 0x1c, (byte) 0xad, (byte) 0xae,
            (byte) 0x3b, (byte) 0x7a, (byte) 0xd7, (byte) 0x9d, (byte) 0x10, (byte) 0x7c,
            (byte) 0xd1, (byte) 0xa7, (byte) 0x96, (byte) 0x39, (byte) 0xa5, (byte) 0x2f,
            (byte) 0xbe, (byte) 0xc3, (byte) 0x2c, (byte) 0x64, (byte) 0x01, (byte) 0xfe,
            (byte) 0xa2, (byte) 0xd1, (byte) 0x6a, (byte) 0xcf, (byte) 0x4c, (byte) 0x76,
            (byte) 0x3b, (byte) 0xc8, (byte) 0x35, (byte) 0x21, (byte) 0xda, (byte) 0x98,
            (byte) 0xcf, (byte) 0xf9, (byte) 0x29, (byte) 0xff, (byte) 0x30, (byte) 0x59,
            (byte) 0x36, (byte) 0x53, (byte) 0x0b, (byte) 0xbb, (byte) 0xfa, (byte) 0xba,
            (byte) 0xc4, (byte) 0x03, (byte) 0x23, (byte) 0xe0, (byte) 0xd3, (byte) 0x33,
            (byte) 0xff, (byte) 0x32, (byte) 0xdb, (byte) 0x30, (byte) 0x64, (byte) 0xc7,
            (byte) 0x56, (byte) 0xca, (byte) 0x55, (byte) 0x14, (byte) 0xee, (byte) 0x58,
            (byte) 0xfe, (byte) 0x96, (byte) 0x7e, (byte) 0x1c, (byte) 0x34, (byte) 0x16,
            (byte) 0xeb, (byte) 0x76, (byte) 0x26, (byte) 0x48, (byte) 0xe2, (byte) 0xe5,
            (byte) 0x5c, (byte) 0xd5, (byte) 0x83, (byte) 0x37, (byte) 0xd9, (byte) 0x09,
            (byte) 0x71, (byte) 0xbc, (byte) 0x54, (byte) 0x25, (byte) 0xca, (byte) 0x2e,
            (byte) 0xdb, (byte) 0x36, (byte) 0x39, (byte) 0xcc, (byte) 0x3a, (byte) 0x81,
            (byte) 0x95, (byte) 0x9e, (byte) 0xf4, (byte) 0x01, (byte) 0xa7, (byte) 0xc0,
            (byte) 0x20, (byte) 0xce, (byte) 0x70, (byte) 0x55, (byte) 0x2c, (byte) 0xe0,
            (byte) 0x93, (byte) 0x72, (byte) 0xa6, (byte) 0x25, (byte) 0xda, (byte) 0x64,
            (byte) 0x19, (byte) 0x18, (byte) 0xd2, (byte) 0x31, (byte) 0xe2, (byte) 0x7c,
            (byte) 0xf2, (byte) 0x30, (byte) 0x9e, (byte) 0x8d, (byte) 0xc6, (byte) 0x14,
            (byte) 0x8a, (byte) 0x38, (byte) 0xf0, (byte) 0x94, (byte) 0xeb, (byte) 0xf4,
            (byte) 0x64, (byte) 0x92, (byte) 0x3d, (byte) 0x67, (byte) 0xa6, (byte) 0x2c,
            (byte) 0x52, (byte) 0xfc, (byte) 0x60, (byte) 0xca, (byte) 0x2a, (byte) 0xcf,
            (byte) 0x24, (byte) 0xd5, (byte) 0x42, (byte) 0x5f, (byte) 0xc7, (byte) 0x9f,
            (byte) 0xf3, (byte) 0xb4, (byte) 0xdf, (byte) 0x76, (byte) 0x6e, (byte) 0x53,
            (byte) 0xa1, (byte) 0x7b, (byte) 0xae, (byte) 0xa5, (byte) 0x84, (byte) 0x1f,
            (byte) 0xfa, (byte) 0xc0, (byte) 0xb4, (byte) 0x6c, (byte) 0xc9, (byte) 0x02,
            (byte) 0x81, (byte) 0xc1, (byte) 0x00, (byte) 0xf3, (byte) 0x17, (byte) 0xd9,
            (byte) 0x48, (byte) 0x17, (byte) 0x87, (byte) 0x84, (byte) 0x16, (byte) 0xea,
            (byte) 0x2d, (byte) 0x31, (byte) 0x1b, (byte) 0xce, (byte) 0xec, (byte) 0xaf,
            (byte) 0xdc, (byte) 0x6b, (byte) 0xaf, (byte) 0xc8, (byte) 0xf1, (byte) 0x40,
            (byte) 0xa7, (byte) 0x4f, (byte) 0xef, (byte) 0x48, (byte) 0x08, (byte) 0x5e,
            (byte) 0x9a, (byte) 0xd1, (byte) 0xc0, (byte) 0xb1, (byte) 0xfe, (byte) 0xe7,
            (byte) 0x03, (byte) 0xd5, (byte) 0x96, (byte) 0x01, (byte) 0xe8, (byte) 0x40,
            (byte) 0xca, (byte) 0x78, (byte) 0xcb, (byte) 0xb3, (byte) 0x28, (byte) 0x1a,
            (byte) 0xf0, (byte) 0xe5, (byte) 0xf6, (byte) 0x46, (byte) 0xef, (byte) 0xcd,
            (byte) 0x1a, (byte) 0x0f, (byte) 0x13, (byte) 0x2d, (byte) 0x38, (byte) 0xf8,
            (byte) 0xf7, (byte) 0x88, (byte) 0x21, (byte) 0x15, (byte) 0xce, (byte) 0x48,
            (byte) 0xf4, (byte) 0x92, (byte) 0x7e, (byte) 0x9b, (byte) 0x2e, (byte) 0x2f,
            (byte) 0x22, (byte) 0x3e, (byte) 0x5c, (byte) 0x67, (byte) 0xd7, (byte) 0x58,
            (byte) 0xf6, (byte) 0xef, (byte) 0x1f, (byte) 0xb4, (byte) 0x04, (byte) 0xc7,
            (byte) 0xfd, (byte) 0x8c, (byte) 0x4e, (byte) 0x27, (byte) 0x9e, (byte) 0xb9,
            (byte) 0xef, (byte) 0x0f, (byte) 0xf7, (byte) 0x4a, (byte) 0xc2, (byte) 0xf4,
            (byte) 0x64, (byte) 0x6b, (byte) 0xe0, (byte) 0xfb, (byte) 0xe3, (byte) 0x45,
            (byte) 0xd5, (byte) 0x37, (byte) 0xa0, (byte) 0x2a, (byte) 0xc6, (byte) 0xf3,
            (byte) 0xf6, (byte) 0xcc, (byte) 0xb5, (byte) 0x94, (byte) 0xbf, (byte) 0x56,
            (byte) 0xa0, (byte) 0x61, (byte) 0x36, (byte) 0x88, (byte) 0x35, (byte) 0xd5,
            (byte) 0xa5, (byte) 0xad, (byte) 0x20, (byte) 0x48, (byte) 0xda, (byte) 0x70,
            (byte) 0x35, (byte) 0xd9, (byte) 0x75, (byte) 0x66, (byte) 0xa5, (byte) 0xac,
            (byte) 0x86, (byte) 0x7a, (byte) 0x75, (byte) 0x49, (byte) 0x88, (byte) 0x40,
            (byte) 0xce, (byte) 0xb0, (byte) 0x6f, (byte) 0x57, (byte) 0x15, (byte) 0x54,
            (byte) 0xd3, (byte) 0x2f, (byte) 0x11, (byte) 0x9b, (byte) 0xe3, (byte) 0x87,
            (byte) 0xc8, (byte) 0x8d, (byte) 0x98, (byte) 0xc6, (byte) 0xe0, (byte) 0xbc,
            (byte) 0x85, (byte) 0xb9, (byte) 0x04, (byte) 0x43, (byte) 0xa9, (byte) 0x41,
            (byte) 0xce, (byte) 0x42, (byte) 0x1a, (byte) 0x57, (byte) 0x10, (byte) 0xd8,
            (byte) 0xe4, (byte) 0x6a, (byte) 0x51, (byte) 0x10, (byte) 0x0a, (byte) 0xec,
            (byte) 0xe4, (byte) 0x57, (byte) 0xc7, (byte) 0xee, (byte) 0xe9, (byte) 0xd6,
            (byte) 0xcb, (byte) 0x3e, (byte) 0xba, (byte) 0xfa, (byte) 0xe9, (byte) 0x0e,
            (byte) 0xed, (byte) 0x87, (byte) 0x04, (byte) 0x9a, (byte) 0x48, (byte) 0xba,
            (byte) 0xaf, (byte) 0x08, (byte) 0xf5, (byte) 0x02, (byte) 0x81, (byte) 0xc1,
            (byte) 0x00, (byte) 0xcb, (byte) 0x63, (byte) 0xd6, (byte) 0x54, (byte) 0xb6,
            (byte) 0xf3, (byte) 0xf3, (byte) 0x8c, (byte) 0xf8, (byte) 0xd0, (byte) 0xd2,
            (byte) 0x84, (byte) 0xc1, (byte) 0xf5, (byte) 0x12, (byte) 0xe0, (byte) 0x02,
            (byte) 0x80, (byte) 0x42, (byte) 0x92, (byte) 0x4e, (byte) 0xa4, (byte) 0x5c,
            (byte) 0xa5, (byte) 0x64, (byte) 0xec, (byte) 0xb7, (byte) 0xdc, (byte) 0xe0,
            (byte) 0x2d, (byte) 0x5d, (byte) 0xac, (byte) 0x0e, (byte) 0x24, (byte) 0x48,
            (byte) 0x13, (byte) 0x05, (byte) 0xe8, (byte) 0xff, (byte) 0x96, (byte) 0x93,
            (byte) 0xba, (byte) 0x3c, (byte) 0x88, (byte) 0xcc, (byte) 0x80, (byte) 0xf9,
            (byte) 0xdb, (byte) 0xa8, (byte) 0x4d, (byte) 0x86, (byte) 0x47, (byte) 0xc8,
            (byte) 0xbf, (byte) 0x34, (byte) 0x2d, (byte) 0xda, (byte) 0xb6, (byte) 0x28,
            (byte) 0xf0, (byte) 0x1e, (byte) 0xd2, (byte) 0x46, (byte) 0x0d, (byte) 0x6f,
            (byte) 0x36, (byte) 0x8e, (byte) 0x84, (byte) 0xd8, (byte) 0xaf, (byte) 0xf7,
            (byte) 0x69, (byte) 0x23, (byte) 0x77, (byte) 0xfb, (byte) 0xc5, (byte) 0x04,
            (byte) 0x08, (byte) 0x18, (byte) 0xac, (byte) 0x85, (byte) 0x80, (byte) 0x87,
            (byte) 0x1c, (byte) 0xfe, (byte) 0x8e, (byte) 0x5d, (byte) 0x00, (byte) 0x7f,
            (byte) 0x5b, (byte) 0x33, (byte) 0xf5, (byte) 0xdf, (byte) 0x70, (byte) 0x81,
            (byte) 0xad, (byte) 0x81, (byte) 0xf4, (byte) 0x5a, (byte) 0x37, (byte) 0x8a,
            (byte) 0x79, (byte) 0x09, (byte) 0xc5, (byte) 0x55, (byte) 0xab, (byte) 0x58,
            (byte) 0x7c, (byte) 0x47, (byte) 0xca, (byte) 0xa5, (byte) 0x80, (byte) 0x49,
            (byte) 0x5f, (byte) 0x71, (byte) 0x83, (byte) 0xfb, (byte) 0x3b, (byte) 0x06,
            (byte) 0xec, (byte) 0x75, (byte) 0x23, (byte) 0xc4, (byte) 0x32, (byte) 0xc7,
            (byte) 0x18, (byte) 0xf6, (byte) 0x82, (byte) 0x95, (byte) 0x98, (byte) 0x39,
            (byte) 0xf7, (byte) 0x92, (byte) 0x31, (byte) 0xc0, (byte) 0x89, (byte) 0xba,
            (byte) 0xd4, (byte) 0xd4, (byte) 0x58, (byte) 0x4e, (byte) 0x38, (byte) 0x35,
            (byte) 0x10, (byte) 0xb9, (byte) 0xf1, (byte) 0x27, (byte) 0xdc, (byte) 0xff,
            (byte) 0xc7, (byte) 0xb2, (byte) 0xba, (byte) 0x1f, (byte) 0x27, (byte) 0xaf,
            (byte) 0x99, (byte) 0xd5, (byte) 0xb0, (byte) 0x39, (byte) 0xe7, (byte) 0x43,
            (byte) 0x88, (byte) 0xd3, (byte) 0xce, (byte) 0x38, (byte) 0xc2, (byte) 0x99,
            (byte) 0x43, (byte) 0xfc, (byte) 0x8a, (byte) 0xe3, (byte) 0x60, (byte) 0x0d,
            (byte) 0x0a, (byte) 0xb8, (byte) 0xc4, (byte) 0x29, (byte) 0xca, (byte) 0x0d,
            (byte) 0x30, (byte) 0xaf, (byte) 0xca, (byte) 0xd0, (byte) 0xaa, (byte) 0x67,
            (byte) 0xb1, (byte) 0xdd, (byte) 0xdb, (byte) 0x7a, (byte) 0x11, (byte) 0xad,
            (byte) 0xeb, (byte) 0x02, (byte) 0x81, (byte) 0xc0, (byte) 0x71, (byte) 0xb8,
            (byte) 0xcf, (byte) 0x72, (byte) 0x35, (byte) 0x67, (byte) 0xb5, (byte) 0x38,
            (byte) 0x8f, (byte) 0x16, (byte) 0xd3, (byte) 0x29, (byte) 0x82, (byte) 0x35,
            (byte) 0x21, (byte) 0xd4, (byte) 0x49, (byte) 0x20, (byte) 0x74, (byte) 0x2d,
            (byte) 0xc0, (byte) 0xa4, (byte) 0x44, (byte) 0xf5, (byte) 0xd8, (byte) 0xc9,
            (byte) 0xe9, (byte) 0x90, (byte) 0x1d, (byte) 0xde, (byte) 0x3a, (byte) 0xa6,
            (byte) 0xd7, (byte) 0xe5, (byte) 0xe8, (byte) 0x4e, (byte) 0x83, (byte) 0xd7,
            (byte) 0xe6, (byte) 0x2f, (byte) 0x92, (byte) 0x31, (byte) 0x21, (byte) 0x3f,
            (byte) 0xfa, (byte) 0xd2, (byte) 0x85, (byte) 0x92, (byte) 0x1f, (byte) 0xff,
            (byte) 0x61, (byte) 0x00, (byte) 0xf6, (byte) 0xda, (byte) 0x6e, (byte) 0xc6,
            (byte) 0x7f, (byte) 0x5a, (byte) 0x35, (byte) 0x79, (byte) 0xdc, (byte) 0xdc,
            (byte) 0xa3, (byte) 0x2e, (byte) 0x9f, (byte) 0x35, (byte) 0xd1, (byte) 0x5c,
            (byte) 0xda, (byte) 0xb9, (byte) 0xf7, (byte) 0x58, (byte) 0x7d, (byte) 0x4f,
            (byte) 0xb6, (byte) 0x13, (byte) 0xd7, (byte) 0x2c, (byte) 0x0a, (byte) 0xa8,
            (byte) 0x4d, (byte) 0xf2, (byte) 0xe4, (byte) 0x67, (byte) 0x4f, (byte) 0x8b,
            (byte) 0xa6, (byte) 0xca, (byte) 0x1a, (byte) 0xbb, (byte) 0x02, (byte) 0x63,
            (byte) 0x8f, (byte) 0xb7, (byte) 0x46, (byte) 0xec, (byte) 0x7a, (byte) 0x8a,
            (byte) 0x09, (byte) 0x0a, (byte) 0x45, (byte) 0x3a, (byte) 0x8d, (byte) 0xa8,
            (byte) 0x83, (byte) 0x4b, (byte) 0x0a, (byte) 0xdb, (byte) 0x4b, (byte) 0x99,
            (byte) 0xf3, (byte) 0x69, (byte) 0x95, (byte) 0xf0, (byte) 0xcf, (byte) 0xe9,
            (byte) 0xf7, (byte) 0x67, (byte) 0xc9, (byte) 0x45, (byte) 0x18, (byte) 0x2f,
            (byte) 0xf0, (byte) 0x5c, (byte) 0x90, (byte) 0xbd, (byte) 0xa6, (byte) 0x66,
            (byte) 0x8c, (byte) 0xfe, (byte) 0x60, (byte) 0x5d, (byte) 0x6c, (byte) 0x27,
            (byte) 0xec, (byte) 0xc1, (byte) 0x84, (byte) 0xb2, (byte) 0xa1, (byte) 0x97,
            (byte) 0x9e, (byte) 0x16, (byte) 0x29, (byte) 0xa7, (byte) 0xe0, (byte) 0x38,
            (byte) 0xa2, (byte) 0x36, (byte) 0x05, (byte) 0x5f, (byte) 0xda, (byte) 0x72,
            (byte) 0x1a, (byte) 0x5f, (byte) 0xa8, (byte) 0x7d, (byte) 0x41, (byte) 0x35,
            (byte) 0xf6, (byte) 0x4e, (byte) 0x0a, (byte) 0x88, (byte) 0x8e, (byte) 0x00,
            (byte) 0x98, (byte) 0xa6, (byte) 0xca, (byte) 0xc1, (byte) 0xdf, (byte) 0x72,
            (byte) 0x6c, (byte) 0xfe, (byte) 0x29, (byte) 0xbe, (byte) 0xa3, (byte) 0x9b,
            (byte) 0x0b, (byte) 0x5c, (byte) 0x0b, (byte) 0x9d, (byte) 0xa7, (byte) 0x71,
            (byte) 0xce, (byte) 0x04, (byte) 0xfa, (byte) 0xac, (byte) 0x01, (byte) 0x8d,
            (byte) 0x52, (byte) 0xa0, (byte) 0x3d, (byte) 0xdd, (byte) 0x02, (byte) 0x81,
            (byte) 0xc1, (byte) 0x00, (byte) 0xc1, (byte) 0xc0, (byte) 0x2e, (byte) 0xa9,
            (byte) 0xee, (byte) 0xca, (byte) 0xff, (byte) 0xe4, (byte) 0xf8, (byte) 0x15,
            (byte) 0xfd, (byte) 0xa5, (byte) 0x68, (byte) 0x1b, (byte) 0x2d, (byte) 0x4a,
            (byte) 0xe6, (byte) 0x37, (byte) 0x06, (byte) 0xb3, (byte) 0xd7, (byte) 0x64,
            (byte) 0xad, (byte) 0xb9, (byte) 0x05, (byte) 0x26, (byte) 0x97, (byte) 0x94,
            (byte) 0x3a, (byte) 0x9e, (byte) 0x1c, (byte) 0xd0, (byte) 0xcd, (byte) 0x7b,
            (byte) 0xf4, (byte) 0x88, (byte) 0xe2, (byte) 0xa5, (byte) 0x6d, (byte) 0xed,
            (byte) 0x24, (byte) 0x77, (byte) 0x52, (byte) 0x39, (byte) 0x43, (byte) 0x0f,
            (byte) 0x4e, (byte) 0x75, (byte) 0xd8, (byte) 0xa3, (byte) 0x59, (byte) 0x5a,
            (byte) 0xc2, (byte) 0xba, (byte) 0x9a, (byte) 0x5b, (byte) 0x60, (byte) 0x31,
            (byte) 0x0d, (byte) 0x58, (byte) 0x89, (byte) 0x13, (byte) 0xe8, (byte) 0x95,
            (byte) 0xdd, (byte) 0xae, (byte) 0xcc, (byte) 0x1f, (byte) 0x73, (byte) 0x48,
            (byte) 0x55, (byte) 0xd8, (byte) 0xfb, (byte) 0x67, (byte) 0xce, (byte) 0x18,
            (byte) 0x85, (byte) 0x59, (byte) 0xad, (byte) 0x1f, (byte) 0x93, (byte) 0xe1,
            (byte) 0xb7, (byte) 0x54, (byte) 0x80, (byte) 0x8e, (byte) 0x5f, (byte) 0xbc,
            (byte) 0x1c, (byte) 0x96, (byte) 0x66, (byte) 0x2e, (byte) 0x40, (byte) 0x17,
            (byte) 0x2e, (byte) 0x01, (byte) 0x7a, (byte) 0x7d, (byte) 0xaa, (byte) 0xff,
            (byte) 0xa3, (byte) 0xd2, (byte) 0xdf, (byte) 0xe2, (byte) 0xf3, (byte) 0x54,
            (byte) 0x51, (byte) 0xeb, (byte) 0xba, (byte) 0x7c, (byte) 0x2a, (byte) 0x22,
            (byte) 0xc6, (byte) 0x42, (byte) 0xbc, (byte) 0xa1, (byte) 0x6c, (byte) 0xcf,
            (byte) 0x73, (byte) 0x2e, (byte) 0x07, (byte) 0xfc, (byte) 0xf5, (byte) 0x67,
            (byte) 0x25, (byte) 0xd0, (byte) 0xfa, (byte) 0xeb, (byte) 0xb4, (byte) 0xd4,
            (byte) 0x19, (byte) 0xcc, (byte) 0x64, (byte) 0xa1, (byte) 0x2e, (byte) 0x78,
            (byte) 0x45, (byte) 0xd9, (byte) 0x7f, (byte) 0x1b, (byte) 0x4c, (byte) 0x10,
            (byte) 0x31, (byte) 0x44, (byte) 0xe8, (byte) 0xcc, (byte) 0xf9, (byte) 0x1b,
            (byte) 0x87, (byte) 0x31, (byte) 0xd6, (byte) 0x69, (byte) 0x85, (byte) 0x4a,
            (byte) 0x49, (byte) 0xf6, (byte) 0xb2, (byte) 0xe0, (byte) 0xb8, (byte) 0x98,
            (byte) 0x3c, (byte) 0xf6, (byte) 0x78, (byte) 0x46, (byte) 0xc8, (byte) 0x3d,
            (byte) 0x60, (byte) 0xc1, (byte) 0xaa, (byte) 0x2f, (byte) 0x28, (byte) 0xa1,
            (byte) 0x14, (byte) 0x6b, (byte) 0x75, (byte) 0x4d, (byte) 0xb1, (byte) 0x3d,
            (byte) 0x80, (byte) 0x49, (byte) 0x33, (byte) 0xfd, (byte) 0x71, (byte) 0xc0,
            (byte) 0x13, (byte) 0x1e, (byte) 0x16, (byte) 0x69, (byte) 0x80, (byte) 0xa4,
            (byte) 0x9c, (byte) 0xd7, (byte) 0x02, (byte) 0x81, (byte) 0xc1, (byte) 0x00,
            (byte) 0x8c, (byte) 0x33, (byte) 0x2d, (byte) 0xd9, (byte) 0xf3, (byte) 0x42,
            (byte) 0x4d, (byte) 0xca, (byte) 0x5e, (byte) 0x60, (byte) 0x14, (byte) 0x10,
            (byte) 0xf6, (byte) 0xf3, (byte) 0x71, (byte) 0x15, (byte) 0x88, (byte) 0x54,
            (byte) 0x84, (byte) 0x21, (byte) 0x04, (byte) 0xb1, (byte) 0xaf, (byte) 0x02,
            (byte) 0x11, (byte) 0x7f, (byte) 0x42, (byte) 0x3e, (byte) 0x86, (byte) 0xcb,
            (byte) 0x6c, (byte) 0xf5, (byte) 0x57, (byte) 0x78, (byte) 0x4a, (byte) 0x03,
            (byte) 0x9b, (byte) 0x80, (byte) 0xc2, (byte) 0x04, (byte) 0x3a, (byte) 0x6b,
            (byte) 0xb3, (byte) 0x30, (byte) 0x31, (byte) 0x7e, (byte) 0xc3, (byte) 0x89,
            (byte) 0x09, (byte) 0x4e, (byte) 0x86, (byte) 0x59, (byte) 0x41, (byte) 0xb5,
            (byte) 0xae, (byte) 0xd5, (byte) 0xc6, (byte) 0x38, (byte) 0xbc, (byte) 0xd7,
            (byte) 0xd7, (byte) 0x8e, (byte) 0xa3, (byte) 0x1a, (byte) 0xde, (byte) 0x32,
            (byte) 0xad, (byte) 0x8d, (byte) 0x15, (byte) 0x81, (byte) 0xfe, (byte) 0xac,
            (byte) 0xbd, (byte) 0xd0, (byte) 0xca, (byte) 0xbc, (byte) 0xd8, (byte) 0x6a,
            (byte) 0xe1, (byte) 0xfe, (byte) 0xda, (byte) 0xc4, (byte) 0xd8, (byte) 0x62,
            (byte) 0x71, (byte) 0x20, (byte) 0xa3, (byte) 0xd3, (byte) 0x06, (byte) 0x11,
            (byte) 0xa9, (byte) 0x53, (byte) 0x7a, (byte) 0x44, (byte) 0x89, (byte) 0x3d,
            (byte) 0x28, (byte) 0x5e, (byte) 0x7d, (byte) 0xf0, (byte) 0x60, (byte) 0xeb,
            (byte) 0xb5, (byte) 0xdf, (byte) 0xed, (byte) 0x4f, (byte) 0x6d, (byte) 0x05,
            (byte) 0x59, (byte) 0x06, (byte) 0xb0, (byte) 0x62, (byte) 0x50, (byte) 0x1c,
            (byte) 0xb7, (byte) 0x2c, (byte) 0x44, (byte) 0xa4, (byte) 0x49, (byte) 0xf8,
            (byte) 0x4f, (byte) 0x4b, (byte) 0xab, (byte) 0x71, (byte) 0x5b, (byte) 0xcb,
            (byte) 0x31, (byte) 0x10, (byte) 0x41, (byte) 0xe0, (byte) 0x1a, (byte) 0x15,
            (byte) 0xdc, (byte) 0x4c, (byte) 0x5d, (byte) 0x4f, (byte) 0x62, (byte) 0x83,
            (byte) 0xa4, (byte) 0x80, (byte) 0x06, (byte) 0x36, (byte) 0xba, (byte) 0xc9,
            (byte) 0xe2, (byte) 0xa4, (byte) 0x11, (byte) 0x98, (byte) 0x6b, (byte) 0x4c,
            (byte) 0xe9, (byte) 0x90, (byte) 0x55, (byte) 0x18, (byte) 0xde, (byte) 0xe1,
            (byte) 0x42, (byte) 0x38, (byte) 0x28, (byte) 0xa3, (byte) 0x54, (byte) 0x56,
            (byte) 0x31, (byte) 0xaf, (byte) 0x5a, (byte) 0xd6, (byte) 0xf0, (byte) 0x26,
            (byte) 0xe0, (byte) 0x7a, (byte) 0xd9, (byte) 0x6c, (byte) 0x64, (byte) 0xca,
            (byte) 0x5d, (byte) 0x6d, (byte) 0x3d, (byte) 0x9a, (byte) 0xfe, (byte) 0x36,
            (byte) 0x93, (byte) 0x9e, (byte) 0x62, (byte) 0x94, (byte) 0xc6, (byte) 0x07,
            (byte) 0x83, (byte) 0x96, (byte) 0xd6, (byte) 0x27, (byte) 0xa6, (byte) 0xd8
    };
    private static final PrivateKey CLIENT_SUITE_B_RSA3072_KEY =
            loadPrivateKey(""RSA"", CLIENT_SUITE_B_RSA3072_KEY_DATA);

    private static final String CLIENT_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIB9zCCAX4CFDpfSZh3AH07BEfGWuMDa7Ynz6y+MAoGCCqGSM49BAMDMF4xCzAJ\n""
                    + ""BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQKDAdB\n""
                    + ""bmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4XDTIw\n""
                    + ""MDcyMTAyMjk1MFoXDTMwMDUzMDAyMjk1MFowYjELMAkGA1UEBhMCVVMxCzAJBgNV\n""
                    + ""BAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsM\n""
                    + ""BVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MHYwEAYHKoZIzj0CAQYFK4EE\n""
                    + ""ACIDYgAEhxhVJ7dcSqrto0X+dgRxtd8BWG8cWmPjBji3MIxDLfpcMDoIB84ae1Ew\n""
                    + ""gJn4YUYHrWsUDiVNihv8j7a/Ol1qcIY2ybH7tbezefLmagqA4vXEUXZXoUyL4ZNC\n""
                    + ""DWcdw6LrMAoGCCqGSM49BAMDA2cAMGQCMH4aP73HrriRUJRguiuRic+X4Cqj/7YQ\n""
                    + ""ueJmP87KF92/thhoQ9OrRo8uJITPmNDswwIwP2Q1AZCSL4BI9dYrqu07Ar+pSkXE\n""
                    + ""R7oOqGdZR+d/MvXcFSrbIaLKEoHXmQamIHLe\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CLIENT_SUITE_B_ECDSA_CERT =
            loadCertificate(CLIENT_SUITE_B_ECDSA_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_ECC_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x81, (byte) 0xb6, (byte) 0x02, (byte) 0x01, (byte) 0x00,
            (byte) 0x30, (byte) 0x10, (byte) 0x06, (byte) 0x07, (byte) 0x2a, (byte) 0x86,
            (byte) 0x48, (byte) 0xce, (byte) 0x3d, (byte) 0x02, (byte) 0x01, (byte) 0x06,
            (byte) 0x05, (byte) 0x2b, (byte) 0x81, (byte) 0x04, (byte) 0x00, (byte) 0x22,
            (byte) 0x04, (byte) 0x81, (byte) 0x9e, (byte) 0x30, (byte) 0x81, (byte) 0x9b,
            (byte) 0x02, (byte) 0x01, (byte) 0x01, (byte) 0x04, (byte) 0x30, (byte) 0xea,
            (byte) 0x6c, (byte) 0x4b, (byte) 0x6d, (byte) 0x43, (byte) 0xf9, (byte) 0x6c,
            (byte) 0x91, (byte) 0xdc, (byte) 0x2d, (byte) 0x6e, (byte) 0x87, (byte) 0x4f,
            (byte) 0x0a, (byte) 0x0b, (byte) 0x97, (byte) 0x25, (byte) 0x1c, (byte) 0x79,
            (byte) 0xa2, (byte) 0x07, (byte) 0xdc, (byte) 0x94, (byte) 0xc2, (byte) 0xee,
            (byte) 0x64, (byte) 0x51, (byte) 0x6d, (byte) 0x4e, (byte) 0x35, (byte) 0x1c,
            (byte) 0x22, (byte) 0x2f, (byte) 0xc0, (byte) 0xea, (byte) 0x09, (byte) 0x47,
            (byte) 0x3e, (byte) 0xb9, (byte) 0xb6, (byte) 0xb8, (byte) 0x83, (byte) 0x9e,
            (byte) 0xed, (byte) 0x59, (byte) 0xe5, (byte) 0xe7, (byte) 0x0f, (byte) 0xa1,
            (byte) 0x64, (byte) 0x03, (byte) 0x62, (byte) 0x00, (byte) 0x04, (byte) 0x87,
            (byte) 0x18, (byte) 0x55, (byte) 0x27, (byte) 0xb7, (byte) 0x5c, (byte) 0x4a,
            (byte) 0xaa, (byte) 0xed, (byte) 0xa3, (byte) 0x45, (byte) 0xfe, (byte) 0x76,
            (byte) 0x04, (byte) 0x71, (byte) 0xb5, (byte) 0xdf, (byte) 0x01, (byte) 0x58,
            (byte) 0x6f, (byte) 0x1c, (byte) 0x5a, (byte) 0x63, (byte) 0xe3, (byte) 0x06,
            (byte) 0x38, (byte) 0xb7, (byte) 0x30, (byte) 0x8c, (byte) 0x43, (byte) 0x2d,
            (byte) 0xfa, (byte) 0x5c, (byte) 0x30, (byte) 0x3a, (byte) 0x08, (byte) 0x07,
            (byte) 0xce, (byte) 0x1a, (byte) 0x7b, (byte) 0x51, (byte) 0x30, (byte) 0x80,
            (byte) 0x99, (byte) 0xf8, (byte) 0x61, (byte) 0x46, (byte) 0x07, (byte) 0xad,
            (byte) 0x6b, (byte) 0x14, (byte) 0x0e, (byte) 0x25, (byte) 0x4d, (byte) 0x8a,
            (byte) 0x1b, (byte) 0xfc, (byte) 0x8f, (byte) 0xb6, (byte) 0xbf, (byte) 0x3a,
            (byte) 0x5d, (byte) 0x6a, (byte) 0x70, (byte) 0x86, (byte) 0x36, (byte) 0xc9,
            (byte) 0xb1, (byte) 0xfb, (byte) 0xb5, (byte) 0xb7, (byte) 0xb3, (byte) 0x79,
            (byte) 0xf2, (byte) 0xe6, (byte) 0x6a, (byte) 0x0a, (byte) 0x80, (byte) 0xe2,
            (byte) 0xf5, (byte) 0xc4, (byte) 0x51, (byte) 0x76, (byte) 0x57, (byte) 0xa1,
            (byte) 0x4c, (byte) 0x8b, (byte) 0xe1, (byte) 0x93, (byte) 0x42, (byte) 0x0d,
            (byte) 0x67, (byte) 0x1d, (byte) 0xc3, (byte) 0xa2, (byte) 0xeb
    };
    private static final PrivateKey CLIENT_SUITE_B_ECC_KEY =
            loadPrivateKey(""EC"", CLIENT_SUITE_B_ECC_KEY_DATA);

    private static X509Certificate loadCertificate(String blob) {
        try {
            final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            InputStream stream = new ByteArrayInputStream(blob.getBytes(StandardCharsets.UTF_8));

            return (X509Certificate) certFactory.generateCertificate(stream);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PrivateKey loadPrivateKey(String algorithm, byte[] fakeKey) {
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            return kf.generatePrivate(new PKCS8EncodedKeySpec(fakeKey));
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            return null;
        }
    }

    private WifiNetworkSuggestion.Builder createBuilderWithCommonParams() {
        return createBuilderWithCommonParams(false);
    }

    private WifiNetworkSuggestion.Builder createBuilderWithCommonParams(boolean isPasspoint) {
        WifiNetworkSuggestion.Builder builder = new WifiNetworkSuggestion.Builder();
        if (!isPasspoint) {
            builder.setSsid(TEST_SSID);
            builder.setBssid(MacAddress.fromString(TEST_BSSID));
            builder.setIsEnhancedOpen(false);
            builder.setIsHiddenSsid(true);
        }
        builder.setPriority(TEST_PRIORITY);
        builder.setIsAppInteractionRequired(true);
        builder.setIsUserInteractionRequired(true);
        builder.setIsMetered(true);
        builder.setCarrierId(TelephonyManager.UNKNOWN_CARRIER_ID);
        builder.setCredentialSharedWithUser(true);
        builder.setIsInitialAutojoinEnabled(true);
        builder.setUntrusted(false);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            builder.setOemPaid(false);
            builder.setOemPrivate(false);
            builder.setSubscriptionId(TEST_SUB_ID);
        }
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            builder.setPriorityGroup(TEST_PRIORITY_GROUP);
        }
        return builder;
    }

    private void validateCommonParams(WifiNetworkSuggestion suggestion) {
        validateCommonParams(suggestion, false);
    }

    private void validateCommonParams(WifiNetworkSuggestion suggestion, boolean isPasspoint) {
        assertNotNull(suggestion);
        assertNotNull(suggestion.getWifiConfiguration());
        if (!isPasspoint) {
            assertEquals(TEST_SSID, suggestion.getSsid());
            assertEquals(TEST_BSSID, suggestion.getBssid().toString());
            assertFalse(suggestion.isEnhancedOpen());
            assertTrue(suggestion.isHiddenSsid());
        }
        assertEquals(TEST_PRIORITY, suggestion.getPriority());
        assertTrue(suggestion.isAppInteractionRequired());
        assertTrue(suggestion.isUserInteractionRequired());
        assertTrue(suggestion.isMetered());
        assertTrue(suggestion.isCredentialSharedWithUser());
        assertTrue(suggestion.isInitialAutojoinEnabled());
        assertFalse(suggestion.isUntrusted());
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertFalse(suggestion.isOemPaid());
            assertFalse(suggestion.isOemPrivate());
            assertEquals(TEST_SUB_ID, suggestion.getSubscriptionId());
        }
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            assertEquals(TEST_PRIORITY_GROUP, suggestion.getPriorityGroup());
            assertEquals(TelephonyManager.UNKNOWN_CARRIER_ID, suggestion.getCarrierId());
        }
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa2Passphrase"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa2Passphrase() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                .setWpa2Passphrase(TEST_PASSPHRASE)
                .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Passphrase"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Passphrase() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3Passphrase(TEST_PASSPHRASE)
                        .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3SaeH2eOnlyMode"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3SaeH2eOnlyMode() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3Passphrase(TEST_PASSPHRASE)
                        .setIsWpa3SaeH2eOnlyModeEnabled(true)
                        .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWapiPassphrase"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWapiPassphrase() throws Exception {
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWapiPassphrase(TEST_PASSPHRASE)
                        .build();
        validateCommonParams(suggestion);
        assertEquals(TEST_PASSPHRASE, suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertNull(suggestion.getPasspointConfig());
    }

    private static WifiEnterpriseConfig createEnterpriseConfig() {
        WifiEnterpriseConfig config = new WifiEnterpriseConfig();
        config.setEapMethod(AKA);
        return config;
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa2Enterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa2Enterprise() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = createEnterpriseConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa2EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Enterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Enterprise() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = createEnterpriseConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3EnterpriseWithStandardApi"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3EnterpriseWithStandardApi() throws Exception {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiEnterpriseConfig enterpriseConfig = createEnterpriseConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseStandardModeConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3EnterpriseWithSuiteBRsaCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3EnterpriseWithSuiteBRsaCerts() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_RSA3072_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_RSA3072_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_RSA3072_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3EnterpriseWithSuiteBEccCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3EnterpriseWithSuiteBEccCerts() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_ECDSA_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_ECC_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_ECDSA_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Enterprise192bitWithSuiteBRsaCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Enterprise192bitWithSuiteBRsaCerts() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_RSA3072_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_RSA3072_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_RSA3072_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3EnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWpa3Enterprise192bitWithSuiteBEccCerts"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWpa3Enterprise192bitWithSuiteBEccCerts() throws Exception {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TLS);
        enterpriseConfig.setCaCertificate(CA_SUITE_B_ECDSA_CERT);
        enterpriseConfig.setClientKeyEntryWithCertificateChain(CLIENT_SUITE_B_ECC_KEY,
                new X509Certificate[] {CLIENT_SUITE_B_ECDSA_CERT});
        enterpriseConfig.setAltSubjectMatch(""domain.com"");
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWpa3Enterprise192BitModeConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithWapiEnterprise"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithWapiEnterprise() throws Exception {
        WifiEnterpriseConfig enterpriseConfig = new WifiEnterpriseConfig();
        enterpriseConfig.setEapMethod(WAPI_CERT);
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams()
                        .setWapiEnterpriseConfig(enterpriseConfig)
                        .build();
        validateCommonParams(suggestion);
        assertNull(suggestion.getPassphrase());
        assertNotNull(suggestion.getEnterpriseConfig());
        assertEquals(enterpriseConfig.getEapMethod(),
                suggestion.getEnterpriseConfig().getEapMethod());
        assertNull(suggestion.getPasspointConfig());
    }

    /**
     * Helper function for creating a {@link PasspointConfiguration} for testing.
     *
     * @return {@link PasspointConfiguration}
     */
    private static PasspointConfiguration createPasspointConfig() {
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""fqdn"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[] {0x55, 0x66});
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(null);
        cred.setCertCredential(null);
        cred.setSimCredential(new Credential.SimCredential());
        cred.getSimCredential().setImsi(""1234*"");
        cred.getSimCredential().setEapType(23); // EAP-AKA
        cred.setCaCertificate(null);
        cred.setClientCertificateChain(null);
        cred.setClientPrivateKey(null);
        PasspointConfiguration config = new PasspointConfiguration();
        config.setHomeSp(homeSp);
        config.setCredential(cred);
        return config;
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"testBuilderWithPasspointConfig"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"public void testBuilderWithPasspointConfig() throws Exception {
        PasspointConfiguration passpointConfig = createPasspointConfig();
        WifiNetworkSuggestion suggestion =
                createBuilderWithCommonParams(true)
                        .setPasspointConfig(passpointConfig)
                        .build();
        validateCommonParams(suggestion, true);
        assertNull(suggestion.getPassphrase());
        assertNull(suggestion.getEnterpriseConfig());
        assertEquals(passpointConfig.getUniqueId(), suggestion.getPasspointConfig().getUniqueId());
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.testcase.NetworkSuggestionTestCase"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/testcase/NetworkSuggestionTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi.testcase;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS;

import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_OPEN;
import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_PSK;

import android.annotation.NonNull;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.SystemClock;
import android.util.Log;
import android.util.Pair;

import androidx.core.os.BuildCompat;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifi.BaseTestCase;
import com.android.cts.verifier.wifi.CallbackUtils;
import com.android.cts.verifier.wifi.TestUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Test cases for network suggestions {@link WifiNetworkSuggestion} added via
 * {@link WifiManager#addNetworkSuggestions(List)}.
 */
public class NetworkSuggestionTestCase extends BaseTestCase {
    private static final String TAG = ""NetworkSuggestionTestCase"";
    private static final boolean DBG = true;

    private static final int PERIODIC_SCAN_INTERVAL_MS = 10_000;
    private static final int CALLBACK_TIMEOUT_MS = 40_000;
    private static final int CAPABILITIES_CHANGED_FOR_METERED_TIMEOUT_MS = 80_000;

    private final Object mLock = new Object();
    private final ScheduledExecutorService mExecutorService;
    private final WifiNetworkSuggestion.Builder mNetworkSuggestionBuilder =
            new WifiNetworkSuggestion.Builder();

    private ConnectivityManager mConnectivityManager;
    private List<WifiNetworkSuggestion> mNetworkSuggestions;
    private NetworkRequest mNetworkRequest;
    private CallbackUtils.NetworkCallback mNetworkCallback;
    private ConnectionStatusListener mConnectionStatusListener;
    private UserApprovalStatusListener mUserApprovalStatusListener;
    private BroadcastReceiver mBroadcastReceiver;
    private String mFailureReason;
    private int mUserApprovedStatus = WifiManager.STATUS_SUGGESTION_APPROVAL_UNKNOWN;

    private final boolean mSetBssid;
    private final boolean mSetRequiresAppInteraction;
    private final boolean mSimulateConnectionFailure;
    private final boolean mSetMeteredPostConnection;

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction) {
        this(context, setBssid, setRequiresAppInteraction, false);
    }

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction, boolean simulateConnectionFailure) {
        this(context, setBssid, setRequiresAppInteraction, simulateConnectionFailure, false);
    }

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction, boolean simulateConnectionFailure,
            boolean setMeteredPostConnection) {
        super(context);
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        mSetBssid = setBssid;
        mSetRequiresAppInteraction = setRequiresAppInteraction;
        mSimulateConnectionFailure = simulateConnectionFailure;
        mSetMeteredPostConnection = setMeteredPostConnection;
    }

    // Create a network specifier based on the test type.
    private WifiNetworkSuggestion createNetworkSuggestion(@NonNull ScanResult scanResult) {
        mNetworkSuggestionBuilder.setSsid(scanResult.SSID);
        if (mSetBssid) {
            mNetworkSuggestionBuilder.setBssid(MacAddress.fromString(scanResult.BSSID));
        }
        if (mSetRequiresAppInteraction) {
            mNetworkSuggestionBuilder.setIsAppInteractionRequired(true);
        }
        if (mSimulateConnectionFailure) {
            // Use a random password to simulate connection failure.
            if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa2Passphrase(mTestUtils.generateRandomPassphrase());
            } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa3Passphrase(mTestUtils.generateRandomPassphrase());
            }
        } else if (!mPsk.isEmpty()) {
            if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa2Passphrase(mPsk);
            } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa3Passphrase(mPsk);
            }
        }
        mNetworkSuggestionBuilder.setIsMetered(false);
        return mNetworkSuggestionBuilder.build();
    }

    private void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    private static class ConnectionStatusListener implements
            WifiManager.SuggestionConnectionStatusListener {
        private final CountDownLatch mCountDownLatch;
        public WifiNetworkSuggestion wifiNetworkSuggestion = null;
        public int failureReason = -1;

        ConnectionStatusListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onConnectionStatus(
                WifiNetworkSuggestion wifiNetworkSuggestion, int failureReason) {
            this.wifiNetworkSuggestion = wifiNetworkSuggestion;
            this.failureReason = failureReason;
            mCountDownLatch.countDown();
        }
    }

    private class UserApprovalStatusListener implements
            WifiManager.SuggestionUserApprovalStatusListener{
        private final CountDownLatch mCountDownLatch;

        UserApprovalStatusListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }
        @Override
        public void onUserApprovalStatusChange(int status) {
            mUserApprovedStatus = status;
            if (status == WifiManager.STATUS_SUGGESTION_APPROVAL_PENDING
                    || status == WifiManager.STATUS_SUGGESTION_APPROVAL_UNKNOWN) {
                return;
            }
            mCountDownLatch.countDown();
        }
    }

    // TODO(b/150890482): Capabilities changed callback can occur multiple times (for ex: RSSI
    // change) & the sufficiency checks may result in ths change taking longer to take effect.
    // This method accounts for both of these situations.
    private boolean waitForNetworkToBeMetered() throws InterruptedException {
        long startTimeMillis = SystemClock.elapsedRealtime();
        while (SystemClock.elapsedRealtime()
                < startTimeMillis + CAPABILITIES_CHANGED_FOR_METERED_TIMEOUT_MS) {
            // Network marked metered.
            if (!mNetworkCallback.getNetworkCapabilities()
                    .hasCapability(NET_CAPABILITY_NOT_METERED)) {
                return true;
            } else {
                Log.w(TAG, ""Network meteredness check failed. ""
                        + mNetworkCallback.getNetworkCapabilities());
            }
            // Wait for the suggestion to be marked metered now.
            if (!mNetworkCallback.waitForCapabilitiesChanged()) {
                Log.w(TAG, ""Network capabilities did not change"");
            }
        }
        return false;
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (mSimulateConnectionFailure && mPsk.isEmpty()) {
            setFailureReason(mContext.getString(R.string.wifi_status_need_psk));
            return false;
        }
        // Step: Scan and find the network around.
        if (DBG) Log.v(TAG, ""Scan and find the network: "" + mSsid);
        ScanResult testNetwork = mTestUtils.startScanAndFindAnyMatchingNetworkInResults(
                mSsid, mPsk.isEmpty() ? SCAN_RESULT_TYPE_OPEN : SCAN_RESULT_TYPE_PSK);
        if (testNetwork == null) {
            setFailureReason(mContext.getString(R.string.wifi_status_scan_failure));
            return false;
        }

        // Step (Optional): Register for the post connection broadcast.
        final CountDownLatch countDownLatchForPostConnectionBcast = new CountDownLatch(1);
        IntentFilter intentFilter =
                new IntentFilter(WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION);
        // Post connection broadcast receiver.
        mBroadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (DBG) Log.v(TAG, ""Broadcast onReceive "" + intent);
                if (!intent.getAction().equals(
                        WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION)) {
                    return;
                }
                if (DBG) Log.v(TAG, ""Post connection broadcast received"");
                countDownLatchForPostConnectionBcast.countDown();
            }
        };
        // Register the receiver for post connection broadcast.
        mContext.registerReceiver(mBroadcastReceiver, intentFilter);
        final CountDownLatch countDownLatchForConnectionStatusListener = new CountDownLatch(1);
        mConnectionStatusListener =
                new ConnectionStatusListener(countDownLatchForConnectionStatusListener);
        mWifiManager.addSuggestionConnectionStatusListener(
                Executors.newSingleThreadExecutor(), mConnectionStatusListener);

        final CountDownLatch userApprovalCountDownLatch = new CountDownLatch(1);
        if (BuildCompat.isAtLeastS()) {
            mUserApprovalStatusListener = new UserApprovalStatusListener(
                    userApprovalCountDownLatch);
            mWifiManager.addSuggestionUserApprovalStatusListener(
                    Executors.newSingleThreadExecutor(), mUserApprovalStatusListener);

        }

        // Step: Register network callback to wait for connection state.
        mNetworkRequest = new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_WIFI)
                .build();
        mNetworkCallback = new CallbackUtils.NetworkCallback(CALLBACK_TIMEOUT_MS);
        mConnectivityManager.registerNetworkCallback(mNetworkRequest, mNetworkCallback);

        // Step: Create a suggestion for the chosen open network depending on the type of test.
        WifiNetworkSuggestion networkSuggestion = createNetworkSuggestion(testNetwork);
        mNetworkSuggestions = Arrays.asList(networkSuggestion);

        // Step: Add a network suggestions.
        if (DBG) Log.v(TAG, ""Adding suggestion"");
        mListener.onTestMsgReceived(mContext.getString(R.string.wifi_status_suggestion_add));
        if (mWifiManager.addNetworkSuggestions(mNetworkSuggestions)
                != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_add_failure));
            return false;
        }
        // Step: Ask user to approval the suggestion.
        if (BuildCompat.isAtLeastS()) {
            if (mUserApprovedStatus != WifiManager.STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER) {
                mListener.onTestMsgReceived(mContext.getString(
                        R.string.wifi_status_suggestion_wait_for_user_approval));
            }
            if (!userApprovalCountDownLatch.await(CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_user_approval_status_failure));
                return false;
            }
            if (mUserApprovedStatus != WifiManager.STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER) {
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_user_approve_failure));
                return false;
            }
        } else {
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_wait_for_user_approval));
        }

        if (DBG) Log.v(TAG, ""Getting suggestion"");
        List<WifiNetworkSuggestion> retrievedSuggestions = mWifiManager.getNetworkSuggestions();
        if (!Objects.equals(mNetworkSuggestions, retrievedSuggestions)) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_get_failure));
            return false;
        }

        // Step: Trigger scans periodically to trigger network selection quicker.
        if (DBG) Log.v(TAG, ""Triggering scan periodically"");
        mExecutorService.scheduleAtFixedRate(() -> {
            if (!mWifiManager.startScan()) {
                Log.w(TAG, ""Failed to trigger scan"");
            }
        }, 0, PERIODIC_SCAN_INTERVAL_MS, TimeUnit.MILLISECONDS);

        // Step: Wait for connection/unavailable.
        if (!mSimulateConnectionFailure) {
            if (DBG) Log.v(TAG, ""Waiting for connection"");
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_wait_for_connect));
            Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
            if (!cbStatusForAvailable.first) {
                Log.e(TAG, ""Failed to get network available callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_cb_timeout));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_connect));
        } else {
            if (DBG) Log.v(TAG, ""Ensure no connection"");
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_ensure_no_connect));
            Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
            if (cbStatusForAvailable.first) {
                Log.e(TAG, ""Unexpectedly got network available callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_available_error));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_not_connected));
        }

        // Step: Ensure that we connected to the suggested network (optionally, the correct BSSID).
        if (!mSimulateConnectionFailure) {
            if (!mTestUtils.isConnected(""\"""" + testNetwork.SSID + ""\"""",
                    // TODO: This might fail if there are other BSSID's for the same network & the
                    //  device decided to connect/roam to a different BSSID. We don't turn off
                    //  roaming for suggestions.
                    mSetBssid ? testNetwork.BSSID : null)) {
                Log.e(TAG, ""Failed to connected to the network"");
                setFailureReason(
                        mContext.getString(R.string.wifi_status_connected_to_other_network));
                return false;
            }
        }

        // Step (Optional): Ensure we received the post connect broadcast.
        if (mSetRequiresAppInteraction) {
            if (DBG) Log.v(TAG, ""Wait for post connection broadcast"");
            mListener.onTestMsgReceived(
                    mContext.getString(
                            R.string.wifi_status_suggestion_wait_for_post_connect_bcast));
            if (!countDownLatchForPostConnectionBcast.await(
                    CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                Log.e(TAG, ""Failed to get post connection broadcast"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_post_connect_bcast_failure));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_post_connect_bcast));
        }
        // Step (Optional): Ensure we received the connection status listener.
        if (mSimulateConnectionFailure) {
            if (DBG) Log.v(TAG, ""Wait for connection status listener"");
            mListener.onTestMsgReceived(
                    mContext.getString(
                            R.string.wifi_status_suggestion_wait_for_connection_status));
            if (!countDownLatchForConnectionStatusListener.await(
                    CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                Log.e(TAG, ""Failed to receive connection status"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_connection_status_failure));
                return false;
            }
            if (DBG) Log.v(TAG, ""Received connection status"");
            if (!Objects.equals(mConnectionStatusListener.wifiNetworkSuggestion, networkSuggestion)
                    || mConnectionStatusListener.failureReason
                    != WifiManager.STATUS_SUGGESTION_CONNECTION_FAILURE_AUTHENTICATION) {
                Log.e(TAG, ""Received wrong connection status for ""
                        + mConnectionStatusListener.wifiNetworkSuggestion
                        + "" with reason: "" + mConnectionStatusListener.failureReason);
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_connection_status_failure));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_connection_status));
        }

        if (mSetMeteredPostConnection) {
            // ensure that the network is not metered before change.
            if (!mNetworkCallback.getNetworkCapabilities()
                    .hasCapability(NET_CAPABILITY_NOT_METERED)) {
                Log.e(TAG, ""Network meteredness check failed ""
                        + mNetworkCallback.getNetworkCapabilities());
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_metered_check_failed));
                return false;
            }
            if (DBG) Log.v(TAG, ""Mark suggestion metered after connection"");
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_metered_change));
            WifiNetworkSuggestion modifiedSuggestion = mNetworkSuggestionBuilder
                    .setIsMetered(true)
                    .build();
            if (mWifiManager.addNetworkSuggestions(Arrays.asList(modifiedSuggestion))
                    != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
                setFailureReason(mContext.getString(R.string.wifi_status_suggestion_add_failure));
                return false;
            }
            if (!waitForNetworkToBeMetered()) {
                Log.e(TAG, ""Network was not marked metered"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_metered_check_failed));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_metered_changed));
        }

        // Step: Remove the suggestions from the app.
        if (DBG) Log.v(TAG, ""Removing suggestion"");
        mListener.onTestMsgReceived(mContext.getString(R.string.wifi_status_suggestion_remove));
        if (mWifiManager.removeNetworkSuggestions(mNetworkSuggestions)
                != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_remove_failure));
            return false;
        }

        // Step: Ensure we disconnect immediately on suggestion removal.
        if (!mSimulateConnectionFailure) {
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_wait_for_disconnect));
            if (DBG) Log.v(TAG, ""Ensuring we disconnect immediately"");
            boolean cbStatusForLost = mNetworkCallback.waitForLost();
            if (!cbStatusForLost) {
                setFailureReason(
                        mContext.getString(R.string.wifi_status_suggestion_not_disconnected));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_disconnected));
        }

        // All done!
        return true;
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void setUp() {
        super.setUp();
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
    }

    @Override
    protected void tearDown() {
        mExecutorService.shutdownNow();
        if (mBroadcastReceiver != null) {
            mContext.unregisterReceiver(mBroadcastReceiver);
        }
        if (mConnectionStatusListener != null) {
            mWifiManager.removeSuggestionConnectionStatusListener(mConnectionStatusListener);
        }
        mWifiManager.removeNetworkSuggestions(new ArrayList<>());
        super.tearDown();
    }
}"	""	""	"select"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testEqualUniqueId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testEqualUniqueId() throws Exception {
        PasspointConfiguration config1 = createConfig();
        PasspointConfiguration config2 = createConfig();

        assertEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is the same for two instances with different
     * HomeSp node but same FQDN
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdSameHomeSpSameFqdn"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdSameHomeSpSameFqdn() throws Exception {
        PasspointConfiguration config1 = createConfig();
        HomeSp homeSp = config1.getHomeSp();
        homeSp.setMatchAnyOis(new long[]{0x1000, 0x2000});

        // Modify config2's RCOIs and friendly name to a different set of values
        PasspointConfiguration config2 = createConfig();
        homeSp = config2.getHomeSp();

        homeSp.setRoamingConsortiumOis(new long[]{0xaa, 0xbb});
        homeSp.setFriendlyName(""Some other name"");
        homeSp.setOtherHomePartnersList(Arrays.asList(""other-provider1"", ""other-provider2""));
        homeSp.setMatchAllOis(new long[]{0x1000, 0x2000});
        config2.setHomeSp(homeSp);

        assertEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with the same
     * HomeSp node but different FQDN
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentHomeSpDifferentFqdn"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentHomeSpDifferentFqdn() throws Exception {
        PasspointConfiguration config1 = createConfig();

        // Modify config2's FQDN to a different value
        PasspointConfiguration config2 = createConfig();
        HomeSp homeSp = config2.getHomeSp();
        homeSp.setFqdn(""fqdn2.com"");
        config2.setHomeSp(homeSp);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * SIM Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentSimCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentSimCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();

        // Modify config2's realm and SIM credential to a different set of values
        PasspointConfiguration config2 = createConfig();
        Credential credential = config2.getCredential();
        credential.setRealm(""realm2.example.com"");
        credential.getSimCredential().setImsi(""350460*"");
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * Realm in the Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentRealm"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentRealm() throws Exception {
        PasspointConfiguration config1 = createConfig();

        // Modify config2's realm to a different set of values
        PasspointConfiguration config2 = createConfig();
        Credential credential = config2.getCredential();
        credential.setRealm(""realm2.example.com"");
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is the same for two instances with different
     * password and same username in the User Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdSameUserInUserCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdSameUserInUserCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();
        Credential credential = createCredentialWithUserCredential(""user"", ""passwd"");
        config1.setCredential(credential);

        // Modify config2's Passpowrd to a different set of values
        PasspointConfiguration config2 = createConfig();
        credential = createCredentialWithUserCredential(""user"", ""newpasswd"");
        config2.setCredential(credential);

        assertEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * username in the User Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentUserCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentUserCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();
        Credential credential = createCredentialWithUserCredential(""user"", ""passwd"");
        config1.setCredential(credential);

        // Modify config2's username to a different value
        PasspointConfiguration config2 = createConfig();
        credential = createCredentialWithUserCredential(""user2"", ""passwd"");
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the unique identifier generated is different for two instances with different
     * Cert Credential node
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testUniqueIdDifferentCertCredential"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testUniqueIdDifferentCertCredential() throws Exception {
        PasspointConfiguration config1 = createConfig();
        Credential credential = createCredentialWithCertificateCredential(true, true);
        config1.setCredential(credential);

        // Modify config2's cert credential to a different set of values
        PasspointConfiguration config2 = createConfig();
        credential = createCredentialWithCertificateCredential(false, false);
        config2.setCredential(credential);

        assertNotEquals(config1.getUniqueId(), config2.getUniqueId());
    }

    /**
     * Verify that the set and get decorated identity prefix methods work as expected.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.passpoint.cts.PasspointConfigurationTest"	"testSetGetDecoratedIdentityPrefix"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/passpoint/cts/PasspointConfigurationTest.java"	""	"public void testSetGetDecoratedIdentityPrefix() throws Exception {
        PasspointConfiguration config = createConfig();
        assertNull(config.getDecoratedIdentityPrefix());
        config.setDecoratedIdentityPrefix(TEST_DECORATED_IDENTITY_PREFIX);
        assertEquals(TEST_DECORATED_IDENTITY_PREFIX, config.getDecoratedIdentityPrefix());

    }

    /**
     * Helper function for generating user credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithUserCredential(String username, String password) {
        Credential.UserCredential userCred = new Credential.UserCredential();
        userCred.setUsername(username);
        userCred.setPassword(password);
        userCred.setEapType(EAP_TTLS);
        userCred.setNonEapInnerMethod(""MS-CHAP"");
        return createCredential(userCred, null, null, null, null, FakeKeys.CA_CERT0);
    }

    /**
     * Helper function for generating Credential for testing.
     *
     * @param userCred               Instance of UserCredential
     * @param certCred               Instance of CertificateCredential
     * @param simCred                Instance of SimCredential
     * @param clientCertificateChain Chain of client certificates
     * @param clientPrivateKey       Client private key
     * @param caCerts                CA certificates
     * @return {@link Credential}
     */
    private static Credential createCredential(Credential.UserCredential userCred,
            Credential.CertificateCredential certCred,
            Credential.SimCredential simCred,
            X509Certificate[] clientCertificateChain, PrivateKey clientPrivateKey,
            X509Certificate... caCerts) {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(userCred);
        cred.setCertCredential(certCred);
        cred.setSimCredential(simCred);
        cred.setCaCertificate(caCerts[0]);
        cred.setClientCertificateChain(clientCertificateChain);
        cred.setClientPrivateKey(clientPrivateKey);
        return cred;
    }

    /**
     * Helper function for generating certificate credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithCertificateCredential(Boolean useCaCert0,
            Boolean useCert0)
            throws NoSuchAlgorithmException, CertificateEncodingException {
        Credential.CertificateCredential certCred = new Credential.CertificateCredential();
        certCred.setCertType(""x509v3"");
        if (useCert0) {
            certCred.setCertSha256Fingerprint(
                    MessageDigest.getInstance(""SHA-256"").digest(FakeKeys.CLIENT_CERT.getEncoded()));
        } else {
            certCred.setCertSha256Fingerprint(MessageDigest.getInstance(""SHA-256"")
                    .digest(FakeKeys.CLIENT_SUITE_B_RSA3072_CERT.getEncoded()));
        }
        return createCredential(null, certCred, null, new X509Certificate[]{FakeKeys.CLIENT_CERT},
                FakeKeys.RSA_KEY1, useCaCert0 ? FakeKeys.CA_CERT0 : FakeKeys.CA_CERT1);
    }

    /**
     * Helper function for creating a {@link PasspointConfiguration} for testing.
     *
     * @return {@link PasspointConfiguration}
     */
    private static PasspointConfiguration createConfig() {
        PasspointConfiguration config = new PasspointConfiguration();
        config.setHomeSp(createHomeSp());
        config.setCredential(createCredential());
        Map<String, byte[]> trustRootCertList = new HashMap<>();
        trustRootCertList.put(""trustRoot.cert1.com"",
                new byte[CERTIFICATE_FINGERPRINT_BYTES]);
        trustRootCertList.put(""trustRoot.cert2.com"",
                new byte[CERTIFICATE_FINGERPRINT_BYTES]);
        return config;
    }

    /**
     * Utility function for creating a {@link android.net.wifi.hotspot2.pps.HomeSp} for testing.
     *
     * @return {@link android.net.wifi.hotspot2.pps.HomeSp}
     */
    private static HomeSp createHomeSp() {
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""fqdn"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        return homeSp;
    }

    /**
     * Utility function for creating a {@link android.net.wifi.hotspot2.pps.Credential} for
     * testing..
     *
     * @return {@link android.net.wifi.hotspot2.pps.Credential}
     */
    private static Credential createCredential() {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(null);
        cred.setCertCredential(null);
        cred.setSimCredential(new Credential.SimCredential());
        cred.getSimCredential().setImsi(""1234*"");
        cred.getSimCredential().setEapType(EAP_SIM);
        cred.setCaCertificate(null);
        cred.setClientCertificateChain(null);
        cred.setClientPrivateKey(null);
        return cred;
    }
}"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiScoringEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testSetWifiScoringEnabled() throws Exception {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            assertTrue(mWifiManager.setWifiScoringEnabled(true));
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private static abstract class TestConnectedNetworkScorer implements
            WifiManager.WifiConnectedNetworkScorer {
        protected CountDownLatch mCountDownLatch;
        public Integer startSessionId;
        public Integer stopSessionId;
        public WifiManager.ScoreUpdateObserver scoreUpdateObserver;
        public boolean isUserSelected;

        TestConnectedNetworkScorer(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onStop(int sessionId) {
            synchronized (mCountDownLatch) {
                this.stopSessionId = sessionId;
                mCountDownLatch.countDown();
            }
        }

        @Override
        public void onSetScoreUpdateObserver(WifiManager.ScoreUpdateObserver observerImpl) {
            synchronized (mCountDownLatch) {
                this.scoreUpdateObserver = observerImpl;
            }
        }

        public void resetCountDownLatch(CountDownLatch countDownLatch) {
            synchronized (mCountDownLatch) {
                mCountDownLatch = countDownLatch;
            }
        }
    }

    private static class TestConnectedNetworkScorerWithSessionId extends
            TestConnectedNetworkScorer {
        TestConnectedNetworkScorerWithSessionId(CountDownLatch countDownLatch) {
            super(countDownLatch);
            isUserSelected = false;
        }

        @Override
        public void onStart(int sessionId) {
            synchronized (mCountDownLatch) {
                this.startSessionId = sessionId;
                mCountDownLatch.countDown();
            }
        }
    }

    private static class TestConnectedNetworkScorerWithSessionInfo extends
            TestConnectedNetworkScorer {
        TestConnectedNetworkScorerWithSessionInfo(CountDownLatch countDownLatch) {
            super(countDownLatch);
        }

        @Override
        public void onStart(WifiConnectedSessionInfo sessionInfo) {
            synchronized (mCountDownLatch) {
                this.startSessionId = sessionInfo.getSessionId();
                this.isUserSelected = sessionInfo.isUserSelected();
                // Build a WifiConnectedSessionInfo object
                WifiConnectedSessionInfo.Builder sessionBuilder =
                        new WifiConnectedSessionInfo.Builder(startSessionId.intValue())
                                .setUserSelected(isUserSelected);
                sessionBuilder.build();
                mCountDownLatch.countDown();
            }
        }
    }

    /**
     * Tests the
     * {@link android.net.wifi.WifiConnectedNetworkScorer#onStart(WifiConnectedSessionInfo)}.
     */"	""	""	"select"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testConnectedNetworkScorerWithSessionId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testConnectedNetworkScorerWithSessionId() throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        TestConnectedNetworkScorerWithSessionId connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionId(countDownLatchScorer);
        testSetWifiConnectedNetworkScorer(connectedNetworkScorer, countDownLatchScorer);
    }

    /**
     * Note: We could write more interesting test cases (if the device has a mobile connection), but
     * that would make the test flaky. The default network/route selection on the device is not just
     * controlled by the wifi scorer input, but also based on params which are controlled by
     * other parts of the platform (likely in connectivity service) and hence will behave
     * differently on OEM devices.
     */
    private void testSetWifiConnectedNetworkScorer(
            TestConnectedNetworkScorer connectedNetworkScorer,
                    CountDownLatch countDownLatchScorer) throws Exception {
        CountDownLatch countDownLatchUsabilityStats = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestUsabilityStatsListener usabilityStatsListener =
                new TestUsabilityStatsListener(countDownLatchUsabilityStats);
        boolean disconnected = false;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Clear any external scorer already active on the device.
            mWifiManager.clearWifiConnectedNetworkScorer();
            Thread.sleep(500);

            mWifiManager.setWifiConnectedNetworkScorer(
                    Executors.newSingleThreadExecutor(), connectedNetworkScorer);
            // Since we're already connected, wait for onStart to be invoked.
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            assertThat(connectedNetworkScorer.startSessionId).isAtLeast(0);
            assertThat(connectedNetworkScorer.isUserSelected).isEqualTo(false);
            assertThat(connectedNetworkScorer.scoreUpdateObserver).isNotNull();
            WifiManager.ScoreUpdateObserver scoreUpdateObserver =
                    connectedNetworkScorer.scoreUpdateObserver;

            // Now trigger a dummy score update.
            scoreUpdateObserver.notifyScoreUpdate(connectedNetworkScorer.startSessionId, 50);

            // Register the usability listener
            mWifiManager.addOnWifiUsabilityStatsListener(
                    Executors.newSingleThreadExecutor(), usabilityStatsListener);
            // Trigger a usability stats update.
            scoreUpdateObserver.triggerUpdateOfWifiUsabilityStats(
                    connectedNetworkScorer.startSessionId);
            // Ensure that we got the stats update callback.
            assertThat(countDownLatchUsabilityStats.await(TIMEOUT, TimeUnit.MILLISECONDS))
                    .isTrue();
            assertThat(usabilityStatsListener.seqNum).isAtLeast(0);

            // Reset the scorer countdown latch for onStop
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // Notify status change and request a NUD check
                scoreUpdateObserver.notifyStatusUpdate(
                        connectedNetworkScorer.startSessionId, false);
                scoreUpdateObserver.requestNudOperation(connectedNetworkScorer.startSessionId);
                // Blocklist current AP with invalid session Id
                scoreUpdateObserver.blocklistCurrentBssid(-1);
            }
            // Now disconnect from the network.
            mWifiManager.disconnect();
            // Wait for it to be disconnected.
            PollingCheck.check(
                    ""Wifi not disconnected"",
                    TIMEOUT,
                    () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
            disconnected = true;

            // Wait for stop to be invoked and ensure that the session id matches.
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(connectedNetworkScorer.stopSessionId)
                    .isEqualTo(connectedNetworkScorer.startSessionId);
            // Verify that onStart() and onStop() set internal variables correctly.
            connectedNetworkScorer.onStart(
                    new WifiConnectedSessionInfo.Builder(100)
                            .setUserSelected(false)
                            .build());
            assertEquals(100, connectedNetworkScorer.startSessionId.intValue());
            assertEquals(false, connectedNetworkScorer.isUserSelected);
            connectedNetworkScorer.onStop(200);
            assertEquals(200, connectedNetworkScorer.stopSessionId.intValue());
        } finally {
            mWifiManager.removeOnWifiUsabilityStatsListener(usabilityStatsListener);
            mWifiManager.clearWifiConnectedNetworkScorer();

            if (disconnected) {
                mWifiManager.reconnect();
                // Wait for it to be reconnected.
                PollingCheck.check(
                        ""Wifi not reconnected"",
                        WIFI_CONNECT_TIMEOUT_MILLIS,
                        () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiConnectedNetworkScorer} interface.
     *
     * Verifies that the external scorer works even after wifi restart.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"select"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.testcase.DataPathOutOfBandTestCase"	"executeTest"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/testcase/DataPathOutOfBandTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware.testcase;

import static com.android.cts.verifier.wifiaware.CallbackUtils.CALLBACK_TIMEOUT_SEC;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.aware.DiscoverySession;
import android.net.wifi.aware.PeerHandle;
import android.net.wifi.aware.PublishConfig;
import android.net.wifi.aware.PublishDiscoverySession;
import android.net.wifi.aware.SubscribeConfig;
import android.net.wifi.aware.SubscribeDiscoverySession;
import android.net.wifi.aware.WifiAwareManager;
import android.net.wifi.aware.WifiAwareSession;
import android.util.Log;
import android.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifiaware.BaseTestCase;
import com.android.cts.verifier.wifiaware.CallbackUtils;

/**
 *Test case for data-path, out-of-band (OOB) test cases:
 * open/passphrase * responder/initiator.
 *
 * OOB assumes that there's an alternative channel over which to communicate the discovery MAC
 * address of the Aware interface. That channel (e.g. bluetooth or a host test device) is not
 * readily available (don't want to have Aware tests dependent on BLE). Instead will fake the OOB
 * channel using Aware itself: will do normal discovery during which the devices will exchange their
 * MAC addresses, then destroy the discovery sessions and use the MAC addresses to perform OOB data-
 * path requests.
 *
 * Responder test sequence:
 * 1. Attach (with identity listener)
 *    wait for results (session)
 *    wait for identity
 * 2. Publish
 *    wait for results (publish session)
 * 3. Wait for rx message (with MAC)
 * 4. Send message with MAC
 *    wait for success
 * 5. Destroy discovery session
 * 6. Request network (as Responder)
 *    wait for network
 *
 * Initiator test sequence:
 * 1. Attach (with identity listener)
 *    wait for results (session)
 *    wait for identity
 * 2. Subscribe
 *    wait for results (subscribe session)
 * 3. Wait for discovery
 * 4. Send message with MAC
 *    wait for success
 * 5. Wait for rx message (with MAC)
 * 6. Destroy discovery session
 * 7. Sleep for 5 seconds to let Responder time to set up
 * 8. Request network (as Initiator)
 *    wait for network
 */
public class DataPathOutOfBandTestCase extends BaseTestCase {
    private static final String TAG = ""DataPathOutOfBandTestCase"";
    private static final boolean DBG = true;

    private static final int MAC_BYTES_LEN = 6;

    private static final String SERVICE_NAME = ""CtsVerifierTestService"";
    private static final String PASSPHRASE = ""Some super secret password"";
    private static final int MESSAGE_ID = 1234;

    private boolean mIsSecurityOpen;
    private boolean mIsResponder;

    private final Object mLock = new Object();

    private String mFailureReason;
    private WifiAwareSession mWifiAwareSession;
    private DiscoverySession mWifiAwareDiscoverySession;
    private byte[] mDiscoveryMac;

    private static int sSDKLevel = android.os.Build.VERSION.SDK_INT;

    public DataPathOutOfBandTestCase(Context context, boolean isSecurityOpen,
            boolean isResponder) {
        super(context);
        mIsSecurityOpen = isSecurityOpen;
        mIsResponder = isResponder;
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (DBG) {
            Log.d(TAG, ""executeTest: mIsSecurityOpen="" + mIsSecurityOpen + "", mIsResponder=""
                    + mIsResponder);
        }

        // 1. attach (with identity listener)
        CallbackUtils.AttachCb attachCb = new CallbackUtils.AttachCb();
        CallbackUtils.IdentityListenerSingleShot identityL = new CallbackUtils
                .IdentityListenerSingleShot();
        mWifiAwareManager.attach(attachCb, identityL, mHandler);
        Pair<Integer, WifiAwareSession> results = attachCb.waitForAttach();
        switch (results.first) {
            case CallbackUtils.AttachCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_attach_timeout));
                Log.e(TAG, ""executeTest: attach TIMEOUT"");
                return false;
            case CallbackUtils.AttachCb.ON_ATTACH_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_attach_fail));
                Log.e(TAG, ""executeTest: attach ON_ATTACH_FAILED"");
                return false;
        }
        mWifiAwareSession = results.second;
        if (mWifiAwareSession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_attach_fail));
            Log.e(TAG, ""executeTest: attach callback succeeded but null session returned!?"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_attached));
        if (DBG) {
            Log.d(TAG, ""executeTest: attach succeeded"");
        }
        mDiscoveryMac = identityL.waitForMac();
        if (mDiscoveryMac == null) {
            setFailureReason(mContext.getString(R.string.aware_status_identity_fail));
            Log.e(TAG, ""executeTest: identity callback not triggered"");
            return false;
        }
        mListener.onTestMsgReceived(mResources.getString(R.string.aware_status_identity,
                bytesToHex(mDiscoveryMac, ':')));
        if (DBG) {
            Log.d(TAG, ""executeTest: identity received: "" + bytesToHex(mDiscoveryMac, ':'));
        }

        if (mIsResponder) {
            return executeTestResponder();
        } else {
            return executeTestInitiator();
        }
    }

    private void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void tearDown() {
        if (mWifiAwareDiscoverySession != null) {
            mWifiAwareDiscoverySession.close();
            mWifiAwareDiscoverySession = null;
        }
        if (mWifiAwareSession != null) {
            mWifiAwareSession.close();
            mWifiAwareSession = null;
        }
        super.tearDown();
    }

    private boolean executeTestResponder() throws InterruptedException {
        if (DBG) Log.d(TAG, ""executeTestResponder"");
        CallbackUtils.DiscoveryCb discoveryCb = new CallbackUtils.DiscoveryCb();

        // 2. publish
        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                SERVICE_NAME).build();
        if (DBG) Log.d(TAG, ""executeTestResponder: publishConfig="" + publishConfig);
        mWifiAwareSession.publish(publishConfig, discoveryCb, mHandler);

        //    wait for results - publish session
        CallbackUtils.DiscoveryCb.CallbackData callbackData = discoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_PUBLISH_STARTED
                        | CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_publish_timeout));
                Log.e(TAG, ""executeTestResponder: publish TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_publish_failed));
                Log.e(TAG, ""executeTestResponder: publish ON_SESSION_CONFIG_FAILED"");
                return false;
        }
        PublishDiscoverySession discoverySession = callbackData.publishDiscoverySession;
        mWifiAwareDiscoverySession = discoverySession;
        if (discoverySession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_publish_null_session));
            Log.e(TAG, ""executeTestResponder: publish succeeded but null session returned"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_publish_started));
        if (DBG) Log.d(TAG, ""executeTestResponder: publish succeeded"");

        // 3. Wait for rx message (with MAC)
        callbackData = discoveryCb.waitForCallbacks(CallbackUtils.DiscoveryCb.ON_MESSAGE_RECEIVED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_receive_timeout));
                Log.e(TAG, ""executeTestResponder: receive message TIMEOUT"");
                return false;
        }

        if (callbackData.serviceSpecificInfo == null
                || callbackData.serviceSpecificInfo.length != MAC_BYTES_LEN) {
            setFailureReason(mContext.getString(R.string.aware_status_receive_failure));
            Log.e(TAG, ""executeTestResponder: receive message message content mismatch: ""
                    + bytesToHex(callbackData.serviceSpecificInfo, ':'));
            return false;
        }

        PeerHandle peerHandle = callbackData.peerHandle;
        byte[] peerMac = callbackData.serviceSpecificInfo;

        mListener.onTestMsgReceived(mResources.getString(R.string.aware_status_received_mac,
                bytesToHex(peerMac, ':')));
        if (DBG) {
            Log.d(TAG, ""executeTestResponder: received MAC address: "" + bytesToHex(peerMac, ':'));
        }

        // 4. Send message with MAC and wait for success
        discoverySession.sendMessage(peerHandle, MESSAGE_ID, mDiscoveryMac);
        callbackData = discoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_SUCCEEDED
                        | CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_send_timeout));
                Log.e(TAG, ""executeTestResponder: send message TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_send_failed));
                Log.e(TAG, ""executeTestResponder: send message ON_MESSAGE_SEND_FAILED"");
                return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_send_success));
        if (DBG) Log.d(TAG, ""executeTestResponder: send message succeeded"");

        if (callbackData.messageId != MESSAGE_ID) {
            setFailureReason(mContext.getString(R.string.aware_status_send_fail_parameter));
            Log.e(TAG, ""executeTestResponder: send message message ID mismatch: ""
                    + callbackData.messageId);
            return false;
        }

        // 5. Destroy discovery session
        discoverySession.close();
        mWifiAwareDiscoverySession = null;

        // 6. Request network (as Responder) and wait for network
        ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(
                Context.CONNECTIVITY_SERVICE);
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                mIsSecurityOpen ? mWifiAwareSession.createNetworkSpecifierOpen(
                        WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER, peerMac)
                        : mWifiAwareSession.createNetworkSpecifierPassphrase(
                                WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_RESPONDER, peerMac,
                                PASSPHRASE)).build();
        CallbackUtils.NetworkCb networkCb = new CallbackUtils.NetworkCb();
        cm.requestNetwork(nr, networkCb, CALLBACK_TIMEOUT_SEC * 1000);
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_requested));
        if (DBG) Log.d(TAG, ""executeTestResponder: requested network"");
        Pair<Network, NetworkCapabilities> info = networkCb.waitForNetworkCapabilities();

        // 7. Sleep for 5 second for Initiator to get NetworkCapabilities.
        Thread.sleep(5000);
        cm.unregisterNetworkCallback(networkCb);

        if (info == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestResponder: network request rejected - ON_UNAVAILABLE"");
            return false;
        }
        if (sSDKLevel <= android.os.Build.VERSION_CODES.P){
            if (info.second.getNetworkSpecifier() != null) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed_leak));
                Log.e(TAG, ""executeTestSubscriber: network request accepted - but leaks NS!"");
                return false;
            }
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_success));
        if (DBG) Log.d(TAG, ""executeTestResponder: network request granted - AVAILABLE"");

        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_lifecycle_ok));
        return true;
    }

    private boolean executeTestInitiator() throws InterruptedException {
        if (DBG) Log.d(TAG, ""executeTestInitiator"");
        CallbackUtils.DiscoveryCb discoveryCb = new CallbackUtils.DiscoveryCb();

        // 2. Subscribe
        SubscribeConfig subscribeConfig = new SubscribeConfig.Builder().setServiceName(
                SERVICE_NAME).build();
        if (DBG) Log.d(TAG, ""executeTestInitiator: subscribeConfig="" + subscribeConfig);
        mWifiAwareSession.subscribe(subscribeConfig, discoveryCb, mHandler);

        //    wait for results - subscribe session
        CallbackUtils.DiscoveryCb.CallbackData callbackData = discoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_SUBSCRIBE_STARTED
                        | CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_subscribe_timeout));
                Log.e(TAG, ""executeTestInitiator: subscribe TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_subscribe_failed));
                Log.e(TAG, ""executeTestInitiator: subscribe ON_SESSION_CONFIG_FAILED"");
                return false;
        }
        SubscribeDiscoverySession discoverySession = callbackData.subscribeDiscoverySession;
        mWifiAwareDiscoverySession = discoverySession;
        if (discoverySession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_subscribe_null_session));
            Log.e(TAG, ""executeTestInitiator: subscribe succeeded but null session returned"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_subscribe_started));
        if (DBG) Log.d(TAG, ""executeTestInitiator: subscribe succeeded"");

        // 3. Wait for discovery
        callbackData = discoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_SERVICE_DISCOVERED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_discovery_timeout));
                Log.e(TAG, ""executeTestInitiator: waiting for discovery TIMEOUT"");
                return false;
        }
        PeerHandle peerHandle = callbackData.peerHandle;
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_discovery));
        if (DBG) Log.d(TAG, ""executeTestInitiator: discovery"");

        // 4. Send message with MAC and wait for success
        discoverySession.sendMessage(peerHandle, MESSAGE_ID, mDiscoveryMac);
        callbackData = discoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_SUCCEEDED
                        | CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_send_timeout));
                Log.e(TAG, ""executeTestInitiator: send message TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_send_failed));
                Log.e(TAG, ""executeTestInitiator: send message ON_MESSAGE_SEND_FAILED"");
                return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_send_success));
        if (DBG) Log.d(TAG, ""executeTestInitiator: send message succeeded"");

        if (callbackData.messageId != MESSAGE_ID) {
            setFailureReason(mContext.getString(R.string.aware_status_send_fail_parameter));
            Log.e(TAG, ""executeTestInitiator: send message message ID mismatch: ""
                    + callbackData.messageId);
            return false;
        }

        // 5. Wait for rx message (with MAC)
        callbackData = discoveryCb.waitForCallbacks(CallbackUtils.DiscoveryCb.ON_MESSAGE_RECEIVED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_receive_timeout));
                Log.e(TAG, ""executeTestInitiator: receive message TIMEOUT"");
                return false;
        }

        if (callbackData.serviceSpecificInfo == null
                || callbackData.serviceSpecificInfo.length != MAC_BYTES_LEN) {
            setFailureReason(mContext.getString(R.string.aware_status_receive_failure));
            Log.e(TAG, ""executeTestInitiator: receive message message content mismatch: ""
                    + bytesToHex(callbackData.serviceSpecificInfo, ':'));
            return false;
        }

        byte[] peerMac = callbackData.serviceSpecificInfo;

        mListener.onTestMsgReceived(mResources.getString(R.string.aware_status_received_mac,
                bytesToHex(peerMac, ':')));
        if (DBG) {
            Log.d(TAG, ""executeTestInitiator: received MAC address: "" + bytesToHex(peerMac, ':'));
        }

        // 6. Destroy discovery session
        discoverySession.close();
        mWifiAwareDiscoverySession = null;

        // 7. Sleep for 5 seconds to let Responder time to set up
        mListener.onTestMsgReceived(
                mContext.getString(R.string.aware_status_sleeping_wait_for_responder));
        Thread.sleep(5000);

        // 8. Request network (as Initiator) and wait for network
        ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(
                Context.CONNECTIVITY_SERVICE);
        NetworkRequest nr = new NetworkRequest.Builder().addTransportType(
                NetworkCapabilities.TRANSPORT_WIFI_AWARE).setNetworkSpecifier(
                mIsSecurityOpen ? mWifiAwareSession.createNetworkSpecifierOpen(
                        WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR, peerMac)
                        : mWifiAwareSession.createNetworkSpecifierPassphrase(
                                WifiAwareManager.WIFI_AWARE_DATA_PATH_ROLE_INITIATOR, peerMac,
                                PASSPHRASE)).build();
        CallbackUtils.NetworkCb networkCb = new CallbackUtils.NetworkCb();
        cm.requestNetwork(nr, networkCb, CALLBACK_TIMEOUT_SEC * 1000);
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_requested));
        if (DBG) Log.d(TAG, ""executeTestInitiator: requested network"");
        Pair<Network, NetworkCapabilities> info = networkCb.waitForNetworkCapabilities();

        // 9. Sleep for 5 second for Responder to get NetworkCapabilities.
        Thread.sleep(5000);
        cm.unregisterNetworkCallback(networkCb);

        if (info == null) {
            setFailureReason(mContext.getString(R.string.aware_status_network_failed));
            Log.e(TAG, ""executeTestInitiator: network request rejected - ON_UNAVAILABLE"");
            return false;
        }
        if (sSDKLevel <= android.os.Build.VERSION_CODES.P){
            if(info.second.getNetworkSpecifier() != null) {
                setFailureReason(mContext.getString(R.string.aware_status_network_failed_leak));
                Log.e(TAG, ""executeTestSubscriber: network request accepted - but leaks NS!"");
                return false;
            }
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_network_success));
        if (DBG) Log.d(TAG, ""executeTestInitiator: network request granted - AVAILABLE"");

        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_lifecycle_ok));
        return true;
    }
}"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiConfigurationTest"	"testGetAuthTypeFailurePsk8021X"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiConfigurationTest.java"	""	"public void testGetAuthTypeFailurePsk8021X() throws Exception {
        WifiConfiguration configuration = new WifiConfiguration();

        configuration.setSecurityParams(SECURITY_TYPE_PSK);
        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.IEEE8021X);
        try {
            configuration.getAuthType();
            fail(""Expected IllegalStateException exception"");
        } catch(IllegalStateException e) {
            // empty
        }
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"IEEE"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiConfigurationTest"	"testGetAuthTypeFailure8021xEapSae"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiConfigurationTest.java"	""	"public void testGetAuthTypeFailure8021xEapSae() throws Exception {
        WifiConfiguration configuration = new WifiConfiguration();

        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.IEEE8021X);
        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_EAP);
        configuration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.SAE);
        try {
            configuration.getAuthType();
            fail(""Expected IllegalStateException exception"");
        } catch(IllegalStateException e) {
            // empty
        }
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"IEEE"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultProperties() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // this test case should in Wifi environment
        for (ScanResult scanResult : mWifiManager.getScanResults()) {
            assertThat(scanResult.toString()).isNotNull();

            for (InformationElement ie : scanResult.getInformationElements()) {
                testInformationElementCopyConstructor(ie);
                testInformationElementFields(ie);
            }

            assertThat(scanResult.getWifiStandard()).isAnyOf(
                    ScanResult.WIFI_STANDARD_UNKNOWN,
                    ScanResult.WIFI_STANDARD_LEGACY,
                    ScanResult.WIFI_STANDARD_11N,
                    ScanResult.WIFI_STANDARD_11AC,
                    ScanResult.WIFI_STANDARD_11AX
            );

            scanResult.isPasspointNetwork();
        }
    }

    private void testInformationElementCopyConstructor(InformationElement ie) {
        InformationElement copy = new InformationElement(ie);

        assertThat(copy.getId()).isEqualTo(ie.getId());
        assertThat(copy.getIdExt()).isEqualTo(ie.getIdExt());
        assertThat(copy.getBytes()).isEqualTo(ie.getBytes());
    }

    private void testInformationElementFields(InformationElement ie) {
        // id is 1 octet
        int id = ie.getId();
        assertThat(id).isAtLeast(0);
        assertThat(id).isAtMost(255);

        // idExt is 0 or 1 octet
        int idExt = ie.getIdExt();
        assertThat(idExt).isAtLeast(0);
        assertThat(idExt).isAtMost(255);

        ByteBuffer bytes = ie.getBytes();
        assertThat(bytes).isNotNull();
    }

    /* Multiple scans to ensure bssid is updated */
    private void scanAndWait() throws Exception {
        synchronized (mMySync) {
            for (int retry  = 0; retry < SCAN_MAX_RETRY_COUNT; retry++) {
                mMySync.expectedState = STATE_START_SCAN;
                mWifiManager.startScan();
                if (waitForBroadcast(SCAN_WAIT_MSEC, STATE_SCAN_RESULTS_AVAILABLE)) {
                    break;
                }
            }
        }
   }

    @VirtualDeviceNotSupported"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testCanRestoreBackupData"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"public void testCanRestoreBackupData() {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        WifiConfiguration origNetwork = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();

            // Pick a regular saved network to modify (non-enterprise, non-Passpoint)
            origNetwork = mWifiManager.getConfiguredNetworks().stream()
                    .filter(n -> {
                        boolean canOverrideConfig = mContext.checkPermission(
                                android.Manifest.permission.OVERRIDE_WIFI_CONFIG, -1, n.creatorUid)
                                == PERMISSION_GRANTED;
                        return canOverrideConfig && !isEnterprise(n) && !n.isPasspoint();
                    })
                    .findAny()
                    .orElse(null);
            if (origNetwork == null) {
                Log.e(TAG, ""Need a non-enterprise and non-Passpoint network created by an app ""
                        + ""holding OVERRIDE_WIFI_CONFIG permission to fully evaluate the ""
                        + ""functionality"");
            }

            // Retrieve backup data.
            byte[] backupData = mWifiManager.retrieveBackupData();

            if (origNetwork != null) {
                // Modify the metered bit.
                final String origNetworkSsid = origNetwork.SSID;
                WifiConfiguration modNetwork = new WifiConfiguration(origNetwork);
                flipMeteredOverride(modNetwork);
                int networkId = mWifiManager.updateNetwork(modNetwork);
                assertThat(networkId).isEqualTo(origNetwork.networkId);
                assertThat(mWifiManager.getConfiguredNetworks()
                        .stream()
                        .filter(n -> n.SSID.equals(origNetworkSsid))
                        .findAny()
                        .get().meteredOverride)
                        .isNotEqualTo(origNetwork.meteredOverride);
            }

            // Restore the original backup data & ensure that the metered bit is back to orig.
            mWifiManager.restoreBackupData(backupData);

            if (origNetwork != null) {
                final String origNetworkSsid = origNetwork.SSID;
                assertThat(mWifiManager.getConfiguredNetworks()
                        .stream()
                        .filter(n -> n.SSID.equals(origNetworkSsid))
                        .findAny()
                        .get().meteredOverride)
                        .isEqualTo(origNetwork.meteredOverride);
            }
        } finally {
            // Restore the orig network
            if (origNetwork != null) {
                mWifiManager.updateNetwork(origNetwork);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests for {@link WifiManager#retrieveSoftApBackupData()} &
     * {@link WifiManager#restoreSoftApBackupData(byte[])}
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testConnectionWithSsidPattern"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testConnectionWithSsidPattern() throws Exception {
        // Creates a ssid pattern by dropping the last char in the saved network & pass that
        // as a prefix match pattern in the request.
        String ssidUnquoted = WifiInfo.sanitizeSsid(sTestNetwork.SSID);
        assertThat(ssidUnquoted.length()).isAtLeast(2);
        String ssidPrefix = ssidUnquoted.substring(0, ssidUnquoted.length() - 1);
        // Note: The match may return more than 1 network in this case since we use a prefix match,
        // But, we will still ensure that the UI interactions in the test still selects the
        // saved network for connection.
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetwork(sTestNetwork)
                .setSsidPattern(new PatternMatcher(ssidPrefix, PatternMatcher.PATTERN_PREFIX))
                .build();
        testSuccessfulConnectionWithSpecifier(specifier);
    }

    /**
     * Tests the entire connection flow using a specific BSSID in the specifier.
     */"	""	""	"select"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testConnectionWithBssidPattern"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testConnectionWithBssidPattern() throws Exception {
        // Note: The match may return more than 1 network in this case since we use a prefix match,
        // But, we will still ensure that the UI interactions in the test still selects the
        // saved network for connection.
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
                        sTestNetwork)
                        .setBssidPattern(MacAddress.fromString(sTestNetwork.BSSID),
                                MacAddress.fromString(""ff:ff:ff:00:00:00""))
                        .build();
        testSuccessfulConnectionWithSpecifier(specifier);
    }

    /**
     * Tests the entire connection flow using a BSSID pattern in the specifier.
     */"	""	""	"select"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testManageCountryCodeMethodsFailWithoutPermissions"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testManageCountryCodeMethodsFailWithoutPermissions() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            try {
                mWifiManager.setOverrideCountryCode(TEST_COUNTRY_CODE);
                fail(""setOverrideCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }

            try {
                mWifiManager.clearOverrideCountryCode();
                fail(""clearOverrideCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }

            try {
                mWifiManager.setDefaultCountryCode(TEST_COUNTRY_CODE);
                fail(""setDefaultCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }
        });
    }

    /**
     * Tests {@link WifiManager#flushPasspointAnqpCache)} does not crash.
     */"	""	""	"ANQP passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testFlushPasspointAnqpCache"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testFlushPasspointAnqpCache() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.flushPasspointAnqpCache();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isDecoratedIdentitySupported)} does not crash.
     */"	""	""	"ANQP passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"ProvisioningCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_SAP;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_STA;
import static android.net.wifi.WifiConfiguration.INVALID_NETWORK_ID;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_SOFTAP;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_AWARE;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_DIRECT;
import static android.net.wifi.WifiScanner.WIFI_BAND_24_GHZ;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertNotEquals;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TetheringManager;
import android.net.Uri;
import android.net.wifi.CoexUnsafeChannel;
import android.net.wifi.ScanResult;
import android.net.wifi.SoftApCapability;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.SoftApInfo;
import android.net.wifi.WifiAvailableChannel;
import android.net.wifi.WifiClient;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.SubsystemRestartTrackingCallback;
import android.net.wifi.WifiManager.WifiLock;
import android.net.wifi.WifiNetworkConnectionStatistics;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.ConfigParser;
import android.net.wifi.hotspot2.OsuProvider;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.ProvisioningCallback;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;
import android.os.Process;
import android.os.SystemClock;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;
import android.provider.Settings;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.ArraySet;
import android.util.Log;
import android.util.SparseArray;
import android.util.SparseIntArray;

import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;
import com.android.modules.utils.build.SdkLevel;
import com.android.net.module.util.MacAddressUtils;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class WifiManagerTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private TetheringManager mTetheringManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private List<ScanResult> mScanResults = null;
    private NetworkInfo mNetworkInfo =
            new NetworkInfo(ConnectivityManager.TYPE_WIFI, TelephonyManager.NETWORK_TYPE_UNKNOWN,
                    ""wifi"", ""unknown"");
    private final Object mLock = new Object();
    private UiDevice mUiDevice;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;
    private SoftApConfiguration mOriginalSoftApConfig = null;

    // Please refer to WifiManager
    private static final int MIN_RSSI = -100;
    private static final int MAX_RSSI = -55;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_ENABLED = 2;
    private static final int STATE_WIFI_DISABLED = 3;
    private static final int STATE_SCANNING = 4;
    private static final int STATE_SCAN_DONE = 5;

    private static final String TAG = ""WifiManagerTest"";
    private static final String SSID1 = ""\""WifiManagerTest\"""";
    // A full single scan duration is about 6-7 seconds if country code is set
    // to US. If country code is set to world mode (00), we would expect a scan
    // duration of roughly 8 seconds. So we set scan timeout as 9 seconds here.
    private static final int SCAN_TEST_WAIT_DURATION_MS = 9000;
    private static final int TEST_WAIT_DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int DURATION_SETTINGS_TOGGLE = 1_000;
    private static final int WIFI_SCAN_TEST_CACHE_DELAY_MILLIS = 3 * 60 * 1000;

    private static final int ENFORCED_NUM_NETWORK_SUGGESTIONS_PER_APP = 50;

    private static final String TEST_PAC_URL = ""http://www.example.com/proxy.pac"";
    private static final String MANAGED_PROVISIONING_PACKAGE_NAME
            = ""com.android.managedprovisioning"";

    private static final String TEST_SSID_UNQUOTED = ""testSsid1"";
    private static final String TEST_IP_ADDRESS = ""192.168.5.5"";
    private static final String TEST_MAC_ADDRESS = ""aa:bb:cc:dd:ee:ff"";
    private static final MacAddress TEST_MAC = MacAddress.fromString(TEST_MAC_ADDRESS);
    private static final String TEST_PASSPHRASE = ""passphrase"";
    private static final String PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT =
            ""assets/ValidPasspointProfile.base64"";
    private static final String TYPE_WIFI_CONFIG = ""application/x-wifi-config"";
    private static final String TEST_PSK_CAP = ""[RSN-PSK-CCMP]"";
    private static final String TEST_BSSID = ""00:01:02:03:04:05"";
    private static final String TEST_COUNTRY_CODE = ""JP"";
    private static final String TEST_DOM_SUBJECT_MATCH = ""domSubjectMatch"";
    private static final int TEST_SUB_ID = 2;

    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {

                synchronized (mMySync) {
                    if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {
                        mScanResults = mWifiManager.getScanResults();
                    } else {
                        mScanResults = null;
                    }
                    mMySync.expectedState = STATE_SCAN_DONE;
                    mMySync.notifyAll();
                }
            } else if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                int newState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
                        WifiManager.WIFI_STATE_UNKNOWN);
                synchronized (mMySync) {
                    if (newState == WifiManager.WIFI_STATE_ENABLED) {
                        Log.d(TAG, ""*** New WiFi state is ENABLED ***"");
                        mMySync.expectedState = STATE_WIFI_ENABLED;
                        mMySync.notifyAll();
                    } else if (newState == WifiManager.WIFI_STATE_DISABLED) {
                        Log.d(TAG, ""*** New WiFi state is DISABLED ***"");
                        mMySync.expectedState = STATE_WIFI_DISABLED;
                        mMySync.notifyAll();
                    }
                }
            } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mNetworkInfo =
                            (NetworkInfo) intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
                    if (mNetworkInfo.getState() == NetworkInfo.State.CONNECTED)
                        mMySync.notifyAll();
                }
            }
        }
    };
    // Initialize with an invalid status value (0)
    private int mProvisioningStatus = 0;
    // Initialize with an invalid status value (0)
    private int mProvisioningFailureStatus = 0;
    private boolean mProvisioningComplete = false;
    private ProvisioningCallback mProvisioningCallback = new ProvisioningCallback() {
        @Override
        public void onProvisioningFailure(int status) {
            synchronized (mLock) {
                mProvisioningFailureStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningStatus(int status) {
            synchronized (mLock) {
                mProvisioningStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningComplete() {
            mProvisioningComplete = true;
        }
    };
    private int mSubsystemRestartStatus = 0; // 0: nada, 1: restarting, 2: restarted
    private SubsystemRestartTrackingCallback mSubsystemRestartTrackingCallback =
            new SubsystemRestartTrackingCallback() {
                @Override
                public void onSubsystemRestarting() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 1;
                        mLock.notify();
                    }
                }

                @Override
                public void onSubsystemRestarted() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 2;
                        mLock.notify();
                    }
                }
            };
    private static final String TEST_SSID = ""TEST SSID"";
    private static final String TEST_FRIENDLY_NAME = ""Friendly Name"";
    private static final Map<String, String> TEST_FRIENDLY_NAMES =
            new HashMap<String, String>() {
                {
                    put(""en"", TEST_FRIENDLY_NAME);
                    put(""kr"", TEST_FRIENDLY_NAME + 2);
                    put(""jp"", TEST_FRIENDLY_NAME + 3);
                }
            };
    private static final String TEST_SERVICE_DESCRIPTION = ""Dummy Service"";
    private static final Uri TEST_SERVER_URI = Uri.parse(""https://test.com"");
    private static final String TEST_NAI = ""test.access.com"";
    private static final List<Integer> TEST_METHOD_LIST =
            Arrays.asList(1 /* METHOD_SOAP_XML_SPP */);
    private final HandlerThread mHandlerThread = new HandlerThread(""WifiManagerTest"");
    protected final Executor mExecutor;
    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = getContext().getSystemService(ConnectivityManager.class);
        mTetheringManager = getContext().getSystemService(TetheringManager.class);
        assertNotNull(mWifiManager);
        assertNotNull(mTetheringManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", TEST_WAIT_DURATION_MS,
                () -> mWifiManager.isWifiEnabled());

        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        turnScreenOnNoDelay();

        synchronized (mMySync) {
            mMySync.expectedState = STATE_NULL;
        }

        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        assertFalse(""Need at least one saved network"", savedNetworks.isEmpty());

        // Get original config for restore
        mOriginalSoftApConfig = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getSoftApConfiguration);
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
        // restore original softap config
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setSoftApConfiguration(mOriginalSoftApConfig));
        Thread.sleep(TEST_WAIT_DURATION_MS);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            if (mWifiManager.isWifiEnabled() != enable) {
                // the new state is different, we expect it to change
                mMySync.expectedState = STATE_WIFI_CHANGING;
            } else {
                mMySync.expectedState = (enable ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            }
            // now trigger the change using shell commands.
            SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
            waitForExpectedWifiState(enable);
        }
    }

    private void waitForExpectedWifiState(boolean enabled) throws InterruptedException {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS;
            int expected = (enabled ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            while (System.currentTimeMillis() < timeout
                    && mMySync.expectedState != expected) {
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    // Get the current scan status from sticky broadcast.
    private boolean isScanCurrentlyAvailable() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED);
        Intent intent = mContext.registerReceiver(null, intentFilter);
        assertNotNull(intent);
        if (intent.getAction().equals(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED)) {
            return intent.getBooleanExtra(WifiManager.EXTRA_SCAN_AVAILABLE, false);
        }
        return false;
    }

    private void startScan() throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_SCANNING;
            mScanResults = null;
            assertTrue(mWifiManager.startScan());
            long timeout = System.currentTimeMillis() + SCAN_TEST_WAIT_DURATION_MS;
            while (System.currentTimeMillis() < timeout && mMySync.expectedState == STATE_SCANNING)
                mMySync.wait(WAIT_MSEC);
        }
    }

    private void waitForNetworkInfoState(NetworkInfo.State state, int timeoutMillis)
            throws Exception {
        synchronized (mMySync) {
            if (mNetworkInfo.getState() == state) return;
            long timeout = System.currentTimeMillis() + timeoutMillis;
            while (System.currentTimeMillis() < timeout
                    && mNetworkInfo.getState() != state)
                mMySync.wait(WAIT_MSEC);
            assertEquals(state, mNetworkInfo.getState());
        }
    }

    private void waitForConnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.CONNECTED, WIFI_CONNECT_TIMEOUT_MILLIS);
    }

    private void waitForDisconnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.DISCONNECTED, TEST_WAIT_DURATION_MS);
    }

    private void ensureNotNetworkInfoState(NetworkInfo.State state) throws Exception {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS + WAIT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                assertNotEquals(state, mNetworkInfo.getState());
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    private void ensureNotConnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.CONNECTED);
    }

    private void ensureNotDisconnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.DISCONNECTED);
    }

    private boolean existSSID(String ssid) {
        for (final WifiConfiguration w : mWifiManager.getConfiguredNetworks()) {
            if (w.SSID.equals(ssid))
                return true;
        }
        return false;
    }

    private int findConfiguredNetworks(String SSID, List<WifiConfiguration> networks) {
        for (final WifiConfiguration w : networks) {
            if (w.SSID.equals(SSID))
                return networks.indexOf(w);
        }
        return -1;
    }

    /**
     * Test creation of WifiManager Lock.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotWithNullBssidConfig"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartLocalOnlyHotspotWithNullBssidConfig() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        SoftApConfiguration customConfig = new SoftApConfiguration.Builder()
                .setSsid(TEST_SSID_UNQUOTED)
                .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                .build();
        TestExecutor executor = new TestExecutor();
        TestLocalOnlyHotspotCallback callback = new TestLocalOnlyHotspotCallback(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        boolean wifiEnabled = mWifiManager.isWifiEnabled();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            mWifiManager.startLocalOnlyHotspot(customConfig, executor, callback);
            // now wait for callback
            Thread.sleep(TEST_WAIT_DURATION_MS);

            // Verify callback is run on the supplied executor
            assertFalse(callback.onStartedCalled);
            executor.runAll();
            assertTrue(callback.onStartedCalled);

            assertNotNull(callback.reservation);
            SoftApConfiguration softApConfig = callback.reservation.getSoftApConfiguration();
            assertNotNull(softApConfig);
            assertEquals(TEST_SSID_UNQUOTED, softApConfig.getSsid());
            assertEquals(TEST_PASSPHRASE, softApConfig.getPassphrase());
        } finally {
            // clean up
            stopLocalOnlyHotspot(callback, wifiEnabled);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Read the content of the given resource file into a String.
     *
     * @param filename String name of the file
     * @return String
     * @throws IOException
     */
    private String loadResourceFile(String filename) throws IOException {
        InputStream in = getClass().getClassLoader().getResourceAsStream(filename);
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        StringBuilder builder = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            builder.append(line).append(""\n"");
        }
        return builder.toString();
    }

    /**
     * Verify that changing the mac randomization setting of a Passpoint configuration.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testMacRandomizationSettingPasspoint"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testMacRandomizationSettingPasspoint() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT);
        PasspointConfiguration config =
                ConfigParser.parsePasspointConfig(TYPE_WIFI_CONFIG, configStr.getBytes());
        String fqdn = config.getHomeSp().getFqdn();
        String uniqueId = config.getUniqueId();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            mWifiManager.addOrUpdatePasspointConfiguration(config);
            PasspointConfiguration passpointConfig = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", passpointConfig);
            assertTrue(""Mac randomization should be enabled for passpoint networks by default."",
                    passpointConfig.isMacRandomizationEnabled());

            mWifiManager.setMacRandomizationSettingPasspointEnabled(fqdn, false);
            passpointConfig = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", passpointConfig);
            assertFalse(""Mac randomization should be disabled by the API call."",
                    passpointConfig.isMacRandomizationEnabled());
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(fqdn);
            uiAutomation.dropShellPermissionIdentity();
        }
    }
    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_STACK} permission is never held by
     * any package.
     * <p>
     * No apps should <em>ever</em> attempt to acquire this permission, since it would give those
     * apps extremely broad access to connectivity functionality.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWifiStandardsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWifiStandardsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for WiFi standards support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isLegacySupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_LEGACY);
        boolean is11nSupporedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N);
        boolean is11acSupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC);
        boolean is11axSupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX);

        // Check for WiFi standards support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());

        boolean isLegacySupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_LEGACY);
        boolean is11nSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N);
        boolean is11acSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC);
        boolean is11axSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX);

        if (isLegacySupportedDisabled) {
            assertTrue(isLegacySupportedEnabled);
        }

        if (is11nSupportedDisabled) {
            assertTrue(is11nSupporedEnabled);
        }

        if (is11acSupportedDisabled) {
            assertTrue(is11acSupportedEnabled);
        }

        if (is11axSupportedDisabled) {
            assertTrue(is11axSupportedEnabled);
        }
    }

    private static PasspointConfiguration createPasspointConfiguration() {
        PasspointConfiguration config = new PasspointConfiguration();
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""test.com"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        config.setHomeSp(homeSp);
        Credential.SimCredential simCred = new Credential.SimCredential();
        simCred.setImsi(""123456*"");
        simCred.setEapType(23 /* EAP_AKA */);
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setSimCredential(simCred);
        config.setCredential(cred);

        return config;
    }

    /**
     * Tests {@link WifiManager#addOrUpdatePasspointConfiguration(PasspointConfiguration)}
     * adds a Passpoint configuration correctly by getting it once it is added, and comparing it
     * to the local copy of the configuration.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddOrUpdatePasspointConfiguration"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAddOrUpdatePasspointConfiguration() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Create and install a Passpoint configuration
        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);

            // Compare configurations
            List<PasspointConfiguration> configurations = mWifiManager.getPasspointConfigurations();
            assertNotNull(""The installed passpoint profile is missing"", configurations);
            assertEquals(passpointConfiguration, getTargetPasspointConfiguration(configurations,
                    passpointConfiguration.getUniqueId()));
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(passpointConfiguration.getHomeSp().getFqdn());
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setPasspointMeteredOverride(String, int)}
     * adds a Passpoint configuration correctly, check the default metered setting. Use API change
     * metered override, verify Passpoint configuration changes with it.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetPasspointMeteredOverride"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetPasspointMeteredOverride() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Create and install a Passpoint configuration
        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        String fqdn = passpointConfiguration.getHomeSp().getFqdn();
        String uniqueId = passpointConfiguration.getUniqueId();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();

        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);
            PasspointConfiguration saved = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", saved);
            // Verify meter override setting.
            assertEquals(""Metered overrider default should be none"",
                    WifiConfiguration.METERED_OVERRIDE_NONE, saved.getMeteredOverride());
            // Change the meter override setting.
            mWifiManager.setPasspointMeteredOverride(fqdn,
                    WifiConfiguration.METERED_OVERRIDE_METERED);
            // Verify passpoint config change with the new setting.
            saved = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", saved);
            assertEquals(""Metered override should be metered"",
                    WifiConfiguration.METERED_OVERRIDE_METERED, saved.getMeteredOverride());
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(fqdn);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests that
     * {@link WifiManager#startSubscriptionProvisioning(OsuProvider, Executor, ProvisioningCallback)}
     * starts a subscription provisioning, and confirm a status callback invoked once.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartSubscriptionProvisioning"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartSubscriptionProvisioning() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Using Java reflection to construct an OsuProvider instance because its constructor is
        // hidden and not available to apps.
        Class<?> osuProviderClass = Class.forName(""android.net.wifi.hotspot2.OsuProvider"");
        Constructor<?> osuProviderClassConstructor = osuProviderClass.getConstructor(String.class,
                Map.class, String.class, Uri.class, String.class, List.class);

        OsuProvider osuProvider = (OsuProvider) osuProviderClassConstructor.newInstance(TEST_SSID,
                TEST_FRIENDLY_NAMES, TEST_SERVICE_DESCRIPTION, TEST_SERVER_URI, TEST_NAI,
                TEST_METHOD_LIST);

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            synchronized (mLock) {
                // Start a subscription provisioning for a non-existent Passpoint R2 AP
                mWifiManager.startSubscriptionProvisioning(osuProvider, mExecutor,
                        mProvisioningCallback);
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }

        // Expect only a single callback event, connecting. Since AP doesn't exist, it ends here
        assertEquals(ProvisioningCallback.OSU_STATUS_AP_CONNECTING, mProvisioningStatus);
        // No failure callbacks expected
        assertEquals(0, mProvisioningFailureStatus);
        // No completion callback expected
        assertFalse(mProvisioningComplete);
    }

    /**
     * Tests {@link WifiManager#setTdlsEnabled(InetAddress, boolean)} does not crash.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoin"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoin() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, false);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, true);
            }

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Restore auto join state.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.allowAutojoin(network.networkId, network.allowAutojoin);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoinPasspoint(String, boolean)}.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoinPasspoint"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoinPasspoint() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);
            // Turn off auto-join
            mWifiManager.allowAutojoinPasspoint(
                    passpointConfiguration.getHomeSp().getFqdn(), false);
            // Turn on auto-join
            mWifiManager.allowAutojoinPasspoint(
                    passpointConfiguration.getHomeSp().getFqdn(), true);
        } finally {
            mWifiManager.removePasspointConfiguration(passpointConfiguration.getHomeSp().getFqdn());
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoinGlobal(boolean)}.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsMultiStaConcurrencySupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsMultiStaConcurrencySupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // ensure no crash.
        mWifiManager.isStaApConcurrencySupported();
    }

    private PasspointConfiguration getTargetPasspointConfiguration(
            List<PasspointConfiguration> configurationList, String uniqueId) {
        if (configurationList == null || configurationList.isEmpty()) {
            return null;
        }
        for (PasspointConfiguration config : configurationList) {
            if (TextUtils.equals(config.getUniqueId(), uniqueId)) {
                return config;
            }
        }
        return null;
    }

    /**
     * Test that {@link WifiManager#is60GHzBandSupported()} throws UnsupportedOperationException
     * if the release is older than S.
     */
    @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.R)"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testInsecureEnterpriseConfigurationsRejected"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testInsecureEnterpriseConfigurationsRejected() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiConfiguration wifiConfiguration = new WifiConfiguration();
        wifiConfiguration.SSID = SSID1;
        wifiConfiguration.setSecurityParams(WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE);
        wifiConfiguration.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TTLS);
        int networkId = INVALID_NETWORK_ID;

        // These below API's only work with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            // Verify that an insecure network is rejected
            assertEquals(INVALID_NETWORK_ID, mWifiManager.addNetwork(wifiConfiguration));

            // Now configure it correctly with a Root CA cert and domain name
            wifiConfiguration.enterpriseConfig.setCaCertificate(FakeKeys.CA_CERT0);
            wifiConfiguration.enterpriseConfig.setAltSubjectMatch(TEST_DOM_SUBJECT_MATCH);

            // Verify that the network is added
            networkId = mWifiManager.addNetwork(wifiConfiguration);
            assertNotEquals(INVALID_NETWORK_ID, networkId);

            // Verify that the update API accepts configurations configured securely
            wifiConfiguration.networkId = networkId;
            assertEquals(networkId, mWifiManager.updateNetwork(wifiConfiguration));

            // Now clear the security configuration
            wifiConfiguration.enterpriseConfig.setCaCertificate(null);
            wifiConfiguration.enterpriseConfig.setAltSubjectMatch(null);

            // Verify that the update API rejects insecure configurations
            assertEquals(INVALID_NETWORK_ID, mWifiManager.updateNetwork(wifiConfiguration));
        } finally {
            if (networkId != INVALID_NETWORK_ID) {
                // Clean up the previously added network
                mWifiManager.removeNetwork(networkId);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isPasspointTermsAndConditionsSupported)} does not crash.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsPasspointTermsAndConditionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsPasspointTermsAndConditionsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        mWifiManager.isPasspointTermsAndConditionsSupported();
    }

    /**
     * Test that call to {@link WifiManager#setOverrideCountryCode()},
     * {@link WifiManager#clearOverrideCountryCode()} and
     * {@link WifiManager#setDefaultCountryCode()} need privileged permission
     * and the permission is not even given to shell user.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetUsableChannels"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetUsableChannels() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            List<WifiAvailableChannel> usableChannels =
                mWifiManager.getUsableChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            //There must be at least one usable channel in 2.4GHz band
            assertFalse(usableChannels.isEmpty());
        } catch (UnsupportedOperationException ex) {
            //expected if the device does not support this API
        } catch (Exception ex) {
            fail(""getUsableChannels unexpected Exception "" + ex);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Validate that the Passpoint feature is enabled on the device.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testPasspointCapability"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testPasspointCapability() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PackageManager packageManager = mContext.getPackageManager();
        assertTrue(""Passpoint must be supported"",
                packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI_PASSPOINT));
    }

    /**
     * Validate add and remove SuggestionUserApprovalStatusListener. And verify the listener's
     * stickiness.
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testMaxNumberOfNetworkSuggestionsPerApp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testMaxNumberOfNetworkSuggestionsPerApp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        assertTrue(mWifiManager.getMaxNumberOfNetworkSuggestionsPerApp()
                > ENFORCED_NUM_NETWORK_SUGGESTIONS_PER_APP);
    }

    private void verifyRegisterSoftApCallback(TestExecutor executor, TestSoftApCallback callback)
            throws Exception {
        // Register callback to get SoftApCapability
        mWifiManager.registerSoftApCallback(executor, callback);
        PollingCheck.check(
                ""SoftAp register failed!"", 5_000,
                () -> {
                    executor.runAll();
                    // Verify callback is run on the supplied executor and called
                    return callback.getOnStateChangedCalled() &&
                            callback.getOnSoftapInfoChangedCalledCount() > 0 &&
                            callback.getOnSoftApCapabilityChangedCalled() &&
                            callback.getOnConnectedClientCalled();
                });
    }

    private void verifySetGetSoftApConfig(SoftApConfiguration targetConfig) {
        mWifiManager.setSoftApConfiguration(targetConfig);
        // Bssid set dodesn't support for tethered hotspot
        SoftApConfiguration currentConfig = mWifiManager.getSoftApConfiguration();
        compareSoftApConfiguration(targetConfig, currentConfig);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertTrue(currentConfig.isUserConfiguration());
        }
    }

    private void compareSoftApConfiguration(SoftApConfiguration currentConfig,
        SoftApConfiguration testSoftApConfig) {
        assertEquals(currentConfig.getSsid(), testSoftApConfig.getSsid());
        assertEquals(currentConfig.getBssid(), testSoftApConfig.getBssid());
        assertEquals(currentConfig.getSecurityType(), testSoftApConfig.getSecurityType());
        assertEquals(currentConfig.getPassphrase(), testSoftApConfig.getPassphrase());
        assertEquals(currentConfig.isHiddenSsid(), testSoftApConfig.isHiddenSsid());
        assertEquals(currentConfig.getBand(), testSoftApConfig.getBand());
        assertEquals(currentConfig.getChannel(), testSoftApConfig.getChannel());
        assertEquals(currentConfig.getMaxNumberOfClients(),
                testSoftApConfig.getMaxNumberOfClients());
        assertEquals(currentConfig.isAutoShutdownEnabled(),
                testSoftApConfig.isAutoShutdownEnabled());
        assertEquals(currentConfig.getShutdownTimeoutMillis(),
                testSoftApConfig.getShutdownTimeoutMillis());
        assertEquals(currentConfig.isClientControlByUserEnabled(),
                testSoftApConfig.isClientControlByUserEnabled());
        assertEquals(currentConfig.getAllowedClientList(),
                testSoftApConfig.getAllowedClientList());
        assertEquals(currentConfig.getBlockedClientList(),
                testSoftApConfig.getBlockedClientList());
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertEquals(currentConfig.getMacRandomizationSetting(),
                    testSoftApConfig.getMacRandomizationSetting());
            assertEquals(currentConfig.getChannels().toString(),
                    testSoftApConfig.getChannels().toString());
            assertEquals(currentConfig.isBridgedModeOpportunisticShutdownEnabled(),
                    testSoftApConfig.isBridgedModeOpportunisticShutdownEnabled());
            assertEquals(currentConfig.isIeee80211axEnabled(),
                    testSoftApConfig.isIeee80211axEnabled());
        }
    }

    private void turnOffWifiAndTetheredHotspotIfEnabled() throws Exception {
        if (mWifiManager.isWifiEnabled()) {
            Log.d(TAG, ""Turn off WiFi"");
            mWifiManager.setWifiEnabled(false);
            PollingCheck.check(
                ""Wifi turn off failed!"", 2_000,
                () -> mWifiManager.isWifiEnabled() == false);
        }
        if (mWifiManager.isWifiApEnabled()) {
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);
            Log.d(TAG, ""Turn off tethered Hotspot"");
            PollingCheck.check(
                ""SoftAp turn off failed!"", 2_000,
                () -> mWifiManager.isWifiApEnabled() == false);
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);
        }
    }

    private void verifyBridgedModeSoftApCallback(TestExecutor executor,
            TestSoftApCallback callback, boolean shouldFallbackSingleApMode, boolean isEnabled)
            throws Exception {
            // Verify state and info callback value as expected
            PollingCheck.check(
                    ""SoftAp state and info on bridged AP mode are mismatch!!!""
                    + "" shouldFallbackSingleApMode = "" + shouldFallbackSingleApMode
                    + "", isEnabled = ""  + isEnabled, 10_000,
                    () -> {
                        executor.runAll();
                        int expectedState = isEnabled ? WifiManager.WIFI_AP_STATE_ENABLED
                                : WifiManager.WIFI_AP_STATE_DISABLED;
                        int expectedInfoSize = isEnabled
                                ? (shouldFallbackSingleApMode ? 1 : 2) : 0;
                        return expectedState == callback.getCurrentState()
                                && callback.getCurrentSoftApInfoList().size() == expectedInfoSize;
                    });
    }

    private boolean shouldFallbackToSingleAp(int[] bands, SoftApCapability capability) {
        for (int band : bands) {
            if (capability.getSupportedChannelList(band).length == 0) {
                return true;
            }
        }
        return false;
    }

    private SparseIntArray getAvailableBandAndChannelForTesting(SoftApCapability capability) {
        final int[] bands = {SoftApConfiguration.BAND_2GHZ, SoftApConfiguration.BAND_5GHZ,
              SoftApConfiguration.BAND_6GHZ, SoftApConfiguration.BAND_60GHZ};
        SparseIntArray testBandsAndChannels = new SparseIntArray();
        if (!ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            testBandsAndChannels.put(SoftApConfiguration.BAND_2GHZ, 1);
            return testBandsAndChannels;
        }
        for (int band : bands) {
            int[] supportedList = capability.getSupportedChannelList(band);
            if (supportedList.length != 0) {
                testBandsAndChannels.put(band, supportedList[0]);
            }
        }
        return testBandsAndChannels;
    }


    /**
     * Test bridged AP enable succeeful when device supports it.
     * Also verify the callback info update correctly.
     * @throws Exception
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"IEEE"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetGetSoftApConfigurationAndSoftApCapabilityCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetGetSoftApConfigurationAndSoftApCapabilityCallback() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SoftApConfiguration.Builder softApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setAutoShutdownEnabled(true)
                    .setShutdownTimeoutMillis(100000)
                    .setBand(getAvailableBandAndChannelForTesting(
                            callback.getCurrentSoftApCapability()).keyAt(0))
                    .setHiddenSsid(false);

            // Test SoftApConfiguration set and get
            verifySetGetSoftApConfig(softApConfigBuilder.build());

            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                        .areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            //Test MAC_ADDRESS_CUSTOMIZATION supported config
            if (isSupportCustomizedMac) {
                softApConfigBuilder.setBssid(TEST_MAC)
                        .setMacRandomizationSetting(SoftApConfiguration.RANDOMIZATION_NONE);

                // Test SoftApConfiguration set and get
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test CLIENT_FORCE_DISCONNECT supported config.
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_CLIENT_FORCE_DISCONNECT)) {
                softApConfigBuilder.setMaxNumberOfClients(10);
                softApConfigBuilder.setClientControlByUserEnabled(true);
                softApConfigBuilder.setBlockedClientList(new ArrayList<>());
                softApConfigBuilder.setAllowedClientList(new ArrayList<>());
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test SAE config
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(SoftApCapability.SOFTAP_FEATURE_WPA3_SAE)) {
                softApConfigBuilder
                        .setPassphrase(TEST_PASSPHRASE,
                          SoftApConfiguration.SECURITY_TYPE_WPA3_SAE_TRANSITION);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
                softApConfigBuilder
                        .setPassphrase(TEST_PASSPHRASE,
                        SoftApConfiguration.SECURITY_TYPE_WPA3_SAE);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            // Test 11 AX control config.
            if (callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(SoftApCapability.SOFTAP_FEATURE_IEEE80211_AX)) {
                softApConfigBuilder.setIeee80211axEnabled(true);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                softApConfigBuilder.setBridgedModeOpportunisticShutdownEnabled(false);
                verifySetGetSoftApConfig(softApConfigBuilder.build());
            }

        } finally {
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify that startTetheredHotspot with specific channel config.
     * @throws Exception
     */"	""	""	"IEEE"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback()
            throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // check that tethering is supported by the device
            if (!mTetheringManager.isTetheringSupported()) {
                return;
            }
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SparseIntArray testBandsAndChannels = getAvailableBandAndChannelForTesting(
                    callback.getCurrentSoftApCapability());

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertNotEquals(0, testBandsAndChannels.size());
            }
            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            SoftApConfiguration.Builder testSoftApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setChannel(testBandsAndChannels.valueAt(0), testBandsAndChannels.keyAt(0));

            if (isSupportCustomizedMac) testSoftApConfigBuilder.setBssid(TEST_MAC);

            SoftApConfiguration testSoftApConfig = testSoftApConfigBuilder.build();

            mWifiManager.setSoftApConfiguration(testSoftApConfig);

            // start tethering which used to verify startTetheredHotspot
            mTetheringManager.startTethering(ConnectivityManager.TETHERING_WIFI, executor,
                new TetheringManager.StartTetheringCallback() {
                    @Override
                    public void onTetheringFailed(final int result) {
                    }
                });

            // Verify state and info callback value as expected
            PollingCheck.check(
                    ""SoftAp channel and state mismatch!!!"", 10_000,
                    () -> {
                        executor.runAll();
                        int sapChannel = ScanResult.convertFrequencyMhzToChannelIfSupported(
                                callback.getCurrentSoftApInfo().getFrequency());
                        boolean isInfoCallbackSupported =
                                callback.getOnSoftapInfoChangedCalledCount() > 1;
                        if (isInfoCallbackSupported) {
                            return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState()
                                && testBandsAndChannels.valueAt(0) == sapChannel;
                        }
                        return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState();
                    });
            // After Soft Ap enabled, check SoftAp info if it supported
            if (isSupportCustomizedMac && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), TEST_MAC);
            }
            if (PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S)
                    && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertNotEquals(callback.getCurrentSoftApInfo().getWifiStandard(),
                        ScanResult.WIFI_STANDARD_UNKNOWN);
            }

            if (callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertTrue(callback.getCurrentSoftApInfo().getAutoShutdownTimeoutMillis() > 0);
            }
        } finally {
            // stop tethering which used to verify stopSoftAp
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);

            // Verify clean up
            PollingCheck.check(
                    ""Stop Softap failed"", 3_000,
                    () -> {
                        executor.runAll();
                        return WifiManager.WIFI_AP_STATE_DISABLED == callback.getCurrentState() &&
                                0 == callback.getCurrentSoftApInfo().getBandwidth() &&
                                0 == callback.getCurrentSoftApInfo().getFrequency();
                    });
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), null);
                assertEquals(ScanResult.WIFI_STANDARD_UNKNOWN,
                        callback.getCurrentSoftApInfo().getWifiStandard());
            }
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final Object mLock;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;
        public int failureReason = -1;

        TestActionListener(Object lock) {
            mLock = lock;
        }

        @Override
        public void onSuccess() {
            synchronized (mLock) {
                onSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onFailure(int reason) {
            synchronized (mLock) {
                onFailedCalled = true;
                failureReason = reason;
                mLock.notify();
            }
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * int, WifiManager.ActionListener)} or {@link WifiManager#connect(WifiConfiguration,
     * WifiManager.ActionListener)}
     *
     * @param withNetworkId Use networkId for triggering connection, false for using
     *                      WifiConfiguration.
     * @throws Exception
     */
    private void testConnect(boolean withNetworkId) throws Exception {
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)
            savedNetworks = mWifiManager.getConfiguredNetworks();

            // Disable all the saved networks to trigger disconnect & disable autojoin.
            for (WifiConfiguration network : savedNetworks) {
                assertTrue(mWifiManager.disableNetwork(network.networkId));
            }
            waitForDisconnection();

            // Now trigger connection to the last saved network.
            WifiConfiguration savedNetworkToConnect =
                    savedNetworks.get(savedNetworks.size() - 1);
            synchronized (mLock) {
                try {
                    if (withNetworkId) {
                        mWifiManager.connect(savedNetworkToConnect.networkId, actionListener);
                    } else {
                        mWifiManager.connect(savedNetworkToConnect, actionListener);
                    }
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);
            // Wait for connection to complete & ensure we are connected to the saved network.
            waitForConnection();
            if (SdkLevel.isAtLeastS()) {
                assertEquals(savedNetworkToConnect.networkId,
                        mWifiManager.getConnectionInfo().getNetworkId());
            } else {
                // In R, auto-upgraded network IDs may be different from the original saved network.
                // Since we may end up selecting the auto-upgraded network ID for connection and end
                // up connected to the original saved network with a different network ID, we should
                // instead match by SSID.
                assertEquals(savedNetworkToConnect.SSID,
                        mWifiManager.getConnectionInfo().getSSID());
            }
        } finally {
            // Re-enable all saved networks before exiting.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.enableNetwork(network.networkId, true);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#connect(int, WifiManager.ActionListener)} to an existing saved
     * network.
     */"	""	""	"select"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testPnoScan"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testPnoScan() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isPreferredNetworkOffloadSupported()) {
            // skip the test if PNO scanning is not supported
            return;
        }

        // make sure we're connected
        waitForConnection();

        WifiInfo currentNetwork = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConnectionInfo);

        // disable all networks that aren't already disabled
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        Set<Integer> disabledNetworkIds = new HashSet<>();
        for (WifiConfiguration config : savedNetworks) {
            if (config.getNetworkSelectionStatus().getNetworkSelectionDisableReason()
                    == WifiConfiguration.NetworkSelectionStatus.DISABLED_NONE) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.disableNetwork(config.networkId));
                disabledNetworkIds.add(config.networkId);
            }
        }

        try {
            // wait for disconnection from current network
            waitForDisconnection();

            // turn screen off
            turnScreenOffNoDelay();

            // re-enable the current network - this will trigger PNO
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.enableNetwork(currentNetwork.getNetworkId(), false));
            disabledNetworkIds.remove(currentNetwork.getNetworkId());

            // PNO should reconnect us back to the network we disconnected from
            waitForConnection();
        } finally {
            // re-enable disabled networks
            for (int disabledNetworkId : disabledNetworkIds) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.enableNetwork(disabledNetworkId, true));
            }
        }
    }

    /**
     * Tests {@link WifiManager#isTdlsSupported()} does not crash.
     */"	""	""	"select"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.testcase.DiscoveryBaseTestCase"	"IdentityListenerSingleShot"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/testcase/DiscoveryBaseTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware.testcase;

import android.content.Context;
import android.net.MacAddress;
import android.net.wifi.aware.DiscoverySession;
import android.net.wifi.aware.PeerHandle;
import android.net.wifi.aware.PublishConfig;
import android.net.wifi.aware.SubscribeConfig;
import android.net.wifi.aware.WifiAwareSession;
import android.util.Log;
import android.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifiaware.BaseTestCase;
import com.android.cts.verifier.wifiaware.CallbackUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Base test case providing utilities for Discovery:
 *
 * Subscribe test sequence:
 * 1. Attach
 *    wait for results (session)
 * 2. Subscribe
 *    wait for results (subscribe session)
 * 3. Wait for discovery (possibly with ranging)
 * 4. Send message
 *    Wait for success
 *
 * Publish test sequence:
 * 1. Attach
 *    wait for results (session)
 * 2. Publish
 *    wait for results (publish session)
 * 3. Wait for rx message
 */
public abstract class DiscoveryBaseTestCase extends BaseTestCase {
    private static final String TAG = ""DiscoveryBaseTestCase"";
    private static final boolean DBG = true;

    private static final String SERVICE_NAME = ""CtsVerifierTestService"";
    private static final byte[] MATCH_FILTER_BYTES = ""bytes used for matching"".getBytes();
    private static final byte[] PUB_SSI = ""Extra bytes in the publisher discovery"".getBytes();
    private static final byte[] SUB_SSI = ""Arbitrary bytes for the subscribe discovery"".getBytes();
    private static final byte[] MSG_SUB_TO_PUB = ""Let's talk"".getBytes();
    protected static final int MESSAGE_ID = 1234;
    protected static final int LARGE_ENOUGH_DISTANCE = 100000; // 100 meters

    protected boolean mIsUnsolicited;
    protected boolean mIsRangingRequired;

    protected final Object mLock = new Object();

    private String mFailureReason;
    protected WifiAwareSession mWifiAwareSession;
    protected DiscoverySession mWifiAwareDiscoverySession;
    protected CallbackUtils.DiscoveryCb mDiscoveryCb;
    protected PeerHandle mPeerHandle;
    protected MacAddress mMyMacAddress;
    protected MacAddress mPeerMacAddress;

    public DiscoveryBaseTestCase(Context context, boolean isUnsolicited,
            boolean isRangingRequired) {
        super(context);

        mIsUnsolicited = isUnsolicited;
        mIsRangingRequired = isRangingRequired;
    }

    private boolean executeAttach() throws InterruptedException {
        // attach (optionally with an identity listener)
        CallbackUtils.AttachCb attachCb = new CallbackUtils.AttachCb();
        CallbackUtils.IdentityListenerSingleShot identityL = new CallbackUtils
                .IdentityListenerSingleShot();
        if (mIsRangingRequired) {
            mWifiAwareManager.attach(attachCb, identityL, mHandler);
        } else {
            mWifiAwareManager.attach(attachCb, mHandler);
        }
        Pair<Integer, WifiAwareSession> results = attachCb.waitForAttach();
        switch (results.first) {
            case CallbackUtils.AttachCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_attach_timeout));
                Log.e(TAG, ""executeTest: attach TIMEOUT"");
                return false;
            case CallbackUtils.AttachCb.ON_ATTACH_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_attach_fail));
                Log.e(TAG, ""executeTest: attach ON_ATTACH_FAILED"");
                return false;
        }
        mWifiAwareSession = results.second;
        if (mWifiAwareSession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_attach_fail));
            Log.e(TAG, ""executeTest: attach callback succeeded but null session returned!?"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_attached));
        if (DBG) {
            Log.d(TAG, ""executeTest: attach succeeded"");
        }

        // 1.5 optionally wait for identity (necessary in ranging cases)
        if (mIsRangingRequired) {
            byte[] mac = identityL.waitForMac();
            if (mac == null) {
                setFailureReason(mContext.getString(R.string.aware_status_identity_fail));
                Log.e(TAG, ""executeAttach: identity callback not triggered"");
                return false;
            }
            mMyMacAddress = MacAddress.fromBytes(mac);
            mListener.onTestMsgReceived(mResources.getString(R.string.aware_status_identity,
                    mMyMacAddress));
            if (DBG) {
                Log.d(TAG, ""executeAttach: identity received: "" + mMyMacAddress.toString());
            }
        }

        return true;
    }

    protected boolean executeSubscribe() throws InterruptedException {
        // 1. attach
        if (!executeAttach()) {
            return false;
        }

        mDiscoveryCb = new CallbackUtils.DiscoveryCb();

        // 2. subscribe
        List<byte[]> matchFilter = new ArrayList<>();
        matchFilter.add(MATCH_FILTER_BYTES);
        SubscribeConfig.Builder builder = new SubscribeConfig.Builder().setServiceName(
                SERVICE_NAME).setServiceSpecificInfo(SUB_SSI).setMatchFilter(
                matchFilter).setSubscribeType(
                mIsUnsolicited ? SubscribeConfig.SUBSCRIBE_TYPE_PASSIVE
                        : SubscribeConfig.SUBSCRIBE_TYPE_ACTIVE).setTerminateNotificationEnabled(
                true);
        if (mIsRangingRequired) {
            // set up a distance that will always trigger - i.e. that we're already in that range
            builder.setMaxDistanceMm(LARGE_ENOUGH_DISTANCE);
        }
        SubscribeConfig subscribeConfig = builder.build();
        if (DBG) Log.d(TAG, ""executeTestSubscriber: subscribeConfig="" + subscribeConfig);
        mWifiAwareSession.subscribe(subscribeConfig, mDiscoveryCb, mHandler);

        //    wait for results - subscribe session
        CallbackUtils.DiscoveryCb.CallbackData callbackData = mDiscoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_SUBSCRIBE_STARTED
                        | CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_subscribe_timeout));
                Log.e(TAG, ""executeTestSubscriber: subscribe TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_subscribe_failed));
                Log.e(TAG, ""executeTestSubscriber: subscribe ON_SESSION_CONFIG_FAILED"");
                return false;
        }
        mWifiAwareDiscoverySession = callbackData.subscribeDiscoverySession;
        if (mWifiAwareDiscoverySession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_subscribe_null_session));
            Log.e(TAG, ""executeTestSubscriber: subscribe succeeded but null session returned"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_subscribe_started));
        if (DBG) Log.d(TAG, ""executeTestSubscriber: subscribe succeeded"");

        // 3. wait for discovery
        callbackData = mDiscoveryCb.waitForCallbacks(
                mIsRangingRequired ? CallbackUtils.DiscoveryCb.ON_SERVICE_DISCOVERED_WITH_RANGE
                        : CallbackUtils.DiscoveryCb.ON_SERVICE_DISCOVERED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_discovery_timeout));
                Log.e(TAG, ""executeTestSubscriber: waiting for discovery TIMEOUT"");
                return false;
        }
        mPeerHandle = callbackData.peerHandle;
        if (!mIsRangingRequired) {
            mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_discovery));
            if (DBG) Log.d(TAG, ""executeTestSubscriber: discovery"");
        } else {
            if (DBG) {
                Log.d(TAG, ""executeTestSubscriber: discovery with range=""
                        + callbackData.distanceMm);
            }
        }

        //    validate discovery parameters match
        if (mIsRangingRequired) {
            try {
                mPeerMacAddress = MacAddress.fromBytes(callbackData.serviceSpecificInfo);
            } catch (IllegalArgumentException e) {
                setFailureReason(mContext.getString(R.string.aware_status_discovery_fail));
                Log.e(TAG, ""executeTestSubscriber: invalid MAC received in SSI: rx='"" + new String(
                        callbackData.serviceSpecificInfo) + ""'"");
                return false;
            }
            mListener.onTestMsgReceived(
                    mResources.getString(R.string.aware_status_discovery_with_info,
                            mPeerMacAddress));
        } else {
            if (!Arrays.equals(PUB_SSI, callbackData.serviceSpecificInfo)) {
                setFailureReason(mContext.getString(R.string.aware_status_discovery_fail));
                Log.e(TAG, ""executeTestSubscriber: discovery but SSI mismatch: rx='"" + new String(
                        callbackData.serviceSpecificInfo) + ""'"");
                return false;
            }
        }
        if (callbackData.matchFilter.size() != 1 || !Arrays.equals(MATCH_FILTER_BYTES,
                callbackData.matchFilter.get(0))) {
            setFailureReason(mContext.getString(R.string.aware_status_discovery_fail));
            StringBuffer sb = new StringBuffer();
            sb.append(""size="").append(callbackData.matchFilter.size());
            for (byte[] mf: callbackData.matchFilter) {
                sb.append("", e='"").append(new String(mf)).append(""'"");
            }
            Log.e(TAG, ""executeTestSubscriber: discovery but matchFilter mismatch: ""
                    + sb.toString());
            return false;
        }
        if (mPeerHandle == null) {
            setFailureReason(mContext.getString(R.string.aware_status_discovery_fail));
            Log.e(TAG, ""executeTestSubscriber: discovery but null peerHandle"");
            return false;
        }

        // 4. send message & wait for send status
        mWifiAwareDiscoverySession.sendMessage(mPeerHandle, MESSAGE_ID,
                mIsRangingRequired ? mMyMacAddress.toByteArray() : MSG_SUB_TO_PUB);
        callbackData = mDiscoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_SUCCEEDED
                        | CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_send_timeout));
                Log.e(TAG, ""executeTestSubscriber: send message TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_MESSAGE_SEND_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_send_failed));
                Log.e(TAG, ""executeTestSubscriber: send message ON_MESSAGE_SEND_FAILED"");
                return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_send_success));
        if (DBG) Log.d(TAG, ""executeTestSubscriber: send message succeeded"");

        if (callbackData.messageId != MESSAGE_ID) {
            setFailureReason(mContext.getString(R.string.aware_status_send_fail_parameter));
            Log.e(TAG, ""executeTestSubscriber: send message message ID mismatch: ""
                    + callbackData.messageId);
            return false;
        }

        return true;
    }

    protected boolean executePublish() throws InterruptedException {
        // 1. attach
        if (!executeAttach()) {
            return false;
        }

        mDiscoveryCb = new CallbackUtils.DiscoveryCb();

        // 2. publish
        List<byte[]> matchFilter = new ArrayList<>();
        matchFilter.add(MATCH_FILTER_BYTES);
        PublishConfig publishConfig = new PublishConfig.Builder().setServiceName(
                SERVICE_NAME).setServiceSpecificInfo(
                mIsRangingRequired ? mMyMacAddress.toByteArray() : PUB_SSI).setMatchFilter(
                matchFilter).setPublishType(mIsUnsolicited ? PublishConfig.PUBLISH_TYPE_UNSOLICITED
                : PublishConfig.PUBLISH_TYPE_SOLICITED).setTerminateNotificationEnabled(
                true).setRangingEnabled(mIsRangingRequired).build();
        if (DBG) Log.d(TAG, ""executeTestPublisher: publishConfig="" + publishConfig);
        mWifiAwareSession.publish(publishConfig, mDiscoveryCb, mHandler);

        //    wait for results - publish session
        CallbackUtils.DiscoveryCb.CallbackData callbackData = mDiscoveryCb.waitForCallbacks(
                CallbackUtils.DiscoveryCb.ON_PUBLISH_STARTED
                        | CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED);
        switch (callbackData.callback) {
            case CallbackUtils.DiscoveryCb.TIMEOUT:
                setFailureReason(mContext.getString(R.string.aware_status_publish_timeout));
                Log.e(TAG, ""executeTestPublisher: publish TIMEOUT"");
                return false;
            case CallbackUtils.DiscoveryCb.ON_SESSION_CONFIG_FAILED:
                setFailureReason(mContext.getString(R.string.aware_status_publish_failed));
                Log.e(TAG, ""executeTestPublisher: publish ON_SESSION_CONFIG_FAILED"");
                return false;
        }
        mWifiAwareDiscoverySession = callbackData.publishDiscoverySession;
        if (mWifiAwareDiscoverySession == null) {
            setFailureReason(mContext.getString(R.string.aware_status_publish_null_session));
            Log.e(TAG, ""executeTestPublisher: publish succeeded but null session returned"");
            return false;
        }
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_publish_started));
        if (DBG) Log.d(TAG, ""executeTestPublisher: publish succeeded"");

        // 3. wait to receive message: no timeout since this depends on (human) operator starting
        //    the test on the subscriber device.
        callbackData = mDiscoveryCb.waitForCallbacksNoTimeout(
                CallbackUtils.DiscoveryCb.ON_MESSAGE_RECEIVED);
        mPeerHandle = callbackData.peerHandle;
        mListener.onTestMsgReceived(mContext.getString(R.string.aware_status_received));
        if (DBG) Log.d(TAG, ""executeTestPublisher: received message"");

        //    validate that received the expected message
        if (mIsRangingRequired) {
            try {
                mPeerMacAddress = MacAddress.fromBytes(callbackData.serviceSpecificInfo);
            } catch (IllegalArgumentException e) {
                setFailureReason(mContext.getString(R.string.aware_status_discovery_fail));
                Log.e(TAG, ""executeTestSubscriber: invalid MAC received in SSI: rx='"" + new String(
                        callbackData.serviceSpecificInfo) + ""'"");
                return false;
            }
            mListener.onTestMsgReceived(mResources.getString(R.string.aware_status_received_mac,
                    mPeerMacAddress));
        } else {
            if (!Arrays.equals(MSG_SUB_TO_PUB, callbackData.serviceSpecificInfo)) {
                setFailureReason(mContext.getString(R.string.aware_status_receive_failure));
                Log.e(TAG, ""executeTestPublisher: receive message message content mismatch: rx='""
                        + new String(callbackData.serviceSpecificInfo) + ""'"");
                return false;
            }
        }
        if (mPeerHandle == null) {
            setFailureReason(mContext.getString(R.string.aware_status_receive_failure));
            Log.e(TAG, ""executeTestPublisher: received message but peerHandle is null!?"");
            return false;
        }

        return true;
    }

    protected void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void tearDown() {
        if (mWifiAwareDiscoverySession != null) {
            mWifiAwareDiscoverySession.close();
            mWifiAwareDiscoverySession = null;
        }
        if (mWifiAwareSession != null) {
            mWifiAwareSession.close();
            mWifiAwareSession = null;
        }
        super.tearDown();
    }
}"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTest11mcAp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTest11mcAp() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }

        // Scan for IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest.Builder builder = new RangingRequest.Builder();
        builder.addAccessPoint(testAp);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
            assertTrue(RangingRequest.getDefaultRttBurstSize()
                    >= RangingRequest.getMinRttBurstSize());
            assertTrue(RangingRequest.getDefaultRttBurstSize()
                    <= RangingRequest.getMaxRttBurstSize());
        }
        RangingRequest request = builder.build();
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(1, request.getRttResponders().size());
        }

        List<RangingResult> allResults = new ArrayList<>();
        int numFailures = 0;
        int distanceSum = 0;
        int distanceMin = 0;
        int distanceMax = 0;
        int[] statuses = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceStdDevMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] rssis = new int[NUM_OF_RTT_ITERATIONS];
        int[] numAttempted = new int[NUM_OF_RTT_ITERATIONS];
        int[] numSuccessful = new int[NUM_OF_RTT_ITERATIONS];
        long[] timestampsMs = new long[NUM_OF_RTT_ITERATIONS];
        byte[] lastLci = null;
        byte[] lastLcr = null;
        for (int i = 0; i < NUM_OF_RTT_ITERATIONS; ++i) {
            ResultCallback callback = new ResultCallback();
            mWifiRttManager.startRanging(request, mExecutor, callback);
            assertTrue(""Wi-Fi RTT results: no callback on iteration "" + i,
                    callback.waitForCallback());

            List<RangingResult> currentResults = callback.getResults();
            assertNotNull(""Wi-Fi RTT results: null results (onRangingFailure) on iteration "" + i,
                    currentResults);
            assertEquals(""Wi-Fi RTT results: unexpected # of results (expect 1) on iteration "" + i,
                    1, currentResults.size());
            RangingResult result = currentResults.get(0);
            assertEquals(""Wi-Fi RTT results: invalid result (wrong BSSID) entry on iteration "" + i,
                    result.getMacAddress().toString(), testAp.BSSID);
            assertNull(""Wi-Fi RTT results: invalid result (non-null PeerHandle) entry on iteration ""
                    + i, result.getPeerHandle());

            allResults.add(result);
            int status = result.getStatus();
            statuses[i] = status;
            if (status == RangingResult.STATUS_SUCCESS) {
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
                    assertEquals(
                            ""Wi-Fi RTT results: invalid result (wrong rttBurstSize) entry on ""
                                    + ""iteration ""
                                    + i,
                            result.getNumAttemptedMeasurements(),
                            RangingRequest.getMaxRttBurstSize());
                    assertTrue(""Wi-Fi RTT results: should be a 802.11MC measurement"",
                            result.is80211mcMeasurement());
                }
                distanceSum += result.getDistanceMm();
                if (i == 0) {
                    distanceMin = result.getDistanceMm();
                    distanceMax = result.getDistanceMm();
                } else {
                    distanceMin = Math.min(distanceMin, result.getDistanceMm());
                    distanceMax = Math.max(distanceMax, result.getDistanceMm());
                }

                assertTrue(""Wi-Fi RTT results: invalid RSSI on iteration "" + i,
                        result.getRssi() >= MIN_VALID_RSSI);

                distanceMms[i - numFailures] = result.getDistanceMm();
                distanceStdDevMms[i - numFailures] = result.getDistanceStdDevMm();
                rssis[i - numFailures] = result.getRssi();
                numAttempted[i - numFailures] = result.getNumAttemptedMeasurements();
                numSuccessful[i - numFailures] = result.getNumSuccessfulMeasurements();
                timestampsMs[i - numFailures] = result.getRangingTimestampMillis();

                byte[] currentLci = result.getLci();
                byte[] currentLcr = result.getLcr();
                if (i - numFailures > 0) {
                    assertTrue(""Wi-Fi RTT results: invalid result (LCI mismatch) on iteration "" + i,
                            Arrays.equals(currentLci, lastLci));
                    assertTrue(""Wi-Fi RTT results: invalid result (LCR mismatch) on iteration "" + i,
                            Arrays.equals(currentLcr, lastLcr));
                }
                lastLci = currentLci;
                lastLcr = currentLcr;
            } else {
                numFailures++;
            }
            // Sleep a while to avoid stress AP.
            Thread.sleep(intervalMs);
        }

        // Save results to log
        int numGoodResults = NUM_OF_RTT_ITERATIONS - numFailures;
        DeviceReportLog reportLog = new DeviceReportLog(TAG, ""testRangingToTestAp"");
        reportLog.addValues(""status_codes"", statuses, ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_mm"", Arrays.copyOf(distanceMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_stddev_mm"", Arrays.copyOf(distanceStdDevMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""rssi_dbm"", Arrays.copyOf(rssis, numGoodResults), ResultType.NEUTRAL,
                ResultUnit.NONE);
        reportLog.addValues(""num_attempted"", Arrays.copyOf(numAttempted, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""num_successful"", Arrays.copyOf(numSuccessful, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""timestamps"", Arrays.copyOf(timestampsMs, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        // Analyze results
        assertTrue(""Wi-Fi RTT failure rate exceeds threshold: FAIL="" + numFailures + "", ITERATIONS=""
                        + NUM_OF_RTT_ITERATIONS + "", AP RSSI="" + testAp.level
                        + "", AP SSID="" + testAp.SSID,
                numFailures <= NUM_OF_RTT_ITERATIONS * MAX_FAILURE_RATE_PERCENT / 100);
        if (numFailures != NUM_OF_RTT_ITERATIONS) {
            double distanceAvg = (double) distanceSum / (NUM_OF_RTT_ITERATIONS - numFailures);
            assertTrue(""Wi-Fi RTT: Variation (max direction) exceeds threshold, Variation =""
                            + (distanceMax - distanceAvg),
                    (distanceMax - distanceAvg) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
            assertTrue(""Wi-Fi RTT: Variation (min direction) exceeds threshold, Variation =""
                            + (distanceAvg - distanceMin),
                    (distanceAvg - distanceMin) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
            for (int i = 0; i < numGoodResults; ++i) {
                assertNotSame(""Number of attempted measurements is 0"", 0, numAttempted[i]);
                assertNotSame(""Number of successful measurements is 0"", 0, numSuccessful[i]);
            }
        }
    }

    /**
     * Validate that when a request contains more range operations than allowed (by API) that we
     * get an exception.
     */"	""	""	"IEEE"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRequestTooLarge"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRequestTooLarge() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        RangingRequest.Builder builder = new RangingRequest.Builder();
        List<ScanResult> scanResults = new ArrayList<>();
        for (int i = 0; i < RangingRequest.getMaxPeers() - 2; ++i) {
            scanResults.add(testAp);
        }
        builder.addAccessPoints(scanResults);

        ScanResult testApNon80211mc = null;
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            testApNon80211mc = scanForTestNon11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        }
        if (testApNon80211mc == null) {
            builder.addAccessPoints(List.of(testAp, testAp, testAp));
        } else {
            builder.addNon80211mcCapableAccessPoints(List.of(testApNon80211mc, testApNon80211mc,
                    testApNon80211mc));
        }

        try {
            mWifiRttManager.startRanging(builder.build(), mExecutor, new ResultCallback());
        } catch (IllegalArgumentException e) {
            return;
        }

        fail(""Did not receive expected IllegalArgumentException when tried to range to too ""
                + ""many peers"");
    }

    /**
     * Verify ResponderLocation API
     */"	""	""	"IEEE"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTestApWithResponderLocation"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTestApWithResponderLocation() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }
        // Scan for IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest request = new RangingRequest.Builder().addAccessPoint(testAp).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback! "",
                callback.waitForCallback());

        RangingResult result = callback.getResults().get(0);
        assertEquals(""Ranging request not success"",
                result.getStatus(), RangingResult.STATUS_SUCCESS);
        ResponderLocation responderLocation = result.getUnverifiedResponderLocation();
        if (responderLocation == null) {
            return;
        }
        assertTrue(""ResponderLocation is not valid"", responderLocation.isLciSubelementValid());

        // Check LCI related APIs
        int exceptionCount = 0;
        int apiCount = 0;
        try {
            apiCount++;
            responderLocation.getLatitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLatitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLongitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLongitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitudeType();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getDatum();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getRegisteredLocationAgreementIndication();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLciVersion();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            assertNotNull(responderLocation.toLocation());
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        // If LCI is not valid, all APIs should throw exception, otherwise no exception.
        assertEquals(""Exception number should equal to API number"",
                responderLocation.isLciSubelementValid()? 0 : apiCount, exceptionCount);

        // Verify ZaxisSubelement APIs
        apiCount = 0;
        exceptionCount = 0;

        try {
            apiCount++;
            responderLocation.getExpectedToMove();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getFloorNumber();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getHeightAboveFloorMeters();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getHeightAboveFloorUncertaintyMeters();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        // If Zaxis is not valid, all APIs should throw exception, otherwise no exception.
        assertEquals(""Exception number should equal to API number"",
                responderLocation.isZaxisSubelementValid() ? 0 : apiCount, exceptionCount);
        // Verify civic location
        if (responderLocation.toCivicLocationAddress() == null) {
            assertNull(responderLocation.toCivicLocationSparseArray());
        } else {
            assertNotNull(responderLocation.toCivicLocationSparseArray());
        }
        // Verify map image
        if (responderLocation.getMapImageUri() == null) {
            assertNull(responderLocation.getMapImageMimeType());
        } else {
            assertNotNull(responderLocation.getMapImageMimeType());
        }
        boolean extraInfoOnAssociationIndication =
                responderLocation.getExtraInfoOnAssociationIndication();
        assertNotNull(""ColocatedBSSID list should be nonNull"",
                responderLocation.getColocatedBssids());
    }

    /**
     * Verify ranging request with aware peer Mac address and peer handle.
     */"	""	""	"IEEE"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testAwareRttWithPeerHandle"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testAwareRttWithPeerHandle() throws InterruptedException {
        if (!(shouldTestWifiRtt(getContext()) && shouldTestWifiAware(getContext()))) {
            return;
        }
        PeerHandle peerHandle = mock(PeerHandle.class);
        RangingRequest request = new RangingRequest.Builder()
                .addWifiAwarePeer(peerHandle).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback"",
                callback.waitForCallback());
        List<RangingResult> rangingResults = callback.getResults();
        assertNotNull(""Wi-Fi RTT results: null results"", rangingResults);
        assertEquals(""Invalid peerHandle should return 0 result"", 0, rangingResults.size());
    }

    /**
     * Test Wi-Fi One-sided RTT ranging operation:
     * - Scan for visible APs for the test AP (which do not support IEEE 802.11mc) and are operating
     * - in the 5GHz band.
     * - Perform N (constant) RTT operations
     * - Remove outliers while insuring greater than 50% of the results still remain
     * - Validate:
     *   - Failure ratio < threshold (constant)
     *   - Result margin < threshold (constant)
     */"	""	""	"IEEE"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTestNon11mcAp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTestNon11mcAp() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())
                || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }

        // Scan for Non-IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTestNon11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which are Non-IEEE 802.11mc - please verify that""
                        + "" your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest.Builder builder = new RangingRequest.Builder();
        builder.addNon80211mcCapableAccessPoint(testAp);
        builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
        RangingRequest request = builder.build();

        List<RangingResult> allResults = new ArrayList<>();
        int numFailures = 0;
        int distanceSum = 0;
        int distanceMin = 0;
        int distanceMax = 0;
        int[] statuses = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceMms = new int[NUM_OF_RTT_ITERATIONS];
        boolean[] distanceInclusionMap = new boolean[NUM_OF_RTT_ITERATIONS];
        int[] distanceStdDevMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] rssis = new int[NUM_OF_RTT_ITERATIONS];
        int[] numAttempted = new int[NUM_OF_RTT_ITERATIONS];
        int[] numSuccessful = new int[NUM_OF_RTT_ITERATIONS];
        long[] timestampsMs = new long[NUM_OF_RTT_ITERATIONS];
        byte[] lastLci = null;
        byte[] lastLcr = null;
        for (int i = 0; i < NUM_OF_RTT_ITERATIONS; ++i) {
            ResultCallback callback = new ResultCallback();
            mWifiRttManager.startRanging(request, mExecutor, callback);
            assertTrue(""Wi-Fi RTT results: no callback on iteration "" + i,
                    callback.waitForCallback());

            List<RangingResult> currentResults = callback.getResults();
            assertNotNull(
                    ""Wi-Fi RTT results: null results (onRangingFailure) on iteration "" + i,
                    currentResults);
            assertEquals(
                    ""Wi-Fi RTT results: unexpected # of results (expect 1) on iteration "" + i,
                    1, currentResults.size());
            RangingResult result = currentResults.get(0);
            assertEquals(
                    ""Wi-Fi RTT results: invalid result (wrong BSSID) entry on iteration "" + i,
                    result.getMacAddress().toString(), testAp.BSSID);

            assertNull(
                    ""Wi-Fi RTT results: invalid result (non-null PeerHandle) entry on iteration ""
                            + i, result.getPeerHandle());

            allResults.add(result);
            int status = result.getStatus();
            statuses[i] = status;
            if (status == RangingResult.STATUS_SUCCESS) {
                assertFalse(""Wi-Fi RTT results: should not be a 802.11MC measurement"",
                        result.is80211mcMeasurement());
                distanceSum += result.getDistanceMm();

                assertTrue(""Wi-Fi RTT results: invalid RSSI on iteration "" + i,
                        result.getRssi() >= MIN_VALID_RSSI);

                distanceMms[i - numFailures] = result.getDistanceMm();
                distanceStdDevMms[i - numFailures] = result.getDistanceStdDevMm();
                rssis[i - numFailures] = result.getRssi();
                // For one-sided RTT the number of packets attempted in a burst is not available,
                // So we set the result to be the same as used in the request.
                numAttempted[i - numFailures] = request.getRttBurstSize();
                numSuccessful[i - numFailures] = result.getNumSuccessfulMeasurements();
                timestampsMs[i - numFailures] = result.getRangingTimestampMillis();

                byte[] currentLci = result.getLci();
                byte[] currentLcr = result.getLcr();
                if (i - numFailures > 0) {
                    assertTrue(""Wi-Fi RTT results: invalid result (LCI mismatch) on iteration "" + i,
                            Arrays.equals(currentLci, lastLci));
                    assertTrue(""Wi-Fi RTT results: invalid result (LCR mismatch) on iteration "" + i,
                            Arrays.equals(currentLcr, lastLcr));
                }
                lastLci = currentLci;
                lastLcr = currentLcr;
            } else {
                numFailures++;
            }
            // Sleep a while to avoid stress AP.
            Thread.sleep(intervalMs);
        }
        // Save results to log
        int numGoodResults = NUM_OF_RTT_ITERATIONS - numFailures;
        DeviceReportLog reportLog = new DeviceReportLog(TAG, ""testRangingToTestAp"");
        reportLog.addValues(""status_codes"", statuses, ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_mm"", Arrays.copyOf(distanceMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_stddev_mm"",
                Arrays.copyOf(distanceStdDevMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""rssi_dbm"", Arrays.copyOf(rssis, numGoodResults),
                ResultType.NEUTRAL,
                ResultUnit.NONE);
        reportLog.addValues(""num_attempted"", Arrays.copyOf(numAttempted, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""num_successful"", Arrays.copyOf(numSuccessful, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""timestamps"", Arrays.copyOf(timestampsMs, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        /** TODO(b/192909380): enable the performance verification after device fix.
            // Analyze results
            assertTrue(""Wi-Fi RTT failure rate exceeds threshold: FAIL="" + numFailures
                            + "", ITERATIONS=""
                            + NUM_OF_RTT_ITERATIONS + "", AP RSSI="" + testAp.level
                            + "", AP SSID="" + testAp.SSID,
                    numFailures <= NUM_OF_RTT_ITERATIONS * MAX_NON11MC_FAILURE_RATE_PERCENT / 100);

            if (numFailures != NUM_OF_RTT_ITERATIONS) {
                // Calculate an initial average using all measurements to determine distance outliers
                double distanceAvg = (double) distanceSum / (NUM_OF_RTT_ITERATIONS - numFailures);
                // Now figure out the distance outliers and mark them in the distance inclusion map
                int validDistances = 0;
                for (int i = 0; i < (NUM_OF_RTT_ITERATIONS - numFailures); i++) {
                    if (distanceMms[i] - MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM < distanceAvg) {
                        // Distances that are in range for the distribution are included in the map
                        distanceInclusionMap[i] = true;
                        validDistances++;
                    } else {
                        // Distances that are out of range for the distribution are excluded in the map
                        distanceInclusionMap[i] = false;
                    }
                }

                assertTrue(""After fails+outlier removal greater that 50% distances must remain: "" +
                        NUM_OF_RTT_ITERATIONS / 2, validDistances > NUM_OF_RTT_ITERATIONS / 2);

                // Remove the distance outliers and find the new average, min and max.
                distanceSum = 0;
                distanceMax = Integer.MIN_VALUE;
                distanceMin = Integer.MAX_VALUE;
                for (int i = 0; i < (NUM_OF_RTT_ITERATIONS - numFailures); i++) {
                    if (distanceInclusionMap[i]) {
                        distanceSum += distanceMms[i];
                        distanceMin = Math.min(distanceMin, distanceMms[i]);
                        distanceMax = Math.max(distanceMax, distanceMms[i]);
                    }
                }
                distanceAvg = (double) distanceSum / validDistances;
                assertTrue(""Wi-Fi RTT: Variation (max direction) exceeds threshold, Variation =""
                                + (distanceMax - distanceAvg),
                        (distanceMax - distanceAvg) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
                assertTrue(""Wi-Fi RTT: Variation (min direction) exceeds threshold, Variation =""
                                + (distanceAvg - distanceMin),
                        (distanceAvg - distanceMin) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
                for (int i = 0; i < numGoodResults; ++i) {
                    assertNotSame(""Number of attempted measurements is 0"", 0, numAttempted[i]);
                    assertNotSame(""Number of successful measurements is 0"", 0, numSuccessful[i]);
                }
         */
    }
}"	""	""	"IEEE"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.PpsMoParserTest"	"getRoamingConsortiumOis"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/PpsMoParserTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.omadm.PpsMoParser;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.test.AndroidTestCase;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * CTS tests for PPS MO (PerProviderSubscription Management Object) XML string parsing API.
 */
public class PpsMoParserTest extends WifiJUnit3TestBase {
    private static final String PPS_MO_XML_FILE = ""assets/PerProviderSubscription.xml"";

    /**
     * Read the content of the given resource file into a String.
     *
     * @param filename String name of the file
     * @return String
     * @throws IOException
     */
    private String loadResourceFile(String filename) throws IOException {
        InputStream in = getClass().getClassLoader().getResourceAsStream(filename);
        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
        StringBuilder builder = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            builder.append(line).append(""\n"");
        }
        return builder.toString();
    }

    /**
     * Generate a {@link PasspointConfiguration} that matches the configuration specified in the
     * XML file {@link #PPS_MO_XML_FILE}.
     *
     * @return {@link PasspointConfiguration}
     */
    private PasspointConfiguration generateConfigurationFromPPSMOTree() throws Exception {
        DateFormat format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss'Z'"");
        byte[] certFingerprint = new byte[32];
        Arrays.fill(certFingerprint, (byte) 0x1f);

        PasspointConfiguration config = new PasspointConfiguration();

        // HomeSP configuration.
        HomeSp homeSp = new HomeSp();
        homeSp.setFriendlyName(""Century House"");
        assertEquals(""Century House"", homeSp.getFriendlyName());
        homeSp.setFqdn(""mi6.co.uk"");
        assertEquals(""mi6.co.uk"", homeSp.getFqdn());
        homeSp.setRoamingConsortiumOis(new long[] {0x112233L, 0x445566L});
        assertTrue(Arrays.equals(new long[] {0x112233L, 0x445566L},
                homeSp.getRoamingConsortiumOis()));
        config.setHomeSp(homeSp);
        assertEquals(homeSp, config.getHomeSp());

        // Credential configuration.
        Credential credential = new Credential();
        credential.setRealm(""shaken.stirred.com"");
        assertEquals(""shaken.stirred.com"", credential.getRealm());
        Credential.UserCredential userCredential = new Credential.UserCredential();
        userCredential.setUsername(""james"");
        assertEquals(""james"", userCredential.getUsername());
        userCredential.setPassword(""Ym9uZDAwNw=="");
        assertEquals(""Ym9uZDAwNw=="", userCredential.getPassword());
        userCredential.setEapType(21);
        assertEquals(21, userCredential.getEapType());
        userCredential.setNonEapInnerMethod(""MS-CHAP-V2"");
        assertEquals(""MS-CHAP-V2"", userCredential.getNonEapInnerMethod());
        credential.setUserCredential(userCredential);
        assertEquals(userCredential, credential.getUserCredential());
        Credential.CertificateCredential certCredential = new Credential.CertificateCredential();
        certCredential.setCertType(""x509v3"");
        assertEquals(""x509v3"", certCredential.getCertType());
        certCredential.setCertSha256Fingerprint(certFingerprint);
        assertTrue(Arrays.equals(certFingerprint, certCredential.getCertSha256Fingerprint()));
        credential.setCertCredential(certCredential);
        assertEquals(certCredential, credential.getCertCredential());
        Credential.SimCredential simCredential = new Credential.SimCredential();
        simCredential.setImsi(""imsi"");
        assertEquals(""imsi"", simCredential.getImsi());
        simCredential.setEapType(24);
        assertEquals(24, simCredential.getEapType());
        credential.setSimCredential(simCredential);
        assertEquals(simCredential, credential.getSimCredential());
        config.setCredential(credential);
        assertEquals(credential, config.getCredential());
        return config;
    }

    /**
     * Parse and verify all supported fields under PPS MO tree.
     *
     * @throws Exception
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.PpsMoParserTest"	"testParsePPSMOTree"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/PpsMoParserTest.java"	""	"public void testParsePPSMOTree() throws Exception {
        String ppsMoTree = loadResourceFile(PPS_MO_XML_FILE);
        PasspointConfiguration expectedConfig = generateConfigurationFromPPSMOTree();
        PasspointConfiguration actualConfig = PpsMoParser.parseMoText(ppsMoTree);
        assertTrue(actualConfig.equals(expectedConfig));
    }
}"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"ActionListener"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static org.junit.Assert.assertNotEquals;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.wifi.WifiManager;
import android.net.wifi.p2p.WifiP2pDevice;
import android.net.wifi.p2p.WifiP2pGroup;
import android.net.wifi.p2p.WifiP2pGroupList;
import android.net.wifi.p2p.WifiP2pInfo;
import android.net.wifi.p2p.WifiP2pManager;
import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
import android.net.wifi.p2p.nsd.WifiP2pUpnpServiceInfo;
import android.provider.Settings;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class ConcurrencyTest extends WifiJUnit3TestBase {
    private class MySync {
        static final int WIFI_STATE = 0;
        static final int P2P_STATE = 1;
        static final int DISCOVERY_STATE = 2;
        static final int NETWORK_INFO = 3;

        public BitSet pendingSync = new BitSet();

        public int expectedWifiState;
        public int expectedP2pState;
        public int expectedDiscoveryState;
        public NetworkInfo expectedNetworkInfo;
    }

    private class MyResponse {
        public boolean valid = false;

        public boolean success;
        public int failureReason;
        public int p2pState;
        public int discoveryState;
        public NetworkInfo networkInfo;
        public WifiP2pInfo p2pInfo;
        public String deviceName;
        public WifiP2pGroupList persistentGroups;
        public WifiP2pGroup group = new WifiP2pGroup();
    }

    private WifiManager mWifiManager;
    private WifiP2pManager mWifiP2pManager;
    private WifiP2pManager.Channel mWifiP2pChannel;
    private MySync mMySync = new MySync();
    private MyResponse mMyResponse = new MyResponse();
    private boolean mWasVerboseLoggingEnabled;

    private static final String TAG = ""ConcurrencyTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION = 5000;
    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.WIFI_STATE);
                    mMySync.expectedWifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
                            WifiManager.WIFI_STATE_DISABLED);
                    mMySync.notify();
                }
            } else if(action.equals(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.P2P_STATE);
                    mMySync.expectedP2pState = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE,
                            WifiP2pManager.WIFI_P2P_STATE_DISABLED);
                    mMySync.notify();
                }
            } else if (action.equals(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.DISCOVERY_STATE);
                    mMySync.expectedDiscoveryState = intent.getIntExtra(
                            WifiP2pManager.EXTRA_DISCOVERY_STATE,
                            WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED);
                    mMySync.notify();
                }
            } else if (action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.pendingSync.set(MySync.NETWORK_INFO);
                    mMySync.expectedNetworkInfo = (NetworkInfo) intent.getExtra(
                            WifiP2pManager.EXTRA_NETWORK_INFO, null);
                    Log.d(TAG, ""Get WIFI_P2P_CONNECTION_CHANGED_ACTION: ""
                            + mMySync.expectedNetworkInfo);
                    mMySync.notify();
                }
            }
        }
    };

    private WifiP2pManager.ActionListener mActionListener = new WifiP2pManager.ActionListener() {
        @Override
        public void onSuccess() {
            synchronized (mMyResponse) {
                mMyResponse.valid = true;
                mMyResponse.success = true;
                mMyResponse.notify();
            }
        }

        @Override
        public void onFailure(int reason) {
            synchronized (mMyResponse) {
                Log.d(TAG, ""failure reason: "" + reason);
                mMyResponse.valid = true;
                mMyResponse.success = false;
                mMyResponse.failureReason = reason;
                mMyResponse.notify();
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
       super.setUp();
       if (!WifiFeature.isWifiSupported(getContext()) &&
                !WifiFeature.isP2pSupported(getContext())) {
            // skip the test if WiFi && p2p are not supported
            return;
        }

        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION);
        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(mWifiManager);
        if (mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi disable"");
            Thread.sleep(DURATION);
        }

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        assertTrue(!mWifiManager.isWifiEnabled());
        mMySync.expectedWifiState = WifiManager.WIFI_STATE_DISABLED;
        mMySync.expectedP2pState = WifiP2pManager.WIFI_P2P_STATE_DISABLED;
        mMySync.expectedDiscoveryState = WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED;
        mMySync.expectedNetworkInfo = null;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext()) &&
                !WifiFeature.isP2pSupported(getContext())) {
            // skip the test if WiFi and p2p are not supported
            super.tearDown();
            return;
        }
        if (null != mWifiP2pManager) {
            removeAllPersistentGroups();
        }
        mContext.unregisterReceiver(mReceiver);

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));

        enableWifi();
        super.tearDown();
    }

    private boolean waitForBroadcasts(List<Integer> waitSyncList) {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                List<Integer> handledSyncList = waitSyncList.stream()
                        .filter(w -> mMySync.pendingSync.get(w))
                        .collect(Collectors.toList());
                handledSyncList.forEach(w -> mMySync.pendingSync.clear(w));
                waitSyncList.removeAll(handledSyncList);
                if (waitSyncList.isEmpty()) {
                    break;
                }
                try {
                    mMySync.wait(WAIT_MSEC);
                } catch (InterruptedException e) { }
            }
            if (!waitSyncList.isEmpty()) {
                Log.i(TAG, ""Missing broadcast: "" + waitSyncList);
            }
            return waitSyncList.isEmpty();
        }
    }

    private boolean waitForBroadcasts(int waitSingleSync) {
        return waitForBroadcasts(
                new LinkedList<Integer>(Arrays.asList(waitSingleSync)));
    }

    private boolean waitForServiceResponse(MyResponse waitResponse) {
        synchronized (waitResponse) {
            long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                try {
                    waitResponse.wait(WAIT_MSEC);
                } catch (InterruptedException e) { }

                if (waitResponse.valid) {
                    return true;
                }
            }
            return false;
        }
    }

    // Return true if location is enabled.
    private boolean isLocationEnabled() {
        return Settings.Secure.getInt(getContext().getContentResolver(),
                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF)
                != Settings.Secure.LOCATION_MODE_OFF;
    }

    // Returns true if the device has location feature.
    private boolean hasLocationFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION);
    }

    private void resetResponse(MyResponse responseObj) {
        synchronized (responseObj) {
            responseObj.valid = false;
            responseObj.networkInfo = null;
            responseObj.p2pInfo = null;
            responseObj.deviceName = null;
            responseObj.persistentGroups = null;
            responseObj.group = null;
        }
    }

    /*
     * Enables Wifi and block until connection is established.
     */
    private void enableWifi() throws InterruptedException {
        if (!mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable"");
        }

        ConnectivityManager cm =
            (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkRequest request =
            new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                                        .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                                        .build();
        final CountDownLatch latch = new CountDownLatch(1);
        NetworkCallback networkCallback = new NetworkCallback() {
            @Override
            public void onAvailable(Network network) {
                latch.countDown();
            }
        };
        cm.registerNetworkCallback(request, networkCallback);
        latch.await(DURATION, TimeUnit.MILLISECONDS);

        cm.unregisterNetworkCallback(networkCallback);
    }

    private void removeAllPersistentGroups() {
        WifiP2pGroupList persistentGroups = getPersistentGroups();
        assertNotNull(persistentGroups);
        for (WifiP2pGroup group: persistentGroups.getGroupList()) {
            resetResponse(mMyResponse);
            ShellIdentityUtils.invokeWithShellPermissions(() -> {
                mWifiP2pManager.deletePersistentGroup(mWifiP2pChannel,
                        group.getNetworkId(),
                        mActionListener);
                assertTrue(waitForServiceResponse(mMyResponse));
                assertTrue(mMyResponse.success);
            });
        }
        persistentGroups = getPersistentGroups();
        assertNotNull(persistentGroups);
        assertEquals(0, persistentGroups.getGroupList().size());
    }

    private boolean setupWifiP2p() {
        // Cannot support p2p alone
        if (!WifiFeature.isWifiSupported(getContext())) {
            assertTrue(!WifiFeature.isP2pSupported(getContext()));
            return false;
        }

        if (!WifiFeature.isP2pSupported(getContext())) {
            // skip the test if p2p is not supported
            return false;
        }

        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return false;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since P-release WiFi Direct""
                    + "" needs Location enabled."");
        }

        long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
        while (!mWifiManager.isWifiEnabled() && System.currentTimeMillis() < timeout) {
            try {
                enableWifi();
            } catch (InterruptedException e) { }
        }

        assertTrue(mWifiManager.isWifiEnabled());

        mWifiP2pManager =
                (WifiP2pManager) getContext().getSystemService(Context.WIFI_P2P_SERVICE);
        mWifiP2pChannel = mWifiP2pManager.initialize(
                getContext(), getContext().getMainLooper(), null);

        assertNotNull(mWifiP2pManager);
        assertNotNull(mWifiP2pChannel);

        assertTrue(waitForBroadcasts(
                new LinkedList<Integer>(
                Arrays.asList(MySync.WIFI_STATE, MySync.P2P_STATE))));

        assertEquals(WifiManager.WIFI_STATE_ENABLED, mMySync.expectedWifiState);
        assertEquals(WifiP2pManager.WIFI_P2P_STATE_ENABLED, mMySync.expectedP2pState);
        removeAllPersistentGroups();

        return true;
    }"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConcurrencyTest"	"testRequestDiscoveryState"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void testRequestDiscoveryState() {
        if (!setupWifiP2p()) {
            return;
        }

        resetResponse(mMyResponse);
        mWifiP2pManager.requestDiscoveryState(
                mWifiP2pChannel, new WifiP2pManager.DiscoveryStateListener() {
                    @Override
                    public void onDiscoveryStateAvailable(int state) {
                        synchronized (mMyResponse) {
                            mMyResponse.valid = true;
                            mMyResponse.discoveryState = state;
                            mMyResponse.notify();
                        }
                    }
                });
        assertTrue(waitForServiceResponse(mMyResponse));
        assertEquals(WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED, mMyResponse.discoveryState);

        // If there is any saved network and this device is connecting to this saved network,
        // p2p discovery might be blocked during DHCP provision.
        int retryCount = 3;
        while (retryCount > 0) {
            resetResponse(mMyResponse);
            mWifiP2pManager.discoverPeers(mWifiP2pChannel, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            if (mMyResponse.success
                    || mMyResponse.failureReason != WifiP2pManager.BUSY) {
                break;
            }
            Log.w(TAG, ""Discovery is blocked, try again!"");
            try {
                Thread.sleep(500);
            } catch (InterruptedException ex) {}
            retryCount--;
        }
        assertTrue(mMyResponse.success);
        assertTrue(waitForBroadcasts(MySync.DISCOVERY_STATE));

        resetResponse(mMyResponse);
        mWifiP2pManager.requestDiscoveryState(mWifiP2pChannel,
                new WifiP2pManager.DiscoveryStateListener() {
                    @Override
                    public void onDiscoveryStateAvailable(int state) {
                        synchronized (mMyResponse) {
                            mMyResponse.valid = true;
                            mMyResponse.discoveryState = state;
                            mMyResponse.notify();
                        }
                    }
                });
        assertTrue(waitForServiceResponse(mMyResponse));
        assertEquals(WifiP2pManager.WIFI_P2P_DISCOVERY_STARTED, mMyResponse.discoveryState);

        mWifiP2pManager.stopPeerDiscovery(mWifiP2pChannel, null);
    }"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.p2p.cts.WifiP2pDeviceTest"	"testDefaultDeviceCapabilityCheck"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/p2p/cts/WifiP2pDeviceTest.java"	""	"public void testDefaultDeviceCapabilityCheck() {
        WifiP2pDevice dev = new WifiP2pDevice();

        assertFalse(dev.isServiceDiscoveryCapable());
    }
}"	""	""	"discovery"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testGetMeteredOverride"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testGetMeteredOverride() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertEquals(METERED_OVERRIDE_NONE, passpointConfiguration.getMeteredOverride());
    }

    /**
     * Tests {@link PasspointConfiguration#getSubscriptionExpirationTimeMillis()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testGetSubscriptionExpirationTimeMillis"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testGetSubscriptionExpirationTimeMillis() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertEquals(Long.MIN_VALUE,
                passpointConfiguration.getSubscriptionExpirationTimeMillis());
    }

    /**
     * Tests {@link PasspointConfiguration#getUniqueId()} method.
     * <p>
     * Test unique identifier is not null
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testGetUniqueId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testGetUniqueId() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Create a configuration and make sure the unique ID is not null
        PasspointConfiguration passpointConfiguration1 = createConfig(SIM_CREDENTIAL, ""123456*"",
                18 /* EAP_SIM */);
        String uniqueId1 = passpointConfiguration1.getUniqueId();
        assertNotNull(uniqueId1);

        // Create another configuration and make sure the unique ID is not null
        PasspointConfiguration passpointConfiguration2 = createConfig(SIM_CREDENTIAL, ""567890*"",
                23 /* EAP_AKA */);
        String uniqueId2 = passpointConfiguration2.getUniqueId();
        assertNotNull(uniqueId2);

        // Make sure the IDs are not equal
        assertFalse(uniqueId1.equals(uniqueId2));

        passpointConfiguration2 = createConfig(USER_CREDENTIAL);
        assertFalse(uniqueId1.equals(passpointConfiguration2.getUniqueId()));

        passpointConfiguration2 = createConfig(CERT_CREDENTIAL);
        assertFalse(uniqueId1.equals(passpointConfiguration2.getUniqueId()));
    }

    /**
     * Tests {@link PasspointConfiguration#isAutojoinEnabled()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testIsAutojoinEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testIsAutojoinEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertTrue(passpointConfiguration.isAutojoinEnabled());
    }

    /**
     * Tests {@link PasspointConfiguration#isMacRandomizationEnabled()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testIsMacRandomizationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testIsMacRandomizationEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = new PasspointConfiguration();
        assertTrue(passpointConfiguration.isMacRandomizationEnabled());
    }

    /**
     * Tests {@link PasspointConfiguration#isOsuProvisioned()} method.
     * <p>
     * Test default value
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testIsOsuProvisioned"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testIsOsuProvisioned() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = createConfig(USER_CREDENTIAL);
        assertFalse(passpointConfiguration.isOsuProvisioned());
    }

    /**
     * Tests {@link PasspointConfiguration#PasspointConfiguration(PasspointConfiguration)} method.
     * <p>
     * Test the PasspointConfiguration copy constructor
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testPasspointConfigurationCopyConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testPasspointConfigurationCopyConstructor() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        PasspointConfiguration passpointConfiguration = createConfig(USER_CREDENTIAL);
        PasspointConfiguration copyOfPasspointConfiguration =
                new PasspointConfiguration(passpointConfiguration);
        assertEquals(passpointConfiguration, copyOfPasspointConfiguration);
    }

    /**
     * Tests {@link HomeSp#HomeSp(HomeSp)} method.
     * <p>
     * Test the HomeSp copy constructor
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiHotspot2Test"	"testCredentialGetClientPrivateKey"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiHotspot2Test.java"	""	"public void testCredentialGetClientPrivateKey() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        Credential credential = new Credential();
        credential.setClientPrivateKey(FakeKeys.RSA_KEY1);

        assertEquals(FakeKeys.RSA_KEY1, credential.getClientPrivateKey());
    }

    private static PasspointConfiguration createConfig(int type) throws Exception {
        return createConfig(type, ""123456*"", 18 /* EAP_SIM */);
    }

    private static PasspointConfiguration createConfig(int type, String imsi, int eapType)
            throws Exception {
        PasspointConfiguration config = new PasspointConfiguration();
        config.setHomeSp(createHomeSp());
        switch (type) {
            default:
            case SIM_CREDENTIAL:
                config.setCredential(
                        createCredentialWithSimCredential(imsi, eapType));
                break;
            case USER_CREDENTIAL:
                config.setCredential(createCredentialWithUserCredential());
                break;
            case CERT_CREDENTIAL:
                config.setCredential(createCredentialWithCertificateCredential());
                break;
        }

        return config;
    }

    /**
     * Helper function for generating HomeSp for testing.
     *
     * @return {@link HomeSp}
     */
    private static HomeSp createHomeSp() {
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""test.com"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        return homeSp;
    }

    /**
     * Helper function for generating Credential for testing.
     *
     * @param userCred               Instance of UserCredential
     * @param certCred               Instance of CertificateCredential
     * @param simCred                Instance of SimCredential
     * @param clientCertificateChain Chain of client certificates
     * @param clientPrivateKey       Client private key
     * @param caCerts                CA certificates
     * @return {@link Credential}
     */
    private static Credential createCredential(Credential.UserCredential userCred,
            Credential.CertificateCredential certCred,
            Credential.SimCredential simCred,
            X509Certificate[] clientCertificateChain, PrivateKey clientPrivateKey,
            X509Certificate... caCerts) {
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setUserCredential(userCred);
        cred.setCertCredential(certCred);
        cred.setSimCredential(simCred);
        return cred;
    }

    /**
     * Helper function for generating certificate credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithCertificateCredential()
            throws NoSuchAlgorithmException, CertificateEncodingException {
        Credential.CertificateCredential certCred = new Credential.CertificateCredential();
        certCred.setCertType(""x509v3"");
        certCred.setCertSha256Fingerprint(
                MessageDigest.getInstance(""SHA-256"").digest(
                        FakeKeys.CLIENT_CERT.getEncoded()));
        return createCredential(null, certCred, null, new X509Certificate[]{
                        FakeKeys.CLIENT_CERT},
                FakeKeys.RSA_KEY1, FakeKeys.CA_CERT0,
                FakeKeys.CA_CERT1);
    }

    /**
     * Helper function for generating SIM credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithSimCredential(String imsi, int eapType) {
        Credential.SimCredential simCred = new Credential.SimCredential();
        simCred.setImsi(imsi);
        simCred.setEapType(eapType);
        return createCredential(null, null, simCred, null, null, (X509Certificate[]) null);
    }

    /**
     * Helper function for generating user credential for testing.
     *
     * @return {@link Credential}
     */
    private static Credential createCredentialWithUserCredential() {
        Credential.UserCredential userCred = new Credential.UserCredential();
        userCred.setUsername(""username"");
        userCred.setPassword(""password"");
        userCred.setEapType(21 /* EAP_TTLS */);
        userCred.setNonEapInnerMethod(""MS-CHAP"");
        return createCredential(userCred, null, null, null, null,
                FakeKeys.CA_CERT0);
    }

    /**
     * Tests {@link OsuProvider#getFriendlyName()} and {@link OsuProvider#getServerUri()} methods.
     * <p>
     * Test that getting a set friendly name and server URI produces the same value
     */"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConfigParserTest"	"testParseConfigFile"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConfigParserTest.java"	""	"public void testParseConfigFile() throws Exception {
        String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT);
        PasspointConfiguration expectedConfig = generateConfigurationFromProfile();
        PasspointConfiguration actualConfig =
                ConfigParser.parsePasspointConfig(
                        ""application/x-wifi-config"", configStr.getBytes());
        assertTrue(actualConfig.equals(expectedConfig));
    }
}"	""	""	"passpoint"	""	""	""	""	""	""	""	""	""	""
"7.4.2.4  . Wi"	"7.4.2.4"	"C-1-3"	"7.4.2.4/C-1-3"	"07040204.670103"	"""C-1-3] MUST support IEEE 802.11u standard, specifically related to Network Discovery and Selection, such as Generic Advertisement Service (GAS) and Access Network Query Protocol (ANQP)."""	""	""	"discovery GAS ANQP passpoint IEEE select"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifiaware.TestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifiaware/TestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifiaware;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.DataSetObserver;
import android.net.wifi.aware.WifiAwareManager;
import android.os.Bundle;
import android.provider.Settings;
import android.util.Log;
import android.view.View;
import android.widget.ListView;

import androidx.core.os.BuildCompat;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter;

/**
 * Activity listing all Wi-Fi Aware tests.
 */
public class TestListActivity extends PassFailButtons.TestListActivity {
    private static final String TAG = ""TestListActivity"";

    private WifiAwareManager mWifiAwareManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mWifiAwareManager = (WifiAwareManager) getSystemService(Context.WIFI_AWARE_SERVICE);
        if (mWifiAwareManager == null) {
            Log.wtf(TAG,
                    ""Can't get WIFI_AWARE_SERVICE. Should be gated by 'test_required_features'!?"");
            return;
        }

        boolean isRttSupported = getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_WIFI_RTT);

        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.aware_test, R.string.aware_test_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        // Add the sub-test/categories
        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);

        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_open_unsolicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathOpenUnsolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathOpenUnsolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathOpenPassiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathOpenPassiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_passphrase_unsolicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPassphraseUnsolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPassphraseUnsolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPassphrasePassiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPassphrasePassiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_pmk_unsolicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPmkUnsolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPmkUnsolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPmkPassiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPmkPassiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_open_solicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathOpenSolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathOpenSolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathOpenActiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathOpenActiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_passphrase_solicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPassphraseSolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPassphraseSolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPassphraseActiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPassphraseActiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_ib_pmk_solicited));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_publish,
                DataPathPmkSolicitedPublishTestActivity.class.getName(),
                new Intent(this, DataPathPmkSolicitedPublishTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_subscribe,
                DataPathPmkActiveSubscribeTestActivity.class.getName(),
                new Intent(this, DataPathPmkActiveSubscribeTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_oob_open));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_responder,
                DataPathOobOpenResponderTestActivity.class.getName(),
                new Intent(this, DataPathOobOpenResponderTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_initiator,
                DataPathOobOpenInitiatorTestActivity.class.getName(),
                new Intent(this, DataPathOobOpenInitiatorTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newCategory(this,
                R.string.aware_dp_oob_passphrase));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_responder,
                DataPathOobPassphraseResponderTestActivity.class.getName(),
                new Intent(this, DataPathOobPassphraseResponderTestActivity.class), null));
        adapter.add(TestListAdapter.TestListItem.newTest(this,
                R.string.aware_initiator,
                DataPathOobPassphraseInitiatorTestActivity.class.getName(),
                new Intent(this, DataPathOobPassphraseInitiatorTestActivity.class), null));
        if (isRttSupported) {
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_discovery_ranging));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DiscoveryRangingPublishTestActivity.class.getName(),
                    new Intent(this, DiscoveryRangingPublishTestActivity.class), null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DiscoveryRangingSubscribeTestActivity.class.getName(),
                    new Intent(this, DiscoveryRangingSubscribeTestActivity.class), null));
        }

        if (BuildCompat.isAtLeastS()) {
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_open_unsolicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathOpenUnsolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenUnsolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathOpenPassiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenPassiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_passphrase_unsolicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPassphraseUnsolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this,
                            DataPathPassphraseUnsolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPassphrasePassiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPassphrasePassiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_pmk_unsolicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPmkUnsolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkUnsolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPmkPassiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkPassiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_open_solicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathOpenSolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenSolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathOpenActiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathOpenActiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_passphrase_solicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPassphraseSolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPassphraseSolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPassphraseActiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPassphraseActiveSubscribeAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newCategory(this,
                    R.string.aware_dp_ib_pmk_solicited_accept_any));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_publish,
                    DataPathPmkSolicitedPublishAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkSolicitedPublishAcceptAnyTestActivity.class),
                    null));
            adapter.add(TestListAdapter.TestListItem.newTest(this,
                    R.string.aware_subscribe,
                    DataPathPmkActiveSubscribeAcceptAnyTestActivity.class.getName(),
                    new Intent(this, DataPathPmkActiveSubscribeAcceptAnyTestActivity.class), null));
        }

        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }

            @Override
            public void onInvalidated() {
                updatePassButton();
            }
        });

        setTestListAdapter(adapter);
    }

    @Override
    protected void handleItemClick(ListView listView, View view, int position, long id) {
        if (!mWifiAwareManager.isAvailable()) {
            showAwareEnableDialog();
            return;
        }

        super.handleItemClick(listView, view, position, id);
    }

    /**
     * Show the dialog to jump to system settings in order to enable
     * WiFi (and by extension WiFi Aware).
     */
    private void showAwareEnableDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setTitle(R.string.aware_not_enabled);
        builder.setMessage(R.string.aware_not_enabled_message);
        builder.setPositiveButton(R.string.aware_settings,
                new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
                    }
                });
        builder.create().show();
    }
}"	""	""	"discovery discovery"	""	""	""	""	""	""	""	""	""	""
