"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testApplicationRestrictions"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testApplicationRestrictions() throws Exception {
        installAppAsUser(DELEGATE_APP_APK, mUserId);
        installAppAsUser(APP_RESTRICTIONS_TARGET_APP_APK, mUserId);

        try {
            // Only the DPC can manage app restrictions by default.
            executeDeviceTestClass("".ApplicationRestrictionsTest"");
            executeAppRestrictionsManagingPackageTest(""testCannotAccessApis"");

            // Letting the DELEGATE_APP_PKG manage app restrictions too.
            changeApplicationRestrictionsManagingPackage(DELEGATE_APP_PKG);
            executeAppRestrictionsManagingPackageTest(""testCanAccessApis"");
            runDeviceTestsAsUser(DELEGATE_APP_PKG, "".GeneralDelegateTest"",
                    ""testSettingAdminComponentNameThrowsException"", mUserId);

            // The DPC should still be able to manage app restrictions normally.
            executeDeviceTestClass("".ApplicationRestrictionsTest"");

            // The app shouldn't be able to manage app restrictions for other users.
            int parentUserId = getPrimaryUser();
            if (parentUserId != mUserId) {
                installAppAsUser(DELEGATE_APP_APK, parentUserId);
                installAppAsUser(APP_RESTRICTIONS_TARGET_APP_APK, parentUserId);
                runDeviceTestsAsUser(DELEGATE_APP_PKG, "".AppRestrictionsDelegateTest"",
                        ""testCannotAccessApis"", parentUserId);
            }

            // Revoking the permission for DELEGAYE_APP_PKG to manage restrictions.
            changeApplicationRestrictionsManagingPackage(null);
            executeAppRestrictionsManagingPackageTest(""testCannotAccessApis"");

            // The DPC should still be able to manage app restrictions normally.
            executeDeviceTestClass("".ApplicationRestrictionsTest"");

            assertMetricsLogged(getDevice(), () -> {
                executeDeviceTestMethod("".ApplicationRestrictionsTest"",
                        ""testSetApplicationRestrictions"");
            }, new DevicePolicyEventWrapper.Builder(EventId.SET_APPLICATION_RESTRICTIONS_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(APP_RESTRICTIONS_TARGET_APP_PKG)
                    .build());
        } finally {
            changeApplicationRestrictionsManagingPackage(null);
        }
    }

    /**
     * Returns a list of delegation tests that should run. Add delegations tests applicable to both
     * device owner and profile owners to this method directly. DO or PO specific tests should be
     * added to {@link #getAdditionalDelegationTests} in the subclass.
     */
    private Map<String, DevicePolicyEventWrapper[]> getDelegationTests() {
        final Map<String, DevicePolicyEventWrapper[]> result = new HashMap<>();
        result.put("".AppRestrictionsDelegateTest"", null);
        result.put("".CertInstallDelegateTest"", null);
        result.put("".BlockUninstallDelegateTest"", null);
        result.put("".PermissionGrantDelegateTest"", null);
        result.put("".PackageAccessDelegateTest"", null);
        result.put("".EnableSystemAppDelegateTest"", null);
        result.putAll(getAdditionalDelegationTests());
        return result;
    }

    Map<String, DevicePolicyEventWrapper[]> getAdditionalDelegationTests() {
        return Collections.<String, DevicePolicyEventWrapper[]>emptyMap();
    }

    /**
     * Returns a list of delegation scopes that are needed to run delegation tests. Add scopes
     * which are applicable to both device owner and profile owners to this method directly.
     * DO or PO specific scopes should be added to {@link #getAdditionalDelegationScopes}
     * in the subclass.
     */
    private List<String> getDelegationScopes() {
        final List<String> result = new ArrayList<>(Arrays.asList(
                DELEGATION_APP_RESTRICTIONS,
                DELEGATION_CERT_INSTALL,
                DELEGATION_BLOCK_UNINSTALL,
                DELEGATION_PERMISSION_GRANT,
                DELEGATION_PACKAGE_ACCESS,
                DELEGATION_ENABLE_SYSTEM_APP,
                // CERT_SELECTION scope is in the list so it still participates GeneralDelegateTest.
                // But its main functionality test is driven by testDelegationCertSelection() and
                // hence missing from getDelegationTests() on purpose.
                DELEGATION_CERT_SELECTION
                ));
        result.addAll(getAdditionalDelegationScopes());
        return result;
    }

    List<String> getAdditionalDelegationScopes() {
        return Collections.<String>emptyList();
    }

    /**
     * General instructions to add a new delegation test:
     * 1. Test primary delegation functionalitiy
     *    Implement the delegate's positive/negate functionaility tests in a new test class
     *    in CtsDelegateApp.apk. Main entry point are {@code testCanAccessApis} and
     *    {@code testCannotAccessApis}. Once implemented, add the delegation scope and the test
     *    class name to {@link #getDelegationScopes}, {@link #getDelegationTests} to make the test
     *    run on DO/PO/PO on primary user.  If the test should only run on a subset of these
     *    combinations, add them to the subclass's {@link #getAdditionalDelegationScopes} and
     *    {@link #getDelegationScopes} intead.
     *    <p>Alternatively, create a separate hostside method to drive the test, similar to
     *    {@link #testDelegationCertSelection}. This is preferred if the delegated functionalities
     *    already exist in another app.
     * 2. Test access control of DO-only delegation
     *    Add the delegation scope to
     *    {@code DelegationTest#testDeviceOwnerOnlyDelegationsOnlyPossibleToBeSetByDeviceOwner} to
     *    test that only DO can delegate this scope.
     * 3. Test behaviour of exclusive delegation
     *    Add the delegation scope to {@code DelegationTest#testExclusiveDelegations} to test that
     *    the scope can only be delegatd to one app at a time.
     */"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.NfcTestActivity"	"getTestMessage"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/NfcTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.app.Activity;
import android.app.admin.DevicePolicyManager;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.nfc.NdefMessage;
import android.nfc.NdefRecord;
import android.nfc.NfcAdapter;
import android.os.Bundle;
import android.os.UserManager;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Toast;

import com.android.cts.verifier.R;

import java.nio.charset.Charset;

public class NfcTestActivity extends Activity {
    private static final String TAG = ""NfcTestActivity"";

    /* package */ static final String EXTRA_DISALLOW_BY_POLICY = ""disallowByPolicy"";

    private static final String NFC_BEAM_PACKAGE = ""com.android.nfc"";
    private static final String NFC_BEAM_ACTIVITY = ""com.android.nfc.BeamShareActivity"";
    private static final String SAMPLE_TEXT = ""sample text"";

    private ComponentName mAdminReceiverComponent;
    private DevicePolicyManager mDevicePolicyManager;
    private UserManager mUserMangaer;
    private NfcAdapter mNfcAdapter;
    private boolean mDisallowByPolicy;
    private boolean mAddUserRestrictionOnFinish;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.byod_nfc_test_activity);

        mAdminReceiverComponent = new ComponentName(this, DeviceAdminTestReceiver.class.getName());
        mDevicePolicyManager = (DevicePolicyManager) getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        mUserMangaer = (UserManager) getSystemService(Context.USER_SERVICE);
        mAddUserRestrictionOnFinish = mUserMangaer.hasUserRestriction(
                UserManager.DISALLOW_OUTGOING_BEAM);
        mDisallowByPolicy = getIntent().getBooleanExtra(EXTRA_DISALLOW_BY_POLICY, false);
        if (mDisallowByPolicy) {
            mDevicePolicyManager.addUserRestriction(mAdminReceiverComponent,
                    UserManager.DISALLOW_OUTGOING_BEAM);
        } else {
            mDevicePolicyManager.clearUserRestriction(mAdminReceiverComponent,
                    UserManager.DISALLOW_OUTGOING_BEAM);
        }

        mNfcAdapter = NfcAdapter.getDefaultAdapter(this);
        mNfcAdapter.setNdefPushMessage(getTestMessage(), this);

        final Intent shareIntent = new Intent(Intent.ACTION_SEND);
        shareIntent.putExtra(Intent.EXTRA_TEXT, SAMPLE_TEXT);

        findViewById(R.id.manual_beam_button).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                mNfcAdapter.invokeBeam(NfcTestActivity.this);
            }
        });
        findViewById(R.id.intent_share_button).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                // Specify the package name of NfcBeamActivity so that the tester don't need to
                // select the activity manually.
                shareIntent.setClassName(NFC_BEAM_PACKAGE, NFC_BEAM_ACTIVITY);
                try {
                    startActivity(shareIntent);
                } catch (ActivityNotFoundException e) {
                    Toast.makeText(NfcTestActivity.this,
                            R.string.provisioning_byod_cannot_resolve_beam_activity,
                            Toast.LENGTH_SHORT).show();
                    Log.e(TAG, ""Nfc beam activity not found"", e);
                }
            }
        });
    }

    @Override
    public void finish() {
        if (mAddUserRestrictionOnFinish) {
            mDevicePolicyManager.addUserRestriction(mAdminReceiverComponent,
                    UserManager.DISALLOW_OUTGOING_BEAM);
        } else {
            mDevicePolicyManager.clearUserRestriction(mAdminReceiverComponent,
                    UserManager.DISALLOW_OUTGOING_BEAM);
        }
        super.finish();
    }

    private NdefMessage getTestMessage() {
        byte[] mimeBytes = ""application/com.android.cts.verifier.managedprovisioning""
                .getBytes(Charset.forName(""US-ASCII""));
        byte[] id = new byte[] {1, 3, 3, 7};
        byte[] payload = SAMPLE_TEXT.getBytes(Charset.forName(""US-ASCII""));
        return new NdefMessage(new NdefRecord[] {
                new NdefRecord(NdefRecord.TNF_MIME_MEDIA, mimeBytes, id, payload)
        });
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hcef.HceFReaderTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hcef/HceFReaderTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.hcef;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;

/** Activity that lists all the NFC HCE reader tests. */
public class HceFReaderTestActivity extends PassFailButtons.TestListActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.nfc_test, R.string.nfc_hce_reader_test_info, 0);
        setPassFailButtonClickListeners();

        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);

        if (getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_NFC_HOST_CARD_EMULATION_NFCF)) {
            adapter.add(TestListItem.newCategory(this, R.string.nfc_hce_f_reader_tests));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_f_reader,
                    HceFReaderActivity.class.getName(),
                    new Intent(this, HceFReaderActivity.class), null));

        }

        setTestListAdapter(adapter);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.NetworkResetTest"	"factoryReset_disallowedByNetworkResetPolicy_doesNotFactoryReset"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/NetworkResetTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = DisallowNetworkReset.class)
    @EnsureHasPermission({NETWORK_SETTINGS, WRITE_SECURE_SETTINGS})
    public void factoryReset_disallowedByNetworkResetPolicy_doesNotFactoryReset() throws Exception {
        final boolean originalUserRestriction =
                sUserManager.hasUserRestriction(DISALLOW_NETWORK_RESET);
        try {
            sConnectivityManager.setAirplaneMode(true);
            sDeviceState.dpc().devicePolicyManager().addUserRestriction(DISALLOW_NETWORK_RESET);

            sConnectivityManager.factoryReset();

            // As the factory reset should have been rejected, it's expected that the airplane mode
            // should not be changed.
            assertThat(getAirplaneMode()).isTrue();
        } finally {
            restoreUserRestriction(originalUserRestriction, DISALLOW_NETWORK_RESET);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.NetworkResetTest"	"factoryReset_disallowedByConfigPrivateDnsPolicy_doesPartialFactoryReset"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/NetworkResetTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = DisallowPrivateDnsConfig.class)
    @EnsureHasPermission({NETWORK_SETTINGS, WRITE_SECURE_SETTINGS})
    public void factoryReset_disallowedByConfigPrivateDnsPolicy_doesPartialFactoryReset()
            throws Exception {
        final boolean originalUserRestriction =
                sUserManager.hasUserRestriction(DISALLOW_CONFIG_PRIVATE_DNS);
        try {
            ConnectivitySettingsManager.setPrivateDnsMode(sContext,
                    ConnectivitySettingsManager.PRIVATE_DNS_MODE_OFF);
            sDeviceState.dpc().devicePolicyManager()
                    .addUserRestriction(DISALLOW_CONFIG_PRIVATE_DNS);

            sConnectivityManager.factoryReset();

            // As setting private dns should be rejected, it's expected that private dns mode
            // should not be changed.
            assertThat(getPrivateDnsMode()).isEqualTo(
                    ConnectivitySettingsManager.PRIVATE_DNS_MODE_OFF);
        } finally {
            restoreUserRestriction(originalUserRestriction, DISALLOW_CONFIG_PRIVATE_DNS);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.NetworkResetTest"	"isFalse"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/NetworkResetTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = DisallowNetworkReset.class)
    @EnsureHasPermission({NETWORK_SETTINGS, WRITE_SECURE_SETTINGS})
    public void factoryReset_noPolicyRestrictions_resetsToDefault() throws Exception {
        final boolean originalPrivateDnsUserRestriction =
                sUserManager.hasUserRestriction(DISALLOW_CONFIG_PRIVATE_DNS);
        final boolean originalNetworkResetUserRestriction =
                sUserManager.hasUserRestriction(DISALLOW_NETWORK_RESET);
        try {
            sConnectivityManager.setAirplaneMode(true);
            ConnectivitySettingsManager.setPrivateDnsMode(sContext,
                    ConnectivitySettingsManager.PRIVATE_DNS_MODE_OFF);
            // Ensure no policy set.
            sDeviceState.dpc().devicePolicyManager()
                    .clearUserRestriction(DISALLOW_CONFIG_PRIVATE_DNS);
            sDeviceState.dpc().devicePolicyManager()
                    .clearUserRestriction(DISALLOW_NETWORK_RESET);

            sConnectivityManager.factoryReset();

            // Verify settings reset to default setting.
            assertThat(getPrivateDnsMode()).isEqualTo(
                    ConnectivitySettingsManager.PRIVATE_DNS_MODE_OPPORTUNISTIC);
            assertThat(getAirplaneMode()).isFalse();
        } finally {
            restoreUserRestriction(originalPrivateDnsUserRestriction, DISALLOW_CONFIG_PRIVATE_DNS);
            restoreUserRestriction(originalNetworkResetUserRestriction, DISALLOW_NETWORK_RESET);
        }
    }

    private boolean getAirplaneMode() throws Exception {
        return Settings.Global.getInt(
                sContext.getContentResolver(), Settings.Global.AIRPLANE_MODE_ON) != 0;
    }

    private int getPrivateDnsMode() {
        return ConnectivitySettingsManager.getPrivateDnsMode(sContext);
    }

    private int getNetworkAvoidBadWifi() {
        return ConnectivitySettingsManager.getNetworkAvoidBadWifi(sContext);
    }

    private void restoreSettings(boolean airplaneMode, int privateDnsMode, int avoidBadWifi) {
        sConnectivityManager.setAirplaneMode(airplaneMode);
        ConnectivitySettingsManager.setPrivateDnsMode(sContext, privateDnsMode);
        ConnectivitySettingsManager.setNetworkAvoidBadWifi(sContext, avoidBadWifi);
    }

    private void restoreUserRestriction(boolean originalUserRestriction, String policy) {
        if (originalUserRestriction) {
            sDeviceState.dpc().devicePolicyManager().addUserRestriction(policy);
        } else {
            sDeviceState.dpc().devicePolicyManager().clearUserRestriction(policy);
        }
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"main.java.com.android.bedstead.nene.users.UserReference"	"permissions"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/main/java/com/android/bedstead/nene/users/UserReference.java"	""	"public void test/*
 *.
 */

package com.android.bedstead.nene.users;

import static android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;

import android.content.Intent;
import android.os.UserHandle;

import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.exceptions.AdbException;
import com.android.bedstead.nene.exceptions.NeneException;
import com.android.bedstead.nene.permissions.PermissionContext;
import com.android.bedstead.nene.users.User.UserState;
import com.android.bedstead.nene.utils.ShellCommand;
import com.android.bedstead.nene.utils.ShellCommandUtils;
import com.android.compatibility.common.util.BlockingBroadcastReceiver;

import javax.annotation.Nullable;

/**
 * A representation of a User on device which may or may not exist.
 *
 * <p>To resolve the user into a {@link User}, see {@link #resolve()}.
 */
public abstract class UserReference implements AutoCloseable {

    private final TestApis mTestApis;
    private final int mId;

    UserReference(TestApis testApis, int id) {
        if (testApis == null) {
            throw new NullPointerException();
        }
        mTestApis = testApis;
        mId = id;
    }

    public final int id() {
        return mId;
    }

    /**
     * Get a {@link UserHandle} for the {@link #id()}.
     */
    public final UserHandle userHandle() {
        return UserHandle.of(mId);
    }

    /**
     * Get the current state of the {@link User} from the device, or {@code null} if the user does
     * not exist.
     */
    @Nullable
    public final User resolve() {
        return mTestApis.users().fetchUser(mId);
    }

    /**
     * Remove the user from the device.
     *
     * <p>If the user does not exist, or the removal fails for any other reason, a
     * {@link NeneException} will be thrown.
     */
    public final void remove() {
        // TODO(scottjonathan): There's a potential issue here as when the user is marked as
        //  ""is removing"" the DPC still can't be uninstalled because it's set as the profile owner.
        try {
            // Expected success string is ""Success: removed user""
            ShellCommand.builder(""pm remove-user"")
                    .addOperand(mId)
                    .validate(ShellCommandUtils::startsWithSuccess)
                    .execute();
            mTestApis.users().waitForUserToNotExistOrMatch(this, User::isRemoving);
        } catch (AdbException e) {
            throw new NeneException(""Could not remove user "" + this, e);
        }
    }

    /**
     * Start the user.
     *
     * <p>After calling this command, the user will be in the {@link UserState#RUNNING_UNLOCKED}
     * state.
     *
     * <p>If the user does not exist, or the start fails for any other reason, a
     * {@link NeneException} will be thrown.
     */
    //TODO(scottjonathan): Deal with users who won't unlock
    public UserReference start() {
        try {
            // Expected success string is ""Success: user started""
            ShellCommand.builder(""am start-user"")
                    .addOperand(mId)
                    .addOperand(""-w"")
                    .validate(ShellCommandUtils::startsWithSuccess)
                    .execute();
            User waitedUser = mTestApis.users().waitForUserToNotExistOrMatch(
                    this, (user) -> user.state() == UserState.RUNNING_UNLOCKED);
            if (waitedUser == null) {
                throw new NeneException(""User does not exist "" + this);
            }
        } catch (AdbException e) {
            throw new NeneException(""Could not start user "" + this, e);
        }

        return this;
    }

    /**
     * Stop the user.
     *
     * <p>After calling this command, the user will be in the {@link UserState#NOT_RUNNING} state.
     */
    public UserReference stop() {
        try {
            // Expects no output on success or failure - stderr output on failure
            ShellCommand.builder(""am stop-user"")
                    .addOperand(""-f"") // Force stop
                    .addOperand(mId)
                    .allowEmptyOutput(true)
                    .validate(String::isEmpty)
                    .execute();
            User waitedUser = mTestApis.users().waitForUserToNotExistOrMatch(
                    this, (user) -> user.state() == UserState.NOT_RUNNING);
            if (waitedUser == null) {
                throw new NeneException(""User does not exist "" + this);
            }
        } catch (AdbException e) {
            throw new NeneException(""Could not stop user "" + this, e);
        }

        return this;
    }

    /**
     * Make the user the foreground user.
     */
    public UserReference switchTo() {
        BlockingBroadcastReceiver broadcastReceiver =
                new BlockingBroadcastReceiver(mTestApis.context().instrumentedContext(),
                        Intent.ACTION_USER_FOREGROUND,
                        (intent) ->((UserHandle)
                                intent.getParcelableExtra(Intent.EXTRA_USER))
                                .getIdentifier() == mId);

        try {
            try (PermissionContext p =
                         mTestApis.permissions().withPermission(INTERACT_ACROSS_USERS_FULL)) {
                broadcastReceiver.registerForAllUsers();
            }

            // Expects no output on success or failure
            ShellCommand.builder(""am switch-user"")
                    .addOperand(mId)
                    .allowEmptyOutput(true)
                    .validate(String::isEmpty)
                    .execute();

            broadcastReceiver.awaitForBroadcast();
        } catch (AdbException e) {
            throw new NeneException(""Could not switch to user"", e);
        } finally {
            broadcastReceiver.unregisterQuietly();
        }

        return this;
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof UserReference)) {
            return false;
        }

        UserReference other = (UserReference) obj;

        return other.id() == id();
    }

    @Override
    public int hashCode() {
        return id();
    }

    /** See {@link #remove}. */
    @Override
    public void close() {
        remove();
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.ThroughputEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ThroughputEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.widget.TextView;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

@TargetApi(19)
public class ThroughputEmulatorActivity extends BaseEmulatorActivity {
    TextView mTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        mTextView = (TextView) findViewById(R.id.text);
        setupServices(this, ThroughputService.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this,
                getString(R.string.nfc_hce_throughput_emulator_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                ThroughputService.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                ThroughputService.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_throughput_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(ThroughputService.COMPONENT)) {
            long timePerApdu = duration / ThroughputService.APDU_COMMAND_SEQUENCE.length;
            if (duration < 1000) {
                mTextView.setText(""PASS. Total duration: "" + Long.toString(duration) + "" ms "" +
                        ""( "" + Long.toString(timePerApdu) + "" ms per APDU roundtrip)."");
                getPassButton().setEnabled(true);
            } else {
                mTextView.setText(""FAIL. Total duration: "" + Long.toString(duration) + "" ms "" +
                        ""("" + Long.toString(timePerApdu) + "" ms per APDU roundtrip)."" +
                        "" Require <= 60ms per APDU roundtrip."");
            }
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.provider.cts.SettingsPanelTest"	"isNull"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/SettingsPanelTest.java"	""	"public void wifiPanel_seeMoreButton_launchesIntoSettings() {
        // Launch panel
        launchWifiPanel();
        String currentPackage = mDevice.getCurrentPackageName();
        assertThat(currentPackage).isEqualTo(mSettingsPackage);

        // Click the see more button
        assumeTrue(mHasTouchScreen);
        pressSeeMore();

        UiObject2 titleView = mDevice.findObject(By.res(mSettingsPackage, RESOURCE_TITLE));
        assertThat(titleView).isNull();
    }

    private void launchVolumePanel() {
        launchPanel(Settings.Panel.ACTION_VOLUME);
    }

    private void launchInternetPanel() {
        launchPanel(Settings.Panel.ACTION_INTERNET_CONNECTIVITY);
    }

    private void launchNfcPanel() {
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC));
        launchPanel(Settings.Panel.ACTION_NFC);
    }

    private void launchWifiPanel() {
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI));
        launchPanel(Settings.Panel.ACTION_WIFI);
    }

    private void launchPanel(String action) {
        // Start from the home screen
        mDevice.pressHome();
        mDevice.wait(Until.hasObject(By.pkg(mLauncherPackage).depth(0)), TIMEOUT);

        Intent intent = new Intent(action);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                | Intent.FLAG_ACTIVITY_CLEAR_TASK);    // Clear out any previous instances
        mContext.startActivity(intent);

        // Wait for the app to appear
        mDevice.wait(Until.hasObject(By.pkg(mSettingsPackage).depth(0)), TIMEOUT);
    }

    private void pressDone() {
        if (mHasTouchScreen) {
            mDevice.findObject(By.res(mSettingsPackage, RESOURCE_DONE)).click();
            mDevice.wait(Until.hasObject(By.pkg(mLauncherPackage).depth(0)), TIMEOUT);
        } else {
            mDevice.pressBack();
        }
    }

    private void pressSeeMore() {
        mDevice.findObject(By.res(mSettingsPackage, RESOURCE_SEE_MORE)).click();
        mDevice.wait(Until.hasObject(By.pkg(mSettingsPackage).depth(0)), TIMEOUT);
    }

    private boolean isCar() {
        PackageManager pm = mContext.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }

    private boolean isWatch() {
      return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);
    }
}"	""	""	"NFC NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.quickaccesswallet.cts.WalletServiceEventTest"	"testParcel_toParcel"	"CtsQuickAccessWalletTestCases"	"/home/gpoor/cts-12-source/cts/tests/quickaccesswallet/src/android/quickaccesswallet/cts/WalletServiceEventTest.java"	""	"public void testParcel_toParcel() {
        WalletServiceEvent event = new WalletServiceEvent(TYPE_NFC_PAYMENT_STARTED);

        Parcel p = Parcel.obtain();
        event.writeToParcel(p, 0);
        p.setDataPosition(0);
        WalletServiceEvent newEvent = WalletServiceEvent.CREATOR.createFromParcel(p);
        assertThat(event.getEventType()).isEqualTo(newEvent.getEventType());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.ForegroundNonPaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ForegroundNonPaymentEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class ForegroundNonPaymentEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
    }

    @Override
    protected void onResume() {
        super.onResume();
        setupServices(this, TransportService1.COMPONENT, TransportService2.COMPONENT);
    }

    @Override
    protected void onPause() {
        super.onPause();
        mCardEmulation.unsetPreferredService(this);
    }

    @Override
    void onServicesSetup(boolean result) {
        // Tell NFC service we prefer TransportService2
        mCardEmulation.setPreferredService(this, TransportService2.COMPONENT);
        NfcDialogs.createHceTapReaderDialog(this,
                getString(R.string.nfc_hce_foreground_non_payment_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                TransportService2.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                TransportService2.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_foreground_non_payment_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(TransportService2.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }

}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.ByodHelperActivity"	"isProfileOwner"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/ByodHelperActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.os.UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES;
import static android.os.UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY;

import android.Manifest;
import android.app.Activity;
import android.app.KeyguardManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.UserManager;
import android.provider.MediaStore;
import android.util.Log;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.core.content.FileProvider;
import androidx.core.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.managedprovisioning.ByodPresentMediaDialog.DialogCallback;

import java.io.File;
import java.util.ArrayList;

/**
 * A helper activity from the managed profile side that responds to requests from CTS verifier in
 * primary user. Profile owner APIs are accessible inside this activity (given this activity is
 * started within the work profile). Its current functionalities include making sure the profile
 * owner is setup correctly, removing the work profile upon request, and verifying the image and
 * video capture functionality.
 *
 * Note: We have to use a test activity because cross-profile intents only work for activities.
 */
public class ByodHelperActivity extends Activity
        implements DialogCallback, ActivityCompat.OnRequestPermissionsResultCallback {

    static final String TAG = ""ByodHelperActivity"";

    // Primary -> managed intent: query if the profile owner has been set up.
    public static final String ACTION_QUERY_PROFILE_OWNER = ""com.android.cts.verifier.managedprovisioning.BYOD_QUERY"";
    // Managed -> primary intent: update profile owner test status in primary's CtsVerifer
    public static final String ACTION_PROFILE_OWNER_STATUS = ""com.android.cts.verifier.managedprovisioning.BYOD_STATUS"";
    // Primary -> managed intent: request to delete the current profile
    public static final String ACTION_REMOVE_MANAGED_PROFILE = ""com.android.cts.verifier.managedprovisioning.BYOD_REMOVE"";
    // Primary -> managed intent: request to capture and check an image
    public static final String ACTION_CAPTURE_AND_CHECK_IMAGE = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_IMAGE"";
    // Primary -> managed intent: request to capture and check a video with custom output path
    public static final String ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT"";
    // Primary -> managed intent: request to capture and check a video without custom output path
    public static final String ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT"";
    // Primary -> managed intent: request to capture and check an audio recording
    public static final String ACTION_CAPTURE_AND_CHECK_AUDIO = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_AUDIO"";
    public static final String ACTION_KEYGUARD_DISABLED_FEATURES =
            ""com.android.cts.verifier.managedprovisioning.BYOD_KEYGUARD_DISABLED_FEATURES"";
    public static final String ACTION_LOCKNOW =
            ""com.android.cts.verifier.managedprovisioning.BYOD_LOCKNOW"";
    public static final String ACTION_TEST_NFC_BEAM = ""com.android.cts.verifier.managedprovisioning.TEST_NFC_BEAM"";

    public static final String EXTRA_PROVISIONED = ""extra_provisioned"";
    public static final String EXTRA_PARAMETER_1 = ""extra_parameter_1"";

    // Primary -> managed intent: check if the disk of the device is encrypted
    public static final String ACTION_CHECK_DISK_ENCRYPTION =
            ""com.android.cts.verifier.managedprovisioning.action.BYOD_CHECK_DISK_ENCRYPTION"";
    // Managed -> primary intent: update disk encryption status in primary's CtsVerifier
    public static final String ACTION_DISK_ENCRYPTION_STATUS =
            ""com.android.cts.verifier.managedprovisioning.action.BYOD_DISK_ENCRYPTION_STATUS"";
    // Int extra field indicating the encryption status of the device storage
    public static final String EXTRA_ENCRYPTION_STATUS = ""extra_encryption_status"";

    // Primary -> managed intent: set unknown sources restriction and install package
    public static final String ACTION_INSTALL_APK = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK"";
    public static final String EXTRA_ALLOW_NON_MARKET_APPS = ""allow_non_market_apps"";
    public static final String ACTION_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION"";
    public static final String EXTRA_ALLOW_NON_MARKET_APPS_DEVICE_WIDE = ""allow_non_market_apps_device_wide"";

    // Primary -> managed intent: set unknown sources globally restriction
    public static final String ACTION_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION"";
    // Managed -> primary intent: install primary profile app with global unknown sources
    // restriction.
    public static final String ACTION_INSTALL_APK_IN_PRIMARY = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK_IN_PRIMARY"";

    // Primary -> managed intent: check if the required cross profile intent filters are set.
    public static final String ACTION_CHECK_INTENT_FILTERS =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_INTENT_FILTERS"";

    // Primary -> managed intent: will send a cross profile intent and check if the user sees an
    // intent picker dialog and can open the apps.
    public static final String ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG =
            ""com.android.cts.verifier.managedprovisioning.action.TEST_CROSS_PROFILE_INTENTS_DIALOG"";

    // Primary -> managed intent: will send an app link intent and check if the user sees a
    // dialog and can open the apps. This test is extremely similar to
    // ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG, but the intent used is a web intent, and there is
    // some behavior which is specific to web intents.
    public static final String ACTION_TEST_APP_LINKING_DIALOG =
            ""com.android.cts.verifier.managedprovisioning.action.TEST_APP_LINKING_DIALOG"";

    public static final String ACTION_NOTIFICATION =
            ""com.android.cts.verifier.managedprovisioning.NOTIFICATION"";
    public static final String ACTION_NOTIFICATION_ON_LOCKSCREEN =
            ""com.android.cts.verifier.managedprovisioning.LOCKSCREEN_NOTIFICATION"";
    public static final String ACTION_CLEAR_NOTIFICATION =
            ""com.android.cts.verifier.managedprovisioning.CLEAR_NOTIFICATION"";

    // Primary -> managed intent: set a user restriction
    public static final String ACTION_SET_USER_RESTRICTION =
            ""com.android.cts.verifier.managedprovisioning.BYOD_SET_USER_RESTRICTION"";

    // Primary -> managed intent: reset a user restriction
    public static final String ACTION_CLEAR_USER_RESTRICTION =
            ""com.android.cts.verifier.managedprovisioning.BYOD_CLEAR_USER_RESTRICTION"";

    // Primary -> managed intent: Start the selection of a work challenge
    public static final String ACTION_TEST_SELECT_WORK_CHALLENGE =
            ""com.android.cts.verifier.managedprovisioning.TEST_SELECT_WORK_CHALLENGE"";

    // Primary -> managed intent: Start the selection of a work challenge
    public static final String ACTION_TEST_PATTERN_WORK_CHALLENGE =
            ""com.android.cts.verifier.managedprovisioning.TEST_PATTERN_WORK_CHALLENGE"";

    // Primary -> managed intent: Start the selection of a parent profile password.
    public static final String ACTION_TEST_PARENT_PROFILE_PASSWORD =
            ""com.android.cts.verifier.managedprovisioning.TEST_PARENT_PROFILE_PASSWORD"";

    // Primary -> managed intent: Start the confirm credentials screen for the managed profile
    public static final String ACTION_LAUNCH_CONFIRM_WORK_CREDENTIALS =
            ""com.android.cts.verifier.managedprovisioning.LAUNCH_CONFIRM_WORK_CREDENTIALS"";

    public static final String ACTION_SET_ORGANIZATION_INFO =
            ""com.android.cts.verifier.managedprovisioning.TEST_ORGANIZATION_INFO"";

    public static final int RESULT_FAILED = RESULT_FIRST_USER;

    private static final int REQUEST_INSTALL_PACKAGE = 2;
    private static final int REQUEST_IMAGE_CAPTURE = 3;
    private static final int REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT = 4;
    private static final int REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT = 5;
    private static final int REQUEST_AUDIO_CAPTURE = 6;

    private static final String ORIGINAL_RESTRICTIONS_NAME = ""original restrictions"";

    private static final int NOTIFICATION_ID = 7;
    private static final String NOTIFICATION_CHANNEL_ID = TAG;

    private static final int EXECUTE_IMAGE_CAPTURE_TEST = 1;
    private static final int EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST = 2;
    private static final int EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST = 3;

    private NotificationManager mNotificationManager;
    private Bundle mOriginalRestrictions;

    private ComponentName mAdminReceiverComponent;
    private DevicePolicyManager mDevicePolicyManager;

    private Uri mImageUri;
    private Uri mVideoUri;
    private File mImageFile;

    private ArrayList<File> mTempFiles = new ArrayList<File>();

    private Handler mMainThreadHandler;

    private void showNotification(int visibility) {
        final Notification notification = new Notification.Builder(this, NOTIFICATION_CHANNEL_ID)
                .setSmallIcon(R.drawable.icon)
                .setContentTitle(getString(R.string.provisioning_byod_notification_title))
                .setContentText(getString(R.string.provisioning_byod_notification_title))
                .setVisibility(visibility)
                .setAutoCancel(true)
                .setPublicVersion(createPublicVersionNotification())
                .build();
        mNotificationManager.notify(NOTIFICATION_ID, notification);
    }

    private Notification createPublicVersionNotification() {
        return new Notification.Builder(this)
                .setSmallIcon(R.drawable.icon)
                .setContentTitle(getString(R.string.provisioning_byod_notification_public_title))
                .setAutoCancel(true)
                .build();
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mMainThreadHandler = new Handler(getMainLooper());
        if (savedInstanceState != null) {
            Log.w(TAG, ""Restored state"");
            mOriginalRestrictions = savedInstanceState.getBundle(ORIGINAL_RESTRICTIONS_NAME);
        } else {
            mOriginalRestrictions = new Bundle();
        }

        mAdminReceiverComponent = new ComponentName(this, DeviceAdminTestReceiver.class.getName());
        mDevicePolicyManager = (DevicePolicyManager) getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        Intent intent = getIntent();
        String action = intent.getAction();
        Log.d(TAG, ""ByodHelperActivity.onCreate: "" + action);
        mNotificationManager.createNotificationChannel(new NotificationChannel(
                NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_ID,
                NotificationManager.IMPORTANCE_DEFAULT));

        // Queried by CtsVerifier in the primary side using startActivityForResult.
        if (action.equals(ACTION_QUERY_PROFILE_OWNER)) {
            Intent response = new Intent();
            response.putExtra(EXTRA_PROVISIONED, isProfileOwner());
            setResult(RESULT_OK, response);
            // Request to delete work profile.
        } else if (action.equals(ACTION_REMOVE_MANAGED_PROFILE)) {
            if (isProfileOwner()) {
                Log.d(TAG, ""Clearing cross profile intents"");
                mDevicePolicyManager.clearCrossProfileIntentFilters(mAdminReceiverComponent);
                mDevicePolicyManager.wipeData(0);
                showToast(R.string.provisioning_byod_profile_deleted);
            }
        } else if (action.equals(ACTION_CHECK_DISK_ENCRYPTION)) {
            final int status = mDevicePolicyManager.getStorageEncryptionStatus();
            final Intent response = new Intent(ACTION_DISK_ENCRYPTION_STATUS)
                    .putExtra(EXTRA_ENCRYPTION_STATUS, status);
            setResult(RESULT_OK, response);
        } else if (action.equals(ACTION_INSTALL_APK)) {
            boolean allowNonMarket = intent.getBooleanExtra(EXTRA_ALLOW_NON_MARKET_APPS, false);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES, !allowNonMarket);
            startInstallerActivity(intent.getStringExtra(EXTRA_PARAMETER_1));
            // Not yet ready to finish - wait until the result comes back
            return;
        } else if (action.equals(ACTION_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION)) {
            // Save original unknown sources setting to be restored later and clear it for now.
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES, false);
            boolean allowNonMarketGlobal = intent.getBooleanExtra(
                    EXTRA_ALLOW_NON_MARKET_APPS_DEVICE_WIDE, false);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
                    !allowNonMarketGlobal);
            startInstallerActivity(intent.getStringExtra(EXTRA_PARAMETER_1));
            // Not yet ready to finish - wait until the result comes back
            return;
        } else if (action.equals(ACTION_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION)) {
            boolean allowNonMarketGlobal = intent.getExtras().getBoolean(
                    EXTRA_ALLOW_NON_MARKET_APPS_DEVICE_WIDE, false);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
                    !allowNonMarketGlobal);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES, false);
            Intent installPersonalProfileIntent = new Intent(ACTION_INSTALL_APK_IN_PRIMARY);
            // Attempt to install an apk in the primary profile
            startActivityForResult(installPersonalProfileIntent, REQUEST_INSTALL_PACKAGE);
            return;
        } else if (action.equals(ACTION_CHECK_INTENT_FILTERS)) {
            // Queried by CtsVerifier in the primary side using startActivityForResult.
            final boolean intentFiltersSetForManagedIntents =
                    new IntentFiltersTestHelper(this).checkCrossProfileIntentFilters(
                            IntentFiltersTestHelper.FLAG_INTENTS_FROM_MANAGED);
            setResult(intentFiltersSetForManagedIntents? RESULT_OK : RESULT_FAILED, null);
        } else if (action.equals(ACTION_CAPTURE_AND_CHECK_IMAGE)) {
            if (hasCameraPermission()) {
                startCaptureImageIntent();
            } else {
                requestCameraPermission(EXECUTE_IMAGE_CAPTURE_TEST);
            }
            return;
        } else if (action.equals(ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT) ||
                action.equals(ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT)) {
            final int testRequestCode;
            if (action.equals(ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT)) {
                testRequestCode = EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST;
            } else {
                testRequestCode = EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST;
            }

            if (hasCameraPermission()) {
                startCaptureVideoActivity(testRequestCode);
            } else {
                requestCameraPermission(testRequestCode);
            }
            return;
        } else if (action.equals(ACTION_CAPTURE_AND_CHECK_AUDIO)) {
            Intent captureAudioIntent = getCaptureAudioIntent();
            if (captureAudioIntent.resolveActivity(getPackageManager()) != null) {
                startActivityForResult(captureAudioIntent, REQUEST_AUDIO_CAPTURE);
            } else {
                Log.e(TAG, ""Capture audio intent could not be resolved in managed profile."");
                showToast(R.string.provisioning_byod_capture_media_error);
                finish();
            }
            return;
        } else if (ACTION_KEYGUARD_DISABLED_FEATURES.equals(action)) {
            final int value = intent.getIntExtra(EXTRA_PARAMETER_1,
                    DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_NONE);
            mDevicePolicyManager.setKeyguardDisabledFeatures(mAdminReceiverComponent, value);
        } else if (ACTION_LOCKNOW.equals(action)) {
            mDevicePolicyManager.lockNow();
            setResult(RESULT_OK);
        } else if (action.equals(ACTION_TEST_NFC_BEAM)) {
            Intent testNfcBeamIntent = new Intent(this, NfcTestActivity.class);
            testNfcBeamIntent.putExtras(intent);
            startActivity(testNfcBeamIntent);
            finish();
            return;
        } else if (action.equals(ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG)) {
            sendIntentInsideChooser(new Intent(
                    CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_PERSONAL));
        } else if (action.equals(ACTION_TEST_APP_LINKING_DIALOG)) {
            mDevicePolicyManager.addUserRestriction(
                    DeviceAdminTestReceiver.getReceiverComponentName(),
                    UserManager.ALLOW_PARENT_PROFILE_APP_LINKING);
            Intent toSend = new Intent(Intent.ACTION_VIEW);
            toSend.setData(Uri.parse(""http://com.android.cts.verifier""));
            sendIntentInsideChooser(toSend);
        } else if (action.equals(ACTION_SET_USER_RESTRICTION)) {
            final String restriction = intent.getStringExtra(EXTRA_PARAMETER_1);
            if (restriction != null) {
                mDevicePolicyManager.addUserRestriction(
                        DeviceAdminTestReceiver.getReceiverComponentName(), restriction);
            }
        } else if (action.equals(ACTION_CLEAR_USER_RESTRICTION)) {
            final String restriction = intent.getStringExtra(EXTRA_PARAMETER_1);
            if (restriction != null) {
                mDevicePolicyManager.clearUserRestriction(
                        DeviceAdminTestReceiver.getReceiverComponentName(), restriction);
            }
        } else if (action.equals(ACTION_NOTIFICATION)) {
            showNotification(Notification.VISIBILITY_PUBLIC);
        } else if (ACTION_NOTIFICATION_ON_LOCKSCREEN.equals(action)) {
            mDevicePolicyManager.lockNow();
            showNotification(Notification.VISIBILITY_PRIVATE);
        } else if (ACTION_CLEAR_NOTIFICATION.equals(action)) {
            mNotificationManager.cancel(NOTIFICATION_ID);
        } else if (ACTION_TEST_SELECT_WORK_CHALLENGE.equals(action)) {
            mDevicePolicyManager.setOrganizationName(mAdminReceiverComponent, getResources()
                    .getString(R.string.provisioning_byod_confirm_work_credentials_header));
            startActivity(new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD));
        } else if (ACTION_LAUNCH_CONFIRM_WORK_CREDENTIALS.equals(action)) {
            KeyguardManager keyguardManager =
                    (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);
            Intent launchIntent = keyguardManager.createConfirmDeviceCredentialIntent(null, null);
            if (launchIntent != null) {
                startActivity(launchIntent);
            } else {
                showToast(R.string.provisioning_byod_no_secure_lockscreen);
            }
        } else if (ACTION_TEST_PATTERN_WORK_CHALLENGE.equals(action)) {
            startActivity(new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD));
            // The remaining steps are manual.
        } else if (ACTION_SET_ORGANIZATION_INFO.equals(action)) {
            if(intent.hasExtra(OrganizationInfoTestActivity.EXTRA_ORGANIZATION_NAME)) {
                final String organizationName = intent
                        .getStringExtra(OrganizationInfoTestActivity.EXTRA_ORGANIZATION_NAME);
                mDevicePolicyManager.setOrganizationName(mAdminReceiverComponent, organizationName);
            }
        } else if (ACTION_TEST_PARENT_PROFILE_PASSWORD.equals(action)) {
            startActivity(new Intent(DevicePolicyManager.ACTION_SET_NEW_PARENT_PROFILE_PASSWORD));
        }
        // This activity has no UI and is only used to respond to CtsVerifier in the primary side.
        finish();
    }

    private void startCaptureVideoActivity(int testRequestCode) {
        Intent captureVideoIntent = getCaptureVideoIntent();
        int videoCaptureRequestId;
        if (testRequestCode == EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST) {
            mVideoUri = getTempUri(""video.mp4"").second;
            captureVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, mVideoUri);
            videoCaptureRequestId = REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT;
        } else {
            videoCaptureRequestId = REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT;
        }
        if (captureVideoIntent.resolveActivity(getPackageManager()) != null) {
            startActivityForResult(captureVideoIntent, videoCaptureRequestId);
        } else {
            Log.e(TAG, ""Capture video intent could not be resolved in managed profile."");
            showToast(R.string.provisioning_byod_capture_media_error);
            finish();
        }
    }

    private void startCaptureImageIntent() {
        Intent captureImageIntent = getCaptureImageIntent();
        Pair<File, Uri> pair = getTempUri(""image.jpg"");
        mImageFile = pair.first;
        mImageUri = pair.second;
        captureImageIntent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);
        if (captureImageIntent.resolveActivity(getPackageManager()) != null) {
            startActivityForResult(captureImageIntent, REQUEST_IMAGE_CAPTURE);
        } else {
            Log.e(TAG, ""Capture image intent could not be resolved in managed profile."");
            showToast(R.string.provisioning_byod_capture_media_error);
            finish();
        }
    }

    private void startInstallerActivity(String pathToApk) {
        // Start the installer activity until this activity is rendered to workaround a glitch.
        mMainThreadHandler.post(() -> {
            final Uri uri;
            if (pathToApk == null) {
                // By default we reinstall ourselves, e.g. request to install a non-market app
                uri = Uri.parse(""package:"" + getPackageName());
            } else {
                uri = FileProvider.getUriForFile(
                    this, Utils.FILE_PROVIDER_AUTHORITY, new File(pathToApk));
            }
            final Intent installIntent = new Intent(Intent.ACTION_INSTALL_PACKAGE)
                .setData(uri)
                .putExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, true)
                .addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                .putExtra(Intent.EXTRA_RETURN_RESULT, true);
            startActivityForResult(installIntent, REQUEST_INSTALL_PACKAGE);
        });
    }

    @Override
    protected void onSaveInstanceState(final Bundle savedState) {
        super.onSaveInstanceState(savedState);

        savedState.putBundle(ORIGINAL_RESTRICTIONS_NAME, mOriginalRestrictions);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_INSTALL_PACKAGE: {
                Log.w(TAG, ""Received REQUEST_INSTALL_PACKAGE, resultCode = "" + resultCode);
                // Restore original settings for restrictions being changed before installs.
                restoreOriginalRestriction(DISALLOW_INSTALL_UNKNOWN_SOURCES);
                restoreOriginalRestriction(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY);
                finish();
                break;
            }
            case REQUEST_IMAGE_CAPTURE: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newImageInstance(mImageFile)
                            .show(getFragmentManager(), ""ViewImageDialogFragment"");
                } else {
                    // Failed capturing image.
                    finish();
                }
                break;
            }
            case REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newVideoInstance(mVideoUri)
                            .show(getFragmentManager(), ""PlayVideoDialogFragment"");
                } else {
                    // Failed capturing video.
                    finish();
                }
                break;
            }
            case REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newVideoInstance(data.getData())
                            .show(getFragmentManager(), ""PlayVideoDialogFragment"");
                } else {
                    // Failed capturing video.
                    finish();
                }
                break;
            }
            case REQUEST_AUDIO_CAPTURE: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newAudioInstance(data.getData())
                            .show(getFragmentManager(), ""PlayAudioDialogFragment"");
                } else {
                    // Failed capturing audio.
                    finish();
                }
                break;
            }
            default: {
                super.onActivityResult(requestCode, resultCode, data);
                break;
            }
        }
    }

    @Override
    protected void onDestroy() {
        cleanUpTempUris();
        super.onDestroy();
    }

    public static Intent getCaptureImageIntent() {
        return new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    }

    public static Intent getCaptureVideoIntent() {
        return new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
    }

    public static Intent getCaptureAudioIntent() {
        return new Intent(MediaStore.Audio.Media.RECORD_SOUND_ACTION);
    }

    public static Intent createLockIntent() {
        return new Intent(ACTION_LOCKNOW);
    }

    private Pair<File, Uri> getTempUri(String fileName) {
        final File file = new File(getFilesDir() + File.separator + ""images""
                + File.separator + fileName);
        file.getParentFile().mkdirs(); //if the folder doesn't exists it is created
        mTempFiles.add(file);
        return new Pair<>(file, FileProvider.getUriForFile(
                this, Utils.FILE_PROVIDER_AUTHORITY, file));
    }

    private void cleanUpTempUris() {
        for (File file : mTempFiles) {
            file.delete();
        }
    }

    private boolean isProfileOwner() {
        return mDevicePolicyManager.isAdminActive(mAdminReceiverComponent) &&
                mDevicePolicyManager.isProfileOwnerApp(mAdminReceiverComponent.getPackageName());
    }

    private boolean isRestrictionSet(String restriction) {
        Bundle restrictions = mDevicePolicyManager.getUserRestrictions(mAdminReceiverComponent);
        // This defaults to false if there is no value already there. If a restriction was true,
        // the restriction would already be set.
        return restrictions.getBoolean(restriction, false);
    }

    private void setRestriction(String restriction, boolean enabled) {
        if (enabled) {
            mDevicePolicyManager.addUserRestriction(mAdminReceiverComponent, restriction);
        } else {
            mDevicePolicyManager.clearUserRestriction(mAdminReceiverComponent, restriction);
        }
    }

    private void setRestrictionAndSaveOriginal(String restriction, boolean enabled) {
        // Saves original restriction values in mOriginalRestrictions before changing its value.
        boolean original = isRestrictionSet(restriction);
        if (enabled != original) {
            setRestriction(restriction, enabled);
            mOriginalRestrictions.putBoolean(restriction, original);
        }
    }

    public void restoreOriginalRestriction(String restriction) {
        if (mOriginalRestrictions.containsKey(restriction)) {
            setRestriction(restriction, mOriginalRestrictions.getBoolean(restriction));
            mOriginalRestrictions.remove(restriction);
        }
    }

    private boolean hasCameraPermission() {
        return ContextCompat.checkSelfPermission(this, android.Manifest.permission.CAMERA)
                == PackageManager.PERMISSION_GRANTED;
    }

    private void requestCameraPermission(int requestCode) {
        ActivityCompat.requestPermissions(this, new String[]{android.Manifest.permission.CAMERA},
                requestCode);
    }

    private boolean hasLocationPermission() {
        return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
                == PackageManager.PERMISSION_GRANTED;
    }

    private void requestLocationPermission(int requestCode) {
        ActivityCompat.requestPermissions(this,
                new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
                requestCode);
    }

    /**
     * Launch the right test based on the request code, after validating the right permission
     * has been granted.
     */
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
            @NonNull int[] grants) {
        // Test that the right permission was granted.
        switch(requestCode) {
            case EXECUTE_IMAGE_CAPTURE_TEST:
            case EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST:
            case EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST:
                if (!permissions[0].equals(android.Manifest.permission.CAMERA)
                        || grants[0] != PackageManager.PERMISSION_GRANTED) {
                    Log.e(TAG, ""The test needs camera permission."");
                    showToast(R.string.provisioning_byod_capture_media_error);
                    finish();
                    return;
                }
                break;
        }

        // Execute the right test.
        switch (requestCode) {
            case EXECUTE_IMAGE_CAPTURE_TEST:
                startCaptureImageIntent();
                break;
            case EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST:
            case EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST:
                startCaptureVideoActivity(requestCode);
                break;
            default:
                Log.e(TAG, ""Unknown action."");
                finish();
        }
    }

    private void sendIntentInsideChooser(Intent toSend) {
        toSend.putExtra(CrossProfileTestActivity.EXTRA_STARTED_FROM_WORK, true);
        Intent chooser = Intent.createChooser(toSend,
                getResources().getString(R.string.provisioning_cross_profile_chooser));
        startActivity(chooser);
    }

    @Override
    public void onDialogClose() {
        finish();
    }

    private void showToast(int messageId) {
        String message = getString(messageId);
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.NfcTest"	"testNfcShareDisabled"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/NfcTest.java"	""	"public void testNfcShareDisabled() throws Exception {
        Intent intent = getTextShareIntent();
        // After the ""no_outgoing_beam"" configuration item is modified, it takes a while
        // until NFC receives the DEVICE_POLICY_MANAGER_STATE_CHANGED broadcast
        waitForNfcBeamActivityDisabled(intent, NFC_RESOLVE_TIMEOUT_MILLIS);
        assertFalse(""Nfc beam activity should not be resolved"", isNfcBeamActivityResolved(intent));
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.NfcTest"	"testNfcShareEnabled"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/NfcTest.java"	""	"public void testNfcShareEnabled() throws Exception {
        Intent intent = getTextShareIntent();
        assertTrue(""Nfc beam activity should be resolved"", isNfcBeamActivityResolved(intent));
    }

    private void waitForNfcBeamActivityDisabled(Intent intent, int maxDelayMillis)
            throws Exception {
        int totalDelayedMillis = 0;
        while (isNfcBeamActivityResolved(intent) && totalDelayedMillis <= maxDelayMillis) {
            Thread.sleep(NFC_RESOLVE_TIME_STEP_MILLIS);
            totalDelayedMillis += NFC_RESOLVE_TIME_STEP_MILLIS;
        }
    }

    private Intent getTextShareIntent() {
        Intent intent = new Intent();
        intent.setAction(Intent.ACTION_SEND);
        intent.putExtra(Intent.EXTRA_TEXT, SAMPLE_TEXT);
        intent.setType(TEXT_MIME_TYPE);
        return intent;
    }

    private boolean isNfcBeamActivityResolved(Intent intent) {
        PackageManager pm = mContext.getPackageManager();
        for (ResolveInfo resolveInfo : pm.queryIntentActivities(intent, 0)) {
            if (NFC_BEAM_ACTIVITY.equals(resolveInfo.activityInfo.name)) {
                return true;
            }
        }

        return false;
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.media.cts.DecoderTest"	"testTrackSelectionMkv"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/DecoderTest.java"	""	"public void testTrackSelectionMkv() throws Exception {
        Log.d(TAG, ""testTrackSelectionMkv!!!!!! "");
        testTrackSelection(""mkv_avc_adpcm_ima.mkv"");
        Log.d(TAG, ""mkv_avc_adpcm_ima finished!!!!!! "");
        testTrackSelection(""mkv_avc_adpcm_ms.mkv"");
        Log.d(TAG, ""mkv_avc_adpcm_ms finished!!!!!! "");
        testTrackSelection(""mkv_avc_wma.mkv"");
        Log.d(TAG, ""mkv_avc_wma finished!!!!!! "");
        testTrackSelection(""mkv_avc_mp2.mkv"");
        Log.d(TAG, ""mkv_avc_mp2 finished!!!!!! "");
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.LargeNumAidsEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/LargeNumAidsEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.nfc.cardemulation.CardEmulation;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

import java.util.ArrayList;

public class LargeNumAidsEmulatorActivity extends BaseEmulatorActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.pass_fail_text);
       setPassFailButtonClickListeners();
       getPassButton().setEnabled(false);
       setupServices(this, LargeNumAidsService.COMPONENT);
    }


    @Override
    protected void onResume() {
        super.onResume();
    }


    @Override
    void onServicesSetup(boolean result) {
        ArrayList<String> aids = new ArrayList<String>();
        for (int i = 0; i < 256; i++) {
            aids.add(HceUtils.LARGE_NUM_AIDS_PREFIX + String.format(""%02X"", i) + HceUtils.LARGE_NUM_AIDS_POSTFIX);
        }
        mCardEmulation.registerAidsForService(LargeNumAidsService.COMPONENT,
                CardEmulation.CATEGORY_OTHER, aids);
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(LargeNumAidsService.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                LargeNumAidsService.getCommandSequence());
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                LargeNumAidsService.getResponseSequence());
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_large_num_aids_reader));
        return readerIntent;
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.HceEmulatorTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/HceEmulatorTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.hce;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.nfc.NfcAdapter;
import android.nfc.cardemulation.CardEmulation;
import android.os.Build;
import android.os.Bundle;

/** Activity that lists all the NFC HCE emulator tests. */
public class HceEmulatorTestActivity extends PassFailButtons.TestListActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.nfc_test, R.string.nfc_hce_emulator_test_info, 0);
        setPassFailButtonClickListeners();

        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);

        NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
        CardEmulation cardEmulation = CardEmulation.getInstance(nfcAdapter);
        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
            adapter.add(TestListItem.newCategory(this, R.string.nfc_hce_emulator_tests));

            /*
             * Only add this test when supported in platform
            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_default_route_emulator,
                    DefaultRouteEmulatorActivity.class.getName(),
                    new Intent(this, DefaultRouteEmulatorActivity.class), null));
            */
            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_protocol_params_emulator,
                    ProtocolParamsEmulatorActivity.class.getName(),
                    new Intent(this, ProtocolParamsEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_single_payment_emulator,
                    SinglePaymentEmulatorActivity.class.getName(),
                    new Intent(this, SinglePaymentEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_dual_payment_emulator,
                    DualPaymentEmulatorActivity.class.getName(),
                    new Intent(this, DualPaymentEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_change_default_emulator,
                    ChangeDefaultEmulatorActivity.class.getName(),
                    new Intent(this, ChangeDefaultEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_foreground_payment_emulator,
                    ForegroundPaymentEmulatorActivity.class.getName(),
                    new Intent(this, ForegroundPaymentEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_single_non_payment_emulator,
                    SingleNonPaymentEmulatorActivity.class.getName(),
                    new Intent(this, SingleNonPaymentEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_dual_non_payment_emulator,
                    DualNonPaymentEmulatorActivity.class.getName(),
                    new Intent(this, DualNonPaymentEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_conflicting_non_payment_emulator,
                    ConflictingNonPaymentEmulatorActivity.class.getName(),
                    new Intent(this, ConflictingNonPaymentEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_foreground_non_payment_emulator,
                    ForegroundNonPaymentEmulatorActivity.class.getName(),
                    new Intent(this, ForegroundNonPaymentEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_throughput_emulator,
                    ThroughputEmulatorActivity.class.getName(),
                    new Intent(this, ThroughputEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_tap_test_emulator,
                    TapTestEmulatorActivity.class.getName(),
                    new Intent(this, TapTestEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_offhost_service_emulator,
                    OffHostEmulatorActivity.class.getName(),
                    new Intent(this, OffHostEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_on_and_offhost_service_emulator,
                    OnAndOffHostEmulatorActivity.class.getName(),
                    new Intent(this, OnAndOffHostEmulatorActivity.class), null));

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                adapter.add(TestListItem.newTest(this, R.string.nfc_hce_large_num_aids_emulator,
                        LargeNumAidsEmulatorActivity.class.getName(),
                        new Intent(this, LargeNumAidsEmulatorActivity.class), null));

                adapter.add(TestListItem.newTest(this, R.string.nfc_hce_payment_dynamic_aids_emulator,
                        DynamicAidEmulatorActivity.class.getName(),
                        new Intent(this, DynamicAidEmulatorActivity.class), null));

                if (cardEmulation.supportsAidPrefixRegistration()) {
                    adapter.add(TestListItem.newTest(this, R.string.nfc_hce_payment_prefix_aids_emulator,
                            PrefixPaymentEmulatorActivity.class.getName(),
                            new Intent(this, PrefixPaymentEmulatorActivity.class), null));

                    adapter.add(TestListItem.newTest(this, R.string.nfc_hce_payment_prefix_aids_emulator_2,
                            PrefixPaymentEmulator2Activity.class.getName(),
                            new Intent(this, PrefixPaymentEmulator2Activity.class), null));

                    adapter.add(TestListItem.newTest(this, R.string.nfc_hce_other_prefix_aids_emulator,
                            DualNonPaymentPrefixEmulatorActivity.class.getName(),
                            new Intent(this, DualNonPaymentPrefixEmulatorActivity.class), null));

                    adapter.add(TestListItem.newTest(this, R.string.nfc_hce_other_conflicting_prefix_aids_emulator,
                            ConflictingNonPaymentPrefixEmulatorActivity.class.getName(),
                            new Intent(this, ConflictingNonPaymentPrefixEmulatorActivity.class), null));
                }
            }

            adapter.add(TestListItem.newTest(this, R.string.nfc_screen_on_only_offhost_emulator,
                    ScreenOnOnlyOffHostEmulatorActivity.class.getName(),
                    new Intent(this, ScreenOnOnlyOffHostEmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_screen_off_hce_payment_emulator,
                    ScreenOffPaymentEmulatorActivity.class.getName(),
                    new Intent(this, ScreenOffPaymentEmulatorActivity.class), null));
        }

        setTestListAdapter(adapter);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2022"	"testPocCVE_2019_2022"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2022.java"	""	"@AsbSecurityTest(cveBugId = 120506143)
    public void testPocCVE_2019_2022() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2022"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"TestApis"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"/*
 *.
 */

package android.devicepolicy.cts;

import static android.app.ActivityManager.LOCK_TASK_MODE_LOCKED;
import static android.app.ActivityManager.LOCK_TASK_MODE_NONE;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_HOME;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_KEYGUARD;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_NONE;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_NOTIFICATIONS;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_OVERVIEW;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_SYSTEM_INFO;
import static android.content.Intent.ACTION_DIAL;
import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK;
import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
import static android.content.pm.PackageManager.FEATURE_TELEPHONY;

import static com.android.queryable.queries.StringQuery.string;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeFalse;
import static org.testng.Assert.assertThrows;

import android.app.ActivityOptions;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.os.Bundle;
import android.stats.devicepolicy.EventId;
import android.telecom.TelecomManager;

import com.android.bedstead.harrier.BedsteadJUnit4;
import com.android.bedstead.harrier.DeviceState;
import com.android.bedstead.harrier.annotations.Postsubmit;
import com.android.bedstead.harrier.annotations.RequireFeature;
import com.android.bedstead.harrier.annotations.enterprise.CannotSetPolicyTest;
import com.android.bedstead.harrier.annotations.enterprise.NegativePolicyTest;
import com.android.bedstead.harrier.annotations.enterprise.PositivePolicyTest;
import com.android.bedstead.harrier.policies.LockTask;
import com.android.bedstead.metricsrecorder.EnterpriseMetricsRecorder;
import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.activities.Activity;
import com.android.bedstead.nene.packages.ComponentReference;
import com.android.bedstead.nene.packages.PackageReference;
import com.android.bedstead.remotedpc.RemoteDpc;
import com.android.bedstead.testapp.TestApp;
import com.android.bedstead.testapp.TestAppActivity;
import com.android.bedstead.testapp.TestAppActivityReference;
import com.android.bedstead.testapp.TestAppInstanceReference;
import com.android.bedstead.testapp.TestAppProvider;
import com.android.compatibility.common.util.PollingCheck;
import com.android.eventlib.EventLogs;
import com.android.eventlib.events.activities.ActivityDestroyedEvent;
import com.android.eventlib.events.activities.ActivityStartedEvent;

import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Set;

@RunWith(BedsteadJUnit4.class)
public class LockTaskTest {

    private static final String PACKAGE_NAME = ""com.android.package.test"";

    @ClassRule @Rule
    public static final DeviceState sDeviceState = new DeviceState();

    private static final TestApis sTestApis = new TestApis();

    private static final DevicePolicyManager sLocalDevicePolicyManager =
            sTestApis.context().instrumentedContext().getSystemService(DevicePolicyManager.class);

    private static final int[] INDIVIDUALLY_SETTABLE_FLAGS = new int[] {
            LOCK_TASK_FEATURE_SYSTEM_INFO,
            LOCK_TASK_FEATURE_HOME,
            LOCK_TASK_FEATURE_GLOBAL_ACTIONS,
            LOCK_TASK_FEATURE_KEYGUARD
    };

    private static final int[] FLAGS_SETTABLE_WITH_HOME = new int[] {
            LOCK_TASK_FEATURE_SYSTEM_INFO,
            LOCK_TASK_FEATURE_OVERVIEW,
            LOCK_TASK_FEATURE_NOTIFICATIONS,
            LOCK_TASK_FEATURE_GLOBAL_ACTIONS,
            LOCK_TASK_FEATURE_KEYGUARD
    };

    private static final TestAppProvider sTestAppProvider = new TestAppProvider();
    private static final TestApp sLockTaskTestApp = sTestAppProvider.query()
            .wherePackageName().isEqualTo(""android.LockTaskApp"")
            .get(); // TODO(scottjonathan): filter by containing activity not by package name
    private static final TestApp sTestApp = sTestAppProvider.any();

    private static final TestApp sSecondTestApp = sTestAppProvider.any();

    private static final ComponentReference BLOCKED_ACTIVITY_COMPONENT =
            sTestApis.packages().component(new ComponentName(
                    ""android"", ""com.android.internal.app.BlockedAppActivity""));

    private static final String ACTION_EMERGENCY_DIAL = ""com.android.phone.EmergencyDialer.DIAL"";"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"setLockTaskPackages_lockTaskPackagesIsSet"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void setLockTaskPackages_lockTaskPackagesIsSet() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{PACKAGE_NAME});

        try {
            assertThat(sDeviceState.dpc().devicePolicyManager().getLockTaskPackages()).asList()
                    .containsExactly(PACKAGE_NAME);
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"isTrue"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void startLockTask_recordsMetric() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        try (EnterpriseMetricsRecorder metrics = EnterpriseMetricsRecorder.create();
             TestAppInstanceReference testApp = sTestApp.install(sTestApis.users().instrumented())){
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{sTestApp.packageName()});
            Activity<TestAppActivity> activity = testApp.activities().any().start();

            try {
                activity.startLockTask();

                // TODO(b/191745956): Improve metrics query interface
                assertThat(metrics.query()
                        .whereType().isEqualTo(EventId.SET_LOCKTASK_MODE_ENABLED_VALUE)
                        .whereAdminPackageName().isEqualTo(
                                RemoteDpc.DPC_COMPONENT_NAME.getPackageName())
                        .whereBoolean().isTrue()
                        .whereStrings().contains(
                                string().isEqualTo(sTestApp.packageName())
                        )
                        .poll()).isNotNull();
            } finally {
                activity.stopLockTask();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"getLockTaskPackages_policyIsNotAllowedToBeFetched_throwsException"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @CannotSetPolicyTest(policy = LockTask.class)
    public void getLockTaskPackages_policyIsNotAllowedToBeFetched_throwsException() {
        assertThrows(SecurityException.class,
                () -> sDeviceState.dpc().devicePolicyManager().getLockTaskPackages());
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"setLockTaskPackages_empty_lockTaskPackagesIsSet"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void setLockTaskPackages_empty_lockTaskPackagesIsSet() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{});

        try {
            assertThat(sDeviceState.dpc().devicePolicyManager().getLockTaskPackages()).asList()
                    .isEmpty();
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"setLockTaskPackages_includesPolicyExemptApp_lockTaskPackagesIsSet"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void setLockTaskPackages_includesPolicyExemptApp_lockTaskPackagesIsSet() {
        Set<String> policyExemptApps = sTestApis.devicePolicy().getPolicyExemptApps();
        assumeFalse(""OEM does not define any policy-exempt apps"",
                policyExemptApps.isEmpty());
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();
        String policyExemptApp = policyExemptApps.iterator().next();

        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{policyExemptApp});

        try {
            assertThat(sDeviceState.dpc().devicePolicyManager().getLockTaskPackages()).asList()
                    .containsExactly(policyExemptApp);
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"setLockTaskPackages_policyIsNotAllowedToBeSet_throwsException"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @CannotSetPolicyTest(policy = LockTask.class)
    public void setLockTaskPackages_policyIsNotAllowedToBeSet_throwsException() {
        assertThrows(SecurityException.class,
                () -> sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{}));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"isLockTaskPermitted_lockTaskPackageIsSet_returnsTrue"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void isLockTaskPermitted_lockTaskPackageIsSet_returnsTrue() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{PACKAGE_NAME});

        try {
            assertThat(sLocalDevicePolicyManager.isLockTaskPermitted(PACKAGE_NAME)).isTrue();
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"isLockTaskPermitted_lockTaskPackageIsSet_policyDoesntApply_returnsFalse"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @NegativePolicyTest(policy = LockTask.class)
    // TODO(scottjonathan): Confirm expected behaviour here
    public void isLockTaskPermitted_lockTaskPackageIsSet_policyDoesntApply_returnsFalse() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{PACKAGE_NAME});

        try {
            assertThat(sLocalDevicePolicyManager.isLockTaskPermitted(PACKAGE_NAME)).isFalse();
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"isLockTaskPermitted_lockTaskPackageIsNotSet_returnsFalse"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void isLockTaskPermitted_lockTaskPackageIsNotSet_returnsFalse() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{});

        try {
            assertThat(sLocalDevicePolicyManager.isLockTaskPermitted(PACKAGE_NAME)).isFalse();
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"isLockTaskPermitted_includesPolicyExemptApps"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void isLockTaskPermitted_includesPolicyExemptApps() {
        Set<String> policyExemptApps = sTestApis.devicePolicy().getPolicyExemptApps();
        // TODO(b/188035301): Add a unit test which ensures this actually gets tested
        assumeFalse(""OEM does not define any policy-exempt apps"",
                policyExemptApps.isEmpty());
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        try {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{});

            for (String app : policyExemptApps) {
                assertWithMessage(""isLockTaskPermitted(%s)"", app)
                        .that(sLocalDevicePolicyManager.isLockTaskPermitted(app)).isTrue();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"setLockTaskFeatures_policyIsNotAllowedToBeSet_throwsException"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @CannotSetPolicyTest(policy = LockTask.class)
    public void setLockTaskFeatures_policyIsNotAllowedToBeSet_throwsException() {
        assertThrows(SecurityException.class, () ->
                sDeviceState.dpc().devicePolicyManager().setLockTaskFeatures(LOCK_TASK_FEATURE_NONE));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"getLockTaskFeatures_policyIsNotAllowedToBeFetched_throwsException"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @CannotSetPolicyTest(policy = LockTask.class)
    public void getLockTaskFeatures_policyIsNotAllowedToBeFetched_throwsException() {
        assertThrows(SecurityException.class, () ->
                sDeviceState.dpc().devicePolicyManager().getLockTaskFeatures());
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"startLockTask_includedInLockTaskPackages_taskIsLocked"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void startLockTask_includedInLockTaskPackages_taskIsLocked() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();
        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                new String[]{sTestApp.packageName()});
        try (TestAppInstanceReference testApp =
                     sTestApp.install(sTestApis.users().instrumented())) {
            Activity<TestAppActivity> activity = testApp.activities().any().start();

            activity.startLockTask();

            try {
                assertThat(sTestApis.activities().foregroundActivity()).isEqualTo(
                        activity.activity().component());
                assertThat(sTestApis.activities().getLockTaskModeState()).isEqualTo(
                        LOCK_TASK_MODE_LOCKED);
            } finally {
                activity.stopLockTask();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"startLockTask_notIncludedInLockTaskPackages_taskIsNotLocked"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void startLockTask_notIncludedInLockTaskPackages_taskIsNotLocked() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();
        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{});
        try (TestAppInstanceReference testApp =
                     sTestApp.install(sTestApis.users().instrumented())) {
            Activity<TestAppActivity> activity = testApp.activities().any().start();

            activity.activity().startLockTask();

            try {
                assertThat(sTestApis.activities().foregroundActivity()).isEqualTo(
                        activity.activity().component());
                assertThat(sTestApis.activities().getLockTaskModeState()).isNotEqualTo(
                        LOCK_TASK_MODE_LOCKED);
            } finally {
                activity.stopLockTask();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"startLockTask_includedInLockTaskPackages_policyShouldNotApply_taskIsNotLocked"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @NegativePolicyTest(policy = LockTask.class)
    public void startLockTask_includedInLockTaskPackages_policyShouldNotApply_taskIsNotLocked() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();
        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                new String[]{sTestApp.packageName()});
        try (TestAppInstanceReference testApp =
                     sTestApp.install(sTestApis.users().instrumented())) {
            Activity<TestAppActivity> activity = testApp.activities().any().start();

            activity.activity().startLockTask();

            try {
                assertThat(sTestApis.activities().foregroundActivity()).isEqualTo(
                        activity.activity().component());
                assertThat(sTestApis.activities().getLockTaskModeState()).isNotEqualTo(
                        LOCK_TASK_MODE_LOCKED);
            } finally {
                activity.stopLockTask();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"finish_isLocked_doesNotFinish"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void finish_isLocked_doesNotFinish() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();
        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                new String[]{sTestApp.packageName()});
        try (TestAppInstanceReference testApp =
                     sTestApp.install(sTestApis.users().instrumented())) {
            Activity<TestAppActivity> activity = testApp.activities().any().start();
            activity.startLockTask();

            activity.activity().finish();

            try {
                // We don't actually watch for the Destroyed event because that'd be waiting for a
                // non occurrence of an event which is slow
                assertThat(sTestApis.activities().foregroundActivity()).isEqualTo(
                        activity.activity().component());
                assertThat(sTestApis.activities().getLockTaskModeState()).isEqualTo(
                        LOCK_TASK_MODE_LOCKED);
            } finally {
                activity.stopLockTask();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"finish_hasStoppedLockTask_doesFinish"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void finish_hasStoppedLockTask_doesFinish() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();
        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                new String[]{sTestApp.packageName()});
        try (TestAppInstanceReference testApp =
                     sTestApp.install(sTestApis.users().instrumented())) {
            Activity<TestAppActivity> activity = testApp.activities().any().start();
            activity.startLockTask();
            activity.stopLockTask();

            activity.activity().finish();

            // TODO(b/189327037): Replace with more direct integration between TestApp and EventLib
            EventLogs<ActivityDestroyedEvent> events =
                    ActivityDestroyedEvent.queryPackage(sTestApp.packageName())
                    .whereActivity().activityClass().className().isEqualTo(
                            activity.activity().component().className());
            assertThat(events.poll()).isNotNull();
            assertThat(sTestApis.activities().foregroundActivity()).isNotEqualTo(
                    activity.activity().component());
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"setLockTaskPackages_removingCurrentlyLockedTask_taskFinishes"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void setLockTaskPackages_removingCurrentlyLockedTask_taskFinishes() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();
        sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                new String[]{sTestApp.packageName()});
        try (TestAppInstanceReference testApp =
                     sTestApp.install(sTestApis.users().instrumented())) {
            Activity<TestAppActivity> activity = testApp.activities().any().start();
            activity.startLockTask();

            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{});

            // TODO(b/189327037): Replace with more direct integration between TestApp and EventLib
            EventLogs<ActivityDestroyedEvent> events =
                    ActivityDestroyedEvent.queryPackage(sTestApp.packageName())
                            .whereActivity().activityClass().className().isEqualTo(
                                    activity.activity().component().className());
            assertThat(events.poll()).isNotNull();
            assertThat(sTestApis.activities().foregroundActivity()).isNotEqualTo(
                    activity.activity().component());
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"isNotNull"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void startActivity_withinSameTask_startsActivity() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();
        try (TestAppInstanceReference testApp =
                     sTestApp.install(sTestApis.users().instrumented());
             TestAppInstanceReference testApp2 =
                     sSecondTestApp.install(sTestApis.users().instrumented())) {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    new String[]{sTestApp.packageName()});
            Activity<TestAppActivity> firstActivity = testApp.activities().any().start();
            TestAppActivityReference secondActivity = testApp2.activities().any();
            Intent secondActivityIntent = new Intent();
            // TODO(scottjonathan): Add filter to ensure no taskAffinity or launchMode which would
            //  stop launching in same task
            secondActivityIntent.setComponent(secondActivity.component().componentName());

            firstActivity.startActivity(secondActivityIntent);

            EventLogs<ActivityStartedEvent> events =
                    ActivityStartedEvent.queryPackage(sSecondTestApp.packageName())
                            .whereActivity().activityClass().className().isEqualTo(
                                    secondActivity.component().className());
            assertThat(events.poll()).isNotNull();
            assertThat(sTestApis.activities().foregroundActivity()).isEqualTo(secondActivity.component());
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(originalLockTaskPackages);
        }
    }"	""	""	"DPC DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"startActivity_ifWhitelistedActivity_startsInLockTaskMode"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void startActivity_ifWhitelistedActivity_startsInLockTaskMode() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        try (TestAppInstanceReference testApp =
                     sLockTaskTestApp.install(sTestApis.users().instrumented())) {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    new String[]{sLockTaskTestApp.packageName()});
            Activity<TestAppActivity> activity = testApp.activities().query()
                    .whereActivity().activityClass().simpleName().isEqualTo(""ifwhitelistedactivity"")
                    // TODO(scottjonathan): filter for lock task mode - currently we can't check
                    //  this so we just get a fixed package which contains a fixed activity
                    .get().start();

            try {
                assertThat(sTestApis.activities().foregroundActivity()).isEqualTo(
                        activity.activity().component());
                assertThat(sTestApis.activities().getLockTaskModeState()).isEqualTo(
                        LOCK_TASK_MODE_LOCKED);
            } finally {
                activity.stopLockTask();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"startActivity_ifWhitelistedActivity_notWhitelisted_startsNotInLockTaskMode"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void startActivity_ifWhitelistedActivity_notWhitelisted_startsNotInLockTaskMode() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        try (TestAppInstanceReference testApp =
                     sLockTaskTestApp.install(sTestApis.users().instrumented())) {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    new String[]{});
            Activity<TestAppActivity> activity = testApp.activities().query()
                    .whereActivity().activityClass().simpleName().isEqualTo(""ifwhitelistedactivity"")
                    // TODO(scottjonathan): filter for lock task mode - currently we can't check
                    //  this so we just get a fixed package which contains a fixed activity
                    .get().start();

            try {
                assertThat(sTestApis.activities().foregroundActivity()).isEqualTo(
                        activity.activity().component());
                assertThat(sTestApis.activities().getLockTaskModeState()).isEqualTo(
                        LOCK_TASK_MODE_NONE);
            } finally {
                activity.stopLockTask();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"finish_ifWhitelistedActivity_doesNotFinish"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void finish_ifWhitelistedActivity_doesNotFinish() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        try (TestAppInstanceReference testApp =
                     sLockTaskTestApp.install(sTestApis.users().instrumented())) {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    new String[]{sLockTaskTestApp.packageName()});
            Activity<TestAppActivity> activity = testApp.activities().query()
                    .whereActivity().activityClass().simpleName().isEqualTo(""ifwhitelistedactivity"")
                    // TODO(scottjonathan): filter for lock task mode - currently we can't check
                    //  this so we just get a fixed package which contains a fixed activity
                    .get().start();

            activity.activity().finish();

            try {
                // We don't actually watch for the Destroyed event because that'd be waiting for a
                // non occurrence of an event which is slow
                assertThat(sTestApis.activities().foregroundActivity()).isEqualTo(
                        activity.activity().component());
                assertThat(sTestApis.activities().getLockTaskModeState()).isEqualTo(
                        LOCK_TASK_MODE_LOCKED);
            } finally {
                activity.stopLockTask();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"setLockTaskPackages_removingExistingIfWhitelistedActivity_stopsTask"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    public void setLockTaskPackages_removingExistingIfWhitelistedActivity_stopsTask() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();

        try (TestAppInstanceReference testApp =
                     sLockTaskTestApp.install(sTestApis.users().instrumented())) {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    new String[]{sLockTaskTestApp.packageName()});
            Activity<TestAppActivity> activity = testApp.activities().query()
                    .whereActivity().activityClass().simpleName().isEqualTo(""ifwhitelistedactivity"")
                    // TODO(scottjonathan): filter for lock task mode - currently we can't check
                    //  this so we just get a fixed package which contains a fixed activity
                    .get().start();

            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(new String[]{});

            EventLogs<ActivityDestroyedEvent> events =
                    ActivityDestroyedEvent.queryPackage(sLockTaskTestApp.packageName())
                            .whereActivity().activityClass().className().isEqualTo(
                            activity.activity().component().className());
            assertThat(events.poll()).isNotNull();
            assertThat(sTestApis.activities().foregroundActivity()).isNotEqualTo(
                    activity.activity().component());
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    originalLockTaskPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"launchEmergencyDialerInLockTaskMode_notWhitelisted_noKeyguardFeature_doesNotLaunch"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    @RequireFeature(FEATURE_TELEPHONY)
    public void launchEmergencyDialerInLockTaskMode_notWhitelisted_noKeyguardFeature_doesNotLaunch() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();
        int originalLockTaskFeatures =
                sDeviceState.dpc().devicePolicyManager().getLockTaskFeatures();
        String emergencyDialerPackageName = getEmergencyDialerPackageName();
        assumeFalse(emergencyDialerPackageName == null);
        try (TestAppInstanceReference testApp =
                     sLockTaskTestApp.install(sTestApis.users().instrumented())) {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    new String[]{sLockTaskTestApp.packageName()});
            sDeviceState.dpc().devicePolicyManager().setLockTaskFeatures(0);
            Activity<TestAppActivity> activity = testApp.activities().any().start();

            try {
                activity.startLockTask();
                Intent intent = new Intent(ACTION_EMERGENCY_DIAL);
                intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK);

                activity.activity().startActivity(intent);

                if (sTestApis.activities().foregroundActivity() != null) {
                    assertThat(sTestApis.activities().foregroundActivity().packageName()).isNotEqualTo(
                            emergencyDialerPackageName);
                }
            } finally {
                activity.stopLockTask();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    originalLockTaskPackages);
            sDeviceState.dpc().devicePolicyManager().setLockTaskFeatures(originalLockTaskFeatures);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.LockTaskTest"	"launchEmergencyDialerInLockTaskMode_notWhitelisted_keyguardFeature_launches"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/LockTaskTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = LockTask.class)
    @RequireFeature(FEATURE_TELEPHONY)
    public void launchEmergencyDialerInLockTaskMode_notWhitelisted_keyguardFeature_launches() {
        String[] originalLockTaskPackages =
                sDeviceState.dpc().devicePolicyManager().getLockTaskPackages();
        int originalLockTaskFeatures =
                sDeviceState.dpc().devicePolicyManager().getLockTaskFeatures();
        String emergencyDialerPackageName = getEmergencyDialerPackageName();
        assumeFalse(emergencyDialerPackageName == null);
        try (TestAppInstanceReference testApp =
                     sLockTaskTestApp.install(sTestApis.users().instrumented())) {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    new String[]{sLockTaskTestApp.packageName()});
            sDeviceState.dpc().devicePolicyManager().setLockTaskFeatures(LOCK_TASK_FEATURE_KEYGUARD);
            Activity<TestAppActivity> activity = testApp.activities().any().start();
            try {
                activity.startLockTask();
                Intent intent = new Intent(ACTION_EMERGENCY_DIAL);
                intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK);

                activity.startActivity(intent);

                assertThat(sTestApis.activities().foregroundActivity().packageName())
                        .isEqualTo(sTestApis.packages().find(emergencyDialerPackageName));
                assertThat(sTestApis.activities().getLockTaskModeState()).isEqualTo(
                        LOCK_TASK_MODE_LOCKED);
            } finally {
                activity.stopLockTask();
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setLockTaskPackages(
                    originalLockTaskPackages);
            sDeviceState.dpc().devicePolicyManager().setLockTaskFeatures(originalLockTaskFeatures);
        }
    }

    private String getEmergencyDialerPackageName() {
        PackageManager packageManager =
                sTestApis.context().instrumentedContext().getPackageManager();
        Intent intent = new Intent(ACTION_EMERGENCY_DIAL).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        ResolveInfo dialerInfo =
                packageManager.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
        return (dialerInfo != null) ? dialerInfo.activityInfo.packageName : null;
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.tech.NdefTagTester"	"getTechList"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/tech/NdefTagTester.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.tech;

import com.android.cts.verifier.R;

import android.content.Context;
import android.nfc.FormatException;
import android.nfc.NdefMessage;
import android.nfc.NdefRecord;
import android.nfc.Tag;
import android.nfc.tech.Ndef;
import android.util.Log;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.Random;

/**
 * {@link TagTester} for NDEF tags. It writes a semi-random NDEF tag with a random id but
 * constant mime type and payload.
 */
public class NdefTagTester implements TagTester {

    private static final String TAG = NdefTagTester.class.getSimpleName();

    private static final String MIME_TYPE = ""application/com.android.cts.verifier.nfc"";

    private static final String PAYLOAD = ""CTS Verifier NDEF Tag"";

    private final Context mContext;

    public NdefTagTester(Context context) {
        this.mContext = context;
    }

    @Override
    public boolean isTestableTag(Tag tag) {
        if (tag != null) {
            for (String tech : tag.getTechList()) {
                if (tech.equals(Ndef.class.getName())) {
                    Ndef ndef = Ndef.get(tag);
                    return ndef != null && ndef.isWritable();
                }
            }
        }
        return false;
    }

    @Override
    public TagVerifier writeTag(Tag tag) throws IOException, FormatException {
        Random random = new Random();
        NdefRecord mimeRecord = createRandomMimeRecord(random);
        NdefRecord[] expectedRecords = new NdefRecord[] {mimeRecord};

        final NdefMessage expectedMessage = new NdefMessage(expectedRecords);
        writeMessage(tag, expectedMessage);

        final String expectedContent = mContext.getString(R.string.nfc_ndef_content,
                NfcUtils.displayByteArray(mimeRecord.getId()), MIME_TYPE, PAYLOAD);

        return new TagVerifier() {
            @Override
            public Result verifyTag(Tag tag) throws IOException, FormatException {
                String actualContent;
                NdefMessage message = readMessage(tag);
                NdefRecord[] records = message.getRecords();

                if (records.length > 0) {
                    NdefRecord record = records[0];
                    actualContent = mContext.getString(R.string.nfc_ndef_content,
                            NfcUtils.displayByteArray(record.getId()),
                            new String(record.getType(), Charset.forName(""US-ASCII"")),
                            new String(record.getPayload(), Charset.forName(""US-ASCII"")));
                } else {
                    actualContent = null;
                }

                return new Result(expectedContent, actualContent,
                        NfcUtils.areMessagesEqual(message, expectedMessage));
            }
        };
    }

    private NdefRecord createRandomMimeRecord(Random random) {
        byte[] mimeBytes = MIME_TYPE.getBytes(Charset.forName(""US-ASCII""));
        byte[] id = new byte[4];
        random.nextBytes(id);
        byte[] payload = PAYLOAD.getBytes(Charset.forName(""US-ASCII""));
        return new NdefRecord(NdefRecord.TNF_MIME_MEDIA, mimeBytes, id, payload);
    }

    private void writeMessage(Tag tag, NdefMessage message) throws IOException, FormatException {
        Ndef ndef = null;
        try {
            ndef = Ndef.get(tag);
            ndef.connect();
            ndef.writeNdefMessage(message);
        } finally {
            if (ndef != null) {
                try {
                    ndef.close();
                } catch (IOException e) {
                    Log.e(TAG, ""IOException while closing NDEF..."", e);
                }
            }
        }
    }

    private NdefMessage readMessage(Tag tag) throws IOException, FormatException {
        Ndef ndef = null;
        try {
            ndef = Ndef.get(tag);
            if (ndef != null) {
                ndef.connect();
                return ndef.getNdefMessage();
            }
        } finally {
            if (ndef != null) {
                try {
                    ndef.close();
                } catch (IOException e) {
                    Log.e(TAG, ""Error closing Ndef..."", e);
                }
            }
        }
        return null;
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.OffHostEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/OffHostEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

@TargetApi(19)
public class OffHostEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        setupServices(this, OffHostService.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_hce_offhost_emulator_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                OffHostService.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                OffHostService.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_offhost_service_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"main.java.com.android.bedstead.harrier.DeviceState"	"TestApis"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/harrier/src/main/java/com/android/bedstead/harrier/DeviceState.java"	""	"public void test/*
 *.
 */

package com.android.bedstead.harrier;

import static android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;

import static com.android.bedstead.nene.permissions.Permissions.NOTIFY_PENDING_SYSTEM_UPDATE;
import static com.android.bedstead.nene.users.UserType.MANAGED_PROFILE_TYPE_NAME;
import static com.android.bedstead.nene.users.UserType.SECONDARY_USER_TYPE_NAME;
import static com.android.bedstead.nene.utils.Versions.meetsSdkVersionRequirements;
import static com.android.bedstead.remotedpc.Configuration.REMOTE_DPC_COMPONENT_NAME;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertFalse;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;

import androidx.test.core.app.ApplicationProvider;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.bedstead.harrier.annotations.AfterClass;
import com.android.bedstead.harrier.annotations.BeforeClass;
import com.android.bedstead.harrier.annotations.EnsureDoesNotHavePermission;
import com.android.bedstead.harrier.annotations.EnsureHasPermission;
import com.android.bedstead.harrier.annotations.EnsurePackageNotInstalled;
import com.android.bedstead.harrier.annotations.FailureMode;
import com.android.bedstead.harrier.annotations.RequireDoesNotHaveFeature;
import com.android.bedstead.harrier.annotations.RequireFeature;
import com.android.bedstead.harrier.annotations.RequireGmsInstrumentation;
import com.android.bedstead.harrier.annotations.RequirePackageInstalled;
import com.android.bedstead.harrier.annotations.RequirePackageNotInstalled;
import com.android.bedstead.harrier.annotations.RequireSdkVersion;
import com.android.bedstead.harrier.annotations.RequireUserSupported;
import com.android.bedstead.harrier.annotations.enterprise.EnsureHasDeviceOwner;
import com.android.bedstead.harrier.annotations.enterprise.EnsureHasNoDeviceOwner;
import com.android.bedstead.harrier.annotations.enterprise.EnsureHasNoProfileOwner;
import com.android.bedstead.harrier.annotations.enterprise.EnsureHasProfileOwner;
import com.android.bedstead.harrier.annotations.meta.EnsureHasNoProfileAnnotation;
import com.android.bedstead.harrier.annotations.meta.EnsureHasNoUserAnnotation;
import com.android.bedstead.harrier.annotations.meta.EnsureHasProfileAnnotation;
import com.android.bedstead.harrier.annotations.meta.EnsureHasUserAnnotation;
import com.android.bedstead.harrier.annotations.meta.ParameterizedAnnotation;
import com.android.bedstead.harrier.annotations.meta.RequireRunOnProfileAnnotation;
import com.android.bedstead.harrier.annotations.meta.RequireRunOnUserAnnotation;
import com.android.bedstead.harrier.annotations.meta.RequiresBedsteadJUnit4;
import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.devicepolicy.DeviceOwner;
import com.android.bedstead.nene.devicepolicy.DevicePolicyController;
import com.android.bedstead.nene.devicepolicy.ProfileOwner;
import com.android.bedstead.nene.exceptions.AdbException;
import com.android.bedstead.nene.exceptions.NeneException;
import com.android.bedstead.nene.packages.Package;
import com.android.bedstead.nene.permissions.PermissionContextImpl;
import com.android.bedstead.nene.users.User;
import com.android.bedstead.nene.users.UserBuilder;
import com.android.bedstead.nene.users.UserReference;
import com.android.bedstead.nene.utils.ShellCommand;
import com.android.bedstead.nene.utils.Versions;
import com.android.bedstead.remotedpc.RemoteDpc;
import com.android.compatibility.common.util.BlockingBroadcastReceiver;

import com.google.common.base.Objects;

import junit.framework.AssertionFailedError;

import org.junit.AssumptionViolatedException;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;
import org.junit.runners.model.TestClass;

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;


/**
 * A Junit rule which exposes methods for efficiently changing and querying device state.
 *
 * <p>States set by the methods on this class will by default be cleaned up after the test.
 *
 *
 * <p>Using this rule also enforces preconditions in annotations from the
 * {@code com.android.comaptibility.common.util.enterprise.annotations} package.
 *
 * {@code assumeTrue} will be used, so tests which do not meet preconditions will be skipped.
 */
public final class DeviceState implements TestRule {

    private static final String GMS_PKG = ""com.google.android.gms"";

    private final Context mContext = ApplicationProvider.getApplicationContext();
    private static final TestApis sTestApis = new TestApis();
    private static final String SKIP_TEST_TEARDOWN_KEY = ""skip-test-teardown"";
    private static final String SKIP_CLASS_TEARDOWN_KEY = ""skip-class-teardown"";
    private static final String SKIP_TESTS_REASON_KEY = ""skip-tests-reason"";
    private boolean mSkipTestTeardown;
    private boolean mSkipClassTeardown;
    private boolean mSkipTests;
    private boolean mFailTests;
    private boolean mUsingBedsteadJUnit4 = false;
    private String mSkipTestsReason;
    private String mFailTestsReason;

    // Marks if the conditions for requiring running under GMS instrumentation have been set
    // if not - we assume the test should never run under GMS instrumentation
    private boolean mHasRequireGmsInstrumentation = false;

    private static final String TV_PROFILE_TYPE_NAME = ""com.android.tv.profile"";

    public DeviceState() {
        Bundle arguments = InstrumentationRegistry.getArguments();
        mSkipTestTeardown = Boolean.parseBoolean(
                arguments.getString(SKIP_TEST_TEARDOWN_KEY, ""false""));
        mSkipClassTeardown = Boolean.parseBoolean(
                arguments.getString(SKIP_CLASS_TEARDOWN_KEY, ""false""));
        mSkipTestsReason = arguments.getString(SKIP_TESTS_REASON_KEY, """");
        mSkipTests = !mSkipTestsReason.isEmpty();
    }

    void setSkipTestTeardown(boolean skipTestTeardown) {
        mSkipTestTeardown = skipTestTeardown;
    }

    void setUsingBedsteadJUnit4(boolean usingBedsteadJUnit4) {
        mUsingBedsteadJUnit4 = usingBedsteadJUnit4;
    }

    @Override public Statement apply(final Statement base,
            final Description description) {

        if (description.isTest()) {
            return applyTest(base, description);
        } else if (description.isSuite()) {
            return applySuite(base, description);
        }
        throw new IllegalStateException(""Unknown description type: "" + description);
    }

    private Statement applyTest(final Statement base, final Description description) {
        return new Statement() {
            @Override public void evaluate() throws Throwable {
                Log.d(LOG_TAG, ""Preparing state for test "" + description.getMethodName());

                assumeFalse(mSkipTestsReason, mSkipTests);
                assertFalse(mFailTestsReason, mFailTests);

                List<Annotation> annotations = getAnnotations(description);
                PermissionContextImpl permissionContext = applyAnnotations(annotations);

                Log.d(LOG_TAG,
                        ""Finished preparing state for test "" + description.getMethodName());

                try {
                    base.evaluate();
                } finally {
                    Log.d(LOG_TAG,
                            ""Tearing down state for test "" + description.getMethodName());

                    if (permissionContext != null) {
                        permissionContext.close();
                    }

                    teardownNonShareableState();
                    if (!mSkipTestTeardown) {
                        teardownShareableState();
                    }
                    Log.d(LOG_TAG,
                            ""Finished tearing down state for test ""
                                    + description.getMethodName());
                }
            }};
    }

    private PermissionContextImpl applyAnnotations(List<Annotation> annotations)
            throws Throwable {
        PermissionContextImpl permissionContext = null;
        for (Annotation annotation : annotations) {
            Class<? extends Annotation> annotationType = annotation.annotationType();

            EnsureHasNoProfileAnnotation ensureHasNoProfileAnnotation =
                    annotationType.getAnnotation(EnsureHasNoProfileAnnotation.class);
            if (ensureHasNoProfileAnnotation != null) {
                UserType userType = (UserType) annotation.annotationType()
                        .getMethod(""forUser"").invoke(annotation);
                ensureHasNoProfile(ensureHasNoProfileAnnotation.value(), userType);
                continue;
            }

            EnsureHasProfileAnnotation ensureHasProfileAnnotation =
                    annotationType.getAnnotation(EnsureHasProfileAnnotation.class);
            if (ensureHasProfileAnnotation != null) {
                UserType forUser = (UserType) annotation.annotationType()
                        .getMethod(""forUser"").invoke(annotation);
                OptionalBoolean installInstrumentedApp = (OptionalBoolean)
                        annotation.annotationType()
                                .getMethod(""installInstrumentedApp"").invoke(annotation);

                boolean dpcIsPrimary = false;
                if (ensureHasProfileAnnotation.hasProfileOwner()) {
                    dpcIsPrimary = (boolean)
                            annotation.annotationType()
                                    .getMethod(""dpcIsPrimary"").invoke(annotation);
                }

                ensureHasProfile(
                        ensureHasProfileAnnotation.value(), installInstrumentedApp,
                        forUser, ensureHasProfileAnnotation.hasProfileOwner(),
                        dpcIsPrimary);
                continue;
            }

            EnsureHasNoUserAnnotation ensureHasNoUserAnnotation =
                    annotationType.getAnnotation(EnsureHasNoUserAnnotation.class);
            if (ensureHasNoUserAnnotation != null) {
                ensureHasNoUser(ensureHasNoUserAnnotation.value());
                continue;
            }

            EnsureHasUserAnnotation ensureHasUserAnnotation =
                    annotationType.getAnnotation(EnsureHasUserAnnotation.class);
            if (ensureHasUserAnnotation != null) {
                OptionalBoolean installInstrumentedApp = (OptionalBoolean)
                        annotation.getClass()
                                .getMethod(""installInstrumentedApp"").invoke(annotation);
                ensureHasUser(ensureHasUserAnnotation.value(), installInstrumentedApp);
                continue;
            }

            RequireRunOnUserAnnotation requireRunOnUserAnnotation =
                    annotationType.getAnnotation(RequireRunOnUserAnnotation.class);
            if (requireRunOnUserAnnotation != null) {
                requireRunOnUser(requireRunOnUserAnnotation.value());
                continue;
            }

            RequireRunOnProfileAnnotation requireRunOnProfileAnnotation =
                    annotationType.getAnnotation(RequireRunOnProfileAnnotation.class);
            if (requireRunOnProfileAnnotation != null) {
                OptionalBoolean installInstrumentedAppInParent = (OptionalBoolean)
                        annotation.getClass()
                                .getMethod(""installInstrumentedAppInParent"")
                                .invoke(annotation);


                boolean dpcIsPrimary = false;
                Set<String> affiliationIds = null;
                if (requireRunOnProfileAnnotation.hasProfileOwner()) {
                    dpcIsPrimary = (boolean)
                            annotation.annotationType()
                                    .getMethod(""dpcIsPrimary"").invoke(annotation);
                    affiliationIds = new HashSet<>(Arrays.asList((String[])
                            annotation.annotationType()
                                    .getMethod(""affiliationIds"").invoke(annotation)));
                }

                requireRunOnProfile(requireRunOnProfileAnnotation.value(),
                        installInstrumentedAppInParent,
                        requireRunOnProfileAnnotation.hasProfileOwner(),
                        dpcIsPrimary, affiliationIds);
                continue;
            }

            if (annotation instanceof EnsureHasDeviceOwner) {
                EnsureHasDeviceOwner ensureHasDeviceOwnerAnnotation =
                        (EnsureHasDeviceOwner) annotation;
                ensureHasDeviceOwner(ensureHasDeviceOwnerAnnotation.onUser(),
                        ensureHasDeviceOwnerAnnotation.failureMode(),
                        ensureHasDeviceOwnerAnnotation.isPrimary(),
                        new HashSet<>(Arrays.asList(ensureHasDeviceOwnerAnnotation.affiliationIds())));
                continue;
            }

            if (annotation instanceof EnsureHasNoDeviceOwner) {
                ensureHasNoDeviceOwner();
                continue;
            }

            if (annotation instanceof RequireFeature) {
                RequireFeature requireFeatureAnnotation = (RequireFeature) annotation;
                requireFeature(
                        requireFeatureAnnotation.value(),
                        requireFeatureAnnotation.failureMode());
                continue;
            }

            if (annotation instanceof RequireDoesNotHaveFeature) {
                RequireDoesNotHaveFeature requireDoesNotHaveFeatureAnnotation =
                        (RequireDoesNotHaveFeature) annotation;
                requireDoesNotHaveFeature(
                        requireDoesNotHaveFeatureAnnotation.value(),
                        requireDoesNotHaveFeatureAnnotation.failureMode());
                continue;
            }

            if (annotation instanceof EnsureHasProfileOwner) {
                EnsureHasProfileOwner ensureHasProfileOwnerAnnotation =
                        (EnsureHasProfileOwner) annotation;
                ensureHasProfileOwner(ensureHasProfileOwnerAnnotation.onUser(),
                        ensureHasProfileOwnerAnnotation.isPrimary(),
                        new HashSet<>(Arrays.asList(ensureHasProfileOwnerAnnotation.affiliationIds())));
                continue;
            }

            if (annotationType.equals(EnsureHasNoProfileOwner.class)) {
                EnsureHasNoProfileOwner ensureHasNoProfileOwnerAnnotation =
                        (EnsureHasNoProfileOwner) annotation;
                ensureHasNoProfileOwner(ensureHasNoProfileOwnerAnnotation.onUser());
                continue;
            }

            if (annotation instanceof RequireUserSupported) {
                RequireUserSupported requireUserSupportedAnnotation =
                        (RequireUserSupported) annotation;
                requireUserSupported(
                        requireUserSupportedAnnotation.value(),
                        requireUserSupportedAnnotation.failureMode());
                continue;
            }

            if (annotation instanceof RequireGmsInstrumentation) {
                RequireGmsInstrumentation requireGmsInstrumentationAnnotation =
                        (RequireGmsInstrumentation) annotation;
                requireGmsInstrumentation(requireGmsInstrumentationAnnotation.min(),
                        requireGmsInstrumentationAnnotation.max());
                continue;
            }

            if (annotation instanceof RequireSdkVersion) {
                RequireSdkVersion requireSdkVersionAnnotation =
                        (RequireSdkVersion) annotation;

                requireSdkVersion(
                        requireSdkVersionAnnotation.min(),
                        requireSdkVersionAnnotation.max(),
                        requireSdkVersionAnnotation.failureMode());
                continue;
            }

            if (annotation instanceof RequirePackageInstalled) {
                RequirePackageInstalled requirePackageInstalledAnnotation =
                        (RequirePackageInstalled) annotation;
                requirePackageInstalled(
                        requirePackageInstalledAnnotation.value(),
                        requirePackageInstalledAnnotation.onUser(),
                        requirePackageInstalledAnnotation.failureMode());
                continue;
            }

            if (annotation instanceof RequirePackageNotInstalled) {
                RequirePackageNotInstalled requirePackageNotInstalledAnnotation =
                        (RequirePackageNotInstalled) annotation;
                requirePackageNotInstalled(
                        requirePackageNotInstalledAnnotation.value(),
                        requirePackageNotInstalledAnnotation.onUser(),
                        requirePackageNotInstalledAnnotation.failureMode()
                );
                continue;
            }

            if (annotation instanceof EnsurePackageNotInstalled) {
                EnsurePackageNotInstalled ensurePackageNotInstalledAnnotation =
                        (EnsurePackageNotInstalled) annotation;
                ensurePackageNotInstalled(
                        ensurePackageNotInstalledAnnotation.value(),
                        ensurePackageNotInstalledAnnotation.onUser()
                );
                continue;
            }

            if (annotation instanceof EnsureHasPermission) {
                EnsureHasPermission ensureHasPermissionAnnotation =
                        (EnsureHasPermission) annotation;

                for (String permission : ensureHasPermissionAnnotation.value()) {
                    ensureCanGetPermission(permission);
                }


                try {
                    if (permissionContext == null) {
                        permissionContext = sTestApis.permissions().withPermission(
                                ensureHasPermissionAnnotation.value());
                    } else {
                        permissionContext = permissionContext.withPermission(
                                ensureHasPermissionAnnotation.value());
                    }
                } catch (NeneException e) {
                    failOrSkip(""Error getting permission: "" + e,
                            ensureHasPermissionAnnotation.failureMode());
                }
                continue;
            }

            if (annotation instanceof EnsureDoesNotHavePermission) {
                EnsureDoesNotHavePermission ensureDoesNotHavePermission =
                        (EnsureDoesNotHavePermission) annotation;

                try {
                    if (permissionContext == null) {
                        permissionContext = sTestApis.permissions().withoutPermission(
                                ensureDoesNotHavePermission.value());
                    } else {
                        permissionContext = permissionContext.withoutPermission(
                                ensureDoesNotHavePermission.value());
                    }
                } catch (NeneException e) {
                    failOrSkip(""Error denying permission: "" + e,
                            ensureDoesNotHavePermission.failureMode());
                }
                continue;
            }
        }

        if (!mHasRequireGmsInstrumentation) {
            // TODO(scottjonathan): Only enforce if we've configured GMS Instrumentation
            requireNoGmsInstrumentation();
        }

        return permissionContext;
    }

    private List<Annotation> getAnnotations(Description description) {
        if (mUsingBedsteadJUnit4 && description.isTest()) {
            // The annotations are already exploded for tests
            return new ArrayList<>(description.getAnnotations());
        }

        // Otherwise we should build a new collection by recursively gathering annotations
        // if we find any which don't work without the runner we should error and fail the test
        List<Annotation> annotations = new ArrayList<>();

        if (description.isTest()) {
            annotations =
                    new ArrayList<>(Arrays.asList(description.getTestClass().getAnnotations()));
        }

        annotations.addAll(description.getAnnotations());

        checkAnnotations(annotations);

        BedsteadJUnit4.resolveRecursiveAnnotations(annotations,
                /* parameterizedAnnotation= */ null);

        checkAnnotations(annotations);

        return annotations;
    }

    private void checkAnnotations(Collection<Annotation> annotations) {
        for (Annotation annotation : annotations) {
            if (annotation.annotationType().getAnnotation(RequiresBedsteadJUnit4.class) != null
                    || annotation.annotationType().getAnnotation(
                            ParameterizedAnnotation.class) != null) {
                throw new AssertionFailedError(""Test is annotated ""
                        + annotation.annotationType().getSimpleName()
                        + "" which requires using the BedsteadJUnit4 test runner"");
            }
        }
    }

    private Statement applySuite(final Statement base, final Description description) {
        return new Statement() {
            @Override
            public void evaluate() throws Throwable {
                checkValidAnnotations(description);

                TestClass testClass = new TestClass(description.getTestClass());

                boolean skipAfterClass = true;
                PermissionContextImpl permissionContext = null;

                if (!mSkipTests && !mFailTests) {
                    skipAfterClass = false;
                    Log.d(LOG_TAG, ""Preparing state for suite "" + description.getClassName());

                    try {
                        List<Annotation> annotations =
                                new ArrayList<>(getAnnotations(description));
                        permissionContext = applyAnnotations(annotations);
                    } catch (AssumptionViolatedException e) {
                        mSkipTests = true;
                        mSkipTestsReason = e.getMessage();
                    } catch (AssertionError e) {
                        mFailTests = true;
                        mFailTestsReason = e.getMessage();
                    }

                    Log.d(LOG_TAG,
                            ""Finished preparing state for suite ""
                                    + description.getClassName());
                }

                if (!mSkipTests && !mFailTests) {
                    runAnnotatedMethods(testClass, BeforeClass.class);
                }

                base.evaluate();

                if (!skipAfterClass) {
                    runAnnotatedMethods(testClass, AfterClass.class);
                }

                if (permissionContext != null) {
                    permissionContext.close();
                }

                if (!mSkipClassTeardown) {
                    teardownShareableState();
                }
            }
        };
    }

    private static final Map<Class<? extends Annotation>, Class<? extends Annotation>>
            BANNED_ANNOTATIONS_TO_REPLACEMENTS = getBannedAnnotationsToReplacements();
    private static Map<
            Class<? extends Annotation>,
            Class<? extends Annotation>> getBannedAnnotationsToReplacements() {
        Map<
                Class<? extends Annotation>,
                Class<? extends Annotation>> bannedAnnotationsToReplacements = new HashMap<>();
        bannedAnnotationsToReplacements.put(org.junit.BeforeClass.class, BeforeClass.class);
        bannedAnnotationsToReplacements.put(org.junit.AfterClass.class, AfterClass.class);
        return bannedAnnotationsToReplacements;
    }

    private void checkValidAnnotations(Description classDescription) {
        for (Method method : classDescription.getTestClass().getMethods()) {
            for (Map.Entry<
                    Class<? extends Annotation>,
                    Class<? extends Annotation>> bannedAnnotation
                    : BANNED_ANNOTATIONS_TO_REPLACEMENTS.entrySet()) {
                if (method.isAnnotationPresent(bannedAnnotation.getKey())) {
                    throw new IllegalStateException(""Do not use ""
                            + bannedAnnotation.getKey().getCanonicalName()
                            + "" when using DeviceState, replace with ""
                            + bannedAnnotation.getValue().getCanonicalName());
                }
            }

            if (method.getAnnotation(BeforeClass.class) != null
                    || method.getAnnotation(AfterClass.class) != null) {
                checkPublicStaticVoidNoArgs(method);
            }
        }
    }

    private void checkPublicStaticVoidNoArgs(Method method) {
        if (method.getParameterTypes().length > 0) {
            throw new IllegalStateException(
                    ""Method "" + method.getName() + "" should have no parameters"");
        }
        if (method.getReturnType() != Void.TYPE) {
            throw new IllegalStateException(""Method "" + method.getName() + ""() should be void"");
        }
        if (!Modifier.isStatic(method.getModifiers())) {
            throw new IllegalStateException(""Method "" + method.getName() + ""() should be static"");
        }
        if (!Modifier.isPublic(method.getModifiers())) {
            throw new IllegalStateException(""Method "" + method.getName() + ""() should be public"");
        }
    }

    private void runAnnotatedMethods(
            TestClass testClass, Class<? extends Annotation> annotation) throws Throwable {

        List<FrameworkMethod> methods = new ArrayList<>(testClass.getAnnotatedMethods(annotation));
        Collections.reverse(methods);
        for (FrameworkMethod method : methods) {
            try {
                method.invokeExplosively(testClass.getJavaClass());
            } catch (InvocationTargetException e) {
                throw e.getCause();
            }
        }
    }

    private void requireRunOnUser(String userType) {
        User instrumentedUser = sTestApis.users().instrumented().resolve();

        assumeTrue(""This test only runs on users of type "" + userType,
                instrumentedUser.type().name().equals(userType));

        mUsers.put(instrumentedUser.type(), instrumentedUser);
    }

    private void requireRunOnProfile(String userType,
            OptionalBoolean installInstrumentedAppInParent,
            boolean hasProfileOwner, boolean dpcIsPrimary, Set<String> affiliationIds) {
        User instrumentedUser = sTestApis.users().instrumented().resolve();

        assumeTrue(""This test only runs on users of type "" + userType,
                instrumentedUser.type().name().equals(userType));

        if (!mProfiles.containsKey(instrumentedUser.type())) {
            mProfiles.put(instrumentedUser.type(), new HashMap<>());
        }

        mProfiles.get(instrumentedUser.type()).put(instrumentedUser.parent(), instrumentedUser);

        if (installInstrumentedAppInParent.equals(OptionalBoolean.TRUE)) {
            sTestApis.packages().find(sContext.getPackageName()).install(
                    instrumentedUser.parent());
        } else if (installInstrumentedAppInParent.equals(OptionalBoolean.FALSE)) {
            sTestApis.packages().find(sContext.getPackageName()).uninstall(
                    instrumentedUser.parent());
        }

        if (hasProfileOwner) {
            ensureHasProfileOwner(instrumentedUser, dpcIsPrimary, affiliationIds);
        } else {
            ensureHasNoProfileOwner(instrumentedUser);
        }
    }

    private void requireFeature(String feature, FailureMode failureMode) {
        checkFailOrSkip(""Device must have feature "" + feature,
                sTestApis.packages().features().contains(feature), failureMode);
    }

    private void requireDoesNotHaveFeature(String feature, FailureMode failureMode) {
        checkFailOrSkip(""Device must not have feature "" + feature,
                !sTestApis.packages().features().contains(feature), failureMode);
    }

    private void requireNoGmsInstrumentation() {
        boolean instrumentingGms =
                sTestApis.context().instrumentedContext().getPackageName().equals(GMS_PKG);

        checkFailOrSkip(
                ""This test never runs using gms instrumentation"",
                !instrumentingGms,
                FailureMode.SKIP
        );
    }

    private void requireGmsInstrumentation(int min, int max) {
        mHasRequireGmsInstrumentation = true;
        boolean instrumentingGms =
                sTestApis.context().instrumentedContext().getPackageName().equals(GMS_PKG);

        if (meetsSdkVersionRequirements(min, max)) {
            checkFailOrSkip(
                    ""For SDK versions between "" + min +  "" and "" + max
                            + "" (inclusive), this test only runs when using gms instrumentation"",
                    instrumentingGms,
                    FailureMode.SKIP
            );
        } else {
            checkFailOrSkip(
                    ""For SDK versions between "" + min +  "" and "" + max
                            + "" (inclusive), this test only runs when not using gms ""
                            + ""instrumentation"",
                    !instrumentingGms,
                    FailureMode.SKIP
            );
        }
    }

    private void requireSdkVersion(int min, int max, FailureMode failureMode) {
        requireSdkVersion(min, max, failureMode,
                ""Sdk version must be between "" + min +  "" and "" + max + "" (inclusive)"");
    }

    private void requireSdkVersion(
            int min, int max, FailureMode failureMode, String failureMessage) {
        checkFailOrSkip(
                failureMessage,
                meetsSdkVersionRequirements(min, max),
                failureMode
        );
    }

    private com.android.bedstead.nene.users.UserType requireUserSupported(
            String userType, FailureMode failureMode) {
        com.android.bedstead.nene.users.UserType resolvedUserType =
                sTestApis.users().supportedType(userType);

        checkFailOrSkip(
                ""Device must support user type "" + userType
                + "" only supports: "" + sTestApis.users().supportedTypes(),
                resolvedUserType != null, failureMode);

        return resolvedUserType;
    }

    private void checkFailOrSkip(String message, boolean value, FailureMode failureMode) {
        if (failureMode.equals(FailureMode.FAIL)) {
            assertWithMessage(message).that(value).isTrue();
        } else if (failureMode.equals(FailureMode.SKIP)) {
            assumeTrue(message, value);
        } else {
            throw new IllegalStateException(""Unknown failure mode: "" + failureMode);
        }
    }

    private void failOrSkip(String message, FailureMode failureMode) {
        if (failureMode.equals(FailureMode.FAIL)) {
            throw new AssertionError(message);
        } else if (failureMode.equals(FailureMode.SKIP)) {
            throw new AssumptionViolatedException(message);
        } else {
            throw new IllegalStateException(""Unknown failure mode: "" + failureMode);
        }
    }

    public enum UserType {
        /** Only to be used with annotations. */
        ANY,
        SYSTEM_USER,
        CURRENT_USER,
        PRIMARY_USER,
        SECONDARY_USER,
        WORK_PROFILE,
        TV_PROFILE,
    }

    private static final String LOG_TAG = ""DeviceState"";

    private static final Context sContext = sTestApis.context().instrumentedContext();

    private final Map<com.android.bedstead.nene.users.UserType, UserReference> mUsers =
            new HashMap<>();
    private final Map<com.android.bedstead.nene.users.UserType, Map<UserReference, UserReference>>
            mProfiles = new HashMap<>();
    private DevicePolicyController mDeviceOwner;
    private Map<UserReference, DevicePolicyController> mProfileOwners = new HashMap<>();
    private DevicePolicyController mPrimaryDpc;

    private final List<UserReference> mCreatedUsers = new ArrayList<>();
    private final List<UserBuilder> mRemovedUsers = new ArrayList<>();
    private final List<BlockingBroadcastReceiver> mRegisteredBroadcastReceivers = new ArrayList<>();
    private boolean mHasChangedDeviceOwner = false;
    private DevicePolicyController mOriginalDeviceOwner = null;
    private Map<UserReference, DevicePolicyController> mChangedProfileOwners = new HashMap<>();

    /**
     * Get the {@link UserReference} of the work profile for the current user.
     *
     * <p>If the current user is a work profile, then the current user will be returned.
     *
     * <p>This should only be used to get work profiles managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed work profile
     */
    public UserReference workProfile() {
        return workProfile(/* forUser= */ UserType.CURRENT_USER);
    }

    /**
     * Get the {@link UserReference} of the work profile.
     *
     * <p>This should only be used to get work profiles managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed work profile for the given user
     */
    public UserReference workProfile(UserType forUser) {
        return workProfile(resolveUserTypeToUser(forUser));
    }

    /**
     * Get the {@link UserReference} of the work profile.
     *
     * <p>This should only be used to get work profiles managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed work profile for the given user
     */
    public UserReference workProfile(UserReference forUser) {
        return profile(MANAGED_PROFILE_TYPE_NAME, forUser);
    }

    /**
     * Get the {@link UserReference} of the profile of the given type for the given user.
     *
     * <p>This should only be used to get profiles managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed profile for the given user
     */
    public UserReference profile(String profileType, UserType forUser) {
        return profile(profileType, resolveUserTypeToUser(forUser));
    }

    /**
     * Get the {@link UserReference} of the profile for the current user.
     *
     * <p>If the current user is a profile of the correct type, then the current user will be
     * returned.
     *
     * <p>This should only be used to get profiles managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed profile
     */
    public UserReference profile(String profileType) {
        return profile(profileType, /* forUser= */ UserType.CURRENT_USER);
    }

    /**
     * Get the {@link UserReference} of the profile of the given type for the given user.
     *
     * <p>This should only be used to get profiles managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed profile for the given user
     */
    public UserReference profile(String profileType, UserReference forUser) {
        com.android.bedstead.nene.users.UserType resolvedUserType =
                sTestApis.users().supportedType(profileType);

        if (resolvedUserType == null) {
            throw new IllegalStateException(""Can not have a profile of type "" + profileType
                    + "" as they are not supported on this device"");
        }

        return profile(resolvedUserType, forUser);
    }

    /**
     * Get the {@link UserReference} of the profile of the given type for the given user.
     *
     * <p>This should only be used to get profiles managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed profile for the given user
     */
    public UserReference profile(
            com.android.bedstead.nene.users.UserType userType, UserReference forUser) {
        if (userType == null || forUser == null) {
            throw new NullPointerException();
        }

        if (!mProfiles.containsKey(userType) || !mProfiles.get(userType).containsKey(forUser)) {
            UserReference parentUser = sTestApis.users().instrumented().resolve().parent();

            if (parentUser != null) {
                if (mProfiles.containsKey(userType)
                        && mProfiles.get(userType).containsKey(parentUser)) {
                    return mProfiles.get(userType).get(parentUser);
                }
            }

            throw new IllegalStateException(
                    ""No harrier-managed profile of type "" + userType + "". This method should only""
                            + "" be used when Harrier has been used to create the profile."");
        }

        return mProfiles.get(userType).get(forUser);
    }

    /**
     * Get the {@link UserReference} of the tv profile for the current user
     *
     * <p>This should only be used to get tv profiles managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed tv profile
     */
    public UserReference tvProfile() {
        return tvProfile(/* forUser= */ UserType.CURRENT_USER);
    }

    /**
     * Get the {@link UserReference} of the tv profile.
     *
     * <p>This should only be used to get tv profiles managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed tv profile
     */
    public UserReference tvProfile(UserType forUser) {
        return tvProfile(resolveUserTypeToUser(forUser));
    }

    /**
     * Get the {@link UserReference} of the tv profile.
     *
     * <p>This should only be used to get tv profiles managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed tv profile
     */
    public UserReference tvProfile(UserReference forUser) {
        return profile(TV_PROFILE_TYPE_NAME, forUser);
    }

    /**
     * Get the user ID of the first human user on the device.
     */
    public UserReference primaryUser() {
        return sTestApis.users().all()
                .stream().filter(User::isPrimary).findFirst()
                .orElseThrow(IllegalStateException::new);
    }

    /**
     * Get a secondary user.
     *
     * <p>This should only be used to get secondary users managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed secondary user
     */
    public UserReference secondaryUser() {
        return user(SECONDARY_USER_TYPE_NAME);
    }

    /**
     * Get a user of the given type.
     *
     * <p>This should only be used to get users managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed user of the correct type
     */
    public UserReference user(String userType) {
        com.android.bedstead.nene.users.UserType resolvedUserType =
                sTestApis.users().supportedType(userType);

        if (resolvedUserType == null) {
            throw new IllegalStateException(""Can not have a user of type "" + userType
                    + "" as they are not supported on this device"");
        }

        return user(resolvedUserType);
    }

    /**
     * Get a user of the given type.
     *
     * <p>This should only be used to get users managed by Harrier (using either the
     * annotations or calls to the {@link DeviceState} class.
     *
     * @throws IllegalStateException if there is no harrier-managed user of the correct type
     */
    public UserReference user(com.android.bedstead.nene.users.UserType userType) {
        if (userType == null) {
            throw new NullPointerException();
        }

        if (!mUsers.containsKey(userType)) {
            throw new IllegalStateException(
                    ""No harrier-managed user of type "" + userType + "". This method should only be""
                            + ""used when Harrier has been used to create the user."");
        }

        return mUsers.get(userType);
    }

    private UserReference ensureHasProfile(
            String profileType,
            OptionalBoolean installInstrumentedApp,
            UserType forUser,
            boolean hasProfileOwner,
            boolean profileOwnerIsPrimary) {
        requireFeature(""android.software.managed_users"", FailureMode.SKIP);
        com.android.bedstead.nene.users.UserType resolvedUserType =
                requireUserSupported(profileType, FailureMode.SKIP);

        UserReference forUserReference = resolveUserTypeToUser(forUser);

        UserReference profile =
                sTestApis.users().findProfileOfType(resolvedUserType, forUserReference);
        if (profile == null) {
            profile = createProfile(resolvedUserType, forUserReference);
        }

        profile.start();

        if (installInstrumentedApp.equals(OptionalBoolean.TRUE)) {
            sTestApis.packages().find(sContext.getPackageName()).install(profile);
        } else if (installInstrumentedApp.equals(OptionalBoolean.FALSE)) {
            sTestApis.packages().find(sContext.getPackageName()).uninstall(profile);
        }

        if (!mProfiles.containsKey(resolvedUserType)) {
            mProfiles.put(resolvedUserType, new HashMap<>());
        }

        mProfiles.get(resolvedUserType).put(forUserReference, profile);

        if (hasProfileOwner) {
            ensureHasProfileOwner(profile, profileOwnerIsPrimary, /* affiliationIds= */ null);
        }
        return profile;
    }

    private void ensureHasNoProfile(String profileType, UserType forUser) {
        requireFeature(""android.software.managed_users"", FailureMode.SKIP);

        UserReference forUserReference = resolveUserTypeToUser(forUser);
        com.android.bedstead.nene.users.UserType resolvedProfileType =
                sTestApis.users().supportedType(profileType);

        if (resolvedProfileType == null) {
            // These profile types don't exist so there can't be any
            return;
        }

        UserReference profile =
                sTestApis.users().findProfileOfType(
                        resolvedProfileType,
                        forUserReference);
        if (profile != null) {
            removeAndRecordUser(profile);
        }
    }

    private void ensureHasUser(String userType, OptionalBoolean installInstrumentedApp) {
        com.android.bedstead.nene.users.UserType resolvedUserType =
                requireUserSupported(userType, FailureMode.SKIP);

        Collection<UserReference> users = sTestApis.users().findUsersOfType(resolvedUserType);

        UserReference user = users.isEmpty() ? createUser(resolvedUserType)
                : users.iterator().next();

        user.start();

        if (installInstrumentedApp.equals(OptionalBoolean.TRUE)) {
            sTestApis.packages().find(sContext.getPackageName()).install(user);
        } else if (installInstrumentedApp.equals(OptionalBoolean.FALSE)) {
            sTestApis.packages().find(sContext.getPackageName()).uninstall(user);
        }

        mUsers.put(resolvedUserType, user);
    }

    /**
     * Ensure that there is no user of the given type.
     */
    private void ensureHasNoUser(String userType) {
        com.android.bedstead.nene.users.UserType resolvedUserType =
                sTestApis.users().supportedType(userType);

        if (resolvedUserType == null) {
            // These user types don't exist so there can't be any
            return;
        }

        for (UserReference secondaryUser : sTestApis.users().findUsersOfType(resolvedUserType)) {
            removeAndRecordUser(secondaryUser);
        }
    }

    private void removeAndRecordUser(UserReference userReference) {
        if (userReference == null) {
            return; // Nothing to remove
        }

        User user = userReference.resolve();

        if (!mCreatedUsers.remove(user)) {
            mRemovedUsers.add(sTestApis.users().createUser()
                    .name(user.name())
                    .type(user.type())
                    .parent(user.parent()));
        }

        user.remove();
    }

    public void requireCanSupportAdditionalUser() {
        int maxUsers = getMaxNumberOfUsersSupported();
        int currentUsers = sTestApis.users().all().size();

        assumeTrue(""The device does not have space for an additional user ("" + currentUsers +
                "" current users, "" + maxUsers + "" max users)"", currentUsers + 1 <= maxUsers);
    }

    /**
     * Create and register a {@link BlockingBroadcastReceiver} which will be unregistered after the
     * test has run.
     */
    public BlockingBroadcastReceiver registerBroadcastReceiver(String action) {
        return registerBroadcastReceiver(action, /* checker= */ null);
    }

    /**
     * Create and register a {@link BlockingBroadcastReceiver} which will be unregistered after the
     * test has run.
     */
    public BlockingBroadcastReceiver registerBroadcastReceiver(
            String action, Function<Intent, Boolean> checker) {
        BlockingBroadcastReceiver broadcastReceiver =
                new BlockingBroadcastReceiver(mContext, action, checker);
        broadcastReceiver.register();
        mRegisteredBroadcastReceivers.add(broadcastReceiver);

        return broadcastReceiver;
    }

    private UserReference resolveUserTypeToUser(UserType userType) {
        switch (userType) {
            case SYSTEM_USER:
                return sTestApis.users().system();
            case CURRENT_USER:
                return sTestApis.users().instrumented();
            case PRIMARY_USER:
                return primaryUser();
            case SECONDARY_USER:
                return secondaryUser();
            case WORK_PROFILE:
                return workProfile();
            case TV_PROFILE:
                return tvProfile();
            case ANY:
                throw new IllegalStateException(""ANY UserType can not be used here"");
            default:
                throw new IllegalArgumentException(""Unknown user type "" + userType);
        }
    }

    private void teardownNonShareableState() {
        mProfiles.clear();
        mUsers.clear();

        for (BlockingBroadcastReceiver broadcastReceiver : mRegisteredBroadcastReceivers) {
            broadcastReceiver.unregisterQuietly();
        }
        mRegisteredBroadcastReceivers.clear();
        mPrimaryDpc = null;
    }

    private void teardownShareableState() {
        if (mHasChangedDeviceOwner) {
            if (mOriginalDeviceOwner == null) {
                if (mDeviceOwner != null) {
                    mDeviceOwner.remove();
                }
            } else if (!mOriginalDeviceOwner.equals(mDeviceOwner)) {
                mDeviceOwner.remove();
                sTestApis.devicePolicy().setDeviceOwner(
                        mOriginalDeviceOwner.user(), mOriginalDeviceOwner.componentName());
            }
            mHasChangedDeviceOwner = false;
            mOriginalDeviceOwner = null;
        }

        for (Map.Entry<UserReference, DevicePolicyController> originalProfileOwner :
                mChangedProfileOwners.entrySet()) {

            ProfileOwner currentProfileOwner =
                    sTestApis.devicePolicy().getProfileOwner(originalProfileOwner.getKey());

            if (Objects.equal(currentProfileOwner, originalProfileOwner.getValue())) {
                continue; // No need to restore
            }

            if (currentProfileOwner != null) {
                currentProfileOwner.remove();
            }

            if (originalProfileOwner.getValue() != null) {
                sTestApis.devicePolicy().setProfileOwner(originalProfileOwner.getKey(),
                        originalProfileOwner.getValue().componentName());
            }
        }
        mChangedProfileOwners.clear();

        for (UserReference user : mCreatedUsers) {
            user.remove();
        }

        mCreatedUsers.clear();

        for (UserBuilder userBuilder : mRemovedUsers) {
            userBuilder.create();
        }

        mRemovedUsers.clear();
    }

    private UserReference createProfile(
            com.android.bedstead.nene.users.UserType profileType, UserReference parent) {
        requireCanSupportAdditionalUser();
        try {
            UserReference user = sTestApis.users().createUser()
                    .parent(parent)
                    .type(profileType)
                    .createAndStart();
            mCreatedUsers.add(user);
            return user;
        } catch (NeneException e) {
            throw new IllegalStateException(""Error creating profile of type "" + profileType, e);
        }
    }

    private UserReference createUser(com.android.bedstead.nene.users.UserType userType) {
        requireCanSupportAdditionalUser();
        try {
            UserReference user = sTestApis.users().createUser()
                    .type(userType)
                    .createAndStart();
            mCreatedUsers.add(user);
            return user;
        } catch (NeneException e) {
            throw new IllegalStateException(""Error creating user of type "" + userType, e);
        }
    }

    private int getMaxNumberOfUsersSupported() {
        try {
            return ShellCommand.builder(""pm get-max-users"")
                    .validate((output) -> output.startsWith(""Maximum supported users:""))
                    .executeAndParseOutput(
                            (output) -> Integer.parseInt(output.split("": "", 2)[1].trim()));
        } catch (AdbException e) {
            throw new IllegalStateException(""Invalid command output"", e);
        }
    }

    private void ensureHasDeviceOwner(UserType onUser, FailureMode failureMode, boolean isPrimary, Set<String> affiliationIds) {
        // TODO(scottjonathan): Should support non-remotedpc device owner (default to remotedpc)
        // TODO(scottjonathan): Should allow setting the device owner on a different user
        UserReference userReference = resolveUserTypeToUser(onUser);
        if (isPrimary && mPrimaryDpc != null && !userReference.equals(mPrimaryDpc.user())) {
            throw new IllegalStateException(""Only one DPC can be marked as primary per test (current primary is "" + mPrimaryDpc + "")"");
        }
        if (!userReference.equals(sTestApis.users().instrumented())) {
            // INTERACT_ACROSS_USERS_FULL is required for RemoteDPC
            ensureCanGetPermission(INTERACT_ACROSS_USERS_FULL);
        }

        DeviceOwner currentDeviceOwner = sTestApis.devicePolicy().getDeviceOwner();

        if (currentDeviceOwner != null
                && currentDeviceOwner.componentName().equals(RemoteDpc.DPC_COMPONENT_NAME)) {
            mDeviceOwner = currentDeviceOwner;
        } else {
            UserReference instrumentedUser = sTestApis.users().instrumented();

            if (!Versions.meetsMinimumSdkVersionRequirement(Build.VERSION_CODES.S)) {
                // Prior to S we can't set device owner if there are other users on the device
                for (UserReference u : sTestApis.users().all()) {
                    if (u.equals(instrumentedUser)) {
                        continue;
                    }
                    try {
                        removeAndRecordUser(u);
                    } catch (NeneException e) {
                        failOrSkip(
                                ""Error removing user to prepare for DeviceOwner: "" + e.toString(),
                                failureMode);
                    }
                }
            }

            // TODO(scottjonathan): Remove accounts
            ensureHasNoProfileOwner(userReference);

            if (!mHasChangedDeviceOwner) {
                mOriginalDeviceOwner = currentDeviceOwner;
                mHasChangedDeviceOwner = true;
            }

            mDeviceOwner = RemoteDpc.setAsDeviceOwner(userReference)
                    .devicePolicyController();
        }

        if (isPrimary) {
            mPrimaryDpc = mDeviceOwner;
        }
        
        RemoteDpc.forDevicePolicyController(mDeviceOwner).devicePolicyManager()
                .setAffiliationIds(affiliationIds);
    }

    private void ensureHasProfileOwner(UserType onUser, boolean isPrimary, Set<String> affiliationIds) {
        // TODO(scottjonathan): Should support non-remotedpc profile owner (default to remotedpc)
        UserReference user = resolveUserTypeToUser(onUser);
        ensureHasProfileOwner(user, isPrimary, affiliationIds);
    }

    private void ensureHasProfileOwner(
            UserReference user, boolean isPrimary, Set<String> affiliationIds) {
        if (isPrimary && mPrimaryDpc != null && !user.equals(mPrimaryDpc.user())) {
            throw new IllegalStateException(""Only one DPC can be marked as primary per test"");
        }

        if (!user.equals(sTestApis.users().instrumented())) {
            // INTERACT_ACROSS_USERS_FULL is required for RemoteDPC
            ensureCanGetPermission(INTERACT_ACROSS_USERS_FULL);
        }

        ProfileOwner currentProfileOwner = sTestApis.devicePolicy().getProfileOwner(user);
        DeviceOwner currentDeviceOwner = sTestApis.devicePolicy().getDeviceOwner();

        if (currentDeviceOwner != null && currentDeviceOwner.user().equals(user)) {
            // Can't have DO and PO on the same user
            ensureHasNoDeviceOwner();
        }

        if (currentProfileOwner != null
                && currentProfileOwner.componentName().equals(
                RemoteDpc.DPC_COMPONENT_NAME)) {
            mProfileOwners.put(user, currentProfileOwner);
        } else {
            if (!mChangedProfileOwners.containsKey(user)) {
                mChangedProfileOwners.put(user, currentProfileOwner);
            }

            mProfileOwners.put(user, RemoteDpc.setAsProfileOwner(user).devicePolicyController());
        }

        if (isPrimary) {
            mPrimaryDpc = mProfileOwners.get(user);
        }

        if (affiliationIds != null) {
            RemoteDpc profileOwner = profileOwner(user);
            profileOwner.devicePolicyManager()
                    .setAffiliationIds(affiliationIds);
        }
    }

    private void ensureHasNoDeviceOwner() {
        DeviceOwner deviceOwner = sTestApis.devicePolicy().getDeviceOwner();

        if (deviceOwner == null) {
            return;
        }

        if (!mHasChangedDeviceOwner) {
            mOriginalDeviceOwner = deviceOwner;
            mHasChangedDeviceOwner = true;
        }

        mDeviceOwner = null;
        deviceOwner.remove();
    }

    private void ensureHasNoProfileOwner(UserType onUser) {
        UserReference user = resolveUserTypeToUser(onUser);

        ensureHasNoProfileOwner(user);
    }

    private void ensureHasNoProfileOwner(UserReference user) {

        ProfileOwner currentProfileOwner = sTestApis.devicePolicy().getProfileOwner(user);

        if (currentProfileOwner == null) {
            return;
        }

        if (!mChangedProfileOwners.containsKey(user)) {
            mChangedProfileOwners.put(user, currentProfileOwner);
        }

        sTestApis.devicePolicy().getProfileOwner(user).remove();
        mProfileOwners.remove(user);
    }

    /**
     * Get the {@link RemoteDpc} for the device owner controlled by Harrier.
     *
     * <p>If no Harrier-managed device owner exists, an exception will be thrown.
     *
     * <p>If the device owner is not a RemoteDPC then an exception will be thrown
     */
    public RemoteDpc deviceOwner() {
        if (mDeviceOwner == null) {
            throw new IllegalStateException(""No Harrier-managed device owner. This method should ""
                    + ""only be used when Harrier was used to set the Device Owner."");
        }
        if (!mDeviceOwner.componentName().equals(REMOTE_DPC_COMPONENT_NAME)) {
            throw new IllegalStateException(""The device owner is not a RemoteDPC.""
                    + "" You must use Nene to query for this device owner."");
        }

        return RemoteDpc.forDevicePolicyController(mDeviceOwner);
    }

    /**
     * Get the {@link RemoteDpc} for the profile owner on the current user controlled by Harrier.
     *
     * <p>If no Harrier-managed profile owner exists, an exception will be thrown.
     *
     * <p>If the profile owner is not a RemoteDPC then an exception will be thrown.
     */
    public RemoteDpc profileOwner() {
        return profileOwner(UserType.CURRENT_USER);
    }

    /**
     * Get the {@link RemoteDpc} for the profile owner on the given user controlled by Harrier.
     *
     * <p>If no Harrier-managed profile owner exists, an exception will be thrown.
     *
     * <p>If the profile owner is not a RemoteDPC then an exception will be thrown.
     */
    public RemoteDpc profileOwner(UserType onUser) {
        if (onUser == null) {
            throw new NullPointerException();
        }

        return profileOwner(resolveUserTypeToUser(onUser));
    }

    /**
     * Get the {@link RemoteDpc} for the profile owner on the given user controlled by Harrier.
     *
     * <p>If no Harrier-managed profile owner exists, an exception will be thrown.
     *
     * <p>If the profile owner is not a RemoteDPC then an exception will be thrown.
     */
    public RemoteDpc profileOwner(UserReference onUser) {
        if (onUser == null) {
            throw new NullPointerException();
        }

        if (!mProfileOwners.containsKey(onUser)) {
            throw new IllegalStateException(""No Harrier-managed profile owner. This method should ""
                    + ""only be used when Harrier was used to set the Profile Owner."");
        }

        DevicePolicyController profileOwner = mProfileOwners.get(onUser);

        if (!profileOwner.componentName().equals(REMOTE_DPC_COMPONENT_NAME)) {
            throw new IllegalStateException(""The profile owner is not a RemoteDPC.""
                    + "" You must use Nene to query for this profile owner."");
        }

        return RemoteDpc.forDevicePolicyController(profileOwner);
    }

    private void requirePackageInstalled(
            String packageName, UserType forUser, FailureMode failureMode) {

        Package pkg = sTestApis.packages().find(packageName).resolve();
        checkFailOrSkip(
                packageName + "" is required to be installed for "" + forUser,
                pkg != null,
                failureMode);

        if (forUser.equals(UserType.ANY)) {
            checkFailOrSkip(
                    packageName + "" is required to be installed"",
                    !pkg.installedOnUsers().isEmpty(),
                    failureMode);
        } else {
            checkFailOrSkip(
                    packageName + "" is required to be installed for "" + forUser,
                    pkg.installedOnUsers().contains(resolveUserTypeToUser(forUser)),
                    failureMode);
        }
    }

    private void requirePackageNotInstalled(
            String packageName, UserType forUser, FailureMode failureMode) {
        Package pkg = sTestApis.packages().find(packageName).resolve();
        if (pkg == null) {
            // Definitely not installed
            return;
        }

        if (forUser.equals(UserType.ANY)) {
            checkFailOrSkip(
                    packageName + "" is required to be not installed"",
                    pkg.installedOnUsers().isEmpty(),
                    failureMode);
        } else {
            checkFailOrSkip(
                    packageName + "" is required to be not installed for "" + forUser,
                    !pkg.installedOnUsers().contains(resolveUserTypeToUser(forUser)),
                    failureMode);
        }
    }

    private void ensurePackageNotInstalled(
            String packageName, UserType forUser) {

        Package pkg = sTestApis.packages().find(packageName).resolve();
        if (pkg == null) {
            // Definitely not installed
            return;
        }

        if (forUser.equals(UserType.ANY)) {
            if (!pkg.installedOnUsers().isEmpty()) {
                pkg.uninstallFromAllUsers();
            }
        } else {
            UserReference user = resolveUserTypeToUser(forUser);
            if (pkg.installedOnUsers().contains(user)) {
                pkg.uninstall(user);
            }
        }
    }

    /**
     * Get the most appropriate {@link RemoteDpc} instance for the device state.
     *
     * <p>This method should only be used by tests which are annotated with {@link PolicyTest}.
     *
     * <p>If no DPC is set as the ""primary"" DPC for the device state, then this method will first
     * check for a profile owner in the current user, or else check for a device owner.
     *
     * <p>If no Harrier-managed profile owner or device owner exists, an exception will be thrown.
     *
     * <p>If the profile owner or device owner is not a RemoteDPC then an exception will be thrown.
     */
    public RemoteDpc dpc() {
        if (mPrimaryDpc != null) {
            return RemoteDpc.forDevicePolicyController(mPrimaryDpc);
        }

        if (mProfileOwners.containsKey(sTestApis.users().instrumented())) {
            DevicePolicyController profileOwner =
                    mProfileOwners.get(sTestApis.users().instrumented());


            if (profileOwner.componentName().equals(REMOTE_DPC_COMPONENT_NAME)) {
                return RemoteDpc.forDevicePolicyController(profileOwner);
            }
        }

        if (mDeviceOwner != null) {
            if (mDeviceOwner.componentName().equals(REMOTE_DPC_COMPONENT_NAME)) {
                return RemoteDpc.forDevicePolicyController(mDeviceOwner);
            }

        }

        throw new IllegalStateException(""No Harrier-managed profile owner or device owner."");
    }

    private void ensureCanGetPermission(String permission) {
        // TODO(scottjonathan): Apply gms permission switches automatically rather than hard-coding
        // TODO(scottjonathan): Add a config to only enforce gms permission when needed
        if (permission.equals(NOTIFY_PENDING_SYSTEM_UPDATE)) {
            requireGmsInstrumentation(1, Build.VERSION_CODES.R);
        }
        // TODO(scottjonathan): Apply version-specific constraints automatically
        if (permission.equals(INTERACT_ACROSS_USERS_FULL)) {
            requireSdkVersion(
                    Build.VERSION_CODES.Q, Integer.MAX_VALUE, FailureMode.SKIP,
                    ""This test requires INTERACT_ACROSS_USERS_FULL which can only be used on Q+"");
        }
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.media.cts.AudioRecordingConfigurationTest"	"testParcel"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioRecordingConfigurationTest.java"	""	"public void testParcel() throws Exception {
        if (!hasMicrophone()) {
            return;
        }
        AudioManager am = new AudioManager(getContext());
        assertNotNull(""Could not create AudioManager"", am);

        assertEquals(AudioRecord.STATE_INITIALIZED, mAudioRecord.getState());
        mAudioRecord.startRecording();
        assertEquals(AudioRecord.RECORDSTATE_RECORDING, mAudioRecord.getRecordingState());
        Thread.sleep(TEST_TIMING_TOLERANCE_MS);

        List<AudioRecordingConfiguration> configs = am.getActiveRecordingConfigurations();
        assertTrue(""Empty array of record configs during recording"", configs.size() > 0);
        assertEquals(0, configs.get(0).describeContents());

        // marshall a AudioRecordingConfiguration and compare to unmarshalled
        final Parcel srcParcel = Parcel.obtain();
        final Parcel dstParcel = Parcel.obtain();

        configs.get(0).writeToParcel(srcParcel, 0 /*no public flags for marshalling*/);
        final byte[] mbytes = srcParcel.marshall();
        dstParcel.unmarshall(mbytes, 0, mbytes.length);
        dstParcel.setDataPosition(0);
        final AudioRecordingConfiguration unmarshalledConf =
                AudioRecordingConfiguration.CREATOR.createFromParcel(dstParcel);

        assertNotNull(""Failure to unmarshall AudioRecordingConfiguration"", unmarshalledConf);
        assertEquals(""Source and destination AudioRecordingConfiguration not equal"",
                configs.get(0), unmarshalledConf);
    }

    static class MyAudioRecordingCallback extends AudioManager.AudioRecordingCallback {
        boolean mCalled;
        List<AudioRecordingConfiguration> mConfigs;
        private final int mTestSource;
        private final int mTestSession;
        private CountDownLatch mCountDownLatch;

        void reset() {
            mCountDownLatch = new CountDownLatch(1);
            mCalled = false;
            mConfigs = new ArrayList<AudioRecordingConfiguration>();
        }

        MyAudioRecordingCallback(int session, int source) {
            mTestSource = source;
            mTestSession = session;
            reset();
        }

        @Override
        public void onRecordingConfigChanged(List<AudioRecordingConfiguration> configs) {
            mCalled = true;
            mConfigs = configs;
            mCountDownLatch.countDown();
        }

        void await(long timeoutMs) {
            try {
                mCountDownLatch.await(timeoutMs, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            }
        }
    }

    private static boolean deviceMatch(AudioDeviceInfo devJoe, AudioDeviceInfo devJeff) {
        return ((devJoe.getId() == devJeff.getId()
                && (devJoe.getAddress() == devJeff.getAddress())
                && (devJoe.getType() == devJeff.getType())));
    }

    private static boolean verifyAudioConfig(int source, int session, AudioFormat format,
            AudioDeviceInfo device, List<AudioRecordingConfiguration> configs) {
        final Iterator<AudioRecordingConfiguration> confIt = configs.iterator();
        while (confIt.hasNext()) {
            final AudioRecordingConfiguration config = confIt.next();
            final AudioDeviceInfo configDevice = config.getAudioDevice();
            assertTrue(""Current recording config has null device"", configDevice != null);
            if ((config.getClientAudioSource() == source)
                    && (config.getClientAudioSessionId() == session)
                    // test the client format matches that requested (same as the AudioRecord's)
                    && (config.getClientFormat().getEncoding() == format.getEncoding())
                    && (config.getClientFormat().getSampleRate() == format.getSampleRate())
                    && (config.getClientFormat().getChannelMask() == format.getChannelMask())
                    && (config.getClientFormat().getChannelIndexMask() ==
                            format.getChannelIndexMask())
                    // test the device format is configured
                    && (config.getFormat().getEncoding() != AudioFormat.ENCODING_INVALID)
                    && (config.getFormat().getSampleRate() > 0)
                    //  for the channel mask, either the position or index-based value must be valid
                    && ((config.getFormat().getChannelMask() != AudioFormat.CHANNEL_INVALID)
                            || (config.getFormat().getChannelIndexMask() !=
                                    AudioFormat.CHANNEL_INVALID))
                    && deviceMatch(device, configDevice)) {
                return true;
            }
        }
        return false;
    }

    private boolean hasMicrophone() {
        return getContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_MICROPHONE);
    }

    private static void verifyPrivilegedInfoIsSafe(AudioRecordingConfiguration config) {
        // verify ""privileged"" fields aren't available through reflection
        final Class<?> confClass = config.getClass();
        try {
            final Method getClientUidMethod = confClass.getDeclaredMethod(""getClientUid"");
            final Method getClientPackageName = confClass.getDeclaredMethod(""getClientPackageName"");
            try {
                getClientUidMethod.invoke(config, (Object[]) null);
                fail(""InvocationTargetException expected during reflection for getClientUid "" +
                    ""without permission"");
            } catch (InvocationTargetException ex) {
                assertEquals(
                    ""SecurityException cause expected for getClientUid without permission"",
                    SecurityException.class /*expected*/,
                    ex.getCause().getClass());
            }
            String name = (String) getClientPackageName.invoke(config, (Object[]) null);
            assertNotNull(""client package name is null"", name);
            assertEquals(""client package name isn't protected"", 0 /*expected*/, name.length());
        } catch (Exception e) {
            fail(""Exception thrown during reflection on config privileged fields"" + e);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2039"	"testPocCVE_2019_2039"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2039.java"	""	"@AsbSecurityTest(cveBugId = 121260197)
    public void testPocCVE_2019_2039() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2039"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.LlcpVersionActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/LlcpVersionActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.app.Dialog;
import android.nfc.NdefMessage;
import android.nfc.NdefRecord;
import android.nfc.NfcAdapter;
import android.nfc.NfcEvent;
import android.nfc.NfcManager;
import android.os.Build;
import android.os.Bundle;
import android.widget.TextView;

import java.nio.charset.Charset;

/**
 * Test activity that sends a particular NDEF Push message to another NFC device.
 */
public class LlcpVersionActivity extends PassFailButtons.Activity implements
        NfcAdapter.CreateNdefMessageCallback {

    private static final int NFC_NOT_ENABLED_DIALOG_ID = 1;
    private static final int NDEF_PUSH_NOT_ENABLED_DIALOG_ID = 2;

    private NfcAdapter mNfcAdapter;
    private TextView mTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setInfoResources(R.string.nfc_llcp_version_check, R.string.nfc_llcp_version_check_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mTextView = (TextView) findViewById(R.id.text);
        mTextView.setText(R.string.nfc_llcp_version_check_info);

        NfcManager nfcManager = (NfcManager) getSystemService(NFC_SERVICE);
        mNfcAdapter = nfcManager.getDefaultAdapter();
    }

    private static NdefMessage getTestMessage() {
        byte[] mimeBytes = ""application/com.android.cts.verifier.nfc""
                .getBytes(Charset.forName(""US-ASCII""));
        byte[] id = new byte[] {1, 3, 3, 7};
        byte[] payload = ""CTS Verifier NDEF Push Tag"".getBytes(Charset.forName(""US-ASCII""));
        return new NdefMessage(new NdefRecord[] {
                new NdefRecord(NdefRecord.TNF_MIME_MEDIA, mimeBytes, id, payload)
        });
    }

    @Override
    protected void onResume() {
        super.onResume();

        if (!mNfcAdapter.isEnabled()) {
            showDialog(NFC_NOT_ENABLED_DIALOG_ID);
        } else if (!mNfcAdapter.isNdefPushEnabled()) {
            /* Sender must have NDEF push enabled */
            showDialog(NDEF_PUSH_NOT_ENABLED_DIALOG_ID);
        }

        mNfcAdapter.setNdefPushMessageCallback(this, this);
    }

    @Override
    protected void onPause() {
        super.onPause();
    }

    @Override
    public Dialog onCreateDialog(int id, Bundle args) {
        switch (id) {
            case NFC_NOT_ENABLED_DIALOG_ID:
                return NfcDialogs.createNotEnabledDialog(this);
            case NDEF_PUSH_NOT_ENABLED_DIALOG_ID:
                return NfcDialogs.createNdefPushNotEnabledDialog(this);
            default:
                return super.onCreateDialog(id, args);
        }
    }

    @Override
    public NdefMessage createNdefMessage(NfcEvent event) {
        if (event.peerLlcpMajorVersion <= 1 && event.peerLlcpMinorVersion < 2) {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    mTextView.setText(R.string.nfc_llcp_version_check_failure);
                }
            });
        } else {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    getPassButton().setEnabled(true);
                    mTextView.setText(R.string.nfc_llcp_version_check_success);
                }
            });
        }
        return null;
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2019"	"testPocCVE_2019_2019"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2019.java"	""	"@AsbSecurityTest(cveBugId = 115635871)
    public void testPocCVE_2019_2019() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2019"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.media.mediaparser.cts.MediaParserTest"	"testWavWithImaAdpcm"	"CtsMediaParserTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/mediaparser/src/android/media/mediaparser/cts/MediaParserTest.java"	""	"public void testWavWithImaAdpcm() throws IOException {
        testAssetExtraction(""wav/sample_ima_adpcm.wav"");
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2018_9558"	"testPocCVE_2018_9558"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2018_9558.java"	""	"@AsbSecurityTest(cveBugId = 112161557)
    public void testPocCVE_2018_9558() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        String binaryName = ""CVE-2018-9558"";
        String signals[] = {CrashUtils.SIGSEGV, CrashUtils.SIGBUS, CrashUtils.SIGABRT};
        AdbUtils.pocConfig testConfig = new AdbUtils.pocConfig(binaryName, getDevice());
        testConfig.config = new CrashUtils.Config().setProcessPatterns(binaryName);
        testConfig.config.setSignals(signals);
        AdbUtils.runPocAssertNoCrashesNotVulnerable(testConfig);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DeviceOwnerTest"	"TestApis"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DeviceOwnerTest.java"	""	"/*
 *.
 */

package com.android.bedstead.nene.devicepolicy;

import static com.google.common.truth.Truth.assertThat;

import android.content.ComponentName;

import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.users.UserReference;
import com.android.bedstead.testapp.TestApp;
import com.android.bedstead.testapp.TestAppProvider;
import com.android.eventlib.premade.EventLibDeviceAdminReceiver;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

@RunWith(JUnit4.class)
public class DeviceOwnerTest {

    //  TODO(180478924): We shouldn't need to hardcode this
    private static final String DEVICE_ADMIN_TESTAPP_PACKAGE_NAME = ""android.DeviceAdminTestApp"";
    private static final ComponentName DPC_COMPONENT_NAME =
            new ComponentName(DEVICE_ADMIN_TESTAPP_PACKAGE_NAME,
                    EventLibDeviceAdminReceiver.class.getName());

    private static final TestApis sTestApis = new TestApis();
    private static final UserReference sUser = sTestApis.users().instrumented();

    private static TestApp sTestApp;
    private static DeviceOwner sDeviceOwner;

    @BeforeClass
    public static void setupClass() {
        sTestApp = new TestAppProvider().query()
                .wherePackageName().isEqualTo(DEVICE_ADMIN_TESTAPP_PACKAGE_NAME)
                .get();

        sTestApp.install(sUser);

        sDeviceOwner = sTestApis.devicePolicy().setDeviceOwner(sUser, DPC_COMPONENT_NAME);
    }

    @AfterClass
    public static void teardownClass() {
        sDeviceOwner.remove();
        sTestApp.uninstall(sUser);
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DeviceOwnerTest"	"isNull"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DeviceOwnerTest.java"	""	"public void remove_removesDeviceOwner() {
        sDeviceOwner.remove();
        try {
            assertThat(sTestApis.devicePolicy().getDeviceOwner()).isNull();
        } finally {
            sDeviceOwner = sTestApis.devicePolicy().setDeviceOwner(sUser, DPC_COMPONENT_NAME);
        }
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.PrefixPaymentEmulator2Activity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/PrefixPaymentEmulator2Activity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

@TargetApi(19)
public class PrefixPaymentEmulator2Activity extends BaseEmulatorActivity {
    final static int STATE_IDLE = 0;
    final static int STATE_SERVICE1_SETTING_UP = 1;
    final static int STATE_SERVICE2_SETTING_UP = 2;
    final static int STATE_MAKING_SERVICE2_DEFAULT = 3;

    int mState = STATE_IDLE;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        mState = STATE_SERVICE2_SETTING_UP;
        setupServices(this, PrefixPaymentService2.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        if (mState == STATE_SERVICE2_SETTING_UP) {
            mState = STATE_SERVICE1_SETTING_UP;
            setupServices(this, PrefixPaymentService1.COMPONENT, PrefixPaymentService2.COMPONENT);
            return;
        }
        // Verify HCE service 2 is the default
        if (makePaymentDefault(PrefixPaymentService2.COMPONENT, R.string.nfc_hce_change_preinstalled_wallet)) {
            mState = STATE_MAKING_SERVICE2_DEFAULT;
        } else {
            // Already default
            NfcDialogs.createHceTapReaderDialog(this,getString(R.string.nfc_hce_payment_prefix_aids_help)).show();
        }
    }

    @Override
    void onPaymentDefaultResult(ComponentName component, boolean success) {
        if (success) {
            NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_hce_payment_prefix_aids_help)).show();
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
    }
    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                PrefixPaymentService2.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                PrefixPaymentService2.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_payment_prefix_aids_reader_2));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(PrefixPaymentService2.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.BaseEmulatorActivity"	"OnClickListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/BaseEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.nfc.NfcAdapter;
import android.nfc.cardemulation.CardEmulation;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

@TargetApi(19)
public abstract class BaseEmulatorActivity extends PassFailButtons.Activity {
    static final String TAG = ""BaseEmulatorActivity"";
    NfcAdapter mAdapter;
    CardEmulation mCardEmulation;
    ProgressDialog mSetupDialog;
    ComponentName mMakingDefault;

    final ArrayList<ComponentName> SERVICES = new ArrayList<ComponentName>(
            Arrays.asList(
            PaymentService1.COMPONENT,
            PaymentService2.COMPONENT,
            TransportService1.COMPONENT,
            TransportService2.COMPONENT,
            AccessService.COMPONENT,
            ThroughputService.COMPONENT,
            OffHostService.COMPONENT,
            PaymentServiceDynamicAids.COMPONENT,
            PrefixPaymentService1.COMPONENT,
            PrefixPaymentService2.COMPONENT,
            PrefixTransportService1.COMPONENT,
            PrefixTransportService2.COMPONENT,
            PrefixAccessService.COMPONENT,
            LargeNumAidsService.COMPONENT,
            ScreenOnOnlyOffHostService.COMPONENT,
            ScreenOffPaymentService.COMPONENT)
    );

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mAdapter = NfcAdapter.getDefaultAdapter(this);
        mCardEmulation = CardEmulation.getInstance(mAdapter);
        IntentFilter filter = new IntentFilter(HceUtils.ACTION_APDU_SEQUENCE_COMPLETE);
        registerReceiver(mReceiver, filter);
    }

    abstract void onServicesSetup(boolean result);

    abstract void onApduSequenceComplete(ComponentName component, long duration);

    void onApduSequenceError() {

    }

    @Override
    protected void onStop() {
        super.onStop();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(mReceiver);
    }

    @Override
    protected void onPause() {
        super.onPause();
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    final void setupServices(Context context, ComponentName... components) {
        mSetupDialog = new ProgressDialog(context);
        new SetupServicesTask().execute(components);
    }

    final boolean makePaymentDefault(final ComponentName defaultComponent, int stringId) {
        if (!mCardEmulation.isDefaultServiceForCategory(defaultComponent,
                CardEmulation.CATEGORY_PAYMENT)) {
            AlertDialog.Builder builder = new AlertDialog.Builder(this);
            builder.setTitle(""Note"");
            builder.setMessage(stringId);
            mMakingDefault = defaultComponent;
            builder.setPositiveButton(""OK"", new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                Intent changeDefault = new Intent(CardEmulation.ACTION_CHANGE_DEFAULT);
                changeDefault.putExtra(CardEmulation.EXTRA_CATEGORY, CardEmulation.CATEGORY_PAYMENT);
                changeDefault.putExtra(CardEmulation.EXTRA_SERVICE_COMPONENT, defaultComponent);
                startActivityForResult(changeDefault, 0);
                }
            });
            builder.show();
            return true;
        } else {
            return false;
        }
    }

    final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (HceUtils.ACTION_APDU_SEQUENCE_COMPLETE.equals(action)) {
                // Get component whose sequence was completed
                ComponentName component = intent.getParcelableExtra(HceUtils.EXTRA_COMPONENT);
                long duration = intent.getLongExtra(HceUtils.EXTRA_DURATION, 0);
                if (component != null) {
                    onApduSequenceComplete(component, duration);
                }
            } else if (HceUtils.ACTION_APDU_SEQUENCE_ERROR.equals(action)) {
                onApduSequenceError();
            }
        }
    };

    private class SetupServicesTask extends AsyncTask<ComponentName, Void, Boolean> {
        @Override
        protected void onPostExecute(Boolean result) {
            super.onPostExecute(result);
            mSetupDialog.dismiss();
            onServicesSetup(result);
        }

        @Override
        protected void onPreExecute() {
            super.onPreExecute();
            mSetupDialog.setTitle(R.string.nfc_hce_please_wait);
            mSetupDialog.setMessage(getString(R.string.nfc_hce_setting_up));
            mSetupDialog.setCancelable(false);
            mSetupDialog.show();
        }

        @Override
        protected Boolean doInBackground(ComponentName... components) {
            List<ComponentName> enableComponents = Arrays.asList(components);
            for (ComponentName component : SERVICES) {
                if (enableComponents.contains(component)) {
                    Log.d(TAG, ""Enabling component "" + component);
                    HceUtils.enableComponent(getPackageManager(), component);
                } else {
                    Log.d(TAG, ""Disabling component "" + component);
                    HceUtils.disableComponent(getPackageManager(), component);
                }
            }
            // This is a trick to invalidate the HCE cache and avoid
            // having to wait for PackageManager broadcasts to NFCService.
            ComponentName bogusComponent = new ComponentName(""com.android.cts.verifier"",
                    ""com.android.cts.verifier.nfc.hce.BogusService"");
            mCardEmulation.isDefaultServiceForCategory(bogusComponent,
                    CardEmulation.CATEGORY_PAYMENT);
            return true;
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (resultCode == Activity.RESULT_OK) {
            // Verify it's default
            if (!mCardEmulation.isDefaultServiceForCategory(mMakingDefault,
                    CardEmulation.CATEGORY_PAYMENT)) {
                // Popup dialog-box
                AlertDialog.Builder builder = new AlertDialog.Builder(this);
                builder.setTitle(""Test failed."");
                builder.setMessage(""The service was not made the default service according "" +
                        ""to CardEmulation.getDefaultServiceForCategory(), verify the make "" +
                        ""default implementation is correct."");
                builder.setPositiveButton(""OK"", null);
                builder.show();
                onPaymentDefaultResult(mMakingDefault, false);
            } else {
                onPaymentDefaultResult(mMakingDefault, true);
            }
        } else {
            AlertDialog.Builder builder = new AlertDialog.Builder(this);
            builder.setTitle(""Test failed."");
            builder.setMessage(""You clicked no."");
            builder.setPositiveButton(""OK"", null);
            builder.show();
            onPaymentDefaultResult(mMakingDefault, false);
        }
    }

    void onPaymentDefaultResult(ComponentName component, boolean success) {

    };
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2038"	"testPocCVE_2019_2038"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2038.java"	""	"@AsbSecurityTest(cveBugId = 121259048)
    public void testPocCVE_2019_2038() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2038"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.HceService"	"currentTimeMillis"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/HceService.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Intent;
import android.nfc.cardemulation.HostApduService;
import android.os.Bundle;
import android.util.Log;

import java.util.Arrays;

@TargetApi(19)
public abstract class HceService extends HostApduService {
    final static String TAG = ""HceService"";

    final static int STATE_IDLE = 0;
    final static int STATE_IN_PROGRESS = 1;
    final static int STATE_FAILED = 2;

    // Variables below only used on main thread
    CommandApdu[] mCommandApdus = null;
    String[] mResponseApdus = null;
    int mApduIndex = 0;
    int mState = STATE_IDLE;
    long mStartTime;

    public void initialize(CommandApdu[] commandApdus, String[] responseApdus) {
       mCommandApdus = commandApdus;
       mResponseApdus = responseApdus;
    }

    @Override
    public void onDeactivated(int arg0) {
        mApduIndex = 0;
        mState = STATE_IDLE;
    }

    public abstract ComponentName getComponent();

    public void onApduSequenceComplete() {
        Intent completionIntent = new Intent(HceUtils.ACTION_APDU_SEQUENCE_COMPLETE);
        completionIntent.putExtra(HceUtils.EXTRA_COMPONENT, getComponent());
        completionIntent.putExtra(HceUtils.EXTRA_DURATION,
                System.currentTimeMillis() - mStartTime);
        sendBroadcast(completionIntent);
    }

    public void onApduSequenceError() {
        Intent errorIntent = new Intent(HceUtils.ACTION_APDU_SEQUENCE_ERROR);
        sendBroadcast(errorIntent);
    }

    @Override
    public byte[] processCommandApdu(byte[] arg0, Bundle arg1) {
        if (mState == STATE_FAILED) {
            // Don't accept any more APDUs until deactivated
            return null;
        }

        if (mState == STATE_IDLE) {
            mState = STATE_IN_PROGRESS;
            mStartTime = System.currentTimeMillis();
        }


        if (mApduIndex >= mCommandApdus.length) {
         // Skip all APDUs which aren't supposed to reach us
            return null;
        }

        do {
            if (!mCommandApdus[mApduIndex].isReachable()) {
                mApduIndex++;
            } else {
                break;
            }
        } while (mApduIndex < mCommandApdus.length);

        if (mApduIndex >= mCommandApdus.length) {
            Log.d(TAG, ""Ignoring command APDU; protocol complete."");
            // Ignore new APDUs after completion
            return null;
        } else {

            if (!Arrays.equals(HceUtils.hexStringToBytes(mCommandApdus[mApduIndex].getApdu()), arg0)) {
                Log.d(TAG, ""Unexpected command APDU: "" + HceUtils.getHexBytes("""", arg0));
                onApduSequenceError();
                return null;
            } else {
                // Send corresponding response APDU
                byte[] responseApdu = HceUtils.hexStringToBytes(mResponseApdus[mApduIndex]);
                mApduIndex++;
                if (mApduIndex == mCommandApdus.length) {
                    // Test passed
                    onApduSequenceComplete();
                }
                return responseApdu;
            }
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.ProfileOwnerTest"	"TestApis"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/ProfileOwnerTest.java"	""	"/*
 *.
 */

package com.android.bedstead.nene.devicepolicy;

import static com.google.common.truth.Truth.assertThat;

import android.content.ComponentName;

import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.users.UserReference;
import com.android.bedstead.nene.users.UserType;
import com.android.bedstead.testapp.TestApp;
import com.android.bedstead.testapp.TestAppProvider;
import com.android.eventlib.premade.EventLibDeviceAdminReceiver;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

@RunWith(JUnit4.class)
public class ProfileOwnerTest {

    //  TODO(180478924): We shouldn't need to hardcode this
    private static final String DEVICE_ADMIN_TESTAPP_PACKAGE_NAME = ""android.DeviceAdminTestApp"";
    private static final ComponentName DPC_COMPONENT_NAME =
            new ComponentName(DEVICE_ADMIN_TESTAPP_PACKAGE_NAME,
                    EventLibDeviceAdminReceiver.class.getName());

    private static final TestApis sTestApis = new TestApis();
    private static final UserReference sUser = sTestApis.users().instrumented();
    private static UserReference sProfile;

    private static TestApp sTestApp;
    private static ProfileOwner sProfileOwner;

    @BeforeClass
    public static void setupClass() {
        sProfile = sTestApis.users().createUser()
                .parent(sUser)
                .type(sTestApis.users().supportedType(UserType.MANAGED_PROFILE_TYPE_NAME))
                .createAndStart();

        sTestApp = new TestAppProvider().query()
                .wherePackageName().isEqualTo(DEVICE_ADMIN_TESTAPP_PACKAGE_NAME)
                .get();

        sTestApp.install(sProfile);

        sProfileOwner = sTestApis.devicePolicy().setProfileOwner(sProfile, DPC_COMPONENT_NAME);
    }

    @AfterClass
    public static void teardownClass() {
        sProfile.remove();
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.ProfileOwnerTest"	"isNull"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/ProfileOwnerTest.java"	""	"public void remove_removesProfileOwner() {
        sProfileOwner.remove();
        try {
            assertThat(sTestApis.devicePolicy().getProfileOwner(sProfile)).isNull();
        } finally {
            sProfileOwner = sTestApis.devicePolicy().setProfileOwner(sProfile, DPC_COMPONENT_NAME);
        }
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.offhost.OffhostUiccEmulatorTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/offhost/OffhostUiccEmulatorTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.offhost;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.nfc.NfcAdapter;
import android.nfc.cardemulation.CardEmulation;
import android.os.Bundle;

/** Activity that lists all the NFC Offhost-UICC emulator tests. */
public class OffhostUiccEmulatorTestActivity extends PassFailButtons.TestListActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.nfc_test, R.string.nfc_offhost_uicc_emulator_test_info, 0);
        setPassFailButtonClickListeners();

        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_OFF_HOST_CARD_EMULATION_UICC)) {
            adapter.add(TestListItem.newCategory(this, R.string.nfc_offhost_uicc_emulator_tests));

            adapter.add(TestListItem.newTest(this, R.string.nfc_offhost_uicc_transaction_event1_emulator,
                    UiccTransactionEvent1EmulatorActivity.class.getName(),
                    new Intent(this, UiccTransactionEvent1EmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_offhost_uicc_transaction_event2_emulator,
                    UiccTransactionEvent2EmulatorActivity.class.getName(),
                    new Intent(this, UiccTransactionEvent2EmulatorActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_offhost_uicc_transaction_event3_emulator,
                    UiccTransactionEvent3EmulatorActivity.class.getName(),
                    new Intent(this, UiccTransactionEvent3EmulatorActivity.class), null));

        }

        setTestListAdapter(adapter);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.ConflictingNonPaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ConflictingNonPaymentEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class ConflictingNonPaymentEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setupServices(this, TransportService1.COMPONENT, TransportService2.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this,
                getString(R.string.nfc_hce_conflicting_non_payment_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                TransportService2.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                TransportService2.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_conflicting_non_payment_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(TransportService2.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.car.cts.powerpolicy.PowerPolicyDef"	"getDisables"	"CtsCarHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/car/src/android/car/cts/powerpolicy/PowerPolicyDef.java"	""	"public void test/*
 *.
 */

package android.car.cts.powerpolicy;

import com.android.tradefed.log.LogUtil.CLog;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.StringTokenizer;

public final class PowerPolicyDef {
    public static final String[] ENABLED_HEADERS =
            {""enabledComponents"", ""Enabled components""};
    public static final String[] DISABLED_HEADERS =
            {""disabledComponents"", ""Disabled components""};
    public static final int STRING_BUILDER_BUF_SIZE = 1024;

    private final String mPolicyId;
    private final PowerComponent[] mEnables;
    private final PowerComponent[] mDisables;

    private PowerPolicyDef(String policyId, PowerComponent[] enables, PowerComponent[] disables) {
        mPolicyId = policyId;
        mEnables = enables;
        mDisables = disables;
    }

    public String getPolicyId() {
        return mPolicyId;
    }

    public PowerComponent[] getEnables() {
        return mEnables;
    }

    public PowerComponent[] getDisables() {
        return mDisables;
    }

    @Override
    public String toString() {
        String[] enables = Arrays.stream(mEnables).map(PowerComponent::getValue)
                .toArray(String[]::new);
        String[] disables = Arrays.stream(mDisables).map(PowerComponent::getValue)
                .toArray(String[]::new);
        StringBuilder str = new StringBuilder();
        str.append(mPolicyId);
        if (enables.length > 0) {
            str.append("" --enable "").append(String.join("","", enables));
        }
        if (disables.length > 0) {
            str.append("" --disable "").append(String.join("","", disables));
        }
        return str.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PowerPolicyDef that = (PowerPolicyDef) o;
        return Objects.equals(mPolicyId, that.mPolicyId)
                && Arrays.equals(mEnables, that.mEnables)
                && Arrays.equals(mDisables, that.mDisables);
    }

    @Override
    public int hashCode() {
        int result = Objects.hash(mPolicyId);
        result = 31 * result + Arrays.hashCode(mEnables);
        result = 31 * result + Arrays.hashCode(mDisables);
        return result;
    }

    public static PowerPolicyDef parse(String policyDefStr, boolean hasPolicyId, int offset)
            throws Exception {
        if (policyDefStr == null) {
            throw new IllegalArgumentException(""null policyDefStr parameter"");
        }
        CLog.d(""policyDefStr: "" + policyDefStr);

        StringTokenizer tokens = new StringTokenizer(policyDefStr, ""():"");
        String policyId = hasPolicyId
                ? tokens.nextToken().trim().substring(offset).trim() : IdSet.NONE;

        if (!search(ENABLED_HEADERS, tokens.nextToken().trim())) {
            throw new IllegalArgumentException(""malformatted enabled headers string: ""
                    + policyDefStr);
        }

        int idx = 0;
        String[] enables = null;
        String tmpStr = tokens.nextToken().trim();
        CLog.d(""enables: "" + tmpStr);
        for (String hdr : DISABLED_HEADERS) {
            idx = tmpStr.indexOf(hdr);
            if (idx >= 0) {
                tmpStr = tmpStr.substring(0, idx).trim();
                if (!tmpStr.isEmpty()) {
                    enables = tmpStr.split("",\\s*"");
                }
                break;
            }
        }
        if (idx < 0) {
            throw new IllegalArgumentException(""malformatted disabled headers string: ""
                    + policyDefStr);
        }
        PowerComponent[] enabledComps = PowerComponent.asComponentArray(enables);

        String[] disables = null;
        tmpStr = tokens.nextToken().trim();
        CLog.d(""disables: "" + tmpStr);
        if (!tmpStr.isEmpty()) {
            disables = tmpStr.split("",\\s*"");
        }
        PowerComponent[] disabledComps = PowerComponent.asComponentArray(disables);

        return new PowerPolicyDef(policyId, enabledComps, disabledComps);
    }

    public static PowerPolicyDef createWithComponentOff(String component)
            throws Exception {
        PowerComponent removingComp = PowerComponent.valueOf(component);

        ArrayList<PowerComponent> enableList = new ArrayList<PowerComponent>(
                Arrays.asList(ComponentList.ALL_COMPONENTS));
        if (!enableList.remove(removingComp)) {
            throw new IllegalArgumentException(component + "" is not in the all list"");
        }

        PowerComponent[] enables = enableList.toArray(new PowerComponent[0]);
        PowerComponent[] disables = {removingComp};
        String policyId = component + ""_disable"";

        return new PowerPolicyDef(policyId, enables, disables);
    }

    private static boolean search(String[] strList, String str) {
        return Arrays.stream(strList).anyMatch(s -> str.contains(s));
    }

    public static final class IdSet {
        public static final String DEFAULT_ALL_ON = ""system_power_policy_all_on"";
        public static final String INITIAL_ALL_ON = ""system_power_policy_initiall_on"";
        public static final String NO_USER_INTERACTION = ""system_power_policy_no_user_interaction"";
        public static final String NONE = ""none"";
        public static final String TEST1 = ""test1"";
        public static final String TEST2 = ""test2"";
        public static final String ERROR_TEST1 = ""error_test1"";
        public static final String ERROR_TEST2 = ""error_test2"";
        public static final String LISTENER_TEST = ""listener_test"";
    }

    public enum PowerComponent {
        NONE(""none""),
        UNKNOWN(""UNKNOWN""),
        AUDIO(""AUDIO""),
        MEDIA(""MEDIA""),
        DISPLAY(""DISPLAY""),
        BLUETOOTH(""BLUETOOTH""),
        WIFI(""WIFI""),
        CELLULAR(""CELLULAR""),
        ETHERNET(""ETHERNET""),
        PROJECTION(""PROJECTION""),
        NFC(""NFC""),
        INPUT(""INPUT""),
        VOICE_INTERACTION(""VOICE_INTERACTION""),
        VISUAL_INTERACTION(""VISUAL_INTERACTION""),
        TRUSTED_DEVICE_DETECTION(""TRUSTED_DEVICE_DETECTION""),
        LOCATION(""LOCATION""),
        MICROPHONE(""MICROPHONE""),
        CPU(""CPU"");

        private final String mValue;

        PowerComponent(String v) {
            mValue = v;
        }

        public String getValue() {
            return mValue;
        }

        public static PowerComponent[] asComponentArray(String[] componentNames) {
            if (componentNames == null) {
                return new PowerComponent[0];
            }
            normalizeComponentName(componentNames);
            PowerComponent[] compArray = Arrays.stream(componentNames).map(PowerComponent::valueOf)
                    .filter(e -> e != NONE).toArray(PowerComponent[]::new);
            Arrays.sort(compArray);
            return compArray;
        }

        public static PowerComponent[] asComponentArray(List<String> nameList) {
            if (nameList == null) {
                return new PowerComponent[0];
            }
            return asComponentArray(nameList.toArray(new String[0]));
        }

        private static void normalizeComponentName(String[] comps) {
            for (int i = 0; i < comps.length; i++) {
                try {
                    PowerComponent.valueOf(comps[i]);
                } catch (Exception e) {
                    if (comps[i] != null && comps[i].equals(""none"")) {
                        comps[i] = ""NONE"";
                    }
                }
            }
        }
    }

    private static final class ComponentList {
        static final PowerComponent[] ALL_COMPONENTS = {
            PowerComponent.AUDIO,
            PowerComponent.MEDIA,
            PowerComponent.DISPLAY,
            PowerComponent.BLUETOOTH,
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.LOCATION,
            PowerComponent.MICROPHONE,
            PowerComponent.CPU
        };

        static final PowerComponent[] INIT_ALL_ON_ENABLE = {
            PowerComponent.AUDIO,
            PowerComponent.DISPLAY,
            PowerComponent.CPU
        };

        static final PowerComponent[] INIT_ALL_ON_DISABLE = {
            PowerComponent.MEDIA,
            PowerComponent.BLUETOOTH,
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.LOCATION,
            PowerComponent.MICROPHONE
        };

        static final PowerComponent[] DEFAULT_ALL_ON_ENABLE = ALL_COMPONENTS;
        static final PowerComponent[] DEFAULT_ALL_ON_DISABLE = {};

        static final PowerComponent[] NO_USER_INTERACT_ENABLE = {
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.CPU
        };

        static final PowerComponent[] NO_USER_INTERACT_DISABLE = {
            PowerComponent.AUDIO,
            PowerComponent.MEDIA,
            PowerComponent.DISPLAY,
            PowerComponent.BLUETOOTH,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.LOCATION,
            PowerComponent.MICROPHONE
        };

        static final PowerComponent[] TEST1_ENABLE =  ALL_COMPONENTS;
        static final PowerComponent[] TEST1_DISABLE = {};

        static final PowerComponent[] TEST2_ENABLE = {};
        static final PowerComponent[] TEST2_DISABLE = ALL_COMPONENTS;

        static final PowerComponent[] ERROR_TEST1_ENABLE = ALL_COMPONENTS;
        static final PowerComponent[] ERROR_TEST1_DISABLE = {PowerComponent.UNKNOWN};

        static final PowerComponent[] ERROR_TEST2_ENABLE = {
            PowerComponent.AUDIO,
            PowerComponent.MEDIA,
            PowerComponent.DISPLAY,
            PowerComponent.UNKNOWN,
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.LOCATION,
            PowerComponent.MICROPHONE,
            PowerComponent.CPU
        };
        static final PowerComponent[] ERROR_TEST2_DISABLE = {};

        static final PowerComponent[] RUNTIME_DEFAULT_ENABLE = ALL_COMPONENTS;
        static final PowerComponent[] RUNTIME_DEFAULT_DISABLE = {};

        static final PowerComponent[] RUNTIME_SILENT_ENABLE = {
            PowerComponent.AUDIO,
            PowerComponent.MEDIA,
            PowerComponent.DISPLAY,
            PowerComponent.BLUETOOTH,
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.LOCATION,
            PowerComponent.MICROPHONE,
            PowerComponent.CPU
        };
        static final PowerComponent[] RUNTIME_SILENT_DISABLE = {};

        static final PowerComponent[] LISTENER_TEST_ENABLE = {
            PowerComponent.MEDIA,
            PowerComponent.DISPLAY,
            PowerComponent.BLUETOOTH,
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.LOCATION,
            PowerComponent.CPU
        };

        static final PowerComponent[] LISTENER_TEST_DISABLE = {
            PowerComponent.AUDIO,
            PowerComponent.MICROPHONE
        };
    }

    public static final class PolicySet {
        public static final int TOTAL_DEFAULT_REGISTERED_POLICIES = 2;

        public static final PowerPolicyDef
                INITIAL_ALL_ON = new PowerPolicyDef(IdSet.INITIAL_ALL_ON,
                ComponentList.INIT_ALL_ON_ENABLE, ComponentList.INIT_ALL_ON_DISABLE);

        public static final PowerPolicyDef
                DEFAULT_ALL_ON = new PowerPolicyDef(IdSet.DEFAULT_ALL_ON,
                ComponentList.DEFAULT_ALL_ON_ENABLE, ComponentList.DEFAULT_ALL_ON_DISABLE);

        public static final PowerPolicyDef
                NO_USER_INTERACT = new PowerPolicyDef(IdSet.NO_USER_INTERACTION,
                ComponentList.NO_USER_INTERACT_ENABLE, ComponentList.NO_USER_INTERACT_DISABLE);

        public static final PowerPolicyDef TEST1 = new PowerPolicyDef(IdSet.TEST1,
                ComponentList.TEST1_ENABLE, ComponentList.TEST1_DISABLE);

        public static final PowerPolicyDef TEST2 = new PowerPolicyDef(IdSet.TEST2,
                ComponentList.TEST2_ENABLE, ComponentList.TEST2_DISABLE);

        public static final PowerPolicyDef ERROR_TEST1 = new PowerPolicyDef(IdSet.ERROR_TEST1,
                ComponentList.ERROR_TEST1_ENABLE, ComponentList.ERROR_TEST1_DISABLE);

        public static final PowerPolicyDef ERROR_TEST2 = new PowerPolicyDef(IdSet.ERROR_TEST2,
                ComponentList.ERROR_TEST2_ENABLE, ComponentList.ERROR_TEST2_DISABLE);

        public static final PowerPolicyDef LISTENER_TEST = new PowerPolicyDef(IdSet.LISTENER_TEST,
                ComponentList.LISTENER_TEST_ENABLE, ComponentList.LISTENER_TEST_DISABLE);
    }

    public static final class ComponentSet {
        public static final PowerPolicyDef RUNTIME_DEFAULT = new PowerPolicyDef(null,
                ComponentList.RUNTIME_DEFAULT_ENABLE, ComponentList.RUNTIME_DEFAULT_DISABLE);

        public static final PowerPolicyDef RUNTIME_SILENT = new PowerPolicyDef(null,
                ComponentList.RUNTIME_SILENT_ENABLE, ComponentList.RUNTIME_SILENT_DISABLE);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.text.cts.StaticLayoutTest"	"testImmutableStaticLayout"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/cts/StaticLayoutTest.java"	""	"public void testImmutableStaticLayout() {
        Editable editable =  Editable.Factory.getInstance().newEditable(""123\t\n555"");
        StaticLayout layout = new StaticLayout(editable, mDefaultPaint,
                DEFAULT_OUTER_WIDTH, DEFAULT_ALIGN, SPACE_MULTI, SPACE_ADD, true);

        assertEquals(2, layout.getLineCount());
        assertTrue(mDefaultLayout.getLineContainsTab(0));

        // change the text
        editable.delete(0, editable.length() - 1);

        assertEquals(2, layout.getLineCount());
        assertTrue(layout.getLineContainsTab(0));

    }

    // String wrapper for testing not well known implementation of CharSequence.
    private class FakeCharSequence implements CharSequence {
        private String mStr;

        public FakeCharSequence(String str) {
            mStr = str;
        }

        @Override
        public char charAt(int index) {
            return mStr.charAt(index);
        }

        @Override
        public int length() {
            return mStr.length();
        }

        @Override
        public CharSequence subSequence(int start, int end) {
            return mStr.subSequence(start, end);
        }

        @Override
        public String toString() {
            return mStr;
        }
    };

    private List<CharSequence> buildTestCharSequences(String testString, Normalizer.Form[] forms) {
        List<CharSequence> result = new ArrayList<>();

        List<String> normalizedStrings = new ArrayList<>();
        for (Normalizer.Form form: forms) {
            normalizedStrings.add(Normalizer.normalize(testString, form));
        }

        for (String str: normalizedStrings) {
            result.add(str);
            result.add(new SpannedString(str));
            result.add(new SpannableString(str));
            result.add(new SpannableStringBuilder(str));  // as a GraphicsOperations implementation.
            result.add(new FakeCharSequence(str));  // as a not well known implementation.
        }
        return result;
    }

    private String buildTestMessage(CharSequence seq) {
        String normalized;
        if (Normalizer.isNormalized(seq, Normalizer.Form.NFC)) {
            normalized = ""NFC"";
        } else if (Normalizer.isNormalized(seq, Normalizer.Form.NFD)) {
            normalized = ""NFD"";
        } else if (Normalizer.isNormalized(seq, Normalizer.Form.NFKC)) {
            normalized = ""NFKC"";
        } else if (Normalizer.isNormalized(seq, Normalizer.Form.NFKD)) {
            normalized = ""NFKD"";
        } else {
            throw new IllegalStateException(""Normalized form is not NFC/NFD/NFKC/NFKD"");
        }

        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < seq.length(); ++i) {
            builder.append(String.format(""0x%04X "", Integer.valueOf(seq.charAt(i))));
        }

        return ""testString: \"""" + seq.toString() + ""\""["" + builder.toString() + ""]"" +
                "", class: "" + seq.getClass().getName() +
                "", Normalization: "" + normalized;
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.text.cts.StaticLayoutTest"	"testGetOffset_UNICODE_Normalization"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/cts/StaticLayoutTest.java"	""	"public void testGetOffset_UNICODE_Normalization() {
        // ""A"" with acute, circumflex, tilde, diaeresis, ring above.
        String testString = ""\u00C1\u00C2\u00C3\u00C4\u00C5"";
        Normalizer.Form[] oneUnicodeForms = { Normalizer.Form.NFC, Normalizer.Form.NFKC };
        for (CharSequence seq: buildTestCharSequences(testString, oneUnicodeForms)) {
            StaticLayout layout = new StaticLayout(seq, mDefaultPaint,
                    DEFAULT_OUTER_WIDTH, DEFAULT_ALIGN, SPACE_MULTI, SPACE_ADD, true);

            String testLabel = buildTestMessage(seq);

            assertEquals(testLabel, 0, layout.getOffsetToLeftOf(0));
            assertEquals(testLabel, 0, layout.getOffsetToLeftOf(1));
            assertEquals(testLabel, 1, layout.getOffsetToLeftOf(2));
            assertEquals(testLabel, 2, layout.getOffsetToLeftOf(3));
            assertEquals(testLabel, 3, layout.getOffsetToLeftOf(4));
            assertEquals(testLabel, 4, layout.getOffsetToLeftOf(5));

            assertEquals(testLabel, 1, layout.getOffsetToRightOf(0));
            assertEquals(testLabel, 2, layout.getOffsetToRightOf(1));
            assertEquals(testLabel, 3, layout.getOffsetToRightOf(2));
            assertEquals(testLabel, 4, layout.getOffsetToRightOf(3));
            assertEquals(testLabel, 5, layout.getOffsetToRightOf(4));
            assertEquals(testLabel, 5, layout.getOffsetToRightOf(5));
        }

        Normalizer.Form[] twoUnicodeForms = { Normalizer.Form.NFD, Normalizer.Form.NFKD };
        for (CharSequence seq: buildTestCharSequences(testString, twoUnicodeForms)) {
            StaticLayout layout = new StaticLayout(seq, mDefaultPaint,
                    DEFAULT_OUTER_WIDTH, DEFAULT_ALIGN, SPACE_MULTI, SPACE_ADD, true);

            String testLabel = buildTestMessage(seq);

            assertEquals(testLabel, 0, layout.getOffsetToLeftOf(0));
            assertEquals(testLabel, 0, layout.getOffsetToLeftOf(1));
            assertEquals(testLabel, 0, layout.getOffsetToLeftOf(2));
            assertEquals(testLabel, 2, layout.getOffsetToLeftOf(3));
            assertEquals(testLabel, 2, layout.getOffsetToLeftOf(4));
            assertEquals(testLabel, 4, layout.getOffsetToLeftOf(5));
            assertEquals(testLabel, 4, layout.getOffsetToLeftOf(6));
            assertEquals(testLabel, 6, layout.getOffsetToLeftOf(7));
            assertEquals(testLabel, 6, layout.getOffsetToLeftOf(8));
            assertEquals(testLabel, 8, layout.getOffsetToLeftOf(9));
            assertEquals(testLabel, 8, layout.getOffsetToLeftOf(10));

            assertEquals(testLabel, 2, layout.getOffsetToRightOf(0));
            assertEquals(testLabel, 2, layout.getOffsetToRightOf(1));
            assertEquals(testLabel, 4, layout.getOffsetToRightOf(2));
            assertEquals(testLabel, 4, layout.getOffsetToRightOf(3));
            assertEquals(testLabel, 6, layout.getOffsetToRightOf(4));
            assertEquals(testLabel, 6, layout.getOffsetToRightOf(5));
            assertEquals(testLabel, 8, layout.getOffsetToRightOf(6));
            assertEquals(testLabel, 8, layout.getOffsetToRightOf(7));
            assertEquals(testLabel, 10, layout.getOffsetToRightOf(8));
            assertEquals(testLabel, 10, layout.getOffsetToRightOf(9));
            assertEquals(testLabel, 10, layout.getOffsetToRightOf(10));
        }
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.text.cts.StaticLayoutTest"	"testGetOffset_UNICODE_Arabic"	"CtsTextTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/text/src/android/text/cts/StaticLayoutTest.java"	""	"public void testGetOffset_UNICODE_Arabic() {
        // Arabic Characters. The expected cursorable boundary is
        // | \u0623 \u064F | \u0633 \u0652 | \u0631 \u064E | \u0629 \u064C |"";
        String testString = ""\u0623\u064F\u0633\u0652\u0631\u064E\u0629\u064C"";

        Normalizer.Form[] oneUnicodeForms = { Normalizer.Form.NFC, Normalizer.Form.NFKC };
        for (CharSequence seq: buildTestCharSequences(testString, oneUnicodeForms)) {
            StaticLayout layout = new StaticLayout(seq, mDefaultPaint,
                    DEFAULT_OUTER_WIDTH, DEFAULT_ALIGN, SPACE_MULTI, SPACE_ADD, true);

            String testLabel = buildTestMessage(seq);

            assertEquals(testLabel, 2, layout.getOffsetToLeftOf(0));
            assertEquals(testLabel, 2, layout.getOffsetToLeftOf(1));
            assertEquals(testLabel, 4, layout.getOffsetToLeftOf(2));
            assertEquals(testLabel, 4, layout.getOffsetToLeftOf(3));
            assertEquals(testLabel, 6, layout.getOffsetToLeftOf(4));
            assertEquals(testLabel, 6, layout.getOffsetToLeftOf(5));
            assertEquals(testLabel, 8, layout.getOffsetToLeftOf(6));
            assertEquals(testLabel, 8, layout.getOffsetToLeftOf(7));
            assertEquals(testLabel, 8, layout.getOffsetToLeftOf(8));

            assertEquals(testLabel, 0, layout.getOffsetToRightOf(0));
            assertEquals(testLabel, 0, layout.getOffsetToRightOf(1));
            assertEquals(testLabel, 0, layout.getOffsetToRightOf(2));
            assertEquals(testLabel, 2, layout.getOffsetToRightOf(3));
            assertEquals(testLabel, 2, layout.getOffsetToRightOf(4));
            assertEquals(testLabel, 4, layout.getOffsetToRightOf(5));
            assertEquals(testLabel, 4, layout.getOffsetToRightOf(6));
            assertEquals(testLabel, 6, layout.getOffsetToRightOf(7));
            assertEquals(testLabel, 6, layout.getOffsetToRightOf(8));
        }
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.DualNonPaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/DualNonPaymentEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class DualNonPaymentEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setupServices(this, TransportService2.COMPONENT, AccessService.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this, null).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        // Combine command/response APDU arrays
        CommandApdu[] commandSequences = new CommandApdu[TransportService2.APDU_COMMAND_SEQUENCE.length +
                                               AccessService.APDU_COMMAND_SEQUENCE.length];
        System.arraycopy(TransportService2.APDU_COMMAND_SEQUENCE, 0, commandSequences, 0,
                TransportService2.APDU_COMMAND_SEQUENCE.length);
        System.arraycopy(AccessService.APDU_COMMAND_SEQUENCE, 0, commandSequences,
                TransportService2.APDU_COMMAND_SEQUENCE.length,
                AccessService.APDU_COMMAND_SEQUENCE.length);

        String[] responseSequences = new String[TransportService2.APDU_RESPOND_SEQUENCE.length +
                                               AccessService.APDU_RESPOND_SEQUENCE.length];
        System.arraycopy(TransportService2.APDU_RESPOND_SEQUENCE, 0, responseSequences, 0,
                TransportService2.APDU_RESPOND_SEQUENCE.length);
        System.arraycopy(AccessService.APDU_RESPOND_SEQUENCE, 0, responseSequences,
                TransportService2.APDU_RESPOND_SEQUENCE.length,
                AccessService.APDU_RESPOND_SEQUENCE.length);

        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS, commandSequences);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES, responseSequences);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_dual_non_payment_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(TransportService2.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.DualPaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/DualPaymentEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.nfc.cardemulation.CardEmulation;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

@TargetApi(19)
public class DualPaymentEmulatorActivity extends BaseEmulatorActivity {
    final static int STATE_IDLE = 0;
    final static int STATE_SERVICE1_SETTING_UP = 1;
    final static int STATE_SERVICE2_SETTING_UP = 2;
    final static int STATE_MAKING_SERVICE2_DEFAULT = 3;

    int mState = STATE_IDLE;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        mState = STATE_SERVICE2_SETTING_UP;
        setupServices(this, PaymentService2.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        if (mState == STATE_SERVICE2_SETTING_UP) {
            mState = STATE_SERVICE1_SETTING_UP;
            setupServices(this, PaymentService1.COMPONENT, PaymentService2.COMPONENT);
            return;
        }
        // Verify HCE service 2 is the default
        if (makePaymentDefault(PaymentService2.COMPONENT, R.string.nfc_hce_change_preinstalled_wallet)) {
            mState = STATE_MAKING_SERVICE2_DEFAULT;
        } else {
            // Already default
            NfcDialogs.createHceTapReaderDialog(this,null).show();
        }
    }

    @Override
    void onPaymentDefaultResult(ComponentName component, boolean success) {
        if (success) {
            NfcDialogs.createHceTapReaderDialog(this, null).show();
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
    }
    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                PaymentService2.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                PaymentService2.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_dual_payment_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(PaymentService2.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2018_9584"	"testPocCVE_2018_9584"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2018_9584.java"	""	"@AsbSecurityTest(cveBugId = 114047681)
    public void testPocCVE_2018_9584() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2018-9584"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.ProtocolParamsReaderActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ProtocolParamsReaderActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.nfc.NfcAdapter;
import android.nfc.NfcAdapter.ReaderCallback;
import android.nfc.tech.IsoDep;
import android.nfc.tech.NfcA;
import android.nfc.Tag;
import android.os.Bundle;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.io.IOException;

@TargetApi(19)
public class ProtocolParamsReaderActivity extends PassFailButtons.Activity implements ReaderCallback {
    public static final String TAG = ""ProtocolParamsReaderActivity"";

    NfcAdapter mAdapter;

    TextView mTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();

        setTitle(R.string.nfc_hce_protocol_params_reader);

        mAdapter = NfcAdapter.getDefaultAdapter(this);
        mTextView = (TextView) findViewById(R.id.text);
        mTextView.setTextSize(12.0f);
    }

    @Override
    protected void onResume() {
        super.onResume();
        mAdapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_A |
                NfcAdapter.FLAG_READER_NFC_BARCODE | NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);
    }

    public boolean parseProtocolParameters(StringBuilder sb, byte[] uid,
            short sak, byte[] atqa, byte[] ats) {

        boolean success = true;

        sb.append(""UID: "" + HceUtils.getHexBytes(null, uid) + ""\n\n"");
        sb.append(""SAK: 0x"" + Integer.toHexString(sak & 0xFF) + ""\n"");

        if ((sak & 0x20) != 0) {
            sb.append(""    (OK) ISO-DEP bit (0x20) is set.\n"");
        } else {
            success = false;
            sb.append(""    (FAIL) ISO-DEP bit (0x20) is NOT set.\n"");
        }

        if ((sak & 0x40) != 0) {
            sb.append(""    (OK) P2P bit (0x40) is set.\n"");
        } else {
            sb.append(""    (WARN) P2P bit (0x40) is NOT set.\n"");
        }

        sb.append(""\n"");
        sb.append(""ATQA: "" + HceUtils.getHexBytes(null, atqa) + ""\n"");
        sb.append(""\n"");

        sb.append(""ATS: "" + HceUtils.getHexBytes(null, ats) + ""\n"");
        sb.append(""    TL: 0x"" + Integer.toHexString(ats[0] & 0xFF) + ""\n"");
        sb.append(""    T0: 0x"" + Integer.toHexString(ats[1] & 0xFF) + ""\n"");

        boolean ta_present = false;
        boolean tb_present = false;
        boolean tc_present = false;
        int atsIndex = 1;
        if ((ats[atsIndex] & 0x40) != 0) {
            sb.append(""        (OK) T(C) is present (bit 7 is set).\n"");
            tc_present = true;
        } else {
            success = false;
            sb.append(""        (FAIL) T(C) is not present (bit 7 is NOT set).\n"");
        }
        if ((ats[atsIndex] & 0x20) != 0) {
            sb.append(""        (OK) T(B) is present (bit 6 is set).\n"");
            tb_present = true;
        } else {
            success = false;
            sb.append(""        (FAIL) T(B) is not present (bit 6 is NOT set).\n"");
        }
        if ((ats[atsIndex] & 0x10) != 0) {
            sb.append(""        (OK) T(A) is present (bit 5 is set).\n"");
            ta_present = true;
        } else {
            success = false;
            sb.append(""        (FAIL) T(A) is not present (bit 5 is NOT set).\n"");
        }
        int fsc = ats[atsIndex] & 0x0F;
        if (fsc > 8) {
            success = false;
            sb.append(""        (FAIL) FSC "" + Integer.toString(fsc) + "" is > 8\n"");
        } else if (fsc < 2) {
            sb.append(""        (FAIL EMVCO) FSC "" + Integer.toString(fsc) + "" is < 2\n"");
        } else {
            sb.append(""        (OK) FSC = "" + Integer.toString(fsc) + ""\n"");
        }

        atsIndex++;
        if (ta_present) {
            sb.append(""    TA: 0x"" + Integer.toHexString(ats[atsIndex] & 0xff) + ""\n"");
            if ((ats[atsIndex] & 0x80) != 0) {
                sb.append(""        (OK) bit 8 set, indicating only same bit rate divisor.\n"");
            } else {
                sb.append(""        (FAIL EMVCO) bit 8 NOT set, indicating support for assymetric "" +
                        ""bit rate divisors. EMVCo requires bit 8 set.\n"");
            }
            if ((ats[atsIndex] & 0x70) != 0) {
                sb.append(""        (FAIL EMVCO) EMVCo requires bits 7 to 5 set to 0.\n"");
            } else {
                sb.append(""        (OK) bits 7 to 5 indicating only 106 kbit/s L->P supported.\n"");
            }
            if ((ats[atsIndex] & 0x7) != 0) {
                sb.append(""        (FAIL EMVCO) EMVCo requires bits 3 to 1 set to 0.\n"");
            } else {
                sb.append(""        (OK) bits 3 to 1 indicating only 106 kbit/s P->L supported.\n"");
            }
            atsIndex++;
        }

        if (tb_present) {
            sb.append(""    TB: 0x"" + Integer.toHexString(ats[3] & 0xFF) + ""\n"");
            int fwi = (ats[atsIndex] & 0xF0) >> 4;
            if (fwi > 8) {
                success = false;
                sb.append(""        (FAIL) FWI="" + Integer.toString(fwi) + "", should be <= 8\n"");
            } else if (fwi == 8) {
                sb.append(""        (FAIL EMVCO) FWI="" + Integer.toString(fwi) +
                        "", EMVCo requires <= 7\n"");
            } else {
                sb.append(""        (OK) FWI="" + Integer.toString(fwi) + ""\n"");
            }
            int sfgi = ats[atsIndex] & 0x0F;
            if (sfgi > 8) {
                success = false;
                sb.append(""        (FAIL) SFGI="" + Integer.toString(sfgi) + "", should be <= 8\n"");
            } else {
                sb.append(""        (OK) SFGI="" + Integer.toString(sfgi) + ""\n"");
            }
            atsIndex++;
        }

        if (tc_present) {
            sb.append(""    TC: 0x"" + Integer.toHexString(ats[atsIndex] & 0xFF) + ""\n"");
            boolean apSupported = (ats[atsIndex] & 0x10) != 0;
            boolean didSupported = (ats[atsIndex] & 0x02) != 0;
            boolean nadSupported = (ats[atsIndex] & 0x01) != 0;
            if (nadSupported) {
                success = false;
                sb.append(""        (FAIL) NAD bit is not allowed to be set.\n"");
            } else {
                sb.append(""        (OK) NAD bit is not set.\n"");
            }
            atsIndex++;
            // See if there's any bytes left for general bytes
            if (atsIndex + 1 < ats.length) {
                int bytesToCopy = ats.length - atsIndex;
                byte[] historical_bytes = new byte[bytesToCopy];
                System.arraycopy(ats, atsIndex, historical_bytes, 0, bytesToCopy);
                sb.append(""\n(OK) Historical bytes: "" +
                        HceUtils.getHexBytes(null, historical_bytes));
            }
        }
        return success;
    }

    @Override
    public void onTagDiscovered(Tag tag) {
        final StringBuilder sb = new StringBuilder();
        IsoDep isoDep = IsoDep.get(tag);
        NfcA nfcA = NfcA.get(tag);
        boolean success = false;
        if (nfcA == null || isoDep == null) {
            return;
        }
        try {
            nfcA.connect();
            byte[] ats = nfcA.transceive(new byte[] { (byte) 0xE0, (byte)0xF0});
            success = parseProtocolParameters(sb, tag.getId(), nfcA.getSak(), nfcA.getAtqa(), ats);
        } catch (IOException e) {
            sb.insert(0, ""Test failed. IOException (did you keep the devices in range?)\n\n."");
        } finally {
            if (success) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(sb.toString());
                        getPassButton().setEnabled(true);
                    }
                });
            } else {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(sb.toString());
                        getPassButton().setEnabled(false);
                    }
                });
            }
            try {
                nfcA.transceive(new byte[] {(byte) 0xC2});
                nfcA.close();
                isoDep.connect();
            } catch (IOException e) {
            }
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.DefaultRouteEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/DefaultRouteEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class DefaultRouteEmulatorActivity extends BaseEmulatorActivity {
    public static final CommandApdu[] APDU_COMMAND_SEQUENCE = {
        HceUtils.buildSelectApdu(""A000000476416E64726F6964484345"", true),
    };
    public static final String[] APDU_RESPONSE_SEQUENCE = {
        ""148100009000""
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this,
                getString(R.string.nfc_hce_default_route_emulator_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS, APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES, APDU_RESPONSE_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_default_route_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.content.cts.AvailableIntentsTest"	"testTapAnPaySettings"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/AvailableIntentsTest.java"	""	"public void testTapAnPaySettings() {
        PackageManager packageManager = mContext.getPackageManager();
        if (packageManager.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
            assertCanBeHandled(new Intent(Settings.ACTION_NFC_PAYMENT_SETTINGS));
        }
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.ChangeDefaultEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ChangeDefaultEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

@TargetApi(19)
public class ChangeDefaultEmulatorActivity extends BaseEmulatorActivity {
    final static int STATE_IDLE = 0;
    final static int STATE_SERVICE1_SETTING_UP = 1;
    final static int STATE_SERVICE2_SETTING_UP = 2;
    final static int STATE_MAKING_SERVICE1_DEFAULT = 3;
    final static int STATE_MAKING_SERVICE2_DEFAULT = 4;
    final static int STATE_DEFAULT_CHANGED = 5;

    int mState = STATE_IDLE;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mState = STATE_SERVICE2_SETTING_UP;
        setupServices(this, PaymentService2.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        if (mState == STATE_SERVICE2_SETTING_UP) {
            mState = STATE_SERVICE1_SETTING_UP;
            setupServices(this, PaymentService1.COMPONENT, PaymentService2.COMPONENT);
            return;
        }
        if (!makePaymentDefault(PaymentService2.COMPONENT,
                R.string.nfc_hce_change_preinstalled_wallet)) {
            // Service 2 is already default, make one default now
            mState = STATE_MAKING_SERVICE1_DEFAULT;
            makePaymentDefault(PaymentService1.COMPONENT, R.string.nfc_hce_change_default_help);
        } else {
            mState = STATE_MAKING_SERVICE2_DEFAULT;
            // will get callback when 2 is made default
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                PaymentService1.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                PaymentService1.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_change_default_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(PaymentService1.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }

    @Override
    void onPaymentDefaultResult(ComponentName component, boolean success) {
        if (mState == STATE_MAKING_SERVICE2_DEFAULT) {
            if (success) {
                mState = STATE_MAKING_SERVICE1_DEFAULT;
             makePaymentDefault(PaymentService1.COMPONENT, R.string.nfc_hce_change_default_help);
            }
        } else if (mState == STATE_MAKING_SERVICE1_DEFAULT) {
            if (success) {
                mState = STATE_DEFAULT_CHANGED;
                NfcDialogs.createHceTapReaderDialog(this, null).show();
            }
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.AlwaysOnVpnTest"	"testSetNonVpnAlwaysOn"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/AlwaysOnVpnTest.java"	""	"public void testSetNonVpnAlwaysOn() throws Exception {
        // Treat this CTS DPC as an non-vpn app, since it doesn't register
        // android.net.VpnService intent filter in AndroidManifest.xml.
        try {
            mDevicePolicyManager.setAlwaysOnVpnPackage(
                    ADMIN_RECEIVER_COMPONENT, mPackageName, true);
            fail(""setAlwaysOnVpnPackage should not accept non-vpn package"");
        } catch (UnsupportedOperationException e) {
            // success
        }
        assertNull(mDevicePolicyManager.getAlwaysOnVpnPackage(ADMIN_RECEIVER_COMPONENT));
    }

    private void waitForConnectivity(String message) throws InterruptedException {
        long deadline = System.nanoTime() + CONNECTIVITY_WAIT_TIME_NS;
        while (System.nanoTime() < deadline) {
            try {
                new Socket(CONNECTIVITY_CHECK_HOST, 80);
                // Domain resolved, we have connectivity.
                return;
            } catch (IOException e) {
                // Log.e(String, String, Throwable) will swallow UnknownHostException,
                // so manually print it out here.
                Log.e(TAG, ""No connectivity yet: "" + e.toString());
                Thread.sleep(2000);
            }
        }
        fail(""Connectivity isn't available: "" + message);
    }

    private void waitForNoConnectivity(String message) throws Exception {
        long deadline = System.nanoTime() + CONNECTIVITY_WAIT_TIME_NS;
        while (System.nanoTime() < deadline) {
            try {
                new Socket(CONNECTIVITY_CHECK_HOST, 80);
                // Domain resolved, we have connectivity.
            } catch (IOException e) {
                // No connectivity
                return;
            }
            Thread.sleep(2000);
        }
        fail(""Connectivity still available after deadline: "" + message);
    }

    private void assertConnectivity(boolean shouldHaveConnectivity, String message) {
        try {
            new Socket(CONNECTIVITY_CHECK_HOST, 80);
            if (!shouldHaveConnectivity) {
                fail(""Connectivity available while not expected: "" + message);
            }
        } catch (IOException e) {
            if (shouldHaveConnectivity) {
                Log.e(TAG, ""Connectivity check failed"", e);
                fail(""Connectivity isn't available while expected: "" + message);
            }
        }
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"processor.main.java.com.android.bedstead.remotedpc.processor.Processor"	"latest"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/processor/main/java/com/android/bedstead/remotedpc/processor/Processor.java"	""	"public void test/*
 *.
 */

package com.android.bedstead.remotedpc.processor;

import com.android.bedstead.remotedpc.processor.annotations.RemoteDpcAutomaticAdmin;
import com.android.bedstead.remotedpc.processor.annotations.RemoteDpcManager;

import com.google.android.enterprise.connectedapps.annotations.CrossProfile;
import com.google.android.enterprise.connectedapps.annotations.CrossProfileConfiguration;
import com.google.android.enterprise.connectedapps.annotations.CrossProfileProvider;
import com.google.auto.service.AutoService;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.MirroredTypeException;
import javax.lang.model.type.TypeKind;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;

/** Processor for generating RemoteDPC API for framework manager classes. */
@SupportedAnnotationTypes({
        ""com.android.bedstead.remotedpc.processor.annotations.RemoteDpcManager"",
})
@AutoService(javax.annotation.processing.Processor.class)
public final class Processor extends AbstractProcessor {
    // TODO(scottjonathan): Add more verification before generating - and add processor tests
    private static final ClassName CONTEXT_CLASSNAME =
            ClassName.get(""android.content"", ""Context"");
    private static final ClassName CONFIGURATION_CLASSNAME =
            ClassName.get(""com.android.bedstead.remotedpc"", ""Configuration"");
    private static final ClassName CROSS_PROFILE_CONNECTOR_CLASSNAME =
            ClassName.get(""com.google.android.enterprise.connectedapps"", ""CrossProfileConnector"");
    private static final ClassName UNAVAILABLE_PROFILE_EXCEPTION_CLASSNAME =
            ClassName.get(
                    ""com.google.android.enterprise.connectedapps.exceptions"",
                    ""UnavailableProfileException"");
    private static final ClassName PROFILE_RUNTIME_EXCEPTION_CLASSNAME =
            ClassName.get(
                    ""com.google.android.enterprise.connectedapps.exceptions"",
                    ""ProfileRuntimeException"");
    private static final ClassName NENE_EXCEPTION_CLASSNAME =
            ClassName.get(
                    ""com.android.bedstead.nene.exceptions"", ""NeneException"");
    public static final String MANAGER_PACKAGE_NAME = ""com.android.bedstead.remotedpc.managers"";

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latest();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations,
            RoundEnvironment roundEnv) {

        Set<TypeElement> interfaces = new HashSet<>();

        for (Element e : roundEnv.getElementsAnnotatedWith(RemoteDpcManager.class)) {
            TypeElement interfaceClass = (TypeElement) e;
            interfaces.add(interfaceClass);
            processRemoteDpcManagerInterface(interfaceClass);
        }

        if (interfaces.isEmpty()) {
            // We only want to generate the provider and configuration once, not on every iteration
            return true;
        }

        generateProvider(interfaces);
        generateConfiguration();

        return true;
    }

    private void processRemoteDpcManagerInterface(TypeElement interfaceClass) {
        RemoteDpcManager r = interfaceClass.getAnnotation(RemoteDpcManager.class);
        TypeElement managerClass = extractClassFromAnnotation(r::managerClass);

        if (!interfaceClass.getKind().isInterface()) {
            showError(""@RemoteDpcManager can only be applied to interfaces"", interfaceClass);
        }

        generateCrossProfileInterface(interfaceClass);
        generateImplClass(interfaceClass, managerClass);
        generateWrapperClass(interfaceClass);
    }

    /** Generate Impl which wraps the manager class. */
    private void generateImplClass(TypeElement interfaceClass, TypeElement managerClass) {
        ClassName managerClassName = ClassName.get(managerClass);

        TypeSpec.Builder classBuilder = TypeSpec.classBuilder(implName(interfaceClass))
                .addSuperinterface(crossProfileInterfaceName(interfaceClass))
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL);

        classBuilder.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
                .addMember(""value"", ""{\""NewApi\"", \""OldTargetApi\""}"")
                .build());

        classBuilder.addField(managerClassName,
                ""mManager"", Modifier.PRIVATE, Modifier.FINAL);

        classBuilder.addMethod(
                MethodSpec.constructorBuilder()
                        .addParameter(CONTEXT_CLASSNAME, ""context"")
                        .addCode(""mManager = context.getSystemService($T.class);"",
                                managerClassName)
                .build()
        );

        for (ExecutableElement method : getMethods(interfaceClass)) {
            MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(
                    method.getSimpleName().toString())
                    .returns(ClassName.get(method.getReturnType()))
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override.class);

            for (VariableElement param : method.getParameters()) {
                ParameterSpec parameterSpec =
                        ParameterSpec.builder(ClassName.get(param.asType()),
                                param.getSimpleName().toString()).build();

                methodBuilder.addParameter(parameterSpec);
            }

            String parametersString = method.getParameters().stream()
                    .map(VariableElement::getSimpleName)
                    .collect(Collectors.joining("", ""));
            CodeBlock methodCall;

            if (method.getAnnotation(RemoteDpcAutomaticAdmin.class) != null) {
                // We just redirect to the other method, adding in the component
                if (parametersString.isEmpty()) {
                    methodCall = CodeBlock.of(""$L($T.REMOTE_DPC_COMPONENT_NAME);"",
                            method.getSimpleName(), CONFIGURATION_CLASSNAME);
                } else {
                    methodCall = CodeBlock.of(""$L($T.REMOTE_DPC_COMPONENT_NAME, $L);"",
                            method.getSimpleName(), CONFIGURATION_CLASSNAME, parametersString);
                }
            } else {
                // We call through to the wrapped manager class
                methodCall = CodeBlock.of(""mManager.$L($L);"",
                        method.getSimpleName(), parametersString);
            }

            if (!method.getReturnType().getKind().equals(TypeKind.VOID)) {
                methodCall = CodeBlock.of(""return $L"", methodCall);
            }
            methodBuilder.addCode(methodCall);

            classBuilder.addMethod(methodBuilder.build());
        }

        PackageElement packageElement = (PackageElement) interfaceClass.getEnclosingElement();

        writeClassToFile(packageElement.getQualifiedName().toString(), classBuilder.build());
    }

    /** Generate wrapper which wraps the cross-profile class. */
    private void generateWrapperClass(TypeElement interfaceClass) {
        TypeSpec.Builder classBuilder =
                TypeSpec.classBuilder(
                        wrapperName(interfaceClass))
                        .addSuperinterface(crossProfileInterfaceName(interfaceClass))
                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL);


        classBuilder.addField(CROSS_PROFILE_CONNECTOR_CLASSNAME,
                ""mConnector"", Modifier.PRIVATE, Modifier.FINAL);
        classBuilder.addField(profileTypeName(interfaceClass),
                ""mProfileType"", Modifier.PRIVATE, Modifier.FINAL);

        classBuilder.addMethod(
                MethodSpec.constructorBuilder()
                        .addModifiers(Modifier.PUBLIC)
                        .addParameter(CROSS_PROFILE_CONNECTOR_CLASSNAME, ""connector"")
                        .addCode(""mConnector = connector;"")
                        .addCode(""mProfileType = $T.create(connector);"",
                                profileTypeName(interfaceClass))
                        .build()
        );

        classBuilder.addMethod(
                MethodSpec.methodBuilder(""tryConnect"")
                        .addModifiers(Modifier.PRIVATE)
                        .addException(UNAVAILABLE_PROFILE_EXCEPTION_CLASSNAME)
                        .addCode(""$T retries = 300;"", int.class)
                        .beginControlFlow(""while (true)"")
                            .beginControlFlow(""try"")
                                .addCode(""mConnector.connect();"")
                                .addCode(""return;"")
                            .nextControlFlow(""catch ($T e)"", UNAVAILABLE_PROFILE_EXCEPTION_CLASSNAME)
                                .addCode(""retries -= 1;"")
                                .beginControlFlow(""if (retries <= 0)"")
                                    .addCode(""throw e;"")
                                .endControlFlow()
                                .beginControlFlow(""try"")
                                    .addCode(""$T.sleep(100);"", Thread.class)
                                 .nextControlFlow(""catch ($T e2)"", InterruptedException.class)
                                .endControlFlow()
                            .endControlFlow()
                        .endControlFlow()
                        .build()
        );

        for (ExecutableElement method : getMethods(interfaceClass)) {
            MethodSpec.Builder methodBuilder =
                    MethodSpec.methodBuilder(method.getSimpleName().toString())
                    .returns(ClassName.get(method.getReturnType()))
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override.class);

            for (VariableElement param : method.getParameters()) {
                ParameterSpec parameterSpec =
                        ParameterSpec.builder(ClassName.get(param.asType()),
                                param.getSimpleName().toString()).build();

                methodBuilder.addParameter(parameterSpec);
            }

            String parametersString = method.getParameters().stream()
                    .map(VariableElement::getSimpleName)
                    .collect(Collectors.joining("", ""));

            CodeBlock methodCall = CodeBlock.of(""mProfileType.other().$L($L);"",
                    method.getSimpleName().toString(), parametersString);
            if (!method.getReturnType().getKind().equals(TypeKind.VOID)) {
                methodCall = CodeBlock.of(""return $L"", methodCall);
            }

            methodBuilder.beginControlFlow(""try"")
                    .addCode(""tryConnect();"")
                    .addCode(methodCall)
                    .nextControlFlow(""catch ($T e)"",
                            UNAVAILABLE_PROFILE_EXCEPTION_CLASSNAME)
                    .addCode(""throw new $T(\""Error connecting\"", e);"", NENE_EXCEPTION_CLASSNAME)
                    .nextControlFlow(""catch ($T e)"",
                            PROFILE_RUNTIME_EXCEPTION_CLASSNAME)
                    .addCode(""throw ($T) e.getCause();"", RuntimeException.class)
                    .nextControlFlow(""finally"")
                    .addCode(""mConnector.stopManualConnectionManagement();"")
                    .endControlFlow();

            classBuilder.addMethod(methodBuilder.build());
        }

        PackageElement packageElement = (PackageElement) interfaceClass.getEnclosingElement();
        writeClassToFile(packageElement.getQualifiedName().toString(), classBuilder.build());
    }

    /** Generate sub-interface which is annotated @CrossProfile. */
    private void generateCrossProfileInterface(TypeElement interfaceClass) {
        TypeSpec.Builder classBuilder =
                TypeSpec.interfaceBuilder(
                        crossProfileInterfaceName(interfaceClass))
                        .addSuperinterface(ClassName.get(interfaceClass))
                        .addModifiers(Modifier.PUBLIC);

        for (ExecutableElement method : getMethods(interfaceClass)) {
            MethodSpec.Builder methodBuilder =
                    MethodSpec.methodBuilder(method.getSimpleName().toString())
                    .returns(ClassName.get(method.getReturnType()))
                    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                    .addAnnotation(CrossProfile.class)
                    .addAnnotation(Override.class);

            for (VariableElement param : method.getParameters()) {
                ParameterSpec parameterSpec =
                        ParameterSpec.builder(ClassName.get(param.asType()),
                                param.getSimpleName().toString()).build();

                methodBuilder.addParameter(parameterSpec);
            }

            classBuilder.addMethod(methodBuilder.build());
        }

        PackageElement packageElement = (PackageElement) interfaceClass.getEnclosingElement();
        writeClassToFile(packageElement.getQualifiedName().toString(), classBuilder.build());
    }

    private void generateProvider(Set<TypeElement> interfaces) {
        TypeSpec.Builder classBuilder =
                TypeSpec.classBuilder(
                        ""Provider"")
                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL);

        for (TypeElement i : interfaces) {
            MethodSpec.Builder methodBuilder =
                    MethodSpec.methodBuilder(""provide_"" + i.getSimpleName())
                    .returns(crossProfileInterfaceName(i))
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(CONTEXT_CLASSNAME, ""context"")
                    .addAnnotation(CrossProfileProvider.class)
                    .addCode(""return new $T(context);"", implName(i));

            classBuilder.addMethod(methodBuilder.build());
        }

        writeClassToFile(MANAGER_PACKAGE_NAME, classBuilder.build());
    }

    private void generateConfiguration() {
        TypeSpec.Builder classBuilder =
                TypeSpec.classBuilder(
                        ""Configuration"")
                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addAnnotation(AnnotationSpec.builder(CrossProfileConfiguration.class)
                        .addMember(""providers"", ""Provider.class"")
                        .build());

        writeClassToFile(MANAGER_PACKAGE_NAME, classBuilder.build());
    }

    private TypeElement extractClassFromAnnotation(Runnable runnable) {
        try {
            runnable.run();
        } catch (MirroredTypeException e) {
            return e.getTypeMirrors().stream()
                    .map(t -> (TypeElement) processingEnv.getTypeUtils().asElement(t))
                    .findFirst()
                    .get();
        }
        throw new AssertionError(""Could not extract class from annotation"");
    }

    private void writeClassToFile(String packageName, TypeSpec clazz) {
        String qualifiedClassName =
                packageName.isEmpty() ? clazz.name : packageName + ""."" + clazz.name;

        JavaFile javaFile = JavaFile.builder(packageName, clazz).build();
        try {
            JavaFileObject builderFile =
                    processingEnv.getFiler().createSourceFile(qualifiedClassName);
            try (PrintWriter out = new PrintWriter(builderFile.openWriter())) {
                javaFile.writeTo(out);
            }
        } catch (IOException e) {
            throw new IllegalStateException(""Error writing "" + qualifiedClassName + "" to file"", e);
        }
    }

    private ClassName crossProfileInterfaceName(TypeElement interfaceClass) {
        return ClassName.bestGuess(interfaceClass.getQualifiedName().toString() + ""_Internal"");
    }

    private ClassName implName(TypeElement interfaceClass) {
        return ClassName.bestGuess(interfaceClass.getQualifiedName().toString() + ""_Impl"");
    }

    private ClassName wrapperName(TypeElement interfaceClass) {
        return ClassName.bestGuess(interfaceClass.getQualifiedName().toString() + ""_Wrapper"");
    }

    private ClassName profileTypeName(TypeElement interfaceClass) {
        ClassName crossProfileInterfaceName = crossProfileInterfaceName(interfaceClass);
        return ClassName.get(crossProfileInterfaceName.packageName(),
                ""Profile"" + crossProfileInterfaceName.simpleName());
    }

    private Set<ExecutableElement> getMethods(TypeElement interfaceClass) {
        return interfaceClass.getEnclosedElements().stream()
                .filter(e -> e instanceof ExecutableElement)
                .map(e -> (ExecutableElement) e)
                .collect(Collectors.toSet());
    }

    private void showError(String errorText, Element errorElement) {
        processingEnv
                .getMessager()
                .printMessage(Diagnostic.Kind.ERROR, errorText, errorElement);
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.offhost.UiccTransactionEvent1EmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/offhost/UiccTransactionEvent1EmulatorActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.offhost;

import android.annotation.TargetApi;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.nfc.NfcAdapter;
import android.nfc.cardemulation.CardEmulation;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import com.android.cts.verifier.nfc.hce.HceUtils;

public class UiccTransactionEvent1EmulatorActivity extends PassFailButtons.Activity {
    static final String TAG = ""UiccTransactionEvent1EmulatorActivity"";

    TextView mTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.R) {
            getPassButton().setEnabled(false);
        } else {
            getPassButton().setEnabled(true);
        }

        mTextView = (TextView) findViewById(R.id.text);
        mTextView.setTextSize(12.0f);
        mTextView.setText(R.string.nfc_offhost_uicc_transaction_event_emulator_help);

        initProcess();
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);

        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mTextView = (TextView) findViewById(R.id.text);
        mTextView.setTextSize(12.0f);

        setIntent(intent);
        initProcess();
    }

    @Override
    protected void onPause() {
        super.onPause();
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleOffhostReaderActivity.class);
        readerIntent.putExtra(SimpleOffhostReaderActivity.EXTRA_APDUS,
                UiccTransactionEvent1Service.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleOffhostReaderActivity.EXTRA_RESPONSES,
                UiccTransactionEvent1Service.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleOffhostReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_offhost_uicc_transaction_event1_reader));
        return readerIntent;
    }

    private void initProcess() {

        Bundle bundle = getIntent().getExtras();
        if(bundle != null){
            byte[] transactionData = bundle.getByteArray(NfcAdapter.EXTRA_DATA);
            if(transactionData != null){
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(""Pass - NFC Action:"" + getIntent().getAction() + "" uri:"" + getIntent().getDataString()
                            + "" data:"" + HceUtils.getHexBytes(null, transactionData));
                        getPassButton().setEnabled(true);
                    }
                });
            } else {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(""Fail - Action:"" + getIntent().getAction() + "" uri:"" + getIntent().getDataString()
                            + "" data: null"");
                        getPassButton().setEnabled(false);
                    }
                });
            }
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2207"	"testPocCVE_2019_2207"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2207.java"	""	"@AsbSecurityTest(cveBugId = 124524315)
    public void testPocCVE_2019_2207() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2207"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2020_0006"	"testPocCVE_2020_0006"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2020_0006.java"	""	"@AsbSecurityTest(cveBugId = 139738828)
    public void testPocCVE_2020_0006() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2020-0006"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.TagVerifierActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/TagVerifierActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.tech.MifareUltralightTagTester;
import com.android.cts.verifier.nfc.tech.NdefTagTester;
import com.android.cts.verifier.nfc.tech.TagTester;
import com.android.cts.verifier.nfc.tech.TagVerifier;
import com.android.cts.verifier.nfc.tech.TagVerifier.Result;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.nfc.NfcAdapter;
import android.nfc.NfcManager;
import android.nfc.Tag;
import android.nfc.tech.MifareUltralight;
import android.nfc.tech.Ndef;
import android.os.AsyncTask;
import android.os.Bundle;
import android.util.Log;
import android.widget.ArrayAdapter;
import android.widget.TextView;
import android.widget.Toast;

/**
 * Test activity for reading and writing NFC tags using different technologies.
 * First, it asks the user to write some random data to the tag. Then it asks
 * the user to scan that tag again to verify that the data was properly written
 * and read back.
 */
public class TagVerifierActivity<T> extends PassFailButtons.ListActivity {

    static final String TAG = TagVerifierActivity.class.getSimpleName();

    /** Non-optional argument specifying the tag technology to be used to read and write tags. */
    static final String EXTRA_TECH = ""tech"";

    private static final int NFC_NOT_ENABLED_DIALOG_ID = 1;
    private static final int TESTABLE_TAG_DISCOVERED_DIALOG_ID = 2;
    private static final int TESTABLE_TAG_REMINDER_DIALOG_ID = 3;
    private static final int WRITE_PROGRESS_DIALOG_ID = 4;
    private static final int READ_PROGRESS_DIALOG_ID = 5;
    private static final int VERIFY_RESULT_DIALOG_ID = 6;

    // Arguments used for the dialog showing what was written to the tag and read from the tag.
    private static final String EXPECTED_CONTENT_ID = ""expectedContent"";
    private static final String ACTUAL_CONTENT_ID = ""actualContent"";
    private static final String IS_MATCH_ID = ""isMatch"";

    // The test activity has two states - writing data to a tag and then verifying it.
    private static final int WRITE_STEP = 0;
    private static final int VERIFY_STEP = 1;

    private NfcAdapter mNfcAdapter;
    private PendingIntent mPendingIntent;
    private Class<?> mTechClass;

    private int mStep;
    private TagTester mTagTester;
    private TagVerifier mTagVerifier;
    private Tag mTag;
    private ArrayAdapter<String> mTechListAdapter;
    private TextView mEmptyText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.nfc_tag);
        setInfoResources(R.string.nfc_tag_verifier, R.string.nfc_tag_verifier_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        parseIntentExtras();
        if (mTechClass != null) {
            mTagTester = getTagTester(mTechClass);

            mEmptyText = (TextView) findViewById(android.R.id.empty);

            mTechListAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1);
            setListAdapter(mTechListAdapter);

            NfcManager nfcManager = (NfcManager) getSystemService(NFC_SERVICE);
            mNfcAdapter = nfcManager.getDefaultAdapter();
            mPendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, getClass())
                    .addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), PendingIntent.FLAG_MUTABLE_UNAUDITED);

            goToWriteStep();
        } else {
            finish();
        }
    }

    private void parseIntentExtras() {
        try {
            String tech = getIntent().getStringExtra(EXTRA_TECH);
            if (tech != null) {
                mTechClass = Class.forName(tech);
            }
        } catch (ClassNotFoundException e) {
            Log.e(TAG, ""Couldn't find tech for class"", e);
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (!mNfcAdapter.isEnabled()) {
            showDialog(NFC_NOT_ENABLED_DIALOG_ID);
        }

        mNfcAdapter.enableForegroundDispatch(this, mPendingIntent, null, null);
    }

    @Override
    protected void onPause() {
        super.onPause();
        mNfcAdapter.disableForegroundDispatch(this);
    }

    private TagTester getTagTester(Class<?> techClass) {
        if (Ndef.class.equals(techClass)) {
            return new NdefTagTester(this);
        } else if (MifareUltralight.class.equals(techClass)) {
            return new MifareUltralightTagTester();
        } else {
            throw new IllegalArgumentException(""Unsupported technology: "" + techClass);
        }
    }

    @Override
    protected void onNewIntent(Intent intent) {
        Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
        if (tag != null) {
            mTag = tag;
            updateTechListAdapter(tag);
            switch (mStep) {
                case WRITE_STEP:
                    handleWriteStep(tag);
                    break;

                case VERIFY_STEP:
                    handleVerifyStep();
                    break;
            }
        }
    }

    private void handleWriteStep(Tag tag) {
        if (mTagTester.isTestableTag(tag)) {
            brutallyDismissDialog(TESTABLE_TAG_REMINDER_DIALOG_ID);
            showDialog(TESTABLE_TAG_DISCOVERED_DIALOG_ID);
        } else {
            brutallyDismissDialog(TESTABLE_TAG_DISCOVERED_DIALOG_ID);
            showDialog(TESTABLE_TAG_REMINDER_DIALOG_ID);
        }
    }

    private void brutallyDismissDialog(int id) {
        try {
            dismissDialog(id);
        } catch (IllegalArgumentException e) {
            // Don't care if it hasn't been shown before...
        }
    }

    private void handleVerifyStep() {
        new VerifyTagTask().execute(mTag);
    }

    private void updateTechListAdapter(Tag tag) {
        mEmptyText.setText(R.string.nfc_no_tech);
        String[] techList = tag.getTechList();
        mTechListAdapter.clear();
        for (String tech : techList) {
            mTechListAdapter.add(tech);
        }
    }

    class WriteTagTask extends AsyncTask<Tag, Void, TagVerifier> {

        @Override
        protected void onPreExecute() {
            super.onPreExecute();
            showDialog(WRITE_PROGRESS_DIALOG_ID);
        }

        @Override
        protected TagVerifier doInBackground(Tag... tags) {
            try {
                return mTagTester.writeTag(tags[0]);
            } catch (Exception e) {
                Log.e(TAG, ""Error writing NFC tag..."", e);
                return null;
            }
        }

        @Override
        protected void onPostExecute(TagVerifier tagVerifier) {
            dismissDialog(WRITE_PROGRESS_DIALOG_ID);
            mTagVerifier = tagVerifier;
            if (tagVerifier != null) {
                goToVerifyStep();
            } else {
                Toast.makeText(TagVerifierActivity.this, R.string.nfc_writing_tag_error,
                        Toast.LENGTH_SHORT).show();
                goToWriteStep();
            }
        }
    }

    private void goToWriteStep() {
        mStep = WRITE_STEP;
        mEmptyText.setText(getString(R.string.nfc_scan_tag, mTechClass.getSimpleName()));
        mTechListAdapter.clear();
    }

    private void goToVerifyStep() {
        mStep = VERIFY_STEP;
        mEmptyText.setText(getString(R.string.nfc_scan_tag_again, mTechClass.getSimpleName()));
        mTechListAdapter.clear();
    }

    class VerifyTagTask extends AsyncTask<Tag, Void, Result> {

        @Override
        protected void onPreExecute() {
            super.onPreExecute();
            showDialog(READ_PROGRESS_DIALOG_ID);
        }

        @Override
        protected Result doInBackground(Tag... tags) {
            try {
                return mTagVerifier.verifyTag(tags[0]);
            } catch (Exception e) {
                Log.e(TAG, ""Error verifying NFC tag..."", e);
                return null;
            }
        }

        @Override
        protected void onPostExecute(Result result) {
            super.onPostExecute(result);
            dismissDialog(READ_PROGRESS_DIALOG_ID);
            mTagVerifier = null;
            if (result != null) {
                getPassButton().setEnabled(result.isMatch());

                Bundle args = new Bundle();
                args.putCharSequence(EXPECTED_CONTENT_ID, result.getExpectedContent());
                args.putCharSequence(ACTUAL_CONTENT_ID, result.getActualContent());
                args.putBoolean(IS_MATCH_ID, result.isMatch());
                showDialog(VERIFY_RESULT_DIALOG_ID, args);

                goToWriteStep();
            } else {
                Toast.makeText(TagVerifierActivity.this, R.string.nfc_reading_tag_error,
                        Toast.LENGTH_SHORT).show();
                goToWriteStep();
            }
        }
    }

    @Override
    public Dialog onCreateDialog(int id, Bundle args) {
        switch (id) {
            case NFC_NOT_ENABLED_DIALOG_ID:
                return NfcDialogs.createNotEnabledDialog(this);

            case TESTABLE_TAG_DISCOVERED_DIALOG_ID:
                return createTestableTagDiscoveredDialog();

            case TESTABLE_TAG_REMINDER_DIALOG_ID:
                return createTestableTagReminderDialog();

            case WRITE_PROGRESS_DIALOG_ID:
                return createWriteProgressDialog();

            case READ_PROGRESS_DIALOG_ID:
                return createReadProgressDialog();

            case VERIFY_RESULT_DIALOG_ID:
                return createVerifyResultDialog();

            default:
                return super.onCreateDialog(id, args);
        }
    }

    private AlertDialog createTestableTagDiscoveredDialog() {
        return new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_info)
                .setTitle(R.string.nfc_write_tag_title)
                .setMessage(R.string.nfc_write_tag_message)
                .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        new WriteTagTask().execute(mTag);
                    }
                })
                .setOnCancelListener(new DialogInterface.OnCancelListener() {
                    @Override
                    public void onCancel(DialogInterface dialog) {
                        goToWriteStep();
                    }
                })
                .show();
    }

    private AlertDialog createTestableTagReminderDialog() {
        return new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setTitle(R.string.nfc_wrong_tag_title)
                .setMessage(getString(R.string.nfc_scan_tag, mTechClass.getSimpleName()))
                .setPositiveButton(android.R.string.ok, null)
                .show();
    }

    private ProgressDialog createWriteProgressDialog() {
        ProgressDialog dialog = new ProgressDialog(this);
        dialog.setMessage(getString(R.string.nfc_writing_tag));
        return dialog;
    }

    private ProgressDialog createReadProgressDialog() {
        ProgressDialog dialog = new ProgressDialog(this);
        dialog.setMessage(getString(R.string.nfc_reading_tag));
        return dialog;
    }

    private AlertDialog createVerifyResultDialog() {
        // Placeholder title and message that will be set properly in onPrepareDialog
        return new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setTitle(R.string.result_failure)
                .setMessage("""")
                .setPositiveButton(android.R.string.ok, null)
                .create();
    }

    @Override
    protected void onPrepareDialog(int id, Dialog dialog, Bundle args) {
        switch (id) {
            case VERIFY_RESULT_DIALOG_ID:
                prepareVerifyResultDialog(dialog, args);
                break;

            default:
                super.onPrepareDialog(id, dialog, args);
                break;
        }
    }

    private void prepareVerifyResultDialog(Dialog dialog, Bundle args) {
        CharSequence expectedContent = args.getCharSequence(EXPECTED_CONTENT_ID);
        CharSequence actualContent = args.getCharSequence(ACTUAL_CONTENT_ID);
        boolean isMatch = args.getBoolean(IS_MATCH_ID);

        AlertDialog alert = (AlertDialog) dialog;
        alert.setTitle(isMatch
                ? R.string.result_success
                : R.string.result_failure);
        alert.setMessage(getString(R.string.nfc_result_message, expectedContent, actualContent));
    }

    @Override
    public String getTestId() {
        return getTagTestId(mTechClass);
    }

    static String getTagTestId(Class<?> primaryTech) {
        return NfcTestActivity.class.getName() + ""_"" + primaryTech.getSimpleName();
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.ManagedProfileTest"	"testNfcRestriction"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTest.java"	""	"public void testNfcRestriction() throws Exception {
        assumeHasNfcFeatures();

        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".NfcTest"",
                ""testNfcShareEnabled"", mProfileUserId);
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".NfcTest"",
                ""testNfcShareEnabled"", mParentUserId);

        changeUserRestrictionOrFail(""no_outgoing_beam"" /* UserManager.DISALLOW_OUTGOING_BEAM */,
                true, mProfileUserId);

        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".NfcTest"",
                ""testNfcShareDisabled"", mProfileUserId);
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".NfcTest"",
                ""testNfcShareEnabled"", mParentUserId);
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.NdefPushSenderActivity"	"getTestMessage"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/NdefPushSenderActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.Dialog;
import android.nfc.NdefMessage;
import android.nfc.NdefRecord;
import android.nfc.NfcAdapter;
import android.nfc.NfcEvent;
import android.nfc.NfcManager;
import android.os.Bundle;
import android.widget.TextView;

import java.nio.charset.Charset;

/**
 * Test activity that sends a particular NDEF Push message to another NFC device.
 */
public class NdefPushSenderActivity extends PassFailButtons.Activity implements
        NfcAdapter.CreateNdefMessageCallback {

    static final NdefMessage TEST_MESSAGE = getTestMessage();

    private static final int NFC_NOT_ENABLED_DIALOG_ID = 1;
    private static final int NDEF_PUSH_NOT_ENABLED_DIALOG_ID = 2;

    private NfcAdapter mNfcAdapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setInfoResources(R.string.nfc_ndef_push_sender, R.string.nfc_ndef_push_sender_info, 0);
        setPassFailButtonClickListeners();

        TextView text = (TextView) findViewById(R.id.text);
        text.setText(R.string.nfc_ndef_push_sender_instructions);

        NfcManager nfcManager = (NfcManager) getSystemService(NFC_SERVICE);
        mNfcAdapter = nfcManager.getDefaultAdapter();
    }

    private static NdefMessage getTestMessage() {
        byte[] mimeBytes = ""application/com.android.cts.verifier.nfc""
                .getBytes(Charset.forName(""US-ASCII""));
        byte[] id = new byte[] {1, 3, 3, 7};
        byte[] payload = ""CTS Verifier NDEF Push Tag"".getBytes(Charset.forName(""US-ASCII""));
        return new NdefMessage(new NdefRecord[] {
                new NdefRecord(NdefRecord.TNF_MIME_MEDIA, mimeBytes, id, payload)
        });
    }

    @Override
    protected void onResume() {
        super.onResume();

        if (!mNfcAdapter.isEnabled()) {
            showDialog(NFC_NOT_ENABLED_DIALOG_ID);
        } else if (!mNfcAdapter.isNdefPushEnabled()) {
            /* Sender must have NDEF push enabled */
            showDialog(NDEF_PUSH_NOT_ENABLED_DIALOG_ID);
        }

        mNfcAdapter.setNdefPushMessageCallback(this, this);
    }

    @Override
    protected void onPause() {
        super.onPause();
    }

    @Override
    public Dialog onCreateDialog(int id, Bundle args) {
        switch (id) {
            case NFC_NOT_ENABLED_DIALOG_ID:
                return NfcDialogs.createNotEnabledDialog(this);
            case NDEF_PUSH_NOT_ENABLED_DIALOG_ID:
                return NfcDialogs.createNdefPushNotEnabledDialog(this);
            default:
                return super.onCreateDialog(id, args);
        }
    }

    @Override
    public NdefMessage createNdefMessage(NfcEvent event) {
        return getTestMessage();
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.ForegroundPaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ForegroundPaymentEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.nfc.cardemulation.CardEmulation;
import android.os.Bundle;
import android.util.Log;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

@TargetApi(19)
public class ForegroundPaymentEmulatorActivity extends BaseEmulatorActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (!mCardEmulation.categoryAllowsForegroundPreference(CardEmulation.CATEGORY_PAYMENT)) {
            // Launch tap&pay settings
            NfcDialogs.createChangeForegroundDialog(this).show();
        } else {
            setupServices(this, PaymentService2.COMPONENT, PaymentService1.COMPONENT);
        }
    }

    @Override
    void onServicesSetup(boolean result) {
        if (!makePaymentDefault(PaymentService1.COMPONENT,
                R.string.nfc_hce_change_preinstalled_wallet)) {
            mCardEmulation.setPreferredService(this, PaymentService2.COMPONENT);
            NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_hce_foreground_payment_help)).show();
        } // else, wait for callback
    }

    @Override
    void onPaymentDefaultResult(ComponentName component, boolean success) {
        if (success) {
            NfcDialogs.createHceTapReaderDialog(this, null).show();
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        mCardEmulation.unsetPreferredService(this);
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                PaymentService2.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                PaymentService2.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_foreground_payment_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(PaymentService2.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.permission.cts.NfcPermissionTest"	"isControllerAlwaysOnSupported"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.nfc.NfcAdapter;
import android.nfc.NfcAdapter.ControllerAlwaysOnListener;
import android.platform.test.annotations.AppModeFull;

import androidx.test.InstrumentationRegistry;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.util.concurrent.Executor;

@RunWith(JUnit4.class)
public final class NfcPermissionTest {

    private NfcAdapter mNfcAdapter;

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_NFC);
    }

    @Before
    public void setUp() {
        assumeTrue(supportsHardware());
        mNfcAdapter = NfcAdapter.getDefaultAdapter(InstrumentationRegistry.getTargetContext());
    }

    /**
     * Verifies that isControllerAlwaysOnSupported() requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.permission.cts.NfcPermissionTest"	"testIsControllerAlwaysOnSupported"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	"@AppModeFull
    public void testIsControllerAlwaysOnSupported() {
        try {
            mNfcAdapter.isControllerAlwaysOnSupported();
            fail(""mNfcAdapter.isControllerAlwaysOnSupported() did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that isControllerAlwaysOn() requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.permission.cts.NfcPermissionTest"	"testIsControllerAlwaysOn"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	"@AppModeFull
    public void testIsControllerAlwaysOn() {
        try {
            mNfcAdapter.isControllerAlwaysOn();
            fail(""mNfcAdapter.isControllerAlwaysOn() did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that setControllerAlwaysOn(true) requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.permission.cts.NfcPermissionTest"	"testSetControllerAlwaysOnTrue"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	"@AppModeFull
    public void testSetControllerAlwaysOnTrue() {
        try {
            mNfcAdapter.setControllerAlwaysOn(true);
            fail(""mNfcAdapter.setControllerAlwaysOn(true) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that setControllerAlwaysOn(false) requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.permission.cts.NfcPermissionTest"	"testSetControllerAlwaysOnFalse"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	"@AppModeFull
    public void testSetControllerAlwaysOnFalse() {
        try {
            mNfcAdapter.setControllerAlwaysOn(false);
            fail(""mNfcAdapter.setControllerAlwaysOn(true) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that registerControllerAlwaysOnListener() requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.permission.cts.NfcPermissionTest"	"testRegisterControllerAlwaysOnListener"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	"@AppModeFull
    public void testRegisterControllerAlwaysOnListener() {
        try {
            mNfcAdapter.registerControllerAlwaysOnListener(
                    new SynchronousExecutor(), new AlwaysOnStateListener());
            fail(""mNfcAdapter.registerControllerAlwaysOnListener did not throw""
                    + ""SecurityException as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that unregisterControllerAlwaysOnListener() requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.permission.cts.NfcPermissionTest"	"testUnregisterControllerAlwaysOnListener"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	"@AppModeFull
    public void testUnregisterControllerAlwaysOnListener() {
        try {
            mNfcAdapter.unregisterControllerAlwaysOnListener(new AlwaysOnStateListener());
            fail(""mNfcAdapter.unregisterControllerAlwaysOnListener did not throw""
                    + ""SecurityException as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    private class SynchronousExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }

    private class AlwaysOnStateListener implements ControllerAlwaysOnListener {
        @Override
        public void onControllerAlwaysOnChanged(boolean isEnabled) {
            // Do nothing
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.comp.BindDeviceAdminServiceFailsTest"	"testCannotBind"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/BindDeviceAdminServiceFailsTest.java"	""	"public void testCannotBind() throws Exception {
        UserHandle otherProfile = Utils.getOtherProfile(mContext);
        if (otherProfile != null) {
            checkCannotBind(AdminReceiver.COMP_DPC_PACKAGE_NAME, otherProfile);
            checkCannotBind(AdminReceiver.COMP_DPC_2_PACKAGE_NAME, otherProfile);
        }
    }

    private void checkCannotBind(String targetPackageName, UserHandle otherProfile) {
        try {
            final Intent serviceIntent = new Intent();
            serviceIntent.setClassName(targetPackageName, ProtectedCrossUserService.class.getName());
            bind(serviceIntent, EMPTY_SERVICE_CONNECTION, otherProfile);
            fail(""SecurityException should be thrown"");
        } catch (SecurityException ex) {
            MoreAsserts.assertContainsRegex(
                    ""Not allowed to bind to target user id"", ex.getMessage());
        }
    }

    private boolean bind(Intent serviceIntent, ServiceConnection serviceConnection,
            UserHandle userHandle) {
        return mDpm.bindDeviceAdminServiceAsUser(AdminReceiver.getComponentName(mContext),
                serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE, userHandle);
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.certinstaller.CertSelectionDelegateTest"	"testNotChosenAnyAlias"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CertInstaller/src/com/android/cts/certinstaller/CertSelectionDelegateTest.java"	""	"public void testNotChosenAnyAlias() throws Exception {
        assertThat(mDpm.getDelegatedScopes(null, mContext.getPackageName())).contains(
                DevicePolicyManager.DELEGATION_CERT_SELECTION);
        assertNull(new KeyChainAliasFuture(KeyChain.KEY_ALIAS_SELECTION_DENIED).get());
    }

    private class KeyChainAliasFuture implements KeyChainAliasCallback {
        private final CountDownLatch mLatch = new CountDownLatch(1);
        private String mChosenAlias = null;

        @Override
        public void alias(final String chosenAlias) {
            mChosenAlias = chosenAlias;
            mLatch.countDown();
        }

        public KeyChainAliasFuture(String alias)
                throws UnsupportedEncodingException {
            /* Pass the alias as a GET to an imaginary server instead of explicitly asking for it,
             * to make sure the DPC actually has to do some work to grant the cert.
             */
            final Uri uri = Uri.parse(""https://example.org/?delegate-alias=""
                    + URLEncoder.encode(alias, ""UTF-8""));
            KeyChain.choosePrivateKeyAlias(mActivity, this,
                    null /* keyTypes */, null /* issuers */, uri, null /* alias */);
        }

        public String get() throws InterruptedException {
            assertWithMessage(""Chooser timeout"")
                    .that(mLatch.await(KEYCHAIN_TIMEOUT_MINS, TimeUnit.MINUTES))
                    .isTrue();
            return mChosenAlias;
        }
    }

    private static PrivateKey getPrivateKey(final byte[] key, String type)
            throws NoSuchAlgorithmException, InvalidKeySpecException {
        return KeyFactory.getInstance(type).generatePrivate(
                new PKCS8EncodedKeySpec(key));
    }

    private static Certificate getCertificate(byte[] cert) throws CertificateException {
        return CertificateFactory.getInstance(""X.509"").generateCertificate(
                new ByteArrayInputStream(cert));
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.ScreenOffPaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ScreenOffPaymentEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.app.Dialog;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.nfc.NfcAdapter;
import android.nfc.NfcManager;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class ScreenOffPaymentEmulatorActivity extends BaseEmulatorActivity {
    final static int STATE_SCREEN_ON = 0;
    final static int STATE_SCREEN_OFF = 1;
    private static final int SECURE_NFC_ENABLED_DIALOG_ID = 1;
    private int mState = STATE_SCREEN_ON;

    private ScreenOnOffReceiver mReceiver;
    private NfcAdapter mNfcAdapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        mState = STATE_SCREEN_ON;
        setupServices(this, ScreenOffPaymentService.COMPONENT);

        mReceiver = new ScreenOnOffReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_SCREEN_OFF);
        filter.addAction(Intent.ACTION_SCREEN_ON);
        registerReceiver(mReceiver, filter);

        NfcManager nfcManager = getSystemService(NfcManager.class);
        mNfcAdapter = nfcManager.getDefaultAdapter();
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (mNfcAdapter.isSecureNfcSupported() && mNfcAdapter.isSecureNfcEnabled()) {
            showDialog(SECURE_NFC_ENABLED_DIALOG_ID);
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(mReceiver);
    }

    @Override
    void onServicesSetup(boolean result) {
        // Verify ScreenOff HCE service is the default
        if (makePaymentDefault(ScreenOffPaymentService.COMPONENT,
                R.string.nfc_hce_change_preinstalled_wallet)) {
            // Wait for callback
        } else {
                NfcDialogs.createHceTapReaderDialog(this,
                        getString(R.string.nfc_screen_off_hce_payment_help)).show();
        }
    }

    @Override
    void onPaymentDefaultResult(ComponentName component, boolean success) {
        if (success) {
            NfcDialogs.createHceTapReaderDialog(this,
                    getString(R.string.nfc_screen_off_hce_payment_help)).show();
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
    }
    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                ScreenOffPaymentService.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                ScreenOffPaymentService.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_screen_off_hce_payment_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(ScreenOffPaymentService.COMPONENT) && mState == STATE_SCREEN_OFF) {
            getPassButton().setEnabled(true);
        }
    }

    @Override
    public Dialog onCreateDialog(int id, Bundle args) {
        switch (id) {
            case SECURE_NFC_ENABLED_DIALOG_ID:
                return NfcDialogs.createSecureNfcEnabledDialog(this);
            default:
                return super.onCreateDialog(id, args);
        }
    }

    private class ScreenOnOffReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (action.equals(Intent.ACTION_SCREEN_OFF)) {
                mState = STATE_SCREEN_OFF;
            } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
                mState = STATE_SCREEN_ON;
            }
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.offhost.SimpleOffhostReaderActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/offhost/SimpleOffhostReaderActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.offhost;

import android.annotation.TargetApi;
import android.app.AlertDialog;
import android.content.Intent;
import android.content.SharedPreferences;
import android.nfc.NfcAdapter;
import android.nfc.NfcAdapter.ReaderCallback;
import android.nfc.tech.IsoDep;
import android.nfc.tech.NfcA;
import android.nfc.tech.NfcB;
import android.nfc.Tag;
import android.os.Bundle;
import android.os.Parcelable;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.Spinner;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.io.IOException;
import java.util.Arrays;

import com.android.cts.verifier.nfc.hce.HceUtils;
import com.android.cts.verifier.nfc.hce.CommandApdu;

public class SimpleOffhostReaderActivity extends PassFailButtons.Activity implements ReaderCallback,
        OnItemSelectedListener {
    public static final String PREFS_NAME = ""OffhostTypePrefs"";

    public static final String TAG = ""SimpleOffhostReaderActivity"";
    public static final String EXTRA_APDUS = ""apdus"";
    public static final String EXTRA_RESPONSES = ""responses"";
    public static final String EXTRA_LABEL = ""label"";
    public static final String EXTRA_DESELECT = ""deselect"";

    NfcAdapter mAdapter;
    CommandApdu[] mApdus;
    String[] mResponses;
    String mLabel;
    boolean mDeselect;
    boolean mIsTypeB;

    TextView mTextView;
    Spinner mSpinner;
    SharedPreferences mPrefs;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.nfc_hce_reader);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mLabel = getIntent().getStringExtra(EXTRA_LABEL);
        mDeselect = getIntent().getBooleanExtra(EXTRA_DESELECT, false);
        setTitle(mLabel);

        mAdapter = NfcAdapter.getDefaultAdapter(this);
        mTextView = (TextView) findViewById(R.id.text);
        mTextView.setTextSize(12.0f);
        mTextView.setText(R.string.nfc_offhost_uicc_type_selection);

        Spinner spinner = (Spinner) findViewById(R.id.type_ab_selection);
        ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(this,
                R.array.nfc_types_array, android.R.layout.simple_spinner_item);
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        spinner.setAdapter(adapter);
        spinner.setOnItemSelectedListener(this);

        mPrefs = getSharedPreferences(PREFS_NAME, 0);
        mIsTypeB = mPrefs.getBoolean(""typeB"", false);
        if (mIsTypeB) {
            spinner.setSelection(1);
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        mAdapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_A |
                NfcAdapter.FLAG_READER_NFC_BARCODE | NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);
        Intent intent = getIntent();
        Parcelable[] apdus = intent.getParcelableArrayExtra(EXTRA_APDUS);
        if (apdus != null) {
            mApdus = new CommandApdu[apdus.length];
            for (int i = 0; i < apdus.length; i++) {
                mApdus[i] = (CommandApdu) apdus[i];
            }
        } else {
            mApdus = null;
        }
        mResponses = intent.getStringArrayExtra(EXTRA_RESPONSES);
    }

    @Override
    public void onTagDiscovered(Tag tag) {
        final StringBuilder sb = new StringBuilder();
        long startTime = 0;
        boolean success = true;
        int count = 0;

        try {
            if(mDeselect) {
                mIsTypeB = mPrefs.getBoolean(""typeB"", false);
                // Use FrameRF for deselect test case
                if(mIsTypeB) {
                    NfcB nfcb = NfcB.get(tag);
                    if (nfcb == null) {
                        // TODO dialog box
                        return;
                    }
                    byte[] tagId = tag.getId();
                    String tagIdString = HceUtils.getHexBytes("""", tagId);
                    nfcb.connect();
                    startTime = System.currentTimeMillis();

                    //ATTRIB
                    int tagIdLen = tagId.length;
                    if (tagIdLen != 4) {
                        // NFCID0 should be 4 bytes
                        return;
                    }
                    byte[] attrib = new byte[tagIdLen + 5];
                    attrib[0] = (byte)0x1d;
                    for(int i = 0; i < tagIdLen; i ++) {
                        attrib[1+i] = tagId[i];
                    }
                    attrib[tagIdLen+1] = 0x00;
                    attrib[tagIdLen+2] = 0x08;
                    attrib[tagIdLen+3] = 0x01;
                    attrib[tagIdLen+4] = 0x00;
                    nfcb.transceive(attrib);

                    count = 0;
                    for (CommandApdu apdu: mApdus) {
                        sb.append(""Request APDU:\n"");
                        sb.append(apdu.getApdu() + ""\n\n"");
                        long apduStartTime = System.currentTimeMillis();
                        byte[] response =
                                nfcb.transceive(HceUtils.hexStringToBytes(apdu.getApdu()));
                        long apduEndTime = System.currentTimeMillis();
                        if (!responseCheck(sb, response, count, apduStartTime, apduEndTime)) {
                            success = false;
                            break;
                        }
                        count++;
                    }
                    nfcb.transceive(HceUtils.hexStringToBytes(""C2""));
                } else {
                    NfcA nfca = NfcA.get(tag);
                    if (nfca == null) {
                        // TODO dialog box
                        return;
                    }
                    nfca.connect();
                    nfca.setTimeout(5000);
                    startTime = System.currentTimeMillis();
                    // RATS
                    nfca.transceive(HceUtils.hexStringToBytes(""E080""));

                    count = 0;
                    for (CommandApdu apdu: mApdus) {
                        sb.append(""Request APDU:\n"");
                        sb.append(apdu.getApdu() + ""\n\n"");
                        long apduStartTime = System.currentTimeMillis();
                        byte[] response =
                                nfca.transceive(HceUtils.hexStringToBytes(apdu.getApdu()));
                        long apduEndTime = System.currentTimeMillis();
                        if (!responseCheck(sb, response, count, apduStartTime, apduEndTime)) {
                            success = false;
                            break;
                        }
                        count++;
                    }
                    // S-block DESELECT
                    nfca.transceive(HceUtils.hexStringToBytes(""C2""));
                }
                mAdapter.disableReaderMode(this);
            } else {
                IsoDep isoDep = IsoDep.get(tag);
                if (isoDep == null) {
                    // TODO dialog box
                    return;
                }
                isoDep.connect();
                isoDep.setTimeout(5000);
                startTime = System.currentTimeMillis();

                count = 0;
                for (CommandApdu apdu: mApdus) {
                    sb.append(""Request APDU:\n"");
                    sb.append(apdu.getApdu() + ""\n\n"");
                    long apduStartTime = System.currentTimeMillis();
                    byte[] response = isoDep.transceive(HceUtils.hexStringToBytes(apdu.getApdu()));
                    long apduEndTime = System.currentTimeMillis();
                    if (!responseCheck(sb, response, count, apduStartTime, apduEndTime)) {
                        success = false;
                        break;
                    }
                    count++;
                }
            }

            if (success) {
                sb.insert(0, ""Total APDU exchange time: "" +
                        Long.toString(System.currentTimeMillis() - startTime) + "" ms.\n\n"");
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(sb.toString());
                        getPassButton().setEnabled(true);
                    }
                });
            } else {
                sb.insert(0, ""FAIL. Total APDU exchange time: "" +
                        Long.toString(System.currentTimeMillis() - startTime) + "" ms.\n\n"");
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(sb.toString());
                        AlertDialog.Builder builder = new AlertDialog.Builder(SimpleOffhostReaderActivity.this);
                        builder.setTitle(""Test failed"");
                        builder.setMessage(""An unexpected response APDU was received, or no APDUs were received at all."");
                        builder.setPositiveButton(""OK"", null);
                        builder.show();
                    }
                });
            }
        } catch (IOException e) {
            sb.insert(0, ""Error while reading: (did you keep the devices in range?)\nPlease try again\n."");
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    mTextView.setText(sb.toString());
                }
            });
        } finally {
        }
    }

    private boolean responseCheck(StringBuilder sb, byte[] response, int count,
            long apduStartTime, long apduEndTime) {
        sb.append(""Response APDU (in "" + Long.toString(apduEndTime - apduStartTime) +
                "" ms):\n"");
        sb.append(HceUtils.getHexBytes(null, response));
        sb.append(""\n\n\n"");
        boolean wildCard = ""*"".equals(mResponses[count]);
        byte[] expectedResponse = HceUtils.hexStringToBytes(mResponses[count]);
        Log.d(TAG, HceUtils.getHexBytes(""APDU response: "", response));

        if (response.length > expectedResponse.length) {
            response = Arrays.copyOfRange(response,
                    response.length - expectedResponse.length, response.length);
        }

        if (!wildCard && !Arrays.equals(response, expectedResponse)) {
            Log.d(TAG, ""Unexpected APDU response: "" +
                                HceUtils.getHexBytes("""", response));
            return false;
        }
        return true;
    }

    @Override
    public void onItemSelected(AdapterView<?> parent, View view, int position,
            long id) {
        if (position == 0) {
            // Type-A
            mAdapter.disableReaderMode(this);
            mAdapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_A |
                NfcAdapter.FLAG_READER_NFC_BARCODE | NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);
            SharedPreferences.Editor editor = mPrefs.edit();
            editor.putBoolean(""typeB"", false);
            editor.commit();
        } else {
            // Type-B
            mAdapter.disableReaderMode(this);
            mAdapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_B |
                    NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);
            SharedPreferences.Editor editor = mPrefs.edit();
            editor.putBoolean(""typeB"", true);
            editor.commit();
        }
    }

    @Override
    public void onNothingSelected(AdapterView<?> parent) {
    }

    @Override
    public String getTestId() {
        return mLabel;
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.comp.BindDeviceAdminServiceGoodSetupTest"	"testCannotBind_unprotectedCrossUserService"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/BindDeviceAdminServiceGoodSetupTest.java"	""	"public void testCannotBind_unprotectedCrossUserService() throws Exception {
        final Intent serviceIntent = new Intent(mContext, UnprotectedCrossUserService.class);
        for (UserHandle targetUser : mTargetUsers) {
            try {
                bind(serviceIntent, EMPTY_SERVICE_CONNECTION, targetUser);
                fail(""SecurityException should be thrown for target user "" + targetUser);
            } catch (SecurityException ex) {
                MoreAsserts.assertContainsRegex(
                        ""must be protected by BIND_DEVICE_ADMIN"", ex.getMessage());
            }
        }
    }

    /**
     * Talk to a DPC package that is neither device owner nor profile owner.
     */"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.comp.BindDeviceAdminServiceGoodSetupTest"	"testCheckCannotBind_nonManagingPackage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/BindDeviceAdminServiceGoodSetupTest.java"	""	"public void testCheckCannotBind_nonManagingPackage() throws Exception {
        final Intent serviceIntent = new Intent();
        serviceIntent.setClassName(NON_MANAGING_PACKAGE, ProtectedCrossUserService.class.getName());
        for (UserHandle targetUser : mTargetUsers) {
            try {
                bind(serviceIntent, EMPTY_SERVICE_CONNECTION, targetUser);
                fail(""SecurityException should be thrown for target user "" + targetUser);
            } catch (SecurityException ex) {
                MoreAsserts.assertContainsRegex(""Only allow to bind service"", ex.getMessage());
            }
        }
    }

    /**
     * Talk to the same DPC in same user, that is talking to itself.
     */"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.NfcDialogs"	"OnClickListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/NfcDialogs.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.provider.Settings;

import com.android.cts.verifier.R;

/** Class containing methods to create common dialogs for NFC activities. */
public class NfcDialogs {

    static AlertDialog createNotEnabledDialog(final Context context) {
        return new AlertDialog.Builder(context)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setTitle(R.string.nfc_not_enabled)
                .setMessage(R.string.nfc_not_enabled_message)
                .setPositiveButton(R.string.nfc_settings, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Intent intent = new Intent(Settings.ACTION_NFC_SETTINGS);
                        context.startActivity(intent);
                    }
                })
                .create();
    }

    static AlertDialog createNdefPushNotEnabledDialog(final Context context) {
        return new AlertDialog.Builder(context)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setTitle(R.string.ndef_push_not_enabled)
                .setMessage(R.string.ndef_push_not_enabled_message)
                .setPositiveButton(R.string.ndef_push_settings, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Intent intent = new Intent(Settings.ACTION_NFCSHARING_SETTINGS);
                        context.startActivity(intent);
                    }
                })
                .create();
    }

    public static AlertDialog createHceTapReaderDialog(final Context context, String message) {
        String baseString = context.getString(R.string.nfc_hce_tap_reader_message);
        return new AlertDialog.Builder(context)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setTitle(R.string.nfc_hce_tap_reader_title)
                .setMessage(message != null ? message + ""\n\n"" + baseString : baseString)
                .setPositiveButton(""OK"", null)
                .create();
    }

    public static AlertDialog createChangeForegroundDialog(final Context context) {
        return new AlertDialog.Builder(context)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setTitle(R.string.nfc_hce_tap_reader_title)
                .setMessage(context.getString(R.string.nfc_hce_change_favor_foreground))
                .setPositiveButton(""OK"", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Intent intent = new Intent(Settings.ACTION_NFC_PAYMENT_SETTINGS);
                        context.startActivity(intent);
                    }
                })
                .create();
    }

    /**
     * SecureNfcEnabled dialog
     */
    public static AlertDialog createSecureNfcEnabledDialog(final Context context) {
        return new AlertDialog.Builder(context)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setTitle(R.string.secure_nfc_enabled)
                .setMessage(R.string.secure_nfc_enabled_message)
                .setPositiveButton(R.string.nfc_settings, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Intent intent = new Intent(Settings.ACTION_NFC_SETTINGS);
                        context.startActivity(intent);
                    }
                })
                .create();
    }


    private NfcDialogs() {
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.AdbUtils"	"emptyList"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/AdbUtils.java"	""	"public void test/*
 *.
 */

package android.security.cts;

import com.android.compatibility.common.util.CrashUtils;
import com.android.compatibility.common.util.MetricsReportLog;
import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;
import com.android.ddmlib.IShellOutputReceiver;
import com.android.ddmlib.NullOutputReceiver;
import com.android.ddmlib.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.device.NativeDevice;
import com.android.tradefed.log.LogUtil.CLog;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.concurrent.TimeoutException;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.concurrent.TimeUnit;
import java.util.Scanner;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.Collections;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.regex.Pattern;
import java.lang.Thread;

import static org.junit.Assert.*;
import static org.junit.Assume.*;

public class AdbUtils {

    final static String TMP_PATH = ""/data/local/tmp/"";
    final static int TIMEOUT_SEC = 9 * 60;
    final static String RESOURCE_ROOT = ""/"";

    public static class pocConfig {
        String binaryName;
        String arguments;
        Map<String, String> envVars;
        String inputFilesDestination;
        ITestDevice device;
        CrashUtils.Config config;
        List<String> inputFiles = Collections.emptyList();
        boolean checkCrash = true;

        pocConfig(String binaryName, ITestDevice device) {
            this.binaryName = binaryName;
            this.device = device;
        }
    }

    /** Runs a commandline on the specified device
     *
     * @param command the command to be ran
     * @param device device for the command to be ran on
     * @return the console output from running the command
     */
    public static String runCommandLine(String command, ITestDevice device) throws Exception {
        if (""reboot"".equals(command)) {
            throw new IllegalArgumentException(
                    ""You called a forbidden command! Please fix your tests."");
        }
        return device.executeShellCommand(command);
    }

    /**
     * Pushes and runs a binary to the selected device
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @return the console output from the binary
     */
    public static String runPoc(String pocName, ITestDevice device) throws Exception {
        return runPoc(pocName, device, SecurityTestCase.TIMEOUT_NONDETERMINISTIC);
    }

    /**
     * Pushes and runs a binary to the selected device
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     * @return the console output from the binary
     */
    public static String runPoc(String pocName, ITestDevice device, int timeout) throws Exception {
        return runPoc(pocName, device, timeout, null);
    }

    /**
     * Pushes and runs a binary to the selected device
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     * @param arguments the input arguments for the poc
     * @return the console output from the binary
     */
    public static String runPoc(String pocName, ITestDevice device, int timeout, String arguments)
            throws Exception {
        CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        runPoc(pocName, device, timeout, arguments, receiver);
        return receiver.getOutput();
    }

    /**
     * Pushes and runs a binary to the selected device and ignores any of its output.
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    public static void runPocNoOutput(String pocName, ITestDevice device, int timeout)
            throws Exception {
        runPocNoOutput(pocName, device, timeout, null);
    }

    /**
     * Pushes and runs a binary with arguments to the selected device and
     * ignores any of its output.
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     * @param arguments input arguments for the poc
     */
    public static void runPocNoOutput(String pocName, ITestDevice device, int timeout,
            String arguments) throws Exception {
        runPoc(pocName, device, timeout, arguments, null);
    }

    /**
     * Pushes and runs a binary with arguments to the selected device and
     * ignores any of its output.
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     * @param arguments input arguments for the poc
     * @param receiver the type of receiver to run against
     */
    public static int runPoc(String pocName, ITestDevice device, int timeout,
            String arguments, IShellOutputReceiver receiver) throws Exception {
              return runPoc(pocName, device, timeout, arguments, null, receiver);
    }

    /**
     * Pushes and runs a binary with arguments to the selected device and
     * ignores any of its output.
     *
     * @param pocName name of the poc binary
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     * @param arguments input arguments for the poc
     * @param envVars run the poc with environment variables
     * @param receiver the type of receiver to run against
     */
    public static int runPoc(String pocName, ITestDevice device, int timeout,
            String arguments, Map<String, String> envVars,
            IShellOutputReceiver receiver) throws Exception {
        String remoteFile = String.format(""%s%s"", TMP_PATH, pocName);
        SecurityTestCase.getPocPusher(device).pushFile(pocName + ""_sts"", remoteFile);

        assertPocExecutable(pocName, device);
        if (receiver == null) {
            receiver = new NullOutputReceiver();
        }
        if (arguments == null) {
            arguments = """";
        }

        String env = """";
        if (envVars != null) {
            StringBuilder sb = new StringBuilder();
            for (Map.Entry<String, String> entry : envVars.entrySet()) {
                sb
                    .append(entry.getKey().trim())
                    .append('=')
                    .append(entry.getValue().trim())
                    .append(' ');
            }
            env = sb.toString();
            CLog.i(""Running poc '%s' with env variables '%s'"", pocName, env);
        }

        // since we have to return the exit status AND the poc stdout+stderr we redirect the exit
        // status to a file temporarily
        String exitStatusFilepath = TMP_PATH + ""exit_status"";
        runCommandLine(""rm "" + exitStatusFilepath, device); // remove any old exit status
        device.executeShellCommand(
                env + TMP_PATH + pocName + "" "" + arguments +
                ""; echo $? > "" + exitStatusFilepath, // echo exit status to file
                receiver, timeout, TimeUnit.SECONDS, 0);

        // cat the exit status
        String exitStatusString = runCommandLine(""cat "" + exitStatusFilepath, device).trim();

        MetricsReportLog reportLog = SecurityTestCase.buildMetricsReportLog(device);
        reportLog.addValue(""poc_name"", pocName, ResultType.NEUTRAL, ResultUnit.NONE);
        int exitStatus = -1;
        try {
            exitStatus = Integer.parseInt(exitStatusString);
            reportLog.addValue(""exit_status"", exitStatus, ResultType.NEUTRAL, ResultUnit.NONE);
        } catch (NumberFormatException e) {
            // Getting the exit status is a bonus. We can continue without it.
            CLog.w(""Could not parse exit status to int: %s"", exitStatusString);
        }
        reportLog.submit();

        runCommandLine(""rm "" + exitStatusFilepath, device);
        return exitStatus;
    }

    /**
     * Assert the poc is executable
     * @param pocName name of the poc binary
     * @param device device to be ran on
     */
    private static void assertPocExecutable(String pocName, ITestDevice device) throws Exception {
        String fullPocPath = TMP_PATH + pocName;
        device.executeShellCommand(""chmod 777 "" + fullPocPath);
        assertEquals(""'"" + pocName + ""' must exist and be readable."", 0,
                runCommandGetExitCode(""test -r "" + fullPocPath, device));
        assertEquals(""'"" + pocName + ""'poc must exist and be writable."", 0,
                runCommandGetExitCode(""test -w "" + fullPocPath, device));
        assertEquals(""'"" + pocName + ""'poc must exist and be executable."", 0,
                runCommandGetExitCode(""test -x "" + fullPocPath, device));
    }

    /**
     * Enables malloc debug on a given process.
     *
     * @param processName the name of the process to run with libc malloc debug
     * @param device the device to use
     * @return true if enabling malloc debug succeeded
     */
    public static boolean enableLibcMallocDebug(String processName, ITestDevice device) throws Exception {
        device.executeShellCommand(""setprop libc.debug.malloc.program "" + processName);
        device.executeShellCommand(""setprop libc.debug.malloc.options \""backtrace guard\"""");
        /**
         * The pidof command is being avoided because it does not exist on versions before M, and
         * it behaves differently between M and N.
         * Also considered was the ps -AoPID,CMDLINE command, but ps does not support options on
         * versions before O.
         * The [^]] prefix is being used for the grep command to avoid the case where the output of
         * ps includes the grep command itself.
         */
        String cmdOut = device.executeShellCommand(""ps -A | grep '[^]]"" + processName + ""'"");
        /**
         * .hasNextInt() checks if the next token can be parsed as an integer, not if any remaining
         * token is an integer.
         * Example command: $ ps | fgrep mediaserver
         * Out: media     269   1     77016  24416 binder_thr 00f35142ec S /system/bin/mediaserver
         * The second field of the output is the PID, which is needed to restart the process.
         */
        Scanner s = new Scanner(cmdOut).useDelimiter(""\\D+"");
        if(!s.hasNextInt()) {
            CLog.w(""Could not find pid for process: "" + processName);
            return false;
        }

        String result = device.executeShellCommand(""kill -9 "" + s.nextInt());
        if(!result.equals("""")) {
            CLog.w(""Could not restart process: "" + processName);
            return false;
        }

        TimeUnit.SECONDS.sleep(1);
        return true;
    }

    /**
     * Pushes and installs an apk to the selected device
     *
     * @param pathToApk a string path to apk from the /res folder
     * @param device device to be ran on
     * @return the output from attempting to install the apk
     */
    public static String installApk(String pathToApk, ITestDevice device) throws Exception {

        String fullResourceName = pathToApk;
        File apkFile = File.createTempFile(""apkFile"", "".apk"");
        try {
            apkFile = extractResource(fullResourceName, apkFile);
            return device.installPackage(apkFile, true);
        } finally {
            apkFile.delete();
        }
    }

    /**
     * Extracts a resource and pushes it to the device
     *
     * @param fullResourceName a string path to resource from the res folder
     * @param deviceFilePath the remote destination absolute file path
     * @param device device to be ran on
     */
    public static void pushResource(String fullResourceName, String deviceFilePath,
                                    ITestDevice device) throws Exception {
        File resFile = File.createTempFile(""CTSResource"", """");
        try {
            resFile = extractResource(fullResourceName, resFile);
            device.pushFile(resFile, deviceFilePath);
        } finally {
            resFile.delete();
        }
    }

    /**
     * Pushes the specified files to the specified destination directory
     *
     * @param inputFiles files required as input
     * @param inputFilesDestination destination directory to which input files are
     *        pushed
     * @param device device to be run on
     */
    public static void pushResources(String[] inputFiles, String inputFilesDestination,
            ITestDevice device) throws Exception {
        if (inputFiles == null || inputFilesDestination == null) {
            throw new IllegalArgumentException(
                    ""Can't push resources: input files or destination is null"");
        }
        for (String tempFile : inputFiles) {
            pushResource(RESOURCE_ROOT + tempFile, inputFilesDestination + tempFile, device);
        }
    }

    /**
     * Removes the specified files from the specified destination directory
     *
     * @param inputFiles files required as input
     * @param inputFilesDestination destination directory where input files are
     *        present
     * @param device device to be run on
     */
    public static void removeResources(String[] inputFiles, String inputFilesDestination,
            ITestDevice device) throws Exception {
        if (inputFiles == null || inputFilesDestination == null) {
            throw new IllegalArgumentException(
                    ""Can't remove resources: input files or destination is null"");
        }
        for (String tempFile : inputFiles) {
            runCommandLine(""rm "" + inputFilesDestination + tempFile, device);
        }
    }

   /**
     * Extracts the binary data from a resource and writes it to a temp file
     */
    private static File extractResource(String fullResourceName, File file) throws Exception {
        try (InputStream in = AdbUtils.class.getResourceAsStream(fullResourceName);
            OutputStream out = new BufferedOutputStream(new FileOutputStream(file))) {
            if (in == null) {
                throw new IllegalArgumentException(""Resource not found: "" + fullResourceName);
            }
            byte[] buf = new byte[65536];
            int chunkSize;
            while ((chunkSize = in.read(buf)) != -1) {
                out.write(buf, 0, chunkSize);
            }
            return file;
        }

    }
    /**
     * Utility function to help check the exit code of a shell command
     */
    public static int runCommandGetExitCode(String cmd, ITestDevice device) throws Exception {
        long time = System.currentTimeMillis();
        String exitStatusString = runCommandLine(
                ""("" + cmd + "") > /dev/null 2>&1; echo $?"", device).trim();
        time = System.currentTimeMillis() - time;

        try {
            int exitStatus = Integer.parseInt(exitStatusString);
            MetricsReportLog reportLog = SecurityTestCase.buildMetricsReportLog(device);
            reportLog.addValue(""command"", cmd, ResultType.NEUTRAL, ResultUnit.NONE);
            reportLog.addValue(""exit_status"", exitStatus, ResultType.NEUTRAL, ResultUnit.NONE);
            reportLog.submit();
            return exitStatus;
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException(String.format(
                    ""Could not get the exit status (%s) for '%s' (%d ms)."",
                    exitStatusString, cmd, time));
        }
    }

    /**
     * Pushes and runs a binary to the selected device and checks exit code
     * Return code 113 is used to indicate the vulnerability
     *
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    @Deprecated
    public static boolean runPocCheckExitCode(String pocName, ITestDevice device,
                                              int timeout) throws Exception {

       //Refer to go/asdl-sts-guide Test section for knowing the significance of 113 code
       return runPocGetExitStatus(pocName, device, timeout) == 113;
    }

    /**
     * Pushes and runs a binary to the device and returns the exit status.
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds

     */
    public static int runPocGetExitStatus(String pocName, ITestDevice device, int timeout)
            throws Exception {
       return runPocGetExitStatus(pocName, null, device, timeout);
    }

    /**
     * Pushes and runs a binary to the device and returns the exit status.
     * @param pocName a string path to poc from the /res folder
     * @param arguments input arguments for the poc
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    public static int runPocGetExitStatus(String pocName, String arguments, ITestDevice device,
            int timeout) throws Exception {
              return runPocGetExitStatus(pocName, arguments, null, device, timeout);
    }

    /**
     * Pushes and runs a binary to the device and returns the exit status.
     * @param pocName name of the poc binary
     * @param arguments input arguments for the poc
     * @param envVars run the poc with environment variables
     * @param device device to be run on
     * @param timeout time to wait for output in seconds
     */
    public static int runPocGetExitStatus(
            String pocName, String arguments, Map<String, String> envVars,
            ITestDevice device, int timeout) throws Exception {
        return runPoc(pocName, device, timeout, arguments, envVars, null);
    }

    /**
     * Pushes and runs a binary and asserts that the exit status isn't 113: vulnerable.
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    public static void runPocAssertExitStatusNotVulnerable(
            String pocName, ITestDevice device, int timeout) throws Exception {
        runPocAssertExitStatusNotVulnerable(pocName, null, device, timeout);
    }

    /**
     * Pushes and runs a binary and asserts that the exit status isn't 113: vulnerable.
     * @param pocName a string path to poc from the /res folder
     * @param arguments input arguments for the poc
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    public static void runPocAssertExitStatusNotVulnerable(String pocName, String arguments,
            ITestDevice device, int timeout) throws Exception {
              runPocGetExitStatus(pocName, arguments, null, device, timeout);
    }

    /**
     * Pushes and runs a binary and asserts that the exit status isn't 113: vulnerable.
     * @param pocName name of the poc binary
     * @param arguments input arguments for the poc
     * @param envVars run the poc with environment variables
     * @param device device to be ran on
     * @param timeout time to wait for output in seconds
     */
    public static void runPocAssertExitStatusNotVulnerable(
            String pocName, String arguments, Map<String, String> envVars,
            ITestDevice device, int timeout) throws Exception {
        assertTrue(""PoC returned exit status 113: vulnerable"",
                runPocGetExitStatus(pocName, arguments, envVars, device, timeout) != 113);
    }

    /**
     * Runs the poc binary and asserts that there are no security crashes that match the expected
     * process pattern.
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param processPatternStrings a Pattern string to match the crash tombstone process
     */
    public static void runPocAssertNoCrashes(String pocName, ITestDevice device,
            String... processPatternStrings) throws Exception {
        runPocAssertNoCrashes(pocName, device,
                new CrashUtils.Config().setProcessPatterns(processPatternStrings));
    }

    /**
     * Runs the poc binary and asserts that there are no security crashes that match the expected
     * process pattern.
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param config a crash parser configuration
     */
    public static void runPocAssertNoCrashes(String pocName, ITestDevice device,
            CrashUtils.Config config) throws Exception {
        runPocAssertNoCrashes(pocName, device, null, config);
    }

    /**
     * Runs the poc binary and asserts that there are no security crashes that match the expected
     * process pattern, including arguments when running.
     * @param pocName a string path to poc from the /res folder
     * @param device device to be ran on
     * @param arguments input arguments for the poc
     * @param config a crash parser configuration
     */
    public static void runPocAssertNoCrashes(String pocName, ITestDevice device, String arguments,
            CrashUtils.Config config) throws Exception {
        AdbUtils.runCommandLine(""logcat -c"", device);
        AdbUtils.runPocNoOutput(pocName, device,
                SecurityTestCase.TIMEOUT_NONDETERMINISTIC, arguments);
        assertNoCrashes(device, config);
    }

    /**
     * Runs the poc binary and asserts following 2 conditions.
     *  1. There are no security crashes in the binary.
     *  2. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param binaryName name of the binary
     * @param arguments arguments for running the binary
     * @param device device to be run on
     */
    public static void runPocAssertNoCrashesNotVulnerable(String binaryName, String arguments,
            ITestDevice device) throws Exception {
        runPocAssertNoCrashesNotVulnerable(binaryName, arguments, null, null, device, null);
    }

    /**
     * Runs the poc binary and asserts following 2 conditions.
     *  1. There are no security crashes in the binary.
     *  2. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param binaryName name of the binary
     * @param arguments arguments for running the binary
     * @param device device to be run on
     * @param processPatternStrings a Pattern string to match the crash tombstone
     *        process
     */
    public static void runPocAssertNoCrashesNotVulnerable(String binaryName, String arguments,
            ITestDevice device, String processPatternStrings[]) throws Exception {
        runPocAssertNoCrashesNotVulnerable(binaryName, arguments, null, null, device,
                processPatternStrings);
    }

    /**
     * Runs the poc binary and asserts following 2 conditions.
     *  1. There are no security crashes in the binary.
     *  2. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param binaryName name of the binary
     * @param arguments arguments for running the binary
     * @param inputFiles files required as input
     * @param inputFilesDestination destination directory to which input files are
     *        pushed
     * @param device device to be run on
     */
    public static void runPocAssertNoCrashesNotVulnerable(String binaryName, String arguments,
            String inputFiles[], String inputFilesDestination, ITestDevice device)
            throws Exception {
        runPocAssertNoCrashesNotVulnerable(binaryName, arguments, inputFiles, inputFilesDestination,
                device, null);
    }

    /**
     * Runs the poc binary and asserts following 3 conditions.
     *  1. There are no security crashes in the binary.
     *  2. There are no security crashes that match the expected process pattern.
     *  3. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param binaryName name of the binary
     * @param arguments arguments for running the binary
     * @param inputFiles files required as input
     * @param inputFilesDestination destination directory to which input files are
     *        pushed
     * @param device device to be run on
     * @param processPatternStrings a Pattern string to match the crash tombstone
     *        process
     */
    public static void runPocAssertNoCrashesNotVulnerable(String binaryName, String arguments,
            String inputFiles[], String inputFilesDestination, ITestDevice device,
            String processPatternStrings[]) throws Exception {
        runPocAssertNoCrashesNotVulnerable(binaryName, arguments, null,
                inputFiles, inputFilesDestination, device, processPatternStrings);
    }

    /**
     * Runs the poc binary and asserts following 3 conditions.
     *  1. There are no security crashes in the binary.
     *  2. There are no security crashes that match the expected process pattern.
     *  3. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param binaryName name of the binary
     * @param arguments arguments for running the binary
     * @param envVars run the poc with environment variables
     * @param inputFiles files required as input
     * @param inputFilesDestination destination directory to which input files are
     *        pushed
     * @param device device to be run on
     * @param processPatternStrings a Pattern string (other than binary name) to match the crash
     *        tombstone process
     */
    public static void runPocAssertNoCrashesNotVulnerable(
            String binaryName, String arguments, Map<String, String> envVars,
            String inputFiles[], String inputFilesDestination, ITestDevice device,
            String... processPatternStrings) throws Exception {
        pocConfig testConfig = new pocConfig(binaryName, device);
        testConfig.arguments = arguments;
        testConfig.envVars = envVars;

        if (inputFiles != null) {
            testConfig.inputFiles = Arrays.asList(inputFiles);
            testConfig.inputFilesDestination = inputFilesDestination;
        }

        List<String> processPatternList = new ArrayList<>();
        if (processPatternStrings != null) {
            processPatternList.addAll(Arrays.asList(processPatternStrings));
        }
        processPatternList.add(binaryName);
        String[] processPatternStringsWithSelf = new String[processPatternList.size()];
        processPatternList.toArray(processPatternStringsWithSelf);
        testConfig.config =
                new CrashUtils.Config().setProcessPatterns(processPatternStringsWithSelf);

        runPocAssertNoCrashesNotVulnerable(testConfig);
    }

    /**
     * Runs the poc binary and asserts following 3 conditions.
     *  1. There are no security crashes in the binary.
     *  2. There are no security crashes that match the expected process pattern.
     *  3. The exit status isn't 113 (Code 113 is used to indicate the vulnerability condition).
     *
     * @param testConfig test configuration
     */
    public static void runPocAssertNoCrashesNotVulnerable(pocConfig testConfig) throws Exception {
        String[] inputFiles = null;
        if(!testConfig.inputFiles.isEmpty()) {
            inputFiles = testConfig.inputFiles.toArray(new String[testConfig.inputFiles.size()]);
            pushResources(inputFiles, testConfig.inputFilesDestination, testConfig.device);
        }
        runCommandLine(""logcat -c"", testConfig.device);
        try {
            runPocAssertExitStatusNotVulnerable(testConfig.binaryName, testConfig.arguments,
                    testConfig.envVars, testConfig.device, TIMEOUT_SEC);
        } catch (IllegalArgumentException e) {
            /*
             * Since 'runPocGetExitStatus' method raises IllegalArgumentException upon
             * hang/timeout, catching the exception here and ignoring it. Hangs are of
             * Moderate severity and hence patches may not be ported. This piece of code can
             * be removed once 'runPocGetExitStatus' is updated to handle hangs.
             */
            CLog.w(""Ignoring IllegalArgumentException: "" + e);
        } finally {
            if (!testConfig.inputFiles.isEmpty()) {
                removeResources(inputFiles, testConfig.inputFilesDestination, testConfig.device);
            }
        }
        if(testConfig.checkCrash) {
            if (testConfig.config == null) {
                testConfig.config = new CrashUtils.Config();
            }
            assertNoCrashes(testConfig.device, testConfig.config);
        }
    }

    /**
     * Dumps logcat and asserts that there are no security crashes that match the expected process.
     * By default, checks min crash addresses
     * pattern. Ensure that adb logcat -c is called beforehand.
     * @param device device to be ran on
     * @param processPatternStrings a Pattern string to match the crash tombstone process
     */
    public static void assertNoCrashes(ITestDevice device, String... processPatternStrings)
            throws Exception {
        assertNoCrashes(device, new CrashUtils.Config().setProcessPatterns(processPatternStrings));
    }

    /**
     * Dumps logcat and asserts that there are no security crashes that match the expected process
     * pattern. Ensure that adb logcat -c is called beforehand.
     * @param device device to be ran on
     * @param config a crash parser configuration
     */
    public static void assertNoCrashes(ITestDevice device,
            CrashUtils.Config config) throws Exception {
        String logcat = AdbUtils.runCommandLine(""logcat -d *:S DEBUG:V"", device);

        JSONArray crashes = CrashUtils.addAllCrashes(logcat, new JSONArray());
        JSONArray securityCrashes = CrashUtils.matchSecurityCrashes(crashes, config);

        MetricsReportLog reportLog = SecurityTestCase.buildMetricsReportLog(device);
        reportLog.addValue(""all_crashes"", crashes.toString(), ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValue(""security_crashes"", securityCrashes.toString(),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        if (securityCrashes.length() == 0) {
            return; // no security crashes detected
        }

        StringBuilder error = new StringBuilder();
        error.append(""Security crash detected:\n"");
        error.append(""Process patterns:"");
        for (Pattern pattern : config.getProcessPatterns()) {
            error.append(String.format("" '%s'"", pattern.toString()));
        }
        error.append(""\nCrashes:\n"");
        for (int i = 0; i < crashes.length(); i++) {
            try {
                JSONObject crash = crashes.getJSONObject(i);
                error.append(String.format(""%s\n"", crash));
            } catch (JSONException e) {}
        }
        fail(error.toString());
    }

    public static void assumeHasNfc(ITestDevice device) throws DeviceNotAvailableException {
        assumeTrue(""nfc not available on device"", device.hasFeature(""android.hardware.nfc""));
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2021"	"testPocCVE_2019_2021"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2021.java"	""	"@AsbSecurityTest(cveBugId = 120428041)
    public void testPocCVE_2019_2021() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2021"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testProvisioningNotAllowedWithDeviceOwner"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testProvisioningNotAllowedWithDeviceOwner() throws Exception {
        assertProvisionManagedProfileNotAllowed(COMP_DPC_PKG);
    }

    /**
     * Both device owner and profile are the same package ({@link #COMP_DPC_PKG}), as setup
     * by createAndManagedUser.
     */
    @FlakyTest"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testBindDeviceAdminServiceAsUser_secondaryUser"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testBindDeviceAdminServiceAsUser_secondaryUser() throws Exception {
        assumeCanCreateAdditionalUsers(1);

        int secondaryUserId = setupManagedSecondaryUser();

        installAppAsUser(COMP_DPC_APK2, mPrimaryUserId);
        installAppAsUser(COMP_DPC_APK2, secondaryUserId);

        // Shouldn't be possible to bind to each other, as they are not affiliated.
        verifyBindDeviceAdminServiceAsUserFails(secondaryUserId);

        // Set the same affiliation ids, and check that DO and PO can now bind to each other.
        setSameAffiliationId(secondaryUserId);
        verifyBindDeviceAdminServiceAsUser(secondaryUserId);
    }

    @FlakyTest(bugId = 141161038)"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testNetworkAndSecurityLoggingAvailableIfAffiliated"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testNetworkAndSecurityLoggingAvailableIfAffiliated() throws Exception {
        assumeCanCreateAdditionalUsers(2);

        // If secondary users are allowed, create an affiliated one, to check that this still
        // works if having both an affiliated user and an affiliated managed profile.
        final int secondaryUserId = setupManagedSecondaryUser();

        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testEnablingNetworkAndSecurityLogging"",
                mPrimaryUserId);
        try {
            // No affiliation ids have been set on the profile, the features shouldn't be available.
            runDeviceTestsAsUser(
                    COMP_DPC_PKG,
                    DEVICE_WIDE_LOGGING_TEST,
                    ""testRetrievingLogsThrowsSecurityException"",
                    mPrimaryUserId);

            // Affiliate the DO and the secondary user.
            setSameAffiliationId(secondaryUserId);
            runDeviceTestsAsUser(
                    COMP_DPC_PKG,
                    DEVICE_WIDE_LOGGING_TEST,
                    ""testRetrievingLogsDoesNotThrowException"",
                    mPrimaryUserId);

            setDifferentAffiliationId(secondaryUserId);
            runDeviceTestsAsUser(
                    COMP_DPC_PKG,
                    DEVICE_WIDE_LOGGING_TEST,
                    ""testRetrievingLogsThrowsSecurityException"",
                    mPrimaryUserId);
        } finally {
            runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testDisablingNetworkAndSecurityLogging"",
                mPrimaryUserId);
        }
    }

    @FlakyTest"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testRequestBugreportAvailableIfAffiliated"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testRequestBugreportAvailableIfAffiliated() throws Exception {
        assumeCanCreateAdditionalUsers(2);

        final int secondaryUserId = setupManagedSecondaryUser();

        // No affiliation ids have been set on the secondary user, the feature shouldn't be
        // available.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testRequestBugreportThrowsSecurityException"",
                mPrimaryUserId);

        // Affiliate the DO and the secondary user.
        setSameAffiliationId(secondaryUserId);
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testRequestBugreportDoesNotThrowException"",
                mPrimaryUserId);

        setDifferentAffiliationId(secondaryUserId, COMP_DPC_PKG);
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testRequestBugreportThrowsSecurityException"",
                mPrimaryUserId);
    }

    private void verifyBindDeviceAdminServiceAsUser(int profileOwnerUserId) throws Exception {
        // Installing a non managing app (neither device owner nor profile owner).
        installAppAsUser(COMP_DPC_APK2, mPrimaryUserId);
        installAppAsUser(COMP_DPC_APK2, profileOwnerUserId);

        // Testing device owner -> profile owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_GOOD_SETUP_TEST,
                mPrimaryUserId);
        // Testing profile owner -> device owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_GOOD_SETUP_TEST,
                profileOwnerUserId);
    }

    private void verifyBindDeviceAdminServiceAsUserFails(int profileOwnerUserId) throws Exception {
        // Installing a non managing app (neither device owner nor profile owner).
        installAppAsUser(COMP_DPC_APK2, mPrimaryUserId);
        installAppAsUser(COMP_DPC_APK2, profileOwnerUserId);

        // Testing device owner -> profile owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_FAILS_TEST,
                mPrimaryUserId);
        // Testing profile owner -> device owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_FAILS_TEST,
                profileOwnerUserId);
    }

    private void setSameAffiliationId(
            int profileOwnerUserId, String profileOwnerPackage) throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                AFFILIATION_TEST,
                ""testSetAffiliationId1"",
                mPrimaryUserId);
        runDeviceTestsAsUser(
                profileOwnerPackage,
                AFFILIATION_TEST,
                ""testSetAffiliationId1"",
                profileOwnerUserId);
    }

    private void setSameAffiliationId(int profileOwnerUserId) throws Exception {
        setSameAffiliationId(profileOwnerUserId, COMP_DPC_PKG);
    }

    private void setDifferentAffiliationId(
            int profileOwnerUserId, String profileOwnerPackage) throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                AFFILIATION_TEST,
                ""testSetAffiliationId1"",
                mPrimaryUserId);
        runDeviceTestsAsUser(
                profileOwnerPackage,
                AFFILIATION_TEST,
                ""testSetAffiliationId2"",
                profileOwnerUserId);
    }

    private void setDifferentAffiliationId(int profileOwnerUserId) throws Exception {
        setDifferentAffiliationId(profileOwnerUserId, COMP_DPC_PKG);
    }

    private void assertProvisionManagedProfileNotAllowed(String packageName) throws Exception {
        runDeviceTestsAsUser(
                packageName,
                MANAGEMENT_TEST,
                ""testProvisionManagedProfileNotAllowed"",
                mPrimaryUserId);
    }

    /** Returns the user id of the newly created managed profile */
    private int setupManagedProfile(String apkName, String packageName,
            String adminReceiverClassName) throws Exception {
        final int userId = createManagedProfile(mPrimaryUserId);
        installAppAsUser(apkName, userId);
        setProfileOwnerOrFail(adminReceiverClassName, userId);
        startUserAndWait(userId);
        runDeviceTestsAsUser(
                packageName,
                MANAGEMENT_TEST,
                ""testIsManagedProfile"",
                userId);
        return userId;
    }

    /** Returns the user id of the newly created secondary user */
    private int setupManagedSecondaryUser() throws Exception {
        assertTrue(""Cannot create 1 additional user"", canCreateAdditionalUsers(1));

        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGEMENT_TEST,
                ""testCreateSecondaryUser"",
                mPrimaryUserId);
        List<Integer> newUsers = getUsersCreatedByTests();
        assertEquals(1, newUsers.size());
        int secondaryUserId = newUsers.get(0);
        getDevice().startUser(secondaryUserId, /* waitFlag= */ true);
        return secondaryUserId;
    }

    /** Returns the user id of the newly created secondary user */
    private int provisionCorpOwnedManagedProfile() throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGED_PROFILE_PROVISIONING_TEST,
                ""testProvisioningCorpOwnedManagedProfile"",
                mPrimaryUserId);
        return getFirstManagedProfileUserId();
    }

    /**
     * Add {@link android.os.UserManager#DISALLOW_REMOVE_USER}.
     */
    private void addDisallowRemoveUserRestriction() throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                USER_RESTRICTION_TEST,
                ""testAddDisallowRemoveUserRestriction"",
                mPrimaryUserId);
    }

    /**
     * Clear {@link android.os.UserManager#DISALLOW_REMOVE_USER}.
     */
    private void clearDisallowRemoveUserRestriction() throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                USER_RESTRICTION_TEST,
                ""testClearDisallowRemoveUserRestriction"",
                mPrimaryUserId);
    }

    private void assertOtherProfilesEqualsBindTargetUsers(int otherProfileUserId) throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGEMENT_TEST,
                ""testOtherProfilesEqualsBindTargetUsers"",
                mPrimaryUserId);
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGEMENT_TEST,
                ""testOtherProfilesEqualsBindTargetUsers"",
                otherProfileUserId);
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.SinglePaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/SinglePaymentEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

@TargetApi(19)
public class SinglePaymentEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setupServices(this, PaymentService1.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        // Verify HCE service 1 is the default
        if (makePaymentDefault(PaymentService1.COMPONENT,
                R.string.nfc_hce_change_preinstalled_wallet)) {
            // Wait for callback
        } else {
         NfcDialogs.createHceTapReaderDialog(this, null).show();
        }
    }

    @Override
    void onPaymentDefaultResult(ComponentName component, boolean success) {
        if (success) {
         NfcDialogs.createHceTapReaderDialog(this, null).show();
        }
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                PaymentService1.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                PaymentService1.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_single_payment_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(PaymentService1.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.KeyManagementTest"	"testRevokeKeyPairFromApp_keyNotUsable"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/KeyManagementTest.java"	""	"public void testRevokeKeyPairFromApp_keyNotUsable() throws Exception {
        mDevicePolicyManager.installKeyPair(getWho(), mFakePrivKey, new Certificate[] {mFakeCert},
                TEST_ALIAS, /* requestAccess=*/ true);
        // Key is requested from KeyChain prior to revoking the grant.
        final PrivateKey key = KeyChain.getPrivateKey(mContext, TEST_ALIAS);
        // Ensure the key is usable prior to being revoked.
        signDataWithKey(""SHA256withRSA"", key);
        mDevicePolicyManager.revokeKeyPairFromApp(getWho(), TEST_ALIAS, getWho().getPackageName());

        // Key shouldn't be valid after the grant is revoked.
        assertThrows(InvalidKeyException.class, () -> signDataWithKey(""SHA256withRSA"", key));
    }

    private void assertGranted(String alias, boolean expected)
            throws InterruptedException, KeyChainException {
        boolean granted = (KeyChain.getPrivateKey(mActivity, alias) != null);
        assertWithMessage(""Grant for alias: \"""" + alias + ""\"""").that(granted).isEqualTo(expected);
    }

    private static PrivateKey getPrivateKey(final byte[] key, String type)
            throws NoSuchAlgorithmException, InvalidKeySpecException {
        return KeyFactory.getInstance(type).generatePrivate(
                new PKCS8EncodedKeySpec(key));
    }

    private static Certificate getCertificate(byte[] cert) throws CertificateException {
        return CertificateFactory.getInstance(""X.509"").generateCertificate(
                new ByteArrayInputStream(cert));
    }

    private Collection<Certificate> loadCertificatesFromAsset(String assetName) {
        try {
            final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            AssetManager am = mActivity.getAssets();
            InputStream is = am.open(assetName);
            return (Collection<Certificate>) certFactory.generateCertificates(is);
        } catch (IOException | CertificateException e) {
            e.printStackTrace();
        }
        return null;
    }

    private PrivateKey loadPrivateKeyFromAsset(String assetName) {
        try {
            AssetManager am = mActivity.getAssets();
            InputStream is = am.open(assetName);
            ByteArrayOutputStream output = new ByteArrayOutputStream();
            int length;
            byte[] buffer = new byte[4096];
            while ((length = is.read(buffer, 0, buffer.length)) != -1) {
              output.write(buffer, 0, length);
            }
            return getPrivateKey(output.toByteArray(), ""RSA"");
        } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }

    private class KeyChainAliasFuture implements KeyChainAliasCallback {
        private final CountDownLatch mLatch = new CountDownLatch(1);
        private String mChosenAlias = null;

        @Override
        public void alias(final String chosenAlias) {
            mChosenAlias = chosenAlias;
            mLatch.countDown();
        }

        public KeyChainAliasFuture(String alias)
                throws UnsupportedEncodingException {
            /* Pass the alias as a GET to an imaginary server instead of explicitly asking for it,
             * to make sure the DPC actually has to do some work to grant the cert.
             */
            final Uri uri =
                    Uri.parse(""https://example.org/?alias="" + URLEncoder.encode(alias, ""UTF-8""));
            KeyChain.choosePrivateKeyAlias(mActivity, this,
                    null /* keyTypes */, null /* issuers */, uri, null /* alias */);
        }

        public String get() throws InterruptedException {
            assertWithMessage(""Chooser timeout"")
                    .that(mLatch.await(KEYCHAIN_TIMEOUT_MINS, TimeUnit.MINUTES))
                    .isTrue();
            return mChosenAlias;
        }
    }

    private ComponentName getWho() {
        return ADMIN_RECEIVER_COMPONENT;
    }

    boolean hasStrongBox() {
        return mActivity.getPackageManager()
            .hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE);
    }

    boolean isUniqueDeviceAttestationSupported() {
        return mDevicePolicyManager.isUniqueDeviceAttestationSupported();
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.EnrollmentSpecificIdTest"	"testCorrectCalculationOfEsid"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/EnrollmentSpecificIdTest.java"	""	"public void testCorrectCalculationOfEsid() {
        mUiAutomation.adoptShellPermissionIdentity(PERMISSIONS_TO_ADOPT);
        mDevicePolicyManager.setOrganizationId(ORGANIZATION_ID);
        final String esidFromDpm = mDevicePolicyManager.getEnrollmentSpecificId();
        final String calculatedEsid = calculateEsid(ADMIN_RECEIVER_COMPONENT.getPackageName(),
                ORGANIZATION_ID);
        assertThat(esidFromDpm).isEqualTo(calculatedEsid);
    }

    private String calculateEsid(String profileOwnerPackage, String enterpriseIdString) {
        TelephonyManager telephonyService = mContext.getSystemService(TelephonyManager.class);
        assertThat(telephonyService).isNotNull();

        WifiManager wifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        final byte[] serialNumber = getPaddedHardwareIdentifier(Build.getSerial()).getBytes();
        final byte[] imei = getPaddedHardwareIdentifier(telephonyService.getImei(0)).getBytes();
        final byte[] meid = getPaddedHardwareIdentifier(telephonyService.getMeid(0)).getBytes();

        final byte[] macAddress;
        final String[] macAddresses = wifiManager.getFactoryMacAddresses();
        if (macAddresses == null || macAddresses.length == 0) {
            macAddress = """".getBytes();
        } else {
            macAddress = macAddresses[0].getBytes();
        }

        final int totalIdentifiersLength = serialNumber.length + imei.length + meid.length
                + macAddress.length;
        final ByteBuffer fixedIdentifiers = ByteBuffer.allocate(totalIdentifiersLength);
        fixedIdentifiers.put(serialNumber);
        fixedIdentifiers.put(imei);
        fixedIdentifiers.put(meid);
        fixedIdentifiers.put(macAddress);

        final byte[] dpcPackage = getPaddedProfileOwnerName(profileOwnerPackage).getBytes();
        final byte[] enterpriseId = getPaddedEnterpriseId(enterpriseIdString).getBytes();
        final ByteBuffer info = ByteBuffer.allocate(dpcPackage.length + enterpriseId.length);
        info.put(dpcPackage);
        info.put(enterpriseId);
        final byte[] esidBytes = computeHkdf(""HMACSHA256"", fixedIdentifiers.array(), null,
                info.array(), 16);
        ByteBuffer esidByteBuffer = ByteBuffer.wrap(esidBytes);

        return encodeBase32(esidByteBuffer.getLong()) + encodeBase32(esidByteBuffer.getLong());
    }

    private static String getPaddedHardwareIdentifier(String hardwareIdentifier) {
        if (hardwareIdentifier == null) {
            hardwareIdentifier = """";
        }
        return String.format(""%16s"", hardwareIdentifier);
    }

    private static String getPaddedProfileOwnerName(String profileOwnerPackage) {
        return String.format(""%64s"", profileOwnerPackage);
    }

    private static String getPaddedEnterpriseId(String enterpriseId) {
        return String.format(""%64s"", enterpriseId);
    }

    // Copied from android.security.identity.Util, here to make sure Enterprise-Specific ID is
    // calculated according to spec.
    @NonNull
    private static byte[] computeHkdf(
            @NonNull String macAlgorithm, @NonNull final byte[] ikm, @NonNull final byte[] salt,
            @NonNull final byte[] info, int size) {
        Mac mac = null;
        try {
            mac = Mac.getInstance(macAlgorithm);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(""No such algorithm: "" + macAlgorithm, e);
        }
        if (size > 255 * mac.getMacLength()) {
            throw new RuntimeException(""size too large"");
        }
        try {
            if (salt == null || salt.length == 0) {
                // According to RFC 5869, Section 2.2 the salt is optional. If no salt is provided
                // then HKDF uses a salt that is an array of zeros of the same length as the hash
                // digest.
                mac.init(new SecretKeySpec(new byte[mac.getMacLength()], macAlgorithm));
            } else {
                mac.init(new SecretKeySpec(salt, macAlgorithm));
            }
            byte[] prk = mac.doFinal(ikm);
            byte[] result = new byte[size];
            int ctr = 1;
            int pos = 0;
            mac.init(new SecretKeySpec(prk, macAlgorithm));
            byte[] digest = new byte[0];
            while (true) {
                mac.update(digest);
                mac.update(info);
                mac.update((byte) ctr);
                digest = mac.doFinal();
                if (pos + digest.length < size) {
                    System.arraycopy(digest, 0, result, pos, digest.length);
                    pos += digest.length;
                    ctr++;
                } else {
                    System.arraycopy(digest, 0, result, pos, size - pos);
                    break;
                }
            }
            return result;
        } catch (InvalidKeyException e) {
            throw new RuntimeException(""Error MACing"", e);
        }
    }

    private static final char[] ENCODE = {
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
            'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
            'Y', 'Z', '2', '3', '4', '5', '6', '7',
    };

    private static final char SEPARATOR = '-';
    private static final int LONG_SIZE = 13;
    private static final int GROUP_SIZE = 4;

    private static String encodeBase32(long input) {
        final char[] alphabet = ENCODE;

        /*
         * Make a character array with room for the separators between each
         * group.
         */
        final char[] encoded = new char[LONG_SIZE + (LONG_SIZE / GROUP_SIZE)];

        int index = encoded.length;
        for (int i = 0; i < LONG_SIZE; i++) {
            /*
             * Make sure we don't put a separator at the beginning. Since we're
             * building from the rear of the array, we use (LONG_SIZE %
             * GROUP_SIZE) to make the odd-size group appear at the end instead
             * of the beginning.
             */
            if (i > 0 && (i % GROUP_SIZE) == (LONG_SIZE % GROUP_SIZE)) {
                encoded[--index] = SEPARATOR;
            }

            /*
             * Extract 5 bits of data, then shift it out.
             */
            final int group = (int) (input & 0x1F);
            input >>>= 5;

            encoded[--index] = alphabet[group];
        }

        return String.valueOf(encoded);
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.IntentFiltersTestHelper"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/IntentFiltersTestHelper.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.app.Activity;
import android.app.admin.DevicePolicyManager;
import android.app.DownloadManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.media.audiofx.AudioEffect;
import android.net.Uri;
import android.nfc.cardemulation.CardEmulation;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.UserHandle;
import android.os.UserManager;
import android.provider.AlarmClock;
import android.provider.CalendarContract.Events;
import android.provider.MediaStore;
import android.provider.Settings;
import android.speech.RecognizerIntent;
import android.util.Log;
import android.widget.Toast;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

/**
 * Helper class for testing if the required cross profile intent filters are set during the
 * managed provisioning.
 */
public class IntentFiltersTestHelper {

    private static final String TAG = ""IntentFiltersTestHelper"";

    // These are the intents which can be forwarded to the managed profile.
    private static final ArrayList<Intent> forwardedIntentsFromPrimary =
            new ArrayList<>(Arrays.asList(
                new Intent(Intent.ACTION_SEND).setType(""*/*""),
                new Intent(Intent.ACTION_SEND_MULTIPLE).setType(""*/*"")
            ));

    // These are the intents which can be forwarded to the primary profile.
    private static final ArrayList<Intent> forwardedIntentsFromManaged =
            new ArrayList<>(Arrays.asList(
                new Intent(AlarmClock.ACTION_SET_ALARM),
                new Intent(AlarmClock.ACTION_SET_TIMER),
                new Intent(AlarmClock.ACTION_SHOW_ALARMS),
                new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS),
                new Intent(Settings.ACTION_CAPTIONING_SETTINGS),
                new Intent(Settings.ACTION_DATE_SETTINGS),
                new Intent(Settings.ACTION_DEVICE_INFO_SETTINGS),
                new Intent(Settings.ACTION_DISPLAY_SETTINGS),
                new Intent(Settings.ACTION_LOCALE_SETTINGS),
                new Intent(Settings.ACTION_PRIVACY_SETTINGS),
                new Intent(Settings.ACTION_SETTINGS),
                new Intent(Settings.ACTION_WIRELESS_SETTINGS),
                new Intent(""android.net.vpn.SETTINGS""),
                new Intent(Settings.ACTION_VPN_SETTINGS),
                new Intent(Settings.ACTION_BATTERY_SAVER_SETTINGS),
                new Intent(""android.settings.LICENSE""),
                new Intent(""android.settings.NOTIFICATION_SETTINGS""),
                new Intent(""android.settings.ZEN_MODE_SETTINGS""),
                new Intent(""com.android.settings.ACCESSIBILITY_COLOR_SPACE_SETTINGS""),
                new Intent(""com.android.settings.TTS_SETTINGS""),
                new Intent(Settings.ACTION_INTERNAL_STORAGE_SETTINGS),
                new Intent(Intent.ACTION_GET_CONTENT).setType(""*/*"").addCategory(
                        Intent.CATEGORY_OPENABLE),
                new Intent(Intent.ACTION_OPEN_DOCUMENT).setType(""*/*"").addCategory(
                        Intent.CATEGORY_OPENABLE)
            ));

    // These are the intents which can either be handled directly in the managed profile,
    // or be forwarded to the primary profile.
    private static final ArrayList<Intent> forwardingOptionalIntentsFromManaged =
            new ArrayList<>(Arrays.asList(
                new Intent(Settings.ACTION_SYNC_SETTINGS),
                new Intent(Settings.ACTION_ADD_ACCOUNT),
                new Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS),
                new Intent(Settings.ACTION_MANAGE_ALL_APPLICATIONS_SETTINGS),
                new Intent(Settings.ACTION_APPLICATION_SETTINGS),
                new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD),
                new Intent(""android.settings.ACCOUNT_SYNC_SETTINGS"")
            ));

    // These are the intents which cannot be forwarded to the primary profile.
    private static final ArrayList<Intent> notForwardedIntentsFromManaged =
            new ArrayList<>(Arrays.asList(
                new Intent(Intent.ACTION_INSERT).setData(
                        Uri.parse(""content://browser/bookmarks"")),
                new Intent(Intent.ACTION_VIEW).setData(
                        Uri.parse(""http://www.example.com"")).addCategory(
                        Intent.CATEGORY_BROWSABLE),
                new Intent(Intent.ACTION_SENDTO).setData(
                        Uri.parse(""mailto:user@example.com"")),
                new Intent(Intent.ACTION_VIEW).setData(
                        Uri.parse(""mailto:user@example.com"")).addCategory(
                        Intent.CATEGORY_BROWSABLE),
                new Intent(Intent.ACTION_VIEW).setData(
                        Uri.parse(""geo:0,0?q=BuckinghamPalace"")),
                new Intent(Intent.ACTION_VIEW).setData(
                        Uri.parse(""http://example.com/oceans.mp4"")).setType(""video/mp4""),
                new Intent(Intent.ACTION_VIEW).setData(
                        Uri.parse(""http://www.example.com/horse.mp3"")).setType(""audio/*""),
                new Intent(MediaStore.INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH),
                new Intent(Intent.ACTION_VIEW).setData(
                        Uri.parse(""market://details?id=com.android.chrome"")).addCategory(
                        Intent.CATEGORY_BROWSABLE),
                new Intent(Intent.ACTION_WEB_SEARCH),
                new Intent(Settings.ACTION_SEARCH_SETTINGS),
                new Intent(Intent.ACTION_MANAGE_NETWORK_USAGE),
                new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).setData(
                        Uri.parse(""package:com.android.chrome"")),
                new Intent(Intent.ACTION_INSERT).setData(Events.CONTENT_URI),
                new Intent(DownloadManager.ACTION_VIEW_DOWNLOADS)
            ));

    // This flag specifies we are dealing with intents fired from the primary profile.
    public static final int FLAG_INTENTS_FROM_PRIMARY = 1;
    // This flag specifies we are dealing with intents fired from the managed profile.
    public static final int FLAG_INTENTS_FROM_MANAGED = 2;

    private Context mContext;

    IntentFiltersTestHelper(Context context) {
        mContext = context;

        addIntentsThatDependOnDeviceConfigs();
        addIntentsThatDependOnDeviceFeatures();
    }

    private void addIntentsThatDependOnDeviceConfigs() {
        if (UserManager.supportsMultipleUsers()) {
            forwardedIntentsFromManaged.add(
                    new Intent(""android.settings.USER_SETTINGS""));
        }
    }

    private void addIntentsThatDependOnDeviceFeatures() {
        PackageManager pm = mContext.getPackageManager();

        if (pm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)
                && pm.hasSystemFeature(PackageManager.FEATURE_CONNECTION_SERVICE)) {
            forwardedIntentsFromManaged.addAll(Arrays.asList(
                    new Intent(""android.intent.action.CALL_EMERGENCY"").setData(
                            Uri.parse(""tel:123"")),
                    new Intent(""android.intent.action.CALL_PRIVILEGED"").setData(
                            Uri.parse(""tel:123"")),
                    new Intent(Intent.ACTION_VIEW).setData(Uri.parse(""tel:123"")).addCategory(
                            Intent.CATEGORY_BROWSABLE),
                    new Intent(Settings.ACTION_NETWORK_OPERATOR_SETTINGS),
                    new Intent(Settings.ACTION_DATA_ROAMING_SETTINGS),
                    new Intent(Intent.ACTION_SENDTO).setData(Uri.parse(""sms:07700900100"")),
                    new Intent(Intent.ACTION_SENDTO).setData(Uri.parse(""smsto:07700900100"")),
                    new Intent(Intent.ACTION_SENDTO).setData(Uri.parse(""mms:07700900100"")),
                    new Intent(Intent.ACTION_SENDTO).setData(Uri.parse(""mmsto:07700900100"")),
                    new Intent(Intent.ACTION_VIEW).setData(
                            Uri.parse(""sms:07700900100?body=Hello%20world"")).addCategory(
                            Intent.CATEGORY_BROWSABLE),
                    new Intent(Intent.ACTION_VIEW).setData(
                            Uri.parse(""smsto:07700900100?body=Hello%20world"")).addCategory(
                            Intent.CATEGORY_BROWSABLE),
                    new Intent(Intent.ACTION_VIEW).setData(
                            Uri.parse(""mms:07700900100?body=Hello%20world"")).addCategory(
                            Intent.CATEGORY_BROWSABLE),
                    new Intent(Intent.ACTION_VIEW).setData(
                            Uri.parse(""mmsto:07700900100?body=Hello%20world"")).addCategory(
                            Intent.CATEGORY_BROWSABLE),
                    new Intent(Settings.ACTION_APN_SETTINGS)));
            notForwardedIntentsFromManaged.addAll(Arrays.asList(
                    new Intent(Intent.ACTION_DIAL).setData(Uri.parse(""tel:123"")),
                    new Intent(Intent.ACTION_CALL).setData(Uri.parse(""tel:123""))));
        }

        if (pm.hasSystemFeature(PackageManager.FEATURE_NFC)) {
            forwardedIntentsFromManaged.addAll(Arrays.asList(
                    new Intent(Settings.ACTION_NFC_SETTINGS),
                    new Intent(Settings.ACTION_NFCSHARING_SETTINGS)));
        }

        if (pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
            forwardedIntentsFromManaged.addAll(Arrays.asList(
                    new Intent(CardEmulation.ACTION_CHANGE_DEFAULT),
                    new Intent(Settings.ACTION_NFC_PAYMENT_SETTINGS)));
        }

        if (pm.hasSystemFeature(PackageManager.FEATURE_CAMERA)) {
            forwardedIntentsFromManaged.addAll(Arrays.asList(
                    new Intent(MediaStore.ACTION_IMAGE_CAPTURE),
                    new Intent(MediaStore.ACTION_VIDEO_CAPTURE),
                    new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA),
                    new Intent(MediaStore.INTENT_ACTION_VIDEO_CAMERA),
                    new Intent(MediaStore.ACTION_IMAGE_CAPTURE_SECURE),
                    new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE)));
        }

        final String state = Environment.getExternalStorageState();
        if (Environment.MEDIA_MOUNTED.equals(state)) {
            forwardedIntentsFromManaged.add(
                    new Intent(Settings.ACTION_MEMORY_CARD_SETTINGS));
        }

        if (pm.hasSystemFeature(PackageManager.FEATURE_WIFI)) {
            forwardedIntentsFromManaged.addAll(Arrays.asList(
                    new Intent(Settings.ACTION_WIFI_IP_SETTINGS),
                    new Intent(Settings.ACTION_WIFI_SETTINGS)));
        }

        if (pm.hasSystemFeature(PackageManager.FEATURE_MICROPHONE)) {
            forwardedIntentsFromManaged.addAll(Arrays.asList(
                    new Intent(MediaStore.Audio.Media.RECORD_SOUND_ACTION),
                    new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH)));
        }

        if (pm.hasSystemFeature(PackageManager.FEATURE_LOCATION)) {
            forwardingOptionalIntentsFromManaged.add(
                    new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS));
        }

        if (pm.hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT)) {
            forwardedIntentsFromManaged.addAll(Arrays.asList(
                    new Intent(Settings.ACTION_SOUND_SETTINGS),
                    new Intent(""android.settings.ACTION_OTHER_SOUND_SETTINGS"")));
            notForwardedIntentsFromManaged.add(
                    new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL));
        }

        if (pm.hasSystemFeature(PackageManager.FEATURE_HOME_SCREEN)) {
            forwardingOptionalIntentsFromManaged.add(
                    new Intent(Settings.ACTION_HOME_SETTINGS));
        }

        if (pm.hasSystemFeature(PackageManager.FEATURE_INPUT_METHODS)) {
            notForwardedIntentsFromManaged.addAll(Arrays.asList(
                    new Intent(Settings.ACTION_INPUT_METHOD_SETTINGS),
                    new Intent(Settings.ACTION_INPUT_METHOD_SUBTYPE_SETTINGS)));
        }

        if (!pm.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            forwardedIntentsFromManaged.add(
                    new Intent(Settings.ACTION_DREAM_SETTINGS));
        }

        if (!pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
            forwardedIntentsFromManaged.add(
                    new Intent(Settings.ACTION_AIRPLANE_MODE_SETTINGS));
        }

        if (pm.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            notForwardedIntentsFromManaged.add(
                    new Intent(Settings.ACTION_PRINT_SETTINGS));
        }

        if (Build.TYPE.equals(""user"")) {
            forwardedIntentsFromManaged.add(
                    new Intent(Settings.ACTION_APPLICATION_DEVELOPMENT_SETTINGS));
        }
    }

    public boolean checkCrossProfileIntentFilters(int flag) {
        boolean crossProfileIntentFiltersSet;
        if (flag == FLAG_INTENTS_FROM_PRIMARY) {
            crossProfileIntentFiltersSet = checkIntentForwardingFromPrimary();
        } else {
            crossProfileIntentFiltersSet =
                    checkIntentForwardingFromManaged() &&
                            checkIntentsWithOptionalForwardingFromManagedAreHandled();
        }
        return crossProfileIntentFiltersSet;
    }

    /**
     * Checks if required cross profile intent filters are set for the intents fired from the
     * primary profile.
     */
    private boolean checkIntentForwardingFromPrimary() {
        // Get the class name of the intentForwarderActivity in the primary profile by firing an
        // intent which we know will be forwarded from primary profile to managed profile.
        ActivityInfo forwarderActivityInfo =
                getForwarderActivityInfo(ByodHelperActivity.ACTION_QUERY_PROFILE_OWNER);
        if (forwarderActivityInfo == null) {
            return false;
        }

        // Check for intents which can be forwarded to the managed profile.
        return checkIntentForwarding(forwardedIntentsFromPrimary,
                forwarderActivityInfo, ""from primary profile should be forwarded to the "" +
                ""managed profile but is not."", true);
    }

    /**
     * Checks that the required intents either have cross profile intent filters set up, or are
     * handled directly in the managed profile.
     */
    private boolean checkIntentsWithOptionalForwardingFromManagedAreHandled() {
        for (Intent intent : forwardingOptionalIntentsFromManaged) {
            List<ResolveInfo> resolveInfoList =
                    mContext.getPackageManager().queryIntentActivities(intent,
                            PackageManager.MATCH_DEFAULT_ONLY);

            if (resolveInfoList.isEmpty()) {
                Log.e(TAG, intent + "" should be handled in or forwarded from the managed "" +
                        ""profile, but it is not."");
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if required cross profile intent filters are set for the intents fired from the
     * managed profile.
     */
    private boolean checkIntentForwardingFromManaged() {
        // Get the class name of the intentForwarderActivity in the managed profile by firing an
        // intent which we know will be forwarded from managed profile to primary profile.
        ActivityInfo forwarderActivityInfo =
                getForwarderActivityInfo(ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS);
        if (forwarderActivityInfo == null) {
            return false;
        }

        boolean success = true;
        // Check for intents which can be forwarded to the primary profile.
        success &= checkIntentForwarding(forwardedIntentsFromManaged,
                forwarderActivityInfo, "" from managed profile should be forwarded to the "" +
                ""primary profile but is not."", true);

        // Check for intents which cannot be forwarded to the primary profile.
        success &= checkIntentForwarding(notForwardedIntentsFromManaged,
                forwarderActivityInfo, ""from managed profile should not be forwarded to the "" +
                ""primary profile but it is."", false);
        return success;
    }

    /**
     * Checks if the intentForwarderActivity can handle the intent passed.
     */
    private boolean canForwarderActivityHandleIntent(Intent intent,
            ActivityInfo forwarderActivityInfo) {
        // Get all the activities which can handle the intent.
        List<ResolveInfo> resolveInfoList =
                mContext.getPackageManager().queryIntentActivities(intent,
                        PackageManager.MATCH_DEFAULT_ONLY);
        // Check if intentForwarderActivity is part of the list.
        for (ResolveInfo resolveInfo : resolveInfoList) {
            if (forwarderActivityInfo.packageName.equals(resolveInfo.activityInfo.packageName)
                    && forwarderActivityInfo.name.equals(resolveInfo.activityInfo.name)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the class name of the intentForwarderActivity.
     */
    private ActivityInfo getForwarderActivityInfo(String action) {
        Intent intent = new Intent(action);
        List<ResolveInfo> resolveInfoList =
                mContext.getPackageManager().queryIntentActivities(intent,
                        PackageManager.MATCH_DEFAULT_ONLY);
        if (resolveInfoList.isEmpty() || resolveInfoList.size() > 1) {
            Log.d(TAG, ""There should be exactly one activity IntentForwarder which "" +
                    ""handles the intent "" + intent);
            return null;
        }
        return resolveInfoList.get(0).activityInfo;
    }

    /**
     * Checks if the intents passed are correctly handled.
     * @return {@code false} if at least one intent is not handled correctly.
     */
    private boolean checkIntentForwarding(ArrayList<Intent> intentList,
            ActivityInfo expectedForwarderActivityInfo, String errorMessage, boolean canResolve) {
        boolean success = true;
        for (Intent intent : intentList) {
            if (canForwarderActivityHandleIntent(intent,
                    expectedForwarderActivityInfo) != canResolve) {
                Log.e(TAG, intent + "" "" + errorMessage);
                success = false;
            }
        }
        return success;
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2020_0037"	"testPocCVE_2020_0037"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2020_0037.java"	""	"@AsbSecurityTest(cveBugId = 143106535)
    public void testPocCVE_2020_0037() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2020-0037"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.ConflictingNonPaymentPrefixEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ConflictingNonPaymentPrefixEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.nfc.cardemulation.CardEmulation;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

import java.util.ArrayList;

public class ConflictingNonPaymentPrefixEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setupServices(this, PrefixTransportService1.COMPONENT, PrefixTransportService2.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        // Do dynamic AID registration
        ArrayList<String> service_aids = new ArrayList<String>();
        service_aids.add(HceUtils.TRANSPORT_PREFIX_AID + ""*"");
        mCardEmulation.registerAidsForService(PrefixTransportService1.COMPONENT, CardEmulation.CATEGORY_OTHER, service_aids);
        mCardEmulation.registerAidsForService(PrefixTransportService2.COMPONENT, CardEmulation.CATEGORY_OTHER, service_aids);
        NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_hce_other_conflicting_prefix_aids_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS, PrefixTransportService2.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES, PrefixTransportService2.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_other_conflicting_prefix_aids_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(PrefixTransportService2.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2206"	"testPocCVE_2019_2206"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2206.java"	""	"@AsbSecurityTest(cveBugId = 139188579)
    public void testPocCVE_2019_2206() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2206"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.NfcTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/NfcTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;
import com.android.cts.verifier.nfc.hce.HceEmulatorTestActivity;
import com.android.cts.verifier.nfc.hce.HceReaderTestActivity;
import com.android.cts.verifier.nfc.hcef.HceFEmulatorTestActivity;
import com.android.cts.verifier.nfc.hcef.HceFReaderTestActivity;
import com.android.cts.verifier.nfc.offhost.OffhostUiccEmulatorTestActivity;
import com.android.cts.verifier.nfc.offhost.OffhostUiccReaderTestActivity;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.nfc.tech.MifareUltralight;
import android.nfc.tech.Ndef;
import android.nfc.tech.TagTechnology;
import android.os.Build;
import android.os.Bundle;

/** Activity that lists all the NFC tests. */
public class NfcTestActivity extends PassFailButtons.TestListActivity {

    private static final String NDEF_ID =
            TagVerifierActivity.getTagTestId(Ndef.class);

    private static final String MIFARE_ULTRALIGHT_ID =
            TagVerifierActivity.getTagTestId(MifareUltralight.class);

    private static final String FEATURE_NFC_MIFARE = ""com.nxp.mifare"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.nfc_test, R.string.nfc_test_info, 0);
        setPassFailButtonClickListeners();

        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_BEAM)) {
            adapter.add(TestListItem.newCategory(this, R.string.nfc_pee_2_pee));
            adapter.add(TestListItem.newTest(this, R.string.nfc_ndef_push_sender,
                    NdefPushSenderActivity.class.getName(),
                    new Intent(this, NdefPushSenderActivity.class), null));
            adapter.add(TestListItem.newTest(this, R.string.nfc_ndef_push_receiver,
                    NdefPushReceiverActivity.class.getName(),
                    new Intent(this, NdefPushReceiverActivity.class), null));

            if (""MNC"".equals(Build.VERSION.CODENAME) || Build.VERSION.SDK_INT >= 23) {
                adapter.add(TestListItem.newTest(this, R.string.nfc_llcp_version_check,
                        LlcpVersionActivity.class.getName(),
                        new Intent(this, LlcpVersionActivity.class), null));
            }
        }

        adapter.add(TestListItem.newCategory(this, R.string.nfc_tag_verification));
        adapter.add(TestListItem.newTest(this, R.string.nfc_ndef,
                NDEF_ID, getTagIntent(Ndef.class), null));
        if (getPackageManager().hasSystemFeature(FEATURE_NFC_MIFARE)) {
            adapter.add(TestListItem.newTest(this, R.string.nfc_mifare_ultralight,
                    MIFARE_ULTRALIGHT_ID, getTagIntent(MifareUltralight.class), null));
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
            adapter.add(TestListItem.newCategory(this, R.string.nfc_hce));
            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_reader_tests,
                    HceReaderTestActivity.class.getName(),
                    new Intent(this, HceReaderTestActivity.class), null));
            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_emulator_tests,
                    HceEmulatorTestActivity.class.getName(),
                    new Intent(this, HceEmulatorTestActivity.class), null));
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION_NFCF)) {
            adapter.add(TestListItem.newCategory(this, R.string.nfc_hce_f));
            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_f_reader_tests,
                    HceFReaderTestActivity.class.getName(),
                    new Intent(this, HceFReaderTestActivity.class), null));
            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_f_emulator_tests,
                    HceFEmulatorTestActivity.class.getName(),
                    new Intent(this, HceFEmulatorTestActivity.class), null));
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_OFF_HOST_CARD_EMULATION_UICC)) {
            adapter.add(TestListItem.newCategory(this, R.string.nfc_offhost_uicc));
            adapter.add(TestListItem.newTest(this, R.string.nfc_offhost_uicc_reader_tests,
                    OffhostUiccReaderTestActivity.class.getName(),
                    new Intent(this, OffhostUiccReaderTestActivity.class), null));
            adapter.add(TestListItem.newTest(this, R.string.nfc_offhost_uicc_emulator_tests,
                    OffhostUiccEmulatorTestActivity.class.getName(),
                    new Intent(this, OffhostUiccEmulatorTestActivity.class), null));
        }

        setTestListAdapter(adapter);
    }

    private Intent getTagIntent(Class<? extends TagTechnology> primaryTech) {
        return new Intent(this, TagVerifierActivity.class)
                .putExtra(TagVerifierActivity.EXTRA_TECH, primaryTech.getName());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"communication.main.java.com.android.bedstead.remotedpc.managers.RemoteDevicePolicyManager"	"isUsingUnifiedPassword"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/communication/main/java/com/android/bedstead/remotedpc/managers/RemoteDevicePolicyManager.java"	""	"public void test/*
 *.
 */

package com.android.bedstead.remotedpc.managers;

import android.app.admin.DevicePolicyManager;
import android.app.admin.SystemUpdateInfo;
import android.content.ComponentName;
import android.content.IntentFilter;
import android.os.Bundle;

import androidx.annotation.NonNull;

import com.android.bedstead.remotedpc.processor.annotations.RemoteDpcAutomaticAdmin;
import com.android.bedstead.remotedpc.processor.annotations.RemoteDpcManager;

import java.util.List;
import java.util.Set;

/**
 * Wrapper of {@link DevicePolicyManager} methods for use with Remote DPC
 *
 * <p>Methods called on this interface will behave as if they were called directly by the
 * RemoteDPC instance. Return values and exceptions will behave as expected.
 *
 * <p>Methods on this interface must match exactly the methods declared by
 * {@link DevicePolicyManager}, or else must be identical to a method declared by
 * {@link DevicePolicyManager} except that it excludes a {@code ComponentName admin} first argument
 * and must be annotated {@link RemoteDpcAutomaticAdmin}.
 *
 * <p>When using {@link RemoteDpcAutomaticAdmin}, there must also exist an identical method on the
 * interface which includes the {@code ComponentName admin} argument. The RemoteDPC component name
 * will be automatically provided when the {@link RemoteDpcAutomaticAdmin} annotated method is
 * called.
 */
@RemoteDpcManager(managerClass = DevicePolicyManager.class)
public interface RemoteDevicePolicyManager {

    /** See {@link DevicePolicyManager#isUsingUnifiedPassword(ComponentName)}. */
    boolean isUsingUnifiedPassword(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#isUsingUnifiedPassword(ComponentName)}. */
    @RemoteDpcAutomaticAdmin boolean isUsingUnifiedPassword();

    /** See {@link DevicePolicyManager#getCurrentFailedPasswordAttempts()}. */
    int getCurrentFailedPasswordAttempts();

    /** See {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}. */
    void setLockTaskPackages(@NonNull ComponentName admin, @NonNull String[] packages);
    /** See {@link DevicePolicyManager#setLockTaskPackages(ComponentName, String[])}. */
    @RemoteDpcAutomaticAdmin void setLockTaskPackages(@NonNull String[] packages);

    /** See {@link DevicePolicyManager#getLockTaskPackages(ComponentName)}. */
    @NonNull String[] getLockTaskPackages(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#getLockTaskPackages(ComponentName)}. */
    @RemoteDpcAutomaticAdmin @NonNull String[] getLockTaskPackages();

    /** See {@link DevicePolicyManager#setLockTaskFeatures(ComponentName, int)}. */
    void setLockTaskFeatures(
            @NonNull ComponentName admin, int flags);
    /** See {@link DevicePolicyManager#setLockTaskFeatures(ComponentName, int)}. */
    @RemoteDpcAutomaticAdmin void setLockTaskFeatures(int flags);

    /** See {@link DevicePolicyManager#getLockTaskFeatures(ComponentName)}. */
    int getLockTaskFeatures(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#getLockTaskFeatures(ComponentName)}. */
    @RemoteDpcAutomaticAdmin int getLockTaskFeatures();


    /** See {@link DevicePolicyManager#setUserControlDisabledPackages(ComponentName, List)}. */
    void setUserControlDisabledPackages(
            @NonNull ComponentName admin, @NonNull List<String> packages);
    /** See {@link DevicePolicyManager#setUserControlDisabledPackages(ComponentName, List)}. */
    @RemoteDpcAutomaticAdmin void setUserControlDisabledPackages(@NonNull List<String> packages);

    /** See {@link DevicePolicyManager#getUserControlDisabledPackages(ComponentName)}. */
    @NonNull List<String> getUserControlDisabledPackages(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#getUserControlDisabledPackages(ComponentName)}. */
    @RemoteDpcAutomaticAdmin @NonNull List<String> getUserControlDisabledPackages();


    /** See {@link DevicePolicyManager#addUserRestriction(ComponentName, String)}. */
    void addUserRestriction(@NonNull ComponentName admin, String key);
    /** See {@link DevicePolicyManager#addUserRestriction(ComponentName, String)}. */
    @RemoteDpcAutomaticAdmin void addUserRestriction(String key);

    /** See {@link DevicePolicyManager#clearUserRestriction(ComponentName, String)}. */
    void clearUserRestriction(@NonNull ComponentName admin, String key);
    /** See {@link DevicePolicyManager#clearUserRestriction(ComponentName, String)}. */
    @RemoteDpcAutomaticAdmin void clearUserRestriction(String key);

    /** See {@link DevicePolicyManager#getUserRestrictions(ComponentName)}. */
    @NonNull Bundle getUserRestrictions(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#getUserRestrictions(ComponentName)}. */
    @RemoteDpcAutomaticAdmin @NonNull Bundle getUserRestrictions();

    /**
     * See {@link DevicePolicyManager#addCrossProfileIntentFilter(ComponentName, IntentFilter,
     * int)}.
     */
    void addCrossProfileIntentFilter(@NonNull ComponentName admin, @NonNull IntentFilter filter,
            int flags);
    /**
     * See {@link DevicePolicyManager#addCrossProfileIntentFilter(ComponentName, IntentFilter,
     * int)}.
     */
    @RemoteDpcAutomaticAdmin void addCrossProfileIntentFilter(@NonNull IntentFilter filter,
            int flags);

    /** See {@link DevicePolicyManager#clearCrossProfileIntentFilters(ComponentName)}. */
    void clearCrossProfileIntentFilters(@NonNull ComponentName admin);
    /** See {@link DevicePolicyManager#clearCrossProfileIntentFilters(ComponentName)}. */
    @RemoteDpcAutomaticAdmin void clearCrossProfileIntentFilters();

    /** See {@link DevicePolicyManager#setPreferentialNetworkServiceEnabled(boolean)}. */
    void setPreferentialNetworkServiceEnabled(boolean enabled);

    /** See {@link DevicePolicyManager#notifyPendingSystemUpdate(long)}. */
    void notifyPendingSystemUpdate(long updateReceivedTime);

    /** See {@link DevicePolicyManager#notifyPendingSystemUpdate(long, boolean)}. */
    void notifyPendingSystemUpdate(long updateReceivedTime, boolean isSecurityPatch);

    /** See {@link DevicePolicyManager#getPendingSystemUpdate(ComponentName}). */
    SystemUpdateInfo getPendingSystemUpdate(ComponentName admin);
    /** See {@link DevicePolicyManager#getPendingSystemUpdate(ComponentName}). */
    @RemoteDpcAutomaticAdmin SystemUpdateInfo getPendingSystemUpdate();

    /** See {@link DevicePolicyManager#setAffiliationIds(ComponentName, Set)}. */
    void setAffiliationIds(ComponentName admin, Set<String> ids);
    /** See {@link DevicePolicyManager#setAffiliationIds(ComponentName, Set)}. */
    @RemoteDpcAutomaticAdmin void setAffiliationIds(Set<String> ids);

    /** See {@link android.app.admin.DevicePolicyManager#addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)}. */
    void addPersistentPreferredActivity(
            ComponentName admin, IntentFilter filter, ComponentName activity);

    /** See {@link android.app.admin.DevicePolicyManager#addPersistentPreferredActivity(ComponentName, IntentFilter, ComponentName)}. */
    @RemoteDpcAutomaticAdmin void addPersistentPreferredActivity(
            IntentFilter filter, ComponentName activity);
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2099"	"testPocCVE_2019_2099"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2099.java"	""	"@AsbSecurityTest(cveBugId = 123583388)
    public void testPocCVE_2019_2099() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2099"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.BaseDevicePolicyTest"	"isHeadlessSystemUserMode"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/BaseDevicePolicyTest.java"	""	"public void test/*
 *.
 */

package com.android.cts.devicepolicy;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.role.RoleProto;
import com.android.role.RoleServiceDumpProto;
import com.android.role.RoleUserStateProto;
import com.android.tradefed.config.Option;
import com.android.tradefed.device.CollectingByteOutputReceiver;
import com.android.tradefed.device.CollectingOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import com.google.common.base.Strings;
import com.google.common.io.ByteStreams;

import org.junit.After;
import org.junit.AssumptionViolatedException;
import org.junit.Before;
import org.junit.Rule;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nullable;

/**
 * Base class for device policy tests. It offers utility methods to run tests, set device or profile
 * owner, etc.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public abstract class BaseDevicePolicyTest extends BaseHostJUnit4Test {

    private static final String FEATURE_BLUETOOTH = ""android.hardware.bluetooth"";
    private static final String FEATURE_CAMERA = ""android.hardware.camera"";
    private static final String FEATURE_CONNECTION_SERVICE = ""android.software.connectionservice"";
    private static final String FEATURE_FBE = ""android.software.file_based_encryption"";
    private static final String FEATURE_LEANBACK = ""android.software.leanback"";
    private static final String FEATURE_NFC = ""android.hardware.nfc"";
    private static final String FEATURE_NFC_BEAM = ""android.software.nfc.beam"";

    private static final String FEATURE_PRINT = ""android.software.print"";
    private static final String FEATURE_TELEPHONY = ""android.hardware.telephony"";
    private static final String FEATURE_SECURE_LOCK_SCREEN = ""android.software.secure_lock_screen"";
    private static final String FEATURE_WIFI = ""android.hardware.wifi"";

    //The maximum time to wait for user to be unlocked.
    private static final long USER_UNLOCK_TIMEOUT_SEC = 30;
    private static final String USER_STATE_UNLOCKED = ""RUNNING_UNLOCKED"";

    protected static final String PERMISSION_INTERACT_ACROSS_USERS =
            ""android.permission.INTERACT_ACROSS_USERS"";

    @Option(
            name = ""skip-device-admin-feature-check"",
            description = ""Flag that allows to skip the check for android.software.device_admin ""
                + ""and run the tests no matter what. This is useful for system that do not what ""
                + ""to expose that feature publicly.""
    )
    private boolean mSkipDeviceAdminFeatureCheck = false;

    private static final String RUNNER = ""androidx.test.runner.AndroidJUnitRunner"";

    protected static final int USER_SYSTEM = 0; // From the UserHandle class.

    protected static final int USER_OWNER = USER_SYSTEM;

    private static final long TIMEOUT_USER_REMOVED_MILLIS = TimeUnit.SECONDS.toMillis(15);
    private static final long WAIT_SAMPLE_INTERVAL_MILLIS = 200;

    /**
     * The defined timeout (in milliseconds) is used as a maximum waiting time when expecting the
     * command output from the device. At any time, if the shell command does not output anything
     * for a period longer than defined timeout the Tradefed run terminates.
     */
    private static final long DEFAULT_SHELL_TIMEOUT_MILLIS = TimeUnit.MINUTES.toMillis(20);

    /**
     * Sets timeout (in milliseconds) that will be applied to each test. In the
     * event of a test timeout it will log the results and proceed with executing the next test.
     */
    private static final long DEFAULT_TEST_TIMEOUT_MILLIS = TimeUnit.MINUTES.toMillis(10);

    /**
     * The amount of milliseconds to wait for the remove user calls in {@link #tearDown}.
     * This is a temporary measure until b/114057686 is fixed.
     */
    private static final long USER_REMOVE_WAIT = TimeUnit.SECONDS.toMillis(5);

    /**
     * The amount of milliseconds to wait for the switch user calls in {@link #tearDown}.
     */
    private static final long USER_SWITCH_WAIT = TimeUnit.SECONDS.toMillis(5);

    // From the UserInfo class
    protected static final int FLAG_GUEST = 0x00000004;
    protected static final int FLAG_EPHEMERAL = 0x00000100;
    protected static final int FLAG_MANAGED_PROFILE = 0x00000020;

    /** Default password to use in tests. */
    protected static final String TEST_PASSWORD = ""1234"";

    /**
     * The {@link android.os.BatteryManager} flags value representing all charging types; {@link
     * android.os.BatteryManager#BATTERY_PLUGGED_AC}, {@link
     * android.os.BatteryManager#BATTERY_PLUGGED_USB}, and {@link
     * android.os.BatteryManager#BATTERY_PLUGGED_WIRELESS}.
     */
    private static final int STAY_ON_WHILE_PLUGGED_IN_FLAGS = 7;

    /**
     * User ID for all users.
     * The value is from the UserHandle class.
     */
    protected static final int USER_ALL = -1;

    private static final String TEST_UPDATE_LOCATION = ""/data/local/tmp/cts/deviceowner"";

    /**
     * Copied from {@link android.app.admin.DevicePolicyManager
     * .InstallSystemUpdateCallback#UPDATE_ERROR_UPDATE_FILE_INVALID}
     */
    protected static final int UPDATE_ERROR_UPDATE_FILE_INVALID = 3;

    protected CompatibilityBuildHelper mBuildHelper;
    private String mPackageVerifier;
    private HashSet<String> mAvailableFeatures;

    /** Packages installed as part of the tests */
    private Set<String> mFixedPackages;

    protected int mDeviceOwnerUserId;
    protected int mPrimaryUserId;

    /** Record the initial user ID. */
    protected int mInitialUserId;

    /** Whether multi-user is supported. */
    private boolean mSupportsMultiUser;

    /** Users we shouldn't delete in the tests */
    private ArrayList<Integer> mFixedUsers;

    private static final String VERIFY_CREDENTIAL_CONFIRMATION = ""Lock credential verified"";

    @Rule
    public final DeviceAdminFeaturesCheckerRule mFeaturesCheckerRule =
            new DeviceAdminFeaturesCheckerRule(this);

    @Before
    public void setUp() throws Exception {
        assertNotNull(getBuild());  // ensure build has been set before test is run.

        if (!mSkipDeviceAdminFeatureCheck) {
            // TODO(b/177965931): STOPSHIP must integrate mSkipDeviceAdminFeatureCheck into
            // DeviceAdminFeaturesCheckerRule
        }

        mSupportsMultiUser = getMaxNumberOfUsersSupported() > 1;
        mFixedPackages = getDevice().getInstalledPackageNames();
        mBuildHelper = new CompatibilityBuildHelper(getBuild());

        if (hasDeviceFeature(FEATURE_SECURE_LOCK_SCREEN)) {
            ensurePrimaryUserHasNoPassword();
        }

        // disable the package verifier to avoid the dialog when installing an app
        mPackageVerifier = getDevice().executeShellCommand(
                ""settings get global verifier_verify_adb_installs"");
        getDevice().executeShellCommand(""settings put global verifier_verify_adb_installs 0"");

        mFixedUsers = new ArrayList<>();

        // Set the value of initial user ID calls in {@link #setUp}.
        if(mSupportsMultiUser) {
            mInitialUserId = getDevice().getCurrentUser();
        }

        if (!isHeadlessSystemUserMode()) {
            mDeviceOwnerUserId = mPrimaryUserId = getPrimaryUser();
        } else {
            // For headless system user, all tests will be executed on current user
            // and therefore, initial user is set as primary user for test purpose.
            mPrimaryUserId = mInitialUserId;
            mDeviceOwnerUserId = USER_SYSTEM;
        }

        mFixedUsers.add(mPrimaryUserId);
        if (mPrimaryUserId != USER_SYSTEM) {
            mFixedUsers.add(USER_SYSTEM);
        }

        if (mFeaturesCheckerRule.hasRequiredFeatures()) {
            // Switching to primary is only needed when we're testing device admin features.
            switchUser(mPrimaryUserId);
        } else {
            // Otherwise, all the tests can be executed in any of the Android users, so remain in
            // current user, and don't delete it. This enables testing in secondary users.
            if (getDevice().getCurrentUser() != mPrimaryUserId) {
                mFixedUsers.add(getDevice().getCurrentUser());
            }
        }
        getDevice().executeShellCommand("" mkdir "" + TEST_UPDATE_LOCATION);

        removeOwners();

        switchUser(mPrimaryUserId);

        removeTestUsers();
        // Unlock keyguard before test
        wakeupAndDismissKeyguard();
        stayAwake();
        // Go to home.
        executeShellCommand(""input keyevent KEYCODE_HOME"");
    }

    private void ensurePrimaryUserHasNoPassword() throws DeviceNotAvailableException {
        if (!verifyUserCredentialIsCorrect(null, mPrimaryUserId)) {
            changeUserCredential(null, TEST_PASSWORD, mPrimaryUserId);
        }
    }

    /** If package manager is not available, e.g. after system crash, wait for it a little bit. */
    private void ensurePackageManagerReady() throws Exception {
        waitForOutput(""Package manager didn't become available"", ""service check package"",
                s -> s.trim().equals(""Service package: found""), 120 /* seconds */);
    }

    protected void waitForUserUnlock(int userId) throws Exception {
        waitForOutput(""User is not unlocked."",
                String.format(""am get-started-user-state %d"", userId),
                s -> s.startsWith(USER_STATE_UNLOCKED), USER_UNLOCK_TIMEOUT_SEC);
    }

    protected void waitForOutput(String message, String command, Predicate<String> predicate,
            long timeoutSec) throws Exception {
        final long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(timeoutSec);
        while (!predicate.test(getDevice().executeShellCommand(command))) {
            if (System.nanoTime() > deadline) {
                fail(message);
            }
            Thread.sleep(1000);
        }
    }

    @After
    public void tearDown() throws Exception {
        // reset the package verifier setting to its original value
        getDevice().executeShellCommand(""settings put global verifier_verify_adb_installs ""
                + mPackageVerifier);
        removeOwners();

        // Switch back to initial user.
        if (mSupportsMultiUser && getDevice().getCurrentUser() != mInitialUserId) {
            switchUser(mInitialUserId);
        }
        removeTestUsers();
        removeTestPackages();
        getDevice().executeShellCommand("" rm -r "" + TEST_UPDATE_LOCATION);
    }

    protected void installAppAsUser(String appFileName, int userId) throws FileNotFoundException,
            DeviceNotAvailableException {
        installAppAsUser(appFileName, true, userId);
    }

    protected void installAppAsUser(String appFileName, boolean grantPermissions, int userId)
            throws FileNotFoundException, DeviceNotAvailableException {
        installAppAsUser(appFileName, grantPermissions, /* dontKillApp */ false, userId);
    }

    protected void installAppAsUser(String appFileName, boolean grantPermissions,
            boolean dontKillApp, int userId)
                    throws FileNotFoundException, DeviceNotAvailableException {
        CLog.e(""Installing app %s for user %d"", appFileName, userId);
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        List<String> extraArgs = new LinkedList<>();
        extraArgs.add(""-t"");
        // Make the test app queryable by other apps via PackageManager APIs.
        extraArgs.add(""--force-queryable"");
        if (dontKillApp) extraArgs.add(""--dont-kill"");
        String result = getDevice().installPackageForUser(
                buildHelper.getTestFile(appFileName), true, grantPermissions, userId,
                extraArgs.toArray(new String[extraArgs.size()]));
        assertNull(""Failed to install "" + appFileName + "" for user "" + userId + "": "" + result,
                result);
    }

    protected void installAppIncremental(String appFileName)
            throws FileNotFoundException, DeviceNotAvailableException {
        final String signatureSuffix = "".idsig"";
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        final File apk = buildHelper.getTestFile(appFileName);
        assertNotNull(apk);
        final File idsig = buildHelper.getTestFile(appFileName + signatureSuffix);
        assertNotNull(idsig);
        final String remoteApkPath = TEST_UPDATE_LOCATION + ""/"" + apk.getName();
        final String remoteIdsigPath = remoteApkPath + signatureSuffix;
        assertTrue(getDevice().pushFile(apk, remoteApkPath));
        assertTrue(getDevice().pushFile(idsig, remoteIdsigPath));
        String installResult = getDevice().executeShellCommand(
                ""pm install-incremental -t -g "" + remoteApkPath);
        assertEquals(""Success\n"", installResult);
    }

    protected void installDeviceOwnerApp(String apk) throws Exception {
        installAppAsUser(apk, mDeviceOwnerUserId);

        if (isHeadlessSystemUserMode()) {
            // Need to explicitly install the device owner app for the current user (rather than
            // relying on DPMS) so it has the same privileges (like INTERACT_ACROSS_USERS) as the
            // app running on system user, otherwise some tests might fail
            installAppAsUser(apk, mPrimaryUserId);
        }
    }

    protected void removeDeviceOwnerAdmin(String componentName) throws DeviceNotAvailableException {
        // Don't fail as it could hide the real failure from the test method
        if (!removeAdmin(componentName, mDeviceOwnerUserId)) {
            CLog.e(""Failed to remove device owner %s on user %d"", componentName,
                    mDeviceOwnerUserId);
        }
        if (isHeadlessSystemUserMode() && !removeAdmin(componentName, mPrimaryUserId)) {
            CLog.e(""Failed to remove profile owner %s on user %d"", componentName, mPrimaryUserId);
        }
    }

    protected void forceStopPackageForUser(String packageName, int userId) throws Exception {
        // TODO Move this logic to ITestDevice
        executeShellCommand(""am force-stop --user "" + userId + "" "" + packageName);
    }

    protected void executeShellCommand(String commandTemplate, Object...args) throws Exception {
        executeShellCommand(String.format(commandTemplate, args));
    }

    protected void executeShellCommand(String command) throws Exception {
        CLog.d(""Starting command "" + command);
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
    }

    /** Initializes the user with the given id. This is required so that apps can run on it. */
    protected void startUser(int userId) throws Exception {
        getDevice().startUser(userId);
    }

    /** Initializes the user with waitFlag. This is required so that apps can run on it. */
    protected void startUserAndWait(int userId) throws Exception {
        getDevice().startUser(userId, /* waitFlag= */ true);
    }

    /**
     * Initializes the user with the given id, and waits until the user has started and unlocked
     * before continuing.
     *
     * <p>This is required so that apps can run on it.
     */
    protected void startUser(int userId, boolean waitFlag) throws Exception {
        getDevice().startUser(userId, waitFlag);
    }

    /**
     * Starts switching to the user with the given ID.
     *
     * <p>This is not blocking. Some operations will be flaky if called immediately afterwards, such
     * as {@link #wakeupAndDismissKeyguard()}. Call {@link #waitForBroadcastIdle()} between this
     * method and those operations to ensure that switching the user has finished.
     */
    protected void switchUser(int userId) throws Exception {
        // TODO Move this logic to ITestDevice
        int retries = 10;
        executeShellCommand(""am switch-user "" + userId);
        while (getDevice().getCurrentUser() != userId && (--retries) >= 0) {
            // am switch-user can be ignored if a previous user-switching operation
            // is still in progress. In this case, sleep a bit and then retry
            Thread.sleep(USER_SWITCH_WAIT);
            executeShellCommand(""am switch-user "" + userId);
        }
        assertTrue(""Failed to switch user after multiple retries"", getDevice().getCurrentUser() == userId);
    }

    protected int getMaxNumberOfUsersSupported() throws DeviceNotAvailableException {
        return getDevice().getMaxNumberOfUsersSupported();
    }

    protected int getMaxNumberOfRunningUsersSupported() throws DeviceNotAvailableException {
        return getDevice().getMaxNumberOfRunningUsersSupported();
    }

    protected int getUserFlags(int userId) throws DeviceNotAvailableException {
        String command = ""pm list users"";
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.i(""Output for command "" + command + "": "" + commandOutput);

        String[] lines = commandOutput.split(""\\r?\\n"");
        assertTrue(commandOutput + "" should contain at least one line"", lines.length >= 1);
        for (int i = 1; i < lines.length; i++) {
            // Individual user is printed out like this:
            // \tUserInfo{$id$:$name$:$Integer.toHexString(flags)$} [running]
            String[] tokens = lines[i].split(""\\{|\\}|:"");
            assertTrue(lines[i] + "" doesn't contain 4 or 5 tokens"",
                    tokens.length == 4 || tokens.length == 5);
            // If the user IDs match, return the flags.
            if (Integer.parseInt(tokens[1]) == userId) {
                return Integer.parseInt(tokens[3], 16);
            }
        }
        fail(""User not found"");
        return 0;
    }

    protected ArrayList<Integer> listUsers() throws DeviceNotAvailableException {
        return getDevice().listUsers();
    }

    protected  ArrayList<Integer> listRunningUsers() throws DeviceNotAvailableException {
        ArrayList<Integer> runningUsers = new ArrayList<>();
        for (int userId : listUsers()) {
            if (getDevice().isUserRunning(userId)) {
                runningUsers.add(userId);
            }
        }
        return runningUsers;
    }

    protected int getFirstManagedProfileUserId() throws DeviceNotAvailableException {
        for (int userId : listUsers()) {
            if ((getUserFlags(userId) & FLAG_MANAGED_PROFILE) != 0) {
                return userId;
            }
        }
        fail(""Managed profile not found"");
        return 0;
    }

    private void stopUserAsync(int userId) throws Exception {
        String stopUserCommand = ""am stop-user -f "" + userId;
        CLog.d(""starting command \"""" + stopUserCommand);
        CLog.d(""Output for command "" + stopUserCommand + "": ""
                + getDevice().executeShellCommand(stopUserCommand));
    }

    protected void stopUser(int userId) throws Exception {
        String stopUserCommand = ""am stop-user -w -f "" + userId;
        CLog.d(""starting command \"""" + stopUserCommand + ""\"" and waiting."");
        CLog.d(""Output for command "" + stopUserCommand + "": ""
                + getDevice().executeShellCommand(stopUserCommand));
    }

    protected void waitForBroadcastIdle() throws DeviceNotAvailableException, IOException {
        final CollectingOutputReceiver receiver = new CollectingOutputReceiver();
        // We allow 8min for the command to complete and 4min for the command to start to
        // output something.
        getDevice().executeShellCommand(
                ""am wait-for-broadcast-idle"", receiver, 8, 4, TimeUnit.MINUTES, 0);
        final String output = receiver.getOutput();
        if (!output.contains(""All broadcast queues are idle!"")) {
            CLog.e(""Output from 'am wait-for-broadcast-idle': %s"", output);
            fail(""'am wait-for-broadcase-idle' did not complete."");
        }
    }

    protected void removeUser(int userId) throws Exception  {
        if (listUsers().contains(userId) && userId != USER_SYSTEM) {
            // Don't log output, as tests sometimes set no debug user restriction, which
            // causes this to fail, we should still continue and remove the user.
            String stopUserCommand = ""am stop-user -w -f "" + userId;
            CLog.d(""stopping and removing user "" + userId);
            getDevice().executeShellCommand(stopUserCommand);
            // TODO: Remove both sleeps and USER_REMOVE_WAIT constant when b/114057686 is fixed.
            Thread.sleep(USER_REMOVE_WAIT);
            // Ephemeral users may have already been removed after being stopped.
            if (listUsers().contains(userId)) {
                assertTrue(""Couldn't remove user"", getDevice().removeUser(userId));
                Thread.sleep(USER_REMOVE_WAIT);
            }
        }
    }

    protected void removeTestUsers() throws Exception {
        List<Integer> usersCreatedByTests = getUsersCreatedByTests();

        // The time spent on stopUser is depend on how busy the broadcast queue is.
        // To optimize the time to remove multiple test users, we mark all users as
        // stopping first, so no more broadcasts will be sent to these users, which make the queue
        // less busy.
        for (int userId : usersCreatedByTests) {
            stopUserAsync(userId);
        }
        for (int userId : usersCreatedByTests) {
            removeTestAddedUser(userId);
        }
    }

    private void removeTestAddedUser(int userId) throws Exception  {
        // Don't remove system user or initial user.
        if (userId != USER_SYSTEM && userId != mInitialUserId) {
            removeUser(userId);
        }
    }

    /**
     * Returns the users that have been created since running this class' setUp() method.
     */
    protected List<Integer> getUsersCreatedByTests() throws Exception {
        List<Integer> result = listUsers();
        result.removeAll(mFixedUsers);
        return result;
    }

    /** Removes any packages that were installed during the test. */
    protected void removeTestPackages() throws Exception {
        for (String packageName : getDevice().getUninstallablePackageNames()) {
            if (mFixedPackages.contains(packageName)) {
                continue;
            }
            CLog.w(""removing leftover package: "" + packageName);
            getDevice().uninstallPackage(packageName);
        }
    }

    protected void runDeviceTestsAsUser(
            String pkgName, @Nullable String testClassName, int userId)
            throws DeviceNotAvailableException {
        runDeviceTestsAsUser(pkgName, testClassName, /* testMethodName= */ null, userId);
    }

    protected void runDeviceTestsAsUser(
            String pkgName, @Nullable String testClassName, String testMethodName, int userId)
            throws DeviceNotAvailableException {
        Map<String, String> params = Collections.emptyMap();
        runDeviceTestsAsUser(pkgName, testClassName, testMethodName, userId, params);
    }

    protected void runDeviceTestsAsUser(
            String pkgName, @Nullable String testClassName,
            @Nullable String testMethodName, int userId,
            Map<String, String> params) throws DeviceNotAvailableException {
        if (testClassName != null && testClassName.startsWith(""."")) {
            testClassName = pkgName + testClassName;
        }

        CLog.i(""runDeviceTestsAsUser(): user=%d, pkg=%s class=%s, test=%s"", userId, pkgName,
                testClassName, testMethodName);
        runDeviceTests(
                getDevice(),
                RUNNER,
                pkgName,
                testClassName,
                testMethodName,
                userId,
                DEFAULT_TEST_TIMEOUT_MILLIS,
                DEFAULT_SHELL_TIMEOUT_MILLIS,
                0L /* maxInstrumentationTimeoutMs */,
                true /* checkResults */,
                false /* isHiddenApiCheckDisabled */,
                params);
    }

    /** Reboots the device and block until the boot complete flag is set. */
    protected void rebootAndWaitUntilReady() throws Exception {
        getDevice().rebootUntilOnline();
        assertTrue(""Device failed to boot"", getDevice().waitForBootComplete(120000));
    }

    /** Returns a boolean value of the system property with the specified key. */
    protected boolean getBooleanSystemProperty(String key, boolean defaultValue)
            throws DeviceNotAvailableException {
        final String[] positiveValues = {""1"", ""y"", ""yes"", ""true"", ""on""};
        final String[] negativeValues = {""0"", ""n"", ""no"", ""false"", ""off""};
        String propertyValue = getDevice().getProperty(key);
        if (propertyValue == null || propertyValue.isEmpty()) {
            return defaultValue;
        }
        if (Arrays.asList(positiveValues).contains(propertyValue)) {
            return true;
        }
        if (Arrays.asList(negativeValues).contains(propertyValue)) {
            return false;
        }
        fail(""Unexpected value of boolean system property '"" + key + ""': "" + propertyValue);
        return false;
    }

    /** Checks whether it is possible to create the desired number of users. */
    protected boolean canCreateAdditionalUsers(int numberOfUsers)
            throws DeviceNotAvailableException {
        return listUsers().size() + numberOfUsers <= getMaxNumberOfUsersSupported();
    }

    /**
     * Throws a {@link org.junit.AssumptionViolatedException} if it's not possible to create the
     * desired number of users.
     */
    protected void assumeCanCreateAdditionalUsers(int numberOfUsers)
            throws DeviceNotAvailableException {
        int maxUsers = getDevice().getMaxNumberOfUsersSupported();
        assumeTrue(""Tests needs at least "" + numberOfUsers + "" extra users, but device supports ""
                + ""at most "" + getMaxNumberOfUsersSupported(),
                canCreateAdditionalUsers(numberOfUsers));
    }

    /** Checks whether it is possible to start the desired number of users. */
    protected boolean canStartAdditionalUsers(int numberOfUsers)
            throws DeviceNotAvailableException {
        return listRunningUsers().size() + numberOfUsers <= getMaxNumberOfRunningUsersSupported();
    }

    protected void assumeCanStartNewUser() throws DeviceNotAvailableException {
        assumeCanCreateOneManagedUser();
        assumeTrue(""Cannot start a new user"", canStartAdditionalUsers(1));
    }

    protected int createUser() throws Exception {
        int userId = createUser(0);
        CLog.i(""Created user with id %d"", userId);
        // TODO remove this and audit tests so they start users as necessary
        startUser(userId);
        return userId;
    }

    protected int createUserAndWaitStart() throws Exception {
        int userId = createUser(0);
        startUserAndWait(userId);
        return userId;
    }

    protected int createUser(int flags) throws Exception {
        boolean guest = FLAG_GUEST == (flags & FLAG_GUEST);
        boolean ephemeral = FLAG_EPHEMERAL == (flags & FLAG_EPHEMERAL);
        CLog.i(""Creating user with flags %d: guest=%b, ephemeral=%b"", flags, guest, ephemeral);
        // TODO Use ITestDevice.createUser() when guest and ephemeral is available
        String command =""pm create-user "" + (guest ? ""--guest "" : """")
                + (ephemeral ? ""--ephemeral "" : """") + ""TestUser_"" + System.currentTimeMillis();
        CLog.d(""Starting command %s"", command);
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command %s: %s"", command, commandOutput);

        // Extract the id of the new user.
        String[] tokens = commandOutput.split(""\\s+"");
        assertTrue(tokens.length > 0);
        assertEquals(""Command '"" + command + ""' failed: "" + commandOutput, ""Success:"", tokens[0]);
        return Integer.parseInt(tokens[tokens.length-1]);
    }

    protected int createManagedProfile(int parentUserId) throws DeviceNotAvailableException {
        String commandOutput = getCreateManagedProfileCommandOutput(parentUserId);
        return getUserIdFromCreateUserCommandOutput(commandOutput);
    }

    protected void assertCannotCreateManagedProfile(int parentUserId)
            throws Exception {
        String commandOutput = getCreateManagedProfileCommandOutput(parentUserId);
        if (commandOutput.startsWith(""Error"")) {
            return;
        }
        int userId = getUserIdFromCreateUserCommandOutput(commandOutput);
        removeUser(userId);
        fail(""Expected not to be able to create a managed profile. Output was: "" + commandOutput);
    }

    private void assumeHasDeviceFeature(String feature) throws DeviceNotAvailableException {
        assumeTrue(""device doesn't have "" + feature, hasDeviceFeature(feature));
    }

    private void assumeDoesNotHaveDeviceFeature(String feature) throws DeviceNotAvailableException {
        assumeFalse(""device has "" + feature, hasDeviceFeature(feature));
    }

    /**
     * Used by test cases to add additional checks priort to {@link #setUp()}, so that when it
     * throws an {@link AssumptionViolatedException} exception nothing is run
     * (even {@link #tearDown()}).
     */
    protected void assumeTestEnabled() throws Exception {
    }

    protected final void assumeCanCreateOneManagedUser() throws DeviceNotAvailableException {
        assumeSupportsMultiUser();
        assumeCanCreateAdditionalUsers(1);
    }

    protected final void assumeSupportsMultiUser() throws DeviceNotAvailableException {
        assumeTrue(""device doesn't support multiple users"", mSupportsMultiUser);
    }

    protected final void assumeHasWifiFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_WIFI);
    }

    protected final void assumeHasTelephonyFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_TELEPHONY);
    }

    protected final void assumeHasNfcFeatures() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_NFC);
        assumeHasDeviceFeature(FEATURE_NFC_BEAM);
    }

    protected final void assumeHasTelephonyAndConnectionServiceFeatures()
            throws DeviceNotAvailableException {
        assumeHasTelephonyFeature();
        assumeHasDeviceFeature(FEATURE_CONNECTION_SERVICE);
    }

    protected final void assumeHasSecureLockScreenFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_SECURE_LOCK_SCREEN);
    }

    protected final void assumeDoesNotHaveSecureLockScreenFeature()
            throws DeviceNotAvailableException {
        assumeDoesNotHaveDeviceFeature(FEATURE_SECURE_LOCK_SCREEN);
    }

    protected final void assumeHasFileBasedEncryptionAndSecureLockScreenFeatures()
            throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_FBE);
        assumeHasSecureLockScreenFeature();
    }

    protected final void assumeHasPrintFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_PRINT);
    }

    protected final void assumeHasCameraFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_CAMERA);
    }

    protected final void assumeHasBluetoothFeature() throws DeviceNotAvailableException {
        assumeHasDeviceFeature(FEATURE_BLUETOOTH);
    }

    protected final void assumeApiLevel(int min) throws DeviceNotAvailableException {
        assumeTrue(""API level must be >="" + min, getDevice().getApiLevel() >= min);
    }

    private int getUserIdFromCreateUserCommandOutput(String commandOutput) {
        // Extract the id of the new user.
        String[] tokens = commandOutput.split(""\\s+"");
        assertTrue(commandOutput + "" expected to have format \""Success: {USER_ID}\"""",
                tokens.length > 0);
        assertEquals(commandOutput, ""Success:"", tokens[0]);
        return Integer.parseInt(tokens[tokens.length-1]);
    }

    private String getCreateManagedProfileCommandOutput(int parentUserId)
            throws DeviceNotAvailableException {
        String command = ""pm create-user --profileOf "" + parentUserId + "" --managed ""
                + ""TestProfile_"" + System.currentTimeMillis();
        CLog.d(""Starting command "" + command);
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
        return commandOutput;
    }

    protected int getPrimaryUser() throws DeviceNotAvailableException {
        return getDevice().getPrimaryUserId();
    }

    protected int getUserSerialNumber(int userId) throws DeviceNotAvailableException{
        // TODO: Move this logic to ITestDevice.
        // dumpsys user output contains lines like ""UserInfo{0:Owner:13} serialNo=0 isPrimary=true""
        final Pattern pattern =
                Pattern.compile(""UserInfo\\{"" + userId + "":[^\\n]*\\sserialNo=(\\d+)\\s"");
        final String commandOutput = getDevice().executeShellCommand(""dumpsys user"");
        final Matcher matcher = pattern.matcher(commandOutput);
        if (matcher.find()) {
            return Integer.parseInt(matcher.group(1));
        }
        fail(""Couldn't find serial number for user "" + userId);
        return -1;
    }

    protected boolean setProfileOwner(String componentName, int userId, boolean expectFailure)
            throws DeviceNotAvailableException {
        String command = ""dpm set-profile-owner --user "" + userId + "" '"" + componentName + ""'"";
        String commandOutput = getDevice().executeShellCommand(command);
        boolean success = commandOutput.startsWith(""Success:"");
        // If we succeeded always log, if we are expecting failure don't log failures
        // as call stacks for passing tests confuse the logs.
        if (success || !expectFailure) {
            CLog.e(""Output for command "" + command + "": "" + commandOutput);
        } else {
            CLog.e(""Command Failed "" + command);
        }
        return success;
    }

    protected void setProfileOwnerOrFail(String componentName, int userId)
            throws Exception {
        if (!setProfileOwner(componentName, userId, /*expectFailure*/ false)) {
            // Don't remove system user or initial user that tests require to run on.
            removeTestAddedUser(userId);
            fail(""Failed to set profile owner"");
        }
    }

    protected void setProfileOwnerExpectingFailure(String componentName, int userId)
            throws Exception {
        if (setProfileOwner(componentName, userId, /* expectFailure =*/ true)) {
            removeTestAddedUser(userId);
            fail(""Setting profile owner should have failed."");
        }
    }

    private String setDeviceAdminInner(String componentName, int userId)
            throws DeviceNotAvailableException {
        String command = ""dpm set-active-admin --user "" + userId + "" '"" + componentName + ""'"";
        String commandOutput = getDevice().executeShellCommand(command);
        return commandOutput;
    }

    protected void setDeviceAdmin(String componentName, int userId)
            throws DeviceNotAvailableException {
        String commandOutput = setDeviceAdminInner(componentName, userId);
        CLog.d(""Output for command "" + commandOutput
                + "": "" + commandOutput);
        assertTrue(commandOutput + "" expected to start with \""Success:\"""",
                commandOutput.startsWith(""Success:""));
    }

    protected void setDeviceAdminExpectingFailure(String componentName, int userId,
            String errorMessage) throws DeviceNotAvailableException {
        String commandOutput = setDeviceAdminInner(componentName, userId);
        if (!commandOutput.contains(errorMessage)) {
            fail(commandOutput + "" expected to contain \"""" + errorMessage + ""\"""");
        }
    }

    protected boolean setDeviceOwner(String componentName, int userId, boolean expectFailure)
            throws DeviceNotAvailableException {
        String command = ""dpm set-device-owner --user "" + userId + "" '"" + componentName + ""'"";
        String commandOutput = getDevice().executeShellCommand(command);
        boolean success = commandOutput.startsWith(""Success:"");
        // If we succeeded always log, if we are expecting failure don't log failures
        // as call stacks for passing tests confuse the logs.
        if (success || !expectFailure) {
            CLog.d(""Output for command "" + command + "": "" + commandOutput);
        } else {
            CLog.d(""Command Failed "" + command);
        }
        return success;
    }

    protected void setDeviceOwnerOrFail(String componentName, int userId)
            throws Exception {
        assertTrue(setDeviceOwner(componentName, userId, /* expectFailure =*/ false));
    }

    protected void setDeviceOwnerExpectingFailure(String componentName, int userId)
            throws Exception {
        assertFalse(setDeviceOwner(componentName, userId, /* expectFailure =*/ true));
    }


    protected void affiliateUsers(String deviceAdminPkg, int userId1, int userId2)
            throws Exception {
        CLog.d(""Affiliating users %d and %d on admin package %s"", userId1, userId2, deviceAdminPkg);
        runDeviceTestsAsUser(
                deviceAdminPkg, "".AffiliationTest"", ""testSetAffiliationId1"", userId1);
        runDeviceTestsAsUser(
                deviceAdminPkg, "".AffiliationTest"", ""testSetAffiliationId1"", userId2);
    }

    protected String getSettings(String namespace, String name, int userId)
            throws DeviceNotAvailableException {
        String command = ""settings --user "" + userId + "" get "" + namespace + "" "" + name;
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
        return commandOutput.replace(""\n"", """").replace(""\r"", """");
    }

    protected void putSettings(String namespace, String name, String value, int userId)
            throws DeviceNotAvailableException {
        String command = ""settings --user "" + userId + "" put "" + namespace + "" "" + name
                + "" "" + value;
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
    }

    protected boolean removeAdmin(String componentName, int userId)
            throws DeviceNotAvailableException {
        String command = ""dpm remove-active-admin --user "" + userId + "" '"" + componentName + ""'"";
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + commandOutput);
        return commandOutput.startsWith(""Success:"");
    }

    // Tries to remove and profile or device owners it finds.
    protected void removeOwners() throws DeviceNotAvailableException {
        String command = ""dumpsys device_policy"";
        String commandOutput = getDevice().executeShellCommand(command);
        String[] lines = commandOutput.split(""\\r?\\n"");
        for (int i = 0; i < lines.length; ++i) {
            String line = lines[i].trim();
            if (line.contains(""Profile Owner"")) {
                // Line is ""Profile owner (User <id>):
                String[] tokens = line.split(""\\(|\\)| "");
                int userId = Integer.parseInt(tokens[4]);
                i++;
                line = lines[i].trim();
                // Line is admin=ComponentInfo{<component>}
                tokens = line.split(""\\{|\\}"");
                String componentName = tokens[1];
                CLog.w(""Cleaning up profile owner "" + userId + "" "" + componentName);
                removeAdmin(componentName, userId);
            } else if (line.contains(""Device Owner:"")) {
                i++;
                line = lines[i].trim();
                // Line is admin=ComponentInfo{<component>}
                String[] tokens = line.split(""\\{|\\}"");
                String componentName = tokens[1];
                // Skip to user id line.
                i += 4;
                line = lines[i].trim();
                // Line is User ID: <N>
                tokens = line.split("":"");
                int userId = Integer.parseInt(tokens[1].trim());
                CLog.w(""Cleaning up device owner "" + userId + "" "" + componentName);
                removeAdmin(componentName, userId);
            }
        }
    }

    /**
     * Runs pm enable command to enable a package or component. Returns the command result.
     */
    protected String enableComponentOrPackage(int userId, String packageOrComponent)
            throws DeviceNotAvailableException {
        String command = ""pm enable --user "" + userId + "" "" + packageOrComponent;
        String result = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + result);
        return result;
    }

    /**
     * Runs pm disable command to disable a package or component. Returns the command result.
     */
    protected String disableComponentOrPackage(int userId, String packageOrComponent)
            throws DeviceNotAvailableException {
        String command = ""pm disable --user "" + userId + "" "" + packageOrComponent;
        String result = getDevice().executeShellCommand(command);
        CLog.d(""Output for command "" + command + "": "" + result);
        return result;
    }

    protected interface SuccessCondition {
        boolean check() throws Exception;
    }

    protected void waitUntilUserRemoved(int userId) throws Exception {
        tryWaitForSuccess(() -> !listUsers().contains(userId),
                ""The user "" + userId + "" has not been removed"",
                TIMEOUT_USER_REMOVED_MILLIS
                );
    }

    protected void tryWaitForSuccess(SuccessCondition successCondition, String failureMessage,
            long timeoutMillis) throws Exception {
        long epoch = System.currentTimeMillis();
        while (System.currentTimeMillis() - epoch <= timeoutMillis) {
            Thread.sleep(WAIT_SAMPLE_INTERVAL_MILLIS);
            if (successCondition.check()) {
                return;
            }
        }
        fail(failureMessage);
    }

    /**
     * Sets a user restriction via SetPolicyActivity.
     * <p>IMPORTANT: The package that contains SetPolicyActivity must have been installed prior to
     * calling this method.
     * @param key user restriction key
     * @param value true if we should set the restriction, false if we should clear it
     * @param userId userId to set/clear the user restriction on
     * @param packageName package where SetPolicyActivity is installed
     * @return The output of the command
     * @throws DeviceNotAvailableException
     */
    protected String changeUserRestriction(String key, boolean value, int userId,
            String packageName) throws DeviceNotAvailableException {
        return changePolicy(getUserRestrictionCommand(value),
                "" --es extra-restriction-key "" + key, userId, packageName);
    }

    /**
     * Same as {@link #changeUserRestriction(String, boolean, int, String)} but asserts that it
     * succeeds.
     */
    protected void changeUserRestrictionOrFail(String key, boolean value, int userId,
            String packageName) throws DeviceNotAvailableException {
        changePolicyOrFail(getUserRestrictionCommand(value), "" --es extra-restriction-key "" + key,
                userId, packageName);
    }

    /**
     * Sets some policy via SetPolicyActivity.
     * <p>IMPORTANT: The package that contains SetPolicyActivity must have been installed prior to
     * calling this method.
     * @param command command to pass to SetPolicyActivity
     * @param extras extras to pass to SetPolicyActivity
     * @param userId the userId where we invoke SetPolicyActivity
     * @param packageName where SetPolicyActivity is installed
     * @return The output of the command
     * @throws DeviceNotAvailableException
     */
    protected String changePolicy(String command, String extras, int userId, String packageName)
            throws DeviceNotAvailableException {
        String adbCommand = ""am start -W --user "" + userId
                + "" -c android.intent.category.DEFAULT ""
                + "" --es extra-command "" + command
                + "" "" + extras
                + "" "" + packageName + ""/.SetPolicyActivity"";
        String commandOutput = getDevice().executeShellCommand(adbCommand);
        CLog.d(""Output for command "" + adbCommand + "": "" + commandOutput);
        return commandOutput;
    }

    /**
     * Same as {@link #changePolicy(String, String, int, String)} but asserts that it succeeds.
     */
    protected void changePolicyOrFail(String command, String extras, int userId,
            String packageName) throws DeviceNotAvailableException {
        String commandOutput = changePolicy(command, extras, userId, packageName);
        assertTrue(""Command was expected to succeed "" + commandOutput,
                commandOutput.contains(""Status: ok""));
    }

    private String getUserRestrictionCommand(boolean setRestriction) {
        if (setRestriction) {
            return ""add-restriction"";
        }
        return ""clear-restriction"";
    }

    /**
     * Set lockscreen password / work challenge for the given user, null or """" means clear
     * IMPORTANT: prefer to use {@link #TEST_PASSWORD} for primary user, otherwise if the test
     * terminates before cleaning password up, the device will be unusable for further testing.
     */
    protected void changeUserCredential(String newCredential, String oldCredential, int userId)
            throws DeviceNotAvailableException {
        final String oldCredentialArgument = (oldCredential == null || oldCredential.isEmpty()) ? """"
                : (""--old "" + oldCredential);
        if (newCredential != null && !newCredential.isEmpty()) {
            String commandOutput = getDevice().executeShellCommand(String.format(
                    ""cmd lock_settings set-password --user %d %s %s"", userId, oldCredentialArgument,
                    newCredential));
            if (!commandOutput.startsWith(""Password set to"")) {
                fail(""Failed to set user credential: "" + commandOutput);
            }
        } else {
            String commandOutput = getDevice().executeShellCommand(String.format(
                    ""cmd lock_settings clear --user %d %s"", userId, oldCredentialArgument));
            if (!commandOutput.startsWith(""Lock credential cleared"")) {
                fail(""Failed to clear user credential: "" + commandOutput);
            }
        }
    }

    /**
     * Verifies the lock credential for the given user.
     *
     * @param credential The credential to verify.
     * @param userId The id of the user.
     */
    protected void verifyUserCredential(String credential, int userId)
            throws DeviceNotAvailableException {
        String commandOutput = verifyUserCredentialCommandOutput(credential, userId);
        if (!commandOutput.startsWith(VERIFY_CREDENTIAL_CONFIRMATION)) {
            fail(""Failed to verify user credential: "" + commandOutput);
        }
     }

    /**
     * Verifies the lock credential for the given user, which unlocks the user, and returns
     * whether it was successful or not.
     *
     * @param credential The credential to verify.
     * @param userId The id of the user.
     */
    protected boolean verifyUserCredentialIsCorrect(String credential, int userId)
            throws DeviceNotAvailableException {
        String commandOutput = verifyUserCredentialCommandOutput(credential, userId);
        return commandOutput.startsWith(VERIFY_CREDENTIAL_CONFIRMATION);
    }

    /**
     * Verifies the lock credential for the given user, which unlocks the user. Returns the
     * commandline output, which includes whether the verification was successful.
     *
     * @param credential The credential to verify.
     * @param userId The id of the user.
     * @return The command line output.
     */
    protected String verifyUserCredentialCommandOutput(String credential, int userId)
            throws DeviceNotAvailableException {
        final String credentialArgument = (credential == null || credential.isEmpty())
                ? """" : (""--old "" + credential);
        String commandOutput = getDevice().executeShellCommand(String.format(
                ""cmd lock_settings verify --user %d %s"", userId, credentialArgument));
        return commandOutput;
    }

    protected void wakeupAndDismissKeyguard() throws Exception {
        executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        executeShellCommand(""wm dismiss-keyguard"");
    }

    protected void pressPowerButton() throws Exception {
        executeShellCommand(""input keyevent KEYCODE_POWER"");
    }

    private void stayAwake() throws Exception {
        executeShellCommand(
                ""settings put global stay_on_while_plugged_in "" + STAY_ON_WHILE_PLUGGED_IN_FLAGS);
    }

    protected void startActivityAsUser(int userId, String packageName, String activityName)
        throws Exception {
        wakeupAndDismissKeyguard();
        String command = ""am start -W --user "" + userId + "" "" + packageName + ""/"" + activityName;
        getDevice().executeShellCommand(command);
    }

    protected String getDefaultLauncher() throws Exception {
        final CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();
        getDevice().executeShellCommand(""dumpsys role --proto"", receiver);

        RoleUserStateProto roleState = null;
        final RoleServiceDumpProto dumpProto =
                RoleServiceDumpProto.parser().parseFrom(receiver.getOutput());
        for (RoleUserStateProto userState : dumpProto.getUserStatesList()) {
            if (getDevice().getCurrentUser() == userState.getUserId()) {
                roleState = userState;
                break;
            }
        }

        if (roleState != null) {
            final List<RoleProto> roles = roleState.getRolesList();
            // Iterate through the roles until we find the Home role
            for (RoleProto roleProto : roles) {
                if (""android.app.role.HOME"".equals(roleProto.getName())) {
                    assertEquals(1, roleProto.getHoldersList().size());
                    return roleProto.getHoldersList().get(0);
                }
            }
        }

        throw new Exception(""Default launcher not found"");
    }

    void assumeIsDeviceAb() throws DeviceNotAvailableException {
        final String result = getDevice().executeShellCommand(""getprop ro.build.ab_update"").trim();
        assumeTrue(""not device AB"", ""true"".equalsIgnoreCase(result));
    }

    // TODO (b/174775905) remove after exposing the check from ITestDevice.
    boolean isHeadlessSystemUserMode() throws DeviceNotAvailableException {
        return isHeadlessSystemUserMode(getDevice());
    }

    // TODO (b/174775905) remove after exposing the check from ITestDevice.
    public static boolean isHeadlessSystemUserMode(ITestDevice device)
            throws DeviceNotAvailableException {
        final String result = device
                .executeShellCommand(""getprop ro.fw.mu.headless_system_user"").trim();
        return ""true"".equalsIgnoreCase(result);
    }

    protected void assumeHeadlessSystemUserMode(String reason)
            throws DeviceNotAvailableException {
        assumeTrue(""Skipping test on non-headless system user mode. Reason: "" + reason,
                isHeadlessSystemUserMode());
    }

    protected void grantDpmWrapperPermissions(String deviceAdminPkg, int userId) throws Exception {
        // TODO(b/176993670): INTERACT_ACROSS_USERS is needed by DevicePolicyManagerWrapper to
        // send ordered broadcasts to the test user. The permission is already available to the
        // packages installed by the host side test (as they're installed with -g), but need to be
        // granted for users created by the test, as the package is intalled by code
        // (DPMS.manageUserUnchecked(), which doesn't grant it (as this is a privileged permission
        // that's not available to 3rd party apps). If we get rid of DevicePolicyManagerWrapper,
        // we won't need to grant it anymore.
        grantPermission(deviceAdminPkg, PERMISSION_INTERACT_ACROSS_USERS, userId, ""its PO needs to ""
                + ""send ordered broadcasts to user 0"");

        // Probably not needed anymore, but it doesn't hurt to keep...
        allowTestApiAccess(deviceAdminPkg);
    }

    protected void allowTestApiAccess(String deviceAdminPkg) throws Exception {
        CLog.i(""Granting ALLOW_TEST_API_ACCESS to package %s"", deviceAdminPkg);
        executeShellCommand(""am compat enable ALLOW_TEST_API_ACCESS %s"", deviceAdminPkg);
    }

    protected void grantPermission(String pkg, String permission, int userId, String reason)
            throws Exception {
        CLog.i(""Granting permission %s to package (%s) on user %d%s"", pkg, permission, userId,
                (reason == null ? """" : ""(reason: "" + reason + "")""));
        executeShellCommand(""pm grant --user %d %s %s"", userId, pkg, permission);
    }

    protected void revokePermission(String pkg, String permission, int userId) throws Exception {
        CLog.i(""Revoking permission %s to package (%s) on user %d"", pkg, permission, userId);
        executeShellCommand(""pm revoke --user %d %s %s"", userId, pkg, permission);
    }

    /** Find effective restriction for user */
    protected boolean isRestrictionSetOnUser(int userId, String restriction) throws Exception {
        String commandOutput = getDevice().executeShellCommand(""dumpsys user"");
        String[] outputLines = commandOutput.split(""\\n"");
        Pattern userPattern = Pattern.compile(""(^.*)UserInfo\\{"" + userId + "":.*$"");
        Pattern restrictionPattern = Pattern.compile(""(^.*)Effective\\srestrictions\\:.*$"");

        boolean userFound = false;
        boolean restrictionsFound = false;
        int lastIndent = -1;

        for (String line : outputLines) {
            // Starting a new block of user infos
            if (!line.startsWith(Strings.repeat("" "", lastIndent + 1))) {
                CLog.d(""User %d restrictions found, no matched restriction."", userId);
                return false;
            }
            //First, try matching user pattern
            Matcher userMatcher = userPattern.matcher(line);
            if (userMatcher.find()) {
                CLog.d(""User %d found in dumpsys, finding restrictions."", userId);
                userFound = true;
                lastIndent = userMatcher.group(1).length();
            }

            // Second, try matching restriction
            Matcher restrictionMatcher = restrictionPattern.matcher(line);
            if (userFound && restrictionMatcher.find()) {
                CLog.d(""User %d restrictions found, finding exact restriction."", userId);
                restrictionsFound = true;
                lastIndent = restrictionMatcher.group(1).length();
            }

            if (restrictionsFound && line.contains(restriction)) {
                return true;
            }
        }
        if (!userFound) {
            CLog.e(""User %d not found in dumpsys."", userId);
        }
        if (!restrictionsFound) {
            CLog.d(""User %d found in dumpsys, but restrictions not found."", userId);
        }
        return false;
    }

    /**
     * Generates instrumentation arguments that indicate the device-side test is exercising device
     * owner APIs.
     *
     * <p>This is needed for hostside tests that use the same class hierarchy for both device and
     * profile owner tests, as on headless system user mode the test side must decide whether to
     * use its ""local DPC"" or wrap the calls to the system user DPC.
     */
    protected static Map<String, String> getParamsForDeviceOwnerTest() {
        Map<String, String> params = new HashMap<>();
        params.put(""admin_type"", ""DeviceOwner"");
        return params;
    }

    boolean isTv() throws DeviceNotAvailableException {
        return hasDeviceFeature(FEATURE_LEANBACK);
    }

    void pushUpdateFileToDevice(String fileName)
            throws IOException, DeviceNotAvailableException {
        File file = File.createTempFile(
                fileName.split(""\\."")[0], ""."" + fileName.split(""\\."")[1]);
        try (OutputStream outputStream = new FileOutputStream(file)) {
            InputStream inputStream = getClass().getResourceAsStream(""/"" + fileName);
            ByteStreams.copy(inputStream, outputStream);
        }

        getDevice().pushFile(file, TEST_UPDATE_LOCATION + ""/"" + fileName);
        file.delete();
    }

    boolean hasService(String service) {
        String command = ""service check "" + service;
        try {
            String commandOutput = getDevice().executeShellCommand(command);
            return !commandOutput.contains(""not found"");
        } catch (Exception e) {
            CLog.w(""Exception running '"" + command + ""': "" + e);
            return false;
        }
    }

    void sleep(int timeMs) throws InterruptedException {
        CLog.d(""Sleeping %d ms"");
        Thread.sleep(timeMs);
    }
}"	""	""	"NFC DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.media.cts.AudioPlaybackConfigurationTest"	"testGetterMediaPlayer"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioPlaybackConfigurationTest.java"	""	"public void testGetterMediaPlayer() throws Exception {
        if (!isValidPlatform(""testGetterMediaPlayer"")) return;

        AudioManager am = new AudioManager(getContext());
        assertNotNull(""Could not create AudioManager"", am);

        final AudioAttributes aa = (new AudioAttributes.Builder())
                .setUsage(TEST_USAGE)
                .setContentType(TEST_CONTENT)
                .setAllowedCapturePolicy(ALLOW_CAPTURE_BY_ALL)
                .build();

        List<AudioPlaybackConfiguration> configs = am.getActivePlaybackConfigurations();
        final int nbActivePlayersBeforeStart = configs.size();

        Preconditions.assertTestFileExists(mInpPrefix + ""sine1khzs40dblong.mp3"");
        mMp = createPreparedMediaPlayer(
                Uri.fromFile(new File(mInpPrefix + ""sine1khzs40dblong.mp3"")), aa,
                am.generateAudioSessionId());
        configs = am.getActivePlaybackConfigurations();
        assertEquals(""inactive MediaPlayer, number of configs shouldn't have changed"",
                nbActivePlayersBeforeStart /*expected*/, configs.size());

        mMp.start();
        Thread.sleep(TEST_TIMING_TOLERANCE_MS);// waiting for playback to start
        configs = am.getActivePlaybackConfigurations();
        assertEquals(""active MediaPlayer, number of configs should have increased"",
                nbActivePlayersBeforeStart + 1 /*expected*/,
                configs.size());
        assertTrue(""Active player, attributes not found"", hasAttr(configs, aa));

        // verify ""privileged"" fields aren't available through reflection
        final AudioPlaybackConfiguration config = configs.get(0);
        final Class<?> confClass = config.getClass();
        final Method getClientUidMethod = confClass.getDeclaredMethod(""getClientUid"");
        final Method getClientPidMethod = confClass.getDeclaredMethod(""getClientPid"");
        final Method getPlayerTypeMethod = confClass.getDeclaredMethod(""getPlayerType"");
        final Method getSessionIdMethod = confClass.getDeclaredMethod(""getSessionId"");
        try {
            Integer uid = (Integer) getClientUidMethod.invoke(config, (Object[]) null);
            assertEquals(""uid isn't protected"", -1 /*expected*/, uid.intValue());
            Integer pid = (Integer) getClientPidMethod.invoke(config, (Object[]) null);
            assertEquals(""pid isn't protected"", -1 /*expected*/, pid.intValue());
            Integer type = (Integer) getPlayerTypeMethod.invoke(config, (Object[]) null);
            assertEquals(""player type isn't protected"", -1 /*expected*/, type.intValue());
            Integer sessionId = (Integer) getSessionIdMethod.invoke(config, (Object[]) null);
            assertEquals(""session ID isn't protected"", 0 /*expected*/, sessionId.intValue());
        } catch (Exception e) {
            fail(""Exception thrown during reflection on config privileged fields""+ e);
        }
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2020_0073"	"testPocCVE_2020_0073"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2020_0073.java"	""	"@AsbSecurityTest(cveBugId = 147309942)
    public void testPocCVE_2020_0073() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        String binaryName = ""CVE-2020-0073"";
        String signals[] = {CrashUtils.SIGSEGV, CrashUtils.SIGBUS, CrashUtils.SIGABRT};
        AdbUtils.pocConfig testConfig = new AdbUtils.pocConfig(binaryName, getDevice());
        testConfig.config = new CrashUtils.Config().setProcessPatterns(binaryName);
        testConfig.config.setSignals(signals);
        AdbUtils.runPocAssertNoCrashesNotVulnerable(testConfig);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.ByodFlowTestActivity"	"ByodFlowTestActivity"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/ByodFlowTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.app.KeyguardManager;
import android.app.admin.DevicePolicyManager;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.provider.Settings;
import android.util.Log;
import android.widget.Toast;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.DialogTestListActivity;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListActivity;
import com.android.cts.verifier.TestListAdapter.TestListItem;
import com.android.cts.verifier.TestResult;

/**
 * CTS verifier test for BYOD managed provisioning flow
 *
 * This activity is responsible for starting the managed provisioning flow and verify the outcome of
 * provisioning. It performs the following verifications:
 *   Full disk encryption is enabled.
 *   Profile owner is correctly installed.
 *   Profile owner shows up in the Settings app.
 *   Badged work apps show up in launcher.
 * The first two verifications are performed automatically, by interacting with profile owner using
 * cross-profile intents, while the last two are carried out manually by the user.
 */
public class ByodFlowTestActivity extends DialogTestListActivity {

    // Action for delivering sub-test result from the profile.
    public static final String ACTION_TEST_RESULT =
            ""com.android.cts.verifier.managedprovisioning.BYOD_TEST_RESULT"";
    // Extra for ACTION_TEST_RESULT containing test result.
    public static final String EXTRA_RESULT = ""extra-result"";
    protected static final String HELPER_APP_PATH = ""/data/local/tmp/NotificationBot.apk"";

    private static final String TAG = ""ByodFlowTestActivity"";
    private static final int PROVISIONING_CHECK_PERIOD_MS = 3000;
    private static ConnectivityManager mCm;
    private static final int REQUEST_MANAGED_PROVISIONING = 0;
    private static final int REQUEST_PROFILE_OWNER_STATUS = 1;
    private static final int REQUEST_INTENT_FILTERS_STATUS = 2;
    private static final int REQUEST_CHECK_DISK_ENCRYPTION = 3;
    private static final int REQUEST_SET_LOCK_FOR_ENCRYPTION = 4;

    private static final String PROVISIONING_PREFERENCES = ""provisioning_preferences"";
    private static final String PREFERENCE_PROVISIONING_COMPLETE_STATUS =
            ""provisioning_complete_status"";
    private static final int PREFERENCE_PROVISIONING_COMPLETE_STATUS_NOT_RECEIVED = 0;
    private static final int PREFERENCE_PROVISIONING_COMPLETE_STATUS_RECEIVED = 1;
    private static final int PREFERENCE_PROVISIONING_COMPLETE_STATUS_PROCESSED = 2;

    private ComponentName mAdminReceiverComponent;
    private KeyguardManager mKeyguardManager;
    private ByodFlowTestHelper mByodFlowTestHelper;

    private DialogTestListItem mProfileOwnerInstalled;
    private DialogTestListItem mDiskEncryptionTest;
    private DialogTestListItem mProfileAccountVisibleTest;
    private DialogTestListItem mDeviceAdminVisibleTest;
    private DialogTestListItem mWorkAppVisibleTest;
    private DialogTestListItem mCrossProfileIntentFiltersTestFromPersonal;
    private DialogTestListItem mCrossProfileIntentFiltersTestFromWork;
    private TestListItem mCrossProfilePermissionControl;
    private DialogTestListItem mAppLinkingTest;
    private TestListItem mNonMarketAppsTest;
    private DialogTestListItem mWorkNotificationBadgedTest;
    private DialogTestListItem mWorkStatusBarIconTest;
    private DialogTestListItem mWorkStatusBarToastTest;
    private DialogTestListItem mUserSettingsVisibleTest;
    private DialogTestListItem mAppSettingsVisibleTest;
    private DialogTestListItem mLocationSettingsVisibleTest;
    private DialogTestListItem mWiFiDataUsageSettingsVisibleTest;
    private DialogTestListItem mCellularDataUsageSettingsVisibleTest;
    private DialogTestListItem mCredSettingsVisibleTest;
    private DialogTestListItem mPrintSettingsVisibleTest;
    private DialogTestListItem mIntentFiltersTest;
    private DialogTestListItem mPermissionLockdownTest;
    private DialogTestListItem mCrossProfileImageCaptureSupportTest;
    private DialogTestListItem mCrossProfileVideoCaptureWithExtraOutputSupportTest;
    private DialogTestListItem mCrossProfileVideoCaptureWithoutExtraOutputSupportTest;
    private DialogTestListItem mCrossProfileAudioCaptureSupportTest;
    private TestListItem mKeyguardDisabledFeaturesTest;
    private DialogTestListItem mDisableNfcBeamTest;
    private TestListItem mAuthenticationBoundKeyTest;
    private TestListItem mEnableLocationModeTest;
    private TestListItem mDisableLocationModeThroughMainSwitchTest;
    private TestListItem mDisableLocationModeThroughWorkSwitchTest;
    private TestListItem mPrimaryLocationWhenWorkDisabledTest;
    private DialogTestListItem mSelectWorkChallenge;
    private DialogTestListItem mConfirmWorkCredentials;
    private DialogTestListItem mPatternWorkChallenge;
    private DialogTestListItem mParentProfilePassword;
    private DialogTestListItem mPersonalRingtonesTest;
    private TestListItem mVpnTest;
    private TestListItem mKeyChainTest;
    private TestListItem mAlwaysOnVpnSettingsTest;
    private TestListItem mRecentsTest;
    private TestListItem mDisallowAppsControlTest;
    private TestListItem mOrganizationInfoTest;
    private TestListItem mPolicyTransparencyTest;
    private TestListItem mTurnOffWorkFeaturesTest;
    private TestListItem mWidgetTest;
    private final Handler mHandler = new Handler(Looper.myLooper());

    private final Runnable mPeriodicProvisioningCheckRunnable = new Runnable() {
        @Override
        public void run() {
            if (isProvisioningCompleteBroadcastReceived(getApplicationContext())) {
                markProvisioningCompleteBroadcastProcessed(getApplicationContext());
                queryProfileOwner(true);
            } else {
                mHandler.postDelayed(this, PROVISIONING_CHECK_PERIOD_MS);
            }
        }
    };

    public static class ProvisioningCompleteReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            markProvisioningCompleteBroadcastReceived(context);
        }
    }

    public ByodFlowTestActivity() {
        super(R.layout.provisioning_byod,
                R.string.provisioning_byod, R.string.provisioning_byod_info,
                R.string.provisioning_byod_instructions);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mByodFlowTestHelper = new ByodFlowTestHelper(this);
        mAdminReceiverComponent = new ComponentName(this, DeviceAdminTestReceiver.class.getName());
        mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);

        mByodFlowTestHelper.setup();

        mPrepareTestButton.setText(R.string.provisioning_byod_start);
        mPrepareTestButton.setOnClickListener(v -> Utils.provisionManagedProfile(
                ByodFlowTestActivity.this, mAdminReceiverComponent,
                REQUEST_MANAGED_PROVISIONING));

        // If we are started by managed provisioning (fresh managed provisioning after encryption
        // reboot), redirect the user back to the main test list. This is because the test result
        // is only saved by the parent TestListActivity, and if we did allow the user to proceed
        // here, the test result would be lost when this activity finishes.
        if (ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS.equals(getIntent().getAction())) {
            startActivity(new Intent(this, TestListActivity.class));
            // Calling super.finish() because we delete managed profile in our overridden of finish(),
            // which is not what we want to do here.
            super.finish();
        } else {
            queryProfileOwner(false);
        }
    }

    @Override
    protected void onStart() {
        super.onStart();
        startPeriodicProvisioningCheckIfNecessary();
    }

    private void startPeriodicProvisioningCheckIfNecessary() {
        if (mHandler.hasCallbacks(mPeriodicProvisioningCheckRunnable)) {
            return;
        }
        if (!isProvisioningCompleteBroadcastProcessed(this)) {
            mHandler.post(mPeriodicProvisioningCheckRunnable);
        }
    }

    @Override
    protected void onStop() {
        super.onStop();
        mHandler.removeCallbacks(mPeriodicProvisioningCheckRunnable);
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        if (ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS.equals(intent.getAction())) {
            // This is called when managed provisioning completes successfully without reboot.
            handleStatusUpdate(RESULT_OK, intent);
        } else if (ACTION_TEST_RESULT.equals(intent.getAction())) {
            // Called when subtest cannot communicate test result from the profile via setResult().
            handleLaunchTestResult(RESULT_OK, intent.getParcelableExtra(EXTRA_RESULT));
        }
    }

    @Override
    protected void handleActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_MANAGED_PROVISIONING:
                return;
            case REQUEST_PROFILE_OWNER_STATUS:
                // Called after queryProfileOwner()
                handleStatusUpdate(resultCode, data);
                break;
            case REQUEST_CHECK_DISK_ENCRYPTION:
                // Called after checkDiskEncryption()
                handleDiskEncryptionStatus(resultCode, data);
                break;
            case REQUEST_SET_LOCK_FOR_ENCRYPTION:
                // Called after handleDiskEncryptionStatus() to set screen lock if necessary
                handleSetLockForEncryption();
                break;
            case REQUEST_INTENT_FILTERS_STATUS:
                // Called after checkIntentFilters()
                handleIntentFiltersStatus(resultCode);
                break;
            default:
                super.handleActivityResult(requestCode, resultCode, data);
        }
    }

    private void handleStatusUpdate(int resultCode, Intent data) {
        boolean provisioned = data != null &&
                data.getBooleanExtra(ByodHelperActivity.EXTRA_PROVISIONED, false);
        setProfileOwnerTestResult((provisioned && resultCode == RESULT_OK) ?
                TestResult.TEST_RESULT_PASSED : TestResult.TEST_RESULT_FAILED);
    }

    @Override
    public void finish() {
        // Pass and fail buttons are known to call finish() when clicked, and this is when we want to
        // clean up the provisioned profile.
        mByodFlowTestHelper.tearDown();
        super.finish();
    }

    @Override
    protected void setupTests(ArrayTestListAdapter adapter) {
        mProfileOwnerInstalled = new DialogTestListItem(this,
                R.string.provisioning_byod_profileowner,
                ""BYOD_ProfileOwnerInstalled"") {
            @Override
            public void performTest(DialogTestListActivity activity) {
                queryProfileOwner(true);
            }
        };

        mDiskEncryptionTest = new DialogTestListItem(this,
                R.string.provisioning_byod_disk_encryption,
                ""BYOD_DiskEncryptionTest"") {
            @Override
            public void performTest(DialogTestListActivity activity) {
                checkDiskEncryption();
            }
        };

        /*
         * To keep the image in this test up to date, use the instructions in
         * {@link ByodIconSamplerActivity}.
         */

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            mWorkAppVisibleTest = new DialogTestListItemWithIcon(this,
                    R.string.provisioning_byod_workapps_visible,
                    ""BYOD_WorkAppVisibleTest"",
                    R.string.provisioning_byod_workapps_visible_instruction,
                    new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME),
                    R.drawable.badged_icon);

            mConfirmWorkCredentials = new DialogTestListItem(this,
                    R.string.provisioning_byod_confirm_work_credentials,
                    ""BYOD_ConfirmWorkCredentials"",
                    R.string.provisioning_byod_confirm_work_credentials_description,
                    new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME));

            mPatternWorkChallenge = new DialogTestListItem(this,
                    R.string.provisioning_byod_pattern_work_challenge,
                    ""BYOD_PatternWorkChallenge"",
                    R.string.provisioning_byod_pattern_work_challenge_description,
                    new Intent(ByodHelperActivity.ACTION_TEST_PATTERN_WORK_CHALLENGE));

            mWiFiDataUsageSettingsVisibleTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_wifi_data_usage_settings,
                    ""BYOD_WiFiDataUsageSettingsVisibleTest"",
                    R.string.provisioning_byod_wifi_data_usage_settings_instruction,
                    new Intent(Settings.ACTION_SETTINGS));
        }

        mWorkNotificationBadgedTest = new DialogTestListItemWithIcon(this,
                R.string.provisioning_byod_work_notification,
                ""BYOD_WorkNotificationBadgedTest"",
                R.string.provisioning_byod_work_notification_instruction,
                new Intent(ByodHelperActivity.ACTION_NOTIFICATION),
                R.drawable.ic_corp_icon);

        Intent workStatusIcon = new Intent(WorkStatusTestActivity.ACTION_WORK_STATUS_ICON);
        workStatusIcon.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mWorkStatusBarIconTest = new DialogTestListItemWithIcon(this,
                R.string.provisioning_byod_work_status_icon,
                ""BYOD_WorkStatusBarIconTest"",
                R.string.provisioning_byod_work_status_icon_instruction,
                workStatusIcon,
                R.drawable.stat_sys_managed_profile_status);

        /* Disable due to b/111734436.
        Intent workStatusToast = new Intent(WorkStatusTestActivity.ACTION_WORK_STATUS_TOAST);
        workStatusToast.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mWorkStatusBarToastTest = new DialogTestListItem(this,
                R.string.provisioning_byod_work_status_toast,
                ""BYOD_WorkStatusBarToastTest"",
                R.string.provisioning_byod_work_status_toast_instruction,
                workStatusToast);
        */

        mNonMarketAppsTest = TestListItem.newTest(this,
                R.string.provisioning_byod_non_market_apps,
                NonMarketAppsActivity.class.getName(),
                new Intent(this, NonMarketAppsActivity.class), null);

        mProfileAccountVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_profile_visible,
                ""BYOD_ProfileAccountVisibleTest"",
                R.string.provisioning_byod_profile_visible_instruction,
                new Intent(Settings.ACTION_SETTINGS));

        mUserSettingsVisibleTest = new DialogTestListItem(this,
            R.string.provisioning_byod_user_settings,
            ""BYOD_UserSettingsVisibleTest"",
            R.string.provisioning_byod_user_settings_instruction,
            new Intent(Settings.ACTION_SETTINGS));

        mAppSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_app_settings,
                ""BYOD_AppSettingsVisibleTest"",
                R.string.provisioning_byod_app_settings_instruction,
                new Intent(Settings.ACTION_APPLICATION_SETTINGS));

        mDeviceAdminVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_admin_visible,
                ""BYOD_DeviceAdminVisibleTest"",
                R.string.provisioning_byod_admin_visible_instruction,
                new Intent(Settings.ACTION_SECURITY_SETTINGS));

        mCredSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_cred_settings,
                ""BYOD_CredSettingsVisibleTest"",
                R.string.provisioning_byod_cred_settings_instruction,
                new Intent(Settings.ACTION_SECURITY_SETTINGS));

        mLocationSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_location_settings,
                ""BYOD_LocationSettingsVisibleTest"",
                R.string.provisioning_byod_location_settings_instruction,
                new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS));

        mCellularDataUsageSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_cellular_data_usage_settings,
                ""BYOD_CellularDataUsageSettingsVisibleTest"",
                R.string.provisioning_byod_cellular_data_usage_settings_instruction,
                new Intent(Settings.ACTION_SETTINGS));

        mPrintSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_print_settings,
                ""BYOD_PrintSettingsVisibleTest"",
                R.string.provisioning_byod_print_settings_instruction,
                new Intent(Settings.ACTION_PRINT_SETTINGS));

        Intent intent = new Intent(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_WORK);
        intent.putExtra(CrossProfileTestActivity.EXTRA_STARTED_FROM_WORK, false);
        Intent chooser = Intent.createChooser(intent,
                getResources().getString(R.string.provisioning_cross_profile_chooser));
        mCrossProfileIntentFiltersTestFromPersonal = new DialogTestListItem(this,
                R.string.provisioning_byod_cross_profile_from_personal,
                ""BYOD_CrossProfileIntentFiltersTestFromPersonal"",
                R.string.provisioning_byod_cross_profile_from_personal_instruction,
                chooser);

        mCrossProfileIntentFiltersTestFromWork = new DialogTestListItem(this,
                R.string.provisioning_byod_cross_profile_from_work,
                ""BYOD_CrossProfileIntentFiltersTestFromWork"",
                R.string.provisioning_byod_cross_profile_from_work_instruction,
                new Intent(ByodHelperActivity.ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG));

        /* Disable due to b/33571176
        mAppLinkingTest = new DialogTestListItem(this,
                R.string.provisioning_app_linking,
                ""BYOD_AppLinking"",
                R.string.provisioning_byod_app_linking_instruction,
                new Intent(ByodHelperActivity.ACTION_TEST_APP_LINKING_DIALOG));
        */

        mKeyguardDisabledFeaturesTest = TestListItem.newTest(this,
                R.string.provisioning_byod_keyguard_disabled_features,
                KeyguardDisabledFeaturesActivity.class.getName(),
                new Intent(this, KeyguardDisabledFeaturesActivity.class), null);

        mAuthenticationBoundKeyTest = TestListItem.newTest(this,
                R.string.provisioning_byod_auth_bound_key,
                AuthenticationBoundKeyTestActivity.class.getName(),
                new Intent(AuthenticationBoundKeyTestActivity.ACTION_AUTH_BOUND_KEY_TEST),
                null);

        mVpnTest = TestListItem.newTest(this,
                R.string.provisioning_byod_vpn,
                VpnTestActivity.class.getName(),
                new Intent(VpnTestActivity.ACTION_VPN),
                null);

        mAlwaysOnVpnSettingsTest = TestListItem.newTest(this,
                R.string.provisioning_byod_always_on_vpn,
                AlwaysOnVpnSettingsTestActivity.class.getName(),
                new Intent(AlwaysOnVpnSettingsTestActivity.ACTION_ALWAYS_ON_VPN_SETTINGS_TEST),
                null);

        mDisallowAppsControlTest = TestListItem.newTest(this,
                R.string.provisioning_byod_disallow_apps_control,
                DisallowAppsControlActivity.class.getName(),
                new Intent(this, DisallowAppsControlActivity.class), null);

        // Test for checking if the required intent filters are set during managed provisioning.
        mIntentFiltersTest = new DialogTestListItem(this,
                R.string.provisioning_byod_cross_profile_intent_filters,
                ""BYOD_IntentFiltersTest"") {
            @Override
            public void performTest(DialogTestListActivity activity) {
                checkIntentFilters();
            }
        };

        mCrossProfilePermissionControl = TestListItem.newTest(this,
                R.string.provisioning_byod_cross_profile_permission_control,
                CrossProfilePermissionControlActivity.class.getName(),
                new Intent(
                        CrossProfilePermissionControlActivity.ACTION_CROSS_PROFILE_PERMISSION_CONTROL),
                        null);

        mTurnOffWorkFeaturesTest = TestListItem.newTest(this,
                R.string.provisioning_byod_turn_off_work,
                TurnOffWorkActivity.class.getName(),
                new Intent(this, TurnOffWorkActivity.class), null);

        Intent permissionCheckIntent = new Intent(
                PermissionLockdownTestActivity.ACTION_MANAGED_PROFILE_CHECK_PERMISSION_LOCKDOWN);
        mPermissionLockdownTest = new DialogTestListItem(this,
                R.string.device_profile_owner_permission_lockdown_test,
                ""BYOD_PermissionLockdownTest"",
                R.string.profile_owner_permission_lockdown_test_info,
                permissionCheckIntent);

        mSelectWorkChallenge = new DialogTestListItem(this,
                R.string.provisioning_byod_select_work_challenge,
                ""BYOD_SelectWorkChallenge"",
                R.string.provisioning_byod_select_work_challenge_description,
                new Intent(ByodHelperActivity.ACTION_TEST_SELECT_WORK_CHALLENGE));

        mRecentsTest = TestListItem.newTest(this,
                R.string.provisioning_byod_recents,
                RecentsRedactionActivity.class.getName(),
                new Intent(RecentsRedactionActivity.ACTION_RECENTS).setFlags(
                        Intent.FLAG_ACTIVITY_NEW_TASK),
                null);

        mOrganizationInfoTest = TestListItem.newTest(this,
                R.string.provisioning_byod_organization_info,
                OrganizationInfoTestActivity.class.getName(),
                new Intent(this, OrganizationInfoTestActivity.class),
                null);

        mKeyChainTest = TestListItem.newTest(this,
                R.string.provisioning_byod_keychain,
                KeyChainTestActivity.class.getName(),
                new Intent(KeyChainTestActivity.ACTION_KEYCHAIN),
                null);

        mParentProfilePassword = new DialogTestListItem(this,
                R.string.provisioning_byod_parent_profile_password,
                ""BYOD_ParentProfilePasswordTest"",
                R.string.provisioning_byod_parent_profile_password_description,
                new Intent(ByodHelperActivity.ACTION_TEST_PARENT_PROFILE_PASSWORD));

        mPersonalRingtonesTest = new DialogTestListItem(this,
                R.string.provisioning_byod_personal_ringtones,
                ""BYOD_PersonalRingtones"",
                R.string.provisioning_byod_personal_ringtones_instruction,
                new Intent(Settings.ACTION_SOUND_SETTINGS));

        final Intent policyTransparencyTestIntent = new Intent(this,
                PolicyTransparencyTestListActivity.class);
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestListActivity.EXTRA_MODE,
                PolicyTransparencyTestListActivity.MODE_MANAGED_PROFILE);
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestActivity.EXTRA_TEST_ID, ""BYOD_PolicyTransparency"");
        mPolicyTransparencyTest = TestListItem.newTest(this,
                R.string.device_profile_owner_policy_transparency_test,
                ""BYOD_PolicyTransparency"",
                policyTransparencyTestIntent, null);

        adapter.add(mProfileOwnerInstalled);
        adapter.add(mDiskEncryptionTest);

        // Badge related tests
        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(mWorkAppVisibleTest);
        }

        adapter.add(mWorkNotificationBadgedTest);
        adapter.add(mWorkStatusBarIconTest);

        /* Disable due to b/111734436.
        adapter.add(mWorkStatusBarToastTest);
        */

        // Settings related tests.
        adapter.add(mProfileAccountVisibleTest);
        adapter.add(mDeviceAdminVisibleTest);
        adapter.add(mCredSettingsVisibleTest);
        adapter.add(mUserSettingsVisibleTest);
        adapter.add(mAppSettingsVisibleTest);
        adapter.add(mLocationSettingsVisibleTest);
        adapter.add(mPrintSettingsVisibleTest);
        adapter.add(mPersonalRingtonesTest);

        adapter.add(mCrossProfileIntentFiltersTestFromPersonal);
        adapter.add(mCrossProfileIntentFiltersTestFromWork);
        /* Disable due to b/33571176
        adapter.add(mAppLinkingTest);
        */
        adapter.add(mIntentFiltersTest);
        adapter.add(mCrossProfilePermissionControl);
        adapter.add(mNonMarketAppsTest);
        adapter.add(mPermissionLockdownTest);
        adapter.add(mKeyguardDisabledFeaturesTest);
        adapter.add(mAuthenticationBoundKeyTest);
        adapter.add(mVpnTest);
        adapter.add(mAlwaysOnVpnSettingsTest);
        adapter.add(mTurnOffWorkFeaturesTest);
        adapter.add(mSelectWorkChallenge);
        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(mConfirmWorkCredentials);
            adapter.add(mPatternWorkChallenge);
        }
        adapter.add(mRecentsTest);
        adapter.add(mOrganizationInfoTest);
        adapter.add(mParentProfilePassword);
        adapter.add(mPolicyTransparencyTest);

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI)) {
                adapter.add(mWiFiDataUsageSettingsVisibleTest);
            }
        }

        mCm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
        if(mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) != null) {
            adapter.add(mCellularDataUsageSettingsVisibleTest);
        }

        if (canResolveIntent(new Intent(Settings.ACTION_APPLICATION_SETTINGS))) {
            adapter.add(mDisallowAppsControlTest);
        }

        /* If there is an application that handles ACTION_IMAGE_CAPTURE, test that it handles it
         * well.
         */
        if (canResolveIntent(ByodHelperActivity.getCaptureImageIntent())) {
            // Capture image intent can be resolved in primary profile, so test.
            mCrossProfileImageCaptureSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_image_support,
                    ""BYOD_CrossProfileImageCaptureSupportTest"",
                    R.string.provisioning_byod_capture_image_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_IMAGE));
            adapter.add(mCrossProfileImageCaptureSupportTest);
        } else {
            // Capture image intent cannot be resolved in primary profile, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_image_capture_resolver, Toast.LENGTH_SHORT)
                    .show();
        }

        /* If there is an application that handles ACTION_VIDEO_CAPTURE, test that it handles it
         * well.
         */
        if (canResolveIntent(ByodHelperActivity.getCaptureVideoIntent())) {
            // Capture video intent can be resolved in primary profile, so test.
            mCrossProfileVideoCaptureWithExtraOutputSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_video_support_with_extra_output,
                    ""BYOD_CrossProfileVideoCaptureWithExtraOutputSupportTest"",
                    R.string.provisioning_byod_capture_video_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT));
            adapter.add(mCrossProfileVideoCaptureWithExtraOutputSupportTest);
            mCrossProfileVideoCaptureWithoutExtraOutputSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_video_support_without_extra_output,
                    ""BYOD_CrossProfileVideoCaptureWithoutExtraOutputSupportTest"",
                    R.string.provisioning_byod_capture_video_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT));
            adapter.add(mCrossProfileVideoCaptureWithoutExtraOutputSupportTest);
        } else {
            // Capture video intent cannot be resolved in primary profile, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_video_capture_resolver, Toast.LENGTH_SHORT)
                    .show();
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC)
                && getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_BEAM)) {
            mDisableNfcBeamTest = new DialogTestListItem(this, R.string.provisioning_byod_nfc_beam,
                    ""BYOD_DisableNfcBeamTest"",
                    R.string.provisioning_byod_nfc_beam_allowed_instruction,
                    new Intent(ByodHelperActivity.ACTION_TEST_NFC_BEAM)) {
                @Override
                public void performTest(final DialogTestListActivity activity) {
                    activity.showManualTestDialog(mDisableNfcBeamTest,
                            new DefaultTestCallback(mDisableNfcBeamTest) {
                        @Override
                        public void onPass() {
                            // Start a second test with beam disallowed by policy.
                            Intent testNfcBeamIntent = new Intent(
                                    ByodHelperActivity.ACTION_TEST_NFC_BEAM);
                            testNfcBeamIntent.putExtra(NfcTestActivity.EXTRA_DISALLOW_BY_POLICY,
                                    true);
                            DialogTestListItem disableNfcBeamTest2 =
                                    new DialogTestListItem(activity,
                                    R.string.provisioning_byod_nfc_beam,
                                    ""BYOD_DisableNfcBeamTest"",
                                    R.string.provisioning_byod_nfc_beam_disallowed_instruction,
                                    testNfcBeamIntent);
                            // The result should be reflected on the original test.
                            activity.showManualTestDialog(disableNfcBeamTest2,
                                    new DefaultTestCallback(mDisableNfcBeamTest));
                        }
                    });
                }
            };
            adapter.add(mDisableNfcBeamTest);
        }

        adapter.add(mKeyChainTest);

        /* If there is an application that handles RECORD_SOUND_ACTION, test that it handles it
         * well.
         */
        if (canResolveIntent(ByodHelperActivity.getCaptureAudioIntent())) {
            // Capture audio intent can be resolved in primary profile, so test.
            mCrossProfileAudioCaptureSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_audio_support,
                    ""BYOD_CrossProfileAudioCaptureSupportTest"",
                    R.string.provisioning_byod_capture_audio_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_AUDIO));
            adapter.add(mCrossProfileAudioCaptureSupportTest);
        } else {
            // Capture audio intent cannot be resolved in primary profile, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_audio_capture_resolver, Toast.LENGTH_SHORT)
                    .show();
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION_GPS)) {
            mEnableLocationModeTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_location_mode_enable,
                    LocationTestActivity.TEST_ID_LOCATION_ENABLED,
                    new Intent(LocationTestActivity.ACTION_TEST_LOCATION_ENABLED),
                    null);
            mDisableLocationModeThroughMainSwitchTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_location_mode_disable,
                    LocationTestActivity.TEST_ID_LOCATION_DISABLED,
                    new Intent(LocationTestActivity.ACTION_TEST_LOCATION_DISABLED),
                    null);
            mDisableLocationModeThroughWorkSwitchTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_work_location_mode_disable,
                    LocationTestActivity.TEST_ID_WORK_LOCATION_DISABLED,
                    new Intent(LocationTestActivity.ACTION_TEST_WORK_LOCATION_DISABLED),
                    null);
            mPrimaryLocationWhenWorkDisabledTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_primary_location_when_work_disabled,
                    LocationTestActivity.TEST_ID_WORK_LOCATION_DISABLED_PRIMARY,
                    new Intent(LocationTestActivity.ACTION_TEST_WORK_LOCATION_DISABLED_PRIMARY),
                    null);
            adapter.add(mEnableLocationModeTest);
            adapter.add(mDisableLocationModeThroughMainSwitchTest);
            adapter.add(mDisableLocationModeThroughWorkSwitchTest);
            adapter.add(mPrimaryLocationWhenWorkDisabledTest);
        } else {
            // The system does not support GPS feature, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_gps_location_feature, Toast.LENGTH_SHORT)
                    .show();
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
            mWidgetTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_work_profile_widget,
                    WorkProfileWidgetActivity.class.getName(),
                    new Intent(WorkProfileWidgetActivity.ACTION_TEST_WORK_PROFILE_WIDGET),
                    new String[]{PackageManager.FEATURE_APP_WIDGETS});
            adapter.add(mWidgetTest);
        }

        adapter.add(new DialogTestListItem(this,
                R.string.provisioning_byod_uninstall_work_app,
                ""BYOD_UninstallWorkApp"",
                R.string.provisioning_byod_uninstall_work_app_instruction,
                createInstallWorkProfileAppIntent()));
    }

    private Intent createInstallWorkProfileAppIntent() {
        // We place the APK file in /data/local/tmp to make it visible from the work profile.
        return new Intent(ByodHelperActivity.ACTION_INSTALL_APK)
                .putExtra(ByodHelperActivity.EXTRA_ALLOW_NON_MARKET_APPS, true)
                .putExtra(ByodHelperActivity.EXTRA_PARAMETER_1, HELPER_APP_PATH);
    }

    // Return whether the intent can be resolved in the current profile
    private boolean canResolveIntent(Intent intent) {
        return intent.resolveActivity(getPackageManager()) != null;
    }

    @Override
    protected void clearRemainingState(final DialogTestListItem test) {
        super.clearRemainingState(test);
        if (ByodHelperActivity.ACTION_NOTIFICATION.equals(
                test.getManualTestIntent().getAction())) {
            try {
                startActivity(new Intent(
                        ByodHelperActivity.ACTION_CLEAR_NOTIFICATION));
            } catch (ActivityNotFoundException e) {
                // User shouldn't run this test before work profile is set up.
            }
        }
    }

    private void queryProfileOwner(boolean showToast) {
        try {
            // Set execution start time for counting test execution time.
            mStartTime = System.currentTimeMillis();
            Intent intent = new Intent(ByodHelperActivity.ACTION_QUERY_PROFILE_OWNER);
            startActivityForResult(intent, REQUEST_PROFILE_OWNER_STATUS);
        }
        catch (ActivityNotFoundException e) {
            Log.d(TAG, ""queryProfileOwner: ActivityNotFoundException"", e);
            setProfileOwnerTestResult(TestResult.TEST_RESULT_FAILED);
            if (showToast) {
                Utils.showToast(this, R.string.provisioning_byod_no_activity);
            }
        }
    }

    private void setProfileOwnerTestResult(int result) {
        setTestResult(mProfileOwnerInstalled, result);
        if (result == TestResult.TEST_RESULT_FAILED) {
            clearProvisioningCompleteBroadcastStatus(this);
            startPeriodicProvisioningCheckIfNecessary();
        }
    }

    private void checkDiskEncryption() {
        try {
            Intent intent = new Intent(ByodHelperActivity.ACTION_CHECK_DISK_ENCRYPTION);
            startActivityForResult(intent, REQUEST_CHECK_DISK_ENCRYPTION);
        } catch (ActivityNotFoundException e) {
            Log.d(TAG, ""checkDiskEncryption: ActivityNotFoundException"", e);
            setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
            Utils.showToast(this, R.string.provisioning_byod_no_activity);
        }
    }

    private void handleDiskEncryptionStatus(int resultCode, Intent data) {
        if (resultCode != RESULT_OK || data == null) {
            Log.e(TAG, ""Failed to get result for disk encryption, result code: "" + resultCode);
            setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
            return;
        }

        final int status = data.getIntExtra(ByodHelperActivity.EXTRA_ENCRYPTION_STATUS,
                DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED);
        switch (status) {
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE:
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER:
                setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_PASSED);
                break;
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY:
                if (!mKeyguardManager.isDeviceSecure()) {
                    Utils.setScreenLock(this, REQUEST_SET_LOCK_FOR_ENCRYPTION);
                    return;
                }
                Log.e(TAG, ""Disk encryption key is not entangled with lock screen credentials"");
                Toast.makeText(this, R.string.provisioning_byod_disk_encryption_default_key_toast,
                        Toast.LENGTH_LONG).show();
                // fall through
            default:
                setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
        }

        if (mKeyguardManager.isDeviceSecure()) {
            Utils.removeScreenLock(this);
        }
    }

    private void handleSetLockForEncryption() {
        if (mKeyguardManager.isDeviceSecure()) {
            checkDiskEncryption();
        } else {
            setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
            Toast.makeText(this, R.string.provisioning_byod_disk_encryption_no_pin_toast,
                    Toast.LENGTH_LONG).show();
        }
    }

    private void checkIntentFilters() {
        try {
            // Enable component HandleIntentActivity before intent filters are checked.
            setHandleIntentActivityEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
            // We disable the ByodHelperActivity in the primary profile. So, this intent
            // will be handled by the ByodHelperActivity in the managed profile.
            Intent intent = new Intent(ByodHelperActivity.ACTION_CHECK_INTENT_FILTERS);
            startActivityForResult(intent, REQUEST_INTENT_FILTERS_STATUS);
        } catch (ActivityNotFoundException e) {
            // Disable component HandleIntentActivity if intent filters check fails.
            setHandleIntentActivityEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
            Log.d(TAG, ""checkIntentFilters: ActivityNotFoundException"", e);
            setTestResult(mIntentFiltersTest, TestResult.TEST_RESULT_FAILED);
            Utils.showToast(this, R.string.provisioning_byod_no_activity);
        }
    }

    private void handleIntentFiltersStatus(int resultCode) {
        // Disable component HandleIntentActivity after intent filters are checked.
        setHandleIntentActivityEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
        // we use the resultCode from ByodHelperActivity in the managed profile to know if certain
        // intents fired from the managed profile are forwarded.
        final boolean intentFiltersSetForManagedIntents = (resultCode == RESULT_OK);
        // Since the ByodFlowTestActivity is running in the primary profile, we directly use
        // the IntentFiltersTestHelper to know if certain intents fired from the primary profile
        // are forwarded.
        final boolean intentFiltersSetForPrimaryIntents =
                new IntentFiltersTestHelper(this).checkCrossProfileIntentFilters(
                        IntentFiltersTestHelper.FLAG_INTENTS_FROM_PRIMARY);
        final boolean intentFiltersSet =
                intentFiltersSetForPrimaryIntents & intentFiltersSetForManagedIntents;
        setTestResult(mIntentFiltersTest,
                intentFiltersSet ? TestResult.TEST_RESULT_PASSED : TestResult.TEST_RESULT_FAILED);
    }

    private void setHandleIntentActivityEnabledSetting(final int enableState) {
        getPackageManager().setComponentEnabledSetting(
            new ComponentName(ByodFlowTestActivity.this, HandleIntentActivity.class.getName()),
            enableState, PackageManager.DONT_KILL_APP);
    }

    private static void markProvisioningCompleteBroadcastReceived(Context context) {
        markProvisioningCompleteBroadcastWithStatus(context,
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_RECEIVED);
    }

    private static void markProvisioningCompleteBroadcastProcessed(Context context) {
        markProvisioningCompleteBroadcastWithStatus(context,
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_PROCESSED);
    }

    private static void clearProvisioningCompleteBroadcastStatus(Context context) {
        markProvisioningCompleteBroadcastWithStatus(context,
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_NOT_RECEIVED);
    }

    private static void markProvisioningCompleteBroadcastWithStatus(Context context, int status) {
        final SharedPreferences prefs = getProvisioningPreferences(context);
        final SharedPreferences.Editor editor = prefs.edit();
        editor.putInt(PREFERENCE_PROVISIONING_COMPLETE_STATUS, status);
        editor.commit();
    }

    private static boolean isProvisioningCompleteBroadcastReceived(Context context) {
        return getProvisioningPreferences(context)
                .getInt(PREFERENCE_PROVISIONING_COMPLETE_STATUS, 0) ==
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_RECEIVED;
    }

    private static boolean isProvisioningCompleteBroadcastProcessed(Context context) {
        return getProvisioningPreferences(context)
                .getInt(PREFERENCE_PROVISIONING_COMPLETE_STATUS, 0) ==
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_PROCESSED;
    }

    private static SharedPreferences getProvisioningPreferences(Context context) {
        return context.getSharedPreferences(PROVISIONING_PREFERENCES, MODE_PRIVATE);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.PrefixPaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/PrefixPaymentEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

@TargetApi(19)
public class PrefixPaymentEmulatorActivity extends BaseEmulatorActivity {
    final static int STATE_IDLE = 0;
    final static int STATE_SERVICE1_SETTING_UP = 1;
    final static int STATE_SERVICE2_SETTING_UP = 2;
    final static int STATE_MAKING_SERVICE1_DEFAULT = 3;

    int mState = STATE_IDLE;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        mState = STATE_SERVICE1_SETTING_UP;
        setupServices(this, PrefixPaymentService1.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        if (mState == STATE_SERVICE1_SETTING_UP) {
            mState = STATE_SERVICE2_SETTING_UP;
            setupServices(this, PrefixPaymentService1.COMPONENT, PrefixPaymentService2.COMPONENT);
            return;
        }
        // Verify HCE service 1 is the default
        if (makePaymentDefault(PrefixPaymentService1.COMPONENT, R.string.nfc_hce_change_preinstalled_wallet)) {
            mState = STATE_MAKING_SERVICE1_DEFAULT;
        } else {
            // Already default
            NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_hce_payment_prefix_aids_help)).show();
        }
    }

    @Override
    void onPaymentDefaultResult(ComponentName component, boolean success) {
        if (success) {
            NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_hce_payment_prefix_aids_help)).show();
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
    }
    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                PrefixPaymentService1.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                PrefixPaymentService1.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_payment_prefix_aids_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(PrefixPaymentService1.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2135"	"testPocCVE_2019_2135"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2135.java"	""	"@AsbSecurityTest(cveBugId = 125900276)
    public void testPocCVE_2019_2135() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE_2019_2135"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.DualNonPaymentPrefixEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/DualNonPaymentPrefixEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.nfc.cardemulation.CardEmulation;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

import java.util.ArrayList;

public class DualNonPaymentPrefixEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setupServices(this, PrefixTransportService1.COMPONENT, PrefixAccessService.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        // Do dynamic AID registration
        ArrayList<String> service1_aids = new ArrayList<String>();
        service1_aids.add(HceUtils.TRANSPORT_PREFIX_AID + ""*"");
        ArrayList<String> service2_aids = new ArrayList<String>();
        service2_aids.add(HceUtils.ACCESS_PREFIX_AID + ""*"");
        mCardEmulation.registerAidsForService(PrefixTransportService1.COMPONENT, CardEmulation.CATEGORY_OTHER, service1_aids);
        mCardEmulation.registerAidsForService(PrefixAccessService.COMPONENT, CardEmulation.CATEGORY_OTHER, service2_aids);
        NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_hce_other_prefix_aids_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        // Combine command/response APDU arrays
        CommandApdu[] commandSequences = new CommandApdu[PrefixTransportService1.APDU_COMMAND_SEQUENCE.length +
                PrefixAccessService.APDU_COMMAND_SEQUENCE.length];
        System.arraycopy(PrefixTransportService1.APDU_COMMAND_SEQUENCE, 0, commandSequences, 0,
                PrefixTransportService1.APDU_COMMAND_SEQUENCE.length);
        System.arraycopy(PrefixAccessService.APDU_COMMAND_SEQUENCE, 0, commandSequences,
                PrefixTransportService1.APDU_COMMAND_SEQUENCE.length,
                PrefixAccessService.APDU_COMMAND_SEQUENCE.length);

        String[] responseSequences = new String[PrefixTransportService1.APDU_RESPOND_SEQUENCE.length +
                PrefixAccessService.APDU_RESPOND_SEQUENCE.length];
        System.arraycopy(PrefixTransportService1.APDU_RESPOND_SEQUENCE, 0, responseSequences, 0,
                PrefixTransportService1.APDU_RESPOND_SEQUENCE.length);
        System.arraycopy(PrefixAccessService.APDU_RESPOND_SEQUENCE, 0, responseSequences,
                PrefixTransportService1.APDU_RESPOND_SEQUENCE.length,
                PrefixAccessService.APDU_RESPOND_SEQUENCE.length);

        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS, commandSequences);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES, responseSequences);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_other_prefix_aids_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(PrefixAccessService.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.app.cts.SystemFeaturesTest"	"testNfcFeatures"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java"	""	"public void testNfcFeatures() {
        if (NfcAdapter.getDefaultAdapter(mContext) != null) {
            // Watches MAY support all FEATURE_NFC features when an NfcAdapter is available, but
            // non-watches MUST support them both.
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
                assertOneAvailable(PackageManager.FEATURE_NFC,
                    PackageManager.FEATURE_NFC_HOST_CARD_EMULATION);
            } else {
                assertAvailable(PackageManager.FEATURE_NFC);
                assertAvailable(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION);
            }
        } else {
            assertNotAvailable(PackageManager.FEATURE_NFC);
            assertNotAvailable(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION);
        }
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.TestMedi"	"testPocCVE_2020_0450"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/TestMedia.java"	""	"@AsbSecurityTest(cveBugId = 157650336)
    public void testPocCVE_2020_0450() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2020-0450"", null, getDevice());
    }

    /**
     * b/156997193
     * Vulnerability Behaviour: SIGABRT in self
     */"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.TestMedi"	"testPocCVE_2019_2133"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/TestMedia.java"	""	"@AsbSecurityTest(cveBugId = 132082342)
    public void testPocCVE_2019_2133() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2133"", null, getDevice());
    }

    /**
     * b/132083376
     * Vulnerability Behaviour: SIGSEGV in self
     */"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.TestMedi"	"testPocCVE_2019_2134"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/TestMedia.java"	""	"@AsbSecurityTest(cveBugId = 132083376)
    public void testPocCVE_2019_2134() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2134"", null, getDevice());
    }

    /**
     * b/31470908
     * Vulnerability Behaviour: SIGSEGV in self
     */"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSettingsPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final ArraySet<String> allowedPackages = new ArraySet();
        final ArraySet<Integer> allowedUIDs = new ArraySet();
        // explicitly add allowed UIDs
        allowedUIDs.add(Process.SYSTEM_UID);
        allowedUIDs.add(Process.SHELL_UID);
        allowedUIDs.add(Process.PHONE_UID);
        allowedUIDs.add(Process.NETWORK_STACK_UID);
        allowedUIDs.add(Process.NFC_UID);

        // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using
        // this fact to determined allowed package name for sysui. This is a signature permission,
        // so allow any package with this permission.
        final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.BIND_QUICK_SETTINGS_TILE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo info : sysuiPackages) {
            allowedPackages.add(info.packageName);
        }

        // the captive portal flow also currently holds the NETWORK_SETTINGS permission
        final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        if (ri != null) {
            allowedPackages.add(ri.activityInfo.packageName);
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_SETTINGS
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        StringBuilder stringBuilder = new StringBuilder();
        for (PackageInfo pi : holding) {
            String packageName = pi.packageName;

            // this is an explicitly allowed package
            if (allowedPackages.contains(packageName)) continue;

            // now check if the packages are from allowed UIDs
            int uid = -1;
            try {
                uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);
            } catch (PackageManager.NameNotFoundException e) {
                continue;
            }
            if (!allowedUIDs.contains(uid)) {
                stringBuilder.append(""The NETWORK_SETTINGS permission must not be held by ""
                    + packageName + "":"" + uid + "" and must be revoked for security reasons\n"");
            }
        }
        if (stringBuilder.length() > 0) {
            fail(stringBuilder.toString());
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} permission is
     * only held by the device setup wizard application.
     * <p>
     * Only the SetupWizard app should <em>ever</em> attempt to acquire this
     * permission, since it would give those apps extremely broad access to connectivity
     * functionality.  The permission is intended to be granted to only the device setup wizard.
     */"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.offhost.OffhostUiccReaderTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/offhost/OffhostUiccReaderTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.offhost;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.nfc.NfcAdapter;
import android.nfc.cardemulation.CardEmulation;
import android.os.Bundle;

/** Activity that lists all the NFC Offhost-UICC reader tests. */
public class OffhostUiccReaderTestActivity extends PassFailButtons.TestListActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.nfc_test, R.string.nfc_offhost_uicc_reader_test_info, 0);
        setPassFailButtonClickListeners();

        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_OFF_HOST_CARD_EMULATION_UICC)) {
            adapter.add(TestListItem.newCategory(this, R.string.nfc_offhost_uicc_reader_tests));

            adapter.add(TestListItem.newTest(this, R.string.nfc_offhost_uicc_transaction_event1_reader,
                    getString(R.string.nfc_offhost_uicc_transaction_event1_reader),
                    UiccTransactionEvent1EmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_offhost_uicc_transaction_event2_reader,
                    getString(R.string.nfc_offhost_uicc_transaction_event2_reader),
                    UiccTransactionEvent2EmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_offhost_uicc_transaction_event3_reader,
                    getString(R.string.nfc_offhost_uicc_transaction_event3_reader),
                    UiccTransactionEvent3EmulatorActivity.buildReaderIntent(this), null));

        }

        setTestListAdapter(adapter);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.quickaccesswallet.cts.QuickAccessWalletClientTest"	"testAddListener_sendEvent_success"	"CtsQuickAccessWalletTestCases"	"/home/gpoor/cts-12-source/cts/tests/quickaccesswallet/src/android/quickaccesswallet/cts/QuickAccessWalletClientTest.java"	""	"public void testAddListener_sendEvent_success() throws Exception {
        QuickAccessWalletClient client = QuickAccessWalletClient.create(mContext);
        TestEventListener listener = new TestEventListener();
        TestQuickAccessWalletService.setExpectedRequestCount(1);
        client.addWalletServiceEventListener(listener);
        TestQuickAccessWalletService.awaitRequests(1, TimeUnit.SECONDS);

        TestQuickAccessWalletService.sendEvent(
                new WalletServiceEvent(WalletServiceEvent.TYPE_NFC_PAYMENT_STARTED));
        listener.await(300, TimeUnit.SECONDS);

        assertThat(listener.mEvents).hasSize(1);
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.quickaccesswallet.cts.QuickAccessWalletClientTest"	"testRemoveListener_sendEvent_shouldNotBeDelivered"	"CtsQuickAccessWalletTestCases"	"/home/gpoor/cts-12-source/cts/tests/quickaccesswallet/src/android/quickaccesswallet/cts/QuickAccessWalletClientTest.java"	""	"public void testRemoveListener_sendEvent_shouldNotBeDelivered() {
        QuickAccessWalletClient client = QuickAccessWalletClient.create(mContext);
        TestEventListener listener = new TestEventListener();
        client.addWalletServiceEventListener(listener);
        client.removeWalletServiceEventListener(listener);

        TestQuickAccessWalletService.sendEvent(
                new WalletServiceEvent(WalletServiceEvent.TYPE_NFC_PAYMENT_STARTED));
        try {
            listener.await(250, TimeUnit.MILLISECONDS);
        } catch (InterruptedException ignored) {
            // It is expected that this time out
        }

        assertThat(listener.mEvents).hasSize(0);
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.SuspendPackageTest"	"testSetPackagesNotSuspended"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SuspendPackageTest.java"	""	"public void testSetPackagesNotSuspended() throws Exception {

        String[] notHandled = setSuspendedPackages(/* suspend= */ false, INTENT_RECEIVER_PKG);
        // all packages should be handled.
        assertWithMessage(""packages not suspended"").that(notHandled).isEmpty();

        // test isPackageSuspended
        assertPackageNotSuspended(INTENT_RECEIVER_PKG);
    }

    /**
     * Verify that we cannot suspend launcher and dpc app.
     */"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.SuspendPackageTest"	"testSuspendNotSuspendablePackages"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SuspendPackageTest.java"	""	"public void testSuspendNotSuspendablePackages() throws Exception {
        String launcherPackage = getDefaultLauncher(getInstrumentation());
        String dpcPackage = ADMIN_RECEIVER_COMPONENT.getPackageName();
        String[] notHandledPackages = setSuspendedPackages(/* suspend= */ true,
                launcherPackage, dpcPackage);
        // no package should be handled.
        assertWithMessage(""not handled packages"").that(notHandledPackages).asList()
                .containsExactly(launcherPackage, dpcPackage);

        Set<String> exemptApps = mDevicePolicyManager.getPolicyExemptApps();
        if (exemptApps.isEmpty()) {
            Log.v(TAG, ""testSuspendNotSuspendablePackages(): no exempt apps"");
            return;
        }

        Log.v(TAG, ""testSuspendNotSuspendablePackages(): testing exempt apps: "" + exemptApps);
        notHandledPackages = setSuspendedPackages(/* suspend= */ true, exemptApps);
        assertWithMessage(""exempt apps not suspended"").that(notHandledPackages).asList()
            .containsExactlyElementsIn(exemptApps);
    }

    private String[] setSuspendedPackages(boolean suspend, Collection<String> pkgs) {
        String[] pkgsArray = new String[pkgs.size()];
        pkgs.toArray(pkgsArray);
        return setSuspendedPackages(suspend, pkgsArray);
    }

    private String[] setSuspendedPackages(boolean suspend, String... pkgs) {
        Log.d(TAG, ""Calling setPackagesSuspended("" + suspend + "", "" + Arrays.toString(pkgs));
        String[] notHandled =
                mDevicePolicyManager.setPackagesSuspended(ADMIN_RECEIVER_COMPONENT, pkgs, suspend);
        Log.d(TAG, ""Returning "" + Arrays.toString(notHandled));
        return notHandled;
    }

    private void assertPackageSuspended(String pkg) throws Exception {
        assertPackageSuspension(pkg, /* expected= */ true);
    }

    private void assertPackageNotSuspended(String pkg) throws Exception {
        assertPackageSuspension(pkg, /* expected= */ false);
    }

    private void assertPackageSuspension(String pkg, boolean expected) throws Exception {
        boolean actual =
                mDevicePolicyManager.isPackageSuspended(ADMIN_RECEIVER_COMPONENT, pkg);
        Log.d(TAG, ""isPackageSuspended("" + pkg + ""): "" + actual);
        assertWithMessage(""package %s suspension"", pkg).that(actual).isEqualTo(expected);
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hcef.HceFEmulatorTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hcef/HceFEmulatorTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.hcef;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.nfc.NfcAdapter;
import android.nfc.cardemulation.CardEmulation;
import android.os.Bundle;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;

/** Activity that lists all the NFC HCE emulator tests. */
public class HceFEmulatorTestActivity extends PassFailButtons.TestListActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.nfc_test, R.string.nfc_hce_emulator_test_info, 0);
        setPassFailButtonClickListeners();

        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);

        NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
        CardEmulation cardEmulation = CardEmulation.getInstance(nfcAdapter);
        if (getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_NFC_HOST_CARD_EMULATION_NFCF)) {
            adapter.add(TestListItem.newCategory(this, R.string.nfc_hce_f_emulator_tests));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_f_emulator,
                    HceFEmulatorActivity.class.getName(),
                    new Intent(this, HceFEmulatorActivity.class), null));
        }

        setTestListAdapter(adapter);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"TestApis"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"/*
 *.
 */

package com.android.bedstead.nene.devicepolicy;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;
import static org.testng.Assert.assertThrows;

import android.content.ComponentName;
import android.os.Build;

import com.android.bedstead.harrier.BedsteadJUnit4;
import com.android.bedstead.harrier.DeviceState;
import com.android.bedstead.harrier.annotations.AfterClass;
import com.android.bedstead.harrier.annotations.BeforeClass;
import com.android.bedstead.harrier.annotations.EnsureHasNoSecondaryUser;
import com.android.bedstead.harrier.annotations.EnsureHasNoWorkProfile;
import com.android.bedstead.harrier.annotations.EnsureHasSecondaryUser;
import com.android.bedstead.harrier.annotations.enterprise.EnsureHasDeviceOwner;
import com.android.bedstead.harrier.annotations.enterprise.EnsureHasNoDeviceOwner;
import com.android.bedstead.harrier.annotations.enterprise.EnsureHasNoProfileOwner;
import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.exceptions.NeneException;
import com.android.bedstead.nene.users.UserReference;
import com.android.bedstead.nene.users.UserType;
import com.android.bedstead.nene.utils.Versions;
import com.android.bedstead.testapp.TestApp;
import com.android.bedstead.testapp.TestAppProvider;
import com.android.eventlib.premade.EventLibDeviceAdminReceiver;

import org.junit.ClassRule;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(BedsteadJUnit4.class)
public class DevicePolicyTest {

    @ClassRule @Rule
    public static final DeviceState sDeviceState = new DeviceState();

    //  TODO(180478924): We shouldn't need to hardcode this
    private static final String DEVICE_ADMIN_TESTAPP_PACKAGE_NAME = ""android.DeviceAdminTestApp"";
    private static final ComponentName DPC_COMPONENT_NAME =
            new ComponentName(DEVICE_ADMIN_TESTAPP_PACKAGE_NAME,
                    EventLibDeviceAdminReceiver.class.getName());
    private static final ComponentName NOT_DPC_COMPONENT_NAME =
            new ComponentName(DEVICE_ADMIN_TESTAPP_PACKAGE_NAME,
                    ""incorrect.class.name"");

    private static final TestApis sTestApis = new TestApis();
    private static final UserReference sUser = sTestApis.users().instrumented();
    private static final UserReference NON_EXISTENT_USER = sTestApis.users().find(99999);

    private static TestApp sTestApp;

    @BeforeClass
    public static void setupClass() {
        sTestApp = new TestAppProvider().query()
                .wherePackageName().isEqualTo(DEVICE_ADMIN_TESTAPP_PACKAGE_NAME)
                .get();

        sTestApp.install(sUser);
    }

    @AfterClass
    public static void teardownClass() {
        sTestApp.uninstall(sUser);
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"setProfileOwner_profileOwnerIsSet"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasNoDeviceOwner
    @EnsureHasNoWorkProfile
    public void setProfileOwner_profileOwnerIsSet() {
        UserReference profile = sTestApis.users().createUser()
                .parent(sUser)
                .type(sTestApis.users().supportedType(UserType.MANAGED_PROFILE_TYPE_NAME))
                .createAndStart();
        sTestApp.install(profile);

        ProfileOwner profileOwner =
                sTestApis.devicePolicy().setProfileOwner(profile, DPC_COMPONENT_NAME);

        try {
            assertThat(sTestApis.devicePolicy().getProfileOwner(profile)).isEqualTo(profileOwner);
        } finally {
            profile.remove();
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"setProfileOwner_profileOwnerIsAlreadySet_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasNoDeviceOwner
    @EnsureHasNoWorkProfile
    public void setProfileOwner_profileOwnerIsAlreadySet_throwsException() {
        UserReference profile = sTestApis.users().createUser()
                .parent(sUser)
                .type(sTestApis.users().supportedType(UserType.MANAGED_PROFILE_TYPE_NAME))
                .createAndStart();
        try {
            sTestApp.install(profile);

            sTestApis.devicePolicy().setProfileOwner(profile, DPC_COMPONENT_NAME);

            assertThrows(NeneException.class,
                    () -> sTestApis.devicePolicy().setProfileOwner(profile, DPC_COMPONENT_NAME));
        } finally {
            profile.remove();
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"setProfileOwner_componentNameIsNotDPC_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasNoDeviceOwner
    @EnsureHasNoProfileOwner
    public void setProfileOwner_componentNameIsNotDPC_throwsException() {
        assertThrows(NeneException.class,
                () -> sTestApis.devicePolicy().setProfileOwner(sUser, NOT_DPC_COMPONENT_NAME));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"setProfileOwner_userDoesNotExist_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasNoDeviceOwner
    @EnsureHasNoProfileOwner
    public void setProfileOwner_userDoesNotExist_throwsException() {
        assertThrows(NeneException.class,
                () -> sTestApis.devicePolicy().setProfileOwner(
                        NON_EXISTENT_USER, DPC_COMPONENT_NAME));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"setDeviceOwner_deviceOwnerIsSet"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasNoDeviceOwner
    @EnsureHasNoProfileOwner
    public void setDeviceOwner_deviceOwnerIsSet() {
        DeviceOwner deviceOwner =
                sTestApis.devicePolicy().setDeviceOwner(sUser, DPC_COMPONENT_NAME);

        try {
            assertThat(sTestApis.devicePolicy().getDeviceOwner()).isEqualTo(deviceOwner);
        } finally {
            deviceOwner.remove();
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"setDeviceOwner_deviceOwnerIsAlreadySet_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasDeviceOwner
    public void setDeviceOwner_deviceOwnerIsAlreadySet_throwsException() {
        assertThrows(NeneException.class,
                () -> sTestApis.devicePolicy().setDeviceOwner(sUser, DPC_COMPONENT_NAME));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"setDeviceOwner_componentNameIsNotDPC_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasNoDeviceOwner
    @EnsureHasNoProfileOwner
    public void setDeviceOwner_componentNameIsNotDPC_throwsException() {
        assertThrows(NeneException.class,
                () -> sTestApis.devicePolicy().setDeviceOwner(sUser, NOT_DPC_COMPONENT_NAME));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"setDeviceOwner_sPlus_userAlreadyOnDevice_deviceOwnerIsSet"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasNoDeviceOwner
    @EnsureHasNoProfileOwner
    @EnsureHasSecondaryUser
    public void setDeviceOwner_sPlus_userAlreadyOnDevice_deviceOwnerIsSet() {
        assumeTrue(""After S, device owner can be set with users on the device"",
                Versions.meetsMinimumSdkVersionRequirement(Build.VERSION_CODES.S));

        DeviceOwner deviceOwner =
                sTestApis.devicePolicy().setDeviceOwner(sUser, DPC_COMPONENT_NAME);

        try {
            assertThat(sTestApis.devicePolicy().getDeviceOwner()).isNotNull();
        } finally {
            deviceOwner.remove();
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"setDeviceOwner_userDoesNotExist_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasNoDeviceOwner
    @EnsureHasNoProfileOwner
    public void setDeviceOwner_userDoesNotExist_throwsException() {
        assertThrows(NeneException.class,
                () -> sTestApis.devicePolicy().setDeviceOwner(
                        NON_EXISTENT_USER, DPC_COMPONENT_NAME));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"isNull"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasNoDeviceOwner
    @EnsureHasNoProfileOwner
    public void deviceOwner_autoclose_removesDeviceOwner() {
        try (DeviceOwner deviceOwner =
                     sTestApis.devicePolicy().setDeviceOwner(sUser, DPC_COMPONENT_NAME)) {
            // We intentionally don't do anything here, just rely on the auto-close behaviour
        }

        assertThat(sTestApis.devicePolicy().getDeviceOwner()).isNull();
    }"	""	""	"DPC DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.devicepolicy.DevicePolicyTest"	"isNotNull"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/devicepolicy/DevicePolicyTest.java"	""	"@EnsureHasNoDeviceOwner
    @EnsureHasNoProfileOwner
    public void setProfileOwner_recentlyUnsetDeviceOwner_sets() {
        sTestApis.devicePolicy().setDeviceOwner(sUser, DPC_COMPONENT_NAME).remove();

        sTestApis.devicePolicy().setProfileOwner(sUser, DPC_COMPONENT_NAME);

        assertThat(sTestApis.devicePolicy().getProfileOwner(sUser)).isNotNull();
    }
}"	""	""	"DPC DPC DPC DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2020_0072"	"testPocCVE_2020_0072"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2020_0072.java"	""	"@AsbSecurityTest(cveBugId = 147310271)
    public void testPocCVE_2020_0072() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.pocConfig testConfig = new AdbUtils.pocConfig(""CVE-2020-0072"", getDevice());
        testConfig.checkCrash = false;
        AdbUtils.runPocAssertNoCrashesNotVulnerable(testConfig);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hcef.HceFEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hcef/HceFEmulatorActivity.java"	""	"public void test/*
 *.
 */
package com.android.cts.verifier.nfc.hcef;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.nfc.NfcAdapter;
import android.nfc.cardemulation.NfcFCardEmulation;
import android.os.Bundle;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

public class HceFEmulatorActivity extends PassFailButtons.Activity{
    static String ACTION_TEST_SUCCESS = ""success"";

    NfcAdapter mAdapter;
    NfcFCardEmulation mNfcFCardEmulation;

    final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();

            if (ACTION_TEST_SUCCESS.equals(action)) {
                getPassButton().setEnabled(true);
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        mAdapter = NfcAdapter.getDefaultAdapter(this);
        mNfcFCardEmulation = NfcFCardEmulation.getInstance(mAdapter);
    }

    @Override
    protected void onResume() {
        super.onResume();
        IntentFilter filter = new IntentFilter(ACTION_TEST_SUCCESS);
        registerReceiver(mReceiver, filter);
        ComponentName hceFService = new ComponentName(""com.android.cts.verifier"",
                MyHostFelicaService.class.getName());
        mNfcFCardEmulation.enableService(this, hceFService);
    }

    @Override
    protected void onPause() {
        super.onPause();
        unregisterReceiver(mReceiver);
    }

}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.DeviceAdminTestReceiver"	"isHeadlessSystemUserMode"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/DeviceAdminTestReceiver.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE;

import android.app.Service;
import android.app.admin.DeviceAdminReceiver;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.PersistableBundle;
import android.os.Process;
import android.os.RemoteException;
import android.os.UserHandle;
import android.os.UserManager;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.android.bedstead.dpmwrapper.DeviceOwnerHelper;
import com.android.compatibility.common.util.enterprise.DeviceAdminReceiverUtils;
import com.android.cts.verifier.R;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;

/**
 * Profile owner receiver for BYOD flow test.
 * Setup cross-profile intent filter after successful provisioning.
 */
public class DeviceAdminTestReceiver extends DeviceAdminReceiver {
    public static final String KEY_BUNDLE_WIPE_IMMEDIATELY = ""wipe_immediately"";
    private static final String TAG = ""DeviceAdminTestReceiver"";
    private static final String DEVICE_OWNER_PKG =
            ""com.android.cts.verifier"";
    private static final String ADMIN_RECEIVER_TEST_CLASS =
            DEVICE_OWNER_PKG + "".managedprovisioning.DeviceAdminTestReceiver"";
    private static final ComponentName RECEIVER_COMPONENT_NAME = new ComponentName(
            DEVICE_OWNER_PKG, ADMIN_RECEIVER_TEST_CLASS);
    public static final String EXTRA_MANAGED_USER_TEST =
            ""com.android.cts.verifier.managedprovisioning.extra.MANAGED_USER_TEST"";
    public static final String EXTRA_LOGOUT_ON_START =
            ""com.android.cts.verifier.managedprovisioning.extra.LOGOUT_ON_START"";
    public static final String AFFILIATION_ID = ""affiliationId"";

    public static ComponentName getReceiverComponentName() {
        return RECEIVER_COMPONENT_NAME;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        if (DeviceAdminReceiverUtils.disableSelf(context, intent)) return;
        if (DeviceOwnerHelper.runManagerMethod(this, context, intent)) return;

        String action = intent.getAction();
        Log.d(TAG, ""onReceive(): user="" + UserHandle.myUserId() + "", action="" + action);

        // Must set affiliation on headless system user, otherwise some operations in the current
        // user (which is PO) won't be allowed (like uininstalling a package)
        if (ACTION_DEVICE_ADMIN_ENABLED.equals(action) && UserManager.isHeadlessSystemUserMode()) {
            Set<String> ids = new HashSet<>();
            ids.add(""affh!"");
            Log.i(TAG, ""Setting affiliation ids to "" + ids);
            getManager(context).setAffiliationIds(getWho(context), ids);
        }

        super.onReceive(context, intent);
    }

    @Override
    public void onProfileProvisioningComplete(Context context, Intent intent) {
        Log.d(TAG, ""Provisioning complete intent received"");
        setupProfile(context);
        wipeIfNecessary(context, intent);
    }

    @Override
    public void onBugreportSharingDeclined(Context context, Intent intent) {
        Log.i(TAG, ""Bugreport sharing declined"");
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_sharing_declined), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onBugreportShared(Context context, Intent intent, String bugreportFileHash) {
        Log.i(TAG, ""Bugreport shared"");
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_shared_successfully), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onBugreportFailed(Context context, Intent intent, int failureCode) {
        Log.i(TAG, ""Bugreport collection operation failed, code: "" + failureCode);
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_failed_completing), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onLockTaskModeEntering(Context context, Intent intent, String pkg) {
        Log.i(TAG, ""Entering LockTask mode: "" + pkg);
        LocalBroadcastManager.getInstance(context)
                .sendBroadcast(new Intent(LockTaskUiTestActivity.ACTION_LOCK_TASK_STARTED));
    }

    @Override
    public void onLockTaskModeExiting(Context context, Intent intent) {
        Log.i(TAG, ""Exiting LockTask mode"");
        LocalBroadcastManager.getInstance(context)
                .sendBroadcast(new Intent(LockTaskUiTestActivity.ACTION_LOCK_TASK_STOPPED));
    }

    @Override
    public void onEnabled(Context context, Intent intent) {
        Log.i(TAG, ""Device admin enabled"");
        if (intent.getBooleanExtra(EXTRA_MANAGED_USER_TEST, false)) {
            DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
            ComponentName admin = getReceiverComponentName();
            dpm.setAffiliationIds(admin,
                    Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));
            context.startActivity(
                    new Intent(context, ManagedUserPositiveTestActivity.class).setFlags(
                            Intent.FLAG_ACTIVITY_NEW_TASK));

            bindPrimaryUserService(context, iCrossUserService -> {
                try {
                    UserHandle userHandle = Process.myUserHandle();
                    Log.d(TAG, ""calling switchUser("" + userHandle + "")"");
                    iCrossUserService.switchUser(userHandle);
                } catch (RemoteException re) {
                    Log.e(TAG, ""Error when calling primary user"", re);
                }
            });
        } else if (intent.getBooleanExtra(EXTRA_LOGOUT_ON_START, false)) {
            DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
            ComponentName admin = getReceiverComponentName();
            dpm.setAffiliationIds(admin,
                    Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));
            dpm.logoutUser(admin);
        }
    }

    private void setupProfile(Context context) {
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        dpm.setProfileEnabled(new ComponentName(context.getApplicationContext(), getClass()));

        // Setup cross-profile intent filter to allow communications between the two versions of CtsVerifier
        // Primary -> work direction
        IntentFilter filter = new IntentFilter();
        filter.addAction(ByodHelperActivity.ACTION_QUERY_PROFILE_OWNER);
        filter.addAction(ByodHelperActivity.ACTION_REMOVE_MANAGED_PROFILE);
        filter.addAction(ByodHelperActivity.ACTION_CHECK_DISK_ENCRYPTION);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_CHECK_INTENT_FILTERS);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_IMAGE);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_AUDIO);
        filter.addAction(ByodHelperActivity.ACTION_KEYGUARD_DISABLED_FEATURES);
        filter.addAction(ByodHelperActivity.ACTION_LOCKNOW);
        filter.addAction(ByodHelperActivity.ACTION_TEST_NFC_BEAM);
        filter.addAction(ByodHelperActivity.ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG);
        filter.addAction(ByodHelperActivity.ACTION_TEST_APP_LINKING_DIALOG);
        filter.addAction(ByodHelperActivity.ACTION_NOTIFICATION);
        filter.addAction(ByodHelperActivity.ACTION_NOTIFICATION_ON_LOCKSCREEN);
        filter.addAction(ByodHelperActivity.ACTION_CLEAR_NOTIFICATION);
        filter.addAction(ByodHelperActivity.ACTION_SET_USER_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_CLEAR_USER_RESTRICTION);
        filter.addAction(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_WORK);
        filter.addAction(WorkStatusTestActivity.ACTION_WORK_STATUS_TOAST);
        filter.addAction(WorkStatusTestActivity.ACTION_WORK_STATUS_ICON);
        filter.addAction(
                PermissionLockdownTestActivity.ACTION_MANAGED_PROFILE_CHECK_PERMISSION_LOCKDOWN);
        filter.addAction(AuthenticationBoundKeyTestActivity.ACTION_AUTH_BOUND_KEY_TEST);
        filter.addAction(VpnTestActivity.ACTION_VPN);
        filter.addAction(AlwaysOnVpnSettingsTestActivity.ACTION_ALWAYS_ON_VPN_SETTINGS_TEST);
        filter.addAction(RecentsRedactionActivity.ACTION_RECENTS);
        filter.addAction(ByodHelperActivity.ACTION_TEST_SELECT_WORK_CHALLENGE);
        filter.addAction(ByodHelperActivity.ACTION_TEST_PATTERN_WORK_CHALLENGE);
        filter.addAction(ByodHelperActivity.ACTION_LAUNCH_CONFIRM_WORK_CREDENTIALS);
        filter.addAction(ByodHelperActivity.ACTION_SET_ORGANIZATION_INFO);
        filter.addAction(ByodHelperActivity.ACTION_TEST_PARENT_PROFILE_PASSWORD);
        filter.addAction(SetSupportMessageActivity.ACTION_SET_SUPPORT_MSG);
        filter.addAction(KeyChainTestActivity.ACTION_KEYCHAIN);
        filter.addAction(CommandReceiverActivity.ACTION_EXECUTE_COMMAND);
        filter.addAction(WorkProfileWidgetActivity.ACTION_TEST_WORK_PROFILE_WIDGET);
        filter.addAction(
                CrossProfilePermissionControlActivity.ACTION_CROSS_PROFILE_PERMISSION_CONTROL);
        filter.addAction(LocationCheckerActivity.ACTION_CHECK_LOCATION_WORK);
        dpm.addCrossProfileIntentFilter(getWho(context), filter,
                DevicePolicyManager.FLAG_MANAGED_CAN_ACCESS_PARENT);

        // Work -> primary direction
        filter = new IntentFilter();
        filter.addAction(ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS);
        filter.addAction(ByodHelperActivity.ACTION_DISK_ENCRYPTION_STATUS);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_IN_PRIMARY);
        filter.addAction(ByodFlowTestActivity.ACTION_TEST_RESULT);
        filter.addAction(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_PERSONAL);

        dpm.addCrossProfileIntentFilter(getWho(context), filter,
                DevicePolicyManager.FLAG_PARENT_CAN_ACCESS_MANAGED);

        // Disable the work profile instance of this activity, because it is a helper activity for
        // the work -> primary direction.
        context.getPackageManager().setComponentEnabledSetting(
                new ComponentName(context, ByodPrimaryHelperActivity.class.getName()),
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);

        // Disable the work profile instance of ByodFlowTestActivity
        context.getPackageManager().setComponentEnabledSetting(
                new ComponentName(context, ByodFlowTestActivity.class),
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
    }

    private void wipeIfNecessary(Context context, Intent intent) {
        PersistableBundle bundle = intent.getParcelableExtra(
                EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE);
        if (bundle != null && bundle.getBoolean(KEY_BUNDLE_WIPE_IMMEDIATELY, false)) {
            getManager(context).wipeData(0);
        }
    }

    private void bindPrimaryUserService(Context context, Consumer<ICrossUserService> consumer) {
        DevicePolicyManager devicePolicyManager = context.getSystemService(
                DevicePolicyManager.class);
        UserHandle primaryUser = devicePolicyManager.getBindDeviceAdminTargetUsers(
                getReceiverComponentName()).get(0);

        Log.d(TAG, ""Calling primary user: "" + primaryUser);
        final ServiceConnection serviceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Log.d(TAG, ""onServiceConnected is called"");
                consumer.accept(ICrossUserService.Stub.asInterface(service));
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                Log.d(TAG, ""onServiceDisconnected is called"");
            }
        };
        final Intent serviceIntent = new Intent(context, PrimaryUserService.class);
        devicePolicyManager.bindDeviceAdminServiceAsUser(getReceiverComponentName(), serviceIntent,
                serviceConnection, Context.BIND_AUTO_CREATE, primaryUser);
    }

    public static final class PrimaryUserService extends Service {
        private final ICrossUserService.Stub mBinder = new ICrossUserService.Stub() {
            public void switchUser(UserHandle userHandle) {
                Log.d(TAG, ""switchUser: "" + userHandle);
                getSystemService(DevicePolicyManager.class).switchUser(getReceiverComponentName(),
                        userHandle);
            }
        };

        @Override
        public IBinder onBind(Intent intent) {
            return mBinder;
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"library.test.java.com.android.bedstead.remotedpc.RemoteDpcTest"	"TestApis"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/library/test/java/com/android/bedstead/remotedpc/RemoteDpcTest.java"	""	"/*
 *.
 */

package com.android.bedstead.remotedpc;

import static com.google.common.truth.Truth.assertThat;

import static org.testng.Assert.assertThrows;

import android.content.ComponentName;
import android.os.UserHandle;

import com.android.bedstead.harrier.BedsteadJUnit4;
import com.android.bedstead.harrier.DeviceState;
import com.android.bedstead.harrier.annotations.AfterClass;
import com.android.bedstead.harrier.annotations.BeforeClass;
import com.android.bedstead.harrier.annotations.enterprise.EnsureHasNoDeviceOwner;
import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.devicepolicy.DeviceOwner;
import com.android.bedstead.nene.devicepolicy.ProfileOwner;
import com.android.bedstead.nene.exceptions.NeneException;
import com.android.bedstead.nene.users.UserReference;
import com.android.bedstead.nene.users.UserType;
import com.android.bedstead.testapp.TestApp;
import com.android.bedstead.testapp.TestAppProvider;
import com.android.eventlib.premade.EventLibDeviceAdminReceiver;

import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(BedsteadJUnit4.class)
public class RemoteDpcTest {
    // TODO(scottjonathan): Add annotations to ensure that there is no DO/PO on appropriate methods
    //  TODO(180478924): We shouldn't need to hardcode this
    private static final String DEVICE_ADMIN_TESTAPP_PACKAGE_NAME = ""android.DeviceAdminTestApp"";
    private static final ComponentName NON_REMOTE_DPC_COMPONENT =
            new ComponentName(DEVICE_ADMIN_TESTAPP_PACKAGE_NAME,
                    EventLibDeviceAdminReceiver.class.getName());

    @ClassRule @Rule
    public static DeviceState sDeviceState = new DeviceState();

    private static final TestApis sTestApis = new TestApis();
    private static TestApp sNonRemoteDpcTestApp;
    private static final UserReference sUser = sTestApis.users().instrumented();
    private static final UserReference NON_EXISTING_USER_REFERENCE =
            sTestApis.users().find(99999);
    private static final UserHandle NON_EXISTING_USER_HANDLE =
            NON_EXISTING_USER_REFERENCE.userHandle();

    @BeforeClass
    public static void setupClass() {
        sNonRemoteDpcTestApp = new TestAppProvider().query()
                // TODO(scottjonathan): Query by feature not package name
                .wherePackageName().isEqualTo(DEVICE_ADMIN_TESTAPP_PACKAGE_NAME)
                .get();

        sNonRemoteDpcTestApp.install(sUser);
    }

    @AfterClass
    public static void teardownClass() {
        sNonRemoteDpcTestApp.uninstall(sUser);
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"library.test.java.com.android.bedstead.remotedpc.RemoteDpcTest"	"isNull"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/library/test/java/com/android/bedstead/remotedpc/RemoteDpcTest.java"	""	"@EnsureHasNoDeviceOwner
    public void remove_profileOwner_removes() {
        try (UserReference profile = sTestApis.users().createUser()
                .parent(sUser)
                .type(sTestApis.users().supportedType(UserType.MANAGED_PROFILE_TYPE_NAME))
                .createAndStart()) {
            RemoteDpc remoteDPC = RemoteDpc.setAsProfileOwner(profile);

            remoteDPC.remove();

            assertThat(sTestApis.devicePolicy().getProfileOwner(profile)).isNull();
        }
    }

    // TODO(scottjonathan): Do we need to support the case where there is both a DO and a PO on
    //  older versions of Android?"	""	""	"DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"library.test.java.com.android.bedstead.remotedpc.RemoteDpcTest"	"isNotNull"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/library/test/java/com/android/bedstead/remotedpc/RemoteDpcTest.java"	""	"public void forDevicePolicyController_remoteDpcDevicePolicyController_returnsRemoteDpc() {
        RemoteDpc remoteDPC = RemoteDpc.setAsDeviceOwner(sUser);

        try {
            assertThat(RemoteDpc.forDevicePolicyController(remoteDPC.devicePolicyController()))
                    .isNotNull();
        } finally {
            remoteDPC.remove();
        }

    }
}"	""	""	"DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"library.test.java.com.android.bedstead.remotedpc.RemoteDpcTest"	"setAsDeviceOwner_userHandle_nonExistingUser_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/library/test/java/com/android/bedstead/remotedpc/RemoteDpcTest.java"	""	"public void setAsDeviceOwner_userHandle_nonExistingUser_throwsException() {
        assertThrows(NeneException.class,
                () -> RemoteDpc.setAsDeviceOwner(NON_EXISTING_USER_HANDLE));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"library.test.java.com.android.bedstead.remotedpc.RemoteDpcTest"	"setAsDeviceOwner_userReference_nonExistingUser_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/library/test/java/com/android/bedstead/remotedpc/RemoteDpcTest.java"	""	"public void setAsDeviceOwner_userReference_nonExistingUser_throwsException() {
        assertThrows(NeneException.class,
                () -> RemoteDpc.setAsDeviceOwner(NON_EXISTING_USER_REFERENCE));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"library.test.java.com.android.bedstead.remotedpc.RemoteDpcTest"	"setAsProfileOwner_userHandle_nonExistingUser_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/library/test/java/com/android/bedstead/remotedpc/RemoteDpcTest.java"	""	"public void setAsProfileOwner_userHandle_nonExistingUser_throwsException() {
        assertThrows(NeneException.class,
                () -> RemoteDpc.setAsProfileOwner(NON_EXISTING_USER_HANDLE));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"library.test.java.com.android.bedstead.remotedpc.RemoteDpcTest"	"setAsProfileOwner_userReference_nonExistingUser_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/library/test/java/com/android/bedstead/remotedpc/RemoteDpcTest.java"	""	"public void setAsProfileOwner_userReference_nonExistingUser_throwsException() {
        assertThrows(NeneException.class,
                () -> RemoteDpc.setAsProfileOwner(NON_EXISTING_USER_REFERENCE));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"library.test.java.com.android.bedstead.remotedpc.RemoteDpcTest"	"isUsingUnifiedPassword"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/library/test/java/com/android/bedstead/remotedpc/RemoteDpcTest.java"	""	"public void frameworkCallRequiresProfileOwner_notProfileOwner_throwsSecurityException() {
        RemoteDpc remoteDPC = RemoteDpc.setAsDeviceOwner(sUser);

        try {
            assertThrows(SecurityException.class,
                    () -> remoteDPC.devicePolicyManager().isUsingUnifiedPassword());
        } finally {
            remoteDPC.remove();
        }
    }"	""	""	"DPC DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.car.cts.powerpolicy.CpmsFrameworkLayerStateInfo"	"getCurrentDisabledComponents"	"CtsCarHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/car/src/android/car/cts/powerpolicy/CpmsFrameworkLayerStateInfo.java"	""	"public void test/*
 *.
 */

package android.car.cts.powerpolicy;

import com.android.tradefed.log.LogUtil.CLog;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Objects;

public final class CpmsFrameworkLayerStateInfo {
    private static final int STRING_BUILDER_BUF_SIZE = 1024;

    public static final String COMMAND = ""dumpsys car_service --services""
            + "" CarPowerManagementService"";
    public static final String CURRENT_STATE_HDR = ""mCurrentState:"";
    public static final String CURRENT_POLICY_ID_HDR = ""mCurrentPowerPolicyId:"";
    public static final String PENDING_POLICY_ID_HDR = ""mPendingPowerPolicyId:"";
    public static final String CURRENT_POLICY_GROUP_ID_HDR = ""mCurrentPowerPolicyGroupId:"";
    public static final String NUMBER_POLICY_LISTENERS_HDR = ""# of power policy change listener:"";
    public static final String POWER_POLICY_GROUPS_HDR = ""Power policy groups:"";
    public static final String PREEMPTIVE_POWER_POLICY_HDR = ""Preemptive power policy:"";
    public static final String COMPONENT_STATE_HDR = ""Power components state:"";
    public static final String COMPONENT_CONTROLLED_HDR =
            ""Components powered off by power policy:"";
    public static final String COMPONENT_CHANGED_HDR = ""Components changed by the last policy:"";
    public static final String MONITORING_HW_HDR = ""Monitoring HW state signal:"";
    public static final String SILENT_MODE_BY_HW_HDR = ""Silent mode by HW state signal:"";
    public static final String FORCED_SILENT_MODE_HDR = ""Forced silent mode:"";

    private static final String[] COMPONENT_LIST = {""AUDIO"", ""MEDIA"", ""DISPLAY"", ""BLUETOOTH"",
            ""WIFI"", ""CELLULAR"", ""ETHERNET"", ""PROJECTION"", ""NFC"", ""INPUT"", ""VOICE_INTERACTION"",
            ""VISUAL_INTERACTION"", ""TRUSTED_DEVICE_DETECTION"", ""LOCATION"", ""MICROPHONE"", ""CPU""};
    private static final HashSet COMPONENT_SET = new HashSet(Arrays.asList(COMPONENT_LIST));

    private final ArrayList<String> mEnables;
    private final ArrayList<String> mDisables;
    private final ArrayList<String> mControlledEnables;
    private final ArrayList<String> mControlledDisables;
    private final String[] mChangedComponents;
    private final PowerPolicyGroups mPowerPolicyGroups;
    private final String mCurrentPolicyId;
    private final String mPendingPolicyId;
    private final String mCurrentPolicyGroupId;
    private final int mNumberPolicyListeners;
    private final boolean mMonitoringHw;
    private final boolean mSilentModeByHw;
    private final boolean mForcedSilentMode;
    private final int mCurrentState;

    private CpmsFrameworkLayerStateInfo(String currentPolicyId, String pendingPolicyId,
            String currentPolicyGroupId, int numberPolicyListeners, String[] changedComponents,
            ArrayList<String> enables, ArrayList<String> disables, PowerPolicyGroups policyGroups,
            ArrayList<String> controlledEnables, ArrayList<String> controlledDisables,
            boolean monitoringHw, boolean silentModeByHw, boolean forcedSilentMode,
            int currentState) {
        mEnables = enables;
        mDisables = disables;
        mControlledEnables = controlledEnables;
        mControlledDisables = controlledDisables;
        mChangedComponents = changedComponents;
        mPowerPolicyGroups = policyGroups;
        mCurrentPolicyId = currentPolicyId;
        mPendingPolicyId = pendingPolicyId;
        mCurrentPolicyGroupId = currentPolicyGroupId;
        mNumberPolicyListeners = numberPolicyListeners;
        mMonitoringHw = monitoringHw;
        mSilentModeByHw = silentModeByHw;
        mForcedSilentMode = forcedSilentMode;
        mCurrentState = currentState;
    }

    public String getCurrentPolicyId() {
        return mCurrentPolicyId;
    }

    public String getPendingPolicyId() {
        return mPendingPolicyId;
    }

    public int getCurrentState() {
        return mCurrentState;
    }

    public boolean getForcedSilentMode() {
        return mForcedSilentMode;
    }

    public PowerPolicyDef.PowerComponent[] getCurrentEnabledComponents() {
        return PowerPolicyDef.PowerComponent.asComponentArray(mEnables);
    }

    public PowerPolicyDef.PowerComponent[] getCurrentDisabledComponents() {
        return PowerPolicyDef.PowerComponent.asComponentArray(mDisables);
    }

    public String getCurrentPolicyGroupId() {
        return mCurrentPolicyGroupId;
    }

    public PowerPolicyGroups getPowerPolicyGroups() {
        return mPowerPolicyGroups;
    }

    public int getNumberPolicyListeners() {
        return mNumberPolicyListeners;
    }

    public boolean isComponentOn(String component) {
        return mEnables.contains(component);
    }

    public boolean isComponentOff(String component) {
        return mDisables.contains(component);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder(STRING_BUILDER_BUF_SIZE);
        sb.append(""mCurrentState="").append(mCurrentState).append(' ');
        sb.append(""mCurrentPolicyId="").append(mCurrentPolicyId).append(' ');
        sb.append(""mPendingPolicyId="").append(mPendingPolicyId).append(' ');
        sb.append(""mCurrentPolicyGroupId="").append(mCurrentPolicyGroupId).append(' ');
        sb.append(""mNumberPolicyListeners="").append(mNumberPolicyListeners).append(' ');
        sb.append(""silentmode="").append(mMonitoringHw).append(',');
        sb.append(mSilentModeByHw).append(',').append(mForcedSilentMode).append(' ');
        sb.append(""enables="").append(String.join("","", mEnables)).append(' ');
        sb.append(""disables="").append(String.join("","", mDisables));
        sb.append(""controlledEnables="").append(String.join("","", mControlledEnables)).append(' ');
        sb.append(""controlledDisables="").append(String.join("","", mControlledDisables));
        sb.append(""changedComponents="").append(String.join("","", mChangedComponents));
        return sb.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CpmsFrameworkLayerStateInfo that = (CpmsFrameworkLayerStateInfo) o;
        return mCurrentState == that.mCurrentState
                && mMonitoringHw == that.mMonitoringHw
                && mSilentModeByHw == that.mSilentModeByHw
                && mForcedSilentMode == that.mForcedSilentMode
                && mNumberPolicyListeners == that.mNumberPolicyListeners
                && mEnables.equals(that.mEnables)
                && mDisables.equals(that.mDisables)
                && mPowerPolicyGroups.equals(that.mPowerPolicyGroups)
                && mControlledEnables.equals(that.mControlledEnables)
                && mControlledDisables.equals(that.mControlledDisables)
                && Arrays.equals(mChangedComponents, that.mChangedComponents)
                && Objects.equals(mCurrentPolicyId, that.mCurrentPolicyId)
                && Objects.equals(mPendingPolicyId, that.mPendingPolicyId)
                && Objects.equals(mCurrentPolicyGroupId, that.mCurrentPolicyGroupId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(mEnables, mDisables, mControlledEnables, mControlledDisables,
                mChangedComponents, mPowerPolicyGroups, mCurrentPolicyId, mPendingPolicyId,
                mCurrentPolicyGroupId, mCurrentState, mMonitoringHw, mSilentModeByHw,
                mForcedSilentMode, mNumberPolicyListeners);
    }

    public static CpmsFrameworkLayerStateInfo parse(String cmdOutput) throws Exception {
        int currentState = -1;
        String currentPolicyId = null;
        String pendingPolicyId = null;
        String currentPolicyGroupId = null;
        ArrayList<String> enables = null;
        ArrayList<String> disables = null;
        ArrayList<String> controlledEnables = null;
        ArrayList<String> controlledDisables = null;
        String[] changedComponents = null;
        PowerPolicyGroups policyGroups = null;
        boolean monitoringHw = false;
        boolean silentModeByHw = false;
        boolean forcedSilentMode = false;
        int numberPolicyListeners = 0;

        String[] lines = cmdOutput.split(""\n"");
        StateInfoParser parser = new StateInfoParser(lines);
        HashSet<String> headerCounter = new HashSet<String>();
        String header;
        while ((header = parser.searchHeader()) != null) {
            switch (header) {
                case CURRENT_STATE_HDR:
                    currentState = parser.getIntData(CURRENT_STATE_HDR);
                    break;
                case CURRENT_POLICY_ID_HDR:
                    currentPolicyId = parser.getStringData(CURRENT_POLICY_ID_HDR);
                    break;
                case PENDING_POLICY_ID_HDR:
                    pendingPolicyId = parser.getStringData(PENDING_POLICY_ID_HDR);
                    break;
                case CURRENT_POLICY_GROUP_ID_HDR:
                    currentPolicyGroupId = parser.getStringData(CURRENT_POLICY_GROUP_ID_HDR);
                    break;
                case POWER_POLICY_GROUPS_HDR:
                    ArrayList<String> groupList = parser.getStringArray(POWER_POLICY_GROUPS_HDR,
                            PREEMPTIVE_POWER_POLICY_HDR);
                    policyGroups = PowerPolicyGroups.parse(groupList);
                    break;
                case COMPONENT_STATE_HDR:
                    parser.parseComponentStates(COMPONENT_STATE_HDR,
                            COMPONENT_CONTROLLED_HDR, true);
                    enables = parser.getEnables();
                    disables = parser.getDisables();
                    Collections.sort(enables);
                    Collections.sort(disables);
                    break;
                case COMPONENT_CONTROLLED_HDR:
                    parser.parseComponentStates(COMPONENT_CONTROLLED_HDR,
                            COMPONENT_CHANGED_HDR, false);
                    controlledEnables = parser.getEnables();
                    controlledDisables = parser.getDisables();
                    Collections.sort(controlledEnables);
                    Collections.sort(controlledDisables);
                    break;
                case COMPONENT_CHANGED_HDR:
                    changedComponents = parser.getChangedComponents(COMPONENT_CHANGED_HDR,
                            MONITORING_HW_HDR);
                    break;
                case MONITORING_HW_HDR:
                    monitoringHw = parser.getBooleanData(MONITORING_HW_HDR);
                    break;
                case SILENT_MODE_BY_HW_HDR:
                    silentModeByHw = parser.getBooleanData(SILENT_MODE_BY_HW_HDR);
                    break;
                case FORCED_SILENT_MODE_HDR:
                    forcedSilentMode = parser.getBooleanData(FORCED_SILENT_MODE_HDR);
                    break;
                case NUMBER_POLICY_LISTENERS_HDR:
                    numberPolicyListeners = parser.getIntData(NUMBER_POLICY_LISTENERS_HDR);
                    break;
                default:
                    throw new IllegalArgumentException(""parser header mismatch: "" + header);
            }
            headerCounter.add(header);
        }

        if (headerCounter.size() != StateInfoParser.HEADERS.length) {
            String errMsg = ""miss headers. got: "" + headerCounter + "" expected: ""
                    + String.join("","", StateInfoParser.HEADERS);
            throw new IllegalArgumentException(errMsg);
        }

        return new CpmsFrameworkLayerStateInfo(currentPolicyId, pendingPolicyId,
                currentPolicyGroupId, numberPolicyListeners, changedComponents, enables,
                disables, policyGroups, controlledEnables, controlledDisables, monitoringHw,
                silentModeByHw, forcedSilentMode, currentState);
    }

    private static final class StateInfoParser {
        private static final String[] HEADERS = {
            CURRENT_STATE_HDR,
            CURRENT_POLICY_ID_HDR,
            PENDING_POLICY_ID_HDR,
            CURRENT_POLICY_GROUP_ID_HDR,
            NUMBER_POLICY_LISTENERS_HDR,
            COMPONENT_STATE_HDR,
            COMPONENT_CONTROLLED_HDR,
            POWER_POLICY_GROUPS_HDR,
            COMPONENT_CHANGED_HDR,
            MONITORING_HW_HDR,
            SILENT_MODE_BY_HW_HDR,
            FORCED_SILENT_MODE_HDR
        };
        private final String[] mLines;
        private ArrayList<String> mEnables;
        private ArrayList<String> mDisables;
        private int mIdx = 0;

        private StateInfoParser(String[] lines) {
            mLines = lines;
        }

        private ArrayList<String> getEnables() {
            return mEnables;
        }

        private ArrayList<String> getDisables() {
            return mDisables;
        }

        private int getIntData(String header) throws Exception {
            int val = 0;
            switch (header) {
                case CURRENT_STATE_HDR:
                    String[] tokens = mLines[mIdx].split("",*\\s"");
                    if (tokens.length != 6) {
                        throw new IllegalArgumentException(""malformatted mCurrentState: ""
                                + mLines[mIdx]);
                    }
                    val = Integer.parseInt(tokens[4].trim().substring(tokens[4].length() - 1));
                    break;
                case NUMBER_POLICY_LISTENERS_HDR:
                    int strLen = mLines[mIdx].length();
                    val = Integer.parseInt(mLines[mIdx].substring(strLen - 1).trim());
                    break;
                default:
                    break;
            }
            return val;
        }

        private String getStringData(String header) {
            String val = null;
            if (mLines[mIdx].trim().length() != header.length()) {
                val = mLines[mIdx].trim().substring(header.length()).trim();
            }
            return val;
        }

        private ArrayList<String> getStringArray(String startHdr, String endHdr)
                throws Exception {
            if (!mLines[mIdx].contains(startHdr)) {
                String errMsg = String.format(""expected start header %s at line %d : %s"",
                        startHdr, mIdx, mLines[mIdx]);
                throw new IllegalArgumentException(errMsg);
            }

            ArrayList<String> strArray = new ArrayList<String>();
            while (++mIdx < mLines.length && !mLines[mIdx].contains(endHdr)) {
                strArray.add(mLines[mIdx]);
            }
            mIdx--;

            if (mIdx == (mLines.length - 1)) {
                throw new IllegalArgumentException(""reaches the end while get "" + startHdr);
            }
            return strArray;
        }

        private void parseComponentStates(String startHdr, String endHdr,
                boolean hasStateInfo) throws Exception {
            mEnables = new ArrayList<String>();
            mDisables = new ArrayList<String>();
            while (mIdx < (mLines.length - 1) && !mLines[++mIdx].contains(endHdr)) {
                String stateStr = mLines[mIdx].trim();
                String[] vals = stateStr.split("":\\s"");
                if (hasStateInfo && vals.length != 2) {
                    String errMsg = String.format(""wrong format at %d in: %s "", mIdx, stateStr);
                    CLog.e(errMsg);
                    throw new IllegalArgumentException(errMsg);
                }

                for (int i = 0; i < vals.length; i++) {
                    vals[i] = vals[i].trim();
                }

                if (!COMPONENT_SET.contains(vals[0])) {
                    String errMsg = String.format(""invalid component at %d with %s in: %s"",
                            mIdx, vals[0], stateStr);
                    CLog.e(errMsg);
                    throw new IllegalArgumentException(errMsg);
                }

                if (hasStateInfo) {
                    if (vals[1].startsWith(""on"")) {
                        mEnables.add(vals[0]);
                    } else if (vals[1].startsWith(""off"")) {
                        mDisables.add(vals[0]);
                    } else {
                        String errMsg =
                                String.format(""wrong state value at %d with (%s, %s) in: %s"",
                                mIdx, vals[0], vals[1], stateStr);
                        CLog.e(errMsg);
                        throw new IllegalArgumentException(errMsg);
                    }
                } else {
                    mDisables.add(vals[0]);
                }
            }
            mIdx--;

            if (mIdx == (mLines.length - 1)) {
                throw new IllegalArgumentException(""reaches the end while parse "" + startHdr);
            }
        }

        private String[] getChangedComponents(String startHdr, String endHdr) {
            int idx = mLines[mIdx].indexOf(endHdr);
            String compStr;
            if (idx < 0) {
                compStr = mLines[mIdx].substring(startHdr.length());
            } else {
                compStr = mLines[mIdx].substring(startHdr.length(), idx);
                mLines[mIdx] = mLines[mIdx].substring(idx);
                mIdx--;
            }
            return compStr.split("",\\s*"");
        }

        private boolean getBooleanData(String header) {
            return Boolean.parseBoolean(mLines[mIdx].trim().substring(header.length()).trim());
        }

        private String searchHeader() {
            String header = null;
            for (mIdx++; mIdx < mLines.length; mIdx++) {
                if (mLines[mIdx].trim().isEmpty()) {
                    continue;
                }

                int firstHdrPos = mLines[mIdx].length() + 1;
                for (int i = 0; i < HEADERS.length; i++) {
                    int tempHdrPos = mLines[mIdx].indexOf(HEADERS[i]);
                    if (tempHdrPos >= 0 && (firstHdrPos > tempHdrPos)) {
                        firstHdrPos = tempHdrPos;
                        header = HEADERS[i];
                    }
                }
                if (header != null) {
                    break;
                }
            }

            return header;
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.DelegatedCertInstallerTest"	"testInstallKeyPair"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/DelegatedCertInstallerTest.java"	""	"public void testInstallKeyPair() throws InterruptedException, KeyChainException {
        final String alias = ""delegated-cert-installer-test-key"";

        // Clear delegated cert installer.
        mDpm.setCertInstallerPackage(ADMIN_RECEIVER_COMPONENT, null);
        // The app is not the cert installer , it shouldn't have have privilege to call
        // installKeyPair().
        installKeyPair(TestCertificates.TEST_KEY, TestCertificates.TEST_CERT, alias);
        assertResult(""installKeyPair"", false);

        // Set the app to be cert installer.
        mDpm.setCertInstallerPackage(ADMIN_RECEIVER_COMPONENT, CERT_INSTALLER_PACKAGE);
        assertEquals(CERT_INSTALLER_PACKAGE,
                mDpm.getCertInstallerPackage(ADMIN_RECEIVER_COMPONENT));

        // Exercise installKeyPair()
        installKeyPair(TestCertificates.TEST_KEY, TestCertificates.TEST_CERT, alias);
        assertResult(""installKeyPair"", true);
    }

    /**
     * If DPC is targeting N+, @{link IllegalArgumentException } should be thrown if the package
     * is missing.
     */"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testWorkProfileMaximumTimeOff_complianceRequiredBroadcastDefault"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testWorkProfileMaximumTimeOff_complianceRequiredBroadcastDefault()
            throws Exception {
        installAppAsUser(DEVICE_ADMIN_APK, mPrimaryUserId);
        // Very long timeout, won't be triggered
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".PersonalAppsSuspensionTest"",
                ""testSetManagedProfileMaximumTimeOff1Year"", mUserId);

        try {
            toggleQuietMode(true);
            waitForUserStopped(mUserId);
            toggleQuietMode(false);
            waitForUserUnlock(mUserId);
            // Ensure the DPC has handled the broadcast
            waitForBroadcastIdle();
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".PersonalAppsSuspensionTest"",
                    ""testComplianceAcknowledgementRequiredReceived"", mUserId);

            // Ensure that the default onComplianceAcknowledgementRequired acknowledged compliance.
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".PersonalAppsSuspensionTest"",
                    ""testComplianceAcknowledgementNotRequired"", mUserId);

        } finally {
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".PersonalAppsSuspensionTest"",
                    ""testClearComplianceSharedPreference"", mUserId);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testWorkProfileMaximumTimeOff_complianceRequiredBroadcastOverride"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testWorkProfileMaximumTimeOff_complianceRequiredBroadcastOverride()
            throws Exception {
        installAppAsUser(DEVICE_ADMIN_APK, mPrimaryUserId);
        // Very long timeout, won't be triggered
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".PersonalAppsSuspensionTest"",
                ""testSetManagedProfileMaximumTimeOff1Year"", mUserId);
        // Set shared preference that instructs the receiver to NOT call default implementation.
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".PersonalAppsSuspensionTest"",
                ""testSetOverrideOnComplianceAcknowledgementRequired"", mUserId);

        try {
            toggleQuietMode(true);
            waitForUserStopped(mUserId);
            toggleQuietMode(false);
            waitForUserUnlock(mUserId);
            // Ensure the DPC has handled the broadcast
            waitForBroadcastIdle();
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".PersonalAppsSuspensionTest"",
                    ""testComplianceAcknowledgementRequiredReceived"", mUserId);

            // Ensure compliance wasn't acknowledged automatically, acknowledge explicitly.
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".PersonalAppsSuspensionTest"",
                    ""testAcknowledgeCompliance"", mUserId);
        } finally {
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".PersonalAppsSuspensionTest"",
                    ""testClearComplianceSharedPreference"", mUserId);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"library.main.java.com.android.bedstead.remotedpc.RemoteDpc"	"TestApis"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/remotedpc/src/library/main/java/com/android/bedstead/remotedpc/RemoteDpc.java"	""	"public void test/*
 *.
 */

package com.android.bedstead.remotedpc;

import static com.android.bedstead.remotedpc.Configuration.REMOTE_DPC_COMPONENT_NAME;
import static com.android.compatibility.common.util.FileUtils.readInputStreamFully;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.os.UserHandle;

import androidx.annotation.Nullable;

import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.devicepolicy.DeviceOwner;
import com.android.bedstead.nene.devicepolicy.DevicePolicyController;
import com.android.bedstead.nene.devicepolicy.ProfileOwner;
import com.android.bedstead.nene.exceptions.NeneException;
import com.android.bedstead.nene.users.UserReference;
import com.android.bedstead.remotedpc.connected.RemoteDPCBinder;
import com.android.bedstead.remotedpc.managers.RemoteDevicePolicyManager;
import com.android.bedstead.remotedpc.managers.RemoteDevicePolicyManager_Wrapper;

import com.google.android.enterprise.connectedapps.CrossProfileConnector;

import java.io.IOException;
import java.io.InputStream;

/** Entry point to RemoteDPC. */
public final class RemoteDpc {

    private static final TestApis sTestApis = new TestApis();
    // This must be instrumentation not instrumented to access the resources
    private static final Context sContext = sTestApis.context().instrumentationContext();

    public static final ComponentName DPC_COMPONENT_NAME = REMOTE_DPC_COMPONENT_NAME;

    /**
     * Get the {@link RemoteDpc} instance for the Device Owner.
     *
     * <p>This will return {@code null} if there is no Device Owner or it is not a RemoteDPC app.
     */
    @Nullable
    public static RemoteDpc deviceOwner() {
        DeviceOwner deviceOwner = sTestApis.devicePolicy().getDeviceOwner();
        if (deviceOwner == null || !deviceOwner.componentName().equals(DPC_COMPONENT_NAME)) {
            return null;
        }

        return new RemoteDpc(deviceOwner);
    }

    /**
     * Get the {@link RemoteDpc} instance for the Profile Owner of the current user.
     *
     * <p>This will return null if there is no Profile Owner or it is not a RemoteDPC app.
     */
    @Nullable
    public static RemoteDpc profileOwner() {
        return profileOwner(sTestApis.users().instrumented());
    }

    /**
     * Get the {@link RemoteDpc} instance for the Profile Owner of the given {@code profile}.
     *
     * <p>This will return null if there is no Profile Owner or it is not a RemoteDPC app.
     */
    @Nullable
    public static RemoteDpc profileOwner(UserHandle profile) {
        if (profile == null) {
            throw new NullPointerException();
        }

        return profileOwner(sTestApis.users().find(profile));
    }

    /**
     * Get the {@link RemoteDpc} instance for the Profile Owner of the given {@code profile}.
     *
     * <p>This will return null if there is no Profile Owner or it is not a RemoteDPC app.
     */
    @Nullable
    public static RemoteDpc profileOwner(UserReference profile) {
        if (profile == null) {
            throw new NullPointerException();
        }

        ProfileOwner profileOwner = sTestApis.devicePolicy().getProfileOwner(profile);
        if (profileOwner == null || !profileOwner.componentName().equals(DPC_COMPONENT_NAME)) {
            return null;
        }

        return new RemoteDpc(profileOwner);
    }

    /**
     * Get the most specific {@link RemoteDpc} instance for the current user.
     *
     * <p>If the user has a RemoteDPC Profile Owner, this will refer to that. If it does not but
     * has a RemoteDPC Device Owner it will refer to that. Otherwise it will return null.
     */
    @Nullable
    public static RemoteDpc any() {
        return any(sTestApis.users().instrumented());
    }

    /**
     * Get the most specific {@link RemoteDpc} instance for the current user.
     *
     * <p>If the user has a RemoteDPC Profile Owner, this will refer to that. If it does not but
     * has a RemoteDPC Device Owner it will refer to that. Otherwise it will return null.
     */
    @Nullable
    public static RemoteDpc any(UserHandle user) {
        if (user == null) {
            throw new NullPointerException();
        }

        return any(sTestApis.users().find(user));
    }

    /**
     * Get the most specific {@link RemoteDpc} instance for the current user.
     *
     * <p>If the user has a RemoteDPC Profile Owner, this will refer to that. If it does not but
     * has a RemoteDPC Device Owner it will refer to that. Otherwise it will return null.
     */
    @Nullable
    public static RemoteDpc any(UserReference user) {
        RemoteDpc remoteDPC = profileOwner(user);
        if (remoteDPC != null) {
            return remoteDPC;
        }
        return deviceOwner();
    }

    /**
     * Get the {@link RemoteDpc} controller for the given {@link DevicePolicyController}.
     */
    public static RemoteDpc forDevicePolicyController(DevicePolicyController controller) {
        if (controller == null) {
            throw new NullPointerException();
        }
        if (!controller.componentName().equals(REMOTE_DPC_COMPONENT_NAME)) {
            throw new IllegalStateException(""DevicePolicyController is not a RemoteDPC: ""
                    + controller);
        }

        return new RemoteDpc(controller);
    }

    /**
     * Set RemoteDPC as the Device Owner.
     */
    public static RemoteDpc setAsDeviceOwner(UserHandle user) {
        if (user == null) {
            throw new NullPointerException();
        }
        return setAsDeviceOwner(sTestApis.users().find(user));
    }

    /**
     * Set RemoteDPC as the Device Owner.
     */
    public static RemoteDpc setAsDeviceOwner(UserReference user) {
        if (user == null) {
            throw new NullPointerException();
        }

        DeviceOwner deviceOwner = sTestApis.devicePolicy().getDeviceOwner();
        if (deviceOwner != null) {
            if (deviceOwner.componentName().equals(DPC_COMPONENT_NAME)) {
                return new RemoteDpc(deviceOwner); // Already set
            }
            deviceOwner.remove();
        }

        ensureInstalled(user);
        return new RemoteDpc(sTestApis.devicePolicy().setDeviceOwner(user,
                REMOTE_DPC_COMPONENT_NAME));
    }

    /**
     * Set RemoteDPC as the Profile Owner.
     */
    public static RemoteDpc setAsProfileOwner(UserHandle user) {
        if (user == null) {
            throw new NullPointerException();
        }
        return setAsProfileOwner(sTestApis.users().find(user));
    }

    /**
     * Set RemoteDPC as the Profile Owner.
     */
    public static RemoteDpc setAsProfileOwner(UserReference user) {
        if (user == null) {
            throw new NullPointerException();
        }

        ProfileOwner profileOwner = sTestApis.devicePolicy().getProfileOwner(user);
        if (profileOwner != null) {
            if (profileOwner.componentName().equals(DPC_COMPONENT_NAME)) {
                return new RemoteDpc(profileOwner); // Already set
            }
            profileOwner.remove();
        }

        ensureInstalled(user);
        return new RemoteDpc(sTestApis.devicePolicy().setProfileOwner(user,
                REMOTE_DPC_COMPONENT_NAME));
    }

    private static void ensureInstalled(UserReference user) {
        sTestApis.packages().install(user, apkBytes());
    }

    private static byte[] apkBytes() {
        int apkId = sContext.getResources().getIdentifier(
                ""raw/RemoteDPC_DPC"", /* defType= */ null, sContext.getPackageName());
        try (InputStream inputStream =
                     sContext.getResources().openRawResource(apkId)) {
            return readInputStreamFully(inputStream);
        } catch (IOException e) {
            throw new NeneException(""Error when reading RemoteDPC bytes"", e);
        }
    }

    private final DevicePolicyController mDevicePolicyController;
    private final CrossProfileConnector mConnector;

    private RemoteDpc(DevicePolicyController devicePolicyController) {
        if (devicePolicyController == null) {
            throw new NullPointerException();
        }
        mDevicePolicyController = devicePolicyController;
        mConnector = CrossProfileConnector.builder(sTestApis.context().instrumentedContext())
                .setBinder(new RemoteDPCBinder(this))
                .build();
    }

    /**
     * Get the {@link DevicePolicyController} for this instance of RemoteDPC.
     */
    public DevicePolicyController devicePolicyController() {
        return mDevicePolicyController;
    }

    /**
     * Remove RemoteDPC as Device Owner or Profile Owner and uninstall the APK from the user.
     */
    public void remove() {
        mDevicePolicyController.remove();
        sTestApis.packages().find(REMOTE_DPC_COMPONENT_NAME.getPackageName())
                .uninstall(mDevicePolicyController.user());
    }

    @Override
    public int hashCode() {
        return mDevicePolicyController.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof RemoteDpc)) {
            return false;
        }

        RemoteDpc other = (RemoteDpc) obj;
        return other.mDevicePolicyController.equals(mDevicePolicyController);
    }

    /**
     * Get a {@link RemoteDevicePolicyManager} to make calls to {@link DevicePolicyManager} using
     * this RemoteDPC.
     */
    public RemoteDevicePolicyManager devicePolicyManager() {
        return new RemoteDevicePolicyManager_Wrapper(mConnector);
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.util.devicepolicy.provisioning.SilentProvisioningTestManager"	"getReceviedProfileProvisionedIntent"	""	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/devicepolicy/provisioning/SilentProvisioningTestManager.java"	""	"public void test/*
 *.
 */
package com.android.compatibility.common.util.devicepolicy.provisioning;

import static android.app.admin.DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED;
import static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE;
import static android.content.Intent.ACTION_MANAGED_PROFILE_ADDED;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.RemoteException;
import android.support.test.uiautomator.UiDevice;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.BlockingBroadcastReceiver;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

// TODO(b/183395856): Remove once the remaining silent provisioning tests are removed.
public class SilentProvisioningTestManager {
    private static final long TIMEOUT_SECONDS = 120L;
    private static final String TAG = ""SilentProvisioningTest"";

    private final LinkedBlockingQueue<Boolean> mProvisioningResults = new LinkedBlockingQueue(1);

    private final IBooleanCallback mProvisioningResultCallback = new IBooleanCallback.Stub() {
        @Override
        public void onResult(boolean result) {
            try {
                mProvisioningResults.put(result);
            } catch (InterruptedException e) {
                Log.e(TAG, ""IBooleanCallback.callback"", e);
            }
        }
    };

    private final Context mContext;
    private Intent mReceivedProfileProvisionedIntent;

    public SilentProvisioningTestManager(Context context) {
        mContext = context.getApplicationContext();
    }

    public Intent getReceviedProfileProvisionedIntent() {
        return mReceivedProfileProvisionedIntent;
    }

    public boolean startProvisioningAndWait(Intent provisioningIntent) throws InterruptedException {
        wakeUpAndDismissInsecureKeyguard();
        mContext.startActivity(getStartIntent(provisioningIntent));
        Log.i(TAG, ""startActivity on user "" + mContext.getUserId() + "" with "" + provisioningIntent);

        if (ACTION_PROVISION_MANAGED_PROFILE.equals(provisioningIntent.getAction())) {
            return waitManagedProfileProvisioning();
        } else {
            return waitDeviceOwnerProvisioning();
        }
    }

    private boolean waitDeviceOwnerProvisioning() throws InterruptedException {
        return pollProvisioningResult();
    }

    private boolean waitManagedProfileProvisioning() throws InterruptedException {
        BlockingBroadcastReceiver managedProfileProvisionedReceiver =
                new BlockingBroadcastReceiver(mContext, ACTION_MANAGED_PROFILE_PROVISIONED);
        BlockingBroadcastReceiver managedProfileAddedReceiver =
                new BlockingBroadcastReceiver(mContext, ACTION_MANAGED_PROFILE_ADDED);
        try {
            managedProfileProvisionedReceiver.register();
            managedProfileAddedReceiver.register();

            if (!pollProvisioningResult()) {
                return false;
            }

            mReceivedProfileProvisionedIntent =
                    managedProfileProvisionedReceiver.awaitForBroadcast(
                            TimeUnit.SECONDS.toMillis(TIMEOUT_SECONDS));
            if (mReceivedProfileProvisionedIntent == null) {
                Log.i(TAG, ""managedProfileProvisionedReceiver.awaitForBroadcast(): failed"");
                return false;
            }

            if (managedProfileAddedReceiver.awaitForBroadcast(
                    TimeUnit.SECONDS.toMillis(TIMEOUT_SECONDS)) == null) {
                Log.i(TAG, ""managedProfileAddedReceiver.awaitForBroadcast(): failed"");
                return false;
            }
        } finally {
            managedProfileProvisionedReceiver.unregisterQuietly();
            managedProfileAddedReceiver.unregisterQuietly();
        }
        return true;
    }

    private boolean pollProvisioningResult() throws InterruptedException {
        Boolean result = mProvisioningResults.poll(TIMEOUT_SECONDS, TimeUnit.SECONDS);
        if (result == null) {
            Log.i(TAG, ""ManagedProvisioning doesn't return result within ""
                    + TIMEOUT_SECONDS + "" seconds "");
            return false;
        }

        if (!result) {
            Log.i(TAG, ""Failed to provision"");
            return false;
        }
        return true;
    }

    private Intent getStartIntent(Intent intent) {
        final Bundle bundle = new Bundle();
        bundle.putParcelable(Intent.EXTRA_INTENT, intent);
        bundle.putBinder(StartProvisioningActivity.EXTRA_BOOLEAN_CALLBACK,
                mProvisioningResultCallback.asBinder());
        return new Intent(mContext, StartProvisioningActivity.class)
                .putExtras(bundle)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    }

    private static void wakeUpAndDismissInsecureKeyguard() {
        try {
            UiDevice uiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
            uiDevice.wakeUp();
            uiDevice.pressMenu();
        } catch (RemoteException e) {
            Log.e(TAG, ""wakeUpScreen"", e);
        }
    }

    private static class BlockingReceiver extends BroadcastReceiver {

        private final CountDownLatch mLatch = new CountDownLatch(1);
        private final Context mContext;
        private final String mAction;
        private Intent mReceivedIntent;

        private BlockingReceiver(Context context, String action) {
            mContext = context;
            mAction = action;
            mReceivedIntent = null;
        }

        public void register() {
            mContext.registerReceiver(this, new IntentFilter(mAction));
        }

        public boolean await() throws InterruptedException {
            return mLatch.await(TIMEOUT_SECONDS, TimeUnit.SECONDS);
        }

        public Intent getReceivedIntent() {
            return mReceivedIntent;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            mReceivedIntent = intent;
            mLatch.countDown();
        }
    }
}"	""	""	"ACTION_MANAGED_PROFILE_PROVISIONED"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.media.tv.tuner.cts.TunerFrontendTest"	"testAtsc3FrontendSettings"	"CtsTvTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/tuner/cts/TunerFrontendTest.java"	""	"public void testAtsc3FrontendSettings() throws Exception {
        Atsc3PlpSettings plp1 =
                Atsc3PlpSettings
                        .builder()
                        .setPlpId(1)
                        .setModulation(Atsc3FrontendSettings.MODULATION_MOD_QPSK)
                        .setInterleaveMode(Atsc3FrontendSettings.TIME_INTERLEAVE_MODE_AUTO)
                        .setCodeRate(Atsc3FrontendSettings.CODERATE_6_15)
                        .setFec(Atsc3FrontendSettings.FEC_BCH_LDPC_64K)
                        .build();

        Atsc3PlpSettings plp2 =
                Atsc3PlpSettings
                        .builder()
                        .setPlpId(2)
                        .setModulation(Atsc3FrontendSettings.MODULATION_MOD_QPSK)
                        .setInterleaveMode(Atsc3FrontendSettings.TIME_INTERLEAVE_MODE_HTI)
                        .setCodeRate(Atsc3FrontendSettings.CODERATE_UNDEFINED)
                        .setFec(Atsc3FrontendSettings.FEC_LDPC_16K)
                        .build();

        Atsc3FrontendSettings settings =
                Atsc3FrontendSettings
                        .builder()
                        .setFrequency(2)
                        .setBandwidth(Atsc3FrontendSettings.BANDWIDTH_BANDWIDTH_6MHZ)
                        .setDemodOutputFormat(Atsc3FrontendSettings.MODULATION_MOD_QPSK)
                        .setPlpSettings(new Atsc3PlpSettings[] {plp1, plp2})
                        .build();

        settings.setSpectralInversion(FrontendSettings.FRONTEND_SPECTRAL_INVERSION_NORMAL);
        settings.setEndFrequency(100);

        assertEquals(FrontendSettings.TYPE_ATSC3, settings.getType());
        assertEquals(2, settings.getFrequency());
        assertEquals(Atsc3FrontendSettings.BANDWIDTH_BANDWIDTH_6MHZ, settings.getBandwidth());
        assertEquals(Atsc3FrontendSettings.MODULATION_MOD_QPSK, settings.getDemodOutputFormat());

        Atsc3PlpSettings[] plps = settings.getPlpSettings();
        assertEquals(2, plps.length);

        assertEquals(1, plps[0].getPlpId());
        assertEquals(Atsc3FrontendSettings.MODULATION_MOD_QPSK, plps[0].getModulation());
        assertEquals(Atsc3FrontendSettings.TIME_INTERLEAVE_MODE_AUTO, plps[0].getInterleaveMode());
        assertEquals(Atsc3FrontendSettings.CODERATE_6_15, plps[0].getCodeRate());
        assertEquals(Atsc3FrontendSettings.FEC_BCH_LDPC_64K, plps[0].getFec());

        assertEquals(2, plps[1].getPlpId());
        assertEquals(Atsc3FrontendSettings.MODULATION_MOD_QPSK, plps[1].getModulation());
        assertEquals(Atsc3FrontendSettings.TIME_INTERLEAVE_MODE_HTI, plps[1].getInterleaveMode());
        assertEquals(Atsc3FrontendSettings.CODERATE_UNDEFINED, plps[1].getCodeRate());
        assertEquals(Atsc3FrontendSettings.FEC_LDPC_16K, plps[1].getFec());

        if (TunerVersionChecker.isHigherOrEqualVersionTo(TunerVersionChecker.TUNER_VERSION_1_1)) {
            assertEquals(FrontendSettings.FRONTEND_SPECTRAL_INVERSION_NORMAL,
                    settings.getFrontendSpectralInversion());
            assertEquals(100, settings.getEndFrequency());
        } else {
            assertEquals(FrontendSettings.FRONTEND_SPECTRAL_INVERSION_UNDEFINED,
                    settings.getFrontendSpectralInversion());
            assertEquals(Tuner.INVALID_FRONTEND_SETTING_FREQUENCY, settings.getEndFrequency());
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.ProtocolParamsEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ProtocolParamsEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class ProtocolParamsEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(true);
    }

    @Override
    protected void onResume() {
        super.onResume();
        NfcDialogs.createHceTapReaderDialog(this,
                getString(R.string.nfc_hce_protocol_params_emulator_help)).show();
    }

    @Override
    void onServicesSetup(boolean result) {
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.ndef.cts.NdefTest"	"testCreateUri"	"CtsNdefTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/ndef/src/android/ndef/cts/NdefTest.java"	""	"public void testCreateUri() {
        assertEquals(new byte[] {
                (byte)0xD1, 1, 8, 'U', (byte)0x01, 'n', 'f', 'c', '.', 'c', 'o', 'm'},
                new NdefMessage(
                        NdefRecord.createUri(Uri.parse(""http://www.nfc.com""))).toByteArray());

        assertEquals(new byte[] {(byte)0xD1, 1, 13, 'U', (byte)0x05,
                '+', '3', '5', '8', '9', '1', '2', '3', '4', '5', '6', '7'},
                new NdefMessage(NdefRecord.createUri(""tel:+35891234567"")).toByteArray());

        assertEquals(new byte[] {
                (byte)0xD1, 1, 4, 'U', (byte)0x00, 'f', 'o', 'o'},
                new NdefMessage(NdefRecord.createUri(""foo"")).toByteArray());

        // make sure UTF-8 encoding is used
        assertEquals(new byte[] {
                (byte)0xD1, 1, 3, 'U', (byte)0x00, (byte)0xC2, (byte)0xA2},
                new NdefMessage(NdefRecord.createUri(""\u00A2"")).toByteArray());
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.ndef.cts.NdefTest"	"testToUri"	"CtsNdefTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/ndef/src/android/ndef/cts/NdefTest.java"	""	"public void testToUri() {
        // absolute uri
        assertEquals(Uri.parse(""http://www.android.com""),
                new NdefRecord(NdefRecord.TNF_ABSOLUTE_URI,
                ""http://www.android.com"".getBytes(), null, null).toUri());
        // wkt uri
        assertEquals(Uri.parse(""http://www.android.com""),
                NdefRecord.createUri(""http://www.android.com"").toUri());
        // smart poster with absolute uri
        assertEquals(Uri.parse(""http://www.android.com""),
                new NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_SMART_POSTER, null,
                new NdefMessage(new NdefRecord(NdefRecord.TNF_ABSOLUTE_URI,
                ""http://www.android.com"".getBytes(), null, null)).toByteArray()).toUri());
        // smart poster with wkt uri
        assertEquals(Uri.parse(""http://www.android.com""),
                new NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_SMART_POSTER, null,
                new NdefMessage(
                NdefRecord.createUri(""http://www.android.com"")).toByteArray()).toUri());
        // smart poster with text and wkt uri
        assertEquals(Uri.parse(""http://www.android.com""),
                new NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_SMART_POSTER, null,
                new NdefMessage(new NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_TEXT, null,
                null), NdefRecord.createUri(""http://www.android.com"")).toByteArray()).toUri());
        // external type
        assertEquals(Uri.parse(""vnd.android.nfc://ext/com.foo.bar:type""),
                NdefRecord.createExternal(""com.foo.bar"", ""type"", null).toUri());
        // check normalization
        assertEquals(Uri.parse(""http://www.android.com""),
                new NdefRecord(NdefRecord.TNF_ABSOLUTE_URI, ""HTTP://www.android.com"".getBytes(),
                null, null).toUri());

        // not uri's
        assertEquals(null, NdefRecord.createMime(""text/plain"", null).toUri());
        assertEquals(null, new NdefRecord(NdefRecord.TNF_EMPTY, null, null, null).toUri());
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hcef.HceFReaderActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hcef/HceFReaderActivity.java"	""	"public void test/*
 *.
 */
package com.android.cts.verifier.nfc.hcef;

import android.annotation.TargetApi;
import android.nfc.NfcAdapter;
import android.nfc.NfcAdapter.ReaderCallback;
import android.nfc.Tag;
import android.nfc.tech.NfcF;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.io.IOException;

@TargetApi(24)
public class HceFReaderActivity extends PassFailButtons.Activity implements ReaderCallback,
        OnItemSelectedListener {
    public static final String TAG = ""HceFReaderActivity"";

    NfcAdapter mAdapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mAdapter = NfcAdapter.getDefaultAdapter(this);
    }

    @Override
    protected void onResume() {
        super.onResume();
        mAdapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_F |
                NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);
    }

    static byte[] createEchoCommand(byte[] nfcid2, byte[] payload) {
        byte length = (byte) (2 + nfcid2.length + payload.length);

        byte[] echo_cmd = new byte[length];
        echo_cmd[0] = length;
        echo_cmd[1] = MyHostFelicaService.CMD_ECHO;
        System.arraycopy(nfcid2, 0, echo_cmd, 2, nfcid2.length);
        System.arraycopy(payload, 0, echo_cmd, 2 + nfcid2.length, payload.length);
        return echo_cmd;
    }

    static byte[] createSuccessCommand(byte[] nfcid2) {
        byte[] cmd = new byte[2 + nfcid2.length];
        cmd[0] = (byte) (2 + nfcid2.length);
        cmd[1] = MyHostFelicaService.CMD_SUCCESS;
        System.arraycopy(nfcid2, 0, cmd, 2, nfcid2.length);
        return cmd;
    }

    static boolean verifyResponse(byte[] cmd, byte[] resp) {
        if (resp == null) return false;

        // Verify length
        if (resp[0] != resp.length) return false;
        if (resp.length != cmd.length) return false;
        // Verify cmd
        if (resp[1] != MyHostFelicaService.RESPONSE_ECHO) return false;

        // Verify rest of data
        for (int i = 2; i < resp.length; i++) {
            if (resp[i] != cmd[i]) return false;
        }

        return true;
    }

    @Override
    public void onTagDiscovered(Tag tag) {
        NfcF felica = NfcF.get(tag);
        if (felica == null) return;

        try {
            felica.connect();
     byte[] command =
      new byte[]{6, 0x00, (byte)0x40, (byte)0x01, 0x00, 0x00}; // in this case, SC of HCE-F is 4001h
     felica.transceive(command);
            for (int i = 0; i < 32; i++) {
                byte[] payload = new byte[] {0x14, (byte)i};
                byte[] echo_cmd = createEchoCommand(MyHostFelicaService.NFCID2, payload);
                byte[] resp = felica.transceive(echo_cmd);
                if (!verifyResponse(echo_cmd, resp)) {
                    Log.e(TAG, ""Echo response not correct."");
                    return;
                }
            }
            // All successful, send success cmd
            byte[] success_cmd = createSuccessCommand(MyHostFelicaService.NFCID2);
            felica.transceive(success_cmd);

            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    getPassButton().setEnabled(true);
                }
            });
        } catch (IOException e) {
            Log.e(TAG, ""IOException, try again."");
        }
    }

    @Override
    public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {

    }

    @Override
    public void onNothingSelected(AdapterView<?> parent) {

    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.DynamicAidEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/DynamicAidEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.nfc.cardemulation.CardEmulation;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

import java.util.ArrayList;

public class DynamicAidEmulatorActivity extends BaseEmulatorActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.pass_fail_text);
       setPassFailButtonClickListeners();
       getPassButton().setEnabled(false);
       setupServices(this, PaymentServiceDynamicAids.COMPONENT);
    }


    @Override
    protected void onResume() {
        super.onResume();
    }


    @Override
    void onServicesSetup(boolean result) {
        ArrayList<String> paymentAids = new ArrayList<String>();
        paymentAids.add(HceUtils.PPSE_AID);
        paymentAids.add(HceUtils.VISA_AID);
        // Register a different set of AIDs for the foreground
        mCardEmulation.registerAidsForService(PaymentServiceDynamicAids.COMPONENT,
                CardEmulation.CATEGORY_PAYMENT, paymentAids);
        // Now make sure it's default
        if (makePaymentDefault(PaymentServiceDynamicAids.COMPONENT,
                R.string.nfc_hce_change_preinstalled_wallet)) {
            // Wait for callback
        } else {
         NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_hce_payment_dynamic_aids_help)).show();
        }
    }

    @Override
    void onPaymentDefaultResult(ComponentName component, boolean success) {
        if (success) {
         NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_hce_payment_dynamic_aids_help)).show();
        }
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(PaymentServiceDynamicAids.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                PaymentServiceDynamicAids.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                PaymentServiceDynamicAids.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_payment_dynamic_aids_reader));
        return readerIntent;
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2040"	"testPocCVE_2019_2040"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2040.java"	""	"@AsbSecurityTest(cveBugId = 122316913)
    public void testPocCVE_2019_2040() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2040"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.SettingsIntentsTest"	"testNfc"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/SettingsIntentsTest.java"	""	"public void testNfc() {
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_NFC)) {
            assertNotNull(mPackageManager.resolveActivity(
                    new Intent(Settings.ACTION_NFC_SETTINGS), 0 /* flags */));
        }
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.TapTestEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/TapTestEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.widget.TextView;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

@TargetApi(19)
public class TapTestEmulatorActivity extends BaseEmulatorActivity {
    TextView mTextView;
    int mNumTaps;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        mTextView = (TextView) findViewById(R.id.text);
        setupServices(this, TransportService1.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
        mNumTaps = 0;
        mTextView.setText(""Number of successful taps: 0/50."");
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this,
                getString(R.string.nfc_hce_tap_test_emulator_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                TransportService1.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                TransportService1.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_tap_test_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(TransportService1.COMPONENT)) {
            mNumTaps++;
            if (mNumTaps <= 50) {
                mTextView.setText(""Number of successful taps: "" + Integer.toString(mNumTaps) +
                        ""/50."");
            }
            if (mNumTaps >= 50) {
                getPassButton().setEnabled(true);
            }
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.offhost.UiccTransactionEvent3EmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/offhost/UiccTransactionEvent3EmulatorActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.offhost;

import android.annotation.TargetApi;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.nfc.NfcAdapter;
import android.nfc.cardemulation.CardEmulation;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import com.android.cts.verifier.nfc.hce.HceUtils;

public class UiccTransactionEvent3EmulatorActivity extends PassFailButtons.Activity {
    static final String TAG = ""UiccTransactionEvent3EmulatorActivity"";

    TextView mTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.R) {
            getPassButton().setEnabled(false);
        } else {
            getPassButton().setEnabled(true);
        }

        mTextView = (TextView) findViewById(R.id.text);
        mTextView.setTextSize(12.0f);
        mTextView.setText(R.string.nfc_offhost_uicc_transaction_event_emulator_help);

        initProcess();
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);

        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mTextView = (TextView) findViewById(R.id.text);
        mTextView.setTextSize(12.0f);

        setIntent(intent);
        initProcess();
    }

    @Override
    protected void onPause() {
        super.onPause();
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleOffhostReaderActivity.class);
        readerIntent.putExtra(SimpleOffhostReaderActivity.EXTRA_APDUS,
                UiccTransactionEvent3Service.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleOffhostReaderActivity.EXTRA_RESPONSES,
                UiccTransactionEvent3Service.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleOffhostReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_offhost_uicc_transaction_event3_reader));
        return readerIntent;
    }

    private void initProcess() {
        Bundle bundle = getIntent().getExtras();
        if(bundle != null){
            byte[] transactionData = bundle.getByteArray(NfcAdapter.EXTRA_DATA);
            if(transactionData != null){
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(""Pass - NFC Action:"" + getIntent().getAction() + "" uri:"" + getIntent().getDataString()
                            + "" data:"" + HceUtils.getHexBytes(null, transactionData));
                        getPassButton().setEnabled(true);
                    }
                });
            } else {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(""Fail - Action:"" + getIntent().getAction() + "" uri:"" + getIntent().getDataString()
                            + "" data: null"");
                        getPassButton().setEnabled(false);
                    }
                });
            }
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.ScreenOnOnlyOffHostEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ScreenOnOnlyOffHostEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class ScreenOnOnlyOffHostEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        setupServices(this, ScreenOnOnlyOffHostService.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_screen_on_only_offhost_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                ScreenOnOnlyOffHostService.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                ScreenOnOnlyOffHostService.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_screen_on_only_offhost_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.telephony.embms.cts.MbmsDownloadCallbackTest"	"testFullCallback"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/embms/cts/MbmsDownloadCallbackTest.java"	""	"public void testFullCallback() throws Exception {
        int sampleInt = 10;
        TestDSCallback statusCallback = new TestDSCallback();
        TestDPCallback progressCallback = new TestDPCallback();
        DownloadRequest request = downloadRequestTemplate.build();
        mDownloadSession.addStatusListener(request, mCallbackExecutor, statusCallback);
        mDownloadSession.addProgressListener(request, mCallbackExecutor, progressCallback);
        mMiddlewareControl.fireOnProgressUpdated(request, CtsDownloadService.FILE_INFO_1,
                sampleInt, sampleInt, sampleInt, sampleInt);
        SomeArgs progressArgs = progressCallback.waitOnProgressUpdated(ASYNC_TIMEOUT);
        assertEquals(request, progressArgs.arg1);
        assertEquals(CtsDownloadService.FILE_INFO_1, progressArgs.arg2);
        assertEquals(sampleInt, progressArgs.arg3);
        assertEquals(sampleInt, progressArgs.arg4);
        assertEquals(sampleInt, progressArgs.arg5);
        assertEquals(sampleInt, progressArgs.arg6);

        mMiddlewareControl.fireOnStateUpdated(request, CtsDownloadService.FILE_INFO_1, sampleInt);
        SomeArgs stateArgs = statusCallback.waitOnStatusUpdated(ASYNC_TIMEOUT);
        assertEquals(request, stateArgs.arg1);
        assertEquals(CtsDownloadService.FILE_INFO_1, stateArgs.arg2);
        assertEquals(sampleInt, stateArgs.arg3);
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.telephony.embms.cts.MbmsDownloadCallbackTest"	"testDeregistration"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/embms/cts/MbmsDownloadCallbackTest.java"	""	"public void testDeregistration() throws Exception {
        TestDSCallback statusCallback = new TestDSCallback();
        TestDPCallback progressCallback = new TestDPCallback();
        DownloadRequest request = downloadRequestTemplate.build();
        mDownloadSession.addProgressListener(request, mCallbackExecutor, progressCallback);
        mDownloadSession.addStatusListener(request, mCallbackExecutor, statusCallback);
        mDownloadSession.removeProgressListener(request, progressCallback);
        mDownloadSession.removeStatusListener(request, statusCallback);

        mMiddlewareControl.fireOnStateUpdated(null, null, 0);
        assertNull(statusCallback.waitOnStatusUpdated(SHORT_TIMEOUT));
        mMiddlewareControl.fireOnProgressUpdated(null, null, 0, 0, 0, 0);
        assertNull(progressCallback.waitOnProgressUpdated(SHORT_TIMEOUT));
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2021_0473"	"testPocCVE_2021_0473"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2021_0473.java"	""	"@AsbSecurityTest(cveBugId = 179687208)
    public void testPocCVE_2021_0473() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.pocConfig testConfig = new AdbUtils.pocConfig(""CVE-2021-0473"", getDevice());
        testConfig.checkCrash = false;
        AdbUtils.runPocAssertNoCrashesNotVulnerable(testConfig);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.telecom.cts.RemoteConferenceTest"	"testRemoteConferenceCreate"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/RemoteConferenceTest.java"	""	"public void testRemoteConferenceCreate() {
        if (!mShouldTestTelecom) {
            return;
        }

        addRemoteConferenceCall();
        verifyRemoteConferenceObject(mRemoteConferenceObject, mRemoteConference, mConference);

        final Call confCall = mInCallCallbacks.getService().getLastConferenceCall();
        assertCallState(confCall, Call.STATE_ACTIVE);

        if (mCall1.getParent() != confCall || mCall2.getParent() != confCall) {
            fail(""The 2 participating calls should contain the conference call as its parent"");
        }
        if (!(confCall.getChildren().contains(mCall1) && confCall.getChildren().contains(mCall2))) {
            fail(""The conference call should contain the 2 participating calls as its children"");
        }

        assertConnectionState(mConnection1, Connection.STATE_ACTIVE);
        assertConnectionState(mConnection2, Connection.STATE_ACTIVE);
        assertConnectionState(mRemoteConnection1, Connection.STATE_ACTIVE);
        assertConnectionState(mRemoteConnection2, Connection.STATE_ACTIVE);
        assertConferenceState(mConference, Connection.STATE_ACTIVE);
        assertConferenceState(mRemoteConference, Connection.STATE_ACTIVE);
        assertRemoteConferenceState(mRemoteConferenceObject, Connection.STATE_ACTIVE);
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.telecom.cts.RemoteConferenceTest"	"testRemoteConferenceSplit"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/RemoteConferenceTest.java"	""	"public void testRemoteConferenceSplit() {
        if (!mShouldTestTelecom) {
            return;
        }

        addRemoteConferenceCall();
        verifyRemoteConferenceObject(mRemoteConferenceObject, mRemoteConference, mConference);

        final Call confCall = mInCallCallbacks.getService().getLastConferenceCall();
        assertCallState(confCall, Call.STATE_ACTIVE);

        if (!(mCall1.getParent() == confCall) && (confCall.getChildren().contains(mCall1))) {
            fail(""Call 1 not conferenced"");
        }
        assertTrue(mConference.getConnections().contains(mConnection1));
        assertTrue(mRemoteConference.getConnections().contains(mRemoteConnection1));

        splitFromConferenceCall(mCall1);

        if ((mCall1.getParent() == confCall) || (confCall.getChildren().contains(mCall1))) {
            fail(""Call 1 should not be still conferenced"");
        }
        assertFalse(mConference.getConnections().contains(mConnection1));
        assertFalse(mRemoteConference.getConnections().contains(mRemoteConnection1));
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.telecom.cts.RemoteConferenceTest"	"testRemoteConferenceHoldAndUnhold"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/RemoteConferenceTest.java"	""	"public void testRemoteConferenceHoldAndUnhold() {
        if (!mShouldTestTelecom) {
            return;
        }

        addRemoteConferenceCall();
        verifyRemoteConferenceObject(mRemoteConferenceObject, mRemoteConference, mConference);

        final Call confCall = mInCallCallbacks.getService().getLastConferenceCall();
        assertCallState(confCall, Call.STATE_ACTIVE);

        confCall.hold();
        assertCallState(confCall, Call.STATE_HOLDING);
        assertCallState(mCall1, Call.STATE_HOLDING);
        assertCallState(mCall2, Call.STATE_HOLDING);
        assertConnectionState(mConnection1, Connection.STATE_HOLDING);
        assertConnectionState(mConnection2, Connection.STATE_HOLDING);
        assertConnectionState(mRemoteConnection1, Connection.STATE_HOLDING);
        assertConnectionState(mRemoteConnection2, Connection.STATE_HOLDING);
        assertConferenceState(mConference, Connection.STATE_HOLDING);
        assertConferenceState(mRemoteConference, Connection.STATE_HOLDING);
        assertRemoteConferenceState(mRemoteConferenceObject, Connection.STATE_HOLDING);

        confCall.unhold();
        assertCallState(confCall, Call.STATE_ACTIVE);
        assertCallState(mCall1, Call.STATE_ACTIVE);
        assertCallState(mCall2, Call.STATE_ACTIVE);
        assertConnectionState(mConnection1, Connection.STATE_ACTIVE);
        assertConnectionState(mConnection2, Connection.STATE_ACTIVE);
        assertConnectionState(mRemoteConnection1, Connection.STATE_ACTIVE);
        assertConnectionState(mRemoteConnection2, Connection.STATE_ACTIVE);
        assertConferenceState(mConference, Connection.STATE_ACTIVE);
        assertConferenceState(mRemoteConference, Connection.STATE_ACTIVE);
        assertRemoteConferenceState(mRemoteConferenceObject, Connection.STATE_ACTIVE);
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.telecom.cts.RemoteConferenceTest"	"testRemoteConferenceMergeAndSwap"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/RemoteConferenceTest.java"	""	"public void testRemoteConferenceMergeAndSwap() {
        if (!mShouldTestTelecom) {
            return;
        }

        addRemoteConferenceCall();
        verifyRemoteConferenceObject(mRemoteConferenceObject, mRemoteConference, mConference);

        final Call confCall = mInCallCallbacks.getService().getLastConferenceCall();
        assertCallState(confCall, Call.STATE_ACTIVE);

        confCall.mergeConference();
        assertCallDisplayName(mCall1, TestUtils.MERGE_CALLER_NAME);
        assertCallDisplayName(mCall2, TestUtils.MERGE_CALLER_NAME);
        assertConnectionCallDisplayName(mConnection1,
                TestUtils.MERGE_CALLER_NAME);
        assertConnectionCallDisplayName(mConnection2,
                TestUtils.MERGE_CALLER_NAME);
        assertConnectionCallDisplayName(mRemoteConnection1,
                TestUtils.MERGE_CALLER_NAME);
        assertConnectionCallDisplayName(mRemoteConnection2,
                TestUtils.MERGE_CALLER_NAME);

        confCall.swapConference();
        assertCallDisplayName(mCall1, TestUtils.SWAP_CALLER_NAME);
        assertCallDisplayName(mCall2, TestUtils.SWAP_CALLER_NAME);
        assertConnectionCallDisplayName(mConnection1,
                TestUtils.SWAP_CALLER_NAME);
        assertConnectionCallDisplayName(mConnection2,
                TestUtils.SWAP_CALLER_NAME);
        assertConnectionCallDisplayName(mRemoteConnection1,
                TestUtils.SWAP_CALLER_NAME);
        assertConnectionCallDisplayName(mRemoteConnection2,
                TestUtils.SWAP_CALLER_NAME);
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.telecom.cts.RemoteConferenceTest"	"testRemoteConferenceDTMFTone"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/RemoteConferenceTest.java"	""	"public void testRemoteConferenceDTMFTone() {
        if (!mShouldTestTelecom) {
            return;
        }

        addRemoteConferenceCall();
        verifyRemoteConferenceObject(mRemoteConferenceObject, mRemoteConference, mConference);

        final Call confCall = mInCallCallbacks.getService().getLastConferenceCall();
        assertCallState(confCall, Call.STATE_ACTIVE);

        assertTrue(mConference.getDtmfString().isEmpty());
        assertTrue(mRemoteConference.getDtmfString().isEmpty());
        confCall.playDtmfTone('1');
        assertDtmfString(mConference, ""1"");
        assertDtmfString(mRemoteConference, ""1"");
        confCall.stopDtmfTone();
        assertDtmfString(mConference, ""1."");
        assertDtmfString(mRemoteConference, ""1."");
        confCall.playDtmfTone('3');
        assertDtmfString(mConference, ""1.3"");
        assertDtmfString(mRemoteConference, ""1.3"");
        confCall.stopDtmfTone();
        assertDtmfString(mConference, ""1.3."");
        assertDtmfString(mRemoteConference, ""1.3."");
    }"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.telecom.cts.RemoteConferenceTest"	"testRemoteConferenceCallbacks_Extras"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/RemoteConferenceTest.java"	""	"public void testRemoteConferenceCallbacks_Extras() {
        if (!mShouldTestTelecom) {
            return;
        }

        addRemoteConferenceCall();
        verifyRemoteConferenceObject(mRemoteConferenceObject, mRemoteConference, mConference);

        Handler handler = setupRemoteConferenceCallbacksTest();

        final InvokeCounter callbackInvoker =
                new InvokeCounter(""testRemoteConferenceCallbacks_Extras"");
        RemoteConference.Callback callback;

        callback = new RemoteConference.Callback() {
            @Override
            public void onExtrasChanged(RemoteConference conference, Bundle extras) {
                super.onExtrasChanged(conference, extras);
                callbackInvoker.invoke(conference, extras);
            }
        };
        mRemoteConferenceObject.registerCallback(callback, handler);
        Bundle extras = new Bundle();
        extras.putString(TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE, ""Test"");
        mRemoteConference.setExtras(extras);
        callbackInvoker.waitForCount(1, WAIT_FOR_STATE_CHANGE_TIMEOUT_MS);
        assertEquals(mRemoteConferenceObject, callbackInvoker.getArgs(0)[0]);
        assertTrue(((Bundle) callbackInvoker.getArgs(0)[1]).containsKey(
                TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE));
        mRemoteConferenceObject.unregisterCallback(callback);
    }

    public static void verifyRemoteConferenceObject(RemoteConference remoteConferenceObject,
            MockConference remoteConference, MockConference conference) {
        assertEquals(remoteConference.getConnectionCapabilities(),
                remoteConferenceObject.getConnectionCapabilities());
        assertTrue(remoteConferenceObject.getConferenceableConnections().isEmpty());
        List<RemoteConnection> remoteConnections = new ArrayList<>();
        for (Connection c: conference.getConnections()) {
            RemoteConnection remoteConnection = ((MockConnection) c).getRemoteConnection();
            if (remoteConnection != null) {
                remoteConnections.add(remoteConnection);
            }
        }
        assertEquals(remoteConnections, remoteConferenceObject.getConnections());
        assertEquals(remoteConference.getDisconnectCause(),
                remoteConferenceObject.getDisconnectCause());
        assertTrue(areBundlesEqual(remoteConferenceObject.getExtras(), conference.getExtras()));
    }

    private void addRemoteConnectionOutgoingCalls() {
        try {
            MockConnectionService managerConnectionService = new MockConnectionService() {
                @Override
                public Connection onCreateOutgoingConnection(
                        PhoneAccountHandle connectionManagerPhoneAccount,
                        ConnectionRequest request) {
                    MockConnection connection = (MockConnection)super.onCreateOutgoingConnection(
                            connectionManagerPhoneAccount, request);
                    ConnectionRequest remoteRequest = new ConnectionRequest(
                            TEST_REMOTE_PHONE_ACCOUNT_HANDLE,
                            request.getAddress(),
                            request.getExtras());
                    RemoteConnection remoteConnection =
                            CtsConnectionService.createRemoteOutgoingConnectionToTelecom(
                                    TEST_REMOTE_PHONE_ACCOUNT_HANDLE, remoteRequest);
                    connection.setRemoteConnection(remoteConnection);
                    // Modify the connection object created with local values.
                    int capabilities = connection.getConnectionCapabilities();
                    connection.setConnectionCapabilities(capabilities | CONF_CAPABILITIES);
                    return connection;
                }
                @Override
                public void onConference(Connection connection1, Connection connection2) {
                    /**
                     * Fetch the corresponding remoteConnection objects and instantiate a remote
                     * conference creation on the remoteConnectionService instead of this
                     * managerConnectionService.
                     */
                    RemoteConnection remoteConnection1 =
                            ((MockConnection)connection1).getRemoteConnection();
                    RemoteConnection remoteConnection2 =
                            ((MockConnection)connection2).getRemoteConnection();
                    if (remoteConnection1.getConference() == null &&
                            remoteConnection2.getConference() == null) {
                        conferenceRemoteConnections(remoteConnection1, remoteConnection2);
                    }

                    if (connection1.getState() == Connection.STATE_HOLDING){
                        connection1.setActive();
                    }
                    if(connection2.getState() == Connection.STATE_HOLDING){
                        connection2.setActive();
                    }
                }
                @Override
                public void onRemoteConferenceAdded(RemoteConference remoteConference) {
                    /**
                     * Now that the remote conference has been created,
                     * let's create a local conference on this ConnectionService.
                     */
                    MockConference conference = new MockConference(mConnection1, mConnection2);
                    conference.setRemoteConference(remoteConference);
                    CtsConnectionService.addConferenceToTelecom(conference);
                    conferences.add(conference);
                    lock.release();
                }
            };
            /**
             * We want the conference to be instantiated on the remoteConnectionService registered
             * with telecom.
             */
            MockConnectionService remoteConnectionService= new MockConnectionService() {
                @Override
                public Connection onCreateOutgoingConnection(
                        PhoneAccountHandle connectionManagerPhoneAccount,
                        ConnectionRequest request) {
                    Connection connection = super.onCreateOutgoingConnection(
                            connectionManagerPhoneAccount,
                            request);
                    // Modify the connection object created with local values.
                    int capabilities = connection.getConnectionCapabilities();
                    connection.setConnectionCapabilities(capabilities | CONF_CAPABILITIES);
                    return connection;
                }
                @Override
                public void onConference(Connection connection1, Connection connection2) {
                    // Make sure that these connections are already not conferenced.
                    if (connection1.getConference() == null &&
                            connection2.getConference() == null) {
                        MockConference conference = new MockConference(
                                (MockConnection)connection1, (MockConnection)connection2);
                        CtsRemoteConnectionService.addConferenceToTelecom(conference);
                        conferences.add(conference);

                        if (connection1.getState() == Connection.STATE_HOLDING){
                            connection1.setActive();
                        }
                        if(connection2.getState() == Connection.STATE_HOLDING){
                            connection2.setActive();
                        }

                        lock.release();
                    }
                }
            };
            setupConnectionServices(managerConnectionService, remoteConnectionService,
                    FLAG_REGISTER | FLAG_ENABLE);
        } catch(Exception e) {
            fail(""Error in setting up the connection services: "" + e.toString());
        }

        placeAndVerifyCall();
        mConnection1 = verifyConnectionForOutgoingCall(0);
        mRemoteConnection1 = verifyConnectionForOutgoingCallOnRemoteCS(0);
        mCall1 = mInCallCallbacks.getService().getLastCall();
        assertCallState(mCall1, Call.STATE_DIALING);
        mConnection1.setActive();
        mRemoteConnection1.setActive();
        assertCallState(mCall1, Call.STATE_ACTIVE);

        placeAndVerifyCall();
        mConnection2 = verifyConnectionForOutgoingCall(1);
        mRemoteConnection2 = verifyConnectionForOutgoingCallOnRemoteCS(1);
        mCall2 = mInCallCallbacks.getService().getLastCall();
        assertCallState(mCall2, Call.STATE_DIALING);
        mConnection2.setActive();
        mRemoteConnection2.setActive();
        assertCallState(mCall2, Call.STATE_ACTIVE);

        setAndVerifyConferenceablesForOutgoingConnection(0);
        setAndVerifyConferenceablesForOutgoingConnection(1);
        setAndVerifyConferenceablesForOutgoingConnectionOnRemoteCS(0);
        setAndVerifyConferenceablesForOutgoingConnectionOnRemoteCS(1);
    }

    private void addRemoteConferenceCall() {
        addRemoteConnectionOutgoingCalls();
        /**
         * We've 2 connections on the local connectionService which have 2 corresponding
         * connections on the remoteConnectionService controlled via 2 RemoteConnection objects
         * on the connectionService. We now create a conference on the local two connections
         * which triggers a creation of conference on the remoteConnectionService via the
         * RemoteConference object.
         */

        addConferenceCall(mCall1, mCall2);
        mConference = verifyConferenceForOutgoingCall();
        mRemoteConference = verifyConferenceForOutgoingCallOnRemoteCS();
        mRemoteConferenceObject = mConference.getRemoteConference();
        mRemoteConnection1 = (MockConnection)mRemoteConference.getConnections().get(0);
        mRemoteConnection2 = (MockConnection)mRemoteConference.getConnections().get(1);
    }

    private Handler setupRemoteConferenceCallbacksTest() {
        final Call confCall = mInCallCallbacks.getService().getLastConferenceCall();
        assertCallState(confCall, Call.STATE_ACTIVE);

        // Create a looper thread for the callbacks.
        HandlerThread workerThread = new HandlerThread(""CallbackThread"");
        workerThread.start();
        Handler handler = new Handler(workerThread.getLooper());
        return handler;
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.NdefPushReceiverActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/NdefPushReceiverActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.tech.NfcUtils;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.PendingIntent;
import android.content.Intent;
import android.nfc.NdefMessage;
import android.nfc.NfcAdapter;
import android.nfc.NfcManager;
import android.os.Bundle;
import android.os.Parcelable;
import android.widget.TextView;

/**
 * Test activity that waits to receive a particular NDEF Push message from another NFC device.
 */
public class NdefPushReceiverActivity extends PassFailButtons.Activity {

    private static final int NFC_NOT_ENABLED_DIALOG_ID = 1;

    private static final int RESULT_DIALOG_ID = 2;

    private static final String IS_MATCH_ARG = ""isMatch"";

    private NfcAdapter mNfcAdapter;

    private PendingIntent mPendingIntent;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setInfoResources(R.string.nfc_ndef_push_receiver, R.string.nfc_ndef_push_receiver_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        TextView text = (TextView) findViewById(R.id.text);
        text.setText(R.string.nfc_ndef_push_receiver_instructions);

        NfcManager nfcManager = (NfcManager) getSystemService(NFC_SERVICE);
        mNfcAdapter = nfcManager.getDefaultAdapter();
        mPendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, getClass())
                .addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), PendingIntent.FLAG_MUTABLE_UNAUDITED);
    }

    @Override
    protected void onResume() {
        super.onResume();

        if (!mNfcAdapter.isEnabled()) {
            showDialog(NFC_NOT_ENABLED_DIALOG_ID);
        }

        /* Only the sender requires mNfcAdapter.isNdefPushEnabled == true,
         * so no need to check it here in the receiver. */

        mNfcAdapter.enableForegroundDispatch(this, mPendingIntent, null, null);
    }

    @Override
    protected void onPause() {
        super.onPause();
        mNfcAdapter.disableForegroundDispatch(this);
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);

        NdefMessage[] messages = getNdefMessages(intent);
        boolean isMatch = messages != null
                && messages.length > 0
                && NfcUtils.areMessagesEqual(messages[0], NdefPushSenderActivity.TEST_MESSAGE);

        getPassButton().setEnabled(isMatch);

        Bundle args = new Bundle();
        args.putBoolean(IS_MATCH_ARG, isMatch);
        showDialog(RESULT_DIALOG_ID, args);
    }

    private NdefMessage[] getNdefMessages(Intent intent) {
        Parcelable[] rawMessages = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);
        if (rawMessages != null) {
            NdefMessage[] messages = new NdefMessage[rawMessages.length];
            for (int i = 0; i < messages.length; i++) {
                messages[i] = (NdefMessage) rawMessages[i];
            }
            return messages;
        } else {
            return null;
        }
    }

    @Override
    public Dialog onCreateDialog(int id, Bundle args) {
        switch (id) {
            case NFC_NOT_ENABLED_DIALOG_ID:
                return NfcDialogs.createNotEnabledDialog(this);

            case RESULT_DIALOG_ID:
                // Set placeholder titles and messages for now. Final titles and messages will
                // be set in onPrepareDialog.
                return new AlertDialog.Builder(this)
                        .setIcon(android.R.drawable.ic_dialog_info)
                        .setTitle(R.string.result_failure)
                        .setMessage("""")
                        .setPositiveButton(android.R.string.ok, null)
                        .show();

            default:
                return super.onCreateDialog(id, args);
        }
    }

    @Override
    protected void onPrepareDialog(int id, Dialog dialog, Bundle args) {
        switch (id) {
            case RESULT_DIALOG_ID:
                boolean isMatch = args.getBoolean(IS_MATCH_ARG);
                AlertDialog alert = (AlertDialog) dialog;
                alert.setTitle(isMatch
                        ? R.string.result_success
                        : R.string.result_failure);
                alert.setMessage(isMatch
                        ? getString(R.string.nfc_ndef_push_receive_success)
                        : getString(R.string.nfc_ndef_push_receive_failure));
                break;

            default:
                super.onPrepareDialog(id, dialog, args);
                break;
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.HceReaderTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/HceReaderTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.hce;

import android.nfc.NfcAdapter;
import android.nfc.cardemulation.CardEmulation;
import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;

/** Activity that lists all the NFC HCE reader tests. */
public class HceReaderTestActivity extends PassFailButtons.TestListActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setInfoResources(R.string.nfc_test, R.string.nfc_hce_reader_test_info, 0);
        setPassFailButtonClickListeners();

        ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
            adapter.add(TestListItem.newCategory(this, R.string.nfc_hce_reader_tests));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_protocol_params_reader,
                    ProtocolParamsReaderActivity.class.getName(),
                    new Intent(this, ProtocolParamsReaderActivity.class), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_single_payment_reader,
                    getString(R.string.nfc_hce_single_payment_reader),
                    SinglePaymentEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_dual_payment_reader,
                    getString(R.string.nfc_hce_dual_payment_reader),
                    DualPaymentEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_change_default_reader,
                    getString(R.string.nfc_hce_change_default_reader),
                    ChangeDefaultEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_foreground_payment_reader,
                    getString(R.string.nfc_hce_foreground_payment_reader),
                    ForegroundPaymentEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_single_non_payment_reader,
                    getString(R.string.nfc_hce_single_non_payment_reader),
                    SingleNonPaymentEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_dual_non_payment_reader,
                    getString(R.string.nfc_hce_dual_non_payment_reader),
                    DualNonPaymentEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_conflicting_non_payment_reader,
                    getString(R.string.nfc_hce_conflicting_non_payment_reader),
                    ConflictingNonPaymentEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_foreground_non_payment_reader,
                    getString(R.string.nfc_hce_foreground_non_payment_reader),
                    ForegroundNonPaymentEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_throughput_reader,
                    getString(R.string.nfc_hce_throughput_reader),
                    ThroughputEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_tap_test_reader,
                    getString(R.string.nfc_hce_tap_test_reader),
                    TapTestEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_offhost_service_reader,
                    getString(R.string.nfc_hce_offhost_service_reader),
                    OffHostEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_on_and_offhost_service_reader,
                    getString(R.string.nfc_hce_on_and_offhost_service_reader),
                    OnAndOffHostEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_payment_dynamic_aids_reader,
                    getString(R.string.nfc_hce_payment_dynamic_aids_reader),
                    DynamicAidEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_hce_large_num_aids_reader,
                    getString(R.string.nfc_hce_large_num_aids_reader),
                    LargeNumAidsEmulatorActivity.buildReaderIntent(this), null));

            NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
            CardEmulation cardEmulation = CardEmulation.getInstance(nfcAdapter);
            if (cardEmulation.supportsAidPrefixRegistration()) {
                adapter.add(TestListItem.newTest(this, R.string.nfc_hce_payment_prefix_aids_reader,
                        getString(R.string.nfc_hce_payment_prefix_aids_reader),
                        PrefixPaymentEmulatorActivity.buildReaderIntent(this), null));

                adapter.add(TestListItem.newTest(this, R.string.nfc_hce_payment_prefix_aids_reader_2,
                        getString(R.string.nfc_hce_payment_prefix_aids_reader_2),
                        PrefixPaymentEmulator2Activity.buildReaderIntent(this), null));

                adapter.add(TestListItem.newTest(this, R.string.nfc_hce_other_prefix_aids_reader,
                        getString(R.string.nfc_hce_other_prefix_aids_reader),
                        DualNonPaymentPrefixEmulatorActivity.buildReaderIntent(this), null));

                adapter.add(TestListItem.newTest(this, R.string.nfc_hce_other_conflicting_prefix_aids_reader,
                        getString(R.string.nfc_hce_other_conflicting_prefix_aids_reader),
                        ConflictingNonPaymentPrefixEmulatorActivity.buildReaderIntent(this), null));
            }

            adapter.add(TestListItem.newTest(this, R.string.nfc_screen_on_only_offhost_reader,
                    getString(R.string.nfc_screen_on_only_offhost_reader),
                    ScreenOnOnlyOffHostEmulatorActivity.buildReaderIntent(this), null));

            adapter.add(TestListItem.newTest(this, R.string.nfc_screen_off_hce_payment_reader,
                    getString(R.string.nfc_screen_off_hce_payment_reader),
                    ScreenOffPaymentEmulatorActivity.buildReaderIntent(this), null));

        }

        setTestListAdapter(adapter);
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.OnAndOffHostEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/OnAndOffHostEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.nfc.NfcDialogs;
import com.android.cts.verifier.R;

@TargetApi(19)
public class OnAndOffHostEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setupServices(this, OffHostService.COMPONENT, AccessService.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_hce_on_and_offhost_emulator_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        // Combine command/response APDU arrays
        CommandApdu[] commandSequences = new CommandApdu[OffHostService.APDU_COMMAND_SEQUENCE.length +
                                               AccessService.APDU_COMMAND_SEQUENCE.length];
        System.arraycopy(OffHostService.APDU_COMMAND_SEQUENCE, 0, commandSequences, 0,
                OffHostService.APDU_COMMAND_SEQUENCE.length);
        System.arraycopy(AccessService.APDU_COMMAND_SEQUENCE, 0, commandSequences,
                OffHostService.APDU_COMMAND_SEQUENCE.length,
                AccessService.APDU_COMMAND_SEQUENCE.length);

        String[] responseSequences = new String[OffHostService.APDU_RESPOND_SEQUENCE.length +
                                               AccessService.APDU_RESPOND_SEQUENCE.length];
        System.arraycopy(OffHostService.APDU_RESPOND_SEQUENCE, 0, responseSequences, 0,
                OffHostService.APDU_RESPOND_SEQUENCE.length);
        System.arraycopy(AccessService.APDU_RESPOND_SEQUENCE, 0, responseSequences,
                OffHostService.APDU_RESPOND_SEQUENCE.length,
                AccessService.APDU_RESPOND_SEQUENCE.length);

        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                commandSequences);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                responseSequences);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_on_and_offhost_service_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(AccessService.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.PreferentialNetworkServiceTest"	"setPreferentialNetworkServiceEnabled_enableService_issueRequest"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/PreferentialNetworkServiceTest.java"	""	"@Postsubmit(reason = ""New test"")
    @EnsureHasPermission({ACCESS_NETWORK_STATE, NETWORK_SETTINGS})
    @PositivePolicyTest(policy = PreferentialNetworkService.class)
    public void setPreferentialNetworkServiceEnabled_enableService_issueRequest() {
        // Expect a regular default network.
        final Network defaultNetwork = Objects.requireNonNull(sCm.getActiveNetwork(),
                ""Default network is required to perform the test."");
        final TestableNetworkCallback defaultCallback = new TestableNetworkCallback();
        sCm.registerDefaultNetworkCallback(defaultCallback);
        defaultCallback.expectAvailableCallbacks(defaultNetwork, /* suspended= */ false,
                /* validated= */ true, /* blocked= */ false, DEFAULT_TIMEOUT_MS);

        // Register a pair of provider and offer that can provides enterprise slice, verify it
        // received nothing since the feature is not enabled.
        final NetworkProvider provider =
                new NetworkProvider(sContext, mHandlerThread.getLooper(), TAG);
        sCm.registerNetworkProvider(provider);
        final TestableNetworkOfferCallback offerCallback = registerEnterpriseNetworkOffer(provider);

        try {
            // Enable PreferentialNetworkService, verify the provider sees the enterprise
            // slice request.
            // But the network callback received nothing since it should automatically fallback to
            // default request if there is no enterprise slice.
            sDeviceState.dpc().devicePolicyManager().setPreferentialNetworkServiceEnabled(true);
            offerCallback.expectOnNetworkNeeded(mEnterpriseNcFilter);
            defaultCallback.assertNoCallback(NO_CALLBACK_TIMEOUT_MS);
        } finally {
            sCm.unregisterNetworkCallback(defaultCallback);
            sDeviceState.dpc().devicePolicyManager().setPreferentialNetworkServiceEnabled(false);
            sCm.unregisterNetworkProvider(provider);
        }
    }

    /**
     * Disable PreferentialNetworkService, verify the provider that provides enterprise slice cannot
     * see the enterprise slice requests.
     */"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.PreferentialNetworkServiceTest"	"setPreferentialNetworkServiceEnabled_disableService_noIssueRequest"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/PreferentialNetworkServiceTest.java"	""	"@Postsubmit(reason = ""New test"")
    @EnsureHasPermission({ACCESS_NETWORK_STATE, NETWORK_SETTINGS})
    @PositivePolicyTest(policy = PreferentialNetworkService.class)
    public void setPreferentialNetworkServiceEnabled_disableService_noIssueRequest() {
        // Expect a regular default network.
        final Network defaultNetwork = Objects.requireNonNull(sCm.getActiveNetwork(),
                ""Default network is required to perform the test."");
        final TestableNetworkCallback defaultCallback = new TestableNetworkCallback();
        sCm.registerDefaultNetworkCallback(defaultCallback);
        defaultCallback.expectAvailableCallbacks(defaultNetwork, /* suspended= */ false,
                /* validated= */ true, /* blocked= */ false, DEFAULT_TIMEOUT_MS);

        // Register a pair of provider and offer that can provides enterprise slice, verify it
        // received nothing since the feature is not enabled.
        final NetworkProvider provider =
                new NetworkProvider(sContext, mHandlerThread.getLooper(), TAG);
        sCm.registerNetworkProvider(provider);
        final TestableNetworkOfferCallback offerCallback = registerEnterpriseNetworkOffer(provider);

        try {
            // Disable PreferentialNetworkService, verify the provider cannot see the enterprise
            // slice request. And the network callback received nothing since there is no any
            // change.
            sDeviceState.dpc().devicePolicyManager().setPreferentialNetworkServiceEnabled(false);
            offerCallback.assertNoCallback();  // Still unneeded.
            defaultCallback.assertNoCallback(NO_CALLBACK_TIMEOUT_MS);
        } finally {
            sCm.unregisterNetworkCallback(defaultCallback);
            sDeviceState.dpc().devicePolicyManager().setPreferentialNetworkServiceEnabled(false);
            sCm.unregisterNetworkProvider(provider);
        }
    }

    private TestableNetworkOfferCallback registerEnterpriseNetworkOffer(
            NetworkProvider provider) {
        final TestableNetworkOfferCallback offerCallback =
                new TestableNetworkOfferCallback(DEFAULT_TIMEOUT_MS, NO_CALLBACK_TIMEOUT_MS);
        provider.registerNetworkOffer(new NetworkScore.Builder().build(), mEnterpriseNcFilter,
                new HandlerExecutor(mHandlerThread.getThreadHandler()), offerCallback);
        offerCallback.assertNoCallback();
        return offerCallback;
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.UserControlDisabledPackagesTest"	"setUserControlDisabledPackages_toOneProtectedPackage"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/UserControlDisabledPackagesTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = UserControlDisabledPackages.class)
    public void setUserControlDisabledPackages_toOneProtectedPackage() {
        List<String> originalDisabledPackages =
                sDeviceState.dpc().devicePolicyManager().getUserControlDisabledPackages();

        sDeviceState.dpc().devicePolicyManager().setUserControlDisabledPackages(
                Arrays.asList(PACKAGE_NAME));
        try {
            assertThat(sDeviceState.dpc().devicePolicyManager().getUserControlDisabledPackages())
                    .containsExactly(PACKAGE_NAME);
        } finally {
            sDeviceState.dpc().devicePolicyManager().setUserControlDisabledPackages(
                    originalDisabledPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.UserControlDisabledPackagesTest"	"setUserControlDisabledPackages_toEmptyProtectedPackages"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/UserControlDisabledPackagesTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = UserControlDisabledPackages.class)
    public void setUserControlDisabledPackages_toEmptyProtectedPackages() {
        List<String> originalDisabledPackages =
                sDeviceState.dpc().devicePolicyManager().getUserControlDisabledPackages();

        sDeviceState.dpc().devicePolicyManager().setUserControlDisabledPackages(
                Collections.emptyList());
        try {
            assertThat(
                    sDeviceState.dpc().devicePolicyManager().getUserControlDisabledPackages()).isEmpty();
        } finally {
            sDeviceState.dpc().devicePolicyManager().setUserControlDisabledPackages(
                    originalDisabledPackages);
        }
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.UserControlDisabledPackagesTest"	"setUserControlDisabledPackages_notAllowedToSetProtectedPackages_throwsException"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/UserControlDisabledPackagesTest.java"	""	"@Postsubmit(reason = ""New test"")
    @CannotSetPolicyTest(policy = UserControlDisabledPackages.class)
    public void setUserControlDisabledPackages_notAllowedToSetProtectedPackages_throwsException() {
        assertThrows(SecurityException.class,
                () -> sDeviceState.dpc().devicePolicyManager().setUserControlDisabledPackages(
                        Collections.emptyList()));
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.UserControlDisabledPackagesTest"	"getUserControlDisabledPackages_noProtectedPackagesSet_returnsEmptyProtectedPackages"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/UserControlDisabledPackagesTest.java"	""	"@Postsubmit(reason = ""New test"")
    @PositivePolicyTest(policy = UserControlDisabledPackages.class)
    public void
    getUserControlDisabledPackages_noProtectedPackagesSet_returnsEmptyProtectedPackages() {
        // This is testing the default state of the device so the disabled packages returned should
        // be empty.
        assertThat(sDeviceState.dpc().devicePolicyManager().getUserControlDisabledPackages())
                .isEmpty();
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.UserControlDisabledPackagesTest"	"getUserControlDisabledPackages_notAllowedToRetrieveProtectedPackages_throwsException"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/UserControlDisabledPackagesTest.java"	""	"@Postsubmit(reason = ""New test"")
    @CannotSetPolicyTest(policy = UserControlDisabledPackages.class)
    public void
    getUserControlDisabledPackages_notAllowedToRetrieveProtectedPackages_throwsException() {
        assertThrows(SecurityException.class,
                () -> sDeviceState.dpc().devicePolicyManager().getUserControlDisabledPackages());
    }"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.UserControlDisabledPackagesTest"	"setUserControlDisabledPackages_launchActivity_verifyPackageNotStopped"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/UserControlDisabledPackagesTest.java"	""	"@Postsubmit(reason = ""New test"")
    @EnsureHasPermission(value = permission.FORCE_STOP_PACKAGES)
    @PositivePolicyTest(policy = UserControlDisabledPackages.class)
    @Ignore // TODO(b/189325405): Re-enable once secondary users can start activities
    public void setUserControlDisabledPackages_launchActivity_verifyPackageNotStopped()
            throws Exception {
        List<String> originalDisabledPackages =
                sDeviceState.dpc().devicePolicyManager().getUserControlDisabledPackages();
        UserReference currentRunningUserOnTest = sTestApis.users().instrumented();
        int currentRunningUserId = currentRunningUserOnTest.id();
        String testAppPackageName = sTestApp.packageName();

        sDeviceState.dpc().devicePolicyManager().setUserControlDisabledPackages(
                Arrays.asList(testAppPackageName));
        try (TestAppInstanceReference instance = sTestApp.install(currentRunningUserOnTest)) {
            instance.activities().any().start();

            sActivityManager.forceStopPackageAsUser(testAppPackageName, currentRunningUserId);

            try {
                assertPackageStopped(
                        testAppPackageName, currentRunningUserId, /* stopped= */ false);
            } finally {
                stopPackage(testAppPackageName, currentRunningUserId);
            }
        } finally {
            sDeviceState.dpc().devicePolicyManager().setUserControlDisabledPackages(
                    originalDisabledPackages);
        }
    }

    private void stopPackage(String packageName, int userId) throws Exception {
        sDeviceState.dpc().devicePolicyManager().setUserControlDisabledPackages(
                Collections.emptyList());
        sActivityManager.forceStopPackageAsUser(packageName, userId);
        assertPackageStopped(packageName, userId, /* stopped= */ true);
    }

    private void assertPackageStopped(String packageName, int userId, boolean stopped)
            throws Exception {
        assertWithMessage(""Package %s stopped for user %s"", packageName, userId)
                .that(isPackageStopped(packageName, userId)).isEqualTo(stopped);
    }

    private boolean isPackageStopped(String packageName, int userId) throws Exception {
        PackageInfo packageInfo = sPackageManager.getPackageInfoAsUser(
                packageName, PackageManager.GET_META_DATA, userId);
        boolean stopped = (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_STOPPED)
                == ApplicationInfo.FLAG_STOPPED;
        Log.i(TAG, ""Application flags for "" + packageName + "" on user "" + userId + "" = ""
                + Integer.toHexString(packageInfo.applicationInfo.flags) + "". Stopped: "" + stopped);
        return stopped;
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.permission.cts.FileSystemPermissionTest"	"testPn544Sane"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	"public void testPn544Sane() throws Exception {
        File f = new File(""/dev/pn544"");
        assertFalse(f.canRead());
        assertFalse(f.canWrite());
        assertFalse(f.canExecute());

        assertFileOwnedBy(f, ""nfc"");
        assertFileOwnedByGroup(f, ""nfc"");
    }

    @MediumTest"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.permission.cts.FileSystemPermissionTest"	"testBcm2079xSane"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	"public void testBcm2079xSane() throws Exception {
        File f = new File(""/dev/bcm2079x"");
        assertFalse(f.canRead());
        assertFalse(f.canWrite());
        assertFalse(f.canExecute());

        assertFileOwnedBy(f, ""nfc"");
        assertFileOwnedByGroup(f, ""nfc"");
    }

    @MediumTest"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.permission.cts.FileSystemPermissionTest"	"testBcm2079xi2cSane"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	"public void testBcm2079xi2cSane() throws Exception {
        File f = new File(""/dev/bcm2079x-i2c"");
        assertFalse(f.canRead());
        assertFalse(f.canWrite());
        assertFalse(f.canExecute());

        assertFileOwnedBy(f, ""nfc"");
        assertFileOwnedByGroup(f, ""nfc"");
    }

    @MediumTest"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.features.FeatureSummaryActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/features/FeatureSummaryActivity.java"	""	"public void test/*
 *.
 */

/*
 * This file references fs_error.png, fs_good.png, fs_indeterminate.png,
 * and fs_warning.png which are licensed under Creative Commons 3.0
 * by fatcow.com.
 * http://www.fatcow.com/free-icons/
 * http://creativecommons.org/licenses/by/3.0/us/
 */

package com.android.cts.verifier.features;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.content.pm.FeatureInfo;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.view.View;
import android.widget.ImageView;
import android.widget.SimpleAdapter;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Set;

public class FeatureSummaryActivity extends PassFailButtons.ListActivity {
    /**
     * Simple storage class for data about an Android feature.
     */
    static class Feature {
        /**
         * The name of the feature. Should be one of the PackageManager.FEATURE*
         * constants.
         */
        public String name;

        /**
         * Indicates whether the field is present on the current device.
         */
        public boolean present;

        /**
         * Indicates whether the field is required for the current device.
         */
        public boolean required;

        /**
         * Constructor does not include 'present' because that's a detected
         * value, and not set during creation.
         *
         * @param name value for this.name
         * @param required value for this.required
         */
        public Feature(String name, boolean required) {
            this.name = name;
            this.required = required;
            this.present = false;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            } else if (o == null || !(o instanceof Feature)) {
                return false;
            } else {
                Feature feature = (Feature) o;
                return name.equals(feature.name);
            }
        }

        @Override
        public int hashCode() {
            return name.hashCode();
        }
    }

    public static final Feature[] ALL_ECLAIR_FEATURES = {
            new Feature(PackageManager.FEATURE_CAMERA, true),
            new Feature(PackageManager.FEATURE_CAMERA_AUTOFOCUS, false),
            new Feature(PackageManager.FEATURE_CAMERA_FLASH, false),
            new Feature(PackageManager.FEATURE_LIVE_WALLPAPER, false),
            new Feature(PackageManager.FEATURE_SENSOR_LIGHT, false),
            new Feature(PackageManager.FEATURE_SENSOR_PROXIMITY, false),
            new Feature(PackageManager.FEATURE_TELEPHONY, false),
            new Feature(PackageManager.FEATURE_TELEPHONY_CDMA, false),
            new Feature(PackageManager.FEATURE_TELEPHONY_GSM, false),
    };

    public static final Feature[] ALL_FROYO_FEATURES = {
            new Feature(""android.hardware.bluetooth"", true),
            new Feature(""android.hardware.location"", true),
            new Feature(""android.hardware.location.gps"", true),
            new Feature(""android.hardware.location.network"", true),
            new Feature(""android.hardware.microphone"", true),
            new Feature(""android.hardware.sensor.accelerometer"", true),
            new Feature(""android.hardware.sensor.compass"", true),
            new Feature(""android.hardware.touchscreen"", true),
            new Feature(""android.hardware.touchscreen.multitouch"", false),
            new Feature(""android.hardware.touchscreen.multitouch.distinct"", false),
            new Feature(""android.hardware.wifi"", false),
    };

    public static final Feature[] ALL_GINGERBREAD_FEATURES = {
            // Required features in prior releases that became optional in GB
            new Feature(""android.hardware.bluetooth"", false),
            new Feature(""android.hardware.camera"", false),
            new Feature(""android.hardware.location.gps"", false),
            new Feature(""android.hardware.microphone"", false),
            new Feature(""android.hardware.sensor.accelerometer"", false),
            new Feature(""android.hardware.sensor.compass"", false),

            // New features in GB
            new Feature(""android.hardware.audio.low_latency"", false),
            new Feature(""android.hardware.camera.front"", false),
            new Feature(""android.hardware.nfc"", false),
            new Feature(""android.hardware.sensor.barometer"", false),
            new Feature(""android.hardware.sensor.gyroscope"", false),
            new Feature(""android.hardware.touchscreen.multitouch.jazzhand"", false),
            new Feature(""android.software.sip"", false),
            new Feature(""android.software.sip.voip"", false),
    };

    public static final Feature[] ALL_GINGERBREAD_MR1_FEATURES = {
            new Feature(""android.hardware.usb.accessory"", false),
    };

    public static final Feature[] ALL_HONEYCOMB_FEATURES = {
            // Required features in prior releases that became optional in HC
            new Feature(""android.hardware.touchscreen"", false),

            new Feature(""android.hardware.faketouch"", true),
    };

    public static final Feature[] ALL_HONEYCOMB_MR1_FEATURES = {
            new Feature(""android.hardware.usb.host"", false),
            new Feature(""android.hardware.usb.accessory"", false),
    };

    public static final Feature[] ALL_HONEYCOMB_MR2_FEATURES = {
            new Feature(""android.hardware.faketouch.multitouch.distinct"", false),
            new Feature(""android.hardware.faketouch.multitouch.jazzhand"", false),
            new Feature(""android.hardware.screen.landscape"", false),
            new Feature(""android.hardware.screen.portrait"", false),
    };

    public static final Feature[] ALL_ICE_CREAM_SANDWICH_FEATURES = {
            new Feature(PackageManager.FEATURE_WIFI_DIRECT, false),
    };

    public static final Feature[] ALL_JELLY_BEAN_FEATURES = {
            // Required features in prior releases that became optional
            new Feature(PackageManager.FEATURE_FAKETOUCH, false),

            //new feature in JB
            new Feature(PackageManager.FEATURE_TELEVISION, false),
    };

    public static final Feature[] ALL_JELLY_BEAN_MR2_FEATURES = {
            new Feature(""android.software.app_widgets"", false),
            new Feature(""android.software.input_methods"", false),
            new Feature(""android.software.home_screen"", false),
            new Feature(""android.hardware.bluetooth_le"", false),
            new Feature(""android.hardware.camera.any"", false),
    };

    public static final Feature[] ALL_KITKAT_FEATURES = {
            new Feature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION, false),
            new Feature(PackageManager.FEATURE_CONSUMER_IR, false),
            new Feature(PackageManager.FEATURE_DEVICE_ADMIN, false),
            new Feature(PackageManager.FEATURE_SENSOR_STEP_COUNTER, false),
            new Feature(PackageManager.FEATURE_SENSOR_STEP_DETECTOR, false),
    };

    public static final Feature[] ALL_KITKAT_WATCH_FEATURES = {
            new Feature(PackageManager.FEATURE_SENSOR_HEART_RATE, false),
            new Feature(PackageManager.FEATURE_BACKUP, false),
            new Feature(PackageManager.FEATURE_PRINTING, false),
            new Feature(PackageManager.FEATURE_WATCH, false),
            new Feature(PackageManager.FEATURE_WEBVIEW, false),
            new Feature(PackageManager.FEATURE_CAMERA_EXTERNAL, false),
    };

    public static final Feature[] ALL_LOLLIPOP_FEATURES = {
            // New features in L
            new Feature(PackageManager.FEATURE_AUDIO_OUTPUT, false),
            new Feature(PackageManager.FEATURE_CAMERA_CAPABILITY_MANUAL_POST_PROCESSING, false),
            new Feature(PackageManager.FEATURE_CAMERA_CAPABILITY_MANUAL_SENSOR, false),
            new Feature(PackageManager.FEATURE_CAMERA_CAPABILITY_RAW, false),
            new Feature(PackageManager.FEATURE_CAMERA_LEVEL_FULL, false),
            new Feature(PackageManager.FEATURE_CONNECTION_SERVICE, false),
            new Feature(PackageManager.FEATURE_GAMEPAD, false),
            new Feature(PackageManager.FEATURE_LEANBACK, false),
            new Feature(PackageManager.FEATURE_LIVE_TV, false),
            new Feature(PackageManager.FEATURE_MANAGED_USERS, false),
            new Feature(PackageManager.FEATURE_OPENGLES_EXTENSION_PACK, false),
            new Feature(PackageManager.FEATURE_SECURELY_REMOVES_USERS, false),
            new Feature(PackageManager.FEATURE_SENSOR_AMBIENT_TEMPERATURE, false),
            new Feature(PackageManager.FEATURE_SENSOR_HEART_RATE_ECG, false),
            new Feature(PackageManager.FEATURE_SENSOR_RELATIVE_HUMIDITY, false),
            new Feature(PackageManager.FEATURE_VERIFIED_BOOT, false),

            // Features explicitly made optional in L
            new Feature(PackageManager.FEATURE_LOCATION_NETWORK, false),

            // New hidden features in L
            new Feature(""android.hardware.ethernet"", false),
            new Feature(""android.hardware.hdmi.cec"", false),
            new Feature(""android.software.leanback_only"", false),
            new Feature(""android.software.voice_recognizers"", false),
    };

    public static final Feature[] ALL_MNC_FEATURES = {
            new Feature(PackageManager.FEATURE_MIDI, false),
            new Feature(PackageManager.FEATURE_AUDIO_PRO, false),
            new Feature(PackageManager.FEATURE_AUTOMOTIVE, false),
            new Feature(PackageManager.FEATURE_HIFI_SENSORS, false),
            new Feature(PackageManager.FEATURE_FINGERPRINT, false),
    };

    public static final Feature[] ALL_NYC_FEATURES = {
            new Feature(PackageManager.FEATURE_VR_MODE, false),
            new Feature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE, false),
            new Feature(PackageManager.FEATURE_VULKAN_HARDWARE_VERSION, false),
            new Feature(PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL, false),
            new Feature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION_NFCF, false),
            new Feature(PackageManager.FEATURE_PICTURE_IN_PICTURE, false),
            new Feature(PackageManager.FEATURE_FREEFORM_WINDOW_MANAGEMENT, false),
            // FEATURE_FILE_BASED_ENCRYPTION is hide
            new Feature(""android.software.file_based_encryption"", false),
    };

    public static final Feature[] ALL_O_FEATURES = {
            new Feature(PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE, false),
            // FEATURE_TELEPHONY_CARRIERLOCK is SystemApi
            new Feature(""android.hardware.telephony.carrierlock"", false),
            new Feature(PackageManager.FEATURE_WIFI_AWARE, false),
            new Feature(PackageManager.FEATURE_EMBEDDED, false),
            new Feature(PackageManager.FEATURE_COMPANION_DEVICE_SETUP, false),
            new Feature(PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS, false),
            new Feature(PackageManager.FEATURE_VR_HEADTRACKING, false),
            // FEATURE_CTS is hide
            new Feature(""android.software.cts"", false),
            new Feature(PackageManager.FEATURE_WIFI_AWARE, false),
    };

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.fs_main);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.feature_summary, R.string.feature_summary_info, R.layout.fs_info);

        // some values used to detect warn-able conditions involving multiple
        // features
        boolean hasWifi = false;
        boolean hasTelephony = false;
        boolean hasBluetooth = false;
        boolean hasIllegalFeature = false;
        boolean hasTelevision = false;

        // get list of all features device thinks it has, & store in a HashMap
        // for fast lookups
        HashMap<String, String> actualFeatures = new HashMap<String, String>();
        for (FeatureInfo fi : getPackageManager().getSystemAvailableFeatures()) {
            actualFeatures.put(fi.name, fi.name);
        }

        // data structure that the SimpleAdapter will use to populate ListView
        ArrayList<HashMap<String, Object>> listViewData = new ArrayList<HashMap<String, Object>>();

        // roll over all known features & check whether device reports them
        boolean present = false;
        int statusIcon;
        Set<Feature> features = new LinkedHashSet<Feature>();

        // add features from latest to last so that the latest requirements are put in the set first
        int apiVersion = Build.VERSION.SDK_INT;
        if (apiVersion >= Build.VERSION_CODES.O) {
            Collections.addAll(features, ALL_O_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.N) {
            Collections.addAll(features, ALL_NYC_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.M) {
            Collections.addAll(features, ALL_MNC_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.LOLLIPOP) {
            Collections.addAll(features, ALL_LOLLIPOP_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.KITKAT_WATCH) {
            Collections.addAll(features, ALL_KITKAT_WATCH_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.KITKAT) {
            Collections.addAll(features, ALL_KITKAT_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
            Collections.addAll(features, ALL_JELLY_BEAN_MR2_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.JELLY_BEAN) {
            Collections.addAll(features, ALL_JELLY_BEAN_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
            Collections.addAll(features, ALL_ICE_CREAM_SANDWICH_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.HONEYCOMB_MR2) {
            Collections.addAll(features, ALL_HONEYCOMB_MR2_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.HONEYCOMB_MR1) {
            Collections.addAll(features, ALL_HONEYCOMB_MR1_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.HONEYCOMB) {
            Collections.addAll(features, ALL_HONEYCOMB_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.GINGERBREAD_MR1) {
            Collections.addAll(features, ALL_GINGERBREAD_MR1_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.GINGERBREAD) {
            Collections.addAll(features, ALL_GINGERBREAD_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.FROYO) {
            Collections.addAll(features, ALL_FROYO_FEATURES);
        }
        if (apiVersion >= Build.VERSION_CODES.ECLAIR_MR1) {
            Collections.addAll(features, ALL_ECLAIR_FEATURES);
        }

        hasTelevision = getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEVISION);
        for (Feature f : features) {
            HashMap<String, Object> row = new HashMap<String, Object>();
            listViewData.add(row);
            present = actualFeatures.containsKey(f.name);
            if (present) {
                // device reports it -- yay! set the happy icon
                hasWifi = hasWifi || PackageManager.FEATURE_WIFI.equals(f.name);
                hasTelephony = hasTelephony || PackageManager.FEATURE_TELEPHONY.equals(f.name);
                hasBluetooth = hasBluetooth || PackageManager.FEATURE_BLUETOOTH.equals(f.name);
                statusIcon = R.drawable.fs_good;
                actualFeatures.remove(f.name);
            } else if (!present && f.required) {
                // it's required, but device doesn't report it. Boo, set the
                // bogus icon
                statusIcon = R.drawable.fs_error;
                if (hasTelevision && PackageManager.FEATURE_LOCATION.equals(f.name)) {
                    statusIcon = R.drawable.fs_indeterminate;
                }
            } else {
                // device doesn't report it, but it's not req'd, so can't tell
                // if there's a problem
                statusIcon = R.drawable.fs_indeterminate;
            }
            row.put(""feature"", f.name);
            row.put(""icon"", statusIcon);
        }

        // now roll over any remaining features (which are non-standard)
        for (String feature : actualFeatures.keySet()) {
            if (feature == null || """".equals(feature))
                continue;
            HashMap<String, Object> row = new HashMap<String, Object>();
            listViewData.add(row);
            row.put(""feature"", feature);
            if (feature.startsWith(""android"")) { // intentionally not ""android.""
                // sorry, you're not allowed to squat in the official namespace;
                // set bogus icon
                row.put(""icon"", R.drawable.fs_error);
                hasIllegalFeature = true;
            } else {
                // non-standard features are okay, but flag them just in case
                row.put(""icon"", R.drawable.fs_warning);
            }
        }

        // sort the ListView's data to group by icon type, for easier reading by
        // humans
        final HashMap<Integer, Integer> idMap = new HashMap<Integer, Integer>();
        idMap.put(R.drawable.fs_error, 0);
        idMap.put(R.drawable.fs_warning, 1);
        idMap.put(R.drawable.fs_indeterminate, 2);
        idMap.put(R.drawable.fs_good, 3);
        Collections.sort(listViewData, new Comparator<HashMap<String, Object>>() {
            public int compare(HashMap<String, Object> left, HashMap<String, Object> right) {
                int leftId = idMap.get(left.get(""icon""));
                int rightId = idMap.get(right.get(""icon""));
                if (leftId == rightId) {
                    return ((String) left.get(""feature"")).compareTo((String) right.get(""feature""));
                }
                if (leftId < rightId)
                    return -1;
                return 1;
            }
        });

        // Set up the SimpleAdapter used to populate the ListView
        SimpleAdapter adapter = new SimpleAdapter(this, listViewData, R.layout.fs_row,
                new String[] {
                        ""feature"", ""icon""
                }, new int[] {
                        R.id.fs_feature, R.id.fs_icon
                });
        adapter.setViewBinder(new SimpleAdapter.ViewBinder() {
            public boolean setViewValue(View view, Object data, String repr) {
                try {
                    if (view instanceof ImageView) {
                        ((ImageView) view).setImageResource((Integer) data);
                    } else if (view instanceof TextView) {
                        ((TextView) view).setText((String) data);
                    } else {
                        return false;
                    }
                    return true;
                } catch (ClassCastException e) {
                    return false;
                }
            }
        });
        setListAdapter(adapter);

        // finally, check for our second-order error cases and set warning text
        // if necessary
        StringBuffer sb = new StringBuffer();
        if (hasIllegalFeature) {
            sb.append(getResources().getString(R.string.fs_disallowed)).append(""\n"");
        }

        if (!hasWifi && !hasTelephony && !hasBluetooth) {
            sb.append(getResources().getString(R.string.fs_missing_wifi_telephony)).append(""\n"");
        }

        String warnings = sb.toString().trim();
        if (warnings == null || """".equals(warnings)) {
            ((TextView) (findViewById(R.id.fs_warnings))).setVisibility(View.GONE);
        } else {
            ((TextView) (findViewById(R.id.fs_warnings))).setText(warnings);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.SimpleReaderActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/SimpleReaderActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.app.AlertDialog;
import android.content.Intent;
import android.content.SharedPreferences;
import android.nfc.NfcAdapter;
import android.nfc.NfcAdapter.ReaderCallback;
import android.nfc.tech.IsoDep;
import android.nfc.Tag;
import android.os.Bundle;
import android.os.Parcelable;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.ArrayAdapter;
import android.widget.Spinner;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.io.IOException;
import java.util.Arrays;

@TargetApi(19)
public class SimpleReaderActivity extends PassFailButtons.Activity implements ReaderCallback,
        OnItemSelectedListener {
    public static final String PREFS_NAME = ""HceTypePrefs"";

    public static final String TAG = ""SimpleReaderActivity"";
    public static final String EXTRA_APDUS = ""apdus"";
    public static final String EXTRA_RESPONSES = ""responses"";
    public static final String EXTRA_LABEL = ""label"";

    NfcAdapter mAdapter;
    CommandApdu[] mApdus;
    String[] mResponses;
    String mLabel;

    TextView mTextView;
    Spinner mSpinner;
    SharedPreferences mPrefs;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.nfc_hce_reader);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mLabel = getIntent().getStringExtra(EXTRA_LABEL);
        setTitle(mLabel);

        mAdapter = NfcAdapter.getDefaultAdapter(this);
        mTextView = (TextView) findViewById(R.id.text);
        mTextView.setTextSize(12.0f);
        mTextView.setText(R.string.nfc_hce_type_selection);

        Spinner spinner = (Spinner) findViewById(R.id.type_ab_selection);
        ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(this,
                R.array.nfc_types_array, android.R.layout.simple_spinner_item);
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        spinner.setAdapter(adapter);
        spinner.setOnItemSelectedListener(this);

        mPrefs = getSharedPreferences(PREFS_NAME, 0);
        boolean isTypeB = mPrefs.getBoolean(""typeB"", false);
        if (isTypeB) {
            spinner.setSelection(1);
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        mAdapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_A |
                NfcAdapter.FLAG_READER_NFC_BARCODE | NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);
        Intent intent = getIntent();
        Parcelable[] apdus = intent.getParcelableArrayExtra(EXTRA_APDUS);
        if (apdus != null) {
         mApdus = new CommandApdu[apdus.length];
         for (int i = 0; i < apdus.length; i++) {
             mApdus[i] = (CommandApdu) apdus[i];
         }
        } else {
            mApdus = null;
        }
        mResponses = intent.getStringArrayExtra(EXTRA_RESPONSES);
    }

    @Override
    public void onTagDiscovered(Tag tag) {
        final StringBuilder sb = new StringBuilder();
        IsoDep isoDep = IsoDep.get(tag);
        if (isoDep == null) {
            // TODO dialog box
            return;
        }

        try {
            isoDep.connect();
            isoDep.setTimeout(5000);
            int count = 0;
            boolean success = true;
            long startTime = System.currentTimeMillis();
            for (CommandApdu apdu: mApdus) {
                sb.append(""Request APDU:\n"");
                sb.append(apdu.getApdu() + ""\n\n"");
                long apduStartTime = System.currentTimeMillis();
                byte[] response = isoDep.transceive(HceUtils.hexStringToBytes(apdu.getApdu()));
                long apduEndTime = System.currentTimeMillis();
                sb.append(""Response APDU (in "" + Long.toString(apduEndTime - apduStartTime) +
                        "" ms):\n"");
                sb.append(HceUtils.getHexBytes(null, response));

                sb.append(""\n\n\n"");
                boolean wildCard = ""*"".equals(mResponses[count]);
                byte[] expectedResponse = HceUtils.hexStringToBytes(mResponses[count]);
                Log.d(TAG, HceUtils.getHexBytes(""APDU response: "", response));
                if (!wildCard && !Arrays.equals(response, expectedResponse)) {
                    Log.d(TAG, ""Unexpected APDU response: "" + HceUtils.getHexBytes("""", response));
                    success = false;
                    break;
                }
                count++;
            }
            if (success) {
                sb.insert(0, ""Total APDU exchange time: "" +
                        Long.toString(System.currentTimeMillis() - startTime) + "" ms.\n\n"");
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(sb.toString());
                        getPassButton().setEnabled(true);
                    }
                });
            } else {
                sb.insert(0, ""FAIL. Total APDU exchange time: "" +
                        Long.toString(System.currentTimeMillis() - startTime) + "" ms.\n\n"");
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(sb.toString());
                        AlertDialog.Builder builder = new AlertDialog.Builder(SimpleReaderActivity.this);
                        builder.setTitle(""Test failed"");
                        builder.setMessage(""An unexpected response APDU was received, or no APDUs were received at all."");
                        builder.setPositiveButton(""OK"", null);
                        builder.show();
                    }
                });
            }
        } catch (IOException e) {
            sb.insert(0, ""Error while reading: (did you keep the devices in range?)\nPlease try again\n."");
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    mTextView.setText(sb.toString());
                }
            });
        } finally {
        }
    }

    @Override
    public void onItemSelected(AdapterView<?> parent, View view, int position,
            long id) {
        if (position == 0) {
            // Type-A
            mAdapter.disableReaderMode(this);
            mAdapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_A |
                NfcAdapter.FLAG_READER_NFC_BARCODE | NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);
            SharedPreferences.Editor editor = mPrefs.edit();
            editor.putBoolean(""typeB"", false);
            editor.commit();
        } else {
            // Type-B
            mAdapter.disableReaderMode(this);
            mAdapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_B |
                    NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);
            SharedPreferences.Editor editor = mPrefs.edit();
            editor.putBoolean(""typeB"", true);
            editor.commit();
        }
    }

    @Override
    public void onNothingSelected(AdapterView<?> parent) {
    }

    @Override
    public String getTestId() {
        return mLabel;
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.telecom.cts.BaseRemoteTelecomTest"	"assertCtsRemoteConnectionServiceUnbound"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BaseRemoteTelecomTest.java"	""	"public void test/*
 *.
 */

package android.telecom.cts;

import static android.telecom.cts.TestUtils.*;

import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.junit.Assert.assertThat;

import android.content.ComponentName;
import android.telecom.Connection;
import android.telecom.PhoneAccount;
import android.telecom.PhoneAccountHandle;
import android.telecom.RemoteConference;
import android.telecom.RemoteConnection;
import android.text.TextUtils;
import android.util.Log;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Base class for Telecom CTS tests that require a {@link CtsConnectionService} and
 * {@link CtsRemoteConnectionService} to verify Telecom functionality. This class
 * extends from the {@link BaseTelecomTestWithMockServices} and should be extended
 * for all RemoteConnection/RemoteConferencTest.
 */
public class BaseRemoteTelecomTest extends BaseTelecomTestWithMockServices {

    public static final PhoneAccountHandle TEST_REMOTE_PHONE_ACCOUNT_HANDLE =
            new PhoneAccountHandle(new ComponentName(PACKAGE, REMOTE_COMPONENT), REMOTE_ACCOUNT_ID);
    public static final String TEST_REMOTE_PHONE_ACCOUNT_ADDRESS = ""tel:666-TEST"";

    MockConnectionService remoteConnectionService = null;

    @Override
    protected void tearDown() throws Exception {
        if (mShouldTestTelecom) {
            tearDownRemoteConnectionService(TEST_REMOTE_PHONE_ACCOUNT_HANDLE);
        }
        super.tearDown();
    }

    protected void setupConnectionServices(MockConnectionService connectionService,
            MockConnectionService remoteConnectionService, int flags) throws Exception {
        // Setup the primary connection service first
        setupConnectionService(connectionService, flags);
        setupRemoteConnectionService(remoteConnectionService, flags);
    }

    protected void setupRemoteConnectionService(MockConnectionService remoteConnectionService,
            int flags) throws Exception {
        if (remoteConnectionService != null) {
            this.remoteConnectionService = remoteConnectionService;
        } else {
            // Generate a vanilla mock connection service, if not provided.
            this.remoteConnectionService = new MockConnectionService();
        }
        CtsRemoteConnectionService.setUp(TEST_REMOTE_PHONE_ACCOUNT_HANDLE,
                this.remoteConnectionService);

        if ((flags & FLAG_REGISTER) != 0) {
            // This needs SIM subscription, so register via adb commands to get system permission.
            TestUtils.registerSimPhoneAccount(getInstrumentation(),
                    TEST_REMOTE_PHONE_ACCOUNT_HANDLE,
                    REMOTE_ACCOUNT_LABEL,
                    TEST_REMOTE_PHONE_ACCOUNT_ADDRESS);
            // Wait till the adb commands have executed and account is in Telecom database.
            assertPhoneAccountRegistered(TEST_REMOTE_PHONE_ACCOUNT_HANDLE);
        }
        if ((flags & FLAG_ENABLE) != 0) {
            TestUtils.enablePhoneAccount(getInstrumentation(), TEST_REMOTE_PHONE_ACCOUNT_HANDLE);
            // Wait till the adb commands have executed and account is enabled in Telecom database.
            assertPhoneAccountEnabled(TEST_REMOTE_PHONE_ACCOUNT_HANDLE);
        }
    }

    protected void tearDownRemoteConnectionService(PhoneAccountHandle remoteAccountHandle)
            throws Exception {
        assertNumConnections(this.remoteConnectionService, 0);
        mTelecomManager.unregisterPhoneAccount(remoteAccountHandle);
        CtsRemoteConnectionService.tearDown();
        //Telecom doesn't unbind the remote connection service at the end of all calls today.
        //assertCtsRemoteConnectionServiceUnbound();
        this.remoteConnectionService = null;
    }

    MockConnection verifyConnectionForOutgoingCallOnRemoteCS() {
        // Assuming only 1 connection present
        return verifyConnectionForOutgoingCallOnRemoteCS(0);
    }

    MockConnection verifyConnectionForOutgoingCallOnRemoteCS(int connectionIndex) {
        try {
            if (!remoteConnectionService.lock.tryAcquire(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No outgoing call connection requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        assertThat(""Telecom should create outgoing connection for remote outgoing call"",
                remoteConnectionService.outgoingConnections.size(), not(equalTo(0)));
        assertEquals(""Telecom should not create incoming connections for remote outgoing calls"",
                0, remoteConnectionService.incomingConnections.size());
        MockConnection connection = remoteConnectionService.outgoingConnections.get(connectionIndex);
        return connection;
    }

    MockConnection verifyConnectionForIncomingCallOnRemoteCS() {
        // Assuming only 1 connection present
        return verifyConnectionForIncomingCallOnRemoteCS(0);
    }

    MockConnection verifyConnectionForIncomingCallOnRemoteCS(int connectionIndex) {
        try {
            if (!remoteConnectionService.lock.tryAcquire(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No outgoing call connection requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        assertThat(""Telecom should create incoming connections for remote incoming calls"",
                remoteConnectionService.incomingConnections.size(), not(equalTo(0)));
        assertEquals(""Telecom should not create outgoing connections for remote incoming calls"",
                0, remoteConnectionService.outgoingConnections.size());
        MockConnection connection = remoteConnectionService.incomingConnections.get(connectionIndex);
        setAndVerifyConnectionForIncomingCall(connection);
        return connection;
    }

    void setAndVerifyConferenceablesForOutgoingConnectionOnRemoteCS(int connectionIndex) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        /**
         * Set the conferenceable connections on the given connection and it's remote connection
         * counterpart.
         */
        // Make all other outgoing connections as conferenceable with this remote connection.
        MockConnection connection = remoteConnectionService.outgoingConnections.get(connectionIndex);
        List<Connection> confConnections =
                new ArrayList<>(remoteConnectionService.outgoingConnections.size());
        for (Connection c : remoteConnectionService.outgoingConnections) {
            if (c != connection) {
                confConnections.add(c);
            }
        }
        connection.setConferenceableConnections(confConnections);
        assertEquals(connection.getConferenceables(), confConnections);
    }

    MockConference verifyConferenceForOutgoingCallOnRemoteCS() {
        try {
            if (!remoteConnectionService.lock.tryAcquire(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No outgoing conference requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }
        // Return the newly created conference object to the caller
        MockConference conference = remoteConnectionService.conferences.get(0);
        setAndVerifyConferenceForOutgoingCall(conference);
        return conference;
    }

    MockConference verifyConferenceOnRemoteCS(int permit) {
        try {
            if (!remoteConnectionService.lock.tryAcquire(permit, WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No conference requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }
        return remoteConnectionService.conferences.get(0);
    }

    void assertRemoteConnectionState(final RemoteConnection connection, final int state) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return state;
                    }

                    @Override
                    public Object actual() {
                        return connection.getState();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Remote Connection should be in state "" + state
        );
    }

    void assertRemoteConferenceState(final RemoteConference conference, final int state) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return state;
                    }

                    @Override
                    public Object actual() {
                        return conference.getState();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Remote Conference should be in state "" + state
        );
    }

    void assertCtsRemoteConnectionServiceUnbound() {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected(){
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return CtsRemoteConnectionService.isServiceUnbound();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""CtsRemoteConnectionService not yet unbound!""
        );
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"main.java.com.android.bedstead.dpmwrapper.DeviceOwnerHelper"	"isHeadlessSystemUser"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/dpmwrapper/src/main/java/com/android/bedstead/dpmwrapper/DeviceOwnerHelper.java"	""	"public void test/*
 *.
 */
package com.android.bedstead.dpmwrapper;

import static com.android.bedstead.dpmwrapper.DataFormatter.addArg;
import static com.android.bedstead.dpmwrapper.DataFormatter.getArg;
import static com.android.bedstead.dpmwrapper.TestAppSystemServiceFactory.RESULT_EXCEPTION;
import static com.android.bedstead.dpmwrapper.TestAppSystemServiceFactory.RESULT_OK;
import static com.android.bedstead.dpmwrapper.Utils.ACTION_WRAPPED_MANAGER_CALL;
import static com.android.bedstead.dpmwrapper.Utils.EXTRA_CLASS;
import static com.android.bedstead.dpmwrapper.Utils.EXTRA_METHOD;
import static com.android.bedstead.dpmwrapper.Utils.EXTRA_NUMBER_ARGS;
import static com.android.bedstead.dpmwrapper.Utils.VERBOSE;
import static com.android.bedstead.dpmwrapper.Utils.callOnHandlerThread;
import static com.android.bedstead.dpmwrapper.Utils.isHeadlessSystemUser;

import android.annotation.Nullable;
import android.app.admin.DeviceAdminReceiver;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Helper class used by the device owner apps.
 */
public final class DeviceOwnerHelper {

    private static final String TAG = DeviceOwnerHelper.class.getSimpleName();

    /**
     * Executes a method requested by the test app.
     *
     * <p>Typical usage:
     *
     * <pre><code>
        @Override
        public void onReceive(Context context, Intent intent) {
            if (DeviceOwnerAdminReceiverHelper.runManagerMethod(this, context, intent)) return;
            super.onReceive(context, intent);
        }
</code></pre>
     *
     * @return whether the {@code intent} represented a method that was executed.
     */
    public static boolean runManagerMethod(BroadcastReceiver receiver, Context context,
            Intent intent) {
        String action = intent.getAction();
        Log.d(TAG, ""runManagerMethod(): user="" + context.getUserId() + "", action="" + action);

        if (!action.equals(ACTION_WRAPPED_MANAGER_CALL)) {
            if (VERBOSE) Log.v(TAG, ""ignoring, it's not "" + ACTION_WRAPPED_MANAGER_CALL);
            return false;
        }

        try {
            String className = intent.getStringExtra(EXTRA_CLASS);
            String methodName = intent.getStringExtra(EXTRA_METHOD);
            int numberArgs = intent.getIntExtra(EXTRA_NUMBER_ARGS, 0);
            Log.d(TAG, ""runManagerMethod(): userId="" + context.getUserId()
                    + "", intent="" + intent.getAction() + "", class="" + className
                    + "", methodName="" + methodName + "", numberArgs="" + numberArgs);
            final Object[] args;
            Class<?>[] parameterTypes = null;
            if (numberArgs > 0) {
                args = new Object[numberArgs];
                parameterTypes = new Class<?>[numberArgs];
                Bundle extras = intent.getExtras();
                for (int i = 0; i < numberArgs; i++) {
                    getArg(extras, args, parameterTypes, i);
                }
                Log.d(TAG, ""converted args: "" + Arrays.toString(args) + "" (with types ""
                        + Arrays.toString(parameterTypes) + "")"");
            } else {
                args = null;
            }
            Class<?> managerClass = Class.forName(className);
            Method method = findMethod(managerClass, methodName, parameterTypes);
            if (method == null) {
                sendError(receiver, new IllegalArgumentException(
                        ""Could not find method "" + methodName + "" using reflection""));
                return true;
            }
            Object manager = context.getSystemService(managerClass);
            // Must handle in a separate thread as some APIs will fail when called from main's
            Object result = callOnHandlerThread(() -> method.invoke(manager, args));

            if (VERBOSE) {
                // Some results - like network logging events - are quite large
                Log.v(TAG, ""runManagerMethod(): method returned "" + result);
            } else {
                Log.v(TAG, ""runManagerMethod(): method returned fine"");
            }
            sendResult(receiver, result);
        } catch (Exception e) {
            sendError(receiver, e);
        }

        return true;
    }

    /**
     * Called by the device owner {@link DeviceAdminReceiver} to broadcasts an intent to the
     * receivers in the test case app.
     *
     * <p>It must be used in place of standard APIs (such as
     * {@code LocalBroadcastManager.sendBroadcast()}) because on headless system user mode the test
     * app might be running in a different user (and this method will take care of IPC'ing the
     * intent over).
     */
    public static void sendBroadcastToTestAppReceivers(Context context, Intent intent) {
        if (forwardBroadcastToTestApp(context, intent)) return;

        Log.d(TAG, ""Broadcasting "" + intent.getAction() + "" locally on user ""
                + context.getUserId());
        LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
    }

    /**
     * Forwards the intent to the test app.
     *
     * <p>This method is needed in cases where the received of DPM callback must to some processing;
     * it should try to forward it first, as if it's running on headless system user, the processing
     * should be tone on the test user side.
     *
     * @return when {@code true}, the intent was forwarded and should not be processed locally.
     */
    public static boolean forwardBroadcastToTestApp(Context context, Intent intent) {
        if (!isHeadlessSystemUser()) return false;

        TestAppCallbacksReceiver.sendBroadcast(context, intent);
        return true;
    }

    @Nullable
    private static Method findMethod(Class<?> clazz, String methodName, Class<?>[] parameterTypes)
            throws NoSuchMethodException {
        // Handle some special cases first...

        // Methods that use CharSequence instead of String
        if (parameterTypes != null && parameterTypes.length == 2) {
            switch (methodName) {
                case ""wipeData"":
                    return clazz.getDeclaredMethod(methodName,
                            new Class<?>[] { int.class, CharSequence.class });
                case ""setDeviceOwnerLockScreenInfo"":
                case ""setOrganizationName"":
                    return clazz.getDeclaredMethod(methodName,
                            new Class<?>[] { ComponentName.class, CharSequence.class });
            }
        }
        if ((methodName.equals(""setStartUserSessionMessage"")
                || methodName.equals(""setEndUserSessionMessage""))) {
            return clazz.getDeclaredMethod(methodName,
                    new Class<?>[] { ComponentName.class, CharSequence.class });
        }

        // Calls with null parameters (and hence the type cannot be inferred)
        Method method = findMethodWithNullParameterCall(clazz, methodName, parameterTypes);
        if (method != null) return method;

        // ...otherwise return exactly what as asked
        return clazz.getDeclaredMethod(methodName, parameterTypes);
    }

    @Nullable
    private static Method findMethodWithNullParameterCall(Class<?> clazz, String methodName,
            Class<?>[] parameterTypes) {
        if (parameterTypes == null) return null;

        Log.d(TAG, ""findMethodWithNullParameterCall(): "" + clazz + ""."" + methodName + ""(""
                    + Arrays.toString(parameterTypes) + "")"");

        boolean hasNullParameter = false;
        for (int i = 0; i < parameterTypes.length; i++) {
            if (parameterTypes[i] == null) {
                if (VERBOSE) {
                    Log.v(TAG, ""Found null parameter at index "" + i + "" of "" + methodName);
                }
                hasNullParameter = true;
                break;
            }
        }
        if (!hasNullParameter) return null;

        List<Method> methods = new ArrayList<>();
        for (Method method : clazz.getDeclaredMethods()) {
            if (method.getName().equals(methodName)
                    && method.getParameterCount() == parameterTypes.length) {
                methods.add(method);
            }
        }
        if (VERBOSE) Log.v(TAG, ""Methods found: "" + methods);

        switch (methods.size()) {
            case 0:
                return null;
            case 1:
                return methods.get(0);
            default:
                return findBestMethod(methods, parameterTypes);
        }
    }

    @Nullable
    private static Method findBestMethod(List<Method> methods, Class<?>[] parameterTypes) {
        if (VERBOSE) {
            Log.v(TAG, ""Found "" + methods.size() + "" methods: "" + methods);
        }
        Method bestMethod = null;

        _methods: for (Method method : methods) {
            Parameter[] methodParameters = method.getParameters();
            for (int i = 0; i < parameterTypes.length; i++) {
                Class<?> expectedType = parameterTypes[i];
                if (expectedType == null) continue;

                Class<?> actualType = methodParameters[i].getType();
                if (!expectedType.equals(actualType)) {
                    if (VERBOSE) {
                        Log.v(TAG, ""Parameter at index "" + i + "" doesn't match (expecting ""
                                + expectedType + "", got "" + actualType + ""); rejecting "" + method);
                    }
                    continue _methods;
                }
            }
            // double check there isn't more than one
            if (bestMethod != null) {
                Log.e(TAG, ""found another method ("" + method + ""), but will use "" + bestMethod);
            } else {
                bestMethod = method;
            }
        }
        if (VERBOSE) Log.v(TAG, ""Returning "" + bestMethod);
        return bestMethod;
    }

    private static void sendError(BroadcastReceiver receiver, Exception e) {
        Log.e(TAG, ""Exception handling wrapped DPC call"" , e);
        sendNoLog(receiver, RESULT_EXCEPTION, e);
    }

    private static void sendResult(BroadcastReceiver receiver, Object result) {
        sendNoLog(receiver, RESULT_OK, result);
        if (VERBOSE) Log.v(TAG, ""Sent"");
    }

    private static void sendNoLog(BroadcastReceiver receiver, int code, Object result) {
        if (VERBOSE) {
            Log.v(TAG, ""Sending "" + TestAppSystemServiceFactory.resultCodeToString(code)
                    + "" (result='"" + result + ""') to "" + receiver + "" on ""
                    + Thread.currentThread());
        }
        receiver.setResultCode(code);
        if (result != null) {
            Intent intent = new Intent();
            addArg(intent, new Object[] { result }, /* index= */ 0);
            receiver.setResultExtras(intent.getExtras());
        }
    }

    private DeviceOwnerHelper() {
        throw new UnsupportedOperationException(""contains only static methods"");
    }
}"	""	""	"DPC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.telecom.cts.BaseTelecomTestWithMockServices"	"disableCarMode"	"CtsTelecomTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BaseTelecomTestWithMockServices.java"	""	"public void test/*
 *.
 */

package android.telecom.cts;

import static android.telecom.cts.TestUtils.PACKAGE;
import static android.telecom.cts.TestUtils.TAG;
import static android.telecom.cts.TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.not;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertThat;

import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.app.UiModeManager;
import android.content.Context;
import android.content.Intent;
import android.content.res.Configuration;
import android.content.pm.PackageManager;
import android.database.ContentObserver;
import android.database.Cursor;
import android.media.AudioManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.RemoteException;
import android.os.Process;
import android.os.UserHandle;
import android.provider.CallLog;
import android.telecom.Call;
import android.telecom.CallAudioState;
import android.telecom.Conference;
import android.telecom.Connection;
import android.telecom.ConnectionRequest;
import android.telecom.InCallService;
import android.telecom.PhoneAccount;
import android.telecom.PhoneAccountHandle;
import android.telecom.TelecomManager;
import android.telecom.VideoProfile;
import android.telecom.cts.MockInCallService.InCallServiceCallbacks;
import android.telecom.cts.carmodetestapp.ICtsCarModeInCallServiceControl;
import android.telephony.PhoneStateListener;
import android.telephony.TelephonyCallback;
import android.telephony.TelephonyManager;
import android.telephony.emergency.EmergencyNumber;
import android.test.InstrumentationTestCase;
import android.text.TextUtils;
import android.util.Log;
import android.util.Pair;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Base class for Telecom CTS tests that require a {@link CtsConnectionService} and
 * {@link MockInCallService} to verify Telecom functionality.
 */
public class BaseTelecomTestWithMockServices extends InstrumentationTestCase {

    public static final int FLAG_REGISTER = 0x1;
    public static final int FLAG_ENABLE = 0x2;
    public static final int FLAG_SET_DEFAULT = 0x4;

    // Don't accidently use emergency number.
    private static int sCounter = 5553638;

    public static final String TEST_EMERGENCY_NUMBER = ""5553637"";
    public static final Uri TEST_EMERGENCY_URI = Uri.fromParts(""tel"", TEST_EMERGENCY_NUMBER, null);
    public static final String PKG_NAME = ""android.telecom.cts"";
    public static final String PERMISSION_PROCESS_OUTGOING_CALLS =
            ""android.permission.PROCESS_OUTGOING_CALLS"";

    Context mContext;
    TelecomManager mTelecomManager;
    TelephonyManager mTelephonyManager;
    UiModeManager mUiModeManager;

    TestUtils.InvokeCounter mOnBringToForegroundCounter;
    TestUtils.InvokeCounter mOnCallAudioStateChangedCounter;
    TestUtils.InvokeCounter mOnPostDialWaitCounter;
    TestUtils.InvokeCounter mOnCannedTextResponsesLoadedCounter;
    TestUtils.InvokeCounter mOnSilenceRingerCounter;
    TestUtils.InvokeCounter mOnConnectionEventCounter;
    TestUtils.InvokeCounter mOnExtrasChangedCounter;
    TestUtils.InvokeCounter mOnPropertiesChangedCounter;
    TestUtils.InvokeCounter mOnRttModeChangedCounter;
    TestUtils.InvokeCounter mOnRttStatusChangedCounter;
    TestUtils.InvokeCounter mOnRttInitiationFailedCounter;
    TestUtils.InvokeCounter mOnRttRequestCounter;
    TestUtils.InvokeCounter mOnHandoverCompleteCounter;
    TestUtils.InvokeCounter mOnHandoverFailedCounter;
    TestUtils.InvokeCounter mOnPhoneAccountChangedCounter;
    Bundle mPreviousExtras;
    int mPreviousProperties = -1;
    PhoneAccountHandle mPreviousPhoneAccountHandle = null;

    InCallServiceCallbacks mInCallCallbacks;
    String mPreviousDefaultDialer = null;
    PhoneAccountHandle mPreviousDefaultOutgoingAccount = null;
    boolean mShouldRestoreDefaultOutgoingAccount = false;
    MockConnectionService connectionService = null;
    boolean mIsEmergencyCallingSetup = false;

    HandlerThread mTelephonyCallbackThread;
    Handler mTelephonyCallbackHandler;
    TestTelephonyCallback mTelephonyCallback;
    TestCallStateListener mTestCallStateListener;
    Handler mHandler;

    /**
     * Uses the control interface to disable car mode.
     * @param expectedUiMode
     */
    protected void disableAndVerifyCarMode(ICtsCarModeInCallServiceControl control,
            int expectedUiMode) {
        if (control == null) {
            return;
        }
        try {
            control.disableCarMode();
        } catch (RemoteException re) {
            fail(""Bee-boop; can't control the incall service"");
        }
        assertUiMode(expectedUiMode);
    }

    protected void disconnectAllCallsAndVerify(ICtsCarModeInCallServiceControl controlBinder) {
        if (controlBinder == null) {
            return;
        }
        try {
            controlBinder.disconnectCalls();
        } catch (RemoteException re) {
            fail(""Bee-boop; can't control the incall service"");
        }
        assertCarModeCallCount(controlBinder, 0);
    }

    /**
     * Verify the car mode ICS has an expected call count.
     * @param expected
     */
    protected void assertCarModeCallCount(ICtsCarModeInCallServiceControl control, int expected) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return expected;
                    }

                    @Override
                    public Object actual() {
                        int callCount = 0;
                        try {
                            callCount = control.getCallCount();
                        } catch (RemoteException re) {
                            fail(""Bee-boop; can't control the incall service"");
                        }
                        return callCount;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected "" + expected + "" calls.""
        );
    }

    static class TestCallStateListener extends TelephonyCallback
            implements TelephonyCallback.CallStateListener {

        private CountDownLatch mCountDownLatch = new CountDownLatch(1);
        private int mLastState = -1;

        @Override
        public void onCallStateChanged(int state) {
            Log.i(TAG, ""onCallStateChanged: state="" + state);
            mLastState = state;
            mCountDownLatch.countDown();
            mCountDownLatch = new CountDownLatch(1);
        }

        public CountDownLatch getCountDownLatch() {
            return mCountDownLatch;
        }

        public int getLastState() {
            return mLastState;
        }
    }

    static class TestTelephonyCallback extends TelephonyCallback implements
            TelephonyCallback.CallStateListener,
            TelephonyCallback.OutgoingEmergencyCallListener,
            TelephonyCallback.EmergencyNumberListListener {
        /** Semaphore released for every callback invocation. */
        public Semaphore mCallbackSemaphore = new Semaphore(0);

        List<Integer> mCallStates = new ArrayList<>();
        EmergencyNumber mLastOutgoingEmergencyNumber;

        LinkedBlockingQueue<Map<Integer, List<EmergencyNumber>>> mEmergencyNumberListQueue =
               new LinkedBlockingQueue<>(2);

        @Override
        public void onCallStateChanged(int state) {
            Log.i(TAG, ""onCallStateChanged: state="" + state);
            mCallStates.add(state);
            mCallbackSemaphore.release();
        }

        @Override
        public void onOutgoingEmergencyCall(EmergencyNumber emergencyNumber, int subscriptionId) {
            Log.i(TAG, ""onOutgoingEmergencyCall: emergencyNumber="" + emergencyNumber);
            mLastOutgoingEmergencyNumber = emergencyNumber;
            mCallbackSemaphore.release();
        }

        @Override
        public void onEmergencyNumberListChanged(
                Map<Integer, List<EmergencyNumber>> emergencyNumberList) {
            Log.i(TAG, ""onEmergencyNumberChanged, total size="" + emergencyNumberList.values()
                    .stream().mapToInt(List::size).sum());
            mEmergencyNumberListQueue.offer(emergencyNumberList);
        }

        public Map<Integer, List<EmergencyNumber>> waitForEmergencyNumberListUpdate(
                long timeoutMillis) throws Throwable {
            return mEmergencyNumberListQueue.poll(timeoutMillis, TimeUnit.MILLISECONDS);
        }
    }

    boolean mShouldTestTelecom = true;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mContext = getInstrumentation().getContext();
        mHandler = new Handler(Looper.getMainLooper());
        mShouldTestTelecom = TestUtils.shouldTestTelecom(mContext);
        if (!mShouldTestTelecom) {
            return;
        }

        // Assume we start in normal mode at the start of all Telecom tests; a failure to leave car
        // mode in any of the tests would cause subsequent test failures.
        // For Watch, UI_MODE shouldn't be normal mode.
        mUiModeManager = mContext.getSystemService(UiModeManager.class);
        TestUtils.executeShellCommand(getInstrumentation(), ""telecom reset-car-mode"");

        if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
             assertUiMode(Configuration.UI_MODE_TYPE_WATCH);
        } else {
             assertUiMode(Configuration.UI_MODE_TYPE_NORMAL);
        }

        AppOpsManager aom = mContext.getSystemService(AppOpsManager.class);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(aom,
                (appOpsMan) -> appOpsMan.setUidMode(AppOpsManager.OPSTR_PROCESS_OUTGOING_CALLS,
                Process.myUid(), AppOpsManager.MODE_ALLOWED));

        mTelecomManager = (TelecomManager) mContext.getSystemService(Context.TELECOM_SERVICE);
        mTelephonyManager = (TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE);

        mPreviousDefaultDialer = TestUtils.getDefaultDialer(getInstrumentation());
        TestUtils.setDefaultDialer(getInstrumentation(), PACKAGE);
        setupCallbacks();

       // Register a call state listener.
        mTestCallStateListener = new TestCallStateListener();
        CountDownLatch latch = mTestCallStateListener.getCountDownLatch();
        mTelephonyManager.registerTelephonyCallback(r -> r.run(), mTestCallStateListener);
        latch.await(
                TestUtils.WAIT_FOR_PHONE_STATE_LISTENER_REGISTERED_TIMEOUT_S, TimeUnit.SECONDS);
        // Create a new thread for the telephony callback.
        mTelephonyCallbackThread = new HandlerThread(""PhoneStateListenerThread"");
        mTelephonyCallbackThread.start();
        mTelephonyCallbackHandler = new Handler(mTelephonyCallbackThread.getLooper());

        mTelephonyCallback = new TestTelephonyCallback();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                (tm) -> tm.registerTelephonyCallback(
                        mTelephonyCallbackHandler::post,
                        mTelephonyCallback));
        UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.grantRuntimePermissionAsUser(PKG_NAME, PERMISSION_PROCESS_OUTGOING_CALLS,
                UserHandle.CURRENT);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        if (!mShouldTestTelecom) {
            return;
        }

        mTelephonyManager.unregisterTelephonyCallback(mTestCallStateListener);

        mTelephonyManager.unregisterTelephonyCallback(mTelephonyCallback);
        mTelephonyCallbackThread.quit();

        cleanupCalls();
        if (!TextUtils.isEmpty(mPreviousDefaultDialer)) {
            TestUtils.setDefaultDialer(getInstrumentation(), mPreviousDefaultDialer);
        }
        tearDownConnectionService(TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
        tearDownEmergencyCalling();
        try {
            assertMockInCallServiceUnbound();
        } catch (Throwable t) {
            // If we haven't unbound, that means there's some dirty state in Telecom that needs
            // cleaning up. Forcibly unbind and clean up Telecom state so that we don't have a
            // cascading failure of tests.
            TestUtils.executeShellCommand(getInstrumentation(), ""telecom cleanup-stuck-calls"");
            throw t;
        }
        UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.revokeRuntimePermissionAsUser(PKG_NAME, PERMISSION_PROCESS_OUTGOING_CALLS,
                UserHandle.CURRENT);
    }

    protected PhoneAccount setupConnectionService(MockConnectionService connectionService,
            int flags) throws Exception {
        Log.i(TAG, ""Setting up mock connection service"");
        if (connectionService != null) {
            this.connectionService = connectionService;
        } else {
            // Generate a vanilla mock connection service, if not provided.
            this.connectionService = new MockConnectionService();
        }
        CtsConnectionService.setUp(this.connectionService);

        if ((flags & FLAG_REGISTER) != 0) {
            mTelecomManager.registerPhoneAccount(TestUtils.TEST_PHONE_ACCOUNT);
        }
        if ((flags & FLAG_ENABLE) != 0) {
            TestUtils.enablePhoneAccount(getInstrumentation(), TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
            // Wait till the adb commands have executed and account is enabled in Telecom database.
            assertPhoneAccountEnabled(TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
        }

        if ((flags & FLAG_SET_DEFAULT) != 0) {
            mPreviousDefaultOutgoingAccount = mTelecomManager.getUserSelectedOutgoingPhoneAccount();
            mShouldRestoreDefaultOutgoingAccount = true;
            TestUtils.setDefaultOutgoingPhoneAccount(getInstrumentation(),
                    TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
            // Wait till the adb commands have executed and the default has changed.
            assertPhoneAccountIsDefault(TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
        }

        return TestUtils.TEST_PHONE_ACCOUNT;
    }

    protected void tearDownConnectionService(PhoneAccountHandle accountHandle) throws Exception {
        Log.i(TAG, ""Tearing down mock connection service"");
        if (this.connectionService != null) {
            assertNumConnections(this.connectionService, 0);
        }
        mTelecomManager.unregisterPhoneAccount(accountHandle);
        CtsConnectionService.tearDown();
        assertCtsConnectionServiceUnbound();
        if (mShouldRestoreDefaultOutgoingAccount) {
            TestUtils.setDefaultOutgoingPhoneAccount(getInstrumentation(),
                    mPreviousDefaultOutgoingAccount);
        }
        this.connectionService = null;
        mPreviousDefaultOutgoingAccount = null;
        mShouldRestoreDefaultOutgoingAccount = false;
    }

    protected void setupForEmergencyCalling(String testNumber) throws Exception {
        TestUtils.setSystemDialerOverride(getInstrumentation());
        TestUtils.addTestEmergencyNumber(getInstrumentation(), testNumber);
        TestUtils.setTestEmergencyPhoneAccountPackageFilter(getInstrumentation(), mContext);
        // Emergency calls require special capabilities.
        TestUtils.registerEmergencyPhoneAccount(getInstrumentation(),
                TestUtils.TEST_EMERGENCY_PHONE_ACCOUNT_HANDLE,
                TestUtils.ACCOUNT_LABEL + ""E"", ""tel:555-EMER"");
        mIsEmergencyCallingSetup = true;
    }

    protected void tearDownEmergencyCalling() throws Exception {
        if (!mIsEmergencyCallingSetup) return;

        TestUtils.clearSystemDialerOverride(getInstrumentation());
        TestUtils.clearTestEmergencyNumbers(getInstrumentation());
        TestUtils.clearTestEmergencyPhoneAccountPackageFilter(getInstrumentation());
        mTelecomManager.unregisterPhoneAccount(TestUtils.TEST_EMERGENCY_PHONE_ACCOUNT_HANDLE);
    }

    protected void startCallTo(Uri address, PhoneAccountHandle accountHandle) {
        final Intent intent = new Intent(Intent.ACTION_CALL, address);
        if (accountHandle != null) {
            intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE, accountHandle);
        }
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
    }

    void sleep(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
        }
    }

    private void setupCallbacks() {
        mInCallCallbacks = new InCallServiceCallbacks() {
            @Override
            public void onCallAdded(Call call, int numCalls) {
                Log.i(TAG, ""onCallAdded, Call: "" + call + "", Num Calls: "" + numCalls);
                this.lock.release();
                mPreviousPhoneAccountHandle = call.getDetails().getAccountHandle();
            }
            @Override
            public void onCallRemoved(Call call, int numCalls) {
                Log.i(TAG, ""onCallRemoved, Call: "" + call + "", Num Calls: "" + numCalls);
            }
            @Override
            public void onParentChanged(Call call, Call parent) {
                Log.i(TAG, ""onParentChanged, Call: "" + call + "", Parent: "" + parent);
                this.lock.release();
            }
            @Override
            public void onChildrenChanged(Call call, List<Call> children) {
                Log.i(TAG, ""onChildrenChanged, Call: "" + call + ""Children: "" + children);
                this.lock.release();
            }
            @Override
            public void onConferenceableCallsChanged(Call call, List<Call> conferenceableCalls) {
                Log.i(TAG, ""onConferenceableCallsChanged, Call: "" + call + "", Conferenceables: "" +
                        conferenceableCalls);
            }
            @Override
            public void onDetailsChanged(Call call, Call.Details details) {
                Log.i(TAG, ""onDetailsChanged, Call: "" + call + "", Details: "" + details);
                if (!areBundlesEqual(mPreviousExtras, details.getExtras())) {
                    mOnExtrasChangedCounter.invoke(call, details);
                }
                mPreviousExtras = details.getExtras();

                if (mPreviousProperties != details.getCallProperties()) {
                    mOnPropertiesChangedCounter.invoke(call, details);
                    Log.i(TAG, ""onDetailsChanged; properties changed from "" + Call.Details.propertiesToString(mPreviousProperties) +
                            "" to "" + Call.Details.propertiesToString(details.getCallProperties()));
                }
                mPreviousProperties = details.getCallProperties();

                if (details.getAccountHandle() != null &&
                        !details.getAccountHandle().equals(mPreviousPhoneAccountHandle)) {
                    mOnPhoneAccountChangedCounter.invoke(call, details.getAccountHandle());
                }
                mPreviousPhoneAccountHandle = details.getAccountHandle();
            }
            @Override
            public void onCallDestroyed(Call call) {
                Log.i(TAG, ""onCallDestroyed, Call: "" + call);
            }
            @Override
            public void onCallStateChanged(Call call, int newState) {
                Log.i(TAG, ""onCallStateChanged, Call: "" + call + "", New State: "" + newState);
            }
            @Override
            public void onBringToForeground(boolean showDialpad) {
                mOnBringToForegroundCounter.invoke(showDialpad);
            }
            @Override
            public void onCallAudioStateChanged(CallAudioState audioState) {
                Log.i(TAG, ""onCallAudioStateChanged, audioState: "" + audioState);
                mOnCallAudioStateChangedCounter.invoke(audioState);
            }
            @Override
            public void onPostDialWait(Call call, String remainingPostDialSequence) {
                mOnPostDialWaitCounter.invoke(call, remainingPostDialSequence);
            }
            @Override
            public void onCannedTextResponsesLoaded(Call call, List<String> cannedTextResponses) {
                mOnCannedTextResponsesLoadedCounter.invoke(call, cannedTextResponses);
            }
            @Override
            public void onConnectionEvent(Call call, String event, Bundle extras) {
                mOnConnectionEventCounter.invoke(call, event, extras);
            }

            @Override
            public void onSilenceRinger() {
                Log.i(TAG, ""onSilenceRinger"");
                mOnSilenceRingerCounter.invoke();
            }

            @Override
            public void onRttModeChanged(Call call, int mode) {
                mOnRttModeChangedCounter.invoke(call, mode);
            }

            @Override
            public void onRttStatusChanged(Call call, boolean enabled, Call.RttCall rttCall) {
                mOnRttStatusChangedCounter.invoke(call, enabled, rttCall);
            }

            @Override
            public void onRttRequest(Call call, int id) {
                mOnRttRequestCounter.invoke(call, id);
            }

            @Override
            public void onRttInitiationFailure(Call call, int reason) {
                mOnRttInitiationFailedCounter.invoke(call, reason);
            }

            @Override
            public void onHandoverComplete(Call call) {
                mOnHandoverCompleteCounter.invoke(call);
            }

            @Override
            public void onHandoverFailed(Call call, int reason) {
                mOnHandoverFailedCounter.invoke(call, reason);
            }
        };

        MockInCallService.setCallbacks(mInCallCallbacks);

        // TODO: If more InvokeCounters are added in the future, consider consolidating them into a
        // single Collection.
        mOnBringToForegroundCounter = new TestUtils.InvokeCounter(""OnBringToForeground"");
        mOnCallAudioStateChangedCounter = new TestUtils.InvokeCounter(""OnCallAudioStateChanged"");
        mOnPostDialWaitCounter = new TestUtils.InvokeCounter(""OnPostDialWait"");
        mOnCannedTextResponsesLoadedCounter = new TestUtils.InvokeCounter(""OnCannedTextResponsesLoaded"");
        mOnSilenceRingerCounter = new TestUtils.InvokeCounter(""OnSilenceRinger"");
        mOnConnectionEventCounter = new TestUtils.InvokeCounter(""OnConnectionEvent"");
        mOnExtrasChangedCounter = new TestUtils.InvokeCounter(""OnDetailsChangedCounter"");
        mOnPropertiesChangedCounter = new TestUtils.InvokeCounter(""OnPropertiesChangedCounter"");
        mOnRttModeChangedCounter = new TestUtils.InvokeCounter(""mOnRttModeChangedCounter"");
        mOnRttStatusChangedCounter = new TestUtils.InvokeCounter(""mOnRttStatusChangedCounter"");
        mOnRttInitiationFailedCounter =
                new TestUtils.InvokeCounter(""mOnRttInitiationFailedCounter"");
        mOnRttRequestCounter = new TestUtils.InvokeCounter(""mOnRttRequestCounter"");
        mOnHandoverCompleteCounter = new TestUtils.InvokeCounter(""mOnHandoverCompleteCounter"");
        mOnHandoverFailedCounter = new TestUtils.InvokeCounter(""mOnHandoverFailedCounter"");
        mOnPhoneAccountChangedCounter = new TestUtils.InvokeCounter(
                ""mOnPhoneAccountChangedCounter"");
    }

    void addAndVerifyNewFailedIncomingCall(Uri incomingHandle, Bundle extras) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        int currentCallCount = 0;
        if (mInCallCallbacks.getService() != null) {
            currentCallCount = mInCallCallbacks.getService().getCallCount();
        }

        if (extras == null) {
            extras = new Bundle();
        }
        extras.putParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS, incomingHandle);
        mTelecomManager.addNewIncomingCall(TestUtils.TEST_PHONE_ACCOUNT_HANDLE, extras);

        if (!connectionService.waitForEvent(
                MockConnectionService.EVENT_CONNECTION_SERVICE_CREATE_CONNECTION_FAILED)) {
            fail(""Incoming Connection failure indication did not get called."");
        }

        assertEquals(""ConnectionService did not receive failed connection"",
                1, connectionService.failedConnections.size());

        assertEquals(""Address is not correct for failed connection"",
                connectionService.failedConnections.get(0).getAddress(), incomingHandle);

        assertEquals(""InCallService should contain the same number of calls."",
                currentCallCount,
                mInCallCallbacks.getService().getCallCount());
    }

    /**
     * Puts Telecom in a state where there is an incoming call provided by the
     * {@link CtsConnectionService} which can be tested.
     */
    void addAndVerifyNewIncomingCall(Uri incomingHandle, Bundle extras) {
        int currentCallCount = addNewIncomingCall(incomingHandle, extras);
        verifyNewIncomingCall(currentCallCount);
    }

    int addNewIncomingCall(Uri incomingHandle, Bundle extras) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        int currentCallCount = 0;
        if (mInCallCallbacks.getService() != null) {
            currentCallCount = mInCallCallbacks.getService().getCallCount();
        }

        if (extras == null) {
            extras = new Bundle();
        }
        extras.putParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS, incomingHandle);
        mTelecomManager.addNewIncomingCall(TestUtils.TEST_PHONE_ACCOUNT_HANDLE, extras);

        return currentCallCount;
    }

    void verifyNewIncomingCall(int currentCallCount) {
        try {
            if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                    TimeUnit.SECONDS)) {
                fail(""No call added to InCallService."");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        assertEquals(""InCallService should contain 1 more call after adding a call."",
                currentCallCount + 1,
                mInCallCallbacks.getService().getCallCount());
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     */
    void placeAndVerifyCall() {
        placeAndVerifyCall(null);
    }

    void placeAndVerifyCallByRedirection(boolean wasCancelled) {
        placeAndVerifyCallByRedirection(null, wasCancelled);
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     */
    void placeAndVerifyCallByRedirection(Bundle extras, boolean wasCancelled) {
        int currentCallCount = (getInCallService() == null) ? 0 : getInCallService().getCallCount();
        int currentConnections = getNumberOfConnections();
        // We expect a new connection if it wasn't cancelled.
        if (!wasCancelled) {
            currentConnections++;
            currentCallCount++;
        }
        placeAndVerifyCall(extras, VideoProfile.STATE_AUDIO_ONLY, currentConnections,
                currentCallCount);
        // Ensure the new outgoing call broadcast fired for the outgoing call.
        assertOutgoingCallBroadcastReceived(true);

        // CTS test does not have read call log permission so should not get the phone number.
        assertNull(NewOutgoingCallBroadcastReceiver.getReceivedNumber());
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     *
     *  @param videoState the video state of the call.
     */
    void placeAndVerifyCall(int videoState) {
        placeAndVerifyCall(null, videoState);
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     */
    void placeAndVerifyCall(Bundle extras) {
        placeAndVerifyCall(extras, VideoProfile.STATE_AUDIO_ONLY);
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     */
    void placeAndVerifyCall(Bundle extras, int videoState) {
        int currentCallCount = (getInCallService() == null) ? 0 : getInCallService().getCallCount();
        // We expect placing the call adds a new call/connection.
        placeAndVerifyCall(extras, videoState, getNumberOfConnections() + 1, currentCallCount + 1);
        assertOutgoingCallBroadcastReceived(true);

        // CTS test does not have read call log permission so should not get the phone number.
        assertNull(NewOutgoingCallBroadcastReceiver.getReceivedNumber());
    }

    /**
     *  Puts Telecom in a state where there is an active call provided by the
     *  {@link CtsConnectionService} which can be tested.
     */
    void placeAndVerifyCall(Bundle extras, int videoState, int expectedConnectionCount,
            int expectedCallCount) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        placeNewCallWithPhoneAccount(extras, videoState);

        try {
            if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                        TimeUnit.SECONDS)) {
                fail(""No call added to InCallService."");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        // Make sure any procedures to disconnect existing calls (makeRoomForOutgoingCall)
        // complete successfully
        TestUtils.waitOnLocalMainLooper(WAIT_FOR_STATE_CHANGE_TIMEOUT_MS);
        TestUtils.waitOnAllHandlers(getInstrumentation());

        assertEquals(""InCallService should match the expected count."", expectedCallCount,
                mInCallCallbacks.getService().getCallCount());

        // The connectionService.lock is released in
        // MockConnectionService#onCreateOutgoingConnection, however the connection will not
        // actually be added to the list of connections in the ConnectionService until shortly
        // afterwards.  So there is still a potential for the lock to be released before it would
        // be seen by calls to ConnectionService#getAllConnections().
        // We will wait here until the list of connections includes one more connection to ensure
        // that placing the call has fully completed.
        assertCSConnections(expectedConnectionCount);
    }

    /**
     * Place an emergency call and verify that it has been setup properly.
     *
     * @param supportsHold If telecom supports holding emergency calls, this will expect two
     * calls. If telecom does not support holding emergency calls, this will expect only the
     * emergency call to be active.
     * @return The emergency connection
     */
    public Connection placeAndVerifyEmergencyCall(boolean supportsHold) {
        Bundle extras = new Bundle();
        extras.putParcelable(TestUtils.EXTRA_PHONE_NUMBER, TEST_EMERGENCY_URI);
        int currentConnectionCount = supportsHold ?
                getNumberOfConnections() + 1 : getNumberOfConnections();
        int currentCallCount = (getInCallService() == null) ? 0 : getInCallService().getCallCount();
        currentCallCount = supportsHold ? currentCallCount + 1 : currentCallCount;
        // The device only supports a max of two calls active at any one time
        currentCallCount = Math.min(currentCallCount, 2);
        placeAndVerifyCall(extras, VideoProfile.STATE_AUDIO_ONLY, currentConnectionCount,
                currentCallCount);
        assertOutgoingCallBroadcastReceived(true);
        Connection connection = verifyConnectionForOutgoingCall(TEST_EMERGENCY_URI);
        TestUtils.waitOnAllHandlers(getInstrumentation());
        return connection;
    }

    int getNumberOfConnections() {
        return CtsConnectionService.getAllConnectionsFromTelecom().size();
    }

    Connection getConnection(Uri address) {
        return CtsConnectionService.getAllConnectionsFromTelecom().stream()
                .filter(c -> c.getAddress().equals(address)).findFirst().orElse(null);
    }

    MockConnection verifyConnectionForOutgoingCall() {
        // Assuming only 1 connection present
        return verifyConnectionForOutgoingCall(0);
    }

    MockConnection verifyConnectionForOutgoingCall(int connectionIndex) {
        try {
            if (!connectionService.lock.tryAcquire(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No outgoing call connection requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        assertThat(""Telecom should create outgoing connection for outgoing call"",
                connectionService.outgoingConnections.size(), not(equalTo(0)));
        MockConnection connection = connectionService.outgoingConnections.get(connectionIndex);
        return connection;
    }

    MockConnection verifyConnectionForOutgoingCall(Uri address) {
        if (!connectionService.waitForEvent(
                MockConnectionService.EVENT_CONNECTION_SERVICE_CREATE_CONNECTION)) {
            fail(""No outgoing call connection requested by Telecom"");
        }
        assertThat(""Telecom should create outgoing connection for outgoing call"",
                connectionService.outgoingConnections.size(), not(equalTo(0)));

        // There is a subtle race condition in ConnectionService.  When onCreateIncomingConnection
        // or onCreateOutgoingConnection completes, ConnectionService then adds the connection to
        // the list of tracked connections.  It's very possible for the lock to be released and
        // the connection to have not yet been added to the connection list yet.
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                                              @Override
                                              public Object expected() {
                                                  return true;
                                              }

                                              @Override
                                              public Object actual() {
                                                  return getConnection(address) != null;
                                              }
                                          },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected call from number "" + address);
        Connection connection = getConnection(address);

        if (connection instanceof MockConnection) {
            if (connectionService.outgoingConnections.contains(connection)) {
                return (MockConnection) connection;
            }
        }
        return null;
    }

    MockConnection verifyConnectionForIncomingCall() {
        // Assuming only 1 connection present
        return verifyConnectionForIncomingCall(0);
    }

    MockConnection verifyConnectionForIncomingCall(int connectionIndex) {
        try {
            if (!connectionService.lock.tryAcquire(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No outgoing call connection requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        assertThat(""Telecom should create incoming connections for incoming calls"",
                connectionService.incomingConnections.size(), not(equalTo(0)));
        MockConnection connection = connectionService.incomingConnections.get(connectionIndex);
        setAndVerifyConnectionForIncomingCall(connection);
        return connection;
    }

    MockConference verifyConference(int permit) {
        try {
            if (!connectionService.lock.tryAcquire(permit, WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No conference requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }
        return connectionService.conferences.get(0);
    }

    void setAndVerifyConnectionForIncomingCall(MockConnection connection) {
        if (connection.getState() == Connection.STATE_ACTIVE) {
            // If the connection is already active (like if it got picked up immediately), don't
            // bother with setting it back to ringing.
            return;
        }
        connection.setRinging();
        assertConnectionState(connection, Connection.STATE_RINGING);
    }

    void setAndVerifyConferenceablesForOutgoingConnection(int connectionIndex) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        // Make all other outgoing connections as conferenceable with this connection.
        MockConnection connection = connectionService.outgoingConnections.get(connectionIndex);
        List<Connection> confConnections =
                new ArrayList<>(connectionService.outgoingConnections.size());
        for (Connection c : connectionService.outgoingConnections) {
            if (c != connection) {
                confConnections.add(c);
            }
        }
        connection.setConferenceableConnections(confConnections);
        assertEquals(connection.getConferenceables(), confConnections);
    }

    void addConferenceCall(Call call1, Call call2) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());
        int currentConfCallCount = 0;
        if (mInCallCallbacks.getService() != null) {
            currentConfCallCount = mInCallCallbacks.getService().getConferenceCallCount();
        }
        // Verify that the calls have each other on their conferenceable list before proceeding
        List<Call> callConfList = new ArrayList<>();
        callConfList.add(call2);
        assertCallConferenceableList(call1, callConfList);

        callConfList.clear();
        callConfList.add(call1);
        assertCallConferenceableList(call2, callConfList);

        call1.conference(call2);

        /**
         * We should have 1 onCallAdded, 2 onChildrenChanged and 2 onParentChanged invoked, so
         * we should have 5 available permits on the incallService lock.
         */
        try {
            if (!mInCallCallbacks.lock.tryAcquire(5, 3, TimeUnit.SECONDS)) {
                fail(""Conference addition failed."");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }

        assertEquals(""InCallService should contain 1 more call after adding a conf call."",
                currentConfCallCount + 1,
                mInCallCallbacks.getService().getConferenceCallCount());
    }

    void splitFromConferenceCall(Call call1) {
        assertEquals(""Lock should have no permits!"", 0, mInCallCallbacks.lock.availablePermits());

        call1.splitFromConference();
        /**
         * We should have 1 onChildrenChanged and 1 onParentChanged invoked, so
         * we should have 2 available permits on the incallService lock.
         */
        try {
            if (!mInCallCallbacks.lock.tryAcquire(2, 3, TimeUnit.SECONDS)) {
                fail(""Conference split failed"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }
    }

    MockConference verifyConferenceForOutgoingCall() {
        try {
            if (!connectionService.lock.tryAcquire(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No outgoing conference requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }
        // Return the newly created conference object to the caller
        MockConference conference = connectionService.conferences.get(0);
        setAndVerifyConferenceForOutgoingCall(conference);
        return conference;
    }

    Pair<Conference, ConnectionRequest> verifyAdhocConferenceCall() {
        try {
            if (!connectionService.lock.tryAcquire(2, WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS)) {
                fail(""No conference requested by Telecom"");
            }
        } catch (InterruptedException e) {
            Log.i(TAG, ""Test interrupted!"");
        }
        return new Pair<>(connectionService.conferences.get(0),
                connectionService.connectionRequest);
    }

    void setAndVerifyConferenceForOutgoingCall(MockConference conference) {
        conference.setActive();
        assertConferenceState(conference, Connection.STATE_ACTIVE);
    }

    void verifyCallStateListener(int expectedCallState) throws InterruptedException {
        mTestCallStateListener.getCountDownLatch().await(
                TestUtils.WAIT_FOR_PHONE_STATE_LISTENER_CALLBACK_TIMEOUT_S, TimeUnit.SECONDS);
        assertEquals(expectedCallState, mTestCallStateListener.getLastState());
    }

    void verifyPhoneStateListenerCallbacksForCall(int expectedCallState, String expectedNumber)
            throws Exception {
        assertTrue(mTelephonyCallback.mCallbackSemaphore.tryAcquire(
                TestUtils.WAIT_FOR_PHONE_STATE_LISTENER_CALLBACK_TIMEOUT_S, TimeUnit.SECONDS));
        // At this point we can only be sure that we got AN update, but not necessarily the one we
        // are looking for; wait until we see the state we want before verifying further.
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                                              @Override
                                              public Object expected() {
                                                  return true;
                                              }

                                              @Override
                                              public Object actual() {
                                                  return mTelephonyCallback.mCallStates
                                                          .stream()
                                                          .filter(p -> p == expectedCallState)
                                                          .count() > 0;
                                              }
                                          },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected call state "" + expectedCallState + "" and number ""
                        + expectedNumber);


        // Get the most recent callback; it is possible that there was an initial state reported due
        // to the fact that TelephonyManager will sometimes give an initial state back to the caller
        // when the listener is registered.
        int callState = mTelephonyCallback.mCallStates.get(
                mTelephonyCallback.mCallStates.size() - 1);
        assertEquals(expectedCallState, callState);
        // Note: We do NOT check the phone number here.  Due to changes in how the phone state
        // broadcast is sent, the caller may receive multiple broadcasts, and the number will be
        // present in one or the other.  We waited for a full matching broadcast above so we can
        // be sure the number was reported as expected.
    }

    void verifyPhoneStateListenerCallbacksForEmergencyCall(String expectedNumber)
        throws Exception {
        assertTrue(mTelephonyCallback.mCallbackSemaphore.tryAcquire(
            TestUtils.WAIT_FOR_PHONE_STATE_LISTENER_CALLBACK_TIMEOUT_S, TimeUnit.SECONDS));
        // At this point we can only be sure that we got AN update, but not necessarily the one we
        // are looking for; wait until we see the state we want before verifying further.
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                                              @Override
                                              public Object expected() {
                                                  return true;
                                              }

                                              @Override
                                              public Object actual() {
                                                  return mTelephonyCallback
                                                      .mLastOutgoingEmergencyNumber != null
                                                      && mTelephonyCallback
                                                      .mLastOutgoingEmergencyNumber.getNumber()
                                                      .equals(expectedNumber);
                                              }
                                          },
            WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
            ""Expected emergency number: "" + expectedNumber);

        assertEquals(mTelephonyCallback.mLastOutgoingEmergencyNumber.getNumber(),
            expectedNumber);
    }

    /**
     * Disconnect the created test call and verify that Telecom has cleared all calls.
     */
    void cleanupCalls() {
        if (mInCallCallbacks != null && mInCallCallbacks.getService() != null) {
            mInCallCallbacks.getService().disconnectAllConferenceCalls();
            mInCallCallbacks.getService().disconnectAllCalls();
            assertNumConferenceCalls(mInCallCallbacks.getService(), 0);
            assertNumCalls(mInCallCallbacks.getService(), 0);
        }
    }

    /**
     * Place a new outgoing call via the {@link CtsConnectionService}
     */
    private void placeNewCallWithPhoneAccount(Bundle extras, int videoState) {
        if (extras == null) {
            extras = new Bundle();
        }
        if (!extras.containsKey(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE)) {
            extras.putParcelable(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE,
                    TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
        }

        if (!VideoProfile.isAudioOnly(videoState)) {
            extras.putInt(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE, videoState);
        }
        Uri number;
        if (extras.containsKey(TestUtils.EXTRA_PHONE_NUMBER)) {
            number = extras.getParcelable(TestUtils.EXTRA_PHONE_NUMBER);
        } else {
            number = createTestNumber();
        }
        mTelecomManager.placeCall(number, extras);
    }

    /**
     * Create a new number each time for a new test. Telecom has special logic to reuse certain
     * calls if multiple calls to the same number are placed within a short period of time which
     * can cause certain tests to fail.
     */
    Uri createTestNumber() {
        return Uri.fromParts(""tel"", String.valueOf(++sCounter), null);
    }

    /**
     * Creates a new random phone number in the range:
     * 000-000-0000
     * to
     * 999-999-9999
     * @return Randomized phone number.
     */
    Uri createRandomTestNumber() {
        return Uri.fromParts(""tel"", String.format(""16%05d"", new Random().nextInt(99999))
                + String.format(""%04d"", new Random().nextInt(9999)), null);
    }

    public static Uri getTestNumber() {
        return Uri.fromParts(""tel"", String.valueOf(sCounter), null);
    }

    public boolean isLoggedCall(PhoneAccountHandle handle) {
        PhoneAccount phoneAccount = mTelecomManager.getPhoneAccount(handle);
        Bundle extras = phoneAccount.getExtras();
        if (extras == null) {
            extras = new Bundle();
        }
        boolean isSelfManaged = (phoneAccount.getCapabilities()
                & PhoneAccount.CAPABILITY_SELF_MANAGED) == PhoneAccount.CAPABILITY_SELF_MANAGED;
        // Calls are logged if:
        // 1. They're not self-managed
        // 2. They're self-managed and are configured to request logging.
        return (!isSelfManaged
                || (isSelfManaged
                && extras.getBoolean(PhoneAccount.EXTRA_LOG_SELF_MANAGED_CALLS)
                && (phoneAccount.getSupportedUriSchemes().contains(PhoneAccount.SCHEME_TEL)
                || phoneAccount.getSupportedUriSchemes().contains(PhoneAccount.SCHEME_SIP))));
    }

    public CountDownLatch getCallLogEntryLatch() {
        CountDownLatch changeLatch = new CountDownLatch(1);
        mContext.getContentResolver().registerContentObserver(
                CallLog.Calls.CONTENT_URI, true,
                new ContentObserver(mHandler) {
                    @Override
                    public void onChange(boolean selfChange, Uri uri) {
                        mContext.getContentResolver().unregisterContentObserver(this);
                        changeLatch.countDown();
                        super.onChange(selfChange);
                    }
                });
        return changeLatch;
    }


    public void verifyCallLogging(CountDownLatch logLatch, boolean isCallLogged, Uri testNumber) {
        Cursor logCursor = getLatestCallLogCursorIfMatchesUri(logLatch, isCallLogged, testNumber);
        if (isCallLogged) {
            assertNotNull(""Call log entry not found for test number"", logCursor);
        }
    }

    public void verifyCallLogging(Uri testNumber, int expectedLogType) {
        CountDownLatch logLatch = getCallLogEntryLatch();
        Cursor logCursor = getLatestCallLogCursorIfMatchesUri(logLatch, true /*isCallLogged*/,
                testNumber);
        assertNotNull(""Call log entry not found for test number"", logCursor);
        int typeIndex = logCursor.getColumnIndex(CallLog.Calls.TYPE);
        int type = logCursor.getInt(typeIndex);
        assertEquals(""recorded type does not match expected"", expectedLogType, type);
    }

    public Cursor getLatestCallLogCursorIfMatchesUri(CountDownLatch latch, boolean newLogExpected,
            Uri testNumber) {
        if (newLogExpected) {
            // Wait for the content observer to report that we have gotten a new call log entry.
            try {
                latch.await(WAIT_FOR_STATE_CHANGE_TIMEOUT_MS, TimeUnit.MILLISECONDS);
            } catch (InterruptedException ie) {
                fail(""Expected log latch"");
            }
        }

        // Query the latest entry into the call log.
        Cursor callsCursor = mContext.getContentResolver().query(CallLog.Calls.CONTENT_URI, null,
                null, null, CallLog.Calls._ID + "" DESC limit 1;"");
        int numberIndex = callsCursor.getColumnIndex(CallLog.Calls.NUMBER);
        if (callsCursor.moveToNext()) {
            String number = callsCursor.getString(numberIndex);
            if (testNumber.getSchemeSpecificPart().equals(number)) {
                return callsCursor;
            } else {
                // Last call log entry doesnt match expected number.
                return null;
            }
        }
        // No Calls
        return null;
    }

    void assertNumCalls(final MockInCallService inCallService, final int numCalls) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
            @Override
            public Object expected() {
                return numCalls;
            }
            @Override
            public Object actual() {
                return inCallService.getCallCount();
            }
        },
        WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
        ""InCallService should contain "" + numCalls + "" calls.""
    );
    }

    void assertNumConferenceCalls(final MockInCallService inCallService, final int numCalls) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
            @Override
            public Object expected() {
                return numCalls;
            }
            @Override
            public Object actual() {
                return inCallService.getConferenceCallCount();
            }
        },
        WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
        ""InCallService should contain "" + numCalls + "" conference calls.""
    );
    }

    void assertCSConnections(final int numConnections) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                                              @Override
                                              public Object expected() {
                                                  return numConnections;
                                              }

                                              @Override
                                              public Object actual() {
                                                  return CtsConnectionService
                                                          .getAllConnectionsFromTelecom()
                                                          .size();
                                              }
                                          },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""ConnectionService should contain "" + numConnections + "" connections.""
        );
    }

    void assertNumConnections(final MockConnectionService connService, final int numConnections) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                                              @Override
                                              public Object expected() {
                                                  return numConnections;
                                              }
                                              @Override
                                              public Object actual() {
                                                  return connService.getAllConnections().size();
                                              }
                                          },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""ConnectionService should contain "" + numConnections + "" connections.""
        );
    }

    void assertMuteState(final InCallService incallService, final boolean isMuted) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isMuted;
                    }

                    @Override
                    public Object actual() {
                        final CallAudioState state = incallService.getCallAudioState();
                        return state == null ? null : state.isMuted();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Phone's mute state should be: "" + isMuted
        );
    }

    void assertMuteState(final MockConnection connection, final boolean isMuted) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isMuted;
                    }

                    @Override
                    public Object actual() {
                        final CallAudioState state = connection.getCallAudioState();
                        return state == null ? null : state.isMuted();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Connection's mute state should be: "" + isMuted
        );
    }

    void assertAudioRoute(final InCallService incallService, final int route) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return route;
                    }

                    @Override
                    public Object actual() {
                        final CallAudioState state = incallService.getCallAudioState();
                        return state == null ? null : state.getRoute();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Phone's audio route should be: "" + route
        );
    }

    void assertNotAudioRoute(final InCallService incallService, final int route) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return new Boolean(true);
                    }

                    @Override
                    public Object actual() {
                        final CallAudioState state = incallService.getCallAudioState();
                        return route != state.getRoute();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Phone's audio route should not be: "" + route
        );
    }

    void assertAudioRoute(final MockConnection connection, final int route) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return route;
                    }

                    @Override
                    public Object actual() {
                        final CallAudioState state = ((Connection) connection).getCallAudioState();
                        return state == null ? null : state.getRoute();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Connection's audio route should be: "" + route
        );
    }

    void assertConnectionState(final Connection connection, final int state) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return state;
                    }

                    @Override
                    public Object actual() {
                        return connection.getState();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Connection should be in state "" + state
        );
    }

    void assertCallState(final Call call, final int state) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return call.getState() == state && call.getDetails().getState() == state;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected state: "" + state + "", callState="" + call.getState() + "", detailState=""
                    + call.getDetails().getState()
        );
    }

    void assertCallConferenceableList(final Call call, final List<Call> conferenceableList) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return conferenceableList;
                    }

                    @Override
                    public Object actual() {
                        return call.getConferenceableCalls();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call: "" + call + "" does not have the correct conferenceable call list.""
        );
    }

    void assertDtmfString(final MockConnection connection, final String dtmfString) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                @Override
                public Object expected() {
                    return dtmfString;
                }

                @Override
                public Object actual() {
                    return connection.getDtmfString();
                }
            },
            WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
            ""DTMF string should be equivalent to entered DTMF characters: "" + dtmfString
        );
    }

    void assertDtmfString(final MockConference conference, final String dtmfString) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
                @Override
                public Object expected() {
                    return dtmfString;
                }

                @Override
                public Object actual() {
                    return conference.getDtmfString();
                }
            },
            WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
            ""DTMF string should be equivalent to entered DTMF characters: "" + dtmfString
        );
    }

    void assertCallDisplayName(final Call call, final String name) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return name;
                    }

                    @Override
                    public Object actual() {
                        return call.getDetails().getCallerDisplayName();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should have display name: "" + name
        );
    }

    void assertCallHandle(final Call call, final Uri expectedHandle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return expectedHandle;
                    }

                    @Override
                    public Object actual() {
                        return call.getDetails().getHandle();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should have handle name: "" + expectedHandle
        );
    }

    void assertCallConnectTimeChanged(final Call call, final long time) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return call.getDetails().getConnectTimeMillis() != time;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call have connect time: "" + time
        );
    }

    void assertConnectionCallDisplayName(final Connection connection, final String name) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return name;
                    }

                    @Override
                    public Object actual() {
                        return connection.getCallerDisplayName();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Connection should have display name: "" + name
        );
    }

    void assertDisconnectReason(final Connection connection, final String disconnectReason) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return disconnectReason;
                    }

                    @Override
                    public Object actual() {
                        return connection.getDisconnectCause().getReason();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Connection should have been disconnected with reason: "" + disconnectReason
        );
    }

    void assertConferenceState(final Conference conference, final int state) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return state;
                    }

                    @Override
                    public Object actual() {
                        return conference.getState();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Conference should be in state "" + state
        );
    }


    void assertOutgoingCallBroadcastReceived(boolean received) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return received;
                    }

                    @Override
                    public Object actual() {
                        return NewOutgoingCallBroadcastReceiver
                                .isNewOutgoingCallBroadcastReceived();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                received ? ""Outgoing Call Broadcast should be received""
                        : ""Outgoing Call Broadcast should not be received""
        );
    }

    void assertCallDetailsConstructed(Call mCall, boolean constructed) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return constructed;
                    }

                    @Override
                    public Object actual() {
                        return mCall != null && mCall.getDetails() != null;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                constructed ? ""Call Details should be constructed""
                        : ""Call Details should not be constructed""
        );
    }

    void assertCallGatewayConstructed(Call mCall, boolean constructed) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return constructed;
                    }

                    @Override
                    public Object actual() {
                        return mCall != null && mCall.getDetails() != null
                                && mCall.getDetails().getGatewayInfo() != null;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                constructed ? ""Call Gateway should be constructed""
                        : ""Call Gateway should not be constructed""
        );
    }

    void assertCallNotNull(Call mCall, boolean notNull) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return notNull;
                    }

                    @Override
                    public Object actual() {
                        return mCall != null;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                notNull ? ""Call should not be null"" : ""Call should be null""
        );
    }

    /**
     * Checks all fields of two PhoneAccounts for equality, with the exception of the enabled state.
     * Should only be called after assertPhoneAccountRegistered when it can be guaranteed
     * that the PhoneAccount is registered.
     * @param expected The expected PhoneAccount.
     * @param actual The actual PhoneAccount.
     */
    void assertPhoneAccountEquals(final PhoneAccount expected,
            final PhoneAccount actual) {
        assertEquals(expected.getAddress(), actual.getAddress());
        assertEquals(expected.getAccountHandle(), actual.getAccountHandle());
        assertEquals(expected.getCapabilities(), actual.getCapabilities());
        assertTrue(areBundlesEqual(expected.getExtras(), actual.getExtras()));
        assertEquals(expected.getHighlightColor(), actual.getHighlightColor());
        assertEquals(expected.getIcon(), actual.getIcon());
        assertEquals(expected.getLabel(), actual.getLabel());
        assertEquals(expected.getShortDescription(), actual.getShortDescription());
        assertEquals(expected.getSubscriptionAddress(), actual.getSubscriptionAddress());
        assertEquals(expected.getSupportedUriSchemes(), actual.getSupportedUriSchemes());
    }

    void assertPhoneAccountRegistered(final PhoneAccountHandle handle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return mTelecomManager.getPhoneAccount(handle) != null;
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Phone account registration failed for "" + handle
        );
    }

    void assertPhoneAccountEnabled(final PhoneAccountHandle handle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        PhoneAccount phoneAccount = mTelecomManager.getPhoneAccount(handle);
                        return (phoneAccount != null && phoneAccount.isEnabled());
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Phone account enable failed for "" + handle
        );
    }

    void assertPhoneAccountIsDefault(final PhoneAccountHandle handle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        PhoneAccountHandle phoneAccountHandle =
                                mTelecomManager.getUserSelectedOutgoingPhoneAccount();
                        return (phoneAccountHandle != null && phoneAccountHandle.equals(handle));
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Failed to set default phone account to "" + handle
        );
    }

    void assertCtsConnectionServiceUnbound() {
        if (CtsConnectionService.isBound()) {
            assertTrue(""CtsConnectionService not yet unbound!"",
                    CtsConnectionService.waitForUnBinding());
        }
    }

    void assertMockInCallServiceUnbound() {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return false;
                    }

                    @Override
                    public Object actual() {
                        return MockInCallService.isServiceBound();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""MockInCallService not yet unbound!""
        );
    }

    void assertIsOutgoingCallPermitted(boolean isPermitted, PhoneAccountHandle handle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isPermitted;
                    }

                    @Override
                    public Object actual() {
                        return mTelecomManager.isOutgoingCallPermitted(handle);
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected isOutgoingCallPermitted to be "" + isPermitted
        );
    }

    void assertIsIncomingCallPermitted(boolean isPermitted, PhoneAccountHandle handle) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isPermitted;
                    }

                    @Override
                    public Object actual() {
                        return mTelecomManager.isIncomingCallPermitted(handle);
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected isIncomingCallPermitted to be "" + isPermitted
        );
    }

    void assertIsInCall(boolean isIncall) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isIncall;
                    }

                    @Override
                    public Object actual() {
                        return mTelecomManager.isInCall();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected isInCall to be "" + isIncall
        );
    }

    void assertIsInManagedCall(boolean isIncall) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return isIncall;
                    }

                    @Override
                    public Object actual() {
                        return mTelecomManager.isInManagedCall();
                    }
                },
                WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected isInManagedCall to be "" + isIncall
        );
    }

    /**
     * Asserts that a call's properties are as expected.
     *
     * @param call The call.
     * @param properties The expected properties.
     */
    public void assertCallProperties(final Call call, final int properties) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return call.getDetails().hasProperty(properties);
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should have properties "" + properties
        );
    }

    /**
     * Asserts that a call does not have any of the specified call capability bits specified.
     *
     * @param call The call.
     * @param capabilities The capability or capabilities which are not expected.
     */
    public void assertDoesNotHaveCallCapabilities(final Call call, final int capabilities) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        int callCapabilities = call.getDetails().getCallCapabilities();
                        return !Call.Details.hasProperty(callCapabilities, capabilities);
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should not have capabilities "" + capabilities
        );
    }

    /**
     * Asserts that a call does not have any of the specified call property bits specified.
     *
     * @param call The call.
     * @param properties The property or properties which are not expected.
     */
    public void assertDoesNotHaveCallProperties(final Call call, final int properties) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return !call.getDetails().hasProperty(properties);
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should not have properties "" + properties
        );
    }

    /**
     * Asserts that the audio manager reports the specified audio mode.
     *
     * @param audioManager The audio manager to check.
     * @param expectedMode The expected audio mode.
     */
    public void assertAudioMode(final AudioManager audioManager, final int expectedMode) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return audioManager.getMode() == expectedMode;
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Audio mode was expected to be "" + expectedMode
        );
    }

    /**
     * Asserts that a call's capabilities are as expected.
     *
     * @param call The call.
     * @param capabilities The expected capabiltiies.
     */
    public void assertCallCapabilities(final Call call, final int capabilities) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return true;
                    }

                    @Override
                    public Object actual() {
                        return (call.getDetails().getCallCapabilities() & capabilities) ==
                                capabilities;
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Call should have properties "" + capabilities
        );
    }

    MockInCallService getInCallService() {
        return (mInCallCallbacks == null) ? null : mInCallCallbacks.getService();
    }

    /**
     * Asserts that the {@link UiModeManager} mode matches the specified mode.
     *
     * @param uiMode The expected ui mode.
     */
    public void assertUiMode(final int uiMode) {
        waitUntilConditionIsTrueOrTimeout(
                new Condition() {
                    @Override
                    public Object expected() {
                        return uiMode;
                    }

                    @Override
                    public Object actual() {
                        return mUiModeManager.getCurrentModeType();
                    }
                },
                TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                ""Expected ui mode "" + uiMode
        );
    }

    void waitUntilConditionIsTrueOrTimeout(Condition condition, long timeout,
            String description) {
        final long start = System.currentTimeMillis();
        while (!Objects.equals(condition.expected(), condition.actual())
                && System.currentTimeMillis() - start < timeout) {
            sleep(50);
        }
        assertEquals(description, condition.expected(), condition.actual());
    }

    /**
     * Performs some work, and waits for the condition to be met.  If the condition is not met in
     * each step of the loop, the work is performed again.
     *
     * @param work The work to perform.
     * @param condition The condition.
     * @param timeout The timeout.
     * @param description Description of the work being performed.
     */
    void doWorkAndWaitUntilConditionIsTrueOrTimeout(Work work, Condition condition, long timeout,
            String description) {
        final long start = System.currentTimeMillis();
        work.doWork();
        while (!condition.expected().equals(condition.actual())
                && System.currentTimeMillis() - start < timeout) {
            sleep(50);
            work.doWork();
        }
        assertEquals(description, condition.expected(), condition.actual());
    }

    protected interface Condition {
        Object expected();
        Object actual();
    }

    protected interface Work {
        void doWork();
    }

    public static boolean areBundlesEqual(Bundle extras, Bundle newExtras) {
        if (extras == null || newExtras == null) {
            return extras == newExtras;
        }

        if (extras.size() != newExtras.size()) {
            return false;
        }

        for (String key : extras.keySet()) {
            if (key != null) {
                final Object value = extras.get(key);
                final Object newValue = newExtras.get(key);
                if (!Objects.equals(value, newValue)) {
                    return false;
                }
            }
        }
        return true;
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.offhost.UiccTransactionEvent2EmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/offhost/UiccTransactionEvent2EmulatorActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.nfc.offhost;

import android.annotation.TargetApi;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.nfc.NfcAdapter;
import android.nfc.cardemulation.CardEmulation;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import com.android.cts.verifier.nfc.hce.HceUtils;

public class UiccTransactionEvent2EmulatorActivity extends PassFailButtons.Activity {
    static final String TAG = ""UiccTransactionEvent2EmulatorActivity"";

    TextView mTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.R) {
            getPassButton().setEnabled(false);
        } else {
            getPassButton().setEnabled(true);
        }

        mTextView = (TextView) findViewById(R.id.text);
        mTextView.setTextSize(12.0f);
        mTextView.setText(R.string.nfc_offhost_uicc_transaction_event_emulator_help);

        initProcess();
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);

        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mTextView = (TextView) findViewById(R.id.text);
        mTextView.setTextSize(12.0f);

        setIntent(intent);
        initProcess();
    }

    @Override
    protected void onPause() {
        super.onPause();
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleOffhostReaderActivity.class);
        readerIntent.putExtra(SimpleOffhostReaderActivity.EXTRA_APDUS,
                UiccTransactionEvent2Service.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleOffhostReaderActivity.EXTRA_RESPONSES,
                UiccTransactionEvent2Service.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleOffhostReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_offhost_uicc_transaction_event2_reader));
        readerIntent.putExtra(SimpleOffhostReaderActivity.EXTRA_DESELECT, true);
        return readerIntent;
    }

    private void initProcess() {
        Bundle bundle = getIntent().getExtras();
        if(bundle != null){
            byte[] transactionData = bundle.getByteArray(NfcAdapter.EXTRA_DATA);
            if(transactionData != null){
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(""Pass - NFC Action:"" + getIntent().getAction() + "" uri:"" + getIntent().getDataString()
                            + "" data:"" + HceUtils.getHexBytes(null, transactionData));
                        getPassButton().setEnabled(true);
                    }
                });
            } else {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mTextView.setText(""Fail - Action:"" + getIntent().getAction() + "" uri:"" + getIntent().getDataString()
                            + "" data: null"");
                        getPassButton().setEnabled(false);
                    }
                });
            }
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.CommandApdu"	"isReachable"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/CommandApdu.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.os.Parcel;
import android.os.Parcelable;

public class CommandApdu implements Parcelable {
    private String mApdu;
    private boolean mReachable;

    public CommandApdu(String apdu, boolean reachable) {
        mApdu = apdu;
        mReachable = reachable;
    }

    public boolean isReachable() {
        return mReachable;
    }

    public String getApdu() {
        return mApdu;
    }

    @Override
    public int describeContents() {
        return 0;
    }

    public static final Parcelable.Creator<CommandApdu> CREATOR =
            new Parcelable.Creator<CommandApdu>() {
        @Override
        public CommandApdu createFromParcel(Parcel source) {
            String apdu = source.readString();
            boolean reachable = source.readInt() != 0 ? true : false;
            return new CommandApdu(apdu, reachable);
        }

        @Override
        public CommandApdu[] newArray(int size) {
            return new CommandApdu[size];
        }
    };

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(mApdu);
        dest.writeInt(mReachable ? 1 : 0);
    }

}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2019_2013"	"testPocCVE_2019_2013"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2019_2013.java"	""	"@AsbSecurityTest(cveBugId = 120497583)
    public void testPocCVE_2019_2013() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2019-2013"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2018_9585"	"testPocCVE_2018_9585"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2018_9585.java"	""	"@AsbSecurityTest(cveBugId = 117554809)
    public void testPocCVE_2018_9585() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2018-9585"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2020_0039"	"testPocCVE_2020_0039"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2020_0039.java"	""	"@AsbSecurityTest(cveBugId = 143155861)
    public void testPocCVE_2020_0039() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2020-0039"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.nfc.hce.SingleNonPaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/SingleNonPaymentEmulatorActivity.java"	""	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class SingleNonPaymentEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setupServices(this, TransportService1.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this, null).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                TransportService1.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                TransportService1.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_single_non_payment_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(TransportService1.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.security.cts.CVE_2020_0038"	"testPocCVE_2020_0038"	"CtsSecurityBulletinHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2020_0038.java"	""	"@AsbSecurityTest(cveBugId = 143109193)
    public void testPocCVE_2020_0038() throws Exception {
        AdbUtils.assumeHasNfc(getDevice());
        pocPusher.only64();
        AdbUtils.runPocAssertNoCrashesNotVulnerable(""CVE-2020-0038"", null, getDevice());
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
"3.9.1"	"3.9.1"	"C-1-8"	"3.9.1/C-1-8"	"03090100.670108"	"""C-1-8] MUST send the ACTION_GET_PROVISIONING_MODE intent after device owner provisioning is triggered so that the DPC app can choose whether to become a Device Owner or a Profile Owner unless it can be determined from context that there is only one valid option (such as for NFC based provisioning where Profile Owner provisioning is not supported). | C-1-8] MUST send ACTION_MANAGED_PROFILE_PROVISIONED broadcast to the personal profile DPC when a Profile Owner is established, regardless of the provisioning method used. <h4 id=""392_managed_profile_support"" """	""	""	"NFC ACTION_MANAGED_PROFILE_PROVISIONED DPC ACTION_GET_PROVISIONING_MODE"	""	""	""	""	""	""	""	""	"android.signature.cts.InterfaceChecker"	"getMethods"	""	"/home/gpoor/cts-12-source/cts/tests/signature/lib/common/src/android/signature/cts/InterfaceChecker.java"	""	"Api methods will by definition contain
        // methods that do not appear in current.txt but do appear at runtime. That means that those
        // interfaces will fail compatibility checking because a developer could never implement all
        // the methods in the interface. However, some interfaces are not intended to be implemented
        // by a developer and so additional methods in the runtime class will not cause
        // compatibility errors. Unfortunately, this checker has no way to determine from the
        // interface whether an interface is intended to be implemented by a developer and for
        // safety's sake assumes that all interfaces are.
        //
        // Additional methods that are provided by the runtime but are not in the API specification
        // must be listed here to prevent them from being reported as errors.
        //
        // TODO(b/71886491): Avoid the need for this allow list.
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract boolean android.companion.DeviceFilter.matches(D)"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public static <D> boolean android.companion.DeviceFilter.matches(android.companion.DeviceFilter<D>,D)"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract java.lang.String android.companion.DeviceFilter.getDeviceDisplayName(D)"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract int android.companion.DeviceFilter.getMediumType()"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract void android.nfc.tech.TagTechnology.reconnect() throws java.io.IOException"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract void android.os.IBinder.shellCommand(java.io.FileDescriptor,java.io.FileDescriptor,java.io.FileDescriptor,java.lang.String[],android.os.ShellCallback,android.os.ResultReceiver) throws android.os.RemoteException"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract int android.text.ParcelableSpan.getSpanTypeIdInternal()"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract void android.text.ParcelableSpan.writeToParcelInternal(android.os.Parcel,int)"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract void android.view.WindowManager.requestAppKeyboardShortcuts(android.view.WindowManager$KeyboardShortcutsReceiver,int)"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract boolean javax.microedition.khronos.egl.EGL10.eglReleaseThread()"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract void org.w3c.dom.ls.LSSerializer.setFilter(org.w3c.dom.ls.LSSerializerFilter)"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract org.w3c.dom.ls.LSSerializerFilter org.w3c.dom.ls.LSSerializer.getFilter()"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract android.graphics.Region android.view.WindowManager.getCurrentImeTouchRegion()"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract java.util.Set<android.media.AudioMetadata$Key<?>> android.media.AudioMetadataReadMap.keySet()"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract android.view.InsetsState android.view.WindowInsetsController.getState()"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract boolean android.view.WindowInsetsController.isRequestedVisible(int)"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract void android.view.WindowInsetsController.setAnimationsDisabled(boolean)"");
        HIDDEN_INTERFACE_METHOD_ALLOW_LIST.add(""public abstract void android.view.inputmethod.InputMethod.hideSoftInputWithToken(int,android.os.ResultReceiver,android.os.IBinder)"");
    }

    private final ResultObserver resultObserver;

    private final Map<Class<?>, JDiffClassDescription> class2Description =
            new TreeMap<>(Comparator.comparing(Class::getName));

    private final ClassProvider classProvider;

    InterfaceChecker(ResultObserver resultObserver, ClassProvider classProvider) {
        this.resultObserver = resultObserver;
        this.classProvider = classProvider;
    }

    public void checkQueued() {
        for (Map.Entry<Class<?>, JDiffClassDescription> entry : class2Description.entrySet()) {
            Class<?> runtimeClass = entry.getKey();
            JDiffClassDescription classDescription = entry.getValue();
            List<Method> methods = checkInterfaceMethodCompliance(classDescription, runtimeClass);
            if (methods.size() > 0) {
                resultObserver.notifyFailure(FailureType.MISMATCH_INTERFACE_METHOD,
                        classDescription.getAbsoluteClassName(), ""Interfaces cannot be modified: ""
                                + classDescription.getAbsoluteClassName()
                                + "" has the following methods that are not present in the API specification:\n\t""
                                + methods.stream().map(Method::toGenericString).collect(Collectors.joining(""\n\t"")));
            }
        }
    }

    private static <T> Predicate<T> not(Predicate<T> predicate) {
        return predicate.negate();
    }

    /**
     * Validate that an interfaces method count is as expected.
     *
     * @param classDescription the class's API description.
     * @param runtimeClass the runtime class corresponding to {@code classDescription}.
     */
    private List<Method> checkInterfaceMethodCompliance(
            JDiffClassDescription classDescription, Class<?> runtimeClass) {

        return Stream.of(runtimeClass.getDeclaredMethods())
                .filter(not(Method::isDefault))
                .filter(not(Method::isSynthetic))
                .filter(not(Method::isBridge))
                .filter(m -> !Modifier.isStatic(m.getModifiers()))
                .filter(m -> !HIDDEN_INTERFACE_METHOD_ALLOW_LIST.contains(m.toGenericString()))
                .filter(m -> !findMethod(classDescription, m))
                .collect(Collectors.toCollection(ArrayList::new));
    }

    private boolean findMethod(JDiffClassDescription classDescription, Method method) {
        Map<Method, String> matchNameNotSignature = new LinkedHashMap<>();
        for (JDiffClassDescription.JDiffMethod jdiffMethod : classDescription.getMethods()) {
            if (ReflectionHelper.matchesSignature(jdiffMethod, method, matchNameNotSignature)) {
                return true;
            }
        }
        for (String interfaceName : classDescription.getImplInterfaces()) {
            Class<?> interfaceClass = null;
            try {
                interfaceClass = ReflectionHelper.findMatchingClass(interfaceName, classProvider);
            } catch (ClassNotFoundException e) {
                LogHelper.loge(""ClassNotFoundException for "" + classDescription.getAbsoluteClassName(), e);
            }

            JDiffClassDescription implInterface = class2Description.get(interfaceClass);
            if (implInterface == null) {
                // Class definition is not in the scope of the API definitions.
                continue;
            }

            if (findMethod(implInterface, method)) {
                return true;
            }
        }
        return false;
    }


    void queueForDeferredCheck(JDiffClassDescription classDescription, Class<?> runtimeClass) {

        JDiffClassDescription existingDescription = class2Description.get(runtimeClass);
        if (existingDescription != null) {
            for (JDiffClassDescription.JDiffMethod method : classDescription.getMethods()) {
                existingDescription.addMethod(method);
            }
        } else {
            class2Description.put(runtimeClass, classDescription);
        }
    }
}"	""	""	"NFC"	""	""	""	""	""	""	""	""	""	""
