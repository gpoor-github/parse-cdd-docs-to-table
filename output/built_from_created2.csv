Section,section_id,req_id,Test Availability,class_def,method,module,method_text,full_key,requirement,key_as_number,search_terms,qualified_method,manual_search_terms,matched_terms,file_name,matched_files,methods_string,urls
,7.1.1.1,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.1.1/H-1-1,,07010101.720101,7.1.1.1 H-1-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-1,,07010406.720101,H-1-1 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-2,,07010406.720102,H-1-2 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-3,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-3,,07010406.720103,H-1-3 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-3,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-4,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-4,,07010406.720104,H-1-4 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-4,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-1,,03081600.720101,3.8.16 H-1-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-2,,03081600.720102,3.8.16 H-1-2,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-3,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-3,,03081600.720103,3.8.16 H-1-3,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-3,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-4,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-4,,03081600.720104,3.8.16 H-1-4,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-4,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.2.3.5,C-2-6,,android.server.wm.SurfaceControlViewHostTests,testDisableInputTouch(),,"     public void testDisableInputTouch() throws Throwable {         mEmbeddedView = new Button(mActivity);         mEmbeddedView.setOnClickListener((View v) -> {             mClicked = true;         });          mEmbeddedLayoutParams = new WindowManager.LayoutParams(mEmbeddedViewWidth,             mEmbeddedViewHeight, WindowManager.LayoutParams.TYPE_APPLICATION, 0,             PixelFormat.OPAQUE);          addSurfaceView(DEFAULT_SURFACE_VIEW_WIDTH, DEFAULT_SURFACE_VIEW_HEIGHT);         mInstrumentation.waitForIdleSync();          mActivityRule.runOnUiThread(() -> {                 mEmbeddedLayoutParams.flags |= FLAG_NOT_TOUCHABLE;                 mVr.relayout(mEmbeddedLayoutParams);         });         mInstrumentation.waitForIdleSync();          CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mSurfaceView);         assertFalse(mClicked);          mActivityRule.runOnUiThread(() -> {                 mEmbeddedLayoutParams.flags &= ~FLAG_NOT_TOUCHABLE;                 mVr.relayout(mEmbeddedLayoutParams);         });         mInstrumentation.waitForIdleSync();          CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mSurfaceView);         assertTrue(mClicked);     } } ",3.2.3.5/C-2-6,,03020305.670206,VIEW android.intent.action.SENDTO 3.2.3.5 android.intent.action.VIEW SMS ACTION_SENDTO SENDTO C-2-6,Test[None]:[android.server.wm.SurfaceControlViewHostTests:testDisableInputTouch()],,VIEW,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/SurfaceControlViewHostTests.java,,
,3.2.3.5,C-5-2,,android.app.notification.legacy.cts.ConditionProviderServiceTest,testUnboundCPSMaintainsCondition_otherProviderRuleChanges(),,"     public void testUnboundCPSMaintainsCondition_otherProviderRuleChanges() throws Exception {         // make sure both services get bound         pollForConnection(LegacyConditionProviderService.class, true);         pollForConnection(SecondaryConditionProviderService.class, true);          // add rules for both         mModeReceiver.reset();          addRule(LegacyConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, true);         pollForSubscribe(LegacyConditionProviderService.getInstance());          addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_ALARMS, true);         pollForSubscribe(SecondaryConditionProviderService.getInstance());          mModeReceiver.waitFor(2/*Legacy and Secondary*/, 1000/*Limit is 1 second*/);         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // unbind one of the services         SecondaryConditionProviderService.getInstance().requestUnbind();          // verify that DND state doesn't change         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // trigger a change in the bound service's rule         addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, false);          // verify that the unbound service maintains it's DND vote         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());     }      ",3.2.3.5/C-5-2,,03020305.670502,REQUEST_DISCOVERABLE 3.2.3.5 DND C-5-2 ACTION_REQUEST_DISCOVERABLE android.bluetooth.adapter.action.REQUEST,Test[None]:[android.app.notification.legacy.cts.ConditionProviderServiceTest:testUnboundCPSMaintainsCondition_otherProviderRuleChanges()],,DND,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/notificationlegacy/notificationlegacy27/src/android/app/notification/legacy/cts/ConditionProviderServiceTest.java,,
,3.2.3.5,C-6-1,,android.app.notification.legacy.cts.ConditionProviderServiceTest,testUnboundCPSMaintainsCondition_otherProviderRuleChanges(),,"     public void testUnboundCPSMaintainsCondition_otherProviderRuleChanges() throws Exception {         // make sure both services get bound         pollForConnection(LegacyConditionProviderService.class, true);         pollForConnection(SecondaryConditionProviderService.class, true);          // add rules for both         mModeReceiver.reset();          addRule(LegacyConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, true);         pollForSubscribe(LegacyConditionProviderService.getInstance());          addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_ALARMS, true);         pollForSubscribe(SecondaryConditionProviderService.getInstance());          mModeReceiver.waitFor(2/*Legacy and Secondary*/, 1000/*Limit is 1 second*/);         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // unbind one of the services         SecondaryConditionProviderService.getInstance().requestUnbind();          // verify that DND state doesn't change         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // trigger a change in the bound service's rule         addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, false);          // verify that the unbound service maintains it's DND vote         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());     }      ",3.2.3.5/C-6-1,,03020305.670601,3.2.3.5 DND C-6-1 MODE_TYPE_NORMAL ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS,Test[None]:[android.app.notification.legacy.cts.ConditionProviderServiceTest:testUnboundCPSMaintainsCondition_otherProviderRuleChanges()],,DND,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/notificationlegacy/notificationlegacy27/src/android/app/notification/legacy/cts/ConditionProviderServiceTest.java,,
,3.2.3.5,C-8-1,,android.accessibilityservice.cts.AccessibilitySettingsTest,testAccessibilitySettingsIntentHandled(),CtsAccessibilityServiceTestCases,"     public void testAccessibilitySettingsIntentHandled() throws Throwable {         PackageManager packageManager = getContext().getPackageManager();         Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);         List<ResolveInfo> resolvedActivities = packageManager.queryIntentActivities(intent,                 PackageManager.MATCH_DEFAULT_ONLY);          // make sure accessibility settings exist         String message = ""Accessibility settings activity must be launched via Intent "" +                 ""Settings.ACTION_ACCESSIBILITY_SETTINGS"";         assertTrue(message, !resolvedActivities.isEmpty());     } }  ",3.2.3.5/C-8-1,,03020305.670801,C-8-1 3.2.3.5 ACCESSIBILITY_SETTINGS android.settings.ACCESSIBILITY ACTION_ACCESSIBILITY_SETTINGS,Test[CtsAccessibilityServiceTestCases]:[android.accessibilityservice.cts.AccessibilitySettingsTest:testAccessibilitySettingsIntentHandled()],,ACTION_ACCESSIBILITY_SETTINGS,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySettingsTest.java,,
,3.2.3.5,C-11-1,,android.view.cts.KeyCharacterMapTest,testIsPrintingKey(),,     public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }      ,3.2.3.5/C-11-1,,03020305.671101,ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SET 3.2.3.5 Settings.ACTION android.hardware.camera.any C-11-1 TINGS,Test[None]:[android.view.cts.KeyCharacterMapTest:testIsPrintingKey()],,TINGS,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java,,
,3.2.3.5,C-13-2,,android.content.cts.ClipboardManagerTest,testPrimaryClipNotAvailableWithoutFocus(),,"     public void testPrimaryClipNotAvailableWithoutFocus() throws Exception {         ClipData textData = ClipData.newPlainText(""TextLabel"", ""Text1"");         assertSetPrimaryClip(textData, ""TextLabel"",                 new String[] {ClipDescription.MIMETYPE_TEXT_PLAIN},                 new ExpectedClipItem(""Text1"", null, null));          // Press the home button to unfocus the app.         mUiDevice.pressHome();         mUiDevice.wait(Until.gone(By.clazz(MockActivity.class)), 5000);          // We should see an empty clipboard now.         assertFalse(mClipboardManager.hasPrimaryClip());         assertFalse(mClipboardManager.hasText());         assertNull(mClipboardManager.getPrimaryClip());         assertNull(mClipboardManager.getPrimaryClipDescription());          // We should be able to set the clipboard but not see the contents.         mClipboardManager.setPrimaryClip(ClipData.newPlainText(""TextLabel"", ""Text2""));         assertFalse(mClipboardManager.hasPrimaryClip());         assertFalse(mClipboardManager.hasText());         assertNull(mClipboardManager.getPrimaryClip());         assertNull(mClipboardManager.getPrimaryClipDescription());          // Launch an activity to get back in focus.         launchActivity(MockActivity.class);           // Verify clipboard access is restored.         assertNotNull(mClipboardManager.getPrimaryClip());         assertNotNull(mClipboardManager.getPrimaryClipDescription());          // Verify we were unable to change the clipboard while out of focus.         assertClipData(mClipboardManager.getPrimaryClip(),                 ""TextLabel"",                 new String[] {ClipDescription.MIMETYPE_TEXT_PLAIN},                 new ExpectedClipItem(""Text2"", null, null));     }      private void launchActivity(Class<? extends Activity> clazz) {         Intent intent = new Intent(Intent.ACTION_MAIN);         intent.setClassName(mContext.getPackageName(), clazz.getName());         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         mContext.startActivity(intent);         mUiDevice.wait(Until.hasObject(By.clazz(clazz)), 5000);     }      private class ExpectedClipItem {         CharSequence mText;         Intent mIntent;         Uri mUri;          ExpectedClipItem(CharSequence text, Intent intent, Uri uri) {             mText = text;             mIntent = intent;             mUri = uri;         }     }      private void assertSetPrimaryClip(ClipData clipData,             String expectedLabel,             String[] expectedMimeTypes,             ExpectedClipItem... expectedClipItems) {         ClipboardManager clipboardManager = mClipboardManager;          clipboardManager.setPrimaryClip(clipData);         assertTrue(clipboardManager.hasPrimaryClip());          if (expectedClipItems != null                 && expectedClipItems.length > 0                 && expectedClipItems[0].mText != null) {             assertTrue(clipboardManager.hasText());         } else {             assertFalse(clipboardManager.hasText());         }          assertNotNull(clipboardManager.getPrimaryClip());         assertNotNull(clipboardManager.getPrimaryClipDescription());          assertClipData(clipboardManager.getPrimaryClip(),                 expectedLabel, expectedMimeTypes, expectedClipItems);          assertClipDescription(clipboardManager.getPrimaryClipDescription(),                 expectedLabel, expectedMimeTypes);     }      private static void assertClipData(ClipData actualData, String expectedLabel,             String[] expectedMimeTypes, ExpectedClipItem... expectedClipItems) {         if (expectedClipItems != null) {             assertEquals(expectedClipItems.length, actualData.getItemCount());             for (int i = 0; i < expectedClipItems.length; i++) {                 assertClipItem(expectedClipItems[i], actualData.getItemAt(i));             }         } else {             throw new IllegalArgumentException(""Should have at least one expectedClipItem..."");         }          assertClipDescription(actualData.getDescription(), expectedLabel, expectedMimeTypes);     }      private static void assertClipDescription(ClipDescription description, String expectedLabel,             String... mimeTypes) {         assertEquals(expectedLabel, description.getLabel());         assertEquals(mimeTypes.length, description.getMimeTypeCount());         int mimeTypeCount = description.getMimeTypeCount();         for (int i = 0; i < mimeTypeCount; i++) {             assertEquals(mimeTypes[i], description.getMimeType(i));         }     }      private static void assertClipItem(ExpectedClipItem expectedItem, Item item) {         assertEquals(expectedItem.mText, item.getText());         if (expectedItem.mIntent != null) {             assertNotNull(item.getIntent());         } else {             assertNull(item.getIntent());         }         if (expectedItem.mUri != null) {             assertEquals(expectedItem.mUri.toString(), item.getUri().toString());         } else {             assertNull(item.getUri());         }     }      private boolean hasAutoFillFeature() {         return mContext.getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_AUTOFILL);     } } ",3.2.3.5/C-13-2,,03020305.671302,android.app.action.SET android.app.action.PROVISION PackageManager.html android.app.action.PROVISIONING ACTION_ADMIN_POLICY_COMPLIANCE android.app.action.START ADMIN_POLICY_COMPLIANCE SET_NEW_PARENT_PROFILE_PASSWORD android.app.action.GET 3.2.3.5 PROVISIONING_SUCCESSFUL FEATURE_AUTOFILL GET_PROVISIONING_MODE C-13-2 PROVISION_MANAGED_DEVICE START_ENCRYPTION android.app.action.ADMIN ACTION_START_ENCRYPTION PROVISION_MANAGED_PROFILE SET_NEW_PASSWORD android.software.autofill,Test[None]:[android.content.cts.ClipboardManagerTest:testPrimaryClipNotAvailableWithoutFocus()],,FEATURE_AUTOFILL,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ClipboardManagerTest.java,,
,3.2.3.5,C-14-1,,android.autofillservice.cts.SettingsIntentTest,testWarningShown_userRejectsByTappingBack(),CtsAutoFillServiceTestCases,"     public void testWarningShown_userRejectsByTappingBack() throws Exception {         disableService();          // Launches Settings.         mActivity.startForResult(newSettingsIntent(), MY_REQUEST_CODE);          // Asserts services are shown.         final UiObject2 object = mUiBot                 .assertShownByText(InstrumentedAutoFillService.sServiceLabel);         object.click();          // TODO(b/79615759): should assert that ""autofill_confirmation_message"" is shown, but that         // string belongs to Settings - we need to move it to frameworks/base first (and/or use         // a resource id, also on framework).         // So, for now, just asserts the service name is showing again (in the popup), and the other         // services are not showing (because the popup hides then).          final UiObject2 msgObj = mUiBot.assertShownById(""android:id/message"");         final String msg = msgObj.getText();         assertWithMessage(""Wrong warning message"").that(msg)                 .contains(InstrumentedAutoFillService.sServiceLabel);          // NOTE: assertion below is fine because it looks for the full text, not a substring         mUiBot.assertNotShowingForSure(InstrumentedAutoFillService.sServiceLabel);         mUiBot.assertNotShowingForSure(InstrumentedAutoFillServiceCompatMode.sServiceLabel);         mUiBot.assertNotShowingForSure(NoOpAutofillService.SERVICE_LABEL);         mUiBot.assertNotShowingForSure(BadAutofillService.SERVICE_LABEL);          // Finishes and asserts result.         mUiBot.pressBack();         mActivity.assertResult(Activity.RESULT_CANCELED);     }      // TODO(b/79615759): add testWarningShown_userRejectsByTappingCancel() and     // testWarningShown_userAccepts() - these tests would require adding the strings and resource     // ids to frameworks/base      private Intent newSettingsIntent() {         return new Intent(Settings.ACTION_REQUEST_SET_AUTOFILL_SERVICE)                 .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)                 .setData(Uri.parse(""package:"" + Helper.MY_PACKAGE));     } } ",3.2.3.5/C-14-1,,03020305.671401,AutofillService.html android.settings.REQUEST C-14-1 AutofillManager.html Settings.html 3.2.3.5 REQUEST_SET_AUTOFILL_SERVICE ACTION_REQUEST_SET_AUTOFILL_SERVICE,Test[CtsAutoFillServiceTestCases]:[android.autofillservice.cts.SettingsIntentTest:testWarningShown_userRejectsByTappingBack()],,ACTION_REQUEST_SET_AUTOFILL_SERVICE,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/SettingsIntentTest.java,,
,3.2.3.5,C-15-1,,android.server.wm.DragDropTest,testNoDragIfNoTouchDown(),,"     public void testNoDragIfNoTouchDown() throws InterruptedException {         // perform a click.         injectMouse5(R.id.draggable, MotionEvent.ACTION_DOWN);         injectMouse5(R.id.draggable, MotionEvent.ACTION_UP);          runOnMain(() -> {             View v = mActivity.findViewById(R.id.draggable);             assertFalse(""Shouldn't start drag"",                 v.startDragAndDrop(sClipData, new View.DragShadowBuilder(v), sLocalState, 0));         });     }      public static class DragDropActivity extends FocusableActivity {         @Override         protected void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             setContentView(R.layout.drag_drop_layout);         }     } } ",3.2.3.5/C-15-1,,03020305.671501,USAGE C-15-1 android.hardware.audio.output ACTION_USAGE_ACCESS_SETTINGS Settings.html ACCESS ACTION 3.2.3.5 android.settings.ACTION SETTINGS,Test[None]:[android.server.wm.DragDropTest:testNoDragIfNoTouchDown()],,ACTION,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DragDropTest.java,,
,3.9.2,C-2-1,,android.server.wm.WindowInsetsPolicyTest,getSimpleName(),,"/*  *  */  package android.server.wm;  import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD; import static android.app.WindowConfiguration.WINDOWING_MODE_SPLIT_SCREEN_PRIMARY; import static android.app.WindowConfiguration.WINDOWING_MODE_SPLIT_SCREEN_SECONDARY; import static android.content.res.Configuration.ORIENTATION_PORTRAIT; import static android.server.wm.app.Components.LAUNCHING_ACTIVITY; import static android.view.Display.DEFAULT_DISPLAY; import static android.view.Surface.ROTATION_0; import static android.view.Surface.ROTATION_90; import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;  import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;  import static org.hamcrest.Matchers.notNullValue; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeFalse; import static org.junit.Assume.assumeTrue;  import android.app.Activity; import android.content.ComponentName; import android.content.pm.PackageManager; import android.graphics.Insets; import android.os.Bundle; import android.platform.test.annotations.Presubmit; import android.util.Log; import android.view.View; import android.view.ViewGroup; import android.view.Window; import android.view.WindowInsets; import android.view.WindowManager.LayoutParams;  import androidx.test.rule.ActivityTestRule;  import com.android.compatibility.common.util.PollingCheck;  import org.hamcrest.CustomTypeSafeMatcher; import org.hamcrest.Matcher; import org.junit.Assert; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ErrorCollector;  import java.util.function.Supplier;  @Presubmit public class WindowInsetsPolicyTest extends ActivityManagerTestBase {     private static final String TAG = WindowInsetsPolicyTest.class.getSimpleName();      private ComponentName mTestActivityComponentName;      @Rule     public final ErrorCollector mErrorCollector = new ErrorCollector();      @Rule     public final ActivityTestRule<TestActivity> mTestActivity =             new ActivityTestRule<>(TestActivity.class, false /* initialTouchMode */,                     false /* launchActivity */);      @Rule     public final ActivityTestRule<FullscreenTestActivity> mFullscreenTestActivity =             new ActivityTestRule<>(FullscreenTestActivity.class, false /* initialTouchMode */,                     false /* launchActivity */);      @Rule     public final ActivityTestRule<FullscreenWmFlagsTestActivity> mFullscreenWmFlagsTestActivity =             new ActivityTestRule<>(FullscreenWmFlagsTestActivity.class,                     false /* initialTouchMode */, false /* launchActivity */);      @Rule     public final ActivityTestRule<ImmersiveFullscreenTestActivity> mImmersiveTestActivity =             new ActivityTestRule<>(ImmersiveFullscreenTestActivity.class,                     false /* initialTouchMode */, false /* launchActivity */);      @Before     @Override     public void setUp() throws Exception {         super.setUp();         mTestActivityComponentName = new ComponentName(mContext, TestActivity.class);     }      ",3.9.2/C-2-1,,03090200.670201,admin.html DPC android.content.ComponentName ACTION_SET_NEW_PASSWORD 3.9.2 index.html DevicePolicyManager.ACTION DevicePolicyManager.html C-2-1,Test[None]:[android.server.wm.WindowInsetsPolicyTest:getSimpleName()],,android.content.ComponentName,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsPolicyTest.java,,
,6.1,C-0-11,,android.view.cts.VelocityTrackerTest,testUsesRawCoordinates(),,"     public void testUsesRawCoordinates() {         VelocityTracker vt = VelocityTracker.obtain();         final int numevents = 5;          final long downTime = SystemClock.uptimeMillis();         for (int i = 0; i < numevents; i++) {             final long eventTime = downTime + i * 10;             int action = i == 0 ? MotionEvent.ACTION_DOWN : MotionEvent.ACTION_MOVE;             MotionEvent event = MotionEvent.obtain(downTime, eventTime, action, 0, 0, 0);             event.offsetLocation(i * 10, i * 10);             vt.addMovement(event);         }         vt.computeCurrentVelocity(1000);         float xVelocity = vt.getXVelocity();         float yVelocity = vt.getYVelocity();         if (xVelocity == 0 || yVelocity == 0) {             fail(""VelocityTracker is using raw coordinates,""                     + "" but it should be using adjusted coordinates"");         }     }      private void move(long duration, long step) {         addMovement();         while (duration > 0) {             duration -= step;             mTime += step;             mPx += (mAx / 2 * step + mVx) * step;             mPy += (mAy / 2 * step + mVy) * step;             mVx += mAx * step;             mVy += mAy * step;             addMovement();         }     }      private void pause(long duration) {         mTime += duration;     }      private void addMovement() {         if (mTime > mLastTime) {             MotionEvent ev = MotionEvent.obtain(0L, mTime, MotionEvent.ACTION_MOVE, mPx, mPy, 0);             mVelocityTracker.addMovement(ev);             ev.recycle();             mLastTime = mTime;              mVelocityTracker.computeCurrentVelocity(1);             final float estimatedVx = mVelocityTracker.getXVelocity();             final float estimatedVy = mVelocityTracker.getYVelocity();             Log.d(TAG, String.format(                     ""[%d] x=%6.1f, y=%6.1f, vx=%6.1f, vy=%6.1f, ax=%6.1f, ay=%6.1f, ""                     + ""evx=%6.1f (%6.1f%%), evy=%6.1f (%6.1f%%)"",                     mTime, mPx, mPy, mVx, mVy, mAx, mAy,                     estimatedVx, error(mVx, estimatedVx) * 100.0f,                     estimatedVy, error(mVy, estimatedVy) * 100.0f));         }     }      private void assertVelocity(float tolerance, String message) {         mVelocityTracker.computeCurrentVelocity(1);         final float estimatedVx = mVelocityTracker.getXVelocity();         final float estimatedVy = mVelocityTracker.getYVelocity();         float errorVx = error(mVx, estimatedVx);         float errorVy = error(mVy, estimatedVy);         if (errorVx > tolerance || errorVy > tolerance) {             fail(String.format(""Velocity exceeds tolerance of %6.1f%%: ""                     + ""expected vx=%6.1f, vy=%6.1f. ""                     + ""actual vx=%6.1f (%6.1f%%), vy=%6.1f (%6.1f%%). %s"",                     tolerance * 100.0f, mVx, mVy,                     estimatedVx, errorVx * 100.0f, estimatedVy, errorVy * 100.0f, message));         }     }      private static float error(float expected, float actual) {         float absError = Math.abs(actual - expected);         if (absError < 0.001f) {             return 0;         }         if (Math.abs(expected) < 0.001f) {             return 1;         }         return absError / Math.abs(expected);     } } ",6.1/C-0-11,,06010000.670011,6.1 C-0-11,Test[None]:[android.view.cts.VelocityTrackerTest:testUsesRawCoordinates()],/home/gpoor/aosp_platform_source/cts/hostsidetests/adbmanager/src/android/adbmanager/cts/AdbManagerHostDeviceTest.java,6.1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/VelocityTrackerTest.java,,
,6.1,C-3-1,,android.view.cts.VelocityTrackerTest,testUsesRawCoordinates(),,"     public void testUsesRawCoordinates() {         VelocityTracker vt = VelocityTracker.obtain();         final int numevents = 5;          final long downTime = SystemClock.uptimeMillis();         for (int i = 0; i < numevents; i++) {             final long eventTime = downTime + i * 10;             int action = i == 0 ? MotionEvent.ACTION_DOWN : MotionEvent.ACTION_MOVE;             MotionEvent event = MotionEvent.obtain(downTime, eventTime, action, 0, 0, 0);             event.offsetLocation(i * 10, i * 10);             vt.addMovement(event);         }         vt.computeCurrentVelocity(1000);         float xVelocity = vt.getXVelocity();         float yVelocity = vt.getYVelocity();         if (xVelocity == 0 || yVelocity == 0) {             fail(""VelocityTracker is using raw coordinates,""                     + "" but it should be using adjusted coordinates"");         }     }      private void move(long duration, long step) {         addMovement();         while (duration > 0) {             duration -= step;             mTime += step;             mPx += (mAx / 2 * step + mVx) * step;             mPy += (mAy / 2 * step + mVy) * step;             mVx += mAx * step;             mVy += mAy * step;             addMovement();         }     }      private void pause(long duration) {         mTime += duration;     }      private void addMovement() {         if (mTime > mLastTime) {             MotionEvent ev = MotionEvent.obtain(0L, mTime, MotionEvent.ACTION_MOVE, mPx, mPy, 0);             mVelocityTracker.addMovement(ev);             ev.recycle();             mLastTime = mTime;              mVelocityTracker.computeCurrentVelocity(1);             final float estimatedVx = mVelocityTracker.getXVelocity();             final float estimatedVy = mVelocityTracker.getYVelocity();             Log.d(TAG, String.format(                     ""[%d] x=%6.1f, y=%6.1f, vx=%6.1f, vy=%6.1f, ax=%6.1f, ay=%6.1f, ""                     + ""evx=%6.1f (%6.1f%%), evy=%6.1f (%6.1f%%)"",                     mTime, mPx, mPy, mVx, mVy, mAx, mAy,                     estimatedVx, error(mVx, estimatedVx) * 100.0f,                     estimatedVy, error(mVy, estimatedVy) * 100.0f));         }     }      private void assertVelocity(float tolerance, String message) {         mVelocityTracker.computeCurrentVelocity(1);         final float estimatedVx = mVelocityTracker.getXVelocity();         final float estimatedVy = mVelocityTracker.getYVelocity();         float errorVx = error(mVx, estimatedVx);         float errorVy = error(mVy, estimatedVy);         if (errorVx > tolerance || errorVy > tolerance) {             fail(String.format(""Velocity exceeds tolerance of %6.1f%%: ""                     + ""expected vx=%6.1f, vy=%6.1f. ""                     + ""actual vx=%6.1f (%6.1f%%), vy=%6.1f (%6.1f%%). %s"",                     tolerance * 100.0f, mVx, mVy,                     estimatedVx, errorVx * 100.0f, estimatedVy, errorVy * 100.0f, message));         }     }      private static float error(float expected, float actual) {         float absError = Math.abs(actual - expected);         if (absError < 0.001f) {             return 0;         }         if (Math.abs(expected) < 0.001f) {             return 1;         }         return absError / Math.abs(expected);     } } ",6.1/C-3-1,,06010000.670301,6.1 C-3-1,Test[None]:[android.view.cts.VelocityTrackerTest:testUsesRawCoordinates()],,6.1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/VelocityTrackerTest.java,,
,6.1,C-3-2,,android.view.cts.VelocityTrackerTest,testUsesRawCoordinates(),,"     public void testUsesRawCoordinates() {         VelocityTracker vt = VelocityTracker.obtain();         final int numevents = 5;          final long downTime = SystemClock.uptimeMillis();         for (int i = 0; i < numevents; i++) {             final long eventTime = downTime + i * 10;             int action = i == 0 ? MotionEvent.ACTION_DOWN : MotionEvent.ACTION_MOVE;             MotionEvent event = MotionEvent.obtain(downTime, eventTime, action, 0, 0, 0);             event.offsetLocation(i * 10, i * 10);             vt.addMovement(event);         }         vt.computeCurrentVelocity(1000);         float xVelocity = vt.getXVelocity();         float yVelocity = vt.getYVelocity();         if (xVelocity == 0 || yVelocity == 0) {             fail(""VelocityTracker is using raw coordinates,""                     + "" but it should be using adjusted coordinates"");         }     }      private void move(long duration, long step) {         addMovement();         while (duration > 0) {             duration -= step;             mTime += step;             mPx += (mAx / 2 * step + mVx) * step;             mPy += (mAy / 2 * step + mVy) * step;             mVx += mAx * step;             mVy += mAy * step;             addMovement();         }     }      private void pause(long duration) {         mTime += duration;     }      private void addMovement() {         if (mTime > mLastTime) {             MotionEvent ev = MotionEvent.obtain(0L, mTime, MotionEvent.ACTION_MOVE, mPx, mPy, 0);             mVelocityTracker.addMovement(ev);             ev.recycle();             mLastTime = mTime;              mVelocityTracker.computeCurrentVelocity(1);             final float estimatedVx = mVelocityTracker.getXVelocity();             final float estimatedVy = mVelocityTracker.getYVelocity();             Log.d(TAG, String.format(                     ""[%d] x=%6.1f, y=%6.1f, vx=%6.1f, vy=%6.1f, ax=%6.1f, ay=%6.1f, ""                     + ""evx=%6.1f (%6.1f%%), evy=%6.1f (%6.1f%%)"",                     mTime, mPx, mPy, mVx, mVy, mAx, mAy,                     estimatedVx, error(mVx, estimatedVx) * 100.0f,                     estimatedVy, error(mVy, estimatedVy) * 100.0f));         }     }      private void assertVelocity(float tolerance, String message) {         mVelocityTracker.computeCurrentVelocity(1);         final float estimatedVx = mVelocityTracker.getXVelocity();         final float estimatedVy = mVelocityTracker.getYVelocity();         float errorVx = error(mVx, estimatedVx);         float errorVy = error(mVy, estimatedVy);         if (errorVx > tolerance || errorVy > tolerance) {             fail(String.format(""Velocity exceeds tolerance of %6.1f%%: ""                     + ""expected vx=%6.1f, vy=%6.1f. ""                     + ""actual vx=%6.1f (%6.1f%%), vy=%6.1f (%6.1f%%). %s"",                     tolerance * 100.0f, mVx, mVy,                     estimatedVx, errorVx * 100.0f, estimatedVy, errorVy * 100.0f, message));         }     }      private static float error(float expected, float actual) {         float absError = Math.abs(actual - expected);         if (absError < 0.001f) {             return 0;         }         if (Math.abs(expected) < 0.001f) {             return 1;         }         return absError / Math.abs(expected);     } } ",6.1/C-3-2,,06010000.670302,6.1 C-3-2,Test[None]:[android.view.cts.VelocityTrackerTest:testUsesRawCoordinates()],,6.1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/VelocityTrackerTest.java,,
,6.1,C-4-1,,android.view.cts.VelocityTrackerTest,testUsesRawCoordinates(),,"     public void testUsesRawCoordinates() {         VelocityTracker vt = VelocityTracker.obtain();         final int numevents = 5;          final long downTime = SystemClock.uptimeMillis();         for (int i = 0; i < numevents; i++) {             final long eventTime = downTime + i * 10;             int action = i == 0 ? MotionEvent.ACTION_DOWN : MotionEvent.ACTION_MOVE;             MotionEvent event = MotionEvent.obtain(downTime, eventTime, action, 0, 0, 0);             event.offsetLocation(i * 10, i * 10);             vt.addMovement(event);         }         vt.computeCurrentVelocity(1000);         float xVelocity = vt.getXVelocity();         float yVelocity = vt.getYVelocity();         if (xVelocity == 0 || yVelocity == 0) {             fail(""VelocityTracker is using raw coordinates,""                     + "" but it should be using adjusted coordinates"");         }     }      private void move(long duration, long step) {         addMovement();         while (duration > 0) {             duration -= step;             mTime += step;             mPx += (mAx / 2 * step + mVx) * step;             mPy += (mAy / 2 * step + mVy) * step;             mVx += mAx * step;             mVy += mAy * step;             addMovement();         }     }      private void pause(long duration) {         mTime += duration;     }      private void addMovement() {         if (mTime > mLastTime) {             MotionEvent ev = MotionEvent.obtain(0L, mTime, MotionEvent.ACTION_MOVE, mPx, mPy, 0);             mVelocityTracker.addMovement(ev);             ev.recycle();             mLastTime = mTime;              mVelocityTracker.computeCurrentVelocity(1);             final float estimatedVx = mVelocityTracker.getXVelocity();             final float estimatedVy = mVelocityTracker.getYVelocity();             Log.d(TAG, String.format(                     ""[%d] x=%6.1f, y=%6.1f, vx=%6.1f, vy=%6.1f, ax=%6.1f, ay=%6.1f, ""                     + ""evx=%6.1f (%6.1f%%), evy=%6.1f (%6.1f%%)"",                     mTime, mPx, mPy, mVx, mVy, mAx, mAy,                     estimatedVx, error(mVx, estimatedVx) * 100.0f,                     estimatedVy, error(mVy, estimatedVy) * 100.0f));         }     }      private void assertVelocity(float tolerance, String message) {         mVelocityTracker.computeCurrentVelocity(1);         final float estimatedVx = mVelocityTracker.getXVelocity();         final float estimatedVy = mVelocityTracker.getYVelocity();         float errorVx = error(mVx, estimatedVx);         float errorVy = error(mVy, estimatedVy);         if (errorVx > tolerance || errorVy > tolerance) {             fail(String.format(""Velocity exceeds tolerance of %6.1f%%: ""                     + ""expected vx=%6.1f, vy=%6.1f. ""                     + ""actual vx=%6.1f (%6.1f%%), vy=%6.1f (%6.1f%%). %s"",                     tolerance * 100.0f, mVx, mVy,                     estimatedVx, errorVx * 100.0f, estimatedVy, errorVy * 100.0f, message));         }     }      private static float error(float expected, float actual) {         float absError = Math.abs(actual - expected);         if (absError < 0.001f) {             return 0;         }         if (Math.abs(expected) < 0.001f) {             return 1;         }         return absError / Math.abs(expected);     } } ",6.1/C-4-1,,06010000.670401,6.1 C-4-1 isAdbWifiSupported(),Test[None]:[android.view.cts.VelocityTrackerTest:testUsesRawCoordinates()],,6.1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/VelocityTrackerTest.java,,
,6.1,C-5-1,,android.view.cts.VelocityTrackerTest,testUsesRawCoordinates(),,"     public void testUsesRawCoordinates() {         VelocityTracker vt = VelocityTracker.obtain();         final int numevents = 5;          final long downTime = SystemClock.uptimeMillis();         for (int i = 0; i < numevents; i++) {             final long eventTime = downTime + i * 10;             int action = i == 0 ? MotionEvent.ACTION_DOWN : MotionEvent.ACTION_MOVE;             MotionEvent event = MotionEvent.obtain(downTime, eventTime, action, 0, 0, 0);             event.offsetLocation(i * 10, i * 10);             vt.addMovement(event);         }         vt.computeCurrentVelocity(1000);         float xVelocity = vt.getXVelocity();         float yVelocity = vt.getYVelocity();         if (xVelocity == 0 || yVelocity == 0) {             fail(""VelocityTracker is using raw coordinates,""                     + "" but it should be using adjusted coordinates"");         }     }      private void move(long duration, long step) {         addMovement();         while (duration > 0) {             duration -= step;             mTime += step;             mPx += (mAx / 2 * step + mVx) * step;             mPy += (mAy / 2 * step + mVy) * step;             mVx += mAx * step;             mVy += mAy * step;             addMovement();         }     }      private void pause(long duration) {         mTime += duration;     }      private void addMovement() {         if (mTime > mLastTime) {             MotionEvent ev = MotionEvent.obtain(0L, mTime, MotionEvent.ACTION_MOVE, mPx, mPy, 0);             mVelocityTracker.addMovement(ev);             ev.recycle();             mLastTime = mTime;              mVelocityTracker.computeCurrentVelocity(1);             final float estimatedVx = mVelocityTracker.getXVelocity();             final float estimatedVy = mVelocityTracker.getYVelocity();             Log.d(TAG, String.format(                     ""[%d] x=%6.1f, y=%6.1f, vx=%6.1f, vy=%6.1f, ax=%6.1f, ay=%6.1f, ""                     + ""evx=%6.1f (%6.1f%%), evy=%6.1f (%6.1f%%)"",                     mTime, mPx, mPy, mVx, mVy, mAx, mAy,                     estimatedVx, error(mVx, estimatedVx) * 100.0f,                     estimatedVy, error(mVy, estimatedVy) * 100.0f));         }     }      private void assertVelocity(float tolerance, String message) {         mVelocityTracker.computeCurrentVelocity(1);         final float estimatedVx = mVelocityTracker.getXVelocity();         final float estimatedVy = mVelocityTracker.getYVelocity();         float errorVx = error(mVx, estimatedVx);         float errorVy = error(mVy, estimatedVy);         if (errorVx > tolerance || errorVy > tolerance) {             fail(String.format(""Velocity exceeds tolerance of %6.1f%%: ""                     + ""expected vx=%6.1f, vy=%6.1f. ""                     + ""actual vx=%6.1f (%6.1f%%), vy=%6.1f (%6.1f%%). %s"",                     tolerance * 100.0f, mVx, mVy,                     estimatedVx, errorVx * 100.0f, estimatedVy, errorVy * 100.0f, message));         }     }      private static float error(float expected, float actual) {         float absError = Math.abs(actual - expected);         if (absError < 0.001f) {             return 0;         }         if (Math.abs(expected) < 0.001f) {             return 1;         }         return absError / Math.abs(expected);     } } ",6.1/C-5-1,,06010000.670501,isAdbWifiQrSupported() 6.1 C-5-1,Test[None]:[android.view.cts.VelocityTrackerTest:testUsesRawCoordinates()],,6.1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/VelocityTrackerTest.java,,
,7.1.1.1,C-2-1,,android.appwidget.cts.RequestPinAppWidgetTest,testPinWidget_launcher2(),,"     public void testPinWidget_launcher2() throws Exception {         runPinWidgetTest(""android.appwidget.cts.packages.launcher2"");     }      @CddTest(requirement=""3.8.2/C-2-1"")     public void verifyIsRequestPinAppWidgetSupported(String launcherPkg, boolean expectedSupport)         throws Exception {         setLauncher(launcherPkg + ""/"" + LAUNCHER_CLASS);          Context context = getInstrumentation().getContext();         assertEquals(expectedSupport,                 AppWidgetManager.getInstance(context).isRequestPinAppWidgetSupported());     }      ",7.1.1.1/C-2-1,,07010101.670201,display(s) cs.android.com 7.1.1.1 C-2-1,Test[None]:[android.appwidget.cts.RequestPinAppWidgetTest:testPinWidget_launcher2()],,C-2-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/appwidget/src/android/appwidget/cts/RequestPinAppWidgetTest.java,,
,7.1.1.1,C-3-1,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.1.1.1/C-3-1,,07010101.670301,C-3-1 7.1.1.1,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.1.4.2,C-1-10,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.1.4.2/C-1-10,,07010402.670110,7.1.4.2 android.software.vulkan.deqp.level EQP C-1-10,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,7.1.4.2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.2.3,C-3-1,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.3/C-3-1,,07020300.670301,7.2.3 C-3-1 KeyEvent.html KEYCODE_ASSIST,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.2.4,C-3-2,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.4/C-3-2,,07020400.670302,android.hardware.faketouch C-3-2 7.2.4,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,android.hardware.faketouch,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.2.4,C-3-3,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.4/C-3-3,,07020400.670303,Configuration.html Configuration.touchscreen C-3-3 7.2.4 TOUCHSCREEN_NOTOUCH,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,TOUCHSCREEN_NOTOUCH,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.2.6.1,C-2-1,,android.server.wm.DisplayCutoutTests,testDisplayCutout_always(),,"     public void testDisplayCutout_always() {         runTest(LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS, (a, insets, displayCutout, which) -> {             if (which == ROOT) {                 assertThat(""Display.getCutout() must equal view root cutout"",                         a.getDisplay().getCutout(), equalTo(displayCutout));             }         });     }      private void runTest(int cutoutMode, TestDef test) {         runTest(cutoutMode, test, orientation);     }      private void runTest(int cutoutMode, TestDef test, int orientation) {         assumeTrue(""Skipping test: orientation not supported"", supportsOrientation(orientation));         final TestActivity activity = launchAndWait(mDisplayCutoutActivity,                 cutoutMode, orientation);          WindowInsets insets = getOnMainSync(activity::getRootInsets);         WindowInsets dispatchedInsets = getOnMainSync(activity::getDispatchedInsets);         Assert.assertThat(""test setup failed, no insets at root"", insets, notNullValue());         Assert.assertThat(""test setup failed, no insets dispatched"",                 dispatchedInsets, notNullValue());          final DisplayCutout displayCutout = insets.getDisplayCutout();         final DisplayCutout dispatchedDisplayCutout = dispatchedInsets.getDisplayCutout();         if (displayCutout != null) {             commonAsserts(activity, displayCutout);             if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS) {                 shortEdgeAsserts(activity, insets, displayCutout);             }             assertCutoutsAreConsistentWithInsets(activity, displayCutout);             assertSafeInsetsAreConsistentWithDisplayCutoutInsets(insets);         }         test.run(activity, insets, displayCutout, ROOT);          if (dispatchedDisplayCutout != null) {             commonAsserts(activity, dispatchedDisplayCutout);             if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS) {                 shortEdgeAsserts(activity, insets, displayCutout);             }             assertCutoutsAreConsistentWithInsets(activity, dispatchedDisplayCutout);             if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT) {                 assertSafeInsetsAreConsistentWithDisplayCutoutInsets(dispatchedInsets);             }         }         test.run(activity, dispatchedInsets, dispatchedDisplayCutout, DISPATCHED);     }      private void assertSafeInsetsAreConsistentWithDisplayCutoutInsets(WindowInsets insets) {         DisplayCutout cutout = insets.getDisplayCutout();         Insets safeInsets = Insets.of(safeInsets(cutout));         assertEquals(""WindowInsets.getInsets(displayCutout()) must equal""                         + "" DisplayCutout.getSafeInsets()"",                 safeInsets, insets.getInsets(Type.displayCutout()));         assertEquals(""WindowInsets.getInsetsIgnoringVisibility(displayCutout()) must equal""                         + "" DisplayCutout.getSafeInsets()"",                 safeInsets, insets.getInsetsIgnoringVisibility(Type.displayCutout()));     }      private void commonAsserts(TestActivity activity, DisplayCutout cutout) {         assertSafeInsetsValid(cutout);         assertCutoutsAreWithinSafeInsets(activity, cutout);         assertBoundsAreNonEmpty(cutout);         assertAtMostOneCutoutPerEdge(activity, cutout);     }      private void shortEdgeAsserts(             TestActivity activity, WindowInsets insets, DisplayCutout cutout) {         assertOnlyShortEdgeHasInsets(activity, cutout);         assertOnlyShortEdgeHasBounds(activity, cutout);         assertThat(""systemWindowInsets (also known as content insets) must be at least as ""                         + ""large as cutout safe insets"",                 safeInsets(cutout), insetsLessThanOrEqualTo(systemWindowInsets(insets)));     }      private void assertCutoutIsConsistentWithInset(String position, DisplayCutout cutout,             int safeInsetSize, Rect appBound) {         if (safeInsetSize > 0) {             assertThat(""cutout must have a bound on the "" + position,                     hasBound(position, cutout, appBound), is(true));         } else {             assertThat(""cutout  must have no bound on the "" + position,                     hasBound(position, cutout, appBound), is(false));         }     }      public void assertCutoutsAreConsistentWithInsets(TestActivity activity, DisplayCutout cutout) {         final Rect appBounds = getAppBounds(activity);         assertCutoutIsConsistentWithInset(TOP, cutout, cutout.getSafeInsetTop(), appBounds);         assertCutoutIsConsistentWithInset(BOTTOM, cutout, cutout.getSafeInsetBottom(), appBounds);         assertCutoutIsConsistentWithInset(LEFT, cutout, cutout.getSafeInsetLeft(), appBounds);         assertCutoutIsConsistentWithInset(RIGHT, cutout, cutout.getSafeInsetRight(), appBounds);     }      private void assertSafeInsetsValid(DisplayCutout displayCutout) {         //noinspection unchecked         assertThat(""all safe insets must be non-negative"", safeInsets(displayCutout),                 insetValues(everyItem((Matcher)greaterThanOrEqualTo(0))));         assertThat(""at least one safe inset must be positive,""                         + "" otherwise WindowInsets.getDisplayCutout()) must return null"",                 safeInsets(displayCutout), insetValues(hasItem(greaterThan(0))));     }      private void assertCutoutsAreWithinSafeInsets(TestActivity a, DisplayCutout cutout) {         final Rect safeRect = getSafeRect(a, cutout);          assertThat(""safe insets must not cover the entire screen"", safeRect.isEmpty(), is(false));         for (Rect boundingRect : cutout.getBoundingRects()) {             assertThat(""boundingRects must not extend beyond safeInsets"",                     boundingRect, not(intersectsWith(safeRect)));         }     }      private void assertAtMostOneCutoutPerEdge(TestActivity a, DisplayCutout cutout) {         final Rect safeRect = getSafeRect(a, cutout);          assertThat(""must not have more than one left cutout"",                 boundsWith(cutout, (r) -> r.right <= safeRect.left), hasSize(lessThanOrEqualTo(1)));         assertThat(""must not have more than one top cutout"",                 boundsWith(cutout, (r) -> r.bottom <= safeRect.top), hasSize(lessThanOrEqualTo(1)));         assertThat(""must not have more than one right cutout"",                 boundsWith(cutout, (r) -> r.left >= safeRect.right), hasSize(lessThanOrEqualTo(1)));         assertThat(""must not have more than one bottom cutout"",                 boundsWith(cutout, (r) -> r.top >= safeRect.bottom), hasSize(lessThanOrEqualTo(1)));     }      private void assertBoundsAreNonEmpty(DisplayCutout cutout) {         for (Rect boundingRect : cutout.getBoundingRects()) {             assertThat(""rect in boundingRects must not be empty"",                     boundingRect.isEmpty(), is(false));         }     }      private void assertOnlyShortEdgeHasInsets(TestActivity activity,             DisplayCutout displayCutout) {         final Rect appBounds = getAppBounds(activity);         if (appBounds.height() > appBounds.width()) {             // Portrait display             assertThat(""left edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetLeft(), is(0));             assertThat(""right edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetRight(), is(0));         }         if (appBounds.height() < appBounds.width()) {             // Landscape display             assertThat(""top edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetTop(), is(0));             assertThat(""bottom edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetBottom(), is(0));         }     }      private void assertOnlyShortEdgeHasBounds(TestActivity activity, DisplayCutout cutout) {         final Rect appBounds = getAppBounds(activity);         if (appBounds.height() > appBounds.width()) {             // Portrait display             assertThat(""left edge has a cutout despite being long edge"",                     hasBound(LEFT, cutout, appBounds), is(false));              assertThat(""right edge has a cutout despite being long edge"",                     hasBound(RIGHT, cutout, appBounds), is(false));         }         if (appBounds.height() < appBounds.width()) {             // Landscape display             assertThat(""top edge has a cutout despite being long edge"",                     hasBound(TOP, cutout, appBounds), is(false));              assertThat(""bottom edge has a cutout despite being long edge"",                     hasBound(BOTTOM, cutout, appBounds), is(false));         }     }      private boolean hasBound(String position, DisplayCutout cutout, Rect appBound) {         final Rect cutoutRect;         final int waterfallSize;         if (LEFT.equals(position)) {             cutoutRect = cutout.getBoundingRectLeft();             waterfallSize = cutout.getWaterfallInsets().left;         } else if (TOP.equals(position)) {             cutoutRect = cutout.getBoundingRectTop();             waterfallSize = cutout.getWaterfallInsets().top;         } else if (RIGHT.equals(position)) {             cutoutRect = cutout.getBoundingRectRight();             waterfallSize = cutout.getWaterfallInsets().right;         } else {             cutoutRect = cutout.getBoundingRectBottom();             waterfallSize = cutout.getWaterfallInsets().bottom;         }         return Rect.intersects(cutoutRect, appBound) || waterfallSize > 0;     }      private List<Rect> boundsWith(DisplayCutout cutout, Predicate<Rect> predicate) {         return cutout.getBoundingRects().stream().filter(predicate).collect(Collectors.toList());     }      private static Rect safeInsets(DisplayCutout displayCutout) {         if (displayCutout == null) {             return null;         }         return new Rect(displayCutout.getSafeInsetLeft(), displayCutout.getSafeInsetTop(),                 displayCutout.getSafeInsetRight(), displayCutout.getSafeInsetBottom());     }      private static Rect systemWindowInsets(WindowInsets insets) {         return new Rect(insets.getSystemWindowInsetLeft(), insets.getSystemWindowInsetTop(),                 insets.getSystemWindowInsetRight(), insets.getSystemWindowInsetBottom());     }      private static Rect stableInsets(WindowInsets insets) {         return new Rect(insets.getStableInsetLeft(), insets.getStableInsetTop(),                 insets.getStableInsetRight(), insets.getStableInsetBottom());     }      private Rect getSafeRect(TestActivity a, DisplayCutout cutout) {         final Rect safeRect = safeInsets(cutout);         safeRect.bottom = getOnMainSync(() -> a.getDecorView().getHeight()) - safeRect.bottom;         safeRect.right = getOnMainSync(() -> a.getDecorView().getWidth()) - safeRect.right;         return safeRect;     }      private Rect getAppBounds(TestActivity a) {         final Rect appBounds = new Rect();         runOnMainSync(() -> {             appBounds.right = a.getDecorView().getWidth();             appBounds.bottom = a.getDecorView().getHeight();         });         return appBounds;     }      private static Matcher<Rect> insetsLessThanOrEqualTo(Rect max) {         return new CustomTypeSafeMatcher<Rect>(""must be smaller on each side than "" + max) {             @Override             protected boolean matchesSafely(Rect actual) {                 return actual.left <= max.left && actual.top <= max.top                         && actual.right <= max.right && actual.bottom <= max.bottom;             }         };     }      private static Matcher<Rect> intersectsWith(Rect safeRect) {         return new CustomTypeSafeMatcher<Rect>(""intersects with "" + safeRect) {             @Override             protected boolean matchesSafely(Rect item) {                 return Rect.intersects(safeRect, item);             }         };     }      private static Matcher<Rect> insetValues(Matcher<Iterable<? super Integer>> valuesMatcher) {         return new FeatureMatcher<Rect, Iterable<Integer>>(valuesMatcher, ""inset values"",                 ""inset values"") {             @Override             protected Iterable<Integer> featureValueOf(Rect actual) {                 return Arrays.asList(actual.left, actual.top, actual.right, actual.bottom);             }         };     }      private <T> void assertThat(String reason, T actual, Matcher<? super T> matcher) {         mErrorCollector.checkThat(reason, actual, matcher);     }      private <R> R getOnMainSync(Supplier<R> f) {         final Object[] result = new Object[1];         runOnMainSync(() -> result[0] = f.get());         //noinspection unchecked         return (R) result[0];     }      private void runOnMainSync(Runnable runnable) {         getInstrumentation().runOnMainSync(runnable);     }      private <T extends TestActivity> T launchAndWait(ActivityTestRule<T> rule, int cutoutMode,             int orientation) {         final T activity = rule.launchActivity(                 new Intent().putExtra(EXTRA_CUTOUT_MODE, cutoutMode)                         .putExtra(EXTRA_ORIENTATION, orientation));         PollingCheck.waitFor(activity::hasWindowFocus);         PollingCheck.waitFor(() -> {             final Rect appBounds = getAppBounds(activity);             final Point displaySize = new Point();             activity.getDisplay().getRealSize(displaySize);             // During app launch into a different rotation, we have temporarily have the display             // in a different rotation than the app itself. Wait for this to settle.             return (appBounds.width() > appBounds.height()) == (displaySize.x > displaySize.y);         });         return activity;     }      private boolean supportsOrientation(int orientation) {         String systemFeature = """";         switch(orientation) {             case SCREEN_ORIENTATION_PORTRAIT:             case SCREEN_ORIENTATION_REVERSE_PORTRAIT:                 systemFeature = PackageManager.FEATURE_SCREEN_PORTRAIT;                 break;             case SCREEN_ORIENTATION_LANDSCAPE:             case SCREEN_ORIENTATION_REVERSE_LANDSCAPE:                 systemFeature = PackageManager.FEATURE_SCREEN_LANDSCAPE;                 break;             default:                 throw new UnsupportedOperationException(""Orientation not supported"");         }          return getInstrumentation().getTargetContext().getPackageManager()                 .hasSystemFeature(systemFeature);     }      public static class TestActivity extends Activity {          static final String EXTRA_CUTOUT_MODE = ""extra.cutout_mode"";         static final String EXTRA_ORIENTATION = ""extra.orientation"";         private WindowInsets mDispatchedInsets;          @Override         protected void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             getWindow().requestFeature(Window.FEATURE_NO_TITLE);             if (getIntent() != null) {                 getWindow().getAttributes().layoutInDisplayCutoutMode = getIntent().getIntExtra(                         EXTRA_CUTOUT_MODE, LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT);                 setRequestedOrientation(getIntent().getIntExtra(                         EXTRA_ORIENTATION, SCREEN_ORIENTATION_UNSPECIFIED));             }             View view = new View(this);             view.setLayoutParams(new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));             view.setOnApplyWindowInsetsListener((v, insets) -> mDispatchedInsets = insets);             setContentView(view);         }          @Override         public void onWindowFocusChanged(boolean hasFocus) {             if (hasFocus) {                 getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN                         | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION                         | View.SYSTEM_UI_FLAG_FULLSCREEN                         | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);             }         }          View getDecorView() {             return getWindow().getDecorView();         }          WindowInsets getRootInsets() {             return getWindow().getDecorView().getRootWindowInsets();         }          WindowInsets getDispatchedInsets() {             return mDispatchedInsets;         }     }      interface TestDef {         void run(TestActivity a, WindowInsets insets, DisplayCutout cutout, Which whichInsets);          enum Which {             DISPATCHED, ROOT         }     } } ",7.2.6.1/C-2-1,,07020601.670201,AXIS_HAT_X4 AXIS_LTRIGGER KEYCODE_BUTTON_A KEYCODE_BUTTON_B KEYCODE_BUTTON_THUMBR KEYCODE_BACK AXIS_RZ AXIS_Z android.hardware.gamepad HID AXIS_RTRIGGER MotionEvent.html 7.2.6.1 AXIS_X KEYCODE_BUTTON_L1 KEYCODE_BUTTON_Y KEYCODE_BUTTON_THUMBL AXIS_HAT_Y4 KEYCODE_HOME C-2-1 KEYCODE_BUTTON_X KEYCODE_BUTTON_R1 AXIS_Y,Test[None]:[android.server.wm.DisplayCutoutTests:testDisplayCutout_always()],,HID,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,,
,7.3,C-1-6,,android.server.wm.MultiDisplaySystemDecorationTests,testImeWindowCanShownWhenActivityMovedToDisplay(),,"     public void testImeWindowCanShownWhenActivityMovedToDisplay() throws Exception {         assumeTrue(MSG_NO_MOCK_IME, supportsInstallableIme());          // Launch a regular activity on default display at the test beginning to prevent the test         // may mis-touch the launcher icon that breaks the test expectation.         final TestActivitySession<Activities.RegularActivity> testActivitySession =                 createManagedTestActivitySession();         testActivitySession.launchTestActivityOnDisplaySync(Activities.RegularActivity.class,                 DEFAULT_DISPLAY);          // Create a virtual display and launch an activity on virtual display.         final DisplayContent newDisplay = createManagedVirtualDisplaySession()                 .setShowSystemDecorations(true)                 .setRequestShowIme(true)                 .setSimulateDisplay(true)                 .createDisplay();          // Leverage MockImeSession to ensure at least an IME exists as default.         final MockImeSession mockImeSession = createManagedMockImeSession(this);         final TestActivitySession<ImeTestActivity> imeTestActivitySession =                 createManagedTestActivitySession();         imeTestActivitySession.launchTestActivityOnDisplaySync(ImeTestActivity.class,                 newDisplay.mId);          // Verify the activity is launched to the secondary display.         final ComponentName imeTestActivityName =                 imeTestActivitySession.getActivity().getComponentName();         assertThat(mWmState.hasActivityInDisplay(newDisplay.mId, imeTestActivityName)).isTrue();          // Tap default display, assume a pointer-out-side event will happened to change the top         // display.         final DisplayContent defDisplay = mWmState.getDisplay(DEFAULT_DISPLAY);         tapOnDisplayCenter(defDisplay.mId);         mWmState.waitForAppTransitionIdleOnDisplay(DEFAULT_DISPLAY);         mWmState.assertSanity();          // Reparent ImeTestActivity from virtual display to default display.         getLaunchActivityBuilder()                 .setUseInstrumentation()                 .setTargetActivity(imeTestActivitySession.getActivity().getComponentName())                 .setIntentFlags(Intent.FLAG_ACTIVITY_NEW_TASK)                 .allowMultipleInstances(false)                 .setDisplayId(DEFAULT_DISPLAY).execute();         waitAndAssertTopResumedActivity(imeTestActivitySession.getActivity().getComponentName(),                 DEFAULT_DISPLAY, ""Activity launched on default display and on top"");          // Activity is no longer on the secondary display         assertThat(mWmState.hasActivityInDisplay(newDisplay.mId, imeTestActivityName)).isFalse();          // Verify if tapping the test activity on default display to request focus on EditText can         // show soft input.         final ImeEventStream stream = mockImeSession.openEventStream();         tapOnCenter(imeTestActivitySession.getActivity().getBoundsOnScreen(), defDisplay.mId);         imeTestActivitySession.runOnMainSyncAndWait(                 imeTestActivitySession.getActivity()::showSoftInput);         waitOrderedImeEventsThenAssertImeShown(stream, defDisplay.mId,                 editorMatcher(""onStartInput"",                         imeTestActivitySession.getActivity().mEditText.getPrivateImeOptions()),                 event -> ""showSoftInput"".equals(event.getEventName()));     }      public static class ImeTestActivity extends Activity {         ImeAwareEditText mEditText;         private LinearLayout mLayout;          @Override         protected void onCreate(Bundle icicle) {             super.onCreate(icicle);             mEditText = new ImeAwareEditText(this);             // Set private IME option for editorMatcher to identify which TextView received             // onStartInput event.             resetPrivateImeOptionsIdentifier();             mLayout = new LinearLayout(this);             mLayout.setOrientation(LinearLayout.VERTICAL);             mLayout.addView(mEditText);             mEditText.requestFocus();             setContentView(mLayout);         }          void showSoftInput() {             mEditText.scheduleShowSoftInput();         }          void resetPrivateImeOptionsIdentifier() {             mEditText.setPrivateImeOptions(                     getClass().getName() + ""/"" + Long.toString(SystemClock.elapsedRealtimeNanos()));         }          Rect getBoundsOnScreen() {             final int[] location = new int[2];             mLayout.getLocationOnScreen(location);             return new Rect(location[0], location[1], location[0] + mLayout.getWidth(),                     location[1] + mLayout.getHeight());         }     }      public static class ImeTestActivity2 extends ImeTestActivity { }      public static final class ImeTestActivityWithBrokenContextWrapper extends Activity {         private EditText mEditText;          /**          * Emulates the behavior of certain {@link ContextWrapper} subclasses we found in the wild.          *          * <p> Certain {@link ContextWrapper} subclass in the wild delegate method calls to          * ApplicationContext except for {@link #getSystemService(String)}.</p>          *          **/         private static final class Bug118341760ContextWrapper extends ContextWrapper {             private final Context mOriginalContext;              Bug118341760ContextWrapper(Context base) {                 super(base.getApplicationContext());                 mOriginalContext = base;             }              /**              * Emulates the behavior of {@link ContextWrapper#getSystemService(String)} of certain              * {@link ContextWrapper} subclasses we found in the wild.              *              * @param name The name of the desired service.              * @return The service or {@link null} if the name does not exist.              */             @Override             public Object getSystemService(String name) {                 return mOriginalContext.getSystemService(name);             }         }          @Override         protected void onCreate(Bundle icicle) {             super.onCreate(icicle);             mEditText = new EditText(new Bug118341760ContextWrapper(this));             // Use SystemClock.elapsedRealtimeNanos()) as a unique ID of this edit text.             mEditText.setPrivateImeOptions(Long.toString(SystemClock.elapsedRealtimeNanos()));             final LinearLayout layout = new LinearLayout(this);             layout.setOrientation(LinearLayout.VERTICAL);             layout.addView(mEditText);             mEditText.requestFocus();             setContentView(layout);         }          EditText getEditText() {             return mEditText;         }     }      private void assertImeWindowAndDisplayConfiguration(             WindowState imeWinState, DisplayContent display) {         final Configuration configurationForIme = imeWinState.mMergedOverrideConfiguration;         final Configuration configurationForDisplay =  display.mMergedOverrideConfiguration;         final int displayDensityDpiForIme = configurationForIme.densityDpi;         final int displayDensityDpi = configurationForDisplay.densityDpi;         final Rect displayBoundsForIme = configurationForIme.windowConfiguration.getBounds();         final Rect displayBounds = configurationForDisplay.windowConfiguration.getBounds();          assertEquals(""Display density not the same"", displayDensityDpi, displayDensityDpiForIme);         assertEquals(""Display bounds not the same"", displayBounds, displayBoundsForIme);     } } ",7.3/C-1-6,,07030000.670106,7.3 Sensor.getResolution C-1-6 SystemClock.elapsedRealtimeNano elapsedRealtimeNano() SensorEvent.html getResolution(),Test[None]:[android.server.wm.MultiDisplaySystemDecorationTests:testImeWindowCanShownWhenActivityMovedToDisplay()],,SystemClock.elapsedRealtimeNano,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySystemDecorationTests.java,,
,7.3,C-1-7,,android.database.cts.CursorWindowTest,testAccessDataValues(),,"     public void testAccessDataValues() {         final long NUMBER_LONG_INTEGER = (long) 0xaabbccddffL;         final long NUMBER_INTEGER = (int) NUMBER_LONG_INTEGER;         final long NUMBER_SHORT = (short) NUMBER_INTEGER;         final float NUMBER_FLOAT_SCIENCE = 7.332952E11f;         final double NUMBER_DOUBLE_SCIENCE = 7.33295205887E11;         final String NUMBER_FLOAT_SCIENCE_STRING = ""7.332952E11"";         final String NUMBER_DOUBLE_SCIENCE_STRING = ""7.33295205887E11"";         final String NUMBER_FLOAT_SCIENCE_STRING2 = ""7.33295e+11"";          byte[] originalBlob = new byte[Byte.MAX_VALUE];         for (int i = 0; i < Byte.MAX_VALUE; i++) {             originalBlob[i] = (byte) i;         }          CursorWindow cursorWindow = new CursorWindow(true);         cursorWindow.setNumColumns(5);         cursorWindow.allocRow();          // Test putString, getString, getLong, getInt, isBlob         assertTrue(cursorWindow.putString(Long.toString(NUMBER_LONG_INTEGER), 0, 0));         assertEquals(Long.toString(NUMBER_LONG_INTEGER), cursorWindow.getString(0, 0));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 0));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 0));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 0));         // Converting of Float, there would be some little precision differences. So just compare         // first 6 digits.         assertEquals(NUMBER_FLOAT_SCIENCE_STRING.substring(0, 6), Float.toString(                 cursorWindow.getFloat(0, 0)).substring(0, 6));         assertEquals(NUMBER_DOUBLE_SCIENCE_STRING, Double.toString(cursorWindow.getDouble(0, 0)));         assertFalse(cursorWindow.isNull(0, 0));         assertFalse(cursorWindow.isBlob(0, 0));          // Test null String         assertTrue(cursorWindow.putString("""", 0, 0));         assertEquals("""", cursorWindow.getString(0, 0));         assertEquals(0, cursorWindow.getLong(0, 0));         assertEquals(0, cursorWindow.getInt(0, 0));         assertEquals(0, cursorWindow.getShort(0, 0));         assertEquals(0.0, cursorWindow.getDouble(0, 0), 0.0);         assertEquals(0.0f, cursorWindow.getFloat(0, 0), 0.0);         assertFalse(cursorWindow.isNull(0, 0));         assertFalse(cursorWindow.isBlob(0, 0));          // Test putNull, getString, getLong, getDouble, getBlob, getInd, getShort, getFloat,         // isBlob.         assertTrue(cursorWindow.putNull(0, 1));         assertNull(cursorWindow.getString(0, 1));         assertEquals(0, cursorWindow.getLong(0, 1));         assertEquals(0, cursorWindow.getInt(0, 1));         assertEquals(0, cursorWindow.getShort(0, 1));         assertEquals(0.0, cursorWindow.getDouble(0, 1), 0.0);         assertEquals(0.0f, cursorWindow.getFloat(0, 1), 0.0);         assertNull(cursorWindow.getBlob(0, 1));         assertTrue(cursorWindow.isNull(0, 1));         // If the field is null, isBlob will return true.         assertTrue(cursorWindow.isBlob(0, 1));          // Test putLong, getLong, getInt, getString , getShort, getFloat, getDouble, isBlob.         assertTrue(cursorWindow.putLong(NUMBER_LONG_INTEGER, 0, 2));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 2));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 2));         assertEquals(Long.toString(NUMBER_LONG_INTEGER), cursorWindow.getString(0, 2));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 2));         assertEquals(NUMBER_FLOAT_SCIENCE, cursorWindow.getFloat(0, 2), 0.0);         assertEquals(NUMBER_DOUBLE_SCIENCE, cursorWindow.getDouble(0, 2), 0.0);         try {             cursorWindow.getBlob(0, 2);             fail(""Can't get Blob from a Integer value."");         } catch (SQLiteException e) {             // expected         }         assertFalse(cursorWindow.isNull(0, 2));         assertFalse(cursorWindow.isBlob(0, 2));          // Test putDouble         assertTrue(cursorWindow.putDouble(NUMBER_DOUBLE_SCIENCE, 0, 3));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 3));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 3));         // Converting from Double to String, there would be some little precision differences. So         // Just compare first 6 digits.         assertEquals(NUMBER_FLOAT_SCIENCE_STRING2.substring(0, 6), cursorWindow.getString(0, 3)                 .substring(0, 6));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 3));         assertEquals(NUMBER_FLOAT_SCIENCE, cursorWindow.getFloat(0, 3), 0.0);         assertEquals(NUMBER_DOUBLE_SCIENCE, cursorWindow.getDouble(0, 3), 0.0);         try {             cursorWindow.getBlob(0, 3);             fail(""Can't get Blob from a Double value."");         } catch (SQLiteException e) {             // expected         }         assertFalse(cursorWindow.isNull(0, 3));         assertFalse(cursorWindow.isBlob(0, 3));          // Test putBlob         assertTrue(cursorWindow.putBlob(originalBlob, 0, 4));         byte[] targetBlob = cursorWindow.getBlob(0, 4);         assertTrue(Arrays.equals(originalBlob, targetBlob));         assertFalse(cursorWindow.isNull(0, 4));         // Test isBlob         assertTrue(cursorWindow.isBlob(0, 4));     }      ",7.3/C-1-7,,07030000.670107,C-1-7 7.3,Test[None]:[android.database.cts.CursorWindowTest:testAccessDataValues()],,7.3,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/database/src/android/database/cts/CursorWindowTest.java,,
,7.3.6,C-2-1,,android.appwidget.cts.RequestPinAppWidgetTest,testPinWidget_launcher2(),,"     public void testPinWidget_launcher2() throws Exception {         runPinWidgetTest(""android.appwidget.cts.packages.launcher2"");     }      @CddTest(requirement=""3.8.2/C-2-1"")     public void verifyIsRequestPinAppWidgetSupported(String launcherPkg, boolean expectedSupport)         throws Exception {         setLauncher(launcherPkg + ""/"" + LAUNCHER_CLASS);          Context context = getInstrumentation().getContext();         assertEquals(expectedSupport,                 AppWidgetManager.getInstance(context).isRequestPinAppWidgetSupported());     }      ",7.3.6/C-2-1,,07030600.670201,TYPE_AMBIENT_TEMPERATURE C-2-1 7.3.6 SENSOR_TYPE_AMBIENT_TEMPERATURE,Test[None]:[android.appwidget.cts.RequestPinAppWidgetTest:testPinWidget_launcher2()],,C-2-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/appwidget/src/android/appwidget/cts/RequestPinAppWidgetTest.java,,
,7.3.10,C-6-2,,android.security.identity.cts.IdentityApiTest,,,"/*  *.  */  package android.security.identity.cts;  import android.content.Context; import android.hardware.biometrics.BiometricPrompt.CryptoObject; import android.security.identity.AccessControlProfileId; import android.security.identity.AlreadyPersonalizedException; import android.security.identity.CipherSuiteNotSupportedException; import android.security.identity.DocTypeNotSupportedException; import android.security.identity.EphemeralPublicKeyNotFoundException; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.InvalidReaderSignatureException; import android.security.identity.InvalidRequestMessageException; import android.security.identity.MessageDecryptionException; import android.security.identity.NoAuthenticationKeyAvailableException; import android.security.identity.SessionTranscriptMismatchException; import android.security.identity.UnknownAuthenticationKeyException;  import androidx.test.InstrumentationRegistry;  import org.junit.Test; import static org.junit.Assert.assertEquals;  public class IdentityApiTest {     private static final String TAG = ""IdentityApiTest"";      ",7.3.10/C-6-2,,07031000.670602,C-6-2 7.3.10 BiometricPrompt.CryptoObject BIOMETRIC_STRONG BiometricManager.Authenticators,Test[None]:[android.security.identity.cts.IdentityApiTest:],,BiometricPrompt.CryptoObject,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/IdentityApiTest.java,,
,7.3.10,C-3-4,,android.appwidget.cts.RequestPinAppWidgetTest,setUpLauncher(),,"/*  *.  */  package android.appwidget.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import android.app.PendingIntent; import android.appwidget.AppWidgetManager; import android.appwidget.cts.common.Constants; import android.content.Context; import android.content.Intent; import android.content.pm.LauncherApps; import android.os.Bundle; import android.platform.test.annotations.AppModeFull;  import com.android.compatibility.common.util.CddTest;  import org.junit.After; import org.junit.Before; import org.junit.Test;  import java.util.Arrays;  @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"") public class RequestPinAppWidgetTest extends AppWidgetTestCase {      private static final String LAUNCHER_CLASS = ""android.appwidget.cts.packages.Launcher"";     private static final String ACTION_PIN_RESULT = ""android.appwidget.cts.ACTION_PIN_RESULT"";      private String mDefaultLauncher;      @Before     public void setUpLauncher() throws Exception {         mDefaultLauncher = getDefaultLauncher();     }      @After     public void tearDownLauncher() throws Exception {         // Set the launcher back         setLauncher(mDefaultLauncher);     }      @CddTest(requirement=""3.8.2/C-2-2"")     private void runPinWidgetTest(final String launcherPkg) throws Exception {         setLauncher(launcherPkg + ""/"" + LAUNCHER_CLASS);          Context context = getInstrumentation().getContext();          // Request to pin widget         BlockingBroadcastReceiver setupReceiver = new BlockingBroadcastReceiver()                 .register(Constants.ACTION_SETUP_REPLY);          Bundle extras = new Bundle();         extras.putString(""dummy"", launcherPkg + ""-dummy"");          PendingIntent pinResult = PendingIntent.getBroadcast(context, 0,                 new Intent(ACTION_PIN_RESULT), PendingIntent.FLAG_ONE_SHOT);         AppWidgetManager.getInstance(context).requestPinAppWidget(                 getFirstWidgetComponent(), extras, pinResult);          setupReceiver.await();         // Verify that the confirmation dialog was opened         assertTrue(setupReceiver.result.getBooleanExtra(Constants.EXTRA_SUCCESS, false));         assertEquals(launcherPkg, setupReceiver.result.getStringExtra(Constants.EXTRA_PACKAGE));          LauncherApps.PinItemRequest req =                 setupReceiver.result.getParcelableExtra(Constants.EXTRA_REQUEST);         assertNotNull(req);         // Verify that multiple calls to getAppWidgetProviderInfo have proper dimension.         boolean[] providerInfo = verifyInstalledProviders(Arrays.asList(                 req.getAppWidgetProviderInfo(context), req.getAppWidgetProviderInfo(context)));         assertTrue(providerInfo[0]);         assertNotNull(req.getExtras());         assertEquals(launcherPkg + ""-dummy"", req.getExtras().getString(""dummy""));          // Accept the request         BlockingBroadcastReceiver resultReceiver = new BlockingBroadcastReceiver()                 .register(ACTION_PIN_RESULT);         context.sendBroadcast(new Intent(Constants.ACTION_CONFIRM_PIN)                 .setPackage(launcherPkg)                 .putExtra(""dummy"", ""dummy-2""));         resultReceiver.await();          // Verify that the result contain the extras         assertEquals(""dummy-2"", resultReceiver.result.getStringExtra(""dummy""));     }      ",7.3.10/C-3-4,,07031000.670304,7.3.10 PIN C-3-4,Test[None]:[android.appwidget.cts.RequestPinAppWidgetTest:setUpLauncher()],,PIN,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/appwidget/src/android/appwidget/cts/RequestPinAppWidgetTest.java,,
,7.3.13,C-1-1,,android.hardware.camera2.cts.LogicalCameraDeviceTest,testDefaultFov(),CtsCameraTestCases,"     @CddTest(requirement=""7.5.4/C-1-1"")     public void testDefaultFov() throws Exception {         final double MIN_FOV = 50;         final double MAX_FOV = 90;         if (!isHandheldDevice()) {             return;         }         for (String id : mCameraIdsUnderTest) {             try {                 Log.i(TAG, ""Testing Camera "" + id);                  StaticMetadata staticInfo = mAllStaticInfo.get(id);                 if (!staticInfo.isColorOutputSupported()) {                     Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");                     continue;                 }                  if (!staticInfo.isLogicalMultiCamera()) {                     Log.i(TAG, ""Camera "" + id + "" is not a logical multi-camera, skipping"");                     continue;                 }                  SizeF physicalSize = staticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);                 double physicalDiag = Math.sqrt(Math.pow(physicalSize.getWidth(), 2)                         + Math.pow(physicalSize.getHeight(), 2));                 Rect activeArraySize = staticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);                  openDevice(id);                 for (int template : sTemplates) {                     try {                         CaptureRequest.Builder requestBuilder =                                 mCamera.createCaptureRequest(template);                         Float requestFocalLength = requestBuilder.get(                                 CaptureRequest.LENS_FOCAL_LENGTH);                         assertNotNull(""LENS_FOCAL_LENGTH must not be null"", requestFocalLength);                          Float requestZoomRatio = requestBuilder.get(                                 CaptureRequest.CONTROL_ZOOM_RATIO);                         assertNotNull(""CONTROL_ZOOM_RATIO must not be null"", requestZoomRatio);                         Rect requestCropRegion = requestBuilder.get(                                 CaptureRequest.SCALER_CROP_REGION);                         assertNotNull(""SCALER_CROP_REGION must not be null"", requestCropRegion);                         float totalZoomRatio = Math.min(                                 1.0f * activeArraySize.width() / requestCropRegion.width(),                                 1.0f * activeArraySize.height() / requestCropRegion.height()) *                                 requestZoomRatio;                          double fov = 2 *                                 Math.toDegrees(Math.atan2(physicalDiag/(2 * totalZoomRatio),                                 requestFocalLength));                          Log.v(TAG, ""Camera "" +  id + "" template "" + template +                                 ""'s default FOV is "" + fov);                         mCollector.expectInRange(""Camera "" +  id + "" template "" + template +                                 ""'s default FOV must fall between [50, 90] degrees"",                                 fov, MIN_FOV, MAX_FOV);                     } catch (IllegalArgumentException e) {                         if (template == CameraDevice.TEMPLATE_MANUAL &&                                 !staticInfo.isCapabilitySupported(CameraCharacteristics.                                 REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {                             // OK                         } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG &&                                 !staticInfo.isCapabilitySupported(CameraCharacteristics.                                 REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)) {                             // OK.                         } else {                             throw e; // rethrow                         }                     }                 }             } finally {                 closeDevice();             }         }     }      /**      * Find a common preview size that's supported by both the logical camera and      * two of the underlying physical cameras.      */     private Size findCommonPreviewSize(String cameraId,             List<String> dualPhysicalCameraIds) throws Exception {          Set<String> physicalCameraIds =                 mStaticInfo.getCharacteristics().getPhysicalCameraIds();         assertTrue(""Logical camera must contain at least 2 physical camera ids"",                 physicalCameraIds.size() >= 2);          List<Size> previewSizes = getSupportedPreviewSizes(                 cameraId, mCameraManager, PREVIEW_SIZE_BOUND);         HashMap<String, List<Size>> physicalPreviewSizesMap = new HashMap<String, List<Size>>();         HashMap<String, StreamConfigurationMap> physicalConfigs = new HashMap<>();         for (String physicalCameraId : physicalCameraIds) {             CameraCharacteristics properties =                     mCameraManager.getCameraCharacteristics(physicalCameraId);             assertNotNull(""Can't get camera characteristics!"", properties);             if (!mAllStaticInfo.get(physicalCameraId).isColorOutputSupported()) {                 // No color output support, skip.                 continue;             }             StreamConfigurationMap configMap =                 properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             physicalConfigs.put(physicalCameraId, configMap);             physicalPreviewSizesMap.put(physicalCameraId,                     getSupportedPreviewSizes(physicalCameraId, mCameraManager, PREVIEW_SIZE_BOUND));         }          // Find display size from window service.         Context context = mActivityRule.getActivity().getApplicationContext();         WindowManager windowManager =                 (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);         Display display = windowManager.getDefaultDisplay();          int displayWidth = display.getWidth();         int displayHeight = display.getHeight();          if (displayHeight > displayWidth) {             displayHeight = displayWidth;             displayWidth = display.getHeight();         }          StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         for (Size previewSize : previewSizes) {             dualPhysicalCameraIds.clear();             // Skip preview sizes larger than screen size             if (previewSize.getWidth() > displayWidth ||                     previewSize.getHeight() > displayHeight) {                 continue;             }              final long minFrameDuration = config.getOutputMinFrameDuration(                    ImageFormat.YUV_420_888, previewSize);              ArrayList<String> supportedPhysicalCameras = new ArrayList<String>();             for (String physicalCameraId : physicalCameraIds) {                 List<Size> physicalPreviewSizes = physicalPreviewSizesMap.get(physicalCameraId);                 if (physicalPreviewSizes != null && physicalPreviewSizes.contains(previewSize)) {                    long minDurationPhysical =                            physicalConfigs.get(physicalCameraId).getOutputMinFrameDuration(                            ImageFormat.YUV_420_888, previewSize);                    if (minDurationPhysical <= minFrameDuration) {                         dualPhysicalCameraIds.add(physicalCameraId);                         if (dualPhysicalCameraIds.size() == 2) {                             return previewSize;                         }                    }                 }             }         }         return null;     }      /**      * Validate that physical cameras are not cropping too much.      *      * This is to make sure physical processed streams have at least the same field of view as      * the logical stream, or the maximum field of view of the physical camera, whichever is      * smaller.      *      * Note that the FOV is calculated in the directio of sensor width.      */     private void validatePhysicalCamerasFov(TotalCaptureResult totalCaptureResult,             List<String> physicalCameraIds) {         Rect cropRegion = totalCaptureResult.get(CaptureResult.SCALER_CROP_REGION);         Float focalLength = totalCaptureResult.get(CaptureResult.LENS_FOCAL_LENGTH);         Float zoomRatio = totalCaptureResult.get(CaptureResult.CONTROL_ZOOM_RATIO);         Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();         SizeF sensorSize = mStaticInfo.getValueFromKeyNonNull(                 CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);          // Assume subject distance >> focal length, and subject distance >> camera baseline.         double fov = 2 * Math.toDegrees(Math.atan2(sensorSize.getWidth() * cropRegion.width() /                 (2 * zoomRatio * activeArraySize.width()),  focalLength));          Map<String, CaptureResult> physicalResultsDual =                     totalCaptureResult.getPhysicalCameraResults();         for (String physicalId : physicalCameraIds) {             StaticMetadata physicalStaticInfo = mAllStaticInfo.get(physicalId);             CaptureResult physicalResult = physicalResultsDual.get(physicalId);             Rect physicalCropRegion = physicalResult.get(CaptureResult.SCALER_CROP_REGION);             Float physicalFocalLength = physicalResult.get(CaptureResult.LENS_FOCAL_LENGTH);             Float physicalZoomRatio = physicalResult.get(CaptureResult.CONTROL_ZOOM_RATIO);             Rect physicalActiveArraySize = physicalStaticInfo.getActiveArraySizeChecked();             SizeF physicalSensorSize = mStaticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);              double physicalFov = 2 * Math.toDegrees(Math.atan2(                     physicalSensorSize.getWidth() * physicalCropRegion.width() /                     (2 * physicalZoomRatio * physicalActiveArraySize.width()), physicalFocalLength));              double maxPhysicalFov = 2 * Math.toDegrees(Math.atan2(physicalSensorSize.getWidth() / 2,                     physicalFocalLength));             double expectedPhysicalFov = Math.min(maxPhysicalFov, fov);              if (VERBOSE) {                 Log.v(TAG, ""Logical camera Fov: "" + fov + "", maxPhyiscalFov: "" + maxPhysicalFov +                         "", physicalFov: "" + physicalFov);             }             assertTrue(""Physical stream FOV (Field of view) should be greater or equal to""                     + "" min(logical stream FOV, max physical stream FOV). Physical FOV: ""                     + physicalFov + "" vs min("" + fov + "", "" + maxPhysicalFov,                     physicalFov - expectedPhysicalFov > -FOV_THRESHOLD);         }     }      /**      * Test physical camera YUV streaming within a particular logical camera.      *      * Use 2 YUV streams with PREVIEW or smaller size.      */     private void testBasicPhysicalStreamingForCamera(String logicalCameraId,             List<String> physicalCameraIds, Size previewSize) throws Exception {         List<OutputConfiguration> outputConfigs = new ArrayList<>();         List<ImageReader> imageReaders = new ArrayList<>();          // Add 1 logical YUV stream         ImageReader logicalTarget = CameraTestUtils.makeImageReader(previewSize,                 ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,                 new ImageDropperListener(), mHandler);         imageReaders.add(logicalTarget);         outputConfigs.add(new OutputConfiguration(logicalTarget.getSurface()));          // Add physical YUV streams         if (physicalCameraIds.size() != 2) {             throw new IllegalArgumentException(""phyiscalCameraIds must contain 2 camera ids"");         }         List<ImageReader> physicalTargets = new ArrayList<>();         for (String physicalCameraId : physicalCameraIds) {             ImageReader physicalTarget = CameraTestUtils.makeImageReader(previewSize,                     ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,                     new ImageDropperListener(), mHandler);             OutputConfiguration config = new OutputConfiguration(physicalTarget.getSurface());             config.setPhysicalCameraId(physicalCameraId);             outputConfigs.add(config);             physicalTargets.add(physicalTarget);         }          SessionConfigSupport sessionConfigSupport = isSessionConfigSupported(                 mCamera, mHandler, outputConfigs, /*inputConfig*/ null,                 SessionConfiguration.SESSION_REGULAR, false/*defaultSupport*/);         assertTrue(""Session configuration query for logical camera failed with error"",                 !sessionConfigSupport.error);         if (!sessionConfigSupport.callSupported) {             return;         }          mSessionListener = new BlockingSessionCallback();         mSessionWaiter = mSessionListener.getStateWaiter();         mSession = configureCameraSessionWithConfig(mCamera, outputConfigs,                 mSessionListener, mHandler);         if (!sessionConfigSupport.configSupported) {             mSessionWaiter.waitForState(BlockingSessionCallback.SESSION_CONFIGURE_FAILED,                     SESSION_CONFIGURE_TIMEOUT_MS);             return;         }          // Stream logical YUV stream and note down the FPS         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         requestBuilder.addTarget(logicalTarget.getSurface());          SimpleCaptureCallback simpleResultListener =                 new SimpleCaptureCallback();         StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         final long minFrameDuration = config.getOutputMinFrameDuration(                 ImageFormat.YUV_420_888, previewSize);         if (minFrameDuration > 0) {             Range<Integer> targetRange = getSuitableFpsRangeForDuration(logicalCameraId,                     minFrameDuration);             requestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, targetRange);         }         mSession.setRepeatingRequest(requestBuilder.build(),                 simpleResultListener, mHandler);          // Converge AE         waitForAeStable(simpleResultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);          if (mStaticInfo.isAeLockSupported()) {             // Lock AE if supported.             requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);             mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,                     mHandler);             waitForResultValue(simpleResultListener, CaptureResult.CONTROL_AE_STATE,                     CaptureResult.CONTROL_AE_STATE_LOCKED, NUM_RESULTS_WAIT_TIMEOUT);         }          // Verify results         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,                 mStaticInfo, mAllStaticInfo, null/*requestedPhysicalIds*/,                 requestBuilder, NUM_FRAMES_CHECKED);          // Collect timestamps for one logical stream only.         long prevTimestamp = -1;         long[] logicalTimestamps = new long[NUM_FRAMES_CHECKED];         for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {             TotalCaptureResult totalCaptureResult =                     simpleResultListener.getTotalCaptureResult(                     CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);             logicalTimestamps[i] = totalCaptureResult.get(CaptureResult.SENSOR_TIMESTAMP);         }          double logicalAvgDurationMs = (logicalTimestamps[NUM_FRAMES_CHECKED-1] -                 logicalTimestamps[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));          // Request one logical stream and one physical stream         simpleResultListener = new SimpleCaptureCallback();         requestBuilder.addTarget(physicalTargets.get(1).getSurface());         mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,                 mHandler);          // Verify results for physical streams request.         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,                 mStaticInfo, mAllStaticInfo, physicalCameraIds.subList(1, 2), requestBuilder,                 NUM_FRAMES_CHECKED);           // Start requesting on both logical and physical streams         SimpleCaptureCallback simpleResultListenerDual =                 new SimpleCaptureCallback();         for (ImageReader physicalTarget : physicalTargets) {             requestBuilder.addTarget(physicalTarget.getSurface());         }         mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListenerDual,                 mHandler);          // Verify results for physical streams request.         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListenerDual,                 mStaticInfo, mAllStaticInfo, physicalCameraIds, requestBuilder,                 NUM_FRAMES_CHECKED);          // Acquire the timestamps of the physical camera.         long[] logicalTimestamps2 = new long[NUM_FRAMES_CHECKED];         long [][] physicalTimestamps = new long[physicalTargets.size()][];         for (int i = 0; i < physicalTargets.size(); i++) {             physicalTimestamps[i] = new long[NUM_FRAMES_CHECKED];         }         for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {             TotalCaptureResult totalCaptureResultDual =                     simpleResultListenerDual.getTotalCaptureResult(                     CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);             logicalTimestamps2[i] = totalCaptureResultDual.get(CaptureResult.SENSOR_TIMESTAMP);              int index = 0;             Map<String, CaptureResult> physicalResultsDual =                     totalCaptureResultDual.getPhysicalCameraResults();             for (String physicalId : physicalCameraIds) {                  if (physicalResultsDual.containsKey(physicalId)) {                      physicalTimestamps[index][i] = physicalResultsDual.get(physicalId).get(                              CaptureResult.SENSOR_TIMESTAMP);                  } else {                      physicalTimestamps[index][i] = -1;                  }                  index++;             }         }          // Check both logical and physical streams' crop region, and make sure their FOVs         // are similar.         TotalCaptureResult totalCaptureResult =                 simpleResultListenerDual.getTotalCaptureResult(                 CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);         validatePhysicalCamerasFov(totalCaptureResult, physicalCameraIds);          // Check timestamp monolithity for individual camera and across cameras         for (int i = 0; i < NUM_FRAMES_CHECKED-1; i++) {             assertTrue(""Logical camera timestamp must monolithically increase"",                     logicalTimestamps2[i] < logicalTimestamps2[i+1]);         }         for (int i = 0; i < physicalCameraIds.size(); i++) {             for (int j = 0 ; j < NUM_FRAMES_CHECKED-1; j++) {                 if (physicalTimestamps[i][j] != -1 && physicalTimestamps[i][j+1] != -1) {                     assertTrue(""Physical camera timestamp must monolithically increase"",                             physicalTimestamps[i][j] < physicalTimestamps[i][j+1]);                 }                 if (j > 0 && physicalTimestamps[i][j] != -1) {                     assertTrue(""Physical camera's timestamp N must be greater than logical "" +                             ""camera's timestamp N-1"",                             physicalTimestamps[i][j] > logicalTimestamps[j-1]);                 }                 if (physicalTimestamps[i][j] != -1) {                     assertTrue(""Physical camera's timestamp N must be less than logical camera's "" +                             ""timestamp N+1"", physicalTimestamps[i][j] > logicalTimestamps[j+1]);                 }             }         }          double logicalAvgDurationMs2 = (logicalTimestamps2[NUM_FRAMES_CHECKED-1] -                 logicalTimestamps2[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));         // Check CALIBRATED synchronization between physical cameras         Integer syncType = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE);         double fpsRatio = (logicalAvgDurationMs2 - logicalAvgDurationMs)/logicalAvgDurationMs;         if (syncType == CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED) {             // Check framerate doesn't slow down with physical streams             mCollector.expectTrue(                     ""The average frame duration with concurrent physical streams is"" +                     logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +                     "" ms for logical streams only"", fpsRatio <= FRAME_DURATION_THRESHOLD);              long maxTimestampDelta = 0;             for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {                 long delta = Math.abs(physicalTimestamps[0][i] - physicalTimestamps[1][i]);                 if (delta > maxTimestampDelta) {                     maxTimestampDelta = delta;                 }             }              Log.i(TAG, ""Maximum difference between physical camera timestamps: ""                     + maxTimestampDelta);              // The maximum timestamp difference should not be larger than the threshold.             mCollector.expectTrue(                     ""The maximum timestamp deltas between the physical cameras ""                     + maxTimestampDelta + "" is larger than "" + MAX_TIMESTAMP_DIFFERENCE_THRESHOLD,                     maxTimestampDelta <= MAX_TIMESTAMP_DIFFERENCE_THRESHOLD);         } else {             // Do not enforce fps check for APPROXIMATE synced device.             if (fpsRatio > FRAME_DURATION_THRESHOLD) {                 Log.w(TAG, ""The average frame duration with concurrent physical streams is"" +                         logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +                         "" ms for logical streams only"");             }         }          if (VERBOSE) {             while (simpleResultListenerDual.hasMoreFailures()) {                 ArrayList<CaptureFailure> failures =                     simpleResultListenerDual.getCaptureFailures(/*maxNumFailures*/ 1);                 for (CaptureFailure failure : failures) {                     String physicalCameraId = failure.getPhysicalCameraId();                     if (physicalCameraId != null) {                         Log.v(TAG, ""Capture result failure for physical camera id: "" +                                 physicalCameraId);                     }                 }             }         }          // Stop preview         if (mSession != null) {             mSession.close();         }     }      /**      * The CDD defines a handheld device as one that has a battery and a screen size between      * 2.5 and 8 inches.      */     private boolean isHandheldDevice() throws Exception {         double screenInches = getScreenSizeInInches();         return deviceHasBattery() && screenInches >= 2.5 && screenInches <= 8.0;     }      private boolean deviceHasBattery() {         final Intent batteryInfo = mContext.registerReceiver(null,                 new IntentFilter(Intent.ACTION_BATTERY_CHANGED));         return batteryInfo != null && batteryInfo.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);     }      private double getScreenSizeInInches() {         DisplayMetrics dm = new DisplayMetrics();         mWindowManager.getDefaultDisplay().getMetrics(dm);         double widthInInchesSquared = Math.pow(dm.widthPixels/dm.xdpi,2);         double heightInInchesSquared = Math.pow(dm.heightPixels/dm.ydpi,2);         return Math.sqrt(widthInInchesSquared + heightInInchesSquared);     } } ",7.3.13/C-1-1,,07031300.670101,STRING_TYPE_HINGE_ANGLE C-1-1 TYPE_HINGLE_ANGLE 7.3.13,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.LogicalCameraDeviceTest:testDefaultFov()],,C-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/LogicalCameraDeviceTest.java,,
,7.3.13,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.3.13/C-1-2,,07031300.670102,C-1-2 7.3.13,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.4.5.3,C-1-1,,android.hardware.camera2.cts.LogicalCameraDeviceTest,testDefaultFov(),CtsCameraTestCases,"     @CddTest(requirement=""7.5.4/C-1-1"")     public void testDefaultFov() throws Exception {         final double MIN_FOV = 50;         final double MAX_FOV = 90;         if (!isHandheldDevice()) {             return;         }         for (String id : mCameraIdsUnderTest) {             try {                 Log.i(TAG, ""Testing Camera "" + id);                  StaticMetadata staticInfo = mAllStaticInfo.get(id);                 if (!staticInfo.isColorOutputSupported()) {                     Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");                     continue;                 }                  if (!staticInfo.isLogicalMultiCamera()) {                     Log.i(TAG, ""Camera "" + id + "" is not a logical multi-camera, skipping"");                     continue;                 }                  SizeF physicalSize = staticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);                 double physicalDiag = Math.sqrt(Math.pow(physicalSize.getWidth(), 2)                         + Math.pow(physicalSize.getHeight(), 2));                 Rect activeArraySize = staticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);                  openDevice(id);                 for (int template : sTemplates) {                     try {                         CaptureRequest.Builder requestBuilder =                                 mCamera.createCaptureRequest(template);                         Float requestFocalLength = requestBuilder.get(                                 CaptureRequest.LENS_FOCAL_LENGTH);                         assertNotNull(""LENS_FOCAL_LENGTH must not be null"", requestFocalLength);                          Float requestZoomRatio = requestBuilder.get(                                 CaptureRequest.CONTROL_ZOOM_RATIO);                         assertNotNull(""CONTROL_ZOOM_RATIO must not be null"", requestZoomRatio);                         Rect requestCropRegion = requestBuilder.get(                                 CaptureRequest.SCALER_CROP_REGION);                         assertNotNull(""SCALER_CROP_REGION must not be null"", requestCropRegion);                         float totalZoomRatio = Math.min(                                 1.0f * activeArraySize.width() / requestCropRegion.width(),                                 1.0f * activeArraySize.height() / requestCropRegion.height()) *                                 requestZoomRatio;                          double fov = 2 *                                 Math.toDegrees(Math.atan2(physicalDiag/(2 * totalZoomRatio),                                 requestFocalLength));                          Log.v(TAG, ""Camera "" +  id + "" template "" + template +                                 ""'s default FOV is "" + fov);                         mCollector.expectInRange(""Camera "" +  id + "" template "" + template +                                 ""'s default FOV must fall between [50, 90] degrees"",                                 fov, MIN_FOV, MAX_FOV);                     } catch (IllegalArgumentException e) {                         if (template == CameraDevice.TEMPLATE_MANUAL &&                                 !staticInfo.isCapabilitySupported(CameraCharacteristics.                                 REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {                             // OK                         } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG &&                                 !staticInfo.isCapabilitySupported(CameraCharacteristics.                                 REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)) {                             // OK.                         } else {                             throw e; // rethrow                         }                     }                 }             } finally {                 closeDevice();             }         }     }      /**      * Find a common preview size that's supported by both the logical camera and      * two of the underlying physical cameras.      */     private Size findCommonPreviewSize(String cameraId,             List<String> dualPhysicalCameraIds) throws Exception {          Set<String> physicalCameraIds =                 mStaticInfo.getCharacteristics().getPhysicalCameraIds();         assertTrue(""Logical camera must contain at least 2 physical camera ids"",                 physicalCameraIds.size() >= 2);          List<Size> previewSizes = getSupportedPreviewSizes(                 cameraId, mCameraManager, PREVIEW_SIZE_BOUND);         HashMap<String, List<Size>> physicalPreviewSizesMap = new HashMap<String, List<Size>>();         HashMap<String, StreamConfigurationMap> physicalConfigs = new HashMap<>();         for (String physicalCameraId : physicalCameraIds) {             CameraCharacteristics properties =                     mCameraManager.getCameraCharacteristics(physicalCameraId);             assertNotNull(""Can't get camera characteristics!"", properties);             if (!mAllStaticInfo.get(physicalCameraId).isColorOutputSupported()) {                 // No color output support, skip.                 continue;             }             StreamConfigurationMap configMap =                 properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             physicalConfigs.put(physicalCameraId, configMap);             physicalPreviewSizesMap.put(physicalCameraId,                     getSupportedPreviewSizes(physicalCameraId, mCameraManager, PREVIEW_SIZE_BOUND));         }          // Find display size from window service.         Context context = mActivityRule.getActivity().getApplicationContext();         WindowManager windowManager =                 (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);         Display display = windowManager.getDefaultDisplay();          int displayWidth = display.getWidth();         int displayHeight = display.getHeight();          if (displayHeight > displayWidth) {             displayHeight = displayWidth;             displayWidth = display.getHeight();         }          StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         for (Size previewSize : previewSizes) {             dualPhysicalCameraIds.clear();             // Skip preview sizes larger than screen size             if (previewSize.getWidth() > displayWidth ||                     previewSize.getHeight() > displayHeight) {                 continue;             }              final long minFrameDuration = config.getOutputMinFrameDuration(                    ImageFormat.YUV_420_888, previewSize);              ArrayList<String> supportedPhysicalCameras = new ArrayList<String>();             for (String physicalCameraId : physicalCameraIds) {                 List<Size> physicalPreviewSizes = physicalPreviewSizesMap.get(physicalCameraId);                 if (physicalPreviewSizes != null && physicalPreviewSizes.contains(previewSize)) {                    long minDurationPhysical =                            physicalConfigs.get(physicalCameraId).getOutputMinFrameDuration(                            ImageFormat.YUV_420_888, previewSize);                    if (minDurationPhysical <= minFrameDuration) {                         dualPhysicalCameraIds.add(physicalCameraId);                         if (dualPhysicalCameraIds.size() == 2) {                             return previewSize;                         }                    }                 }             }         }         return null;     }      /**      * Validate that physical cameras are not cropping too much.      *      * This is to make sure physical processed streams have at least the same field of view as      * the logical stream, or the maximum field of view of the physical camera, whichever is      * smaller.      *      * Note that the FOV is calculated in the directio of sensor width.      */     private void validatePhysicalCamerasFov(TotalCaptureResult totalCaptureResult,             List<String> physicalCameraIds) {         Rect cropRegion = totalCaptureResult.get(CaptureResult.SCALER_CROP_REGION);         Float focalLength = totalCaptureResult.get(CaptureResult.LENS_FOCAL_LENGTH);         Float zoomRatio = totalCaptureResult.get(CaptureResult.CONTROL_ZOOM_RATIO);         Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();         SizeF sensorSize = mStaticInfo.getValueFromKeyNonNull(                 CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);          // Assume subject distance >> focal length, and subject distance >> camera baseline.         double fov = 2 * Math.toDegrees(Math.atan2(sensorSize.getWidth() * cropRegion.width() /                 (2 * zoomRatio * activeArraySize.width()),  focalLength));          Map<String, CaptureResult> physicalResultsDual =                     totalCaptureResult.getPhysicalCameraResults();         for (String physicalId : physicalCameraIds) {             StaticMetadata physicalStaticInfo = mAllStaticInfo.get(physicalId);             CaptureResult physicalResult = physicalResultsDual.get(physicalId);             Rect physicalCropRegion = physicalResult.get(CaptureResult.SCALER_CROP_REGION);             Float physicalFocalLength = physicalResult.get(CaptureResult.LENS_FOCAL_LENGTH);             Float physicalZoomRatio = physicalResult.get(CaptureResult.CONTROL_ZOOM_RATIO);             Rect physicalActiveArraySize = physicalStaticInfo.getActiveArraySizeChecked();             SizeF physicalSensorSize = mStaticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);              double physicalFov = 2 * Math.toDegrees(Math.atan2(                     physicalSensorSize.getWidth() * physicalCropRegion.width() /                     (2 * physicalZoomRatio * physicalActiveArraySize.width()), physicalFocalLength));              double maxPhysicalFov = 2 * Math.toDegrees(Math.atan2(physicalSensorSize.getWidth() / 2,                     physicalFocalLength));             double expectedPhysicalFov = Math.min(maxPhysicalFov, fov);              if (VERBOSE) {                 Log.v(TAG, ""Logical camera Fov: "" + fov + "", maxPhyiscalFov: "" + maxPhysicalFov +                         "", physicalFov: "" + physicalFov);             }             assertTrue(""Physical stream FOV (Field of view) should be greater or equal to""                     + "" min(logical stream FOV, max physical stream FOV). Physical FOV: ""                     + physicalFov + "" vs min("" + fov + "", "" + maxPhysicalFov,                     physicalFov - expectedPhysicalFov > -FOV_THRESHOLD);         }     }      /**      * Test physical camera YUV streaming within a particular logical camera.      *      * Use 2 YUV streams with PREVIEW or smaller size.      */     private void testBasicPhysicalStreamingForCamera(String logicalCameraId,             List<String> physicalCameraIds, Size previewSize) throws Exception {         List<OutputConfiguration> outputConfigs = new ArrayList<>();         List<ImageReader> imageReaders = new ArrayList<>();          // Add 1 logical YUV stream         ImageReader logicalTarget = CameraTestUtils.makeImageReader(previewSize,                 ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,                 new ImageDropperListener(), mHandler);         imageReaders.add(logicalTarget);         outputConfigs.add(new OutputConfiguration(logicalTarget.getSurface()));          // Add physical YUV streams         if (physicalCameraIds.size() != 2) {             throw new IllegalArgumentException(""phyiscalCameraIds must contain 2 camera ids"");         }         List<ImageReader> physicalTargets = new ArrayList<>();         for (String physicalCameraId : physicalCameraIds) {             ImageReader physicalTarget = CameraTestUtils.makeImageReader(previewSize,                     ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,                     new ImageDropperListener(), mHandler);             OutputConfiguration config = new OutputConfiguration(physicalTarget.getSurface());             config.setPhysicalCameraId(physicalCameraId);             outputConfigs.add(config);             physicalTargets.add(physicalTarget);         }          SessionConfigSupport sessionConfigSupport = isSessionConfigSupported(                 mCamera, mHandler, outputConfigs, /*inputConfig*/ null,                 SessionConfiguration.SESSION_REGULAR, false/*defaultSupport*/);         assertTrue(""Session configuration query for logical camera failed with error"",                 !sessionConfigSupport.error);         if (!sessionConfigSupport.callSupported) {             return;         }          mSessionListener = new BlockingSessionCallback();         mSessionWaiter = mSessionListener.getStateWaiter();         mSession = configureCameraSessionWithConfig(mCamera, outputConfigs,                 mSessionListener, mHandler);         if (!sessionConfigSupport.configSupported) {             mSessionWaiter.waitForState(BlockingSessionCallback.SESSION_CONFIGURE_FAILED,                     SESSION_CONFIGURE_TIMEOUT_MS);             return;         }          // Stream logical YUV stream and note down the FPS         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         requestBuilder.addTarget(logicalTarget.getSurface());          SimpleCaptureCallback simpleResultListener =                 new SimpleCaptureCallback();         StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         final long minFrameDuration = config.getOutputMinFrameDuration(                 ImageFormat.YUV_420_888, previewSize);         if (minFrameDuration > 0) {             Range<Integer> targetRange = getSuitableFpsRangeForDuration(logicalCameraId,                     minFrameDuration);             requestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, targetRange);         }         mSession.setRepeatingRequest(requestBuilder.build(),                 simpleResultListener, mHandler);          // Converge AE         waitForAeStable(simpleResultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);          if (mStaticInfo.isAeLockSupported()) {             // Lock AE if supported.             requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);             mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,                     mHandler);             waitForResultValue(simpleResultListener, CaptureResult.CONTROL_AE_STATE,                     CaptureResult.CONTROL_AE_STATE_LOCKED, NUM_RESULTS_WAIT_TIMEOUT);         }          // Verify results         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,                 mStaticInfo, mAllStaticInfo, null/*requestedPhysicalIds*/,                 requestBuilder, NUM_FRAMES_CHECKED);          // Collect timestamps for one logical stream only.         long prevTimestamp = -1;         long[] logicalTimestamps = new long[NUM_FRAMES_CHECKED];         for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {             TotalCaptureResult totalCaptureResult =                     simpleResultListener.getTotalCaptureResult(                     CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);             logicalTimestamps[i] = totalCaptureResult.get(CaptureResult.SENSOR_TIMESTAMP);         }          double logicalAvgDurationMs = (logicalTimestamps[NUM_FRAMES_CHECKED-1] -                 logicalTimestamps[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));          // Request one logical stream and one physical stream         simpleResultListener = new SimpleCaptureCallback();         requestBuilder.addTarget(physicalTargets.get(1).getSurface());         mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,                 mHandler);          // Verify results for physical streams request.         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,                 mStaticInfo, mAllStaticInfo, physicalCameraIds.subList(1, 2), requestBuilder,                 NUM_FRAMES_CHECKED);           // Start requesting on both logical and physical streams         SimpleCaptureCallback simpleResultListenerDual =                 new SimpleCaptureCallback();         for (ImageReader physicalTarget : physicalTargets) {             requestBuilder.addTarget(physicalTarget.getSurface());         }         mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListenerDual,                 mHandler);          // Verify results for physical streams request.         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListenerDual,                 mStaticInfo, mAllStaticInfo, physicalCameraIds, requestBuilder,                 NUM_FRAMES_CHECKED);          // Acquire the timestamps of the physical camera.         long[] logicalTimestamps2 = new long[NUM_FRAMES_CHECKED];         long [][] physicalTimestamps = new long[physicalTargets.size()][];         for (int i = 0; i < physicalTargets.size(); i++) {             physicalTimestamps[i] = new long[NUM_FRAMES_CHECKED];         }         for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {             TotalCaptureResult totalCaptureResultDual =                     simpleResultListenerDual.getTotalCaptureResult(                     CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);             logicalTimestamps2[i] = totalCaptureResultDual.get(CaptureResult.SENSOR_TIMESTAMP);              int index = 0;             Map<String, CaptureResult> physicalResultsDual =                     totalCaptureResultDual.getPhysicalCameraResults();             for (String physicalId : physicalCameraIds) {                  if (physicalResultsDual.containsKey(physicalId)) {                      physicalTimestamps[index][i] = physicalResultsDual.get(physicalId).get(                              CaptureResult.SENSOR_TIMESTAMP);                  } else {                      physicalTimestamps[index][i] = -1;                  }                  index++;             }         }          // Check both logical and physical streams' crop region, and make sure their FOVs         // are similar.         TotalCaptureResult totalCaptureResult =                 simpleResultListenerDual.getTotalCaptureResult(                 CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);         validatePhysicalCamerasFov(totalCaptureResult, physicalCameraIds);          // Check timestamp monolithity for individual camera and across cameras         for (int i = 0; i < NUM_FRAMES_CHECKED-1; i++) {             assertTrue(""Logical camera timestamp must monolithically increase"",                     logicalTimestamps2[i] < logicalTimestamps2[i+1]);         }         for (int i = 0; i < physicalCameraIds.size(); i++) {             for (int j = 0 ; j < NUM_FRAMES_CHECKED-1; j++) {                 if (physicalTimestamps[i][j] != -1 && physicalTimestamps[i][j+1] != -1) {                     assertTrue(""Physical camera timestamp must monolithically increase"",                             physicalTimestamps[i][j] < physicalTimestamps[i][j+1]);                 }                 if (j > 0 && physicalTimestamps[i][j] != -1) {                     assertTrue(""Physical camera's timestamp N must be greater than logical "" +                             ""camera's timestamp N-1"",                             physicalTimestamps[i][j] > logicalTimestamps[j-1]);                 }                 if (physicalTimestamps[i][j] != -1) {                     assertTrue(""Physical camera's timestamp N must be less than logical camera's "" +                             ""timestamp N+1"", physicalTimestamps[i][j] > logicalTimestamps[j+1]);                 }             }         }          double logicalAvgDurationMs2 = (logicalTimestamps2[NUM_FRAMES_CHECKED-1] -                 logicalTimestamps2[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));         // Check CALIBRATED synchronization between physical cameras         Integer syncType = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE);         double fpsRatio = (logicalAvgDurationMs2 - logicalAvgDurationMs)/logicalAvgDurationMs;         if (syncType == CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED) {             // Check framerate doesn't slow down with physical streams             mCollector.expectTrue(                     ""The average frame duration with concurrent physical streams is"" +                     logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +                     "" ms for logical streams only"", fpsRatio <= FRAME_DURATION_THRESHOLD);              long maxTimestampDelta = 0;             for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {                 long delta = Math.abs(physicalTimestamps[0][i] - physicalTimestamps[1][i]);                 if (delta > maxTimestampDelta) {                     maxTimestampDelta = delta;                 }             }              Log.i(TAG, ""Maximum difference between physical camera timestamps: ""                     + maxTimestampDelta);              // The maximum timestamp difference should not be larger than the threshold.             mCollector.expectTrue(                     ""The maximum timestamp deltas between the physical cameras ""                     + maxTimestampDelta + "" is larger than "" + MAX_TIMESTAMP_DIFFERENCE_THRESHOLD,                     maxTimestampDelta <= MAX_TIMESTAMP_DIFFERENCE_THRESHOLD);         } else {             // Do not enforce fps check for APPROXIMATE synced device.             if (fpsRatio > FRAME_DURATION_THRESHOLD) {                 Log.w(TAG, ""The average frame duration with concurrent physical streams is"" +                         logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +                         "" ms for logical streams only"");             }         }          if (VERBOSE) {             while (simpleResultListenerDual.hasMoreFailures()) {                 ArrayList<CaptureFailure> failures =                     simpleResultListenerDual.getCaptureFailures(/*maxNumFailures*/ 1);                 for (CaptureFailure failure : failures) {                     String physicalCameraId = failure.getPhysicalCameraId();                     if (physicalCameraId != null) {                         Log.v(TAG, ""Capture result failure for physical camera id: "" +                                 physicalCameraId);                     }                 }             }         }          // Stop preview         if (mSession != null) {             mSession.close();         }     }      /**      * The CDD defines a handheld device as one that has a battery and a screen size between      * 2.5 and 8 inches.      */     private boolean isHandheldDevice() throws Exception {         double screenInches = getScreenSizeInInches();         return deviceHasBattery() && screenInches >= 2.5 && screenInches <= 8.0;     }      private boolean deviceHasBattery() {         final Intent batteryInfo = mContext.registerReceiver(null,                 new IntentFilter(Intent.ACTION_BATTERY_CHANGED));         return batteryInfo != null && batteryInfo.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);     }      private double getScreenSizeInInches() {         DisplayMetrics dm = new DisplayMetrics();         mWindowManager.getDefaultDisplay().getMetrics(dm);         double widthInInchesSquared = Math.pow(dm.widthPixels/dm.xdpi,2);         double heightInInchesSquared = Math.pow(dm.heightPixels/dm.ydpi,2);         return Math.sqrt(widthInInchesSquared + heightInInchesSquared);     } } ",7.4.5.3/C-1-1,,07040503.670101,ACTION_CAPTIVE_PORTAL_SIGN_IN C-1-1 7.4.5.3,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.LogicalCameraDeviceTest:testDefaultFov()],,C-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/LogicalCameraDeviceTest.java,,
,7.4.5.3,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.4.5.3/C-1-2,,07040503.670102,C-1-2 7.4.5.3,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.4.5.3,C-1-3,,android.net.cts.IpConfigurationTest,setUp(),,"/*  *.  */  package android.net.cts;  import static com.android.testutils.ParcelUtilsKt.assertParcelSane;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull;  import android.net.IpConfiguration; import android.net.LinkAddress; import android.net.ProxyInfo; import android.net.StaticIpConfiguration;  import androidx.test.runner.AndroidJUnit4;  import libcore.net.InetAddressUtils;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.net.InetAddress; import java.util.ArrayList;  @RunWith(AndroidJUnit4.class) public final class IpConfigurationTest {     private static final LinkAddress LINKADDR = new LinkAddress(""192.0.2.2/25"");     private static final InetAddress GATEWAY = InetAddressUtils.parseNumericAddress(""192.0.2.1"");     private static final InetAddress DNS1 = InetAddressUtils.parseNumericAddress(""8.8.8.8"");     private static final InetAddress DNS2 = InetAddressUtils.parseNumericAddress(""8.8.4.4"");     private static final String DOMAINS = ""example.com"";      private static final ArrayList<InetAddress> dnsServers = new ArrayList<>();      private StaticIpConfiguration mStaticIpConfig;     private ProxyInfo mProxy;      @Before     public void setUp() {         dnsServers.add(DNS1);         dnsServers.add(DNS2);         mStaticIpConfig = new StaticIpConfiguration.Builder()                 .setIpAddress(LINKADDR)                 .setGateway(GATEWAY)                 .setDnsServers(dnsServers)                 .setDomains(DOMAINS)                 .build();          mProxy = ProxyInfo.buildDirectProxy(""test"", 8888);     }      ",7.4.5.3/C-1-3,,07040503.670103,C-1-3 7.4.5.3 DNS,Test[None]:[android.net.cts.IpConfigurationTest:setUp()],,DNS,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpConfigurationTest.java,,
,7.4.5.3,C-1-4,,android.net.cts.IpConfigurationTest,setUp(),,"/*  *.  */  package android.net.cts;  import static com.android.testutils.ParcelUtilsKt.assertParcelSane;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull;  import android.net.IpConfiguration; import android.net.LinkAddress; import android.net.ProxyInfo; import android.net.StaticIpConfiguration;  import androidx.test.runner.AndroidJUnit4;  import libcore.net.InetAddressUtils;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.net.InetAddress; import java.util.ArrayList;  @RunWith(AndroidJUnit4.class) public final class IpConfigurationTest {     private static final LinkAddress LINKADDR = new LinkAddress(""192.0.2.2/25"");     private static final InetAddress GATEWAY = InetAddressUtils.parseNumericAddress(""192.0.2.1"");     private static final InetAddress DNS1 = InetAddressUtils.parseNumericAddress(""8.8.8.8"");     private static final InetAddress DNS2 = InetAddressUtils.parseNumericAddress(""8.8.4.4"");     private static final String DOMAINS = ""example.com"";      private static final ArrayList<InetAddress> dnsServers = new ArrayList<>();      private StaticIpConfiguration mStaticIpConfig;     private ProxyInfo mProxy;      @Before     public void setUp() {         dnsServers.add(DNS1);         dnsServers.add(DNS2);         mStaticIpConfig = new StaticIpConfiguration.Builder()                 .setIpAddress(LINKADDR)                 .setGateway(GATEWAY)                 .setDnsServers(dnsServers)                 .setDomains(DOMAINS)                 .build();          mProxy = ProxyInfo.buildDirectProxy(""test"", 8888);     }      ",7.4.5.3/C-1-4,,07040503.670104,7.4.5.3 LinkProperties.html android.net.LinkProperties.getPrivateDnsServerName android.net.LinkProperties.isPrivateDnsActive DNS C-1-4,Test[None]:[android.net.cts.IpConfigurationTest:setUp()],,DNS,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpConfigurationTest.java,,
,7.4.5.3,C-1-5,,android.suspendapps.cts.DialogTests,testInterceptorActivity_moreDetails(),,"     public void testInterceptorActivity_moreDetails() throws Exception {         final SuspendDialogInfo dialogInfo = new SuspendDialogInfo.Builder()                 .setIcon(R.drawable.ic_settings)                 .setTitle(R.string.dialog_title)                 .setMessage(R.string.dialog_message)                 .setNeutralButtonText(R.string.more_details_button_text)                 .build();         SuspendTestUtils.suspend(null, null, dialogInfo);         // Ensure test app's activity is stopped before proceeding.         assertTrue(mTestAppInterface.awaitTestActivityStop());          startTestAppActivity(null);         // Test activity should not start.         assertNull(""Test activity started while suspended"",                 mTestAppInterface.awaitTestActivityStart(5_000));          // The dialog should have correct specifications         final String expectedTitle = mContext.getResources().getString(R.string.dialog_title);         final String expectedMessage = mContext.getResources().getString(R.string.dialog_message,                 TEST_APP_LABEL);         final String expectedButtonText = mContext.getResources().getString(                 R.string.more_details_button_text);          assertNotNull(""Given dialog title: "" + expectedTitle + "" not shown"",                 mUiDevice.wait(Until.findObject(By.text(expectedTitle)), UI_TIMEOUT_MS));         assertNotNull(""Given dialog message: "" + expectedMessage + "" not shown"",                 mUiDevice.findObject(By.text(expectedMessage)));         // Sometimes, button texts can have styles that override case (e.g. b/134033532)         final Pattern buttonTextIgnoreCase = Pattern.compile(Pattern.quote(expectedButtonText),                 Pattern.CASE_INSENSITIVE);         final UiObject2 moreDetailsButton = mUiDevice.findObject(                 By.clickable(true).text(buttonTextIgnoreCase));         assertNotNull(expectedButtonText + "" button not shown"", moreDetailsButton);          // Tapping on the neutral button should start the correct intent.         moreDetailsButton.click();         final Intent incomingIntent = sIncomingIntent.poll(30, TimeUnit.SECONDS);         assertNotNull(incomingIntent);         assertEquals(Intent.ACTION_SHOW_SUSPENDED_APP_DETAILS, incomingIntent.getAction());         assertEquals(""Wrong package name sent with "" + Intent.ACTION_SHOW_SUSPENDED_APP_DETAILS,                 TEST_APP_PACKAGE_NAME, incomingIntent.getStringExtra(Intent.EXTRA_PACKAGE_NAME));     }      @After     public void tearDown() {         if (mTestAppInterface != null) {             mTestAppInterface.disconnect();         }     } } ",7.4.5.3/C-1-5,,07040503.670105,android.net.ConnectivityManager.NetworkCallback ConnectivityManager.registerDefaultNetworkCallback 7.4.5.3 java.net.Socket connect() C-1-5 ConnectivityManager.getActiveNetwork,Test[None]:[android.suspendapps.cts.DialogTests:testInterceptorActivity_moreDetails()],,connect(),/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DialogTests.java,,
,7.4.8,C-1-2,,android.omapi.cts.OmapiTest,testOpenBasicChannelNonNullAid(),,"     public void testOpenBasicChannelNonNullAid() {         assumeTrue(supportOMAPIReaders());         try {             waitForConnection();             Reader[] readers = seService.getReaders();              for (Reader reader : readers) {                 Session session = null;                 Channel channel = null;                 try {                     session = reader.openSession();                     assertNotNull(""Could not open session"", session);                     channel = session.openBasicChannel(SELECTABLE_AID, (byte) 0x00);                 } finally {                     if (channel != null) channel.close();                     if (session != null) session.close();                 }                 if (reader.getName().startsWith(UICC_READER_PREFIX)) {                     assertNull(""Basic channel on UICC can be opened"", channel);                 } else {                     assertNotNull(""Basic Channel cannot be opened"", channel);                 }             }         } catch (Exception e) {             fail(""Unexpected Exception "" + e);         }     }      /** Tests Select API */     ",7.4.8/C-1-2,,07040800.670102,FEATURE_SE_OMAPI_UICC android.hardware.se.omapi.uicc android.hardware.se.omapi.ese android.hardware.se.omapi.sd FEATURE_SE_OMAPI_ESE FEATURE_SE_OMAPI_SD 7.4.8 C-1-2 UICC,Test[None]:[android.omapi.cts.OmapiTest:testOpenBasicChannelNonNullAid()],,UICC,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/secure_element/omapi/src/android/omapi/cts/OmapiTest.java,,
,7.5.4,C-0-12,,android.hardware.camera2.cts.NativeCameraDeviceTest,,CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import android.graphics.SurfaceTexture; import android.hardware.camera2.cts.testcases.Camera2SurfaceViewTestCase; import android.util.Log; import android.util.Size; import android.view.Surface;  import org.junit.runner.RunWith; import org.junit.runners.Parameterized; import org.junit.Test;  import static org.junit.Assert.assertTrue;  /**  * <p>Basic test for CameraManager class.</p>  */  @RunWith(Parameterized.class) public class NativeCameraDeviceTest extends Camera2SurfaceViewTestCase {     private static final String TAG = ""NativeCameraDeviceTest"";     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);      /** Load jni on initialization */     static {         Log.i(""NativeCameraDeviceTest"", ""before loadlibrary"");         System.loadLibrary(""ctscamera2_jni"");         Log.i(""NativeCameraDeviceTest"", ""after loadlibrary"");     }      ",7.5.4/C-0-12,,07050400.670012,C-0-12 7.5.4 android.hardware.Camera android.hardware.camera,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.NativeCameraDeviceTest:],,android.hardware.camera,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/NativeCameraDeviceTest.java,,
,9.1,C-2-1,,android.appwidget.cts.RequestPinAppWidgetTest,testPinWidget_launcher2(),,"     public void testPinWidget_launcher2() throws Exception {         runPinWidgetTest(""android.appwidget.cts.packages.launcher2"");     }      @CddTest(requirement=""3.8.2/C-2-1"")     public void verifyIsRequestPinAppWidgetSupported(String launcherPkg, boolean expectedSupport)         throws Exception {         setLauncher(launcherPkg + ""/"" + LAUNCHER_CLASS);          Context context = getInstrumentation().getContext();         assertEquals(expectedSupport,                 AppWidgetManager.getInstance(context).isRequestPinAppWidgetSupported());     }      ",9.1/C-2-1,,09010000.670201,Settings.html C-2-1 9.1 ACTION_MANAGE_OVERLAY_PERMISSION,Test[None]:[android.appwidget.cts.RequestPinAppWidgetTest:testPinWidget_launcher2()],,C-2-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/appwidget/src/android/appwidget/cts/RequestPinAppWidgetTest.java,,
,9.5,C-1-2,,android.uirendering.cts.testclasses.ExactCanvasTests,testUnclippedSaveLayerRounding(),,"     public void testUnclippedSaveLayerRounding() {         createTest()                 .addCanvasClient((canvas, width, height) -> {                     canvas.saveLayerAlpha(10.5f, 10.5f, 79.5f, 79.5f, 255);                     canvas.drawRect(20, 20, 70, 70, new Paint());                     canvas.restore();                 })                 .runWithVerifier(new RectVerifier(Color.WHITE, Color.BLACK,                         new Rect(20, 20, 70, 70)));     }      ",9.5/C-1-2,,09050000.670102,9.5 C-1-2 permissions.html,Test[None]:[android.uirendering.cts.testclasses.ExactCanvasTests:testUnclippedSaveLayerRounding()],,9.5,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/uirendering/src/android/uirendering/cts/testclasses/ExactCanvasTests.java,,
,9.8.9,C-0-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testMonochromeCharacteristics(),CtsCameraTestCases,"     public void testMonochromeCharacteristics() {         for (int i = 0; i < mAllCameraIds.length; i++) {             Log.i(TAG, ""testMonochromeCharacteristics: Testing camera ID "" + mAllCameraIds[i]);              CameraCharacteristics c = mCharacteristics.get(i);             int[] capabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);             assertNotNull(""android.request.availableCapabilities must never be null"",                     capabilities);             boolean supportMonochrome = arrayContains(capabilities, MONOCHROME);              if (!supportMonochrome) {                 continue;             }              List<Key<?>> allKeys = c.getKeys();             List<CaptureRequest.Key<?>> requestKeys = c.getAvailableCaptureRequestKeys();             List<CaptureResult.Key<?>> resultKeys = c.getAvailableCaptureResultKeys();              assertTrue(""Monochrome camera must have BACKWARD_COMPATIBLE capability"",                     arrayContains(capabilities, BC));             int colorFilterArrangement = c.get(                     CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT);             assertTrue(""Monochrome camera must have either MONO or NIR color filter pattern"",                     colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO                     || colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR);              assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX1));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT1));             assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX2));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT2));              assertFalse(                     ""Monochrome capture result must not contain SENSOR_NEUTRAL_COLOR_POINT key"",                     resultKeys.contains(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT));             assertFalse(""Monochrome capture result must not contain SENSOR_GREEN_SPLIT key"",                     resultKeys.contains(CaptureResult.SENSOR_GREEN_SPLIT));              // Check that color correction tags are not available for monochrome cameras             assertTrue(""Monochrome camera must not have MANUAL_POST_PROCESSING capability"",                     !arrayContains(capabilities, MANUAL_POSTPROC));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_GAINS));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_GAINS));              // Check that awbSupportedModes only contains AUTO             int[] awbAvailableModes = c.get(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES);             assertTrue(""availableAwbModes must not be null"", awbAvailableModes != null);             assertTrue(""availableAwbModes must contain only AUTO"", awbAvailableModes.length == 1 &&                     awbAvailableModes[0] == CaptureRequest.CONTROL_AWB_MODE_AUTO);         }     }      /**      * Check that all devices available through the legacy API are also      * accessible via Camera2.      */     @CddTest(requirement=""7.5.4/C-0-11"")     ",9.8.9/C-0-1,,09080900.670001,C-0-1 9.8.9,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testMonochromeCharacteristics()],,C-0-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.8.10,C-1-1,,android.hardware.camera2.cts.LogicalCameraDeviceTest,testDefaultFov(),CtsCameraTestCases,"     @CddTest(requirement=""7.5.4/C-1-1"")     public void testDefaultFov() throws Exception {         final double MIN_FOV = 50;         final double MAX_FOV = 90;         if (!isHandheldDevice()) {             return;         }         for (String id : mCameraIdsUnderTest) {             try {                 Log.i(TAG, ""Testing Camera "" + id);                  StaticMetadata staticInfo = mAllStaticInfo.get(id);                 if (!staticInfo.isColorOutputSupported()) {                     Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");                     continue;                 }                  if (!staticInfo.isLogicalMultiCamera()) {                     Log.i(TAG, ""Camera "" + id + "" is not a logical multi-camera, skipping"");                     continue;                 }                  SizeF physicalSize = staticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);                 double physicalDiag = Math.sqrt(Math.pow(physicalSize.getWidth(), 2)                         + Math.pow(physicalSize.getHeight(), 2));                 Rect activeArraySize = staticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);                  openDevice(id);                 for (int template : sTemplates) {                     try {                         CaptureRequest.Builder requestBuilder =                                 mCamera.createCaptureRequest(template);                         Float requestFocalLength = requestBuilder.get(                                 CaptureRequest.LENS_FOCAL_LENGTH);                         assertNotNull(""LENS_FOCAL_LENGTH must not be null"", requestFocalLength);                          Float requestZoomRatio = requestBuilder.get(                                 CaptureRequest.CONTROL_ZOOM_RATIO);                         assertNotNull(""CONTROL_ZOOM_RATIO must not be null"", requestZoomRatio);                         Rect requestCropRegion = requestBuilder.get(                                 CaptureRequest.SCALER_CROP_REGION);                         assertNotNull(""SCALER_CROP_REGION must not be null"", requestCropRegion);                         float totalZoomRatio = Math.min(                                 1.0f * activeArraySize.width() / requestCropRegion.width(),                                 1.0f * activeArraySize.height() / requestCropRegion.height()) *                                 requestZoomRatio;                          double fov = 2 *                                 Math.toDegrees(Math.atan2(physicalDiag/(2 * totalZoomRatio),                                 requestFocalLength));                          Log.v(TAG, ""Camera "" +  id + "" template "" + template +                                 ""'s default FOV is "" + fov);                         mCollector.expectInRange(""Camera "" +  id + "" template "" + template +                                 ""'s default FOV must fall between [50, 90] degrees"",                                 fov, MIN_FOV, MAX_FOV);                     } catch (IllegalArgumentException e) {                         if (template == CameraDevice.TEMPLATE_MANUAL &&                                 !staticInfo.isCapabilitySupported(CameraCharacteristics.                                 REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {                             // OK                         } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG &&                                 !staticInfo.isCapabilitySupported(CameraCharacteristics.                                 REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)) {                             // OK.                         } else {                             throw e; // rethrow                         }                     }                 }             } finally {                 closeDevice();             }         }     }      /**      * Find a common preview size that's supported by both the logical camera and      * two of the underlying physical cameras.      */     private Size findCommonPreviewSize(String cameraId,             List<String> dualPhysicalCameraIds) throws Exception {          Set<String> physicalCameraIds =                 mStaticInfo.getCharacteristics().getPhysicalCameraIds();         assertTrue(""Logical camera must contain at least 2 physical camera ids"",                 physicalCameraIds.size() >= 2);          List<Size> previewSizes = getSupportedPreviewSizes(                 cameraId, mCameraManager, PREVIEW_SIZE_BOUND);         HashMap<String, List<Size>> physicalPreviewSizesMap = new HashMap<String, List<Size>>();         HashMap<String, StreamConfigurationMap> physicalConfigs = new HashMap<>();         for (String physicalCameraId : physicalCameraIds) {             CameraCharacteristics properties =                     mCameraManager.getCameraCharacteristics(physicalCameraId);             assertNotNull(""Can't get camera characteristics!"", properties);             if (!mAllStaticInfo.get(physicalCameraId).isColorOutputSupported()) {                 // No color output support, skip.                 continue;             }             StreamConfigurationMap configMap =                 properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             physicalConfigs.put(physicalCameraId, configMap);             physicalPreviewSizesMap.put(physicalCameraId,                     getSupportedPreviewSizes(physicalCameraId, mCameraManager, PREVIEW_SIZE_BOUND));         }          // Find display size from window service.         Context context = mActivityRule.getActivity().getApplicationContext();         WindowManager windowManager =                 (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);         Display display = windowManager.getDefaultDisplay();          int displayWidth = display.getWidth();         int displayHeight = display.getHeight();          if (displayHeight > displayWidth) {             displayHeight = displayWidth;             displayWidth = display.getHeight();         }          StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         for (Size previewSize : previewSizes) {             dualPhysicalCameraIds.clear();             // Skip preview sizes larger than screen size             if (previewSize.getWidth() > displayWidth ||                     previewSize.getHeight() > displayHeight) {                 continue;             }              final long minFrameDuration = config.getOutputMinFrameDuration(                    ImageFormat.YUV_420_888, previewSize);              ArrayList<String> supportedPhysicalCameras = new ArrayList<String>();             for (String physicalCameraId : physicalCameraIds) {                 List<Size> physicalPreviewSizes = physicalPreviewSizesMap.get(physicalCameraId);                 if (physicalPreviewSizes != null && physicalPreviewSizes.contains(previewSize)) {                    long minDurationPhysical =                            physicalConfigs.get(physicalCameraId).getOutputMinFrameDuration(                            ImageFormat.YUV_420_888, previewSize);                    if (minDurationPhysical <= minFrameDuration) {                         dualPhysicalCameraIds.add(physicalCameraId);                         if (dualPhysicalCameraIds.size() == 2) {                             return previewSize;                         }                    }                 }             }         }         return null;     }      /**      * Validate that physical cameras are not cropping too much.      *      * This is to make sure physical processed streams have at least the same field of view as      * the logical stream, or the maximum field of view of the physical camera, whichever is      * smaller.      *      * Note that the FOV is calculated in the directio of sensor width.      */     private void validatePhysicalCamerasFov(TotalCaptureResult totalCaptureResult,             List<String> physicalCameraIds) {         Rect cropRegion = totalCaptureResult.get(CaptureResult.SCALER_CROP_REGION);         Float focalLength = totalCaptureResult.get(CaptureResult.LENS_FOCAL_LENGTH);         Float zoomRatio = totalCaptureResult.get(CaptureResult.CONTROL_ZOOM_RATIO);         Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();         SizeF sensorSize = mStaticInfo.getValueFromKeyNonNull(                 CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);          // Assume subject distance >> focal length, and subject distance >> camera baseline.         double fov = 2 * Math.toDegrees(Math.atan2(sensorSize.getWidth() * cropRegion.width() /                 (2 * zoomRatio * activeArraySize.width()),  focalLength));          Map<String, CaptureResult> physicalResultsDual =                     totalCaptureResult.getPhysicalCameraResults();         for (String physicalId : physicalCameraIds) {             StaticMetadata physicalStaticInfo = mAllStaticInfo.get(physicalId);             CaptureResult physicalResult = physicalResultsDual.get(physicalId);             Rect physicalCropRegion = physicalResult.get(CaptureResult.SCALER_CROP_REGION);             Float physicalFocalLength = physicalResult.get(CaptureResult.LENS_FOCAL_LENGTH);             Float physicalZoomRatio = physicalResult.get(CaptureResult.CONTROL_ZOOM_RATIO);             Rect physicalActiveArraySize = physicalStaticInfo.getActiveArraySizeChecked();             SizeF physicalSensorSize = mStaticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);              double physicalFov = 2 * Math.toDegrees(Math.atan2(                     physicalSensorSize.getWidth() * physicalCropRegion.width() /                     (2 * physicalZoomRatio * physicalActiveArraySize.width()), physicalFocalLength));              double maxPhysicalFov = 2 * Math.toDegrees(Math.atan2(physicalSensorSize.getWidth() / 2,                     physicalFocalLength));             double expectedPhysicalFov = Math.min(maxPhysicalFov, fov);              if (VERBOSE) {                 Log.v(TAG, ""Logical camera Fov: "" + fov + "", maxPhyiscalFov: "" + maxPhysicalFov +                         "", physicalFov: "" + physicalFov);             }             assertTrue(""Physical stream FOV (Field of view) should be greater or equal to""                     + "" min(logical stream FOV, max physical stream FOV). Physical FOV: ""                     + physicalFov + "" vs min("" + fov + "", "" + maxPhysicalFov,                     physicalFov - expectedPhysicalFov > -FOV_THRESHOLD);         }     }      /**      * Test physical camera YUV streaming within a particular logical camera.      *      * Use 2 YUV streams with PREVIEW or smaller size.      */     private void testBasicPhysicalStreamingForCamera(String logicalCameraId,             List<String> physicalCameraIds, Size previewSize) throws Exception {         List<OutputConfiguration> outputConfigs = new ArrayList<>();         List<ImageReader> imageReaders = new ArrayList<>();          // Add 1 logical YUV stream         ImageReader logicalTarget = CameraTestUtils.makeImageReader(previewSize,                 ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,                 new ImageDropperListener(), mHandler);         imageReaders.add(logicalTarget);         outputConfigs.add(new OutputConfiguration(logicalTarget.getSurface()));          // Add physical YUV streams         if (physicalCameraIds.size() != 2) {             throw new IllegalArgumentException(""phyiscalCameraIds must contain 2 camera ids"");         }         List<ImageReader> physicalTargets = new ArrayList<>();         for (String physicalCameraId : physicalCameraIds) {             ImageReader physicalTarget = CameraTestUtils.makeImageReader(previewSize,                     ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,                     new ImageDropperListener(), mHandler);             OutputConfiguration config = new OutputConfiguration(physicalTarget.getSurface());             config.setPhysicalCameraId(physicalCameraId);             outputConfigs.add(config);             physicalTargets.add(physicalTarget);         }          SessionConfigSupport sessionConfigSupport = isSessionConfigSupported(                 mCamera, mHandler, outputConfigs, /*inputConfig*/ null,                 SessionConfiguration.SESSION_REGULAR, false/*defaultSupport*/);         assertTrue(""Session configuration query for logical camera failed with error"",                 !sessionConfigSupport.error);         if (!sessionConfigSupport.callSupported) {             return;         }          mSessionListener = new BlockingSessionCallback();         mSessionWaiter = mSessionListener.getStateWaiter();         mSession = configureCameraSessionWithConfig(mCamera, outputConfigs,                 mSessionListener, mHandler);         if (!sessionConfigSupport.configSupported) {             mSessionWaiter.waitForState(BlockingSessionCallback.SESSION_CONFIGURE_FAILED,                     SESSION_CONFIGURE_TIMEOUT_MS);             return;         }          // Stream logical YUV stream and note down the FPS         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         requestBuilder.addTarget(logicalTarget.getSurface());          SimpleCaptureCallback simpleResultListener =                 new SimpleCaptureCallback();         StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         final long minFrameDuration = config.getOutputMinFrameDuration(                 ImageFormat.YUV_420_888, previewSize);         if (minFrameDuration > 0) {             Range<Integer> targetRange = getSuitableFpsRangeForDuration(logicalCameraId,                     minFrameDuration);             requestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, targetRange);         }         mSession.setRepeatingRequest(requestBuilder.build(),                 simpleResultListener, mHandler);          // Converge AE         waitForAeStable(simpleResultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);          if (mStaticInfo.isAeLockSupported()) {             // Lock AE if supported.             requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);             mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,                     mHandler);             waitForResultValue(simpleResultListener, CaptureResult.CONTROL_AE_STATE,                     CaptureResult.CONTROL_AE_STATE_LOCKED, NUM_RESULTS_WAIT_TIMEOUT);         }          // Verify results         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,                 mStaticInfo, mAllStaticInfo, null/*requestedPhysicalIds*/,                 requestBuilder, NUM_FRAMES_CHECKED);          // Collect timestamps for one logical stream only.         long prevTimestamp = -1;         long[] logicalTimestamps = new long[NUM_FRAMES_CHECKED];         for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {             TotalCaptureResult totalCaptureResult =                     simpleResultListener.getTotalCaptureResult(                     CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);             logicalTimestamps[i] = totalCaptureResult.get(CaptureResult.SENSOR_TIMESTAMP);         }          double logicalAvgDurationMs = (logicalTimestamps[NUM_FRAMES_CHECKED-1] -                 logicalTimestamps[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));          // Request one logical stream and one physical stream         simpleResultListener = new SimpleCaptureCallback();         requestBuilder.addTarget(physicalTargets.get(1).getSurface());         mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,                 mHandler);          // Verify results for physical streams request.         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,                 mStaticInfo, mAllStaticInfo, physicalCameraIds.subList(1, 2), requestBuilder,                 NUM_FRAMES_CHECKED);           // Start requesting on both logical and physical streams         SimpleCaptureCallback simpleResultListenerDual =                 new SimpleCaptureCallback();         for (ImageReader physicalTarget : physicalTargets) {             requestBuilder.addTarget(physicalTarget.getSurface());         }         mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListenerDual,                 mHandler);          // Verify results for physical streams request.         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListenerDual,                 mStaticInfo, mAllStaticInfo, physicalCameraIds, requestBuilder,                 NUM_FRAMES_CHECKED);          // Acquire the timestamps of the physical camera.         long[] logicalTimestamps2 = new long[NUM_FRAMES_CHECKED];         long [][] physicalTimestamps = new long[physicalTargets.size()][];         for (int i = 0; i < physicalTargets.size(); i++) {             physicalTimestamps[i] = new long[NUM_FRAMES_CHECKED];         }         for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {             TotalCaptureResult totalCaptureResultDual =                     simpleResultListenerDual.getTotalCaptureResult(                     CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);             logicalTimestamps2[i] = totalCaptureResultDual.get(CaptureResult.SENSOR_TIMESTAMP);              int index = 0;             Map<String, CaptureResult> physicalResultsDual =                     totalCaptureResultDual.getPhysicalCameraResults();             for (String physicalId : physicalCameraIds) {                  if (physicalResultsDual.containsKey(physicalId)) {                      physicalTimestamps[index][i] = physicalResultsDual.get(physicalId).get(                              CaptureResult.SENSOR_TIMESTAMP);                  } else {                      physicalTimestamps[index][i] = -1;                  }                  index++;             }         }          // Check both logical and physical streams' crop region, and make sure their FOVs         // are similar.         TotalCaptureResult totalCaptureResult =                 simpleResultListenerDual.getTotalCaptureResult(                 CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);         validatePhysicalCamerasFov(totalCaptureResult, physicalCameraIds);          // Check timestamp monolithity for individual camera and across cameras         for (int i = 0; i < NUM_FRAMES_CHECKED-1; i++) {             assertTrue(""Logical camera timestamp must monolithically increase"",                     logicalTimestamps2[i] < logicalTimestamps2[i+1]);         }         for (int i = 0; i < physicalCameraIds.size(); i++) {             for (int j = 0 ; j < NUM_FRAMES_CHECKED-1; j++) {                 if (physicalTimestamps[i][j] != -1 && physicalTimestamps[i][j+1] != -1) {                     assertTrue(""Physical camera timestamp must monolithically increase"",                             physicalTimestamps[i][j] < physicalTimestamps[i][j+1]);                 }                 if (j > 0 && physicalTimestamps[i][j] != -1) {                     assertTrue(""Physical camera's timestamp N must be greater than logical "" +                             ""camera's timestamp N-1"",                             physicalTimestamps[i][j] > logicalTimestamps[j-1]);                 }                 if (physicalTimestamps[i][j] != -1) {                     assertTrue(""Physical camera's timestamp N must be less than logical camera's "" +                             ""timestamp N+1"", physicalTimestamps[i][j] > logicalTimestamps[j+1]);                 }             }         }          double logicalAvgDurationMs2 = (logicalTimestamps2[NUM_FRAMES_CHECKED-1] -                 logicalTimestamps2[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));         // Check CALIBRATED synchronization between physical cameras         Integer syncType = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE);         double fpsRatio = (logicalAvgDurationMs2 - logicalAvgDurationMs)/logicalAvgDurationMs;         if (syncType == CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED) {             // Check framerate doesn't slow down with physical streams             mCollector.expectTrue(                     ""The average frame duration with concurrent physical streams is"" +                     logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +                     "" ms for logical streams only"", fpsRatio <= FRAME_DURATION_THRESHOLD);              long maxTimestampDelta = 0;             for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {                 long delta = Math.abs(physicalTimestamps[0][i] - physicalTimestamps[1][i]);                 if (delta > maxTimestampDelta) {                     maxTimestampDelta = delta;                 }             }              Log.i(TAG, ""Maximum difference between physical camera timestamps: ""                     + maxTimestampDelta);              // The maximum timestamp difference should not be larger than the threshold.             mCollector.expectTrue(                     ""The maximum timestamp deltas between the physical cameras ""                     + maxTimestampDelta + "" is larger than "" + MAX_TIMESTAMP_DIFFERENCE_THRESHOLD,                     maxTimestampDelta <= MAX_TIMESTAMP_DIFFERENCE_THRESHOLD);         } else {             // Do not enforce fps check for APPROXIMATE synced device.             if (fpsRatio > FRAME_DURATION_THRESHOLD) {                 Log.w(TAG, ""The average frame duration with concurrent physical streams is"" +                         logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +                         "" ms for logical streams only"");             }         }          if (VERBOSE) {             while (simpleResultListenerDual.hasMoreFailures()) {                 ArrayList<CaptureFailure> failures =                     simpleResultListenerDual.getCaptureFailures(/*maxNumFailures*/ 1);                 for (CaptureFailure failure : failures) {                     String physicalCameraId = failure.getPhysicalCameraId();                     if (physicalCameraId != null) {                         Log.v(TAG, ""Capture result failure for physical camera id: "" +                                 physicalCameraId);                     }                 }             }         }          // Stop preview         if (mSession != null) {             mSession.close();         }     }      /**      * The CDD defines a handheld device as one that has a battery and a screen size between      * 2.5 and 8 inches.      */     private boolean isHandheldDevice() throws Exception {         double screenInches = getScreenSizeInInches();         return deviceHasBattery() && screenInches >= 2.5 && screenInches <= 8.0;     }      private boolean deviceHasBattery() {         final Intent batteryInfo = mContext.registerReceiver(null,                 new IntentFilter(Intent.ACTION_BATTERY_CHANGED));         return batteryInfo != null && batteryInfo.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);     }      private double getScreenSizeInInches() {         DisplayMetrics dm = new DisplayMetrics();         mWindowManager.getDefaultDisplay().getMetrics(dm);         double widthInInchesSquared = Math.pow(dm.widthPixels/dm.xdpi,2);         double heightInInchesSquared = Math.pow(dm.heightPixels/dm.ydpi,2);         return Math.sqrt(widthInInchesSquared + heightInInchesSquared);     } } ",9.8.10/C-1-1,,09081000.670101,C-1-1 9.8.10 BUGREPORT_MODE_TELEPHONY,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.LogicalCameraDeviceTest:testDefaultFov()],,C-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/LogicalCameraDeviceTest.java,,
,9.8.10,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.8.10/C-1-2,,09081000.670102,C-1-2 9.8.10,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.8.10,C-1-4,,android.view.cts.KeyCharacterMapTest,testIsPrintingKey(),,     public void testIsPrintingKey() {          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_UNKNOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SOFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CALL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENDCALL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STAR));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POUND));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DPAD_CENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAMERA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CLEAR));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_A));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_B));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_C));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_D));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_E));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_G));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_H));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_I));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_J));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_K));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_L));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_M));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_N));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_O));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_P));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Q));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_R));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_S));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_T));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_U));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_V));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_W));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_X));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Y));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_Z));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_COMMA));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PERIOD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ALT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SHIFT_RIGHT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TAB));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SPACE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EXPLORER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENVELOPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ENTER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DEL));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GRAVE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MINUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_LEFT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_RIGHT_BRACKET));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BACKSLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEMICOLON));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_APOSTROPHE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SLASH));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_HEADSETHOOK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FOCUS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PLUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MENU));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NOTIFICATION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SEARCH));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_STOP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_NEXT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_REWIND));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_FAST_FORWARD));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MUTE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PAGE_DOWN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PICTSYMBOLS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SWITCH_CHARSET));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_A));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_B));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_C));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_X));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Y));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_Z));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_L2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_R2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBL));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_THUMBR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_START));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_SELECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BUTTON_MODE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ESCAPE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD_DEL));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CTRL_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPS_LOCK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SCROLL_LOCK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_LEFT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_META_RIGHT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FUNCTION));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SYSRQ));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BREAK));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_HOME));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MOVE_END));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INSERT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_FORWARD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PLAY));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_PAUSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_CLOSE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_EJECT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_MEDIA_RECORD));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F1));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F2));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F3));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F4));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F5));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F6));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F7));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F8));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F9));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F10));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F11));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_F12));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUM_LOCK));          assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_0));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_1));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_2));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_3));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_4));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_5));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_6));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_7));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_8));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_9));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DIVIDE));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_MULTIPLY));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_SUBTRACT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ADD));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_DOT));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_COMMA));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_ENTER));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_EQUALS));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_LEFT_PAREN));         assertTrue(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_NUMPAD_RIGHT_PAREN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_VOLUME_MUTE));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_INFO));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_UP));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CHANNEL_DOWN));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_IN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_ZOOM_OUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_WINDOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_GUIDE));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_DVR));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_BOOKMARK));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_CAPTIONS));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_SETTINGS));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_TV_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_STB_INPUT));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_POWER));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_AVR_INPUT));          assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_RED));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_GREEN));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_YELLOW));         assertFalse(mKeyCharacterMap.isPrintingKey(KeyEvent.KEYCODE_PROG_BLUE));     }      ,9.8.10/C-1-4,,09081000.670104,C-1-4 9.8.10 UID,Test[None]:[android.view.cts.KeyCharacterMapTest:testIsPrintingKey()],,UID,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/view/src/android/view/cts/KeyCharacterMapTest.java,,
,9.8.11,C-1-1,,android.hardware.camera2.cts.LogicalCameraDeviceTest,testDefaultFov(),CtsCameraTestCases,"     @CddTest(requirement=""7.5.4/C-1-1"")     public void testDefaultFov() throws Exception {         final double MIN_FOV = 50;         final double MAX_FOV = 90;         if (!isHandheldDevice()) {             return;         }         for (String id : mCameraIdsUnderTest) {             try {                 Log.i(TAG, ""Testing Camera "" + id);                  StaticMetadata staticInfo = mAllStaticInfo.get(id);                 if (!staticInfo.isColorOutputSupported()) {                     Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");                     continue;                 }                  if (!staticInfo.isLogicalMultiCamera()) {                     Log.i(TAG, ""Camera "" + id + "" is not a logical multi-camera, skipping"");                     continue;                 }                  SizeF physicalSize = staticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);                 double physicalDiag = Math.sqrt(Math.pow(physicalSize.getWidth(), 2)                         + Math.pow(physicalSize.getHeight(), 2));                 Rect activeArraySize = staticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);                  openDevice(id);                 for (int template : sTemplates) {                     try {                         CaptureRequest.Builder requestBuilder =                                 mCamera.createCaptureRequest(template);                         Float requestFocalLength = requestBuilder.get(                                 CaptureRequest.LENS_FOCAL_LENGTH);                         assertNotNull(""LENS_FOCAL_LENGTH must not be null"", requestFocalLength);                          Float requestZoomRatio = requestBuilder.get(                                 CaptureRequest.CONTROL_ZOOM_RATIO);                         assertNotNull(""CONTROL_ZOOM_RATIO must not be null"", requestZoomRatio);                         Rect requestCropRegion = requestBuilder.get(                                 CaptureRequest.SCALER_CROP_REGION);                         assertNotNull(""SCALER_CROP_REGION must not be null"", requestCropRegion);                         float totalZoomRatio = Math.min(                                 1.0f * activeArraySize.width() / requestCropRegion.width(),                                 1.0f * activeArraySize.height() / requestCropRegion.height()) *                                 requestZoomRatio;                          double fov = 2 *                                 Math.toDegrees(Math.atan2(physicalDiag/(2 * totalZoomRatio),                                 requestFocalLength));                          Log.v(TAG, ""Camera "" +  id + "" template "" + template +                                 ""'s default FOV is "" + fov);                         mCollector.expectInRange(""Camera "" +  id + "" template "" + template +                                 ""'s default FOV must fall between [50, 90] degrees"",                                 fov, MIN_FOV, MAX_FOV);                     } catch (IllegalArgumentException e) {                         if (template == CameraDevice.TEMPLATE_MANUAL &&                                 !staticInfo.isCapabilitySupported(CameraCharacteristics.                                 REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {                             // OK                         } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG &&                                 !staticInfo.isCapabilitySupported(CameraCharacteristics.                                 REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)) {                             // OK.                         } else {                             throw e; // rethrow                         }                     }                 }             } finally {                 closeDevice();             }         }     }      /**      * Find a common preview size that's supported by both the logical camera and      * two of the underlying physical cameras.      */     private Size findCommonPreviewSize(String cameraId,             List<String> dualPhysicalCameraIds) throws Exception {          Set<String> physicalCameraIds =                 mStaticInfo.getCharacteristics().getPhysicalCameraIds();         assertTrue(""Logical camera must contain at least 2 physical camera ids"",                 physicalCameraIds.size() >= 2);          List<Size> previewSizes = getSupportedPreviewSizes(                 cameraId, mCameraManager, PREVIEW_SIZE_BOUND);         HashMap<String, List<Size>> physicalPreviewSizesMap = new HashMap<String, List<Size>>();         HashMap<String, StreamConfigurationMap> physicalConfigs = new HashMap<>();         for (String physicalCameraId : physicalCameraIds) {             CameraCharacteristics properties =                     mCameraManager.getCameraCharacteristics(physicalCameraId);             assertNotNull(""Can't get camera characteristics!"", properties);             if (!mAllStaticInfo.get(physicalCameraId).isColorOutputSupported()) {                 // No color output support, skip.                 continue;             }             StreamConfigurationMap configMap =                 properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             physicalConfigs.put(physicalCameraId, configMap);             physicalPreviewSizesMap.put(physicalCameraId,                     getSupportedPreviewSizes(physicalCameraId, mCameraManager, PREVIEW_SIZE_BOUND));         }          // Find display size from window service.         Context context = mActivityRule.getActivity().getApplicationContext();         WindowManager windowManager =                 (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);         Display display = windowManager.getDefaultDisplay();          int displayWidth = display.getWidth();         int displayHeight = display.getHeight();          if (displayHeight > displayWidth) {             displayHeight = displayWidth;             displayWidth = display.getHeight();         }          StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         for (Size previewSize : previewSizes) {             dualPhysicalCameraIds.clear();             // Skip preview sizes larger than screen size             if (previewSize.getWidth() > displayWidth ||                     previewSize.getHeight() > displayHeight) {                 continue;             }              final long minFrameDuration = config.getOutputMinFrameDuration(                    ImageFormat.YUV_420_888, previewSize);              ArrayList<String> supportedPhysicalCameras = new ArrayList<String>();             for (String physicalCameraId : physicalCameraIds) {                 List<Size> physicalPreviewSizes = physicalPreviewSizesMap.get(physicalCameraId);                 if (physicalPreviewSizes != null && physicalPreviewSizes.contains(previewSize)) {                    long minDurationPhysical =                            physicalConfigs.get(physicalCameraId).getOutputMinFrameDuration(                            ImageFormat.YUV_420_888, previewSize);                    if (minDurationPhysical <= minFrameDuration) {                         dualPhysicalCameraIds.add(physicalCameraId);                         if (dualPhysicalCameraIds.size() == 2) {                             return previewSize;                         }                    }                 }             }         }         return null;     }      /**      * Validate that physical cameras are not cropping too much.      *      * This is to make sure physical processed streams have at least the same field of view as      * the logical stream, or the maximum field of view of the physical camera, whichever is      * smaller.      *      * Note that the FOV is calculated in the directio of sensor width.      */     private void validatePhysicalCamerasFov(TotalCaptureResult totalCaptureResult,             List<String> physicalCameraIds) {         Rect cropRegion = totalCaptureResult.get(CaptureResult.SCALER_CROP_REGION);         Float focalLength = totalCaptureResult.get(CaptureResult.LENS_FOCAL_LENGTH);         Float zoomRatio = totalCaptureResult.get(CaptureResult.CONTROL_ZOOM_RATIO);         Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();         SizeF sensorSize = mStaticInfo.getValueFromKeyNonNull(                 CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);          // Assume subject distance >> focal length, and subject distance >> camera baseline.         double fov = 2 * Math.toDegrees(Math.atan2(sensorSize.getWidth() * cropRegion.width() /                 (2 * zoomRatio * activeArraySize.width()),  focalLength));          Map<String, CaptureResult> physicalResultsDual =                     totalCaptureResult.getPhysicalCameraResults();         for (String physicalId : physicalCameraIds) {             StaticMetadata physicalStaticInfo = mAllStaticInfo.get(physicalId);             CaptureResult physicalResult = physicalResultsDual.get(physicalId);             Rect physicalCropRegion = physicalResult.get(CaptureResult.SCALER_CROP_REGION);             Float physicalFocalLength = physicalResult.get(CaptureResult.LENS_FOCAL_LENGTH);             Float physicalZoomRatio = physicalResult.get(CaptureResult.CONTROL_ZOOM_RATIO);             Rect physicalActiveArraySize = physicalStaticInfo.getActiveArraySizeChecked();             SizeF physicalSensorSize = mStaticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);              double physicalFov = 2 * Math.toDegrees(Math.atan2(                     physicalSensorSize.getWidth() * physicalCropRegion.width() /                     (2 * physicalZoomRatio * physicalActiveArraySize.width()), physicalFocalLength));              double maxPhysicalFov = 2 * Math.toDegrees(Math.atan2(physicalSensorSize.getWidth() / 2,                     physicalFocalLength));             double expectedPhysicalFov = Math.min(maxPhysicalFov, fov);              if (VERBOSE) {                 Log.v(TAG, ""Logical camera Fov: "" + fov + "", maxPhyiscalFov: "" + maxPhysicalFov +                         "", physicalFov: "" + physicalFov);             }             assertTrue(""Physical stream FOV (Field of view) should be greater or equal to""                     + "" min(logical stream FOV, max physical stream FOV). Physical FOV: ""                     + physicalFov + "" vs min("" + fov + "", "" + maxPhysicalFov,                     physicalFov - expectedPhysicalFov > -FOV_THRESHOLD);         }     }      /**      * Test physical camera YUV streaming within a particular logical camera.      *      * Use 2 YUV streams with PREVIEW or smaller size.      */     private void testBasicPhysicalStreamingForCamera(String logicalCameraId,             List<String> physicalCameraIds, Size previewSize) throws Exception {         List<OutputConfiguration> outputConfigs = new ArrayList<>();         List<ImageReader> imageReaders = new ArrayList<>();          // Add 1 logical YUV stream         ImageReader logicalTarget = CameraTestUtils.makeImageReader(previewSize,                 ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,                 new ImageDropperListener(), mHandler);         imageReaders.add(logicalTarget);         outputConfigs.add(new OutputConfiguration(logicalTarget.getSurface()));          // Add physical YUV streams         if (physicalCameraIds.size() != 2) {             throw new IllegalArgumentException(""phyiscalCameraIds must contain 2 camera ids"");         }         List<ImageReader> physicalTargets = new ArrayList<>();         for (String physicalCameraId : physicalCameraIds) {             ImageReader physicalTarget = CameraTestUtils.makeImageReader(previewSize,                     ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,                     new ImageDropperListener(), mHandler);             OutputConfiguration config = new OutputConfiguration(physicalTarget.getSurface());             config.setPhysicalCameraId(physicalCameraId);             outputConfigs.add(config);             physicalTargets.add(physicalTarget);         }          SessionConfigSupport sessionConfigSupport = isSessionConfigSupported(                 mCamera, mHandler, outputConfigs, /*inputConfig*/ null,                 SessionConfiguration.SESSION_REGULAR, false/*defaultSupport*/);         assertTrue(""Session configuration query for logical camera failed with error"",                 !sessionConfigSupport.error);         if (!sessionConfigSupport.callSupported) {             return;         }          mSessionListener = new BlockingSessionCallback();         mSessionWaiter = mSessionListener.getStateWaiter();         mSession = configureCameraSessionWithConfig(mCamera, outputConfigs,                 mSessionListener, mHandler);         if (!sessionConfigSupport.configSupported) {             mSessionWaiter.waitForState(BlockingSessionCallback.SESSION_CONFIGURE_FAILED,                     SESSION_CONFIGURE_TIMEOUT_MS);             return;         }          // Stream logical YUV stream and note down the FPS         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         requestBuilder.addTarget(logicalTarget.getSurface());          SimpleCaptureCallback simpleResultListener =                 new SimpleCaptureCallback();         StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         final long minFrameDuration = config.getOutputMinFrameDuration(                 ImageFormat.YUV_420_888, previewSize);         if (minFrameDuration > 0) {             Range<Integer> targetRange = getSuitableFpsRangeForDuration(logicalCameraId,                     minFrameDuration);             requestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, targetRange);         }         mSession.setRepeatingRequest(requestBuilder.build(),                 simpleResultListener, mHandler);          // Converge AE         waitForAeStable(simpleResultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);          if (mStaticInfo.isAeLockSupported()) {             // Lock AE if supported.             requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);             mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,                     mHandler);             waitForResultValue(simpleResultListener, CaptureResult.CONTROL_AE_STATE,                     CaptureResult.CONTROL_AE_STATE_LOCKED, NUM_RESULTS_WAIT_TIMEOUT);         }          // Verify results         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,                 mStaticInfo, mAllStaticInfo, null/*requestedPhysicalIds*/,                 requestBuilder, NUM_FRAMES_CHECKED);          // Collect timestamps for one logical stream only.         long prevTimestamp = -1;         long[] logicalTimestamps = new long[NUM_FRAMES_CHECKED];         for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {             TotalCaptureResult totalCaptureResult =                     simpleResultListener.getTotalCaptureResult(                     CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);             logicalTimestamps[i] = totalCaptureResult.get(CaptureResult.SENSOR_TIMESTAMP);         }          double logicalAvgDurationMs = (logicalTimestamps[NUM_FRAMES_CHECKED-1] -                 logicalTimestamps[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));          // Request one logical stream and one physical stream         simpleResultListener = new SimpleCaptureCallback();         requestBuilder.addTarget(physicalTargets.get(1).getSurface());         mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,                 mHandler);          // Verify results for physical streams request.         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,                 mStaticInfo, mAllStaticInfo, physicalCameraIds.subList(1, 2), requestBuilder,                 NUM_FRAMES_CHECKED);           // Start requesting on both logical and physical streams         SimpleCaptureCallback simpleResultListenerDual =                 new SimpleCaptureCallback();         for (ImageReader physicalTarget : physicalTargets) {             requestBuilder.addTarget(physicalTarget.getSurface());         }         mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListenerDual,                 mHandler);          // Verify results for physical streams request.         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListenerDual,                 mStaticInfo, mAllStaticInfo, physicalCameraIds, requestBuilder,                 NUM_FRAMES_CHECKED);          // Acquire the timestamps of the physical camera.         long[] logicalTimestamps2 = new long[NUM_FRAMES_CHECKED];         long [][] physicalTimestamps = new long[physicalTargets.size()][];         for (int i = 0; i < physicalTargets.size(); i++) {             physicalTimestamps[i] = new long[NUM_FRAMES_CHECKED];         }         for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {             TotalCaptureResult totalCaptureResultDual =                     simpleResultListenerDual.getTotalCaptureResult(                     CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);             logicalTimestamps2[i] = totalCaptureResultDual.get(CaptureResult.SENSOR_TIMESTAMP);              int index = 0;             Map<String, CaptureResult> physicalResultsDual =                     totalCaptureResultDual.getPhysicalCameraResults();             for (String physicalId : physicalCameraIds) {                  if (physicalResultsDual.containsKey(physicalId)) {                      physicalTimestamps[index][i] = physicalResultsDual.get(physicalId).get(                              CaptureResult.SENSOR_TIMESTAMP);                  } else {                      physicalTimestamps[index][i] = -1;                  }                  index++;             }         }          // Check both logical and physical streams' crop region, and make sure their FOVs         // are similar.         TotalCaptureResult totalCaptureResult =                 simpleResultListenerDual.getTotalCaptureResult(                 CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);         validatePhysicalCamerasFov(totalCaptureResult, physicalCameraIds);          // Check timestamp monolithity for individual camera and across cameras         for (int i = 0; i < NUM_FRAMES_CHECKED-1; i++) {             assertTrue(""Logical camera timestamp must monolithically increase"",                     logicalTimestamps2[i] < logicalTimestamps2[i+1]);         }         for (int i = 0; i < physicalCameraIds.size(); i++) {             for (int j = 0 ; j < NUM_FRAMES_CHECKED-1; j++) {                 if (physicalTimestamps[i][j] != -1 && physicalTimestamps[i][j+1] != -1) {                     assertTrue(""Physical camera timestamp must monolithically increase"",                             physicalTimestamps[i][j] < physicalTimestamps[i][j+1]);                 }                 if (j > 0 && physicalTimestamps[i][j] != -1) {                     assertTrue(""Physical camera's timestamp N must be greater than logical "" +                             ""camera's timestamp N-1"",                             physicalTimestamps[i][j] > logicalTimestamps[j-1]);                 }                 if (physicalTimestamps[i][j] != -1) {                     assertTrue(""Physical camera's timestamp N must be less than logical camera's "" +                             ""timestamp N+1"", physicalTimestamps[i][j] > logicalTimestamps[j+1]);                 }             }         }          double logicalAvgDurationMs2 = (logicalTimestamps2[NUM_FRAMES_CHECKED-1] -                 logicalTimestamps2[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));         // Check CALIBRATED synchronization between physical cameras         Integer syncType = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE);         double fpsRatio = (logicalAvgDurationMs2 - logicalAvgDurationMs)/logicalAvgDurationMs;         if (syncType == CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED) {             // Check framerate doesn't slow down with physical streams             mCollector.expectTrue(                     ""The average frame duration with concurrent physical streams is"" +                     logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +                     "" ms for logical streams only"", fpsRatio <= FRAME_DURATION_THRESHOLD);              long maxTimestampDelta = 0;             for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {                 long delta = Math.abs(physicalTimestamps[0][i] - physicalTimestamps[1][i]);                 if (delta > maxTimestampDelta) {                     maxTimestampDelta = delta;                 }             }              Log.i(TAG, ""Maximum difference between physical camera timestamps: ""                     + maxTimestampDelta);              // The maximum timestamp difference should not be larger than the threshold.             mCollector.expectTrue(                     ""The maximum timestamp deltas between the physical cameras ""                     + maxTimestampDelta + "" is larger than "" + MAX_TIMESTAMP_DIFFERENCE_THRESHOLD,                     maxTimestampDelta <= MAX_TIMESTAMP_DIFFERENCE_THRESHOLD);         } else {             // Do not enforce fps check for APPROXIMATE synced device.             if (fpsRatio > FRAME_DURATION_THRESHOLD) {                 Log.w(TAG, ""The average frame duration with concurrent physical streams is"" +                         logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +                         "" ms for logical streams only"");             }         }          if (VERBOSE) {             while (simpleResultListenerDual.hasMoreFailures()) {                 ArrayList<CaptureFailure> failures =                     simpleResultListenerDual.getCaptureFailures(/*maxNumFailures*/ 1);                 for (CaptureFailure failure : failures) {                     String physicalCameraId = failure.getPhysicalCameraId();                     if (physicalCameraId != null) {                         Log.v(TAG, ""Capture result failure for physical camera id: "" +                                 physicalCameraId);                     }                 }             }         }          // Stop preview         if (mSession != null) {             mSession.close();         }     }      /**      * The CDD defines a handheld device as one that has a battery and a screen size between      * 2.5 and 8 inches.      */     private boolean isHandheldDevice() throws Exception {         double screenInches = getScreenSizeInInches();         return deviceHasBattery() && screenInches >= 2.5 && screenInches <= 8.0;     }      private boolean deviceHasBattery() {         final Intent batteryInfo = mContext.registerReceiver(null,                 new IntentFilter(Intent.ACTION_BATTERY_CHANGED));         return batteryInfo != null && batteryInfo.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);     }      private double getScreenSizeInInches() {         DisplayMetrics dm = new DisplayMetrics();         mWindowManager.getDefaultDisplay().getMetrics(dm);         double widthInInchesSquared = Math.pow(dm.widthPixels/dm.xdpi,2);         double heightInInchesSquared = Math.pow(dm.heightPixels/dm.ydpi,2);         return Math.sqrt(widthInInchesSquared + heightInInchesSquared);     } } ",9.8.11/C-1-1,,09081100.670101,C-1-1 BlobStoreManager.session allowPackageAccess() 9.8.11 allowPublicAccess() allowSameSignatureAccess(),Test[CtsCameraTestCases]:[android.hardware.camera2.cts.LogicalCameraDeviceTest:testDefaultFov()],,C-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/LogicalCameraDeviceTest.java,,
,9.8.11,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.8.11/C-1-2,,09081100.670102,C-1-2 9.8.11,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.9.4,C-0-1,,android.assist.cts.LifecycleTest,testNoUiLayerDoesNotTriggerLifecycleMethods(),,"     public void testNoUiLayerDoesNotTriggerLifecycleMethods() throws Exception {         if (mActivityManager.isLowRamDevice()) {             Log.d(TAG, ""Not running assist tests on low-RAM device."");             return;         }         mLostFocusIsLifecycle = true;         startTest(Utils.LIFECYCLE_NOUI);         waitForAssistantToBeReady();         start3pApp(Utils.LIFECYCLE_NOUI);         waitForHasFocus();         final AutoResetLatch latch = startSession();         waitForContext(latch);         // Do this after waitForContext(), since we don't start looking for context until         // calling the above (RACY!!!).         waitAndSeeIfLifecycleMethodsAreTriggered();          Bundle bundle = new Bundle();         bundle.putString(Utils.EXTRA_REMOTE_CALLBACK_ACTION, Utils.HIDE_LIFECYCLE_ACTIVITY);         m3pActivityCallback.sendResult(bundle);          waitForDestroy();     }      private class LifecycleTestReceiver extends ActionLatchReceiver {          @Override         protected void onAction(Bundle bundle, String action) {             if (action.equals(ACTION_HAS_FOCUS) && mHasFocusLatch != null) {                 mHasFocusLatch.countDown();             } else if (action.equals(ACTION_LOST_FOCUS) && mLostFocusLatch != null) {                 if (mLostFocusIsLifecycle) {                     mActivityLifecycleLatch.countDown();                 } else {                     mLostFocusLatch.countDown();                 }             } else if (action.equals(ACTION_ON_PAUSE) && mActivityLifecycleLatch != null) {                 mActivityLifecycleLatch.countDown();             } else if (action.equals(ACTION_ON_STOP) && mActivityLifecycleLatch != null) {                 mActivityLifecycleLatch.countDown();             } else if (action.equals(ACTION_ON_DESTROY) && mActivityLifecycleLatch != null) {                 mActivityLifecycleLatch.countDown();                 mDestroyLatch.countDown();             } else {                 super.onAction(bundle, action);             }         }     } } ",9.9.4/C-0-1,,09090400.670001,RAM PIN C-0-1 9.9.4 OTA,Test[None]:[android.assist.cts.LifecycleTest:testNoUiLayerDoesNotTriggerLifecycleMethods()],,RAM,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/assist/src/android/assist/cts/LifecycleTest.java,,
,9.11.3,C-0-1,,android.server.wm.SurfaceControlViewHostTests,setUp(),,"/*  *  */  package android.server.wm;  import static android.server.wm.UiDeviceUtils.pressHomeButton; import static android.server.wm.UiDeviceUtils.pressUnlockButton; import static android.server.wm.UiDeviceUtils.pressWakeupButton; import static android.view.WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import android.app.Activity; import android.app.ActivityManager; import android.app.Instrumentation; import android.content.Context; import android.content.pm.ConfigurationInfo; import android.content.pm.FeatureInfo; import android.graphics.PixelFormat; import android.graphics.Point; import android.graphics.Rect; import android.platform.test.annotations.RequiresDevice; import android.view.Gravity; import android.view.View; import android.view.ViewGroup; import android.view.SurfaceControl; import android.view.SurfaceHolder; import android.view.SurfaceHolder.Callback; import android.view.WindowInsets; import android.view.WindowManager; import android.view.SurfaceControlViewHost; import android.widget.FrameLayout; import android.widget.Button;  import android.view.SurfaceView;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.FlakyTest; import androidx.test.rule.ActivityTestRule;  import com.android.compatibility.common.util.CtsTouchUtils; import com.android.compatibility.common.util.WidgetTestUtils;   import android.platform.test.annotations.Presubmit;  import org.junit.Before; import org.junit.Test;  /**  * Ensure end-to-end functionality of SurfaceControlViewHost.  *  * Build/Install/Run:  *     atest CtsWindowManagerDeviceTestCases:SurfaceControlViewHostTests  */ @Presubmit public class SurfaceControlViewHostTests implements SurfaceHolder.Callback {     private final ActivityTestRule<Activity> mActivityRule = new ActivityTestRule<>(Activity.class);      private Instrumentation mInstrumentation;     private Activity mActivity;     private SurfaceView mSurfaceView;      private SurfaceControlViewHost mVr;     private View mEmbeddedView;     private WindowManager.LayoutParams mEmbeddedLayoutParams;      private volatile boolean mClicked = false;      /*      * Configurable state to control how the surfaceCreated callback      * will initialize the embedded view hierarchy.      */     int mEmbeddedViewWidth = 100;     int mEmbeddedViewHeight = 100;      private static final int DEFAULT_SURFACE_VIEW_WIDTH = 100;     private static final int DEFAULT_SURFACE_VIEW_HEIGHT = 100;      @Before     public void setUp() {         pressWakeupButton();         pressUnlockButton();         pressHomeButton();          mClicked = false;         mEmbeddedLayoutParams = null;          mInstrumentation = InstrumentationRegistry.getInstrumentation();         mActivity = mActivityRule.launchActivity(null);         mInstrumentation.waitForIdleSync();     }      private void addSurfaceView(int width, int height) throws Throwable {         mActivityRule.runOnUiThread(() -> {             final FrameLayout content = new FrameLayout(mActivity);             mSurfaceView = new SurfaceView(mActivity);             mSurfaceView.setZOrderOnTop(true);             content.addView(mSurfaceView, new FrameLayout.LayoutParams(                 width, height, Gravity.LEFT | Gravity.TOP));             mActivity.setContentView(content, new ViewGroup.LayoutParams(width, height));             mSurfaceView.getHolder().addCallback(this);         });     }      private void addViewToSurfaceView(SurfaceView sv, View v, int width, int height) {         mVr = new SurfaceControlViewHost(mActivity, mActivity.getDisplay(), sv.getHostToken());          sv.setChildSurfacePackage(mVr.getSurfacePackage());          if (mEmbeddedLayoutParams == null) {             mVr.setView(v, width, height);         } else {             mVr.setView(v, mEmbeddedLayoutParams);         }         assertEquals(v, mVr.getView());     }      @Override     public void surfaceCreated(SurfaceHolder holder) {         addViewToSurfaceView(mSurfaceView, mEmbeddedView,                 mEmbeddedViewWidth, mEmbeddedViewHeight);     }      @Override     public void surfaceDestroyed(SurfaceHolder holder) {     }      @Override     public void surfaceChanged(SurfaceHolder holder, int format, int width,             int height) {     }      ",9.11.3/C-0-1,,09110300.670001,android.content.Context getInstance() 9.11.3 C-0-1,Test[None]:[android.server.wm.SurfaceControlViewHostTests:setUp()],,android.content.Context,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/SurfaceControlViewHostTests.java,,
,9.11.3,C-0-2,,android.telephony.cts.SmsManagerTest,testSendAndReceiveMessages(),,"(timeout = 10 * 60 * 1000)     public void testSendAndReceiveMessages() throws Exception {         assertFalse(""[RERUN] SIM card does not provide phone number. Use a suitable SIM Card."",                 TextUtils.isEmpty(mDestAddr));          String mccmnc = mTelephonyManager.getSimOperator();         setupBroadcastReceivers();          // send/receive single text sms with and without messageId         sendAndReceiveSms(/* addMessageId= */ true);         sendAndReceiveSms(/* addMessageId= */ false);          // due to permission restrictions, currently there is no way to make this test app the         // default SMS app          if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA) {             // TODO: temp workaround, OCTET encoding for EMS not properly supported             return;         }          // send/receive data sms         sendDataSms(mccmnc);          // send/receive multi part text sms with and without messageId         sendAndReceiveMultipartSms(mccmnc, /* addMessageId= */ true);         sendAndReceiveMultipartSms(mccmnc, /* addMessageId= */ false);     }      ",9.11.3/C-0-2,,09110300.670002,DMA 9.11.3 android.security.identity C-0-2,Test[None]:[android.telephony.cts.SmsManagerTest:testSendAndReceiveMessages()],,DMA,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java,,
,9.11.3,C-0-3,,android.security.identity.cts.DynamicAuthTest,,,"/*  *.  */  package android.security.identity.cts;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.content.Context;  import android.security.identity.EphemeralPublicKeyNotFoundException; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.NoAuthenticationKeyAvailableException; import android.security.identity.ResultData; import androidx.test.InstrumentationRegistry;  import org.junit.Test;  import java.io.ByteArrayOutputStream; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.KeyPair; import java.security.SignatureException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.LinkedHashMap; import java.util.Map;  import javax.crypto.SecretKey;  import co.nstant.in.cbor.CborBuilder; import co.nstant.in.cbor.CborEncoder; import co.nstant.in.cbor.CborException;  public class DynamicAuthTest {     private static final String TAG = ""DynamicAuthTest"";      ",9.11.3/C-0-3,,09110300.670003,createEphemeralKeyPair() 9.11.3 android.security.identity C-0-3,Test[None]:[android.security.identity.cts.DynamicAuthTest:],,android.security.identity,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/DynamicAuthTest.java,,
,9.11.3,C-0-4,,android.net.cts.MacAddressTest,testMatches(),,"     public void testMatches() {         // match 4 bytes prefix         assertTrue(MacAddress.fromString(""aa:bb:cc:dd:ee:11"").matches(                 MacAddress.fromString(""aa:bb:cc:dd:00:00""),                 MacAddress.fromString(""ff:ff:ff:ff:00:00"")));          // match bytes 0,1,2 and 5         assertTrue(MacAddress.fromString(""aa:bb:cc:dd:ee:11"").matches(                 MacAddress.fromString(""aa:bb:cc:00:00:11""),                 MacAddress.fromString(""ff:ff:ff:00:00:ff"")));          // match 34 bit prefix         assertTrue(MacAddress.fromString(""aa:bb:cc:dd:ee:11"").matches(                 MacAddress.fromString(""aa:bb:cc:dd:c0:00""),                 MacAddress.fromString(""ff:ff:ff:ff:c0:00"")));          // fail to match 36 bit prefix         assertFalse(MacAddress.fromString(""aa:bb:cc:dd:ee:11"").matches(                 MacAddress.fromString(""aa:bb:cc:dd:40:00""),                 MacAddress.fromString(""ff:ff:ff:ff:f0:00"")));          // match all 6 bytes         assertTrue(MacAddress.fromString(""aa:bb:cc:dd:ee:11"").matches(                 MacAddress.fromString(""aa:bb:cc:dd:ee:11""),                 MacAddress.fromString(""ff:ff:ff:ff:ff:ff"")));          // match none of 6 bytes         assertTrue(MacAddress.fromString(""aa:bb:cc:dd:ee:11"").matches(                 MacAddress.fromString(""00:00:00:00:00:00""),                 MacAddress.fromString(""00:00:00:00:00:00"")));     }      /**      * Tests that link-local address generation from MAC is valid.      */     ",9.11.3/C-0-4,,09110300.670004,MAC 9.11.3 C-0-4,Test[None]:[android.net.cts.MacAddressTest:testMatches()],,MAC,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/MacAddressTest.java,,
,9.16,C-1-1,,android.hardware.camera2.cts.LogicalCameraDeviceTest,testDefaultFov(),CtsCameraTestCases,"     @CddTest(requirement=""7.5.4/C-1-1"")     public void testDefaultFov() throws Exception {         final double MIN_FOV = 50;         final double MAX_FOV = 90;         if (!isHandheldDevice()) {             return;         }         for (String id : mCameraIdsUnderTest) {             try {                 Log.i(TAG, ""Testing Camera "" + id);                  StaticMetadata staticInfo = mAllStaticInfo.get(id);                 if (!staticInfo.isColorOutputSupported()) {                     Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");                     continue;                 }                  if (!staticInfo.isLogicalMultiCamera()) {                     Log.i(TAG, ""Camera "" + id + "" is not a logical multi-camera, skipping"");                     continue;                 }                  SizeF physicalSize = staticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);                 double physicalDiag = Math.sqrt(Math.pow(physicalSize.getWidth(), 2)                         + Math.pow(physicalSize.getHeight(), 2));                 Rect activeArraySize = staticInfo.getCharacteristics().get(                         CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);                  openDevice(id);                 for (int template : sTemplates) {                     try {                         CaptureRequest.Builder requestBuilder =                                 mCamera.createCaptureRequest(template);                         Float requestFocalLength = requestBuilder.get(                                 CaptureRequest.LENS_FOCAL_LENGTH);                         assertNotNull(""LENS_FOCAL_LENGTH must not be null"", requestFocalLength);                          Float requestZoomRatio = requestBuilder.get(                                 CaptureRequest.CONTROL_ZOOM_RATIO);                         assertNotNull(""CONTROL_ZOOM_RATIO must not be null"", requestZoomRatio);                         Rect requestCropRegion = requestBuilder.get(                                 CaptureRequest.SCALER_CROP_REGION);                         assertNotNull(""SCALER_CROP_REGION must not be null"", requestCropRegion);                         float totalZoomRatio = Math.min(                                 1.0f * activeArraySize.width() / requestCropRegion.width(),                                 1.0f * activeArraySize.height() / requestCropRegion.height()) *                                 requestZoomRatio;                          double fov = 2 *                                 Math.toDegrees(Math.atan2(physicalDiag/(2 * totalZoomRatio),                                 requestFocalLength));                          Log.v(TAG, ""Camera "" +  id + "" template "" + template +                                 ""'s default FOV is "" + fov);                         mCollector.expectInRange(""Camera "" +  id + "" template "" + template +                                 ""'s default FOV must fall between [50, 90] degrees"",                                 fov, MIN_FOV, MAX_FOV);                     } catch (IllegalArgumentException e) {                         if (template == CameraDevice.TEMPLATE_MANUAL &&                                 !staticInfo.isCapabilitySupported(CameraCharacteristics.                                 REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {                             // OK                         } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG &&                                 !staticInfo.isCapabilitySupported(CameraCharacteristics.                                 REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)) {                             // OK.                         } else {                             throw e; // rethrow                         }                     }                 }             } finally {                 closeDevice();             }         }     }      /**      * Find a common preview size that's supported by both the logical camera and      * two of the underlying physical cameras.      */     private Size findCommonPreviewSize(String cameraId,             List<String> dualPhysicalCameraIds) throws Exception {          Set<String> physicalCameraIds =                 mStaticInfo.getCharacteristics().getPhysicalCameraIds();         assertTrue(""Logical camera must contain at least 2 physical camera ids"",                 physicalCameraIds.size() >= 2);          List<Size> previewSizes = getSupportedPreviewSizes(                 cameraId, mCameraManager, PREVIEW_SIZE_BOUND);         HashMap<String, List<Size>> physicalPreviewSizesMap = new HashMap<String, List<Size>>();         HashMap<String, StreamConfigurationMap> physicalConfigs = new HashMap<>();         for (String physicalCameraId : physicalCameraIds) {             CameraCharacteristics properties =                     mCameraManager.getCameraCharacteristics(physicalCameraId);             assertNotNull(""Can't get camera characteristics!"", properties);             if (!mAllStaticInfo.get(physicalCameraId).isColorOutputSupported()) {                 // No color output support, skip.                 continue;             }             StreamConfigurationMap configMap =                 properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             physicalConfigs.put(physicalCameraId, configMap);             physicalPreviewSizesMap.put(physicalCameraId,                     getSupportedPreviewSizes(physicalCameraId, mCameraManager, PREVIEW_SIZE_BOUND));         }          // Find display size from window service.         Context context = mActivityRule.getActivity().getApplicationContext();         WindowManager windowManager =                 (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);         Display display = windowManager.getDefaultDisplay();          int displayWidth = display.getWidth();         int displayHeight = display.getHeight();          if (displayHeight > displayWidth) {             displayHeight = displayWidth;             displayWidth = display.getHeight();         }          StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         for (Size previewSize : previewSizes) {             dualPhysicalCameraIds.clear();             // Skip preview sizes larger than screen size             if (previewSize.getWidth() > displayWidth ||                     previewSize.getHeight() > displayHeight) {                 continue;             }              final long minFrameDuration = config.getOutputMinFrameDuration(                    ImageFormat.YUV_420_888, previewSize);              ArrayList<String> supportedPhysicalCameras = new ArrayList<String>();             for (String physicalCameraId : physicalCameraIds) {                 List<Size> physicalPreviewSizes = physicalPreviewSizesMap.get(physicalCameraId);                 if (physicalPreviewSizes != null && physicalPreviewSizes.contains(previewSize)) {                    long minDurationPhysical =                            physicalConfigs.get(physicalCameraId).getOutputMinFrameDuration(                            ImageFormat.YUV_420_888, previewSize);                    if (minDurationPhysical <= minFrameDuration) {                         dualPhysicalCameraIds.add(physicalCameraId);                         if (dualPhysicalCameraIds.size() == 2) {                             return previewSize;                         }                    }                 }             }         }         return null;     }      /**      * Validate that physical cameras are not cropping too much.      *      * This is to make sure physical processed streams have at least the same field of view as      * the logical stream, or the maximum field of view of the physical camera, whichever is      * smaller.      *      * Note that the FOV is calculated in the directio of sensor width.      */     private void validatePhysicalCamerasFov(TotalCaptureResult totalCaptureResult,             List<String> physicalCameraIds) {         Rect cropRegion = totalCaptureResult.get(CaptureResult.SCALER_CROP_REGION);         Float focalLength = totalCaptureResult.get(CaptureResult.LENS_FOCAL_LENGTH);         Float zoomRatio = totalCaptureResult.get(CaptureResult.CONTROL_ZOOM_RATIO);         Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();         SizeF sensorSize = mStaticInfo.getValueFromKeyNonNull(                 CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);          // Assume subject distance >> focal length, and subject distance >> camera baseline.         double fov = 2 * Math.toDegrees(Math.atan2(sensorSize.getWidth() * cropRegion.width() /                 (2 * zoomRatio * activeArraySize.width()),  focalLength));          Map<String, CaptureResult> physicalResultsDual =                     totalCaptureResult.getPhysicalCameraResults();         for (String physicalId : physicalCameraIds) {             StaticMetadata physicalStaticInfo = mAllStaticInfo.get(physicalId);             CaptureResult physicalResult = physicalResultsDual.get(physicalId);             Rect physicalCropRegion = physicalResult.get(CaptureResult.SCALER_CROP_REGION);             Float physicalFocalLength = physicalResult.get(CaptureResult.LENS_FOCAL_LENGTH);             Float physicalZoomRatio = physicalResult.get(CaptureResult.CONTROL_ZOOM_RATIO);             Rect physicalActiveArraySize = physicalStaticInfo.getActiveArraySizeChecked();             SizeF physicalSensorSize = mStaticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);              double physicalFov = 2 * Math.toDegrees(Math.atan2(                     physicalSensorSize.getWidth() * physicalCropRegion.width() /                     (2 * physicalZoomRatio * physicalActiveArraySize.width()), physicalFocalLength));              double maxPhysicalFov = 2 * Math.toDegrees(Math.atan2(physicalSensorSize.getWidth() / 2,                     physicalFocalLength));             double expectedPhysicalFov = Math.min(maxPhysicalFov, fov);              if (VERBOSE) {                 Log.v(TAG, ""Logical camera Fov: "" + fov + "", maxPhyiscalFov: "" + maxPhysicalFov +                         "", physicalFov: "" + physicalFov);             }             assertTrue(""Physical stream FOV (Field of view) should be greater or equal to""                     + "" min(logical stream FOV, max physical stream FOV). Physical FOV: ""                     + physicalFov + "" vs min("" + fov + "", "" + maxPhysicalFov,                     physicalFov - expectedPhysicalFov > -FOV_THRESHOLD);         }     }      /**      * Test physical camera YUV streaming within a particular logical camera.      *      * Use 2 YUV streams with PREVIEW or smaller size.      */     private void testBasicPhysicalStreamingForCamera(String logicalCameraId,             List<String> physicalCameraIds, Size previewSize) throws Exception {         List<OutputConfiguration> outputConfigs = new ArrayList<>();         List<ImageReader> imageReaders = new ArrayList<>();          // Add 1 logical YUV stream         ImageReader logicalTarget = CameraTestUtils.makeImageReader(previewSize,                 ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,                 new ImageDropperListener(), mHandler);         imageReaders.add(logicalTarget);         outputConfigs.add(new OutputConfiguration(logicalTarget.getSurface()));          // Add physical YUV streams         if (physicalCameraIds.size() != 2) {             throw new IllegalArgumentException(""phyiscalCameraIds must contain 2 camera ids"");         }         List<ImageReader> physicalTargets = new ArrayList<>();         for (String physicalCameraId : physicalCameraIds) {             ImageReader physicalTarget = CameraTestUtils.makeImageReader(previewSize,                     ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,                     new ImageDropperListener(), mHandler);             OutputConfiguration config = new OutputConfiguration(physicalTarget.getSurface());             config.setPhysicalCameraId(physicalCameraId);             outputConfigs.add(config);             physicalTargets.add(physicalTarget);         }          SessionConfigSupport sessionConfigSupport = isSessionConfigSupported(                 mCamera, mHandler, outputConfigs, /*inputConfig*/ null,                 SessionConfiguration.SESSION_REGULAR, false/*defaultSupport*/);         assertTrue(""Session configuration query for logical camera failed with error"",                 !sessionConfigSupport.error);         if (!sessionConfigSupport.callSupported) {             return;         }          mSessionListener = new BlockingSessionCallback();         mSessionWaiter = mSessionListener.getStateWaiter();         mSession = configureCameraSessionWithConfig(mCamera, outputConfigs,                 mSessionListener, mHandler);         if (!sessionConfigSupport.configSupported) {             mSessionWaiter.waitForState(BlockingSessionCallback.SESSION_CONFIGURE_FAILED,                     SESSION_CONFIGURE_TIMEOUT_MS);             return;         }          // Stream logical YUV stream and note down the FPS         CaptureRequest.Builder requestBuilder =                 mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);         requestBuilder.addTarget(logicalTarget.getSurface());          SimpleCaptureCallback simpleResultListener =                 new SimpleCaptureCallback();         StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);         final long minFrameDuration = config.getOutputMinFrameDuration(                 ImageFormat.YUV_420_888, previewSize);         if (minFrameDuration > 0) {             Range<Integer> targetRange = getSuitableFpsRangeForDuration(logicalCameraId,                     minFrameDuration);             requestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, targetRange);         }         mSession.setRepeatingRequest(requestBuilder.build(),                 simpleResultListener, mHandler);          // Converge AE         waitForAeStable(simpleResultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);          if (mStaticInfo.isAeLockSupported()) {             // Lock AE if supported.             requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);             mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,                     mHandler);             waitForResultValue(simpleResultListener, CaptureResult.CONTROL_AE_STATE,                     CaptureResult.CONTROL_AE_STATE_LOCKED, NUM_RESULTS_WAIT_TIMEOUT);         }          // Verify results         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,                 mStaticInfo, mAllStaticInfo, null/*requestedPhysicalIds*/,                 requestBuilder, NUM_FRAMES_CHECKED);          // Collect timestamps for one logical stream only.         long prevTimestamp = -1;         long[] logicalTimestamps = new long[NUM_FRAMES_CHECKED];         for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {             TotalCaptureResult totalCaptureResult =                     simpleResultListener.getTotalCaptureResult(                     CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);             logicalTimestamps[i] = totalCaptureResult.get(CaptureResult.SENSOR_TIMESTAMP);         }          double logicalAvgDurationMs = (logicalTimestamps[NUM_FRAMES_CHECKED-1] -                 logicalTimestamps[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));          // Request one logical stream and one physical stream         simpleResultListener = new SimpleCaptureCallback();         requestBuilder.addTarget(physicalTargets.get(1).getSurface());         mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,                 mHandler);          // Verify results for physical streams request.         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,                 mStaticInfo, mAllStaticInfo, physicalCameraIds.subList(1, 2), requestBuilder,                 NUM_FRAMES_CHECKED);           // Start requesting on both logical and physical streams         SimpleCaptureCallback simpleResultListenerDual =                 new SimpleCaptureCallback();         for (ImageReader physicalTarget : physicalTargets) {             requestBuilder.addTarget(physicalTarget.getSurface());         }         mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListenerDual,                 mHandler);          // Verify results for physical streams request.         CaptureResultTest.validateCaptureResult(mCollector, simpleResultListenerDual,                 mStaticInfo, mAllStaticInfo, physicalCameraIds, requestBuilder,                 NUM_FRAMES_CHECKED);          // Acquire the timestamps of the physical camera.         long[] logicalTimestamps2 = new long[NUM_FRAMES_CHECKED];         long [][] physicalTimestamps = new long[physicalTargets.size()][];         for (int i = 0; i < physicalTargets.size(); i++) {             physicalTimestamps[i] = new long[NUM_FRAMES_CHECKED];         }         for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {             TotalCaptureResult totalCaptureResultDual =                     simpleResultListenerDual.getTotalCaptureResult(                     CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);             logicalTimestamps2[i] = totalCaptureResultDual.get(CaptureResult.SENSOR_TIMESTAMP);              int index = 0;             Map<String, CaptureResult> physicalResultsDual =                     totalCaptureResultDual.getPhysicalCameraResults();             for (String physicalId : physicalCameraIds) {                  if (physicalResultsDual.containsKey(physicalId)) {                      physicalTimestamps[index][i] = physicalResultsDual.get(physicalId).get(                              CaptureResult.SENSOR_TIMESTAMP);                  } else {                      physicalTimestamps[index][i] = -1;                  }                  index++;             }         }          // Check both logical and physical streams' crop region, and make sure their FOVs         // are similar.         TotalCaptureResult totalCaptureResult =                 simpleResultListenerDual.getTotalCaptureResult(                 CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);         validatePhysicalCamerasFov(totalCaptureResult, physicalCameraIds);          // Check timestamp monolithity for individual camera and across cameras         for (int i = 0; i < NUM_FRAMES_CHECKED-1; i++) {             assertTrue(""Logical camera timestamp must monolithically increase"",                     logicalTimestamps2[i] < logicalTimestamps2[i+1]);         }         for (int i = 0; i < physicalCameraIds.size(); i++) {             for (int j = 0 ; j < NUM_FRAMES_CHECKED-1; j++) {                 if (physicalTimestamps[i][j] != -1 && physicalTimestamps[i][j+1] != -1) {                     assertTrue(""Physical camera timestamp must monolithically increase"",                             physicalTimestamps[i][j] < physicalTimestamps[i][j+1]);                 }                 if (j > 0 && physicalTimestamps[i][j] != -1) {                     assertTrue(""Physical camera's timestamp N must be greater than logical "" +                             ""camera's timestamp N-1"",                             physicalTimestamps[i][j] > logicalTimestamps[j-1]);                 }                 if (physicalTimestamps[i][j] != -1) {                     assertTrue(""Physical camera's timestamp N must be less than logical camera's "" +                             ""timestamp N+1"", physicalTimestamps[i][j] > logicalTimestamps[j+1]);                 }             }         }          double logicalAvgDurationMs2 = (logicalTimestamps2[NUM_FRAMES_CHECKED-1] -                 logicalTimestamps2[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));         // Check CALIBRATED synchronization between physical cameras         Integer syncType = mStaticInfo.getCharacteristics().get(                 CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE);         double fpsRatio = (logicalAvgDurationMs2 - logicalAvgDurationMs)/logicalAvgDurationMs;         if (syncType == CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED) {             // Check framerate doesn't slow down with physical streams             mCollector.expectTrue(                     ""The average frame duration with concurrent physical streams is"" +                     logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +                     "" ms for logical streams only"", fpsRatio <= FRAME_DURATION_THRESHOLD);              long maxTimestampDelta = 0;             for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {                 long delta = Math.abs(physicalTimestamps[0][i] - physicalTimestamps[1][i]);                 if (delta > maxTimestampDelta) {                     maxTimestampDelta = delta;                 }             }              Log.i(TAG, ""Maximum difference between physical camera timestamps: ""                     + maxTimestampDelta);              // The maximum timestamp difference should not be larger than the threshold.             mCollector.expectTrue(                     ""The maximum timestamp deltas between the physical cameras ""                     + maxTimestampDelta + "" is larger than "" + MAX_TIMESTAMP_DIFFERENCE_THRESHOLD,                     maxTimestampDelta <= MAX_TIMESTAMP_DIFFERENCE_THRESHOLD);         } else {             // Do not enforce fps check for APPROXIMATE synced device.             if (fpsRatio > FRAME_DURATION_THRESHOLD) {                 Log.w(TAG, ""The average frame duration with concurrent physical streams is"" +                         logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +                         "" ms for logical streams only"");             }         }          if (VERBOSE) {             while (simpleResultListenerDual.hasMoreFailures()) {                 ArrayList<CaptureFailure> failures =                     simpleResultListenerDual.getCaptureFailures(/*maxNumFailures*/ 1);                 for (CaptureFailure failure : failures) {                     String physicalCameraId = failure.getPhysicalCameraId();                     if (physicalCameraId != null) {                         Log.v(TAG, ""Capture result failure for physical camera id: "" +                                 physicalCameraId);                     }                 }             }         }          // Stop preview         if (mSession != null) {             mSession.close();         }     }      /**      * The CDD defines a handheld device as one that has a battery and a screen size between      * 2.5 and 8 inches.      */     private boolean isHandheldDevice() throws Exception {         double screenInches = getScreenSizeInInches();         return deviceHasBattery() && screenInches >= 2.5 && screenInches <= 8.0;     }      private boolean deviceHasBattery() {         final Intent batteryInfo = mContext.registerReceiver(null,                 new IntentFilter(Intent.ACTION_BATTERY_CHANGED));         return batteryInfo != null && batteryInfo.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);     }      private double getScreenSizeInInches() {         DisplayMetrics dm = new DisplayMetrics();         mWindowManager.getDefaultDisplay().getMetrics(dm);         double widthInInchesSquared = Math.pow(dm.widthPixels/dm.xdpi,2);         double heightInInchesSquared = Math.pow(dm.heightPixels/dm.ydpi,2);         return Math.sqrt(widthInInchesSquared + heightInInchesSquared);     } } ",9.16/C-1-1,,09160000.670101,9.16 C-1-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.LogicalCameraDeviceTest:testDefaultFov()],,C-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/LogicalCameraDeviceTest.java,,
,9.16,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.16/C-1-2,,09160000.670102,9.16 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.16,C-1-4,,android.server.wm.DisplayCutoutTests,testDisplayCutout_always(),,"     public void testDisplayCutout_always() {         runTest(LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS, (a, insets, displayCutout, which) -> {             if (which == ROOT) {                 assertThat(""Display.getCutout() must equal view root cutout"",                         a.getDisplay().getCutout(), equalTo(displayCutout));             }         });     }      private void runTest(int cutoutMode, TestDef test) {         runTest(cutoutMode, test, orientation);     }      private void runTest(int cutoutMode, TestDef test, int orientation) {         assumeTrue(""Skipping test: orientation not supported"", supportsOrientation(orientation));         final TestActivity activity = launchAndWait(mDisplayCutoutActivity,                 cutoutMode, orientation);          WindowInsets insets = getOnMainSync(activity::getRootInsets);         WindowInsets dispatchedInsets = getOnMainSync(activity::getDispatchedInsets);         Assert.assertThat(""test setup failed, no insets at root"", insets, notNullValue());         Assert.assertThat(""test setup failed, no insets dispatched"",                 dispatchedInsets, notNullValue());          final DisplayCutout displayCutout = insets.getDisplayCutout();         final DisplayCutout dispatchedDisplayCutout = dispatchedInsets.getDisplayCutout();         if (displayCutout != null) {             commonAsserts(activity, displayCutout);             if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS) {                 shortEdgeAsserts(activity, insets, displayCutout);             }             assertCutoutsAreConsistentWithInsets(activity, displayCutout);             assertSafeInsetsAreConsistentWithDisplayCutoutInsets(insets);         }         test.run(activity, insets, displayCutout, ROOT);          if (dispatchedDisplayCutout != null) {             commonAsserts(activity, dispatchedDisplayCutout);             if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS) {                 shortEdgeAsserts(activity, insets, displayCutout);             }             assertCutoutsAreConsistentWithInsets(activity, dispatchedDisplayCutout);             if (cutoutMode != LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT) {                 assertSafeInsetsAreConsistentWithDisplayCutoutInsets(dispatchedInsets);             }         }         test.run(activity, dispatchedInsets, dispatchedDisplayCutout, DISPATCHED);     }      private void assertSafeInsetsAreConsistentWithDisplayCutoutInsets(WindowInsets insets) {         DisplayCutout cutout = insets.getDisplayCutout();         Insets safeInsets = Insets.of(safeInsets(cutout));         assertEquals(""WindowInsets.getInsets(displayCutout()) must equal""                         + "" DisplayCutout.getSafeInsets()"",                 safeInsets, insets.getInsets(Type.displayCutout()));         assertEquals(""WindowInsets.getInsetsIgnoringVisibility(displayCutout()) must equal""                         + "" DisplayCutout.getSafeInsets()"",                 safeInsets, insets.getInsetsIgnoringVisibility(Type.displayCutout()));     }      private void commonAsserts(TestActivity activity, DisplayCutout cutout) {         assertSafeInsetsValid(cutout);         assertCutoutsAreWithinSafeInsets(activity, cutout);         assertBoundsAreNonEmpty(cutout);         assertAtMostOneCutoutPerEdge(activity, cutout);     }      private void shortEdgeAsserts(             TestActivity activity, WindowInsets insets, DisplayCutout cutout) {         assertOnlyShortEdgeHasInsets(activity, cutout);         assertOnlyShortEdgeHasBounds(activity, cutout);         assertThat(""systemWindowInsets (also known as content insets) must be at least as ""                         + ""large as cutout safe insets"",                 safeInsets(cutout), insetsLessThanOrEqualTo(systemWindowInsets(insets)));     }      private void assertCutoutIsConsistentWithInset(String position, DisplayCutout cutout,             int safeInsetSize, Rect appBound) {         if (safeInsetSize > 0) {             assertThat(""cutout must have a bound on the "" + position,                     hasBound(position, cutout, appBound), is(true));         } else {             assertThat(""cutout  must have no bound on the "" + position,                     hasBound(position, cutout, appBound), is(false));         }     }      public void assertCutoutsAreConsistentWithInsets(TestActivity activity, DisplayCutout cutout) {         final Rect appBounds = getAppBounds(activity);         assertCutoutIsConsistentWithInset(TOP, cutout, cutout.getSafeInsetTop(), appBounds);         assertCutoutIsConsistentWithInset(BOTTOM, cutout, cutout.getSafeInsetBottom(), appBounds);         assertCutoutIsConsistentWithInset(LEFT, cutout, cutout.getSafeInsetLeft(), appBounds);         assertCutoutIsConsistentWithInset(RIGHT, cutout, cutout.getSafeInsetRight(), appBounds);     }      private void assertSafeInsetsValid(DisplayCutout displayCutout) {         //noinspection unchecked         assertThat(""all safe insets must be non-negative"", safeInsets(displayCutout),                 insetValues(everyItem((Matcher)greaterThanOrEqualTo(0))));         assertThat(""at least one safe inset must be positive,""                         + "" otherwise WindowInsets.getDisplayCutout()) must return null"",                 safeInsets(displayCutout), insetValues(hasItem(greaterThan(0))));     }      private void assertCutoutsAreWithinSafeInsets(TestActivity a, DisplayCutout cutout) {         final Rect safeRect = getSafeRect(a, cutout);          assertThat(""safe insets must not cover the entire screen"", safeRect.isEmpty(), is(false));         for (Rect boundingRect : cutout.getBoundingRects()) {             assertThat(""boundingRects must not extend beyond safeInsets"",                     boundingRect, not(intersectsWith(safeRect)));         }     }      private void assertAtMostOneCutoutPerEdge(TestActivity a, DisplayCutout cutout) {         final Rect safeRect = getSafeRect(a, cutout);          assertThat(""must not have more than one left cutout"",                 boundsWith(cutout, (r) -> r.right <= safeRect.left), hasSize(lessThanOrEqualTo(1)));         assertThat(""must not have more than one top cutout"",                 boundsWith(cutout, (r) -> r.bottom <= safeRect.top), hasSize(lessThanOrEqualTo(1)));         assertThat(""must not have more than one right cutout"",                 boundsWith(cutout, (r) -> r.left >= safeRect.right), hasSize(lessThanOrEqualTo(1)));         assertThat(""must not have more than one bottom cutout"",                 boundsWith(cutout, (r) -> r.top >= safeRect.bottom), hasSize(lessThanOrEqualTo(1)));     }      private void assertBoundsAreNonEmpty(DisplayCutout cutout) {         for (Rect boundingRect : cutout.getBoundingRects()) {             assertThat(""rect in boundingRects must not be empty"",                     boundingRect.isEmpty(), is(false));         }     }      private void assertOnlyShortEdgeHasInsets(TestActivity activity,             DisplayCutout displayCutout) {         final Rect appBounds = getAppBounds(activity);         if (appBounds.height() > appBounds.width()) {             // Portrait display             assertThat(""left edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetLeft(), is(0));             assertThat(""right edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetRight(), is(0));         }         if (appBounds.height() < appBounds.width()) {             // Landscape display             assertThat(""top edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetTop(), is(0));             assertThat(""bottom edge has a cutout despite being long edge"",                     displayCutout.getSafeInsetBottom(), is(0));         }     }      private void assertOnlyShortEdgeHasBounds(TestActivity activity, DisplayCutout cutout) {         final Rect appBounds = getAppBounds(activity);         if (appBounds.height() > appBounds.width()) {             // Portrait display             assertThat(""left edge has a cutout despite being long edge"",                     hasBound(LEFT, cutout, appBounds), is(false));              assertThat(""right edge has a cutout despite being long edge"",                     hasBound(RIGHT, cutout, appBounds), is(false));         }         if (appBounds.height() < appBounds.width()) {             // Landscape display             assertThat(""top edge has a cutout despite being long edge"",                     hasBound(TOP, cutout, appBounds), is(false));              assertThat(""bottom edge has a cutout despite being long edge"",                     hasBound(BOTTOM, cutout, appBounds), is(false));         }     }      private boolean hasBound(String position, DisplayCutout cutout, Rect appBound) {         final Rect cutoutRect;         final int waterfallSize;         if (LEFT.equals(position)) {             cutoutRect = cutout.getBoundingRectLeft();             waterfallSize = cutout.getWaterfallInsets().left;         } else if (TOP.equals(position)) {             cutoutRect = cutout.getBoundingRectTop();             waterfallSize = cutout.getWaterfallInsets().top;         } else if (RIGHT.equals(position)) {             cutoutRect = cutout.getBoundingRectRight();             waterfallSize = cutout.getWaterfallInsets().right;         } else {             cutoutRect = cutout.getBoundingRectBottom();             waterfallSize = cutout.getWaterfallInsets().bottom;         }         return Rect.intersects(cutoutRect, appBound) || waterfallSize > 0;     }      private List<Rect> boundsWith(DisplayCutout cutout, Predicate<Rect> predicate) {         return cutout.getBoundingRects().stream().filter(predicate).collect(Collectors.toList());     }      private static Rect safeInsets(DisplayCutout displayCutout) {         if (displayCutout == null) {             return null;         }         return new Rect(displayCutout.getSafeInsetLeft(), displayCutout.getSafeInsetTop(),                 displayCutout.getSafeInsetRight(), displayCutout.getSafeInsetBottom());     }      private static Rect systemWindowInsets(WindowInsets insets) {         return new Rect(insets.getSystemWindowInsetLeft(), insets.getSystemWindowInsetTop(),                 insets.getSystemWindowInsetRight(), insets.getSystemWindowInsetBottom());     }      private static Rect stableInsets(WindowInsets insets) {         return new Rect(insets.getStableInsetLeft(), insets.getStableInsetTop(),                 insets.getStableInsetRight(), insets.getStableInsetBottom());     }      private Rect getSafeRect(TestActivity a, DisplayCutout cutout) {         final Rect safeRect = safeInsets(cutout);         safeRect.bottom = getOnMainSync(() -> a.getDecorView().getHeight()) - safeRect.bottom;         safeRect.right = getOnMainSync(() -> a.getDecorView().getWidth()) - safeRect.right;         return safeRect;     }      private Rect getAppBounds(TestActivity a) {         final Rect appBounds = new Rect();         runOnMainSync(() -> {             appBounds.right = a.getDecorView().getWidth();             appBounds.bottom = a.getDecorView().getHeight();         });         return appBounds;     }      private static Matcher<Rect> insetsLessThanOrEqualTo(Rect max) {         return new CustomTypeSafeMatcher<Rect>(""must be smaller on each side than "" + max) {             @Override             protected boolean matchesSafely(Rect actual) {                 return actual.left <= max.left && actual.top <= max.top                         && actual.right <= max.right && actual.bottom <= max.bottom;             }         };     }      private static Matcher<Rect> intersectsWith(Rect safeRect) {         return new CustomTypeSafeMatcher<Rect>(""intersects with "" + safeRect) {             @Override             protected boolean matchesSafely(Rect item) {                 return Rect.intersects(safeRect, item);             }         };     }      private static Matcher<Rect> insetValues(Matcher<Iterable<? super Integer>> valuesMatcher) {         return new FeatureMatcher<Rect, Iterable<Integer>>(valuesMatcher, ""inset values"",                 ""inset values"") {             @Override             protected Iterable<Integer> featureValueOf(Rect actual) {                 return Arrays.asList(actual.left, actual.top, actual.right, actual.bottom);             }         };     }      private <T> void assertThat(String reason, T actual, Matcher<? super T> matcher) {         mErrorCollector.checkThat(reason, actual, matcher);     }      private <R> R getOnMainSync(Supplier<R> f) {         final Object[] result = new Object[1];         runOnMainSync(() -> result[0] = f.get());         //noinspection unchecked         return (R) result[0];     }      private void runOnMainSync(Runnable runnable) {         getInstrumentation().runOnMainSync(runnable);     }      private <T extends TestActivity> T launchAndWait(ActivityTestRule<T> rule, int cutoutMode,             int orientation) {         final T activity = rule.launchActivity(                 new Intent().putExtra(EXTRA_CUTOUT_MODE, cutoutMode)                         .putExtra(EXTRA_ORIENTATION, orientation));         PollingCheck.waitFor(activity::hasWindowFocus);         PollingCheck.waitFor(() -> {             final Rect appBounds = getAppBounds(activity);             final Point displaySize = new Point();             activity.getDisplay().getRealSize(displaySize);             // During app launch into a different rotation, we have temporarily have the display             // in a different rotation than the app itself. Wait for this to settle.             return (appBounds.width() > appBounds.height()) == (displaySize.x > displaySize.y);         });         return activity;     }      private boolean supportsOrientation(int orientation) {         String systemFeature = """";         switch(orientation) {             case SCREEN_ORIENTATION_PORTRAIT:             case SCREEN_ORIENTATION_REVERSE_PORTRAIT:                 systemFeature = PackageManager.FEATURE_SCREEN_PORTRAIT;                 break;             case SCREEN_ORIENTATION_LANDSCAPE:             case SCREEN_ORIENTATION_REVERSE_LANDSCAPE:                 systemFeature = PackageManager.FEATURE_SCREEN_LANDSCAPE;                 break;             default:                 throw new UnsupportedOperationException(""Orientation not supported"");         }          return getInstrumentation().getTargetContext().getPackageManager()                 .hasSystemFeature(systemFeature);     }      public static class TestActivity extends Activity {          static final String EXTRA_CUTOUT_MODE = ""extra.cutout_mode"";         static final String EXTRA_ORIENTATION = ""extra.orientation"";         private WindowInsets mDispatchedInsets;          @Override         protected void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             getWindow().requestFeature(Window.FEATURE_NO_TITLE);             if (getIntent() != null) {                 getWindow().getAttributes().layoutInDisplayCutoutMode = getIntent().getIntExtra(                         EXTRA_CUTOUT_MODE, LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT);                 setRequestedOrientation(getIntent().getIntExtra(                         EXTRA_ORIENTATION, SCREEN_ORIENTATION_UNSPECIFIED));             }             View view = new View(this);             view.setLayoutParams(new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));             view.setOnApplyWindowInsetsListener((v, insets) -> mDispatchedInsets = insets);             setContentView(view);         }          @Override         public void onWindowFocusChanged(boolean hasFocus) {             if (hasFocus) {                 getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN                         | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION                         | View.SYSTEM_UI_FLAG_FULLSCREEN                         | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);             }         }          View getDecorView() {             return getWindow().getDecorView();         }          WindowInsets getRootInsets() {             return getWindow().getDecorView().getRootWindowInsets();         }          WindowInsets getDispatchedInsets() {             return mDispatchedInsets;         }     }      interface TestDef {         void run(TestActivity a, WindowInsets insets, DisplayCutout cutout, Which whichInsets);          enum Which {             DISPATCHED, ROOT         }     } } ",9.16/C-1-4,,09160000.670104,AND 9.16 C-1-4,Test[None]:[android.server.wm.DisplayCutoutTests:testDisplayCutout_always()],,AND,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,,
,9.16,C-1-5,,android.graphics.cts.VulkanFeaturesTest,testVulkan1_1Requirements(),,"     public void testVulkan1_1Requirements() throws JSONException {         if (mVulkanHardwareVersion == null || mVulkanHardwareVersion.version < VULKAN_1_1                 || !PropertyUtil.isVendorApiLevelNewerThan(                         API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ)) {             return;         }         assertTrue(""Devices with Vulkan 1.1 must support sampler YCbCr conversion"",                 mBestDevice.getJSONObject(""samplerYcbcrConversionFeatures"")                            .getInt(""samplerYcbcrConversion"") != 0);          if (hasOnlyCpuDevice()) {             return;         }         assertTrue(""Devices with Vulkan 1.1 must support "" +                 VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME +                 "" (version >= "" + VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION +                 "")"",                 hasExtension(mBestDevice,                     VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME,                     VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION));         assertTrue(""Devices with Vulkan 1.1 must support SYNC_FD external semaphores"",                 hasHandleType(mBestDevice.getJSONArray(""externalSemaphoreProperties""),                     VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,                     ""externalSemaphoreFeatures"", 0x3 /* importable + exportable */));         assertTrue(""Devices with Vulkan 1.1 must support SYNC_FD external fences"",                 hasHandleType(mBestDevice.getJSONArray(""externalFenceProperties""),                     VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,                     ""externalFenceFeatures"", 0x3 /* importable + exportable */));     }      @CddTest(requirement = ""7.9.2/C-1-5"")     ",9.16/C-1-5,,09160000.670105,9.16 C-1-5,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkan1_1Requirements()],,C-1-5,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayCutoutTests.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
