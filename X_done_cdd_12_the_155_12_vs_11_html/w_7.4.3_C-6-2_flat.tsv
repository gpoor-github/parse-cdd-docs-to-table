"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.LauncherAppsTest"	"dropShellPermissionIdentity"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/LauncherAppsTest.java"	""	"/*
 *.
 */

package com.android.cts.managedprofile;

import static android.app.admin.DevicePolicyManager.FLAG_MANAGED_CAN_ACCESS_PARENT;
import static android.app.admin.DevicePolicyManager.FLAG_PARENT_CAN_ACCESS_MANAGED;
import static android.util.DisplayMetrics.DENSITY_DEFAULT;

import static com.android.cts.managedprofile.BaseManagedProfileTest.ADMIN_RECEIVER_COMPONENT;

import static junit.framework.Assert.assertTrue;

import android.app.admin.DevicePolicyManager;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.LauncherApps;
import android.content.pm.ShortcutInfo;
import android.content.pm.ShortcutManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.Icon;
import android.os.Bundle;
import android.os.UserHandle;
import android.util.DisplayMetrics;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;
import static com.google.common.truth.Truth.assertThat;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Collections;
import java.util.List;

@RunWith(AndroidJUnit4.class)
public class LauncherAppsTest {

    private static final String INTERACT_ACROSS_USERS_FULL_PERMISSION =
            ""android.permission.INTERACT_ACROSS_USERS_FULL"";
    private static final String ACCESS_SHORTCUTS_PERMISSION = ""android.permission.ACCESS_SHORTCUTS"";

    private final Context mContext = InstrumentationRegistry.getContext();

    @After
    public void tearDown() {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
    }"	""	""	"android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.util.ShellIdentityUtils"	"adoptShellPermissionIdentity"	""	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/ShellIdentityUtils.java"	""	"public void test/*
 *.
 */

package com.android.compatibility.common.util;

import android.app.UiAutomation;

import androidx.test.InstrumentationRegistry;

import java.util.function.BiFunction;
import java.util.function.Supplier;

/**
 * Provides utility methods to invoke system and privileged APIs as the shell user.
 */
public class ShellIdentityUtils {

    /**
     * Utility interface to invoke a method against the target object.
     *
     * @param <T> the type returned by the invoked method.
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionMethodHelper<T, U> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         * @return the result of the invoked method.
         */
        T callMethod(U targetObject);
    }

    /**
     * Utility interface to invoke a method against the target object.
     *
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionMethodHelperNoReturn<U> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         */
        void callMethod(U targetObject);
    }

    /**
     * Utility interface to invoke a method against the target object that may throw an Exception.
     *
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionThrowableMethodHelper<T, U, E extends Throwable> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         * @return the result of the target method.
         */
        T callMethod(U targetObject) throws E;
    }

    /**
     * Utility interface to invoke a method against the target object that may throw an Exception.
     *
     * @param <U> the type of the object against which the method is invoked.
     */
    public interface ShellPermissionThrowableMethodHelperNoReturn<U, E extends Throwable> {
        /**
         * Invokes the method against the target object.
         *
         * @param targetObject the object against which the method should be invoked.
         */
        void callMethod(U targetObject) throws E;
    }

    /**
     * Invokes the specified method on the targetObject as the shell user. The method can be invoked
     * as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId());}
     */
    public static <T, U> T invokeMethodWithShellPermissions(U targetObject,
            ShellPermissionMethodHelper<T, U> methodHelper) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            return methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method on the targetObject as the shell user with only the subset of
     * permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId(), ""android.permission.READ_PHONE_STATE"");}
     */
    public static <T, U> T invokeMethodWithShellPermissions(U targetObject,
            ShellPermissionMethodHelper<T, U> methodHelper, String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /** A three argument {@link java.util.function.Function}. */
    public interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }

    /** A four argument {@link java.util.function.Function}. */
    public interface QuadFunction<T, U, V, W, R> {
        R apply(T t, U u, V v, W w);
    }

    /**
     * Invokes the specified method wht arg1 and arg2, as the shell user
     * with only the subset of permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(op, pers,
     *        mTelephonyManager::setNetworkSelectionModeManual(on, p),
     *        ""android.permission.MODIFY_PHONE_STATE"");}
     */
    public static <T, U, R> R invokeMethodWithShellPermissions(T arg1, U arg2,
            BiFunction<? super T, ? super U, ? extends R>  methodHelper, String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.apply(arg1, arg2);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method with arg1, arg2 and arg3, as the shell user
     * with only the subset of permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(req, cb, exe,
     *        mTelephonyManager::requestNetworkScan,
     *        ""android.permission.MODIFY_PHONE_STATE"",
     *        ""android.permission.ACCESS_FINE_LOCATION"");}
     */
    public static <T, U, V, R> R invokeMethodWithShellPermissions(T arg1, U arg2, V arg3,
            TriFunction<? super T, ? super U, ? super V, ? extends R>  methodHelper,
            String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.apply(arg1, arg2, arg3);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method with arg1, arg2, arg3 and arg4, as the shell
     * user with only the subset of permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(a, b, c, d,
     *        mTelephonyManager::requestSomething,
     *        ""android.permission.MODIFY_PHONE_STATE"",
     *        ""android.permission.ACCESS_FINE_LOCATION"");}
     */
    public static <T, U, V, W, R> R invokeMethodWithShellPermissions(T arg1, U arg2, V arg3, W arg4,
            QuadFunction<? super T, ? super U, ? super V, ? super W, ? extends R>  methodHelper,
            String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.apply(arg1, arg2, arg3, arg4);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method on the targetObject as the shell user with only the subset of
     * permissions specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mRcsUceAdapter,
     *        (m) -> RcsUceAdapter::getUcePublishState, ImsException.class,
     *                     ""android.permission.READ_PRIVILEGED_PHONE_STATE"")}
     */
    public static <T, U, E extends Throwable> T invokeThrowableMethodWithShellPermissions(
            U targetObject, ShellPermissionThrowableMethodHelper<T, U, E> methodHelper,
            Class<E> clazz, String... permissions) throws E {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            return methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified method on the targetObject as the shell user for only the permissions
     * specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId(), ""android.permission.READ_PHONE_STATE"");}
     */
    public static <U> void invokeMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionMethodHelperNoReturn<U> methodHelper,
            String... permissions) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified throwable method on the targetObject as the shell user with only the
     * subset of permissions specified specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mImsMmtelManager,
     *        (m) -> m.isSupported(...), ImsException.class);}
     */
    public static <U, E extends Throwable> void invokeThrowableMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionThrowableMethodHelperNoReturn<U, E> methodHelper,
            Class<E> clazz) throws E {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Invokes the specified throwable method on the targetObject as the shell user with only the
     * subset of permissions specified specified. The method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mImsMmtelManager,
     *        (m) -> m.isSupported(...), ImsException.class,
     *        ""android.permission.READ_PRIVILEGED_PHONE_STATE"");}
     */
    public static <U, E extends Throwable> void invokeThrowableMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionThrowableMethodHelperNoReturn<U, E> methodHelper,
            Class<E> clazz, String... permissions) throws E {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(permissions);
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }


    /**
     * Invokes the specified method on the targetObject as the shell user. The method can be invoked
     * as follows:
     *
     * {@code ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
     *        (tm) -> tm.getDeviceId());}
     */
    public static <U> void invokeMethodWithShellPermissionsNoReturn(
            U targetObject, ShellPermissionMethodHelperNoReturn<U> methodHelper) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            methodHelper.callMethod(targetObject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Utility interface to invoke a static method.
     *
     * @param <T> the type returned by the invoked method.
     */
    public interface StaticShellPermissionMethodHelper<T> {
        /**
         * Invokes the static method.
         *
         * @return the result of the invoked method.
         */
        T callMethod();
    }

    /**
     * Invokes the specified static method as the shell user. This method can be invoked as follows:
     *
     * {@code ShellIdentityUtils.invokeStaticMethodWithShellPermissions(Build::getSerial));}
     */
    public static <T> T invokeStaticMethodWithShellPermissions(
            StaticShellPermissionMethodHelper<T> methodHelper) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            return methodHelper.callMethod();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Drop the shell permission identity adopted by a previous call to
     * {@link UiAutomation#adoptShellPermissionIdentity()}.
     */
    public static void dropShellPermissionIdentity() {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();

        uiAutomation.dropShellPermissionIdentity();
    }

    /**
     * Run an arbitrary piece of code while holding shell permissions.
     *
     * @param supplier an expression that performs the desired operation with shell permissions
     * @param <T> the return type of the expression
     * @return the return value of the expression
     */
    public static <T> T invokeWithShellPermissions(Supplier<T> supplier) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            return supplier.get();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Run an arbitrary piece of code while holding shell permissions.
     *
     * @param runnable an expression that performs the desired operation with shell permissions
     * @return the return value of the expression
     */
    public static void invokeWithShellPermissions(Runnable runnable) {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            runnable.run();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }
}"	""	""	"ACCESS_FINE_LOCATION android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.WifiNetworkConfigurationWithoutFineLocationPermissionTest"	"testAddAndRetrieveCallerConfiguredNetworks"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/WifiNetworkConfigurationWithoutFineLocationPermissionTest.java"	""	"public void testAddAndRetrieveCallerConfiguredNetworks() throws Exception {
        assertWithMessage(""wifi is enabled"").that(mWifiManager.isWifiEnabled()).isTrue();
        assertWithMessage(""permission status (denied=%s) for %s on user %s"",
                PackageManager.PERMISSION_DENIED, Manifest.permission.ACCESS_FINE_LOCATION, mUserId)
                        .that(mContext.checkSelfPermission(
                                        Manifest.permission.ACCESS_FINE_LOCATION))
                        .isEqualTo(PackageManager.PERMISSION_DENIED);

        int netId = mWifiConfigCreator.addNetwork(NETWORK_SSID, /* hidden */ false,
                SECURITY_TYPE_NONE, /* password */ null);
        assertWithMessage(""id of added network"").that(netId).isNotEqualTo(INVALID_NETWORK_ID);

        try {
            List<WifiConfiguration> configs = mWifiManager.getCallerConfiguredNetworks();
            assertWithMessage(""configured networks"").that(configs).isNotEmpty();
            assertWithMessage(""SSID of configured networks"").that(configs.get(0).SSID)
                    .isEqualTo('""' + NETWORK_SSID + '""');
        } finally {
            Log.d(TAG, ""Removing network "" + netId);
            mWifiManager.removeNetwork(netId);
        }
    }

    private void awaitWifiEnabled()  {
        for (int probes = 0; probes * UPDATE_INTERVAL_MS <= UPDATE_TIMEOUT_MS; probes++) {
            if (probes != 0) {
                SystemClock.sleep(UPDATE_INTERVAL_MS);
            }
            if (mWifiManager.isWifiEnabled()) {
                return;
            }
        }
        fail(""Waited too long for wifi enabled"");
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyManagerTest"	"testHasCarrierPrivilegesViaCarrierConfigs"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	"public void testHasCarrierPrivilegesViaCarrierConfigs() throws Exception {
        if (!hasCellular()) return;
        PersistableBundle carrierConfig = mCarrierConfigManager.getConfigForSubId(mTestSub);

        try {
            assertNotNull(""CarrierConfigManager#getConfigForSubId() returned null"",
                    carrierConfig);
            assertFalse(""CarrierConfigManager#getConfigForSubId() returned empty bundle"",
                    carrierConfig.isEmpty());

            // purge the certs in carrierConfigs first
            carrierConfig.putStringArray(
                    CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY, new String[]{});
            overrideCarrierConfig(carrierConfig);
            // verify we don't have privilege through carrierConfigs or Uicc
            assertFalse(mTelephonyManager.hasCarrierPrivileges());

            carrierConfig.putStringArray(
                    CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY,
                    new String[]{mSelfCertHash});

            // verify we now have privilege after adding certificate to carrierConfigs
            overrideCarrierConfig(carrierConfig);
            assertTrue(mTelephonyManager.hasCarrierPrivileges());
        } finally {
            // purge the newly added certificate
            carrierConfig.putStringArray(
                    CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY, new String[]{});
            // carrierConfig.remove(CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY);
            overrideCarrierConfig(carrierConfig);

            // verify we no longer have privilege after removing certificate
            assertFalse(mTelephonyManager.hasCarrierPrivileges());
        }
    }

    private void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        mReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mCarrierConfigManager,
                (cm) -> cm.overrideConfig(mTestSub, bundle));
        mReceiver.waitForCarrierConfigChanged();
    }

    public static void grantLocationPermissions() {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        String packageName = getContext().getPackageName();
        uiAutomation.grantRuntimePermission(packageName, permission.ACCESS_COARSE_LOCATION);
        uiAutomation.grantRuntimePermission(packageName, permission.ACCESS_FINE_LOCATION);
        uiAutomation.grantRuntimePermission(packageName, permission.ACCESS_BACKGROUND_LOCATION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.ComponentName;
import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SdkSuppress;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests location sensitive APIs exposed by Wi-Fi.
 * Ensures that permissions on these APIs are properly enforced.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class WifiLocationInfoTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiLocationInfoTest"";

    private static final String WIFI_LOCATION_TEST_APP_APK_PATH =
            ""/data/local/tmp/cts/wifi/CtsWifiLocationTestApp.apk"";
    private static final String WIFI_LOCATION_TEST_APP_PACKAGE_NAME =
            ""android.net.wifi.cts.app"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveTransportInfoAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveTransportInfoAndReturnStatusService"";

    private static final int DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    @Rule
    public final ActivityTestRule<WaitForResultActivity> mActivityRule =
            new ActivityTestRule<>(WaitForResultActivity.class);

    private Context mContext;
    private WifiManager mWifiManager;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        installApp(WIFI_LOCATION_TEST_APP_APK_PATH);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", DURATION_MS, () -> mWifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;

        uninstallApp(WIFI_LOCATION_TEST_APP_PACKAGE_NAME);

        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        // now trigger the change using shell commands.
        SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
    }

    private void turnScreenOn() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(
                ""input keyevent KEYCODE_WAKEUP"");
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(""""
                + ""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(2_000);
    }

    private void turnScreenOff() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(
                ""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(2_000);
    }

    private void installApp(String apk) throws InterruptedException {
        String installResult = SystemUtil.runShellCommand(""pm install -r -d "" + apk);
        Thread.sleep(10_000);
        assertThat(installResult.trim()).isEqualTo(""Success"");
    }

    private void uninstallApp(String pkg) throws InterruptedException {
        String uninstallResult = SystemUtil.runShellCommand(
                ""pm uninstall "" + pkg);
        Thread.sleep(10_000);
        assertThat(uninstallResult.trim()).isEqualTo(""Success"");
    }

    private void startFgActivityAndAssertStatusIs(
            ComponentName componentName, boolean status) throws Exception {
        turnScreenOn();

        WaitForResultActivity activity = mActivityRule.getActivity();
        activity.startActivityToWaitForResult(componentName);
        assertThat(activity.waitForActivityResult(DURATION_MS)).isEqualTo(status);
    }

    private void startBgServiceAndAssertStatusIs(
            ComponentName componentName, boolean status) throws Exception {
        turnScreenOff();

        WaitForResultActivity activity = mActivityRule.getActivity();
        activity.startServiceToWaitForResult(componentName);
        assertThat(activity.waitForServiceResult(DURATION_MS)).isEqualTo(status);
    }

    private void triggerScanFgActivityAndAssertStatusIs(boolean status) throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY), status);
    }

    private void triggerScanBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE), status);
    }

    private void retrieveScanResultsFgActivityAndAssertStatusIs(boolean status) throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY), status);
    }

    private void retrieveScanResultsBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE), status);
    }

    private void retrieveConnectionInfoFgActivityAndAssertStatusIs(boolean status)
            throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY), status);
    }

    private void retrieveConnectionInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE), status);
    }

    private void retrieveTransportInfoFgActivityAndAssertStatusIs(boolean status)
            throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_ACTIVITY), status);
    }

    private void retrieveTransportInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE), status);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        triggerScanFgActivityAndAssertStatusIs(true);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        triggerScanBgServiceAndAssertStatusIs(true);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        triggerScanBgServiceAndAssertStatusIs(false);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveScanResultsFgActivityAndAssertStatusIs(true);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveScanResultsBgServiceAndAssertStatusIs(true);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveScanResultsBgServiceAndAssertStatusIs(false);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testConnectionInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testConnectionInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveConnectionInfoFgActivityAndAssertStatusIs(true);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testConnectionInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void
        testConnectionInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveConnectionInfoBgServiceAndAssertStatusIs(true);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testConnectionInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void
        testConnectionInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveConnectionInfoBgServiceAndAssertStatusIs(false);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testTransportInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testTransportInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveTransportInfoFgActivityAndAssertStatusIs(true);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testTransportInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void
    testTransportInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveTransportInfoBgServiceAndAssertStatusIs(true);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testTransportInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void
    testTransportInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveTransportInfoBgServiceAndAssertStatusIs(false);
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionWhitelistedAtInstall29() throws Exception {
        installApp(APK_USES_LOCATION_29, null, new ArraySet<>(Arrays.asList(ACCESS_FINE_LOCATION,
                ACCESS_BACKGROUND_LOCATION)));
        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionNotWhitelistedAtInstall29"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionNotWhitelistedAtInstall29() throws Exception {
        installApp(APK_USES_LOCATION_29, Collections.emptySet(),
                Collections.singleton(ACCESS_FINE_LOCATION));
        assertNoRestrictedPermissionWhitelisted();
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionWhitelistedAtInstall22() throws Exception {
        installApp(APK_USES_LOCATION_22, null, new ArraySet<>(Arrays.asList(ACCESS_FINE_LOCATION,
                ACCESS_BACKGROUND_LOCATION)));
        assertAllRestrictedPermissionWhitelisted();
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionNotWhitelistedAtInstall22"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    public void testLocationBackgroundPermissionNotWhitelistedAtInstall22() throws Exception {
        installApp(APK_USES_LOCATION_22, Collections.emptySet(),
                Collections.singleton(ACCESS_FINE_LOCATION));
        assertNoRestrictedPermissionWhitelisted();
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission2.cts.RestrictedPermissionsTest"	"isTrue"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	"@AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void shareUidBetweenRestrictedAndNotRestrictedApp() throws Exception {
        runShellCommand(
                ""pm install -g --force-queryable --restrict-permissions ""
                + APK_USES_SMS_RESTRICTED_SHARED_UID);
        runShellCommand(""pm install -g --force-queryable ""
                + APK_USES_SMS_NOT_RESTRICTED_SHARED_UID);

        eventually(
                () -> assertThat(isGranted(PKG_USES_SMS_RESTRICTED_SHARED_UID, READ_SMS)).isTrue());
        // The apps share a UID, hence the whitelisting is shared too
        assertThat(isGranted(PKG_USES_SMS_NOT_RESTRICTED_SHARED_UID, READ_SMS)).isTrue();
    }

    private static void installRestrictedPermissionUserApp(@NonNull SessionParams params)
            throws Exception {
        final CountDownLatch installLatch = new CountDownLatch(1);

        // Create an install result receiver.
        final BroadcastReceiver installReceiver = new BroadcastReceiver() {
            public void onReceive(Context context, Intent intent) {
                if (intent.getIntExtra(PackageInstaller.EXTRA_STATUS,
                        PackageInstaller.STATUS_FAILURE_INVALID)
                            == PackageInstaller.STATUS_SUCCESS) {
                    installLatch.countDown();
                }
            }
        };

        // Register the result receiver.
        final String action = ""android.permission2.cts.ACTION_INSTALL_COMMIT"";
        final IntentFilter intentFilter = new IntentFilter(action);
        getContext().registerReceiver(installReceiver, intentFilter);

        try {
            // Create a session.
            final PackageInstaller packageInstaller = getContext()
                    .getPackageManager().getPackageInstaller();
            final int sessionId = packageInstaller.createSession(params);
            final Session session = packageInstaller.openSession(sessionId);

            // Write the apk.
            try (
                    InputStream in = new BufferedInputStream(new FileInputStream(
                        new File(APK_USES_SMS_CALL_LOG_29)));
                    OutputStream out = session.openWrite(
                            APK_NAME_USES_SMS_CALL_LOG_29, 0, -1);
            ) {
                final byte[] buf = new byte[8192];
                int size;
                while ((size = in.read(buf)) != -1) {
                    out.write(buf, 0, size);
                }
            }

            final Intent intent = new Intent(action);
            final IntentSender intentSender = PendingIntent.getBroadcast(getContext(),
                    1, intent, PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE)
                    .getIntentSender();

            // Commit as shell to avoid confirm UI
            runWithShellPermissionIdentity(() -> {
                session.commit(intentSender);
                installLatch.await(UI_TIMEOUT, TimeUnit.MILLISECONDS);
            });
        } finally {
            getContext().unregisterReceiver(installReceiver);
        }
    }

    private void assertWeCannotReadOrWriteWhileShellCanReadAndWrite(int whitelist)
            throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        try {
            packageManager.getWhitelistedRestrictedPermissions(PKG, whitelist);
            fail();
        } catch (SecurityException expected) {
            /*ignore*/
        }
        try {
            packageManager.addWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            fail();
        } catch (SecurityException expected) {
            /*ignore*/
        }
        runWithShellPermissionIdentity(() -> {
            packageManager.addWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    whitelist)).contains(permission.SEND_SMS);
            packageManager.removeWhitelistedRestrictedPermission(PKG,
                    permission.SEND_SMS, whitelist);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    whitelist)).doesNotContain(permission.SEND_SMS);
        });
    }

    private @NonNull Set<String> getPermissionsOfAppWithAnyOfFlags(int flags) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final Set<String> restrictedPermissions = new ArraySet<>();
        for (String permission : getRequestedPermissionsOfApp()) {
            PermissionInfo permInfo = packageManager.getPermissionInfo(permission, 0);

            if ((permInfo.flags & flags) != 0) {
                restrictedPermissions.add(permission);
            }
        }
        return restrictedPermissions;
    }

    private @NonNull Set<String> getRestrictedPermissionsOfApp() throws Exception {
        return getPermissionsOfAppWithAnyOfFlags(
                PermissionInfo.FLAG_HARD_RESTRICTED | PermissionInfo.FLAG_SOFT_RESTRICTED);
    }

    private @NonNull String[] getRequestedPermissionsOfApp() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(PKG,
                PackageManager.GET_PERMISSIONS);
        return packageInfo.requestedPermissions;
    }

    private void assertAllRestrictedPermissionWhitelisted() throws Exception {
        assertRestrictedPermissionWhitelisted(getRestrictedPermissionsOfApp());
    }

    private void assertNoRestrictedPermissionWhitelisted() throws Exception {
        assertRestrictedPermissionWhitelisted(
                Collections.EMPTY_SET /*expectedWhitelistedPermissions*/);
    }

    /**
     * Assert that the passed in restrictions are whitelisted and that their app-op is set
     * correctly.
     *
     * @param expectedWhitelistedPermissions The expected white listed permissions
     */
    private void assertRestrictedPermissionWhitelisted(
            @NonNull Set<String> expectedWhitelistedPermissions) throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        eventually(() -> runWithShellPermissionIdentity(() -> {
            final AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final PackageInfo packageInfo = packageManager.getPackageInfo(PKG,
                    PackageManager.GET_PERMISSIONS);

            final Set<String> whitelistedPermissions = packageManager
                .getWhitelistedRestrictedPermissions(PKG,
                        PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                        | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER
                        | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE);

            assertThat(whitelistedPermissions).isNotNull();
            assertWithMessage(""Whitelisted permissions"").that(whitelistedPermissions)
                    .containsExactlyElementsIn(expectedWhitelistedPermissions);

            // Also assert that apps ops are properly set
            for (String permission : getRestrictedPermissionsOfApp()) {
                String op = AppOpsManager.permissionToOp(permission);
                ArraySet<Integer> possibleModes = new ArraySet<>();

                if (permission.equals(Manifest.permission.ACCESS_BACKGROUND_LOCATION)) {
                    op = AppOpsManager.OPSTR_FINE_LOCATION;

                    // If permission is denied app-op might be allowed/fg or ignored. It does
                    // not matter. If permission is granted, it has to be allowed/fg.
                    if (isPermissionGranted(PKG, Manifest.permission.ACCESS_FINE_LOCATION)) {
                        if (expectedWhitelistedPermissions.contains(permission)
                                && isPermissionGranted(PKG, permission)) {
                            possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        } else {
                            possibleModes.add(AppOpsManager.MODE_FOREGROUND);
                        }
                    } else {
                        possibleModes.add(AppOpsManager.MODE_IGNORED);
                        possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        possibleModes.add(AppOpsManager.MODE_FOREGROUND);
                    }
                } else {
                    if (expectedWhitelistedPermissions.contains(permission)) {
                        // If permission is denied app-op might be allowed or ignored. It does not
                        // matter. If permission is granted, it has to be allowed.
                        possibleModes.add(AppOpsManager.MODE_ALLOWED);
                        if (!isPermissionGranted(PKG, permission)) {
                            possibleModes.add(AppOpsManager.MODE_IGNORED);
                        }
                    } else {
                        possibleModes.add(AppOpsManager.MODE_IGNORED);
                    }
                }

                assertWithMessage(op).that(appOpsManager.unsafeCheckOpRawNoThrow(op,
                        packageInfo.applicationInfo.uid, PKG)).isIn(possibleModes);
            }
        }));
    }

    private void assertAllRestrictedPermissionGranted() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(
                PKG, PackageManager.GET_PERMISSIONS);
        if (packageInfo.requestedPermissions != null) {
            final int permissionCount = packageInfo.requestedPermissions.length;
            for (int i = 0; i < permissionCount; i++) {
                final String permission = packageInfo.requestedPermissions[i];
                final PermissionInfo permissionInfo = packageManager.getPermissionInfo(
                        permission, 0);
                if ((permissionInfo.flags & PermissionInfo.FLAG_HARD_RESTRICTED) != 0) {
                    assertThat((packageInfo.requestedPermissionsFlags[i]
                            & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isNotEqualTo(0);
                }
            }
        }
    }

    private void assertNoRestrictedPermissionGranted() throws Exception {
        assertRestrictedPermissionGranted(Collections.EMPTY_SET);
    }

    private void assertRestrictedPermissionGranted(@NonNull Set<String> expectedGrantedPermissions)
            throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();
        final PackageInfo packageInfo = packageManager.getPackageInfo(
                PKG, PackageManager.GET_PERMISSIONS);
        if (packageInfo.requestedPermissions != null) {
            final int permissionCount = packageInfo.requestedPermissions.length;
            for (int i = 0; i < permissionCount; i++) {
                final String permission = packageInfo.requestedPermissions[i];
                final PermissionInfo permissionInfo = packageManager.getPermissionInfo(
                        permission, 0);
                if ((permissionInfo.flags & PermissionInfo.FLAG_HARD_RESTRICTED) != 0
                        || (permissionInfo.flags & PermissionInfo.FLAG_SOFT_RESTRICTED) != 0) {
                    if (expectedGrantedPermissions.contains(permission)) {
                        assertThat((packageInfo.requestedPermissionsFlags[i]
                                & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isNotEqualTo(0);
                    } else {
                        assertThat((packageInfo.requestedPermissionsFlags[i]
                                & PackageInfo.REQUESTED_PERMISSION_GRANTED)).isEqualTo(0);
                    }
                }
            }
        }
    }

    /**
     * Install {@link #APK_USES_SMS_CALL_LOG_29}.
     *
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installRestrictedPermissionUserApp(@Nullable Set<String> whitelistedPermissions,
            @Nullable Set<String> grantedPermissions) throws Exception {
        installApp(APK_USES_SMS_CALL_LOG_29, whitelistedPermissions, grantedPermissions);
    }

    /**
     * Install app and grant all permission.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     */
    private void installApp(@NonNull String app, @Nullable Set<String> whitelistedPermissions)
            throws Exception {
        installApp(app, whitelistedPermissions, null /*grantedPermissions*/);
    }

    /**
     * Install an app.
     *
     * @param app The app to be installed
     * @param whitelistedPermissions The permission to be whitelisted. {@code null} == all
     * @param grantedPermissions The permission to be granted. {@code null} == all
     */
    private void installApp(@NonNull String app, @Nullable Set<String> whitelistedPermissions,
            @Nullable Set<String> grantedPermissions) throws Exception {
        // Install the app and whitelist/grant all permission if requested.
        String installResult = runShellCommand(""pm install -r --force-queryable ""
                + ""--restrict-permissions "" + app);
        assertThat(installResult.trim()).isEqualTo(""Success"");

        final Set<String> adjustedWhitelistedPermissions;
        if (whitelistedPermissions == null) {
            adjustedWhitelistedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedWhitelistedPermissions = whitelistedPermissions;
        }

        final Set<String> adjustedGrantedPermissions;
        if (grantedPermissions == null) {
            adjustedGrantedPermissions = getRestrictedPermissionsOfApp();
        } else {
            adjustedGrantedPermissions = grantedPermissions;
        }

        // Whitelist subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedWhitelistedPermissions) {
                packageManager.addWhitelistedRestrictedPermission(PKG, permission,
                        PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
            }
        });

        // Grant subset of permissions if requested
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : adjustedGrantedPermissions) {
                packageManager.grantRuntimePermission(PKG, permission,
                        getContext().getUser());
                packageManager.updatePermissionFlags(permission, PKG,
                        PackageManager.FLAG_PERMISSION_REVOKED_COMPAT, 0, getContext().getUser());
            }
        });

        // Mark all permissions as reviewed as for pre-22 apps the restriction state might not be
        // applied until reviewed
        runWithShellPermissionIdentity(() -> {
            final PackageManager packageManager = getContext().getPackageManager();
            for (String permission : getRequestedPermissionsOfApp()) {
                packageManager.updatePermissionFlags(permission, PKG,
                        PackageManager.FLAG_PERMISSION_REVIEW_REQUIRED, 0,
                        getContext().getUser());
            }
        });
    }

    @After
    public void uninstallApp() {
        runShellCommand(""pm uninstall "" + PKG);
        runShellCommand(""pm uninstall "" + PKG_USES_SMS_NOT_RESTRICTED_SHARED_UID);
        runShellCommand(""pm uninstall "" + PKG_USES_SMS_RESTRICTED_SHARED_UID);
    }

    private static @NonNull Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static void runWithShellPermissionIdentity(@NonNull ThrowingRunnable command)
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity();
        try {
            command.run();
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testWifiNetworkConfigurationWithoutFineLocationPermission"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"public void testWifiNetworkConfigurationWithoutFineLocationPermission() throws Exception {
        executeShellCommand(""pm revoke --user %d %s android.permission.ACCESS_FINE_LOCATION"",
                mPrimaryUserId, DEVICE_OWNER_PKG);

        executeDeviceOwnerTest(""WifiNetworkConfigurationWithoutFineLocationPermissionTest"");
    }

    private int createAffiliatedSecondaryUser() throws Exception {
        final int userId = createUser();
        installAppAsUser(INTENT_RECEIVER_APK, userId);
        // For headless system user mode, after DO is setup, PO is already
        // set on the secondary user. Meanwhile, it requires additional permission while
        // using DevicePolicyManagerWrapper while using DPM APIs from secondary user.
        if (!isHeadlessSystemUserMode()) {
            installAppAsUser(DEVICE_OWNER_APK, userId);
            setProfileOwnerOrFail(DEVICE_OWNER_COMPONENT, userId);
        } else {
            grantDpmWrapperPermissions(DEVICE_OWNER_PKG, userId);
        }
        wakeupAndDismissKeyguard();

        // Setting the same affiliation ids on both users
        CLog.d(""createAffiliatedSecondaryUser(): deviceOwnerId="" + mDeviceOwnerUserId
                + "", primaryUserId="" + mPrimaryUserId + "", newUserId="" + userId);
        affiliateUsers(DEVICE_OWNER_PKG, mDeviceOwnerUserId, userId);

        return userId;
    }

    private void executeDeviceTestMethod(String className, String testName,
            Map<String, String> params) throws Exception {
        runDeviceTestsAsUser(DEVICE_OWNER_PKG, className, testName,
                /* deviceOwnerUserId */ mPrimaryUserId, params);
    }

    private void executeCreateAndManageUserTest(String testMethod) throws Exception {
        // These test must be run on device owner user, as it's the only user that's guaranteed  to
        // be always running (otherwise, the test case would crash on headless system user mode if
        // the current user is switched out)
        executeDeviceOwnerTestMethod("".CreateAndManageUserTest"", testMethod);
    }

    private void executeListForegroundAffiliatedUsersTest(String testMethod) throws Exception {
        // These test must be run on device owner user, as it's the only user that's guaranteed  to
        // be always running (otherwise, the test case would crash on headless system user mode if
        // the current user is switched out)
        executeDeviceOwnerTestMethod("".ListForegroundAffiliatedUsersTest"", testMethod);
    }

    private void assertNewUserStopped() throws Exception {
        List<Integer> newUsers = getUsersCreatedByTests();
        assertEquals(1, newUsers.size());
        int newUserId = newUsers.get(0);

        assertFalse(getDevice().isUserRunning(newUserId));
    }
}"	""	""	"ACCESS_FINE_LOCATION android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testBluetoothRestriction"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"public void testBluetoothRestriction() throws Exception {
        executeDeviceOwnerTest(""BluetoothRestrictionTest"");
    }"	""	""	"BluetoothRestrictionTest"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"isEnabled"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.Manifest.permission.BLUETOOTH_CONNECT;
import static android.Manifest.permission.BLUETOOTH_SCAN;
import static android.permission.cts.PermissionUtils.grantPermission;
import static android.permission.cts.PermissionUtils.install;
import static android.permission.cts.PermissionUtils.revokePermission;
import static android.permission.cts.PermissionUtils.uninstallApp;

import static com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.bluetooth.cts.BTAdapterUtils;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SdkSuppress;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests the behavior of the
 * {@link android.Manifest.permission_group#NEARBY_DEVICES} permission group
 * under various permutations of grant states.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S, codeName = ""S"")
public class NearbyDevicesPermissionTest {
    private static final String TEST_APP_PKG = ""android.permission.cts.appthatrequestpermission"";
    private static final String TEST_APP_AUTHORITY = ""appthatrequestpermission"";
    private static final String DISAVOWAL_APP_PKG = ""android.permission.cts.appneverforlocation"";

    private static final String TMP_DIR = ""/data/local/tmp/cts/permissions/"";
    private static final String APK_BLUETOOTH_30 = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermission30.apk"";
    private static final String APK_BLUETOOTH_31 = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermission31.apk"";
    private static final String APK_BLUETOOTH_NEVER_FOR_LOCATION_31 = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermissionNeverForLocation31.apk"";
    private static final String APK_BLUETOOTH_NEVER_FOR_LOCATION_NO_PROVIDER = TMP_DIR
            + ""CtsAppThatRequestsBluetoothPermissionNeverForLocationNoProvider.apk"";

    private enum Result {
        UNKNOWN, EXCEPTION, EMPTY, FILTERED, FULL
    }

    private Context mContext = InstrumentationRegistry.getInstrumentation().getContext();
    private BluetoothAdapter mBluetoothAdapter;
    private boolean mBluetoothAdapterWasEnabled;

    @Before
    public void enableBluetooth() {
        assumeTrue(supportsBluetooth());
        mBluetoothAdapter = mContext.getSystemService(BluetoothManager.class).getAdapter();
        mBluetoothAdapterWasEnabled = mBluetoothAdapter.isEnabled();
        assertTrue(BTAdapterUtils.enableAdapter(mBluetoothAdapter, mContext));
        enableTestMode();
    }

    @After
    public void disableBluetooth() {
        assumeTrue(supportsBluetooth());
        disableTestMode();
        if (!mBluetoothAdapterWasEnabled) {
            assertTrue(BTAdapterUtils.disableAdapter(mBluetoothAdapter, mContext));
        }
    }

    @Before
    @After
    public void uninstallTestApp() {
        uninstallApp(TEST_APP_PKG);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission30_GrantLocation"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission30_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_30);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantLocation"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantNearby_GrantLocation"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantNearby_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantLocation"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantNearby_GrantLocation"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantNearby_GrantLocation()
            throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FILTERED);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission_Upgrade"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"@Ignore
    public void testRequestBluetoothPermission_Upgrade() throws Throwable {
        install(APK_BLUETOOTH_30);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);

        // Upgrading to target a new SDK level means they need to explicitly
        // request the new runtime permission; by default it's denied
        install(APK_BLUETOOTH_31);
        assertScanBluetoothResult(Result.EXCEPTION);

        // If the user does grant it, they can scan again
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.FULL);
    }

    /**
     * Verify that downgrading an app doesn't gain them any access to Bluetooth
     * scan results; they'd always need to involve the user to gain permissions.
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission_Downgrade"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	"public void testRequestBluetoothPermission_Downgrade() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);

        // Revoking nearby permission means modern app can't scan
        revokePermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        revokePermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.EXCEPTION);

        // And if they attempt to downgrade, confirm that they can't obtain the
        // split-permission grant from the older non-runtime permissions
        install(APK_BLUETOOTH_30);
        assertScanBluetoothResult(Result.EXCEPTION);
    }

    private void assertScanBluetoothResult(Result expected) {
        assertScanBluetoothResult(null, expected);
    }

    private void assertScanBluetoothResult(String arg, Result expected) {
        SystemClock.sleep(1000); // Wait for location permissions to propagate
        final ContentResolver resolver = InstrumentationRegistry.getTargetContext()
                .getContentResolver();
        final Bundle res = resolver.call(TEST_APP_AUTHORITY, """", arg, null);
        Result actual = Result.values()[res.getInt(Intent.EXTRA_INDEX)];
        assertEquals(expected, actual);
    }

    private boolean supportsBluetooth() {
        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH);
    }

    private void enableTestMode() {
        runShellCommandOrThrow(""dumpsys activity service""
                + "" com.android.bluetooth/.btservice.AdapterService set-test-mode enabled"");
    }

    private void disableTestMode() {
        runShellCommandOrThrow(""dumpsys activity service""
                + "" com.android.bluetooth/.btservice.AdapterService set-test-mode disabled"");
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.camera.intents.CameraIntentsActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/camera/intents/CameraIntentsActivity.java"	""	"public void test/*
 *.
 */
package com.android.cts.verifier.camera.intents;

import android.app.job.JobInfo;
import android.app.job.JobParameters;
import android.app.job.JobScheduler;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.pm.PermissionInfo;
import android.hardware.Camera;
import android.media.ExifInterface;
import android.media.MediaMetadataRetriever;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.provider.MediaStore;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.TextView;
import androidx.core.content.FileProvider;
import android.Manifest;

import com.android.cts.verifier.camera.intents.CameraContentJobService;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestResult;
import android.widget.Toast;

import static android.media.MediaMetadataRetriever.METADATA_KEY_HAS_VIDEO;
import static android.media.MediaMetadataRetriever.METADATA_KEY_LOCATION;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.TreeSet;
import java.util.Date;
import java.text.SimpleDateFormat;

/**
 * Tests for manual verification of uri trigger and camera intents being fired.
 *
 * MediaStore.Images.Media.EXTERNAL_CONTENT_URI:
 * android.hardware.Camera.ACTION_NEW_PICTURE:
 *  These should fire when a new picture was captured by the camera app, and
 *  it has been added to the media store.
 * MediaStore.Video.Media.EXTERNAL_CONTENT_URI:
 * android.hardware.Camera.ACTION_NEW_VIDEO:
 *  These should fire when a new video has been captured by the camera app, and
 *  it has been added to the media store.
 *
 * The tests verify this both by asking the user to manually launch
 *  the camera activity, as well as by programatically launching the camera
 *  activity via MediaStore intents.
 *
 * Please ensure when replacing the default camera app on a device,
 *  that these intents are still firing as a lot of 3rd party applications
 *  (e.g. social network apps that upload a photo after you take a picture)
 *  rely on this functionality present and correctly working.
 */
public class CameraIntentsActivity extends PassFailButtons.Activity
implements OnClickListener, SurfaceHolder.Callback {

    private static final String TAG = ""CameraIntents"";
    private static final int STATE_OFF = 0;
    private static final int STATE_STARTED = 1;
    private static final int STATE_SUCCESSFUL = 2;
    private static final int STATE_FAILED = 3;

    private static final int STAGE_APP_PICTURE = 0;
    private static final int STAGE_APP_VIDEO = 1;
    private static final int STAGE_INTENT_PICTURE = 2;
    private static final int STAGE_INTENT_PICTURE_SECURE = 3;
    private static final int STAGE_INTENT_VIDEO = 4;
    private static final int NUM_STAGES = 5;
    private static final String STAGE_INDEX_EXTRA = ""stageIndex"";

    private static String[]  EXPECTED_INTENTS = new String[] {
        Camera.ACTION_NEW_PICTURE,
        Camera.ACTION_NEW_VIDEO,
        null,
        null,
        null
    };

    private ImageButton mPassButton;
    private ImageButton mFailButton;
    private Button mStartTestButton;
    private Button mSettingsButton;
    private File mDebugFolder = null;
    private File mImageTarget = null;
    private File mVideoTarget = null;
    private int mState = STATE_OFF;
    // MediaStore.Images.Media.EXTERNAL_CONTENT_URI or
    // MediaStore.Video.Media.EXTERNAL_CONTENT_URI are successfully received.
    private boolean mUriSuccess = false;
    // android.hardware.Camera.ACTION_NEW_PICTURE or
    // android.hardware.Camera.ACTION_NEW_VIDEO are successfully received.
    private boolean mActionSuccess = false;
    private Object mLock = new Object();

    private BroadcastReceiver mReceiver;
    private IntentFilter mFilterPicture;
    private boolean mActivityResult = false;
    private boolean mDetectCheating = false;

    private StringBuilder mReportBuilder = new StringBuilder();
    private final TreeSet<String> mTestedCombinations = new TreeSet<String>();
    private final TreeSet<String> mUntestedCombinations = new TreeSet<String>();

    private CameraContentJobService.TestEnvironment mTestEnv;
    private static final int CAMERA_JOB_ID = CameraIntentsActivity.class.hashCode();
    private static final int JOB_TYPE_IMAGE = 0;
    private static final int JOB_TYPE_VIDEO = 1;

    private static int[] TEST_JOB_TYPES = new int[] {
        JOB_TYPE_IMAGE,
        JOB_TYPE_VIDEO,
        JOB_TYPE_IMAGE,
        JOB_TYPE_IMAGE,
        JOB_TYPE_VIDEO
    };

    private JobInfo makeJobInfo(int jobType) {
        JobInfo.Builder builder = new JobInfo.Builder(CAMERA_JOB_ID,
                new ComponentName(this, CameraContentJobService.class));
        // Look for specific changes to images in the provider.
        Uri uriToTrigger = null;
        switch (jobType) {
            case JOB_TYPE_IMAGE:
                uriToTrigger = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
                break;
            case JOB_TYPE_VIDEO:
                uriToTrigger = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
                break;
            default:
                Log.e(TAG, ""Unknown jobType"" + jobType);
                return null;
        }
        builder.addTriggerContentUri(new JobInfo.TriggerContentUri(
                uriToTrigger,
                JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS));
        // For testing purposes, react quickly.
        builder.setTriggerContentUpdateDelay(100);
        builder.setTriggerContentMaxDelay(100);
        return builder.build();
    }

    /* Callback from mReceiver#onReceive */
    public void onReceivedIntent(Intent intent) {
        Log.v(TAG, ""Received intent "" + intent.toString());
        synchronized(mLock) {
            if (mState == STATE_STARTED) {

                /* this can happen if..
                  the camera apps intent finishes,
                  user returns to cts verifier,
                  user leaves cts verifier and tries to fake receiver intents
                  */
                if (mDetectCheating) {
                    Log.w(TAG, ""Cheating attempt suppressed"");

                    mState = STATE_FAILED;
                }

                String expectedIntent = EXPECTED_INTENTS[getStageIndex()];
                if (expectedIntent != intent.getAction()) {
                    Log.e(TAG, ""FAIL: Test # "" + getStageIndex()
                        + "" must not broadcast ""
                        + intent.getAction()
                        + "", expected: ""
                        + (expectedIntent != null ? expectedIntent : ""no intent""));

                    mState = STATE_FAILED;
                }

                if (mState != STATE_FAILED) {
                    mActionSuccess = true;
                }
                updateSuccessState();
            }
        }
    }

    private void updateSuccessState() {
        // Last stage requires additional step to switch on location permission
        if (mActionSuccess && mUriSuccess && getStageIndex() < NUM_STAGES - 1) {
            mState = STATE_SUCCESSFUL;
        }

        setPassButton(mState == STATE_SUCCESSFUL);
    }

    private void setPassButton(Boolean pass) {
        mPassButton.setEnabled(pass);
        mFailButton.setEnabled(!pass);
    }

    private int getStageIndex()
    {
        final int stageIndex = getIntent().getIntExtra(STAGE_INDEX_EXTRA, 0);
        return stageIndex;
    }

    private String getStageString(int stageIndex)
    {
        if (stageIndex == STAGE_APP_PICTURE) {
            return ""Application Picture"";
        }
        if (stageIndex == STAGE_APP_VIDEO) {
            return ""Application Video"";
        }
        if (stageIndex == STAGE_INTENT_PICTURE) {
            return ""Intent Picture"";
        }
        if (stageIndex == STAGE_INTENT_PICTURE_SECURE) {
            return ""Intent Picture Secure"";
        }
        if (stageIndex == STAGE_INTENT_VIDEO) {
            return ""Intent Video"";
        }

        return ""Unknown!!!"";
    }

    private String getStageIntentString(int stageIndex)
    {
        if (stageIndex == STAGE_APP_PICTURE) {
            return android.hardware.Camera.ACTION_NEW_PICTURE;
        }
        if (stageIndex == STAGE_APP_VIDEO) {
            return android.hardware.Camera.ACTION_NEW_VIDEO;
        }
        if (stageIndex == STAGE_INTENT_PICTURE) {
            return android.hardware.Camera.ACTION_NEW_PICTURE;
        }
        if (stageIndex == STAGE_INTENT_PICTURE_SECURE) {
            return android.hardware.Camera.ACTION_NEW_PICTURE + "" (Secure)"";
        }
        if (stageIndex == STAGE_INTENT_VIDEO) {
            return android.hardware.Camera.ACTION_NEW_VIDEO;
        }

        return ""Unknown Intent!!!"";
    }

    private String getStageInstructionLabel(int stageIndex)
    {
        if (stageIndex == STAGE_APP_PICTURE) {
            return getString(R.string.ci_instruction_text_app_picture_label);
        }
        if (stageIndex == STAGE_APP_VIDEO) {
            return getString(R.string.ci_instruction_text_app_video_label);
        }
        if (stageIndex == STAGE_INTENT_PICTURE) {
            return getString(R.string.ci_instruction_text_intent_picture_label);
        }
        if (stageIndex == STAGE_INTENT_PICTURE_SECURE) {
            return getString(R.string.ci_instruction_text_intent_picture_secure_label);
        }
        if (stageIndex == STAGE_INTENT_VIDEO) {
            return getString(R.string.ci_instruction_text_intent_video_label);
        }

        return ""Unknown Instruction Label!!!"";
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.ci_main);
        setPassFailButtonClickListeners();
        setInfoResources(R.string.camera_intents, R.string.ci_info, -1);

        mPassButton         = (ImageButton) findViewById(R.id.pass_button);
        mFailButton         = (ImageButton) findViewById(R.id.fail_button);
        mStartTestButton  = (Button) findViewById(R.id.start_test_button);
        mSettingsButton  = (Button) findViewById(R.id.settings_button);
        mStartTestButton.setOnClickListener(this);
        mSettingsButton.setOnClickListener(this);

        // This activity is reused multiple times
        // to test each camera/intents combination
        final int stageIndex = getIntent().getIntExtra(STAGE_INDEX_EXTRA, 0);

        // Hitting the pass button goes to the next test activity.
        // Only the last one uses the PassFailButtons click callback function,
        // which gracefully terminates the activity.
        if (stageIndex + 1 < NUM_STAGES) {
            setPassButtonGoesToNextStage();
        }
        resetButtons();

        // Set initial values

        TextView intentsLabel =
                (TextView) findViewById(R.id.intents_text);
        intentsLabel.setText(
                getString(R.string.ci_intents_label)
                + "" ""
                + Integer.toString(getStageIndex()+1)
                + "" of ""
                + Integer.toString(NUM_STAGES)
                + "": ""
                + getStageIntentString(getStageIndex())
                );

        TextView instructionLabel =
                (TextView) findViewById(R.id.instruction_text);
        instructionLabel.setText(R.string.ci_instruction_text_photo_label);

        /* Display the instructions to launch camera app and take a photo */
        TextView cameraExtraLabel =
                (TextView) findViewById(R.id.instruction_extra_text);
        cameraExtraLabel.setText(getStageInstructionLabel(getStageIndex()));

        mStartTestButton.setEnabled(true);
        mSettingsButton.setEnabled(true);

        mReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                onReceivedIntent(intent);
            }
        };

        mFilterPicture = new IntentFilter();
        mFilterPicture.addAction(Camera.ACTION_NEW_PICTURE);
        mFilterPicture.addAction(Camera.ACTION_NEW_VIDEO);

        try {
            mFilterPicture.addDataType(""video/*"");
            mFilterPicture.addDataType(""image/*"");
        }
        catch(IntentFilter.MalformedMimeTypeException e) {
            Log.e(TAG, ""Caught exceptione e "" + e.toString());
        }
        registerReceiver(mReceiver, mFilterPicture);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.v(TAG, ""onDestroy"");
        this.unregisterReceiver(mReceiver);
    }

    @Override
    public void onResume() {
        super.onResume();
        mFailButton.setEnabled(false);
        /**
         * If location is not enabled, fail buttons should be disabled, since they take us back to
         * the original CTS Verifier activity where other tests might depend on these
         * If we're in STAGE_INTENT_VIDEO even the pass button should be disabled till location
         * access is turned back on for CTS Verifier.
         */
        Boolean locationEnabled = (checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) ==
                PackageManager.PERMISSION_GRANTED);

        if (getStageIndex() == NUM_STAGES - 1) {
                /**
                 * Don't enable the pass /fail button till the user grants CTS verifier location
                 * access again.
                 */
                if (mActionSuccess) {
                    mState = STATE_SUCCESSFUL;
                }
                mPassButton.setEnabled(false);
                if (locationEnabled) {
                    if (mState == STATE_SUCCESSFUL) {
                        mPassButton.setEnabled(true);
                    } else {
                        mFailButton.setEnabled(true);
                    }
                } else if (mState != STATE_OFF) {
                    Toast.makeText(this, R.string.ci_location_permissions_error,
                            Toast.LENGTH_SHORT).show();
                }
        } else {
            if (locationEnabled) {
                mFailButton.setEnabled(true);
            } else {
                Toast.makeText(this, R.string.ci_location_permissions_fail_error,
                    Toast.LENGTH_SHORT).show();
            }
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        /*
        When testing INTENT_PICTURE, INTENT_PICTURE_SECURE, INTENT_VIDEO,
        do not allow user to cheat by going to camera app and re-firing
        the intents by taking a photo/video
        */
        if (getStageIndex() == STAGE_INTENT_PICTURE ||
            getStageIndex() == STAGE_INTENT_PICTURE_SECURE ||
            getStageIndex() == STAGE_INTENT_VIDEO) {

            if (mActivityResult && mState == STATE_STARTED) {
                mDetectCheating = true;
                Log.w(TAG, ""Potential cheating detected"");
            }
        }

    }

    @Override
    protected void onActivityResult(
        int requestCode, int resultCode, Intent data) {
        int stageIndex = getStageIndex();
        if (requestCode == 1337 + stageIndex) {
            Log.v(TAG, ""Activity we launched was finished"");
            mActivityResult = true;
            synchronized(mLock) {
                if (mState != STATE_FAILED) {
                    switch (stageIndex) {
                        case STAGE_INTENT_PICTURE:
                        case STAGE_INTENT_PICTURE_SECURE:
                            handleIntentPictureResult();
                            // No broadcast should be received. Proceed to update test result
                            updateSuccessState();
                            break;
                        case STAGE_INTENT_VIDEO:
                            handleIntentVideoResult();
                            // No broadcast should be received because EXTRA_OUTPUT is set.
                            // Proceed to update test result
                            updateSuccessState();
                            break;
                        default:
                            return;
                    }
                }
            }
        }
    }

    private void handleIntentPictureResult() {
        if (mImageTarget == null) {
            Log.d(TAG, ""Image target was not set"");
            return;
        }
        try {
            if (!mImageTarget.exists() || mImageTarget.length() == 0) {
                Log.d(TAG, ""Image target does not exist or is empty"");
                mState = STATE_FAILED;
                return;
            }

            try {
                final ExifInterface exif = new ExifInterface(new FileInputStream(mImageTarget));
                if (!checkExifAttribute(exif, ExifInterface.TAG_MAKE)
                    || !checkExifAttribute(exif, ExifInterface.TAG_MODEL)
                    || !checkExifAttribute(exif, ExifInterface.TAG_DATETIME)) {
                    Log.d(TAG, ""The required tag does not appear in the exif"");
                    mState = STATE_FAILED;
                    return;
                }

                float[] latLong = new float[2];
                if (exif.getLatLong(latLong)) {
                    Log.d(TAG, ""Should not contain location information"");
                    mState = STATE_FAILED;
                    return;
                }
                mActionSuccess = true;
            } catch (IOException ex) {
                Log.e(TAG, ""Failed to verify Exif"", ex);
                mState = STATE_FAILED;
                return;
            }
        } finally {
            mImageTarget.delete();
        }
    }

    private void handleIntentVideoResult() {
        if (mVideoTarget == null) {
            Log.d(TAG, ""Video target was not set"");
            return;
        }
        /**
         * Check that there is no location data in video.
         */
        MediaMetadataRetriever mediaRetriever = new MediaMetadataRetriever();
        mediaRetriever.setDataSource(mVideoTarget.toString());
        if (mediaRetriever.extractMetadata(METADATA_KEY_HAS_VIDEO) == null ||
            mediaRetriever.extractMetadata(METADATA_KEY_LOCATION) != null) {
            mState = STATE_FAILED;
        } else {
            mVideoTarget.delete();
        }
        Log.d(TAG, ""METADATA_KEY_HAS_VIDEO: "" +
              mediaRetriever.extractMetadata(METADATA_KEY_HAS_VIDEO) +
              "" METADATA_KEY_LOCATION: "" +
              mediaRetriever.extractMetadata(METADATA_KEY_LOCATION));
        mediaRetriever.release();
        /* successful, unless we get the URI trigger back at some point later on. */
        mActionSuccess = true;
    }

    private boolean checkExifAttribute(ExifInterface exif, String tag) {
        final String res = exif.getAttribute(tag);
        return res != null && res.length() > 0;
    }

    @Override
    public String getTestDetails() {
        return mReportBuilder.toString();
    }

    private class WaitForTriggerTask extends AsyncTask<Void, Void, Boolean> {
        protected Boolean doInBackground(Void... param) {
            try {
                boolean executed = mTestEnv.awaitExecution();
                synchronized(mLock) {
                    // Check latest test param
                    if (executed && mState == STATE_STARTED) {

                        // this can happen if..
                        //  the camera apps intent finishes,
                        //  user returns to cts verifier,
                        //  user leaves cts verifier and tries to fake receiver intents
                        if (mDetectCheating) {
                            Log.w(TAG, ""Cheating attempt suppressed"");
                            mState = STATE_FAILED;
                        }

                        if (mState != STATE_FAILED) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            Log.e(TAG, ""FAIL: timeout waiting for URI trigger"");
            return false;
        }

        protected void onPostExecute(Boolean pass) {
            synchronized(mLock) {
                mUriSuccess = pass;
                updateSuccessState();
            }
        }
    }

    @Override
    public void onClick(View view) {
        Log.v(TAG, ""Click detected"");

        final int stageIndex = getStageIndex();
        if (view == mSettingsButton) {
            Log.v(TAG, ""Opening up Settings app"");
            startActivity(new Intent(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS));
        }

        if (view == mStartTestButton) {
            Log.v(TAG, ""Starting testing... "");

            mState = STATE_STARTED;
            mUriSuccess = false;
            mActionSuccess = false;

            // Skip URI check for stages that should not receive intent
            if (EXPECTED_INTENTS[stageIndex] == null) {
                mUriSuccess = true;
            }

            JobScheduler jobScheduler = (JobScheduler) getSystemService(
                    Context.JOB_SCHEDULER_SERVICE);
            jobScheduler.cancelAll();

            mTestEnv = CameraContentJobService.TestEnvironment.getTestEnvironment();

            mTestEnv.setUp();

            /**
             * Intent stages do not need to wait on a ContentProvider broadcast since we're starting
             * the intent activity with EXTRA_OUTPUT set
             */
            if (stageIndex != STAGE_INTENT_VIDEO &&
                stageIndex != STAGE_INTENT_PICTURE &&
                stageIndex != STAGE_INTENT_PICTURE_SECURE) {
                JobInfo job = makeJobInfo(TEST_JOB_TYPES[stageIndex]);
                jobScheduler.schedule(job);
                new WaitForTriggerTask().execute();
            }

            /* we can allow user to fail immediately if location is on, otherwise they must
             * enable location */
            if (checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) ==
                PackageManager.PERMISSION_GRANTED) {
                mFailButton.setEnabled(true);
            }

            /* trigger an ACTION_IMAGE_CAPTURE intent
                which will run the camera app itself */
            String intentStr = null;
            Intent cameraIntent = null;
            if (stageIndex == STAGE_INTENT_PICTURE) {
                intentStr = android.provider.MediaStore.ACTION_IMAGE_CAPTURE;
            }
            else if (stageIndex == STAGE_INTENT_PICTURE_SECURE) {
                intentStr = android.provider.MediaStore.ACTION_IMAGE_CAPTURE_SECURE;
            }
            else if (stageIndex == STAGE_INTENT_VIDEO) {
                intentStr = android.provider.MediaStore.ACTION_VIDEO_CAPTURE;
            }

            if (intentStr != null) {
                cameraIntent = new Intent(intentStr);
                mDebugFolder = new File(this.getFilesDir(), ""debug"");
                mDebugFolder.mkdirs();
                if (!mDebugFolder.exists()) {
                    Toast.makeText(this, R.string.ci_directory_creation_error,
                            Toast.LENGTH_SHORT).show();
                    Log.v(TAG, ""Could not create directory"");
                    return;
                }

                File targetFile;
                String timeStamp = new SimpleDateFormat(""yyyyMMdd_HHmmss"").format(new Date());
                switch (stageIndex) {
                    case STAGE_INTENT_PICTURE:
                    case STAGE_INTENT_PICTURE_SECURE:
                        mImageTarget = new File(mDebugFolder, timeStamp + ""capture.jpg"");
                        targetFile = mImageTarget;
                        break;
                    case STAGE_INTENT_VIDEO:
                        mVideoTarget = new File(mDebugFolder, timeStamp  + ""video.mp4"");
                        targetFile = mVideoTarget;
                        break;
                    default:
                        Log.wtf(TAG, ""Unexpected stage index to send intent with extras"");
                        return;
                }
                cameraIntent.putExtra(MediaStore.EXTRA_OUTPUT, FileProvider.getUriForFile(this,
                              ""com.android.cts.verifier.managedprovisioning.fileprovider"",
                              targetFile));
                startActivityForResult(cameraIntent, 1337 + getStageIndex());
            }

            mStartTestButton.setEnabled(false);
        }

        if(view == mPassButton || view == mFailButton) {
            // Stop any running wait
            mTestEnv.cancelWait();

            for (int counter = 0; counter < NUM_STAGES; counter++) {
                String combination = getStageString(counter) + ""\n"";

                if(counter < stageIndex) {
                    // test already passed, or else wouldn't have made
                    // it to current stageIndex
                    mTestedCombinations.add(combination);
                }

                if(counter == stageIndex) {
                    // current test configuration
                    if(view == mPassButton) {
                        mTestedCombinations.add(combination);
                    }
                    else if(view == mFailButton) {
                        mUntestedCombinations.add(combination);
                    }
                }

                if(counter > stageIndex) {
                    // test not passed yet, since haven't made it to
                    // stageIndex
                    mUntestedCombinations.add(combination);
                }

                counter++;
            }

            mReportBuilder = new StringBuilder();
            mReportBuilder.append(""Passed combinations:\n"");
            for (String combination : mTestedCombinations) {
                mReportBuilder.append(combination);
            }
            mReportBuilder.append(""Failed/untested combinations:\n"");
            for (String combination : mUntestedCombinations) {
                mReportBuilder.append(combination);
            }

            if(view == mPassButton) {
                TestResult.setPassedResult(this, ""CameraIntentsActivity"",
                        getTestDetails());
            }
            if(view == mFailButton) {
                TestResult.setFailedResult(this, ""CameraIntentsActivity"",
                        getTestDetails());
            }

            // restart activity to test next intents
            Intent intent = new Intent(CameraIntentsActivity.this,
                    CameraIntentsActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP
                    | Intent.FLAG_ACTIVITY_FORWARD_RESULT);
            intent.putExtra(STAGE_INDEX_EXTRA, stageIndex + 1);
            startActivity(intent);
        }
    }

    private void resetButtons() {
        enablePassFailButtons(false);
    }

    private void enablePassFailButtons(boolean enable) {
        mPassButton.setEnabled(enable);
        mFailButton.setEnabled(enable);
    }

    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width,
            int height) {
    }

    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        // Auto-generated method stub
    }

    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {
        // Auto-generated method stub
    }

    private void setPassButtonGoesToNextStage() {
        findViewById(R.id.pass_button).setOnClickListener(this);
    }

}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testMethodPermissions"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testMethodPermissions() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);
        Collection<Uri> numbers = new ArrayList<>(1);
        numbers.add(sTestNumberUri);

        // isUceSettingEnabled - read
        Boolean isUceSettingEnabledResult = null;
        try {
            isUceSettingEnabledResult =
                    ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                    uceAdapter, RcsUceAdapter::isUceSettingEnabled, ImsException.class,
                    ""android.permission.READ_PHONE_STATE"");
            assertNotNull(""result from isUceSettingEnabled should not be null"",
                    isUceSettingEnabledResult);
        } catch (SecurityException e) {
            fail(""isUceSettingEnabled should succeed with READ_PHONE_STATE."");
        } catch (ImsException e) {
            // unsupported is a valid fail cause.
            if (e.getCode() != ImsException.CODE_ERROR_UNSUPPORTED_OPERATION) {
                fail(""isUceSettingEnabled failed with code "" + e.getCode());
            }
        }

        // isUceSettingEnabled - read_privileged
        try {
            isUceSettingEnabledResult =
                    ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                            uceAdapter, RcsUceAdapter::isUceSettingEnabled, ImsException.class,
                            ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            assertNotNull(""result from isUceSettingEnabled should not be null"",
                    isUceSettingEnabledResult);
        } catch (SecurityException e) {
            fail(""isUceSettingEnabled should succeed with READ_PRIVILEGED_PHONE_STATE."");
        } catch (ImsException e) {
            // unsupported is a valid fail cause.
            if (e.getCode() != ImsException.CODE_ERROR_UNSUPPORTED_OPERATION) {
                fail(""isUceSettingEnabled failed with code "" + e.getCode());
            }
        }

        // setUceSettingEnabled
        boolean isUceSettingEnabled =
                (isUceSettingEnabledResult == null ? false : isUceSettingEnabledResult);
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                    (m) -> m.setUceSettingEnabled(isUceSettingEnabled), ImsException.class,
                    ""android.permission.MODIFY_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""setUceSettingEnabled should succeed with MODIFY_PHONE_STATE."");
        } catch (ImsException e) {
            // unsupported is a valid fail cause.
            if (e.getCode() != ImsException.CODE_ERROR_UNSUPPORTED_OPERATION) {
                fail(""setUceSettingEnabled failed with code "" + e.getCode());
            }
        }

        // getUcePublishState without permission
        try {
            uceAdapter.getUcePublishState();
            fail(""getUcePublishState should require READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        // getUcePublishState with permission
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                    RcsUceAdapter::getUcePublishState, ImsException.class,
                    ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""getUcePublishState should succeed with READ_PRIVILEGED_PHONE_STATE."");
        } catch (ImsException e) {
            // ImsExceptions are still valid because it means the permission check passed.
        }

        final RcsUceAdapter.OnPublishStateChangedListener publishStateListener = (state) -> { };

        // addOnPublishStateChangedListener without permission
        try {
            uceAdapter.addOnPublishStateChangedListener(Runnable::run, publishStateListener);
            fail(""addOnPublishStateChangedListener should require ""
                    + ""READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            // expected
        }

        // addOnPublishStateChangedListener with permission.
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                    (m) -> m.addOnPublishStateChangedListener(Runnable::run, publishStateListener),
                    ImsException.class,
                    ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""addOnPublishStateChangedListener should succeed with ""
                    + ""READ_PRIVILEGED_PHONE_STATE."");
        } catch (ImsException e) {
            // ImsExceptions are still valid because it means the permission check passed.
        }

        // removeOnPublishStateChangedListener without permission
        try {
            uceAdapter.removeOnPublishStateChangedListener(publishStateListener);
            fail(""removeOnPublishStateChangedListener should require ""
                    + ""READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            // expected
        }

        // Prepare the callback of the capability request
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
            }
            @Override
            public void onComplete() {
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
            }
        };

        // requestCapabilities without permission
        try {
            uceAdapter.requestCapabilities(numbers, Runnable::run , callback);
            fail(""requestCapabilities should require ACCESS_RCS_USER_CAPABILITY_EXCHANGE."");
        } catch (SecurityException e) {
            //expected
        }

        // requestAvailability without permission
        try {
            uceAdapter.requestAvailability(sTestNumberUri, Runnable::run, callback);
            fail(""requestAvailability should require ACCESS_RCS_USER_CAPABILITY_EXCHANGE."");
        } catch (SecurityException e) {
            //expected
        }

        // requestCapabilities in the foreground
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                    (m) -> m.requestCapabilities(numbers, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE."");
        } catch (ImsException e) {
            // ImsExceptions are still valid because it means the permission check passed.
        }

        // requestAvailability in the foreground
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                    (m) -> m.requestAvailability(sTestNumberUri, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestAvailability should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE."");
        } catch (ImsException e) {
            // ImsExceptions are still valid because it means the permission check passed.
        }

        overrideCarrierConfig(null);
    }"	""	""	"android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testReceivingEmptyPidfXml"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	"public void testReceivingEmptyPidfXml() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* OPTIONS */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMilliseconds);
            }
        };

        // Prepare the test contact
        Collection<Uri> contacts = new ArrayList<>(1);
        contacts.add(sTestNumberUri);

        // Prepare the empty PIDF xml
        ArrayList<String> pidfXmlList = new ArrayList<>(1);
        pidfXmlList.add("""");

        // Setup the network response is 200 OK, empty PIDF data and the reason of onTerminated
        // is ""TIMEOUT""
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onNotifyCapabilitiesUpdate(pidfXmlList);
            cb.onTerminated(""TIMEOUT"", 0L);
        });

        requestCapabilities(uceAdapter, contacts, callback);
        try {
            // Verify the contact capabilities is received and the result is NOT FOUND.
            RcsContactUceCapability capability = waitForResult(capabilityQueue);
            assertNotNull(""Capabilities were not received."", capability);
            verifyCapabilityResult(capability, sTestNumberUri, SOURCE_TYPE_NETWORK,
                    REQUEST_RESULT_NOT_FOUND, false, false);

            // Verify the callback ""onCompleted"" is called
            waitForResult(completeQueue);
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
            completeQueue.clear();
            capabilityQueue.clear();
            removeTestContactFromEab();
        }

        // Setup the network response is 404 NOT FOUND
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(404, ""NOT FOUND"");
        });

        requestCapabilities(uceAdapter, contacts, callback);
        try {
            // Verify the contact capabilities is received and the result is NOT FOUND.
            RcsContactUceCapability capability = waitForResult(capabilityQueue);
            assertNotNull(""Capabilities is not received."", capability);
            verifyCapabilityResult(capability, sTestNumberUri, SOURCE_TYPE_NETWORK,
                    REQUEST_RESULT_NOT_FOUND, false, false);

            // Verify that the callback ""onComplete"" is called
            waitForResult(completeQueue);
        } catch (Exception e) {
            fail(""requestCapabilities is failed: "" + e);
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
            completeQueue.clear();
            capabilityQueue.clear();
            removeTestContactFromEab();
        }

        // Setup the network response is 405 Method Not Allowed
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(405, ""Method Not Allowed"");
        });

        requestCapabilities(uceAdapter, contacts, callback);
        try {
            // Verify the contact capabilities is received and the result is NOT FOUND.
            RcsContactUceCapability capability = waitForResult(capabilityQueue);
            assertNotNull(""Capabilities is not received."", capability);
            verifyCapabilityResult(capability, sTestNumberUri, SOURCE_TYPE_NETWORK,
                    REQUEST_RESULT_NOT_FOUND, false, false);

            // Verify that the callback ""onComplete"" is called
            waitForResult(completeQueue);
        } catch (Exception e) {
            fail(""requestCapabilities is failed: "" + e);
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
            completeQueue.clear();
            capabilityQueue.clear();
            removeTestContactFromEab();
        }

        overrideCarrierConfig(null);
    }

    private void setupTestImsService(RcsUceAdapter uceAdapter, boolean presencePublishEnabled,
            boolean presenceCapExchangeEnabled, boolean sipOptionsEnabled) throws Exception {
        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL,
                presencePublishEnabled);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL,
                presenceCapExchangeEnabled);
        bundle.putBoolean(CarrierConfigManager.KEY_USE_RCS_SIP_OPTIONS_BOOL, sipOptionsEnabled);
        overrideCarrierConfig(bundle);

        // Connect to the TestImsService
        connectTestImsService();
    }

    private String getPidfXmlData(Uri contact, boolean audioSupported, boolean videoSupported) {
        StringBuilder pidfBuilder = new StringBuilder();
        pidfBuilder.append(""<?xml version='1.0' encoding='utf-8' standalone='yes' ?>"")
                .append(""<presence entity=\"""").append(contact).append(""\"""")
                .append("" xmlns=\""urn:ietf:params:xml:ns:pidf\"""")
                .append("" xmlns:op=\""urn:oma:xml:prs:pidf:oma-pres\"""")
                .append("" xmlns:caps=\""urn:ietf:params:xml:ns:pidf:caps\"">"")
                .append(""<tuple id=\""tid0\""><status><basic>open</basic></status>"")
                .append(""<op:service-description>"")
                .append(""<op:service-id>service_id_01</op:service-id>"")
                .append(""<op:version>1.0</op:version>"")
                .append(""<op:description>description_test1</op:description>"")
                .append(""</op:service-description>"")
                .append(""<caps:servcaps>"")
                .append(""<caps:audio>"").append(audioSupported).append(""</caps:audio>"")
                .append(""<caps:video>"").append(videoSupported).append(""</caps:video>"")
                .append(""</caps:servcaps>"")
                .append(""<contact>"").append(contact).append(""</contact>"")
                .append(""</tuple></presence>"");
        return pidfBuilder.toString();
    }

    private RcsContactUceCapability getContactCapability(
            List<RcsContactUceCapability> resultCapList, Uri targetUri) {
        if (resultCapList == null) {
            return null;
        }
        return resultCapList.stream()
            .filter(capability -> targetUri.equals(capability.getContactUri()))
            .findFirst()
            .orElse(null);
    }

    private void verifyCapabilityResult(RcsContactUceCapability resultCapability, Uri expectedUri,
            int expectedSourceType, int expectedResult, boolean expectedAudioSupported,
            boolean expectedVideoSupported) {
        // Verify the contact URI
        assertEquals(expectedUri, resultCapability.getContactUri());

        // Verify the source type is the network type.
        assertEquals(expectedSourceType,
                resultCapability.getSourceType());

        // Verify the request result is expected.
        final int requestResult = resultCapability.getRequestResult();
        assertEquals(expectedResult, requestResult);

        // Return directly if the result is not found.
        if (requestResult == REQUEST_RESULT_NOT_FOUND) {
            return;
        }

        // Verify the mechanism is presence
        assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_PRESENCE,
                resultCapability.getCapabilityMechanism());

        RcsContactPresenceTuple presenceTuple =
                resultCapability.getCapabilityTuple(""service_id_01"");
        assertNotNull(""Contact Presence tuple should not be null!"", presenceTuple);

        ServiceCapabilities capabilities = presenceTuple.getServiceCapabilities();
        assertNotNull(""Service capabilities should not be null!"", capabilities);

        // Verify if the audio is supported
        assertEquals(expectedAudioSupported, capabilities.isAudioCapable());

        // Verify if the video is supported
        assertEquals(expectedVideoSupported, capabilities.isVideoCapable());
    }

    private void verifyOptionsCapabilityResult(List<RcsContactUceCapability> resultCapList,
            Collection<Uri> expectedUriList, int expectedSourceType, int expectedMechanism,
            int expectedResult, List<String> expectedFeatureTags) {
        assertEquals(resultCapList.size(), expectedUriList.size());

        assertTrue(resultCapList.stream().map(capability -> capability.getContactUri())
                .anyMatch(expectedUriList::contains));

        resultCapList.stream().map(capability -> capability.getSourceType())
                .forEach(sourceType -> assertEquals((int) sourceType, (int) expectedSourceType));

        resultCapList.stream().map(capability -> capability.getCapabilityMechanism())
                .forEach(mechanism -> assertEquals((int) mechanism, (int) expectedMechanism));

        resultCapList.stream().map(capability -> capability.getRequestResult())
                .forEach(result -> assertEquals((int) result, (int) expectedResult));

        resultCapList.stream().map(capability -> capability.getFeatureTags())
                .forEach(featureTags -> {
                    assertEquals((int) featureTags.size(), (int) expectedFeatureTags.size());
                    assertTrue(featureTags.containsAll(expectedFeatureTags));
                });
    }

    private void registerUceObserver(Consumer<Uri> resultConsumer) {
        mUceObserver = new ContentObserver(new Handler(sHandlerThread.getLooper())) {
            @Override
            public void onChange(boolean selfChange, Uri uri) {
                resultConsumer.accept(uri);
            }
        };
        getContext().getContentResolver().registerContentObserver(LISTENER_URI,
                true /*notifyForDecendents*/, mUceObserver);
    }

    private void unregisterUceObserver() {
        if (mUceObserver != null) {
            getContext().getContentResolver().unregisterContentObserver(mUceObserver);
        }
    }

    private int waitForIntResult(BlockingQueue<Integer> queue) throws Exception {
        Integer result = queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        return result != null ? result : Integer.MAX_VALUE;
    }

    private long waitForLongResult(BlockingQueue<Long> queue) throws Exception {
        Long result = queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        return result != null ? result : Long.MAX_VALUE;
    }

    private <T> T waitForResult(BlockingQueue<T> queue) throws Exception {
        return queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private void connectTestImsService() throws Exception {
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .build()));

        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(""Did not receive createRcsFeature"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_CREATE_RCS));
        assertTrue(""Did not receive RcsFeature#onReady"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_RCS_READY));
        // Make sure the RcsFeature was created in the test service.
        assertNotNull(""Device ImsService created, but TestDeviceImsService#createRcsFeature was not""
                + ""called!"", sServiceConnector.getCarrierService().getRcsFeature());
        assertTrue(""Did not receive RcsFeature#setCapabilityExchangeEventListener"",
                sServiceConnector.getCarrierService().waitForLatchCountdown(
                        TestImsService.LATCH_UCE_LISTENER_SET));
        int serviceSlot = sServiceConnector.getCarrierService().getRcsFeature().getSlotIndex();
        assertEquals(""The slot specified for the test ("" + sTestSlot + "") does not match the ""
                        + ""assigned slot ("" + serviceSlot + ""+ for the associated RcsFeature"",
                sTestSlot, serviceSlot);
    }

    private static void initPhoneNumbers() {
        // Generate a random phone number
        sTestPhoneNumber = generateRandomPhoneNumber();
        sTestNumberUri = Uri.fromParts(PhoneAccount.SCHEME_TEL, sTestPhoneNumber, null);

        sTestContact2 = generateRandomContact(5);
        sTestContact2Uri = Uri.fromParts(PhoneAccount.SCHEME_SIP, sTestContact2, null);

        sTestContact3 = generateRandomContact(6);
        sTestContact3Uri = Uri.fromParts(PhoneAccount.SCHEME_SIP, sTestContact3, null);
    }

    private static String generateRandomPhoneNumber() {
        Random random = new Random();
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < 10; i++) {
            builder.append(random.nextInt(10));
        }
        return builder.toString();
    }

    private static String generateRandomContact(int length) {
        Random random = new Random();
        StringBuilder builder = new StringBuilder(""TestContact"");
        for (int i = 0; i < length; i++) {
            int asciiNum = random.nextInt(26) + 65;  // ascii 65
            builder.append((char) asciiNum);
        }
        return builder.toString();
    }

    private static void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getInstrumentation()
                .getContext().getSystemService(CarrierConfigManager.class);
        sReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(sTestSub, bundle));
        sReceiver.waitForCarrierConfigChanged();
    }

    private static void removeTestContactFromEab() {
        try {
            StringBuilder builder = new StringBuilder();
            builder.append(sTestPhoneNumber)
                    .append("","").append(sTestContact2)
                    .append("","").append(sTestContact3);
            sServiceConnector.removeEabContacts(sTestSlot, builder.toString());
        } catch (Exception e) {
            Log.w(""RcsUceAdapterTest"", ""Cannot remove test contacts from eab database: "" + e);
        }
    }

    private static void removeUceRequestDisallowedStatus() {
        try {
            sServiceConnector.removeUceRequestDisallowedStatus(sTestSlot);
        } catch (Exception e) {
            Log.w(""RcsUceAdapterTest"", ""Cannot remove request disallowed status: "" + e);
        }
    }

    private static void setCapabilitiesRequestTimeout(long timeoutAfterMillis) {
        try {
            sServiceConnector.setCapabilitiesRequestTimeout(sTestSlot, timeoutAfterMillis);
        } catch (Exception e) {
            Log.w(""RcsUceAdapterTest"", ""Cannot set capabilities request timeout: "" + e);
        }
    }

    private void requestCapabilities(RcsUceAdapter uceAdapter, Collection<Uri> numbers,
            RcsUceAdapter.CapabilitiesCallback callback) {
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestCapabilities(numbers, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE. ""
                    + ""Exception: "" + e);
        } catch (ImsException e) {
            fail(""requestCapabilities failed "" + e);
        }
    }

    private void requestAvailability(RcsUceAdapter uceAdapter, Uri number,
            RcsUceAdapter.CapabilitiesCallback callback) {
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestAvailability(number, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestAvailability should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE. ""
                    + ""Exception: "" + e);
        } catch (ImsException e) {
            fail(""requestAvailability failed "" + e);
        }
    }
}"	""	""	"android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.LocationCheckerActivity"	"hasLocationPermission"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/LocationCheckerActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.Manifest;
import android.app.Activity;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.location.Location;
import android.location.LocationManager;
import android.location.LocationRequest;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.util.Log;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import com.android.cts.verifier.R;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Activity that checks whether it can obtain location. Asks for permission in case it is missing.
 * Result is reported to whoever invoked it with startActivityForResult.
 */
public class LocationCheckerActivity extends Activity {
    private static final String TAG = LocationCheckerActivity.class.getSimpleName();

    public static final String ACTION_CHECK_LOCATION_PRIMARY =
            ""com.android.cts.verifier.managedprovisioning.CHECK_LOCATION_ACCESS_PRIMARY"";
    public static final String ACTION_CHECK_LOCATION_WORK =
            ""com.android.cts.verifier.managedprovisioning.CHECK_LOCATION_ACCESS_WORK"";
    public static final String WORK_ACTIVITY_ALIAS =
            ""com.android.cts.verifier.managedprovisioning.WorkLocationCheckerActivityAlias"";

    public static final String EXTRA_ERROR_ID = ""extra-error-id"";
    public static final int LOCATION_PERMISSION_REQUEST = 125;
    private static final int REQUEST_MAX_DURATION_MILLIS = 15000;

    private List<String> mProviders;
    private LocationManager mLocationManager;
    private TextView mStatusText;
    private final CancellationSignal mCancellationSignal = new CancellationSignal();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.location_checker);

        mLocationManager = getSystemService(LocationManager.class);
        mStatusText = findViewById(R.id.status_text);

        if (hasLocationPermission()) {
            requestCurrentLocation();
        } else {
            requestLocationPermission();
        }
    }

    private void requestCurrentLocation() {
        synchronized (this) {
            mProviders = mLocationManager.getAllProviders().stream()
                    .filter(mLocationManager::isProviderEnabled)
                    .collect(Collectors.toList());
            if (mProviders.isEmpty()) {
                finish(R.string.provisioning_byod_location_no_provider);
                return;
            }
            // Callback will be invoked with null if duration exceeded.
            LocationRequest request = new LocationRequest.Builder(0)
                    .setDurationMillis(REQUEST_MAX_DURATION_MILLIS).build();
            // Request location from all available providers.
            for (String provider: mProviders) {
                mLocationManager.getCurrentLocation(provider, request, mCancellationSignal,
                        getMainExecutor(), l -> onLocation(provider, l));
            }
            updateStatusLocked();
        }
    }

    private void updateStatusLocked() {
        String providers = String.join("", "", mProviders);
        mStatusText.setText(getString(R.string.provisioning_byod_location_trying, providers));
    }

    private boolean hasLocationPermission() {
        return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
                == PackageManager.PERMISSION_GRANTED;
    }

    private void requestLocationPermission() {
        ActivityCompat.requestPermissions(this,
                new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
                LOCATION_PERMISSION_REQUEST);
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
            @NonNull int[] grants) {
        // Test that the right permission was granted.
        if (requestCode == LOCATION_PERMISSION_REQUEST) {
            if (!permissions[0].equals(Manifest.permission.ACCESS_FINE_LOCATION)
                    || grants[0] != PackageManager.PERMISSION_GRANTED
                    || !hasLocationPermission()) {
                Log.e(TAG, ""The test needs location permission."");
                finish(R.string.provisioning_byod_location_mode_enable_missing_permission);
                return;
            }
            requestCurrentLocation();
        }
    }

    private void onLocation(String provider, Location location) {
        if (mCancellationSignal.isCanceled()) {
            return;
        } else if (location != null) {
            mCancellationSignal.cancel();
            finish(-1 /* no error */);
        }

        // location == null, provider wasn't able to get location, see if there are more providers
        synchronized (this) {
            mProviders.remove(provider);
            if (mProviders.isEmpty()) {
                finish(R.string.provisioning_byod_location_failed);
            } else {
                updateStatusLocked();
            }
        }
    }

    void finish(int messageId) {
        Intent result = new Intent();
        result.putExtra(EXTRA_ERROR_ID, messageId);
        setResult(Activity.RESULT_OK, result);
        finish();
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.LocationAccessCheckTest"	"getPermissionControllerPackageName"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.app.AppOpsManager.OPSTR_FINE_LOCATION;
import static android.app.AppOpsManager.OP_FLAGS_ALL_TRUSTED;
import static android.app.Notification.EXTRA_TITLE;
import static android.content.Context.BIND_AUTO_CREATE;
import static android.content.Context.BIND_NOT_FOREGROUND;
import static android.content.Intent.ACTION_BOOT_COMPLETED;
import static android.content.Intent.FLAG_RECEIVER_FOREGROUND;
import static android.location.Criteria.ACCURACY_FINE;
import static android.os.Process.myUserHandle;
import static android.provider.Settings.Secure.LOCATION_ACCESS_CHECK_DELAY_MILLIS;
import static android.provider.Settings.Secure.LOCATION_ACCESS_CHECK_INTERVAL_MILLIS;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;
import static com.android.server.job.nano.JobPackageHistoryProto.START_PERIODIC_JOB;
import static com.android.server.job.nano.JobPackageHistoryProto.STOP_JOB;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import static java.lang.Math.max;
import static java.util.concurrent.TimeUnit.MILLISECONDS;

import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.location.Criteria;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Looper;
import android.permission.cts.appthataccesseslocation.IAccessLocationOnCommand;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;
import android.platform.test.annotations.SystemUserOnly;
import android.provider.DeviceConfig;
import android.provider.Settings;
import android.service.notification.NotificationListenerService;
import android.service.notification.StatusBarNotification;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.DeviceConfigStateHelper;
import com.android.compatibility.common.util.ProtoUtils;
import com.android.compatibility.common.util.mainline.MainlineModule;
import com.android.compatibility.common.util.mainline.ModuleDetector;
import com.android.server.job.nano.JobPackageHistoryProto;
import com.android.server.job.nano.JobSchedulerServiceDumpProto;
import com.android.server.job.nano.JobSchedulerServiceDumpProto.RegisteredJob;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;

/**
 * Tests the {@code LocationAccessCheck} in permission controller.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Cannot set system settings as instant app. Also we never show a location ""
        + ""access check notification for instant apps."")
public class LocationAccessCheckTest {
    private static final String LOG_TAG = LocationAccessCheckTest.class.getSimpleName();

    private static final String TEST_APP_PKG = ""android.permission.cts.appthataccesseslocation"";
    private static final String TEST_APP_LABEL = ""CtsLocationAccess"";
    private static final String TEST_APP_SERVICE = TEST_APP_PKG + "".AccessLocationOnCommand"";
    private static final String TEST_APP_LOCATION_BG_ACCESS_APK =
            ""/data/local/tmp/cts/permissions/CtsAppThatAccessesLocationOnCommand.apk"";
    private static final String TEST_APP_LOCATION_FG_ACCESS_APK =
            ""/data/local/tmp/cts/permissions/AppThatDoesNotHaveBgLocationAccess.apk"";
    private static final int LOCATION_ACCESS_CHECK_JOB_ID = 0;

    /** Whether to show location access check notifications. */
    private static final String PROPERTY_LOCATION_ACCESS_CHECK_ENABLED =
            ""location_access_check_enabled"";

    private static final long UNEXPECTED_TIMEOUT_MILLIS = 10000;
    private static final long EXPECTED_TIMEOUT_MILLIS = 15000;
    private static final long LOCATION_ACCESS_TIMEOUT_MILLIS = 15000;

    private static final Context sContext = InstrumentationRegistry.getTargetContext();
    private static final ActivityManager sActivityManager =
            sContext.getSystemService(ActivityManager.class);
    private static final PackageManager sPackageManager = sContext.getPackageManager();
    private static final AppOpsManager sAppOpsManager =
            sContext.getSystemService(AppOpsManager.class);
    private static final UiAutomation sUiAutomation = InstrumentationRegistry.getInstrumentation()
            .getUiAutomation();

    private static final String PERMISSION_CONTROLLER_PKG = sContext.getPackageManager()
            .getPermissionControllerPackageName();

    /**
     * The result of {@link #assumeCanGetFineLocation()}, so we don't have to run it over and over
     * again.
     */
    private static Boolean sCanAccessFineLocation = null;

    private static ServiceConnection sConnection;
    private static IAccessLocationOnCommand sLocationAccessor;

    private DeviceConfigStateHelper mPrivacyDeviceConfig =
            new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_PRIVACY);
    private static DeviceConfigStateHelper sJobSchedulerDeviceConfig =
            new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_JOB_SCHEDULER);

    private static void assumeNotPlayManaged() throws Exception {
        assumeFalse(ModuleDetector.moduleIsPlayManaged(
                sContext.getPackageManager(), MainlineModule.PERMISSION_CONTROLLER));
    }

    /**
     * Connected to {@value #TEST_APP_PKG} and make it access the location in the background
     */
    private void accessLocation() throws Throwable {
        if (sConnection == null || sLocationAccessor == null) {
            bindService();
        }

        long beforeAccess = System.currentTimeMillis();
        // Wait a little to avoid raciness in timing between threads
        Thread.sleep(1000);

        // Try again until binder call goes though. It might not go through if the sLocationAccessor
        // is not bound yet
        eventually(() -> {
            assertNotNull(sLocationAccessor);
            sLocationAccessor.accessLocation();
        }, EXPECTED_TIMEOUT_MILLIS);

        // Wait until the access is recorded
        eventually(() -> {
            List<AppOpsManager.PackageOps> ops = runWithShellPermissionIdentity(
                    () -> sAppOpsManager.getOpsForPackage(
                            sPackageManager.getPackageUid(TEST_APP_PKG, 0), TEST_APP_PKG,
                            OPSTR_FINE_LOCATION));

            // Background access must have happened after ""beforeAccess""
            assertTrue(ops.get(0).getOps().get(0).getLastAccessBackgroundTime(OP_FLAGS_ALL_TRUSTED)
                    >= beforeAccess);
        }, EXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * A {@link java.util.concurrent.Callable} that can throw a {@link Throwable}
     */
    private interface ThrowingCallable<T> {
        T call() throws Throwable;
    }

    /**
     * A {@link Runnable} that can throw a {@link Throwable}
     */
    private interface ThrowingRunnable {
        void run() throws Throwable;
    }

    /**
     * Make sure that a {@link ThrowingRunnable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r       The {@link ThrowingRunnable} to run.
     * @param timeout the maximum time to wait
     */
    public static void eventually(@NonNull ThrowingRunnable r, long timeout) throws Throwable {
        eventually(() -> {
            r.run();
            return 0;
        }, timeout);
    }

    /**
     * Make sure that a {@link ThrowingCallable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r       The {@link ThrowingCallable} to run.
     * @param timeout the maximum time to wait
     * @return the return value from the callable
     * @throws NullPointerException If the return value never becomes non-null
     */
    public static <T> T eventually(@NonNull ThrowingCallable<T> r, long timeout) throws Throwable {
        long start = System.currentTimeMillis();

        while (true) {
            try {
                T res = r.call();
                if (res == null) {
                    throw new NullPointerException(""No result"");
                }

                return res;
            } catch (Throwable e) {
                if (System.currentTimeMillis() - start < timeout) {
                    Log.d(LOG_TAG, ""Ignoring exception"", e);

                    Thread.sleep(500);
                } else {
                    throw e;
                }
            }
        }
    }

    /**
     * Get the state of the job scheduler
     */
    public static JobSchedulerServiceDumpProto getJobSchedulerDump() throws Exception {
        return ProtoUtils.getProto(sUiAutomation, JobSchedulerServiceDumpProto.class,
                ProtoUtils.DUMPSYS_JOB_SCHEDULER);
    }

    /**
     * Clear all data of a package including permissions and files.
     *
     * @param pkg The name of the package to be cleared
     */
    private static void clearPackageData(@NonNull String pkg) {
        unbindService();
        runShellCommand(""pm clear --user -2 "" + pkg);
    }

    /**
     * Get the last time the LOCATION_ACCESS_CHECK_JOB_ID job was started/stopped for permission
     * controller.
     *
     * @param event the job event (start/stop)
     *
     * @return the last time the event happened.
     */
    private static long getLastJobTime(int event) throws Exception {
        int permControllerUid = sPackageManager.getPackageUid(PERMISSION_CONTROLLER_PKG, 0);

        long lastTime = -1;

        for (JobPackageHistoryProto.HistoryEvent historyEvent :
                getJobSchedulerDump().history.historyEvent) {
            if (historyEvent.uid == permControllerUid
                    && historyEvent.jobId == LOCATION_ACCESS_CHECK_JOB_ID
                    && historyEvent.event == event) {
                lastTime = max(lastTime,
                        System.currentTimeMillis() - historyEvent.timeSinceEventMs);
            }
        }

        return lastTime;
    }

    /**
     * Force a run of the location check.
     */
    private static void runLocationCheck() throws Throwable {
        // Sleep a little bit to make sure we don't have overlap in timing
        Thread.sleep(1000);

        long beforeJob = System.currentTimeMillis();

        // Sleep a little bit to avoid raciness in time keeping
        Thread.sleep(1000);

        runShellCommand(
                ""cmd jobscheduler run -u "" + android.os.Process.myUserHandle().getIdentifier()
                        + "" -f "" + PERMISSION_CONTROLLER_PKG + "" 0"");

        eventually(() -> {
            long startTime = getLastJobTime(START_PERIODIC_JOB);
            assertTrue(startTime + "" !> "" + beforeJob, startTime > beforeJob);
        }, EXPECTED_TIMEOUT_MILLIS);

        // We can't simply require startTime <= endTime because the time being reported isn't
        // accurate, and sometimes the end time may come before the start time by around 100 ms.
        eventually(() -> {
            long stopTime = getLastJobTime(STOP_JOB);
            assertTrue(stopTime + "" !> "" + beforeJob, stopTime > beforeJob);
        }, EXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * Get a notification thrown by the permission controller that is currently visible.
     *
     * @return The notification or {@code null} if there is none
     */
    private @Nullable StatusBarNotification getPermissionControllerNotification() throws Exception {
        NotificationListenerService notificationService = NotificationListener.getInstance();

        for (StatusBarNotification notification : notificationService.getActiveNotifications()) {
            if (notification.getPackageName().equals(PERMISSION_CONTROLLER_PKG)) {
                return notification;
            }
        }

        return null;
    }

    /**
     * Get a location access notification that is currently visible.
     *
     * @param cancelNotification if {@code true} the notification is canceled inside this method
     * @return The notification or {@code null} if there is none
     */
    private StatusBarNotification getNotification(boolean cancelNotification) throws Throwable {
        NotificationListenerService notificationService = NotificationListener.getInstance();

        StatusBarNotification notification = getPermissionControllerNotification();
        if (notification == null) {
            return null;
        }

        if (notification.getNotification().extras.getString(EXTRA_TITLE, """")
                .contains(TEST_APP_LABEL)) {
            if (cancelNotification) {
                notificationService.cancelNotification(notification.getKey());

                // Wait for notification to get canceled
                eventually(() -> assertFalse(
                        Arrays.asList(notificationService.getActiveNotifications()).contains(
                                notification)), UNEXPECTED_TIMEOUT_MILLIS);
            }

            return notification;
        }

        Log.d(LOG_TAG, ""Bad notification "" + notification);

        return null;
    }

    /**
     * Grant a permission to the {@value #TEST_APP_PKG}.
     *
     * @param permission The permission to grant
     */
    private void grantPermissionToTestApp(@NonNull String permission) {
        sUiAutomation.grantRuntimePermission(TEST_APP_PKG, permission);
    }

    /**
     * Register {@link NotificationListener}.
     */
    @BeforeClass
    public static void allowNotificationAccess() {
        runShellCommand(""cmd notification allow_listener "" + (new ComponentName(sContext,
                NotificationListener.class).flattenToString()));
    }

    /**
     * Change settings so that permission controller can show location access notifications more
     * often.
     */
    @BeforeClass
    public static void reduceDelays() {
        runWithShellPermissionIdentity(() -> {
            ContentResolver cr = sContext.getContentResolver();

            // New settings will be applied in when permission controller is reset
            Settings.Secure.putLong(cr, LOCATION_ACCESS_CHECK_INTERVAL_MILLIS, 100);
            Settings.Secure.putLong(cr, LOCATION_ACCESS_CHECK_DELAY_MILLIS, 50);

            // Disable job scheduler throttling by allowing 300000 jobs per 30 sec
            sJobSchedulerDeviceConfig.set(""qc_max_job_count_per_rate_limiting_window"", ""3000000"");
            sJobSchedulerDeviceConfig.set(""qc_rate_limiting_window_ms"", ""30000"");
        });
    }

    @BeforeClass
    public static void installBackgroundAccessApp() throws Exception {
        installBackgroundAccessApp(false);
    }

    private static void installBackgroundAccessApp(boolean isDowngrade) throws Exception {
        String command = ""pm install -r -g "";
        if (isDowngrade) {
            command = command + ""-d "";
        }
        String output = runShellCommand(command + TEST_APP_LOCATION_BG_ACCESS_APK);
        assertTrue(output.contains(""Success""));
        // Wait for user sensitive to be updated, which is checked by LocationAccessCheck.
        Thread.sleep(5000);
    }

    @AfterClass
    public static void uninstallBackgroundAccessApp() {
        unbindService();
        runShellCommand(""pm uninstall "" + TEST_APP_PKG);
    }

    private static void unbindService() {
        if (sConnection != null) {
            sContext.unbindService(sConnection);
        }
        sConnection = null;
        sLocationAccessor = null;
    }


    private static void installForegroundAccessApp() throws Exception {
        unbindService();
        runShellCommand(""pm install -r -g "" + TEST_APP_LOCATION_FG_ACCESS_APK);
        // Wait for user sensitive to be updated, which is checked by LocationAccessCheck.
        Thread.sleep(5000);
    }

    private static void uninstallForegroundAccessApp() {
        runShellCommand(""pm uninstall "" + TEST_APP_LOCATION_FG_ACCESS_APK);
    }

    /**
     * Skip each test for low ram device
     */
    @Before
    public void assumeIsNotLowRamDevice() {
        assumeFalse(sActivityManager.isLowRamDevice());
    }

    @Before
    public void wakeUpAndDismissKeyguard() {
        runShellCommand(""input keyevent KEYCODE_WAKEUP"");
        runShellCommand(""wm dismiss-keyguard"");
    }

    @Before
    public void bindService() {
        sConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                sLocationAccessor = IAccessLocationOnCommand.Stub.asInterface(service);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                sConnection = null;
                sLocationAccessor = null;
            }
        };

        Intent testAppService = new Intent();
        testAppService.setComponent(new ComponentName(TEST_APP_PKG, TEST_APP_SERVICE));

        sContext.bindService(testAppService, sConnection, BIND_AUTO_CREATE | BIND_NOT_FOREGROUND);
    }

    /**
     * Reset the permission controllers state before each test
     */
    @Before
    public void resetPermissionControllerBeforeEachTest() throws Throwable {
        // Has to be before resetPermissionController to make sure enablement time is the reset time
        // of permission controller
        enableLocationAccessCheck();

        resetPermissionController();

        eventually(() -> assertNull(getNotification(false)), UNEXPECTED_TIMEOUT_MILLIS);

        // Reset job scheduler stats (to allow more jobs to be run)
        runShellCommand(
                ""cmd jobscheduler reset-execution-quota -u "" + myUserHandle().getIdentifier() + "" ""
                        + PERMISSION_CONTROLLER_PKG);
    }

    /**
     * Enable location access check
     */
    public void enableLocationAccessCheck() throws Throwable {
        mPrivacyDeviceConfig.set(PROPERTY_LOCATION_ACCESS_CHECK_ENABLED, ""true"");

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    /**
     * Disable location access check
     */
    private void disableLocationAccessCheck() throws Throwable {
        mPrivacyDeviceConfig.set(PROPERTY_LOCATION_ACCESS_CHECK_ENABLED, ""false"");

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    /**
     * Make sure fine location can be accessed at all.
     */
    @Before
    public void assumeCanGetFineLocation() {
        if (sCanAccessFineLocation == null) {
            Criteria crit = new Criteria();
            crit.setAccuracy(ACCURACY_FINE);

            CountDownLatch locationCounter = new CountDownLatch(1);
            sContext.getSystemService(LocationManager.class).requestSingleUpdate(crit,
                    new LocationListener() {
                        @Override
                        public void onLocationChanged(Location location) {
                            locationCounter.countDown();
                        }

                        @Override
                        public void onStatusChanged(String provider, int status, Bundle extras) {
                        }

                        @Override
                        public void onProviderEnabled(String provider) {
                        }

                        @Override
                        public void onProviderDisabled(String provider) {
                        }
                    }, Looper.getMainLooper());


            try {
                sCanAccessFineLocation = locationCounter.await(LOCATION_ACCESS_TIMEOUT_MILLIS,
                        MILLISECONDS);
            } catch (InterruptedException ignored) {
            }
        }

        assumeTrue(sCanAccessFineLocation);
    }

    /**
     * Reset the permission controllers state.
     */
    private static void resetPermissionController() throws Throwable {
        clearPackageData(PERMISSION_CONTROLLER_PKG);
        int currentUserId = myUserHandle().getIdentifier();

        // Wait until jobs are cleared
        eventually(() -> {
            JobSchedulerServiceDumpProto dump = getJobSchedulerDump();

            for (RegisteredJob job : dump.registeredJobs) {
                if (job.dump.sourceUserId == currentUserId) {
                    assertNotEquals(job.dump.sourcePackageName, PERMISSION_CONTROLLER_PKG);
                }
            }
        }, UNEXPECTED_TIMEOUT_MILLIS);

        // Setup up permission controller again (simulate a reboot)
        Intent permissionControllerSetupIntent = null;
        for (ResolveInfo ri : sContext.getPackageManager().queryBroadcastReceivers(
                new Intent(ACTION_BOOT_COMPLETED), 0)) {
            String pkg = ri.activityInfo.packageName;

            if (pkg.equals(PERMISSION_CONTROLLER_PKG)) {
                permissionControllerSetupIntent = new Intent()
                        .setClassName(pkg, ri.activityInfo.name)
                        .setFlags(FLAG_RECEIVER_FOREGROUND)
                        .setPackage(PERMISSION_CONTROLLER_PKG);

                sContext.sendBroadcast(permissionControllerSetupIntent);
            }
        }

        // Wait until jobs are set up
        eventually(() -> {
            JobSchedulerServiceDumpProto dump = getJobSchedulerDump();

            for (RegisteredJob job : dump.registeredJobs) {
                if (job.dump.sourceUserId == currentUserId
                        && job.dump.sourcePackageName.equals(PERMISSION_CONTROLLER_PKG)
                        && job.dump.jobInfo.service.className.contains(""LocationAccessCheck"")) {
                    return;
                }
            }

            fail(""Permission controller jobs not found"");
        }, UNEXPECTED_TIMEOUT_MILLIS);
    }

    /**
     * Unregister {@link NotificationListener}.
     */
    @AfterClass
    public static void disallowNotificationAccess() {
        runShellCommand(""cmd notification disallow_listener "" + (new ComponentName(sContext,
                NotificationListener.class)).flattenToString());
    }

    /**
     * Reset settings so that permission controller runs normally.
     */
    @AfterClass
    public static void resetDelays() throws Throwable {
        runWithShellPermissionIdentity(() -> {
            ContentResolver cr = sContext.getContentResolver();

            Settings.Secure.resetToDefaults(cr, LOCATION_ACCESS_CHECK_INTERVAL_MILLIS);
            Settings.Secure.resetToDefaults(cr, LOCATION_ACCESS_CHECK_DELAY_MILLIS);

            sJobSchedulerDeviceConfig.restoreOriginalValues();
        });
    }

    /**
     * Reset location access check
     */
    @After
    public void resetPrivacyConfig() throws Throwable {
        mPrivacyDeviceConfig.restoreOriginalValues();

        // Run a location access check to update enabled state inside permission controller
        runLocationCheck();
    }

    @After
    public void locationUnbind() throws Throwable {
        unbindService();
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.LocationAccessCheckTest"	"notificationIsShownAgainAfterClear"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	"@AsbSecurityTest(cveBugId = 141028068)
    public void notificationIsShownAgainAfterClear() throws Throwable {
        assumeNotPlayManaged();
        accessLocation();
        runLocationCheck();

        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);

        clearPackageData(TEST_APP_PKG);

        // Wait until package is cleared and permission controller has cleared the state
        Thread.sleep(10000);

        // Clearing removed the permissions, hence grant them again
        grantPermissionToTestApp(ACCESS_FINE_LOCATION);
        grantPermissionToTestApp(ACCESS_BACKGROUND_LOCATION);

        accessLocation();
        runLocationCheck();

        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);
    }

    @SystemUserOnly(reason = ""b/172259935"")"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.backup.cts.PermissionTest"	"testGrantDeniedRuntimePermission"	"CtsBackupTestCases"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	"public void testGrantDeniedRuntimePermission() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        grantPermission(APP, ACCESS_FINE_LOCATION);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            assertEquals(PERMISSION_GRANTED, checkPermission(APP, ACCESS_FINE_LOCATION));
            assertEquals(PERMISSION_DENIED, checkPermission(APP, READ_CONTACTS));
        });
    }

    /**
     * Test backup and restore of pre-M regular runtime permission.
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.backup.cts.PermissionTest"	"testGrantDeniedRuntimePermission22"	"CtsBackupTestCases"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	"public void testGrantDeniedRuntimePermission22() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        setAppOp(APP22, READ_CONTACTS, MODE_IGNORED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP22);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            assertEquals(MODE_IGNORED, getAppOp(APP22, READ_CONTACTS));
            assertEquals(MODE_ALLOWED, getAppOp(APP22, ACCESS_FINE_LOCATION));
        });
    }

    /**
     * Test backup and restore of foreground runtime permission.
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.backup.cts.PermissionTest"	"testNoTriStateRuntimePermission"	"CtsBackupTestCases"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	"public void testNoTriStateRuntimePermission() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        // Set a marker
        grantPermission(APP, WRITE_CONTACTS);

        // revoked is the default state. Hence mark the permissions as user set, so the permissions
        // are even backed up
        setFlag(APP, ACCESS_FINE_LOCATION, FLAG_PERMISSION_USER_SET);
        setFlag(APP, ACCESS_BACKGROUND_LOCATION, FLAG_PERMISSION_USER_SET);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            // Wait until marker is set
            assertEquals(PERMISSION_GRANTED, checkPermission(APP, WRITE_CONTACTS));

            assertEquals(PERMISSION_DENIED, checkPermission(APP, ACCESS_FINE_LOCATION));
            assertEquals(PERMISSION_DENIED, checkPermission(APP, ACCESS_BACKGROUND_LOCATION));
            assertEquals(MODE_IGNORED, getAppOp(APP, ACCESS_FINE_LOCATION));
        });
    }

    /**
     * Test backup and restore of foreground runtime permission.
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.backup.cts.PermissionTest"	"testNoTriStateRuntimePermission22"	"CtsBackupTestCases"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	"public void testNoTriStateRuntimePermission22() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        setAppOp(APP22, ACCESS_FINE_LOCATION, MODE_IGNORED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP22);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> assertEquals(MODE_IGNORED, getAppOp(APP22, ACCESS_FINE_LOCATION)));
    }

    /**
     * Test backup and restore of foreground runtime permission.
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.backup.cts.PermissionTest"	"testGrantForegroundRuntimePermission"	"CtsBackupTestCases"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	"public void testGrantForegroundRuntimePermission() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        grantPermission(APP, ACCESS_FINE_LOCATION);

        // revoked is the default state. Hence mark the permission as user set, so the permissions
        // are even backed up
        setFlag(APP, ACCESS_BACKGROUND_LOCATION, FLAG_PERMISSION_USER_SET);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            assertEquals(PERMISSION_GRANTED, checkPermission(APP, ACCESS_FINE_LOCATION));
            assertEquals(PERMISSION_DENIED, checkPermission(APP, ACCESS_BACKGROUND_LOCATION));
            assertEquals(MODE_FOREGROUND, getAppOp(APP, ACCESS_FINE_LOCATION));
        });
    }

    /**
     * Test backup and restore of foreground runtime permission.
     *
     * Comment out the test since it's a JUnit 3 test which doesn't support @Ignore
     * TODO: b/178522459 to fix the test once the foundamental issue has been fixed.
     */
//"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.backup.cts.PermissionTest"	"testGrantForegroundRuntimePermission22"	"CtsBackupTestCases"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	"public void testGrantForegroundRuntimePermission22() throws Exception {
//        if (!isBackupSupported()) {
//            return;
//        }
//        setAppOp(APP22, ACCESS_FINE_LOCATION, MODE_FOREGROUND);
//
//        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
//        resetApp(APP22);
//        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);
//
//        eventually(() -> assertEquals(MODE_FOREGROUND, getAppOp(APP22, ACCESS_FINE_LOCATION)));
//    }

    /**
     * Test backup and restore of foreground runtime permission.
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.backup.cts.PermissionTest"	"testGrantForegroundAndBackgroundRuntimePermission"	"CtsBackupTestCases"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	"public void testGrantForegroundAndBackgroundRuntimePermission() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        grantPermission(APP, ACCESS_FINE_LOCATION);
        grantPermission(APP, ACCESS_BACKGROUND_LOCATION);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            assertEquals(PERMISSION_GRANTED, checkPermission(APP, ACCESS_FINE_LOCATION));
            assertEquals(PERMISSION_GRANTED, checkPermission(APP, ACCESS_BACKGROUND_LOCATION));
            assertEquals(MODE_ALLOWED, getAppOp(APP, ACCESS_FINE_LOCATION));
        });
    }

    /**
     * Test backup and restore of foreground runtime permission.
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.backup.cts.PermissionTest"	"testGrantForegroundAndBackgroundRuntimePermission22"	"CtsBackupTestCases"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	"public void testGrantForegroundAndBackgroundRuntimePermission22() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        // Set a marker
        setAppOp(APP22, WRITE_CONTACTS, MODE_IGNORED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP22);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            // Wait for marker
            assertEquals(MODE_IGNORED, getAppOp(APP22, WRITE_CONTACTS));

            assertEquals(MODE_ALLOWED, getAppOp(APP22, ACCESS_FINE_LOCATION));
        });
    }

    /**
     * Restore if the permission was reviewed
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.backup.cts.PermissionTest"	"testDelayedRestore"	"CtsBackupTestCases"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	"public void testDelayedRestore() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        grantPermission(APP, ACCESS_FINE_LOCATION);

        setAppOp(APP22, READ_CONTACTS, MODE_IGNORED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);

        uninstall(APP);
        uninstall(APP22);

        try {
            mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

            install(APP_APK);

            eventually(() -> assertEquals(PERMISSION_GRANTED,
                    checkPermission(APP, ACCESS_FINE_LOCATION)));

            install(APP22_APK);

            eventually(() -> assertEquals(MODE_IGNORED, getAppOp(APP22, READ_CONTACTS)));
        } finally {
            install(APP_APK);
            install(APP22_APK);
        }
    }

    private void install(String apk) {
        ShellUtils.runShellCommand(""pm install -r "" + apk);
    }

    private void uninstall(String packageName) {
        ShellUtils.runShellCommand(""pm uninstall "" + packageName);
    }

    private void resetApp(String packageName) {
        ShellUtils.runShellCommand(""pm clear "" + packageName);
        ShellUtils.runShellCommand(""appops reset "" + packageName);
    }

    /**
     * Make sure that a {@link Runnable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r The {@link Runnable} to run.
     */
    public static void eventually(@NonNull Runnable r) {
        long start = System.currentTimeMillis();

        while (true) {
            try {
                r.run();
                return;
            } catch (Throwable e) {
                if (System.currentTimeMillis() - start < TIMEOUT_MILLIS) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException ignored) {
                        throw new RuntimeException(e);
                    }
                } else {
                    throw e;
                }
            }
        }
    }

    private void setFlag(String app, String permission, int flag) {
        runWithShellPermissionIdentity(
                () -> sContext.getPackageManager().updatePermissionFlags(permission, app,
                        flag, flag, sContext.getUser()));
    }

    private void clearFlag(String app, String permission, int flag) {
        runWithShellPermissionIdentity(
                () -> sContext.getPackageManager().updatePermissionFlags(permission, app,
                        flag, 0, sContext.getUser()));
    }

    private boolean isFlagSet(String app, String permission, int flag) {
        try {
            return (callWithShellPermissionIdentity(
                    () -> sContext.getPackageManager().getPermissionFlags(permission, app,
                            sContext.getUser())) & flag) == flag;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private int checkPermission(String app, String permission) {
        return sContext.getPackageManager().checkPermission(permission, app);
    }

    private void setAppOp(String app, String permission, int mode) {
        runWithShellPermissionIdentity(
                () -> sContext.getSystemService(AppOpsManager.class).setUidMode(
                        permissionToOp(permission),
                        sContext.getPackageManager().getPackageUid(app, 0), mode));
    }

    private int getAppOp(String app, String permission) {
        try {
            return callWithShellPermissionIdentity(
                    () -> sContext.getSystemService(AppOpsManager.class).unsafeCheckOpRaw(
                            permissionToOp(permission),
                            sContext.getPackageManager().getPackageUid(app, 0), app));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.TestHelper"	"isEmpty"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/TestHelper.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.os.WorkSource;
import android.support.test.uiautomator.UiDevice;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Class to hold helper methods that are repeated across wifi CTS tests.
 */
public class TestHelper {
    private static final String TAG = ""WifiTestHelper"";

    private final Context mContext;
    private final WifiManager mWifiManager;
    private final ConnectivityManager mConnectivityManager;
    private final UiDevice mUiDevice;

    private static final int DURATION_MILLIS = 10_000;
    private static final int DURATION_NETWORK_CONNECTION_MILLIS = 40_000;
    private static final int DURATION_SCREEN_TOGGLE_MILLIS = 2000;
    private static final int DURATION_UI_INTERACTION_MILLIS = 25_000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    public TestHelper(@NonNull Context context, @NonNull UiDevice uiDevice) {
        mContext = context;
        mWifiManager = context.getSystemService(WifiManager.class);
        mConnectivityManager = context.getSystemService(ConnectivityManager.class);
        mUiDevice = uiDevice;
    }

    public void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    public void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    private static class TestScanResultsCallback extends WifiManager.ScanResultsCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;

        TestScanResultsCallback(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onScanResultsAvailable() {
            onAvailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Loops through all the saved networks available in the scan results. Returns a list of
     * WifiConfiguration with the matching bssid filled in {@link WifiConfiguration#BSSID}.
     *
     * Note:
     * a) If there are more than 2 networks with the same SSID, but different credential type, then
     * this matching may pick the wrong one.
     *
     * @param wifiManager WifiManager service
     * @param savedNetworks List of saved networks on the device.
     */
    public static List<WifiConfiguration> findMatchingSavedNetworksWithBssid(
            @NonNull WifiManager wifiManager, @NonNull List<WifiConfiguration> savedNetworks) {
        if (savedNetworks.isEmpty()) return Collections.emptyList();
        List<WifiConfiguration> matchingNetworksWithBssids = new ArrayList<>();
        CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 0; i < SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID; i++) {
            // Trigger a scan to get fresh scan results.
            TestScanResultsCallback scanResultsCallback =
                    new TestScanResultsCallback(countDownLatch);
            try {
                wifiManager.registerScanResultsCallback(
                        Executors.newSingleThreadExecutor(), scanResultsCallback);
                wifiManager.startScan(new WorkSource(myUid()));
                // now wait for callback
                countDownLatch.await(DURATION_MILLIS, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            } finally {
                wifiManager.unregisterScanResultsCallback(scanResultsCallback);
            }
            List<ScanResult> scanResults = wifiManager.getScanResults();
            if (scanResults == null || scanResults.isEmpty()) fail(""No scan results available"");
            for (ScanResult scanResult : scanResults) {
                WifiConfiguration matchingNetwork = savedNetworks.stream()
                        .filter(network -> TextUtils.equals(
                                scanResult.SSID, WifiInfo.sanitizeSsid(network.SSID)))
                        .findAny()
                        .orElse(null);
                if (matchingNetwork != null) {
                    // make a copy in case we have 2 bssid's for the same network.
                    WifiConfiguration matchingNetworkCopy = new WifiConfiguration(matchingNetwork);
                    matchingNetworkCopy.BSSID = scanResult.BSSID;
                    matchingNetworksWithBssids.add(matchingNetworkCopy);
                }
            }
            if (!matchingNetworksWithBssids.isEmpty()) break;
        }
        return matchingNetworksWithBssids;
    }

    /**
     * Convert the provided saved network to a corresponding suggestion builder.
     */
    public static WifiNetworkSuggestion.Builder
            createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        WifiNetworkSuggestion.Builder suggestionBuilder = new WifiNetworkSuggestion.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID))
                .setBssid(MacAddress.fromString(network.BSSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                suggestionBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                suggestionBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            suggestionBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        suggestionBuilder.setIsHiddenSsid(network.hiddenSSID);
        return suggestionBuilder;
    }


    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder createSpecifierBuilderWithCredentialFromSavedNetwork(
            @NonNull WifiConfiguration network) {
        WifiNetworkSpecifier.Builder specifierBuilder = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                specifierBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                specifierBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            specifierBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        specifierBuilder.setIsHiddenSsid(network.hiddenSSID);
        return specifierBuilder;
    }

    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder
            createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        return createSpecifierBuilderWithCredentialFromSavedNetwork(network)
                .setBssid(MacAddress.fromString(network.BSSID));
    }

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;
        public boolean onUnavailableCalled = false;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch, int flags) {
            super(flags);
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onAvailable(Network network) {
            onAvailableCalled = true;
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            this.networkCapabilities = networkCapabilities;
            mCountDownLatch.countDown();
        }

        @Override
        public void onUnavailable() {
            onUnavailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    private static TestNetworkCallback createTestNetworkCallback(
            @NonNull CountDownLatch countDownLatch) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // flags for NetworkCallback only introduced in S.
            return new TestNetworkCallback(countDownLatch, FLAG_INCLUDE_LOCATION_INFO);
        } else {
            return new TestNetworkCallback(countDownLatch);
        }
    }

    @NonNull
    private WifiInfo getWifiInfo(@NonNull NetworkCapabilities networkCapabilities) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // WifiInfo in transport info, only available in S.
            return (WifiInfo) networkCapabilities.getTransportInfo();
        } else {
            return mWifiManager.getConnectionInfo();
        }
    }

    private static void assertConnectionEquals(@NonNull WifiConfiguration network,
            @NonNull WifiInfo wifiInfo) {
        assertThat(network.SSID).isEqualTo(wifiInfo.getSSID());
        assertThat(network.BSSID).isEqualTo(wifiInfo.getBSSID());
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final CountDownLatch mCountDownLatch;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;

        TestActionListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onSuccess() {
            onSuccessCalled = true;
            mCountDownLatch.countDown();
        }

        @Override
        public void onFailure(int reason) {
            onFailedCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * WifiConfiguration, WifiManager.ActionListener)}
     *
     * @param network saved network from the device to use for the connection.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithConnect(
            @NonNull WifiConfiguration network) throws Exception {
        CountDownLatch countDownLatchAl = new CountDownLatch(1);
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestActionListener actionListener = new TestActionListener(countDownLatchAl);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // File a callback for wifi network.
            mConnectivityManager.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            // Needed to ensure that the restricted concurrent connection does not
                            // match this request.
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE)
                            .build(),
                    testNetworkCallback);
            // Trigger the connection.
            mWifiManager.connect(network, actionListener);
            // now wait for action listener callback
            assertThat(countDownLatchAl.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            // check if we got the success callback
            assertThat(actionListener.onSuccessCalled).isTrue();

            // Wait for connection to complete & ensure we are connected to the saved network.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
            final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
            assertConnectionEquals(network, wifiInfo);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // User connections should always be primary.
                assertThat(wifiInfo.isPrimary()).isTrue();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            // Unregister the network callback in case of any failure (since we don't end up
            // returning the network callback to the caller).
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionWithShellIdentity(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        return testConnectionFlowWithSuggestionInternal(
                network, suggestion, executorService, restrictedNetworkCapabilities, true);
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionWithShellIdentity(
                    network, suggestion, executorService, restrictedNetworkCapabilities);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the connection failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFailureFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionInternal(
                    network, suggestion, executorService, restrictedNetworkCapabilities, false);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the entire connection success/failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     * @param expectConnectionSuccess Whether to expect connection success or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    private ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionInternal(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities,
            boolean expectConnectionSuccess) throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);
        try {
            // File a request for restricted (oem paid) wifi network.
            NetworkRequest.Builder nrBuilder = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (restrictedNetworkCapabilities.isEmpty()) {
                // If not a restricted connection, a network callback is sufficient.
                mConnectivityManager.registerNetworkCallback(
                        nrBuilder.build(), testNetworkCallback);
            } else {
                for (Integer restrictedNetworkCapability : restrictedNetworkCapabilities) {
                    nrBuilder.addCapability(restrictedNetworkCapability);
                }
                mConnectivityManager.requestNetwork(nrBuilder.build(), testNetworkCallback);
            }
            // Add wifi network suggestion.
            assertThat(mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)))
                    .isEqualTo(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS);
            // Wait for the request to reach the wifi stack before kick-start periodic scans.
            Thread.sleep(100);
            // Step: Trigger scans periodically to trigger network selection quicker.
            executorService.scheduleAtFixedRate(() -> {
                if (!mWifiManager.startScan()) {
                    Log.w(TAG, ""Failed to trigger scan"");
                }
            }, 0, DURATION_MILLIS, TimeUnit.MILLISECONDS);
            if (expectConnectionSuccess) {
                // now wait for connection to complete and wait for callback
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
                    assertThat(wifiInfo.isTrusted()).isTrue();
                    WifiInfo redact = wifiInfo
                            .makeCopy(NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION);
                    assertThat(wifiInfo.getInformationElements()).isNotNull();
                    assertThat(redact.getInformationElements()).isNull();
                    assertThat(redact.getApplicableRedactions()).isEqualTo(
                            NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION
                            | NetworkCapabilities.REDACT_FOR_LOCAL_MAC_ADDRESS
                            | NetworkCapabilities.REDACT_FOR_NETWORK_SETTINGS);
                }
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for restricted connection is supported, this should not
                    // be the primary connection.
                    if (!restrictedNetworkCapabilities.isEmpty()
                            && mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            } else {
                // now wait for connection to timeout.
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isFalse();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            executorService.shutdown();
        }
        return testNetworkCallback;
    }

    private static class TestNetworkRequestMatchCallback implements
            WifiManager.NetworkRequestMatchCallback {
        private final Object mLock;

        public boolean onRegistrationCalled = false;
        public boolean onAbortCalled = false;
        public boolean onMatchCalled = false;
        public boolean onConnectSuccessCalled = false;
        public boolean onConnectFailureCalled = false;
        public WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback = null;
        public List<ScanResult> matchedScanResults = null;

        TestNetworkRequestMatchCallback(Object lock) {
            mLock = lock;
        }

        @Override
        public void onUserSelectionCallbackRegistration(
                WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback) {
            synchronized (mLock) {
                onRegistrationCalled = true;
                this.userSelectionCallback = userSelectionCallback;
                mLock.notify();
            }
        }

        @Override
        public void onAbort() {
            synchronized (mLock) {
                onAbortCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onMatch(List<ScanResult> scanResults) {
            synchronized (mLock) {
                // This can be invoked multiple times. So, ignore after the first one to avoid
                // disturbing the rest of the test sequence.
                if (onMatchCalled) return;
                onMatchCalled = true;
                matchedScanResults = scanResults;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectSuccess(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectFailure(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectFailureCalled = true;
                mLock.notify();
            }
        }
    }

    private void handleUiInteractions(WifiConfiguration network, boolean shouldUserReject) {
        // can't use CountDownLatch since there are many callbacks expected and CountDownLatch
        // cannot be reset.
        // TODO(b/177591382): Use ArrayBlockingQueue/LinkedBlockingQueue
        Object uiLock = new Object();
        TestNetworkRequestMatchCallback networkRequestMatchCallback =
                new TestNetworkRequestMatchCallback(uiLock);
        try {
            // 1. Wait for registration callback.
            synchronized (uiLock) {
                try {
                    mWifiManager.registerNetworkRequestMatchCallback(
                            Executors.newSingleThreadExecutor(), networkRequestMatchCallback);
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            assertThat(networkRequestMatchCallback.onRegistrationCalled).isTrue();
            assertThat(networkRequestMatchCallback.userSelectionCallback).isNotNull();

            // 2. Wait for matching scan results
            synchronized (uiLock) {
                if (!networkRequestMatchCallback.onMatchCalled) {
                    try {
                        uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                    } catch (InterruptedException e) {
                    }
                }
            }
            assertThat(networkRequestMatchCallback.onMatchCalled).isTrue();
            assertThat(networkRequestMatchCallback.matchedScanResults).isNotNull();
            assertThat(networkRequestMatchCallback.matchedScanResults.size()).isAtLeast(1);

            // 3. Trigger connection to one of the matched networks or reject the request.
            if (shouldUserReject) {
                networkRequestMatchCallback.userSelectionCallback.reject();
            } else {
                networkRequestMatchCallback.userSelectionCallback.select(network);
            }

            // 4. Wait for connection success or abort.
            synchronized (uiLock) {
                try {
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            if (shouldUserReject) {
                assertThat(networkRequestMatchCallback.onAbortCalled).isTrue();
            } else {
                assertThat(networkRequestMatchCallback.onConnectSuccessCalled).isTrue();
            }
        } finally {
            mWifiManager.unregisterNetworkRequestMatchCallback(networkRequestMatchCallback);
        }
    }

    /**
     * Tests the entire connection flow using the provided specifier,
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifierWithShellIdentity(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);

        // Fork a thread to handle the UI interactions.
        Thread uiThread = new Thread(() -> {
            try {
                handleUiInteractions(network, shouldUserReject);
            } catch (Throwable e /* catch assertions & exceptions */) {
                try {
                    mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
                } catch (IllegalArgumentException ie) { }
                throw e;
            }
        });

        try {
            // File a request for wifi network.
            mConnectivityManager.requestNetwork(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            .setNetworkSpecifier(specifier)
                            .build(),
                    testNetworkCallback);
            // Wait for the request to reach the wifi stack before kick-starting the UI
            // interactions.
            Thread.sleep(1_000);
            // Start the UI interactions.
            uiThread.run();
            // now wait for callback
            assertThat(countDownLatch.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            if (shouldUserReject) {
                assertThat(testNetworkCallback.onUnavailableCalled).isTrue();
            } else {
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for local only connection is supported, this should not
                    // be the primary connection.
                    if (mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        }
        try {
            // Ensure that the UI interaction thread has completed.
            uiThread.join(DURATION_UI_INTERACTION_MILLIS);
        } catch (InterruptedException e) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            fail(""UI interaction interrupted"");
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection flow using the provided specifier.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS);
            return testConnectionFlowWithSpecifierWithShellIdentity(
                    network, specifier, shouldUserReject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Returns the number of wifi connections visible at the networking layer.
     */
    public long getNumWifiConnections() {
        Network[] networks = mConnectivityManager.getAllNetworks();
        return Arrays.stream(networks)
                .filter(n ->
                        mConnectivityManager.getNetworkCapabilities(n).hasTransport(TRANSPORT_WIFI))
                .count();
    }

    /**
     * Registers a network callback for internet connectivity via wifi and asserts that a network
     * is available within {@link #DURATION_NETWORK_CONNECTION_MILLIS}.
     *
     * @throws Exception
     */
    public void assertWifiInternetConnectionAvailable() throws Exception {
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        try {
            // File a callback for wifi network.
            NetworkRequest.Builder builder = new NetworkRequest.Builder()
                    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // Needed to ensure that the restricted concurrent connection does not
                // match this request.
                builder.addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                        .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE);
            }
            mConnectivityManager.registerNetworkCallback(builder.build(), testNetworkCallback);
            // Wait for connection to complete & ensure we are connected to some network capable
            // of providing internet access.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
        } finally {
            mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
        }
    }

    public static int getBandFromFrequency(final int freqMHz) {
        if (freqMHz < 1000) {
            return ScanResult.UNSPECIFIED;
        } else if (freqMHz < 4000) { // getFrequency is in WifiInfo.FREQUENCY_UNITS = MHz
            return ScanResult.WIFI_BAND_24_GHZ;
        } else if (freqMHz < 5900) {
            // 5GHz band stops at 5885MHz, 6GHz band starts at 5955. See android.net.wifi.ScanResult
            return ScanResult.WIFI_BAND_5_GHZ;
        } else if (freqMHz < 10_000) {
            return ScanResult.WIFI_BAND_6_GHZ;
        } else if (freqMHz < 71_000) {
            // 60 GHz band stops at 70_200
            return ScanResult.WIFI_BAND_60_GHZ;
        } else {
            return ScanResult.UNSPECIFIED;
        }
    }

}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.bluetooth.cts.BluetoothLeScanTest"	"isEnabled"	"CtsBluetoothTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/BluetoothLeScanTest.java"	""	"public void test/*
 *.
 */

package android.bluetooth.cts;

import android.app.PendingIntent;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanFilter;
import android.bluetooth.le.ScanRecord;
import android.bluetooth.le.ScanResult;
import android.bluetooth.le.ScanSettings;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.ParcelUuid;
import android.os.SystemClock;
import android.test.AndroidTestCase;
import android.test.suitebuilder.annotation.MediumTest;
import android.util.Log;
import android.util.SparseArray;

import androidx.test.InstrumentationRegistry;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Test cases for Bluetooth LE scans.
 * <p>
 * To run the test, the device must be placed in an environment that has at least 3 beacons, all
 * placed less than 5 meters away from the DUT.
 * <p>
 * Run 'run cts --class android.bluetooth.cts.BluetoothLeScanTest' in cts-tradefed to run the test
 * cases.
 */
public class BluetoothLeScanTest extends AndroidTestCase {

    private static final String TAG = ""BluetoothLeScanTest"";

    private static final int SCAN_DURATION_MILLIS = 10000;
    private static final int BATCH_SCAN_REPORT_DELAY_MILLIS = 20000;
    private static final int SCAN_STOP_TIMEOUT = 2000;
    private CountDownLatch mFlushBatchScanLatch;

    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothLeScanner mScanner;
    // Whether location is on before running the tests.
    private boolean mLocationOn;

    @Override
    public void setUp() {
        if (!TestUtils.isBleSupported(getContext())) {
            return;
        }
        BluetoothManager manager = (BluetoothManager) mContext.getSystemService(
                Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = manager.getAdapter();
        if (!mBluetoothAdapter.isEnabled()) {
            assertTrue(BTAdapterUtils.enableAdapter(mBluetoothAdapter, mContext));
        }
        mScanner = mBluetoothAdapter.getBluetoothLeScanner();
        mLocationOn = TestUtils.isLocationOn(getContext());
        if (!mLocationOn) {
            TestUtils.enableLocation(getContext());
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                ""android.bluetooth.cts"", android.Manifest.permission.ACCESS_FINE_LOCATION);
    }

    @Override
    public void tearDown() {
        if (!TestUtils.isBleSupported(getContext())) {
          // mBluetoothAdapter == null.
          return;
        }

        if (!mLocationOn) {
            TestUtils.disableLocation(getContext());
        }
        assertTrue(BTAdapterUtils.disableAdapter(mBluetoothAdapter, mContext));
    }

    /**
     * Basic test case for BLE scans. Checks BLE scan timestamp is within correct range.
     */
    @MediumTest"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.locationpolicy.LocationPolicyTest"	"testLocationPolicyPermissions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/LocationPolicyApp/src/android/appsecurity/cts/locationpolicy/LocationPolicyTest.java"	""	"@AsbSecurityTest(cveBugId = 148414207)
    public void testLocationPolicyPermissions() throws Exception {
        assertNotNull(mContext);
        PackageManager pm = mContext.getPackageManager();
        assertNotNull(pm);
        assertNotEquals(
            PackageManager.PERMISSION_GRANTED,
            pm.checkPermission(Manifest.permission.ACCESS_FINE_LOCATION,
            mContext.getPackageName()));
        assertNotEquals(
            PackageManager.PERMISSION_GRANTED,
            pm.checkPermission(Manifest.permission.ACCESS_COARSE_LOCATION,
            mContext.getPackageName()));
        UserManager manager = mContext.getSystemService(UserManager.class);
        if (manager.isSystemUser()) {
            return;
        }
        if (pm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            TelephonyManager tele = mContext.getSystemService(TelephonyManager.class);
            try {
                tele.getCellLocation();
            fail(
                ""ACCESS_FINE_LOCATION and ACCESS_COARSE_LOCATION Permissions not granted. Should""
                  + "" have received a security exception when invoking getCellLocation()."");
            } catch (SecurityException ignore) {
              // That's what we want!
            }
        }
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.ByodHelperActivity"	"isProfileOwner"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/ByodHelperActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.os.UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES;
import static android.os.UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY;

import android.Manifest;
import android.app.Activity;
import android.app.KeyguardManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.UserManager;
import android.provider.MediaStore;
import android.util.Log;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.core.content.FileProvider;
import androidx.core.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.managedprovisioning.ByodPresentMediaDialog.DialogCallback;

import java.io.File;
import java.util.ArrayList;

/**
 * A helper activity from the managed profile side that responds to requests from CTS verifier in
 * primary user. Profile owner APIs are accessible inside this activity (given this activity is
 * started within the work profile). Its current functionalities include making sure the profile
 * owner is setup correctly, removing the work profile upon request, and verifying the image and
 * video capture functionality.
 *
 * Note: We have to use a test activity because cross-profile intents only work for activities.
 */
public class ByodHelperActivity extends Activity
        implements DialogCallback, ActivityCompat.OnRequestPermissionsResultCallback {

    static final String TAG = ""ByodHelperActivity"";

    // Primary -> managed intent: query if the profile owner has been set up.
    public static final String ACTION_QUERY_PROFILE_OWNER = ""com.android.cts.verifier.managedprovisioning.BYOD_QUERY"";
    // Managed -> primary intent: update profile owner test status in primary's CtsVerifer
    public static final String ACTION_PROFILE_OWNER_STATUS = ""com.android.cts.verifier.managedprovisioning.BYOD_STATUS"";
    // Primary -> managed intent: request to delete the current profile
    public static final String ACTION_REMOVE_MANAGED_PROFILE = ""com.android.cts.verifier.managedprovisioning.BYOD_REMOVE"";
    // Primary -> managed intent: request to capture and check an image
    public static final String ACTION_CAPTURE_AND_CHECK_IMAGE = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_IMAGE"";
    // Primary -> managed intent: request to capture and check a video with custom output path
    public static final String ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT"";
    // Primary -> managed intent: request to capture and check a video without custom output path
    public static final String ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT"";
    // Primary -> managed intent: request to capture and check an audio recording
    public static final String ACTION_CAPTURE_AND_CHECK_AUDIO = ""com.android.cts.verifier.managedprovisioning.BYOD_CAPTURE_AND_CHECK_AUDIO"";
    public static final String ACTION_KEYGUARD_DISABLED_FEATURES =
            ""com.android.cts.verifier.managedprovisioning.BYOD_KEYGUARD_DISABLED_FEATURES"";
    public static final String ACTION_LOCKNOW =
            ""com.android.cts.verifier.managedprovisioning.BYOD_LOCKNOW"";
    public static final String ACTION_TEST_NFC_BEAM = ""com.android.cts.verifier.managedprovisioning.TEST_NFC_BEAM"";

    public static final String EXTRA_PROVISIONED = ""extra_provisioned"";
    public static final String EXTRA_PARAMETER_1 = ""extra_parameter_1"";

    // Primary -> managed intent: check if the disk of the device is encrypted
    public static final String ACTION_CHECK_DISK_ENCRYPTION =
            ""com.android.cts.verifier.managedprovisioning.action.BYOD_CHECK_DISK_ENCRYPTION"";
    // Managed -> primary intent: update disk encryption status in primary's CtsVerifier
    public static final String ACTION_DISK_ENCRYPTION_STATUS =
            ""com.android.cts.verifier.managedprovisioning.action.BYOD_DISK_ENCRYPTION_STATUS"";
    // Int extra field indicating the encryption status of the device storage
    public static final String EXTRA_ENCRYPTION_STATUS = ""extra_encryption_status"";

    // Primary -> managed intent: set unknown sources restriction and install package
    public static final String ACTION_INSTALL_APK = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK"";
    public static final String EXTRA_ALLOW_NON_MARKET_APPS = ""allow_non_market_apps"";
    public static final String ACTION_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION"";
    public static final String EXTRA_ALLOW_NON_MARKET_APPS_DEVICE_WIDE = ""allow_non_market_apps_device_wide"";

    // Primary -> managed intent: set unknown sources globally restriction
    public static final String ACTION_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION"";
    // Managed -> primary intent: install primary profile app with global unknown sources
    // restriction.
    public static final String ACTION_INSTALL_APK_IN_PRIMARY = ""com.android.cts.verifier.managedprovisioning.BYOD_INSTALL_APK_IN_PRIMARY"";

    // Primary -> managed intent: check if the required cross profile intent filters are set.
    public static final String ACTION_CHECK_INTENT_FILTERS =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_INTENT_FILTERS"";

    // Primary -> managed intent: will send a cross profile intent and check if the user sees an
    // intent picker dialog and can open the apps.
    public static final String ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG =
            ""com.android.cts.verifier.managedprovisioning.action.TEST_CROSS_PROFILE_INTENTS_DIALOG"";

    // Primary -> managed intent: will send an app link intent and check if the user sees a
    // dialog and can open the apps. This test is extremely similar to
    // ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG, but the intent used is a web intent, and there is
    // some behavior which is specific to web intents.
    public static final String ACTION_TEST_APP_LINKING_DIALOG =
            ""com.android.cts.verifier.managedprovisioning.action.TEST_APP_LINKING_DIALOG"";

    public static final String ACTION_NOTIFICATION =
            ""com.android.cts.verifier.managedprovisioning.NOTIFICATION"";
    public static final String ACTION_NOTIFICATION_ON_LOCKSCREEN =
            ""com.android.cts.verifier.managedprovisioning.LOCKSCREEN_NOTIFICATION"";
    public static final String ACTION_CLEAR_NOTIFICATION =
            ""com.android.cts.verifier.managedprovisioning.CLEAR_NOTIFICATION"";

    // Primary -> managed intent: set a user restriction
    public static final String ACTION_SET_USER_RESTRICTION =
            ""com.android.cts.verifier.managedprovisioning.BYOD_SET_USER_RESTRICTION"";

    // Primary -> managed intent: reset a user restriction
    public static final String ACTION_CLEAR_USER_RESTRICTION =
            ""com.android.cts.verifier.managedprovisioning.BYOD_CLEAR_USER_RESTRICTION"";

    // Primary -> managed intent: Start the selection of a work challenge
    public static final String ACTION_TEST_SELECT_WORK_CHALLENGE =
            ""com.android.cts.verifier.managedprovisioning.TEST_SELECT_WORK_CHALLENGE"";

    // Primary -> managed intent: Start the selection of a work challenge
    public static final String ACTION_TEST_PATTERN_WORK_CHALLENGE =
            ""com.android.cts.verifier.managedprovisioning.TEST_PATTERN_WORK_CHALLENGE"";

    // Primary -> managed intent: Start the selection of a parent profile password.
    public static final String ACTION_TEST_PARENT_PROFILE_PASSWORD =
            ""com.android.cts.verifier.managedprovisioning.TEST_PARENT_PROFILE_PASSWORD"";

    // Primary -> managed intent: Start the confirm credentials screen for the managed profile
    public static final String ACTION_LAUNCH_CONFIRM_WORK_CREDENTIALS =
            ""com.android.cts.verifier.managedprovisioning.LAUNCH_CONFIRM_WORK_CREDENTIALS"";

    public static final String ACTION_SET_ORGANIZATION_INFO =
            ""com.android.cts.verifier.managedprovisioning.TEST_ORGANIZATION_INFO"";

    public static final int RESULT_FAILED = RESULT_FIRST_USER;

    private static final int REQUEST_INSTALL_PACKAGE = 2;
    private static final int REQUEST_IMAGE_CAPTURE = 3;
    private static final int REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT = 4;
    private static final int REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT = 5;
    private static final int REQUEST_AUDIO_CAPTURE = 6;

    private static final String ORIGINAL_RESTRICTIONS_NAME = ""original restrictions"";

    private static final int NOTIFICATION_ID = 7;
    private static final String NOTIFICATION_CHANNEL_ID = TAG;

    private static final int EXECUTE_IMAGE_CAPTURE_TEST = 1;
    private static final int EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST = 2;
    private static final int EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST = 3;

    private NotificationManager mNotificationManager;
    private Bundle mOriginalRestrictions;

    private ComponentName mAdminReceiverComponent;
    private DevicePolicyManager mDevicePolicyManager;

    private Uri mImageUri;
    private Uri mVideoUri;
    private File mImageFile;

    private ArrayList<File> mTempFiles = new ArrayList<File>();

    private Handler mMainThreadHandler;

    private void showNotification(int visibility) {
        final Notification notification = new Notification.Builder(this, NOTIFICATION_CHANNEL_ID)
                .setSmallIcon(R.drawable.icon)
                .setContentTitle(getString(R.string.provisioning_byod_notification_title))
                .setContentText(getString(R.string.provisioning_byod_notification_title))
                .setVisibility(visibility)
                .setAutoCancel(true)
                .setPublicVersion(createPublicVersionNotification())
                .build();
        mNotificationManager.notify(NOTIFICATION_ID, notification);
    }

    private Notification createPublicVersionNotification() {
        return new Notification.Builder(this)
                .setSmallIcon(R.drawable.icon)
                .setContentTitle(getString(R.string.provisioning_byod_notification_public_title))
                .setAutoCancel(true)
                .build();
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mMainThreadHandler = new Handler(getMainLooper());
        if (savedInstanceState != null) {
            Log.w(TAG, ""Restored state"");
            mOriginalRestrictions = savedInstanceState.getBundle(ORIGINAL_RESTRICTIONS_NAME);
        } else {
            mOriginalRestrictions = new Bundle();
        }

        mAdminReceiverComponent = new ComponentName(this, DeviceAdminTestReceiver.class.getName());
        mDevicePolicyManager = (DevicePolicyManager) getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        Intent intent = getIntent();
        String action = intent.getAction();
        Log.d(TAG, ""ByodHelperActivity.onCreate: "" + action);
        mNotificationManager.createNotificationChannel(new NotificationChannel(
                NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_ID,
                NotificationManager.IMPORTANCE_DEFAULT));

        // Queried by CtsVerifier in the primary side using startActivityForResult.
        if (action.equals(ACTION_QUERY_PROFILE_OWNER)) {
            Intent response = new Intent();
            response.putExtra(EXTRA_PROVISIONED, isProfileOwner());
            setResult(RESULT_OK, response);
            // Request to delete work profile.
        } else if (action.equals(ACTION_REMOVE_MANAGED_PROFILE)) {
            if (isProfileOwner()) {
                Log.d(TAG, ""Clearing cross profile intents"");
                mDevicePolicyManager.clearCrossProfileIntentFilters(mAdminReceiverComponent);
                mDevicePolicyManager.wipeData(0);
                showToast(R.string.provisioning_byod_profile_deleted);
            }
        } else if (action.equals(ACTION_CHECK_DISK_ENCRYPTION)) {
            final int status = mDevicePolicyManager.getStorageEncryptionStatus();
            final Intent response = new Intent(ACTION_DISK_ENCRYPTION_STATUS)
                    .putExtra(EXTRA_ENCRYPTION_STATUS, status);
            setResult(RESULT_OK, response);
        } else if (action.equals(ACTION_INSTALL_APK)) {
            boolean allowNonMarket = intent.getBooleanExtra(EXTRA_ALLOW_NON_MARKET_APPS, false);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES, !allowNonMarket);
            startInstallerActivity(intent.getStringExtra(EXTRA_PARAMETER_1));
            // Not yet ready to finish - wait until the result comes back
            return;
        } else if (action.equals(ACTION_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION)) {
            // Save original unknown sources setting to be restored later and clear it for now.
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES, false);
            boolean allowNonMarketGlobal = intent.getBooleanExtra(
                    EXTRA_ALLOW_NON_MARKET_APPS_DEVICE_WIDE, false);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
                    !allowNonMarketGlobal);
            startInstallerActivity(intent.getStringExtra(EXTRA_PARAMETER_1));
            // Not yet ready to finish - wait until the result comes back
            return;
        } else if (action.equals(ACTION_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION)) {
            boolean allowNonMarketGlobal = intent.getExtras().getBoolean(
                    EXTRA_ALLOW_NON_MARKET_APPS_DEVICE_WIDE, false);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
                    !allowNonMarketGlobal);
            setRestrictionAndSaveOriginal(DISALLOW_INSTALL_UNKNOWN_SOURCES, false);
            Intent installPersonalProfileIntent = new Intent(ACTION_INSTALL_APK_IN_PRIMARY);
            // Attempt to install an apk in the primary profile
            startActivityForResult(installPersonalProfileIntent, REQUEST_INSTALL_PACKAGE);
            return;
        } else if (action.equals(ACTION_CHECK_INTENT_FILTERS)) {
            // Queried by CtsVerifier in the primary side using startActivityForResult.
            final boolean intentFiltersSetForManagedIntents =
                    new IntentFiltersTestHelper(this).checkCrossProfileIntentFilters(
                            IntentFiltersTestHelper.FLAG_INTENTS_FROM_MANAGED);
            setResult(intentFiltersSetForManagedIntents? RESULT_OK : RESULT_FAILED, null);
        } else if (action.equals(ACTION_CAPTURE_AND_CHECK_IMAGE)) {
            if (hasCameraPermission()) {
                startCaptureImageIntent();
            } else {
                requestCameraPermission(EXECUTE_IMAGE_CAPTURE_TEST);
            }
            return;
        } else if (action.equals(ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT) ||
                action.equals(ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT)) {
            final int testRequestCode;
            if (action.equals(ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT)) {
                testRequestCode = EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST;
            } else {
                testRequestCode = EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST;
            }

            if (hasCameraPermission()) {
                startCaptureVideoActivity(testRequestCode);
            } else {
                requestCameraPermission(testRequestCode);
            }
            return;
        } else if (action.equals(ACTION_CAPTURE_AND_CHECK_AUDIO)) {
            Intent captureAudioIntent = getCaptureAudioIntent();
            if (captureAudioIntent.resolveActivity(getPackageManager()) != null) {
                startActivityForResult(captureAudioIntent, REQUEST_AUDIO_CAPTURE);
            } else {
                Log.e(TAG, ""Capture audio intent could not be resolved in managed profile."");
                showToast(R.string.provisioning_byod_capture_media_error);
                finish();
            }
            return;
        } else if (ACTION_KEYGUARD_DISABLED_FEATURES.equals(action)) {
            final int value = intent.getIntExtra(EXTRA_PARAMETER_1,
                    DevicePolicyManager.KEYGUARD_DISABLE_FEATURES_NONE);
            mDevicePolicyManager.setKeyguardDisabledFeatures(mAdminReceiverComponent, value);
        } else if (ACTION_LOCKNOW.equals(action)) {
            mDevicePolicyManager.lockNow();
            setResult(RESULT_OK);
        } else if (action.equals(ACTION_TEST_NFC_BEAM)) {
            Intent testNfcBeamIntent = new Intent(this, NfcTestActivity.class);
            testNfcBeamIntent.putExtras(intent);
            startActivity(testNfcBeamIntent);
            finish();
            return;
        } else if (action.equals(ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG)) {
            sendIntentInsideChooser(new Intent(
                    CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_PERSONAL));
        } else if (action.equals(ACTION_TEST_APP_LINKING_DIALOG)) {
            mDevicePolicyManager.addUserRestriction(
                    DeviceAdminTestReceiver.getReceiverComponentName(),
                    UserManager.ALLOW_PARENT_PROFILE_APP_LINKING);
            Intent toSend = new Intent(Intent.ACTION_VIEW);
            toSend.setData(Uri.parse(""http://com.android.cts.verifier""));
            sendIntentInsideChooser(toSend);
        } else if (action.equals(ACTION_SET_USER_RESTRICTION)) {
            final String restriction = intent.getStringExtra(EXTRA_PARAMETER_1);
            if (restriction != null) {
                mDevicePolicyManager.addUserRestriction(
                        DeviceAdminTestReceiver.getReceiverComponentName(), restriction);
            }
        } else if (action.equals(ACTION_CLEAR_USER_RESTRICTION)) {
            final String restriction = intent.getStringExtra(EXTRA_PARAMETER_1);
            if (restriction != null) {
                mDevicePolicyManager.clearUserRestriction(
                        DeviceAdminTestReceiver.getReceiverComponentName(), restriction);
            }
        } else if (action.equals(ACTION_NOTIFICATION)) {
            showNotification(Notification.VISIBILITY_PUBLIC);
        } else if (ACTION_NOTIFICATION_ON_LOCKSCREEN.equals(action)) {
            mDevicePolicyManager.lockNow();
            showNotification(Notification.VISIBILITY_PRIVATE);
        } else if (ACTION_CLEAR_NOTIFICATION.equals(action)) {
            mNotificationManager.cancel(NOTIFICATION_ID);
        } else if (ACTION_TEST_SELECT_WORK_CHALLENGE.equals(action)) {
            mDevicePolicyManager.setOrganizationName(mAdminReceiverComponent, getResources()
                    .getString(R.string.provisioning_byod_confirm_work_credentials_header));
            startActivity(new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD));
        } else if (ACTION_LAUNCH_CONFIRM_WORK_CREDENTIALS.equals(action)) {
            KeyguardManager keyguardManager =
                    (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);
            Intent launchIntent = keyguardManager.createConfirmDeviceCredentialIntent(null, null);
            if (launchIntent != null) {
                startActivity(launchIntent);
            } else {
                showToast(R.string.provisioning_byod_no_secure_lockscreen);
            }
        } else if (ACTION_TEST_PATTERN_WORK_CHALLENGE.equals(action)) {
            startActivity(new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD));
            // The remaining steps are manual.
        } else if (ACTION_SET_ORGANIZATION_INFO.equals(action)) {
            if(intent.hasExtra(OrganizationInfoTestActivity.EXTRA_ORGANIZATION_NAME)) {
                final String organizationName = intent
                        .getStringExtra(OrganizationInfoTestActivity.EXTRA_ORGANIZATION_NAME);
                mDevicePolicyManager.setOrganizationName(mAdminReceiverComponent, organizationName);
            }
        } else if (ACTION_TEST_PARENT_PROFILE_PASSWORD.equals(action)) {
            startActivity(new Intent(DevicePolicyManager.ACTION_SET_NEW_PARENT_PROFILE_PASSWORD));
        }
        // This activity has no UI and is only used to respond to CtsVerifier in the primary side.
        finish();
    }

    private void startCaptureVideoActivity(int testRequestCode) {
        Intent captureVideoIntent = getCaptureVideoIntent();
        int videoCaptureRequestId;
        if (testRequestCode == EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST) {
            mVideoUri = getTempUri(""video.mp4"").second;
            captureVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, mVideoUri);
            videoCaptureRequestId = REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT;
        } else {
            videoCaptureRequestId = REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT;
        }
        if (captureVideoIntent.resolveActivity(getPackageManager()) != null) {
            startActivityForResult(captureVideoIntent, videoCaptureRequestId);
        } else {
            Log.e(TAG, ""Capture video intent could not be resolved in managed profile."");
            showToast(R.string.provisioning_byod_capture_media_error);
            finish();
        }
    }

    private void startCaptureImageIntent() {
        Intent captureImageIntent = getCaptureImageIntent();
        Pair<File, Uri> pair = getTempUri(""image.jpg"");
        mImageFile = pair.first;
        mImageUri = pair.second;
        captureImageIntent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);
        if (captureImageIntent.resolveActivity(getPackageManager()) != null) {
            startActivityForResult(captureImageIntent, REQUEST_IMAGE_CAPTURE);
        } else {
            Log.e(TAG, ""Capture image intent could not be resolved in managed profile."");
            showToast(R.string.provisioning_byod_capture_media_error);
            finish();
        }
    }

    private void startInstallerActivity(String pathToApk) {
        // Start the installer activity until this activity is rendered to workaround a glitch.
        mMainThreadHandler.post(() -> {
            final Uri uri;
            if (pathToApk == null) {
                // By default we reinstall ourselves, e.g. request to install a non-market app
                uri = Uri.parse(""package:"" + getPackageName());
            } else {
                uri = FileProvider.getUriForFile(
                    this, Utils.FILE_PROVIDER_AUTHORITY, new File(pathToApk));
            }
            final Intent installIntent = new Intent(Intent.ACTION_INSTALL_PACKAGE)
                .setData(uri)
                .putExtra(Intent.EXTRA_NOT_UNKNOWN_SOURCE, true)
                .addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                .putExtra(Intent.EXTRA_RETURN_RESULT, true);
            startActivityForResult(installIntent, REQUEST_INSTALL_PACKAGE);
        });
    }

    @Override
    protected void onSaveInstanceState(final Bundle savedState) {
        super.onSaveInstanceState(savedState);

        savedState.putBundle(ORIGINAL_RESTRICTIONS_NAME, mOriginalRestrictions);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_INSTALL_PACKAGE: {
                Log.w(TAG, ""Received REQUEST_INSTALL_PACKAGE, resultCode = "" + resultCode);
                // Restore original settings for restrictions being changed before installs.
                restoreOriginalRestriction(DISALLOW_INSTALL_UNKNOWN_SOURCES);
                restoreOriginalRestriction(DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY);
                finish();
                break;
            }
            case REQUEST_IMAGE_CAPTURE: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newImageInstance(mImageFile)
                            .show(getFragmentManager(), ""ViewImageDialogFragment"");
                } else {
                    // Failed capturing image.
                    finish();
                }
                break;
            }
            case REQUEST_VIDEO_CAPTURE_WITH_EXTRA_OUTPUT: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newVideoInstance(mVideoUri)
                            .show(getFragmentManager(), ""PlayVideoDialogFragment"");
                } else {
                    // Failed capturing video.
                    finish();
                }
                break;
            }
            case REQUEST_VIDEO_CAPTURE_WITHOUT_EXTRA_OUTPUT: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newVideoInstance(data.getData())
                            .show(getFragmentManager(), ""PlayVideoDialogFragment"");
                } else {
                    // Failed capturing video.
                    finish();
                }
                break;
            }
            case REQUEST_AUDIO_CAPTURE: {
                if (resultCode == RESULT_OK) {
                    ByodPresentMediaDialog.newAudioInstance(data.getData())
                            .show(getFragmentManager(), ""PlayAudioDialogFragment"");
                } else {
                    // Failed capturing audio.
                    finish();
                }
                break;
            }
            default: {
                super.onActivityResult(requestCode, resultCode, data);
                break;
            }
        }
    }

    @Override
    protected void onDestroy() {
        cleanUpTempUris();
        super.onDestroy();
    }

    public static Intent getCaptureImageIntent() {
        return new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    }

    public static Intent getCaptureVideoIntent() {
        return new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
    }

    public static Intent getCaptureAudioIntent() {
        return new Intent(MediaStore.Audio.Media.RECORD_SOUND_ACTION);
    }

    public static Intent createLockIntent() {
        return new Intent(ACTION_LOCKNOW);
    }

    private Pair<File, Uri> getTempUri(String fileName) {
        final File file = new File(getFilesDir() + File.separator + ""images""
                + File.separator + fileName);
        file.getParentFile().mkdirs(); //if the folder doesn't exists it is created
        mTempFiles.add(file);
        return new Pair<>(file, FileProvider.getUriForFile(
                this, Utils.FILE_PROVIDER_AUTHORITY, file));
    }

    private void cleanUpTempUris() {
        for (File file : mTempFiles) {
            file.delete();
        }
    }

    private boolean isProfileOwner() {
        return mDevicePolicyManager.isAdminActive(mAdminReceiverComponent) &&
                mDevicePolicyManager.isProfileOwnerApp(mAdminReceiverComponent.getPackageName());
    }

    private boolean isRestrictionSet(String restriction) {
        Bundle restrictions = mDevicePolicyManager.getUserRestrictions(mAdminReceiverComponent);
        // This defaults to false if there is no value already there. If a restriction was true,
        // the restriction would already be set.
        return restrictions.getBoolean(restriction, false);
    }

    private void setRestriction(String restriction, boolean enabled) {
        if (enabled) {
            mDevicePolicyManager.addUserRestriction(mAdminReceiverComponent, restriction);
        } else {
            mDevicePolicyManager.clearUserRestriction(mAdminReceiverComponent, restriction);
        }
    }

    private void setRestrictionAndSaveOriginal(String restriction, boolean enabled) {
        // Saves original restriction values in mOriginalRestrictions before changing its value.
        boolean original = isRestrictionSet(restriction);
        if (enabled != original) {
            setRestriction(restriction, enabled);
            mOriginalRestrictions.putBoolean(restriction, original);
        }
    }

    public void restoreOriginalRestriction(String restriction) {
        if (mOriginalRestrictions.containsKey(restriction)) {
            setRestriction(restriction, mOriginalRestrictions.getBoolean(restriction));
            mOriginalRestrictions.remove(restriction);
        }
    }

    private boolean hasCameraPermission() {
        return ContextCompat.checkSelfPermission(this, android.Manifest.permission.CAMERA)
                == PackageManager.PERMISSION_GRANTED;
    }

    private void requestCameraPermission(int requestCode) {
        ActivityCompat.requestPermissions(this, new String[]{android.Manifest.permission.CAMERA},
                requestCode);
    }

    private boolean hasLocationPermission() {
        return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
                == PackageManager.PERMISSION_GRANTED;
    }

    private void requestLocationPermission(int requestCode) {
        ActivityCompat.requestPermissions(this,
                new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
                requestCode);
    }

    /**
     * Launch the right test based on the request code, after validating the right permission
     * has been granted.
     */
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
            @NonNull int[] grants) {
        // Test that the right permission was granted.
        switch(requestCode) {
            case EXECUTE_IMAGE_CAPTURE_TEST:
            case EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST:
            case EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST:
                if (!permissions[0].equals(android.Manifest.permission.CAMERA)
                        || grants[0] != PackageManager.PERMISSION_GRANTED) {
                    Log.e(TAG, ""The test needs camera permission."");
                    showToast(R.string.provisioning_byod_capture_media_error);
                    finish();
                    return;
                }
                break;
        }

        // Execute the right test.
        switch (requestCode) {
            case EXECUTE_IMAGE_CAPTURE_TEST:
                startCaptureImageIntent();
                break;
            case EXECUTE_VIDEO_CAPTURE_WITH_EXTRA_TEST:
            case EXECUTE_VIDEO_CAPTURE_WITHOUT_EXTRA_TEST:
                startCaptureVideoActivity(requestCode);
                break;
            default:
                Log.e(TAG, ""Unknown action."");
                finish();
        }
    }

    private void sendIntentInsideChooser(Intent toSend) {
        toSend.putExtra(CrossProfileTestActivity.EXTRA_STARTED_FROM_WORK, true);
        Intent chooser = Intent.createChooser(toSend,
                getResources().getString(R.string.provisioning_cross_profile_chooser));
        startActivity(chooser);
    }

    @Override
    public void onDialogClose() {
        finish();
    }

    private void showToast(int messageId) {
        String message = getString(messageId);
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.EnterprisePrivacyTestListActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/EnterprisePrivacyTestListActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.Manifest;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.DataSetObserver;
import android.os.Bundle;
import android.provider.Settings;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.IntentDrivenTestActivity.ButtonInfo;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;

import static com.android.cts.verifier.managedprovisioning.Utils.createInteractiveTestItem;

/**
 * Test class to verify privacy information is shown for devices managed by a Device Owner.
 */
public class EnterprisePrivacyTestListActivity extends PassFailButtons.TestListActivity {

    private static final String ENTERPRISE_PRIVACY_PAGE = ""ENTERPRISE_PRIVACY_PAGE"";
    private static final String ENTERPRISE_PRIVACY_NETWORK_LOGGING
            = ""ENTERPRISE_PRIVACY_NETWORK_LOGGING"";
    private static final String ENTERPRISE_PRIVACY_BUG_REPORT = ""ENTERPRISE_PRIVACY_BUG_REPORT"";
    private static final String ENTERPRISE_PRIVACY_SECURITY_LOGGING
            = ""ENTERPRISE_PRIVACY_SECURITY_LOGGING"";
    private static final String ENTERPRISE_PRIVACY_ENTERPRISE_INSTALLED_APPS
            = ""ENTERPRISE_PRIVACY_ENTERPRISE_INSTALLED_APPS"";
    private static final String ENTERPRISE_PRIVACY_LOCATION_ACCESS
            = ""ENTERPRISE_PRIVACY_LOCATION_ACCESS"";
    private static final String ENTERPRISE_PRIVACY_MICROPHONE_ACCESS
            = ""ENTERPRISE_PRIVACY_MICROPHONE_ACCESS"";
    private static final String ENTERPRISE_PRIVACY_CAMERA_ACCESS
            = ""ENTERPRISE_PRIVACY_CAMERA_ACCESS"";
    private static final String ENTERPRISE_PRIVACY_DEFAULT_APPS
            = ""ENTERPRISE_PRIVACY_DEFAULT_APPS"";
    private static final String ENTERPRISE_PRIVACY_DEFAULT_IME
            = ""ENTERPRISE_PRIVACY_DEFAULT_IME"";
    private static final String ENTERPRISE_PRIVACY_ALWAYS_ON_VPN
            = ""ENTERPRISE_PRIVACY_ALWAYS_ON_VPN"";
    private static final String ENTERPRISE_PRIVACY_GLOBAL_HTTP_PROXY
            = ""ENTERPRISE_PRIVACY_GLOBAL_HTTP_PROXY"";
    private static final String ENTERPRISE_PRIVACY_CA_CERTS = ""ENTERPRISE_PRIVACY_CA_CERTS"";
    private static final String ENTERPRISE_PRIVACY_FAILED_PASSWORD_WIPE
            = ""ENTERPRISE_PRIVACY_FAILED_PASSWORD_WIPE"";
    private static final String ENTERPRISE_PRIVACY_QUICK_SETTINGS
            = ""ENTERPRISE_PRIVACY_QUICK_SETTINGS"";
    private static final String ENTERPRISE_PRIVACY_KEYGUARD = ""ENTERPRISE_PRIVACY_KEYGUARD"";
    private static final String ENTERPRISE_PRIVACY_ADD_ACCOUNT = ""ENTERPRISE_PRIVACY_ADD_ACCOUNT"";

    public static final String EXTRA_TEST_ID =
            ""com.android.cts.verifier.managedprovisioning.extra.TEST_ID"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_list);
        setPassFailButtonClickListeners();
        final ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);
        addTestsToAdapter(adapter);
        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }
        });
        setTestListAdapter(adapter);
    }

    private Intent buildCommandIntent(String command) {
        return new Intent(CommandReceiverActivity.ACTION_EXECUTE_COMMAND)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND, command);
    }

    private TestListItem buildCommandTest(String id, int titleRes, int infoRes,
            int commandButtonRes, String command) {
        return createInteractiveTestItem(this, id, titleRes, infoRes,
                new ButtonInfo[] {
                        new ButtonInfo(commandButtonRes, buildCommandIntent(command)),
                        new ButtonInfo(R.string.enterprise_privacy_open_settings,
                               new Intent(Settings.ACTION_ENTERPRISE_PRIVACY_SETTINGS))});
    }

    private TestListItem buildAdminGrantedPermissionTest(String id, int titleRes, int infoRes,
            String permission) {
        return createInteractiveTestItem(this, id, titleRes, infoRes,
                new ButtonInfo[] {
                        new ButtonInfo(R.string.enterprise_privacy_reset, buildCommandIntent(
                                CommandReceiverActivity.COMMAND_SET_PERMISSION_GRANT_STATE)
                                .putExtra(CommandReceiverActivity.EXTRA_PERMISSION, permission)
                                .putExtra(CommandReceiverActivity.EXTRA_GRANT_STATE,
                                        DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT)),
                        new ButtonInfo(R.string.enterprise_privacy_grant, buildCommandIntent(
                                CommandReceiverActivity.COMMAND_SET_PERMISSION_GRANT_STATE)
                                .putExtra(CommandReceiverActivity.EXTRA_PERMISSION, permission)
                                .putExtra(CommandReceiverActivity.EXTRA_GRANT_STATE,
                                        DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED)),
                        new ButtonInfo(R.string.enterprise_privacy_open_settings,
                                new Intent(Settings.ACTION_ENTERPRISE_PRIVACY_SETTINGS))});
    }

    private void addTestsToAdapter(final ArrayTestListAdapter adapter) {
        adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_PAGE,
                R.string.enterprise_privacy_page,
                R.string.enterprise_privacy_page_info,
                new ButtonInfo(R.string.go_button_text, new Intent(Settings.ACTION_SETTINGS))));
        adapter.add(buildCommandTest(ENTERPRISE_PRIVACY_NETWORK_LOGGING,
                R.string.enterprise_privacy_network_logging,
                R.string.enterprise_privacy_network_logging_info,
                R.string.enterprise_privacy_retrieve_network_logs,
                CommandReceiverActivity.COMMAND_RETRIEVE_NETWORK_LOGS));
        adapter.add(buildCommandTest(ENTERPRISE_PRIVACY_BUG_REPORT,
                R.string.enterprise_privacy_bug_report,
                R.string.enterprise_privacy_bug_report_info,
                R.string.enterprise_privacy_request_bug_report,
                CommandReceiverActivity.COMMAND_REQUEST_BUGREPORT));
        adapter.add(buildCommandTest(ENTERPRISE_PRIVACY_SECURITY_LOGGING,
                R.string.enterprise_privacy_security_logging,
                R.string.enterprise_privacy_security_logging_info,
                R.string.enterprise_privacy_retrieve_security_logs,
                CommandReceiverActivity.COMMAND_RETRIEVE_SECURITY_LOGS));
        adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_ENTERPRISE_INSTALLED_APPS,
                R.string.enterprise_privacy_enterprise_installed_apps,
                R.string.enterprise_privacy_enterprise_installed_apps_info,
                new ButtonInfo[] {
                        new ButtonInfo(R.string.enterprise_privacy_install,
                                buildCommandIntent(
                                        CommandReceiverActivity.COMMAND_INSTALL_HELPER_PACKAGE)),
                        new ButtonInfo(R.string.enterprise_privacy_uninstall,
                                buildCommandIntent(CommandReceiverActivity
                                        .COMMAND_UNINSTALL_HELPER_PACKAGE)),
                        new ButtonInfo(R.string.enterprise_privacy_open_settings,
                                new Intent(Settings.ACTION_ENTERPRISE_PRIVACY_SETTINGS))}));
        adapter.add(buildAdminGrantedPermissionTest(ENTERPRISE_PRIVACY_LOCATION_ACCESS,
                R.string.enterprise_privacy_admin_granted_location_access,
                R.string.enterprise_privacy_admin_granted_location_access_info,
                Manifest.permission.ACCESS_FINE_LOCATION));
        adapter.add(buildAdminGrantedPermissionTest(ENTERPRISE_PRIVACY_MICROPHONE_ACCESS,
                R.string.enterprise_privacy_admin_granted_microphone_access,
                R.string.enterprise_privacy_admin_granted_microphone_access_info,
                Manifest.permission.RECORD_AUDIO));
        adapter.add(buildAdminGrantedPermissionTest(ENTERPRISE_PRIVACY_CAMERA_ACCESS,
                R.string.enterprise_privacy_admin_granted_camera_access,
                R.string.enterprise_privacy_admin_granted_camera_access_info,
                Manifest.permission.CAMERA));
        adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_DEFAULT_APPS,
                R.string.enterprise_privacy_default_apps,
                R.string.enterprise_privacy_default_apps_info,
                new ButtonInfo[] {
                        new ButtonInfo(R.string.enterprise_privacy_open_settings,
                                new Intent(Settings.ACTION_ENTERPRISE_PRIVACY_SETTINGS)),
                        new ButtonInfo(R.string.enterprise_privacy_reset, buildCommandIntent(
                                CommandReceiverActivity
                                        .COMMAND_CLEAR_PERSISTENT_PREFERRED_ACTIVITIES)),
                        new ButtonInfo(R.string.enterprise_privacy_set_default_apps,
                                buildCommandIntent(CommandReceiverActivity
                                        .COMMAND_ADD_PERSISTENT_PREFERRED_ACTIVITIES))}));
        adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_DEFAULT_IME,
                R.string.enterprise_privacy_default_ime,
                R.string.enterprise_privacy_default_ime_info,
                new ButtonInfo[] {
                        new ButtonInfo(R.string.enterprise_privacy_open_settings,
                                new Intent(Settings.ACTION_ENTERPRISE_PRIVACY_SETTINGS)),
                        new ButtonInfo(R.string.enterprise_privacy_set_keyboard,
                                buildCommandIntent(CommandReceiverActivity
                                        .COMMAND_SET_DEFAULT_IME)),
                        new ButtonInfo(R.string.enterprise_privacy_finish,
                                buildCommandIntent(CommandReceiverActivity
                                        .COMMAND_CLEAR_DEFAULT_IME))}));
        adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_ALWAYS_ON_VPN,
                R.string.enterprise_privacy_always_on_vpn,
                R.string.enterprise_privacy_always_on_vpn_info,
                new ButtonInfo[] {
                        new ButtonInfo(R.string.enterprise_privacy_open_settings,
                                new Intent(Settings.ACTION_ENTERPRISE_PRIVACY_SETTINGS)),
                        new ButtonInfo(R.string.enterprise_privacy_set_always_on_vpn,
                                buildCommandIntent(
                                        CommandReceiverActivity.COMMAND_SET_ALWAYS_ON_VPN)),
                        new ButtonInfo(R.string.enterprise_privacy_finish,
                                buildCommandIntent(
                                        CommandReceiverActivity.COMMAND_CLEAR_ALWAYS_ON_VPN))}));

        adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_GLOBAL_HTTP_PROXY,
                R.string.enterprise_privacy_global_http_proxy,
                R.string.enterprise_privacy_global_http_proxy_info,
                new ButtonInfo[] {
                        new ButtonInfo(R.string.enterprise_privacy_open_settings,
                                new Intent(Settings.ACTION_ENTERPRISE_PRIVACY_SETTINGS)),
                        new ButtonInfo(R.string.enterprise_privacy_set_proxy,
                                buildCommandIntent(
                                        CommandReceiverActivity.COMMAND_SET_GLOBAL_HTTP_PROXY)),
                        new ButtonInfo(R.string.enterprise_privacy_clear_proxy,
                                buildCommandIntent(CommandReceiverActivity
                                        .COMMAND_CLEAR_GLOBAL_HTTP_PROXY))}));
        adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_CA_CERTS,
                R.string.enterprise_privacy_ca_certs,
                R.string.enterprise_privacy_ca_certs_info,
                new ButtonInfo[] {
                        new ButtonInfo(R.string.enterprise_privacy_open_settings,
                                new Intent(Settings.ACTION_ENTERPRISE_PRIVACY_SETTINGS)),
                        new ButtonInfo(R.string.enterprise_privacy_install_cert,
                                buildCommandIntent(
                                        CommandReceiverActivity.COMMAND_INSTALL_CA_CERT)),
                        new ButtonInfo(R.string.enterprise_privacy_finish,
                                buildCommandIntent(
                                        CommandReceiverActivity.COMMAND_CLEAR_CA_CERT))}));
        if (Utils.isLockscreenSupported(this)) {
            adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_FAILED_PASSWORD_WIPE,
                    R.string.enterprise_privacy_failed_password_wipe,
                    R.string.enterprise_privacy_failed_password_wipe_info,
                    new ButtonInfo[]{
                            new ButtonInfo(R.string.enterprise_privacy_open_settings,
                                    new Intent(Settings.ACTION_ENTERPRISE_PRIVACY_SETTINGS)),
                            new ButtonInfo(R.string.enterprise_privacy_set_limit,
                                    buildCommandIntent(CommandReceiverActivity
                                            .COMMAND_SET_MAXIMUM_PASSWORD_ATTEMPTS)),
                            new ButtonInfo(R.string.enterprise_privacy_finish,
                                    buildCommandIntent(CommandReceiverActivity
                                            .COMMAND_CLEAR_MAXIMUM_PASSWORD_ATTEMPTS))}));
        }
        adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_QUICK_SETTINGS,
                R.string.enterprise_privacy_quick_settings,
                R.string.enterprise_privacy_quick_settings_info,
                new ButtonInfo[] {
                        new ButtonInfo(R.string.enterprise_privacy_clear_organization,
                                buildCommandIntent(
                                        CommandReceiverActivity.COMMAND_SET_ORGANIZATION_NAME)),
                        new ButtonInfo(R.string.enterprise_privacy_set_organization,
                                buildCommandIntent(
                                        CommandReceiverActivity.COMMAND_SET_ORGANIZATION_NAME)
                                        .putExtra(CommandReceiverActivity.EXTRA_ORGANIZATION_NAME,
                                                ""Foo, Inc.""))}));
        if (Utils.isLockscreenSupported(this)) {
            adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_KEYGUARD,
                    R.string.enterprise_privacy_keyguard,
                    R.string.enterprise_privacy_keyguard_info,
                    new ButtonInfo[]{
                            new ButtonInfo(R.string.enterprise_privacy_open_settings,
                                    new Intent(Settings.ACTION_SETTINGS)),
                            new ButtonInfo(R.string.enterprise_privacy_clear_organization,
                                    buildCommandIntent(
                                            CommandReceiverActivity.COMMAND_SET_ORGANIZATION_NAME)),
                            new ButtonInfo(R.string.enterprise_privacy_set_organization,
                                    buildCommandIntent(
                                            CommandReceiverActivity.COMMAND_SET_ORGANIZATION_NAME)
                                            .putExtra(
                                                    CommandReceiverActivity.EXTRA_ORGANIZATION_NAME,
                                                    ""Foo, Inc.""))}));
        }
        adapter.add(createInteractiveTestItem(this, ENTERPRISE_PRIVACY_ADD_ACCOUNT,
                R.string.enterprise_privacy_add_account,
                R.string.enterprise_privacy_add_account_info,
                new ButtonInfo[] {
                        new ButtonInfo(R.string.enterprise_privacy_open_settings,
                                new Intent(Settings.ACTION_ADD_ACCOUNT)),
                        new ButtonInfo(R.string.enterprise_privacy_clear_organization,
                                buildCommandIntent(
                                        CommandReceiverActivity.COMMAND_SET_ORGANIZATION_NAME)),
                        new ButtonInfo(R.string.enterprise_privacy_set_organization,
                                buildCommandIntent(
                                        CommandReceiverActivity.COMMAND_SET_ORGANIZATION_NAME)
                                        .putExtra(CommandReceiverActivity.EXTRA_ORGANIZATION_NAME,
                                                ""Foo, Inc.""))}));
    }

    @Override
    public String getTestId() {
        return getIntent().getStringExtra(EXTRA_TEST_ID);
    }

    @Override
    public void finish() {
        super.finish();
        Intent intent = buildCommandIntent(CommandReceiverActivity.COMMAND_CLEAR_POLICIES)
                .putExtra(PolicyTransparencyTestListActivity.EXTRA_MODE,
                        PolicyTransparencyTestListActivity.MODE_DEVICE_OWNER);
        startActivity(intent);
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"PermissionBroadcastReceiver"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner;

import static android.Manifest.permission.READ_CONTACTS;
import static android.Manifest.permission.WRITE_CONTACTS;
import static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
import static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED;
import static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;
import static android.app.admin.DevicePolicyManager.PERMISSION_POLICY_AUTO_DENY;
import static android.app.admin.DevicePolicyManager.PERMISSION_POLICY_AUTO_GRANT;
import static android.app.admin.DevicePolicyManager.PERMISSION_POLICY_PROMPT;
import static android.content.pm.PackageManager.PERMISSION_DENIED;
import static android.content.pm.PackageManager.PERMISSION_GRANTED;

import android.Manifest.permission;
import android.app.UiAutomation;
import android.app.admin.DevicePolicyManager;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.BySelector;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.UiObject2;
import android.util.Log;

import com.android.cts.devicepolicy.PermissionBroadcastReceiver;
import com.android.cts.devicepolicy.PermissionUtils;

import com.google.android.collect.Sets;

import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Test Runtime Permissions APIs in DevicePolicyManager.
 */
public class PermissionsTest extends BaseDeviceAdminTest {

    private static final String TAG = ""PermissionsTest"";

    private static final String PERMISSION_APP_PACKAGE_NAME = ""com.android.cts.permissionapp"";
    private static final String PRE_M_APP_PACKAGE_NAME
            = ""com.android.cts.launcherapps.simplepremapp"";
    private static final String PERMISSIONS_ACTIVITY_NAME
            = PERMISSION_APP_PACKAGE_NAME + "".PermissionActivity"";
    private static final String CUSTOM_PERM_A_NAME = ""com.android.cts.permissionapp.permA"";
    private static final String CUSTOM_PERM_B_NAME = ""com.android.cts.permissionapp.permB"";
    private static final String DEVELOPMENT_PERMISSION = ""android.permission.INTERACT_ACROSS_USERS"";

    private static final String ACTION_PERMISSION_RESULT
            = ""com.android.cts.permission.action.PERMISSION_RESULT"";

    private static final BySelector CRASH_POPUP_BUTTON_SELECTOR = By
            .clazz(android.widget.Button.class.getName())
            .text(""OK"")
            .pkg(""android"");
    private static final BySelector CRASH_POPUP_TEXT_SELECTOR = By
            .clazz(android.widget.TextView.class.getName())
            .pkg(""android"");
    private static final String CRASH_WATCHER_ID = ""CRASH"";
    private static final String AUTO_GRANTED_PERMISSIONS_CHANNEL_ID =
            ""alerting auto granted permissions"";

    private static final Set<String> LOCATION_PERMISSIONS = Sets.newHashSet(
            permission.ACCESS_FINE_LOCATION,
            permission.ACCESS_BACKGROUND_LOCATION,
            permission.ACCESS_COARSE_LOCATION);

    private static final Set<String> SENSORS_PERMISSIONS = Sets.newHashSet(
            permission.ACCESS_FINE_LOCATION,
            permission.ACCESS_COARSE_LOCATION,
            permission.CAMERA,
            permission.ACTIVITY_RECOGNITION,
            permission.BODY_SENSORS);


    private PermissionBroadcastReceiver mReceiver;
    private UiDevice mDevice;
    private UiAutomation mUiAutomation;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mReceiver = new PermissionBroadcastReceiver();
        mContext.registerReceiver(mReceiver, new IntentFilter(ACTION_PERMISSION_RESULT));
        mDevice = UiDevice.getInstance(getInstrumentation());
        mUiAutomation = getInstrumentation().getUiAutomation();
    }

    @Override
    protected void tearDown() throws Exception {
        mContext.unregisterReceiver(mReceiver);
        mDevice.removeWatcher(CRASH_WATCHER_ID);
        super.tearDown();
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testStateOfSensorsRelatedPermissionsCannotBeRead"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	"public void testStateOfSensorsRelatedPermissionsCannotBeRead() throws Exception {
        for (String sensorPermission : SENSORS_PERMISSIONS) {
            try {
                // The admin tries to grant the permission.
                setPermissionGrantState(sensorPermission, PERMISSION_GRANT_STATE_GRANTED);

                // But the user denies it.
                PermissionUtils.launchActivityAndRequestPermission(mReceiver, mDevice,
                        sensorPermission, PERMISSION_DENIED, PERMISSION_APP_PACKAGE_NAME,
                        PERMISSIONS_ACTIVITY_NAME);

                // And the admin cannot learn of it.
                assertPermissionGrantState(sensorPermission, PERMISSION_GRANT_STATE_DEFAULT);
            } finally {
                revokePermission(sensorPermission);
            }
        }
    }

    private void revokePermission(String sensorPermission) {
        if (LOCATION_PERMISSIONS.contains(sensorPermission)) {
            mUiAutomation.revokeRuntimePermission(PERMISSION_APP_PACKAGE_NAME,
                    permission.ACCESS_FINE_LOCATION);
            mUiAutomation.revokeRuntimePermission(PERMISSION_APP_PACKAGE_NAME,
                    permission.ACCESS_COARSE_LOCATION);
        } else {
            mUiAutomation.revokeRuntimePermission(PERMISSION_APP_PACKAGE_NAME, sensorPermission);
        }
    }

    private void assertFailedToSetPermissionGrantState(String permission, int value) {
        assertTrue(mDevicePolicyManager.setPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, permission, value));
        assertEquals(mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, permission),
                DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT);
        assertEquals(mContext.getPackageManager().checkPermission(permission,
                PERMISSION_APP_PACKAGE_NAME),
                PackageManager.PERMISSION_DENIED);
    }

    private CountDownLatch initPermissionNotificationLatch() {
        CountDownLatch notificationCounterLatch = new CountDownLatch(1);
        NotificationListener.getInstance().addListener((notification) -> {
            if (notification.getPackageName().equals(
                    mContext.getPackageManager().getPermissionControllerPackageName()) &&
                    notification.getNotification().getChannelId().equals(
                            AUTO_GRANTED_PERMISSIONS_CHANNEL_ID)) {
                notificationCounterLatch.countDown();
            }
        });
        return notificationCounterLatch;
    }

    private void setPermissionPolicy(int permissionPolicy) {
        mDevicePolicyManager.setPermissionPolicy(ADMIN_RECEIVER_COMPONENT, permissionPolicy);
    }

    private boolean setPermissionGrantState(String permission, int grantState) {
        return mDevicePolicyManager.setPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, permission, grantState);
    }

    private void unableToSetPermissionGrantState(String permission, int grantState) {
        assertFalse(setPermissionGrantState(permission, grantState));
    }

    private void assertPermissionGrantState(String permission, int grantState) {
        assertEquals(mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, permission), grantState);
    }

    private void assertPermissionPolicy(int permissionPolicy) {
        assertEquals(mDevicePolicyManager.getPermissionPolicy(ADMIN_RECEIVER_COMPONENT),
                permissionPolicy);
    }

    private void assertCanRequestPermissionFromActivity(String permission) throws Exception {
        PermissionUtils.launchActivityAndRequestPermission(
                mReceiver, permission, PERMISSION_GRANTED,
                PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);
    }

    private void assertCannotRequestPermissionFromActivity(String permission) throws Exception {
        PermissionUtils.launchActivityAndRequestPermission(
                mReceiver, permission, PERMISSION_DENIED,
                PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);
    }

    private void assertHasPermissionFromActivity(String permission) throws Exception {
        PermissionUtils.launchActivityAndCheckPermission(
                mReceiver, permission, PERMISSION_GRANTED,
                PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);
    }

    private void assertNoPermissionFromActivity(String permission) throws Exception {
        PermissionUtils.launchActivityAndCheckPermission(
                mReceiver, permission, PERMISSION_DENIED,
                PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.permissionstate.DangerousPermissionStateTests"	"testDangerousPermissionState"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/permissionstate/DangerousPermissionStateTests.java"	""	"public void testDangerousPermissionState() throws Exception {

        final int FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED = 1 << 9;
        final int PROTECTION_FLAG_DANGEROUS = 1;
        final int PROTECTION_FLAG_INSTANT = 0x1000;

        // Set up what to collect
        ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.DANGEROUS_PERMISSION_STATE_FIELD_NUMBER);

        boolean verifiedKnowPermissionState = false;

        // Pull a report
        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        int testAppId = getAppId(DeviceUtils.getStatsdTestAppUid(getDevice()));

        for (AtomsProto.Atom atom : ReportUtils.getGaugeMetricAtoms(getDevice())) {
            AtomsProto.DangerousPermissionState permissionState = atom.getDangerousPermissionState();

            assertThat(permissionState.getPermissionName()).isNotNull();
            assertThat(permissionState.getUid()).isAtLeast(0);
            assertThat(permissionState.getPackageName()).isNotNull();

            if (getAppId(permissionState.getUid()) == testAppId) {

                if (permissionState.getPermissionName().contains(
                        ""ACCESS_FINE_LOCATION"")) {
                    assertThat(permissionState.getIsGranted()).isTrue();
                    assertThat(permissionState.getPermissionFlags() & ~(
                            FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED
                                    | FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED))
                            .isEqualTo(0);
                    assertThat(permissionState.getProtectionFlags()).isEqualTo(
                            PROTECTION_FLAG_DANGEROUS | PROTECTION_FLAG_INSTANT
                    );

                    verifiedKnowPermissionState = true;
                }
            }
        }

        assertThat(verifiedKnowPermissionState).isTrue();
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.util.BaseDefaultPermissionGrantPolicyTest"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/BaseDefaultPermissionGrantPolicyTest.java"	""	"public void testDefaultGrantsWithRemoteExceptions(boolean preGrantsOnly) throws Exception {
        List<PackageInfo> allPackages = getAllPackages();
        Set<String> runtimePermNames = getRuntimePermissionNames(allPackages);
        ArrayMap<String, PackageInfo> packagesToVerify =
                getMsdkTargetingPackagesUsingRuntimePerms(allPackages, runtimePermNames);

        // Ignore CTS infrastructure
        packagesToVerify.remove(""android.tradefed.contentprovider"");

        SparseArray<UidState> pregrantUidStates = new SparseArray<>();

        addDefaultSystemHandlerPermissions(packagesToVerify, pregrantUidStates);

        // Add split permissions that were split from non-runtime permissions
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.Q)) {
            addSplitFromNonDangerousPermissions(packagesToVerify, pregrantUidStates);
        }

        // Add exceptions
        addExceptionsDefaultPermissions(packagesToVerify, runtimePermNames, pregrantUidStates);

        // packageName -> message -> [permission]
        ArrayMap<String, ArrayMap<String, ArraySet<String>>> violations = new ArrayMap();

        // Enforce default grants in the right state
        checkDefaultGrantsInCorrectState(packagesToVerify, pregrantUidStates, violations);

        // Nothing else should have default grants
        checkPackagesForUnexpectedGrants(packagesToVerify, runtimePermNames, violations,
                preGrantsOnly);

        logPregrantUidStates(pregrantUidStates);

        // Bail if we found any violations
        if (!violations.isEmpty()) {
            fail(createViolationsErrorString(violations));
        }
    }


    /**
     * Primarily invoked by business logic, set default permission grant exceptions for this
     * instance of the test class. This is an alternative to downloading the encrypted xml
     * file, a process which is now deprecated.
     *
     * @param pkg         the package name
     * @param sha256      the sha256 cert digest of the package
     * @param permissions the set of permissions, formatted ""permission_name fixed_boolean""
     */
    public void setException(String pkg, String sha256, String... permissions) {
        HashMap<String, Boolean> permissionsMap = new HashMap<>();
        for (String permissionString : permissions) {
            String[] parts = permissionString.trim().split(""\\s+"");
            if (parts.length != 2) {
                Log.e(LOG_TAG, ""Unable to parse remote exception permission: "" + permissionString);
                return;
            }
            permissionsMap.put(parts[0], Boolean.valueOf(parts[1]));
        }
        mRemoteExceptions.add(new DefaultPermissionGrantException(pkg, sha256, permissionsMap));
    }

    /**
     * Primarily invoked by business logic, set default permission grant exceptions for this
     * instance of the test class. Also enables the supply of exception metadata.
     *
     * @param company     the company name
     * @param metadata    the exception metadata
     * @param pkg         the package name
     * @param sha256      the sha256 cert digest of the package
     * @param permissions the set of permissions, formatted ""permission_name fixed_boolean""
     */
    public void setExceptionWithMetadata(String company, String metadata, String pkg,
            String sha256, String... permissions) {
        HashMap<String, Boolean> permissionsMap = new HashMap<>();
        for (String permissionString : permissions) {
            String[] parts = permissionString.trim().split(""\\s+"");
            if (parts.length != 2) {
                Log.e(LOG_TAG, ""Unable to parse remote exception permission: "" + permissionString);
                return;
            }
            permissionsMap.put(parts[0], Boolean.valueOf(parts[1]));
        }
        mRemoteExceptions.add(new DefaultPermissionGrantException(
                company, metadata, pkg, sha256, permissionsMap));
    }

    /**
     * Primarily invoked by business logic, set default permission grant exceptions on CN Gms
     * for this instance of the test class. This is an alternative to downloading the encrypted
     * xml file, a process which is now deprecated.
     *
     * @param pkg         the package name
     * @param sha256      the sha256 cert digest of the package
     * @param permissions the set of permissions, formatted ""permission_name fixed_boolean""
     */
    public void setCNGmsException(String pkg, String sha256, String... permissions) {
        if (!isCnGmsBuild()) {
            Log.e(LOG_TAG, ""Regular GMS build, skip allowlisting: "" + pkg);
            return;
        }
        setException(pkg, sha256, permissions);
    }

    /**
     * Primarily invoked by business logic, set default permission grant exceptions on CN Gms
     * for this instance of the test class. This is an alternative to downloading the encrypted
     * xml file, a process which is now deprecated.
     *
     * @param company     the company name
     * @param metadata    the exception metadata
     * @param pkg         the package name
     * @param sha256      the sha256 cert digest of the package
     * @param permissions the set of permissions, formatted ""permission_name fixed_boolean""
     */
    public void setCNGmsExceptionWithMetadata(String company, String metadata, String pkg,
            String sha256, String... permissions) {
        if (!isCnGmsBuild()) {
            Log.e(LOG_TAG, ""Regular GMS build, skip allowlisting: "" + pkg);
            return;
        }
        setExceptionWithMetadata(company, metadata, pkg, sha256, permissions);
    }


    public List<PackageInfo> getAllPackages() {
        return getInstrumentation().getContext().getPackageManager()
                .getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES
                        | PackageManager.GET_PERMISSIONS | PackageManager.GET_SIGNATURES);
    }

    public static ArrayMap<String, PackageInfo> getMsdkTargetingPackagesUsingRuntimePerms(
            List<PackageInfo> packageInfos, Set<String> runtimePermNames) {
        ArrayMap<String, PackageInfo> packageInfoMap = new ArrayMap<>();

        final int packageInfoCount = packageInfos.size();
        for (int i = 0; i < packageInfoCount; i++) {
            PackageInfo packageInfo = packageInfos.get(i);
            if (packageInfo.requestedPermissions == null) {
                continue;
            }
            if (packageInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.M) {
                continue;
            }
            for (String requestedPermission : packageInfo.requestedPermissions) {
                if (runtimePermNames.contains(requestedPermission)) {
                    packageInfoMap.put(packageInfo.packageName, packageInfo);
                    break;
                }
            }
        }

        return packageInfoMap;
    }

    public static void addViolation(
            Map<String, ArrayMap<String, ArraySet<String>>> violations, String packageName,
            String permission, String message) {
        if (!violations.containsKey(packageName)) {
            violations.put(packageName, new ArrayMap<>());
        }

        if (!violations.get(packageName).containsKey(message)) {
            violations.get(packageName).put(message, new ArraySet<>());
        }

        violations.get(packageName).get(message).add(permission);
    }

    public static boolean isPackageOnSystemImage(PackageInfo packageInfo) {
        return (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
    }


    public static String computePackageCertDigest(Signature signature) {
        MessageDigest messageDigest;
        try {
            messageDigest = MessageDigest.getInstance(""SHA256"");
        } catch (NoSuchAlgorithmException e) {
            /* can't happen */
            return null;
        }

        messageDigest.update(signature.toByteArray());

        final byte[] digest = messageDigest.digest();
        final int digestLength = digest.length;
        final int charCount = 2 * digestLength;

        final char[] chars = new char[charCount];
        for (int i = 0; i < digestLength; i++) {
            final int byteHex = digest[i] & 0xFF;
            chars[i * 2] = HEX_ARRAY[byteHex >>> 4];
            chars[i * 2 + 1] = HEX_ARRAY[byteHex & 0x0F];
        }
        return new String(chars);
    }

    public static ArrayMap<String, Object> getPackageProperties(String packageName) {
        ArrayMap<String, Object> properties = new ArrayMap();

        PackageManager pm = getInstrumentation().getContext().getPackageManager();
        PackageInfo info = null;
        try {
            info = pm.getPackageInfo(packageName,
                    PackageManager.GET_UNINSTALLED_PACKAGES | PackageManager.GET_SIGNATURES);
        } catch (PackageManager.NameNotFoundException ignored) {
        }

        properties.put(""targetSDK"", info.applicationInfo.targetSdkVersion);
        properties.put(""signature"", computePackageCertDigest(info.signatures[0]).toUpperCase());
        properties.put(""uid"", UserHandle.getAppId(info.applicationInfo.uid));
        properties.put(""priv app"", info.applicationInfo.isPrivilegedApp());
        properties.put(""persistent"", ((info.applicationInfo.flags
                & ApplicationInfo.FLAG_PERSISTENT) != 0) + ""\n"");
        properties.put(""has platform signature"", (pm.checkSignatures(info.packageName,
                PLATFORM_PACKAGE_NAME) == PackageManager.SIGNATURE_MATCH));
        properties.put(""on system image"", isPackageOnSystemImage(info));

        return properties;
    }


    public void addException(DefaultPermissionGrantException exception,
            Set<String> runtimePermNames, Map<String, PackageInfo> packageInfos,
            SparseArray<UidState> outUidStates) {
        Log.v(LOG_TAG, ""Adding exception for company "" + exception.company
                + "". Metadata: "" + exception.metadata);
        String packageName = exception.pkg;
        PackageInfo packageInfo = packageInfos.get(packageName);
        if (packageInfo == null) {
            Log.v(LOG_TAG, ""Trying to add exception to missing package:"" + packageName);

            try {
                // Do not overwhelm logging
                Thread.sleep(10);
            } catch (InterruptedException ignored) {
            }
            return;
        }
        if (!packageInfo.applicationInfo.isSystemApp()) {
            if (isCnBuild() && exception.hasNonBrandSha256()) {
                // Due to CN app removability requirement, allow non-system app pregrant exceptions,
                // as long as they specify a hash (b/121209050)
            } else {
                Log.w(LOG_TAG, ""Cannot pregrant permissions to non-system package:"" + packageName);
                return;
            }
        }
        // If cert SHA-256 digest is specified it is used for verification, for user builds only
        if (exception.hasNonBrandSha256()) {
            String expectedDigest = exception.sha256.replace("":"", """").toLowerCase();
            String packageDigest = computePackageCertDigest(packageInfo.signatures[0]);
            if (PropertyUtil.isUserBuild() && !expectedDigest.equalsIgnoreCase(packageDigest)) {
                Log.w(LOG_TAG, ""SHA256 cert digest does not match for package: "" + packageName
                        + "". Expected: "" + expectedDigest.toUpperCase() + "", observed: ""
                        + packageDigest.toUpperCase());
                return;
            }
        } else if (exception.hasBrand) {
            // Rare case -- exception.sha256 is actually brand name, verify brand instead
            String expectedBrand = exception.sha256;
            String actualBrand = PropertyUtil.getProperty(BRAND_PROPERTY);
            if (!expectedBrand.equalsIgnoreCase(actualBrand)) {
                Log.w(LOG_TAG, String.format(""Brand %s does not match for package: %s"",
                        expectedBrand, packageName));
                return;
            }
        } else {
            Log.w(LOG_TAG, ""Attribute sha256-cert-digest or brand must be provided for package: ""
                    + packageName);
            return;
        }

        List<String> requestedPermissions = Arrays.asList(packageInfo.requestedPermissions);
        for (Map.Entry<String, Boolean> entry : exception.permissions.entrySet()) {
            String permission = entry.getKey();
            Boolean fixed = entry.getValue();
            if (!requestedPermissions.contains(permission)) {
                Log.w(LOG_TAG, ""Permission "" + permission + "" not requested by: "" + packageName);
                continue;
            }
            if (!runtimePermNames.contains(permission)) {
                Log.w(LOG_TAG, ""Permission:"" + permission + "" in not runtime"");
                continue;
            }
            final int uid = packageInfo.applicationInfo.uid;
            UidState uidState = outUidStates.get(uid);
            if (uidState == null) {
                uidState = new UidState();
                outUidStates.put(uid, uidState);
            }

            for (String extendedPerm : extendBySplitPermissions(permission,
                    packageInfo.applicationInfo.targetSdkVersion)) {
                uidState.overrideGrantedPermission(packageInfo.packageName,
                        permission.equals(extendedPerm) ? ""exception""
                                : ""exception (split from "" + permission + "")"", extendedPerm, fixed);
            }
        }
    }


    public static ArrayList<String> extendBySplitPermissions(String permission, int appTargetSdk) {
        ArrayList<String> extendedPermissions = new ArrayList<>();
        extendedPermissions.add(permission);

        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.Q)) {
            Context context = getInstrumentation().getTargetContext();
            PermissionManager permissionManager = context.getSystemService(PermissionManager.class);

            for (PermissionManager.SplitPermissionInfo splitPerm :
                    permissionManager.getSplitPermissions()) {
                if (splitPerm.getSplitPermission().equals(permission)
                        && splitPerm.getTargetSdk() > appTargetSdk) {
                    extendedPermissions.addAll(splitPerm.getNewPermissions());
                }
            }
        }

        return extendedPermissions;
    }


    public void setPermissionGrantState(String packageName, String permission,
            boolean granted) {
        try {
            if (granted) {
                getInstrumentation().getUiAutomation().grantRuntimePermission(packageName,
                        permission, android.os.Process.myUserHandle());
            } else {
                getInstrumentation().getUiAutomation().revokeRuntimePermission(packageName,
                        permission, android.os.Process.myUserHandle());
            }
        } catch (Exception e) {
            /* do nothing - best effort */
        }
    }

    public void addExceptionsDefaultPermissions(Map<String, PackageInfo> packageInfos,
            Set<String> runtimePermNames,
            SparseArray<UidState> outUidStates) throws Exception {
        // Only use exceptions from business logic if they've been added
        if (!mRemoteExceptions.isEmpty()) {
            Log.d(LOG_TAG, String.format(""Found %d remote exceptions"", mRemoteExceptions.size()));
            for (DefaultPermissionGrantException dpge : mRemoteExceptions) {
                addException(dpge, runtimePermNames, packageInfos, outUidStates);
            }
        } else {
            Log.w(LOG_TAG, ""Failed to retrieve remote default permission grant exceptions."");
        }
    }


    // Permissions split from non dangerous permissions
    private void addSplitFromNonDangerousPermissions(Map<String, PackageInfo> packageInfos,
            SparseArray<UidState> outUidStates) {
        Context context = getInstrumentation().getTargetContext();

        for (PackageInfo pkg : packageInfos.values()) {
            int targetSdk = pkg.applicationInfo.targetSandboxVersion;
            int uid = pkg.applicationInfo.uid;

            for (String permission : pkg.requestedPermissions) {
                PermissionInfo permInfo;
                try {
                    permInfo = context.getPackageManager().getPermissionInfo(permission, 0);
                } catch (PackageManager.NameNotFoundException ignored) {
                    // ignore permissions that are requested but not defined
                    continue;
                }


                // Permissions split from dangerous permission are granted when the original
                // permission permission is granted;
                if ((permInfo.getProtection() & PROTECTION_DANGEROUS) != 0) {
                    continue;
                }

                for (String extendedPerm : extendBySplitPermissions(permission, targetSdk)) {
                    if (!isSplitPermissionNameViolation(extendedPerm)) {
                        continue;
                    }

                    if (!extendedPerm.equals(permission)) {
                        UidState uidState = outUidStates.get(uid);

                        if (uidState != null
                                && uidState.grantedPermissions.containsKey(extendedPerm)) {
                            // permission is already granted. Don't override the grant-state.
                            continue;
                        }

                        appendPackagePregrantedPerms(pkg, ""split from non-dangerous permission ""
                                        + permission, false, Collections.singleton(extendedPerm),
                                outUidStates);
                    }
                }
            }
        }
    }

    public static void appendPackagePregrantedPerms(PackageInfo packageInfo, String reason,
            boolean fixed, Set<String> pregrantedPerms, SparseArray<UidState> outUidStates) {
        final int uid = packageInfo.applicationInfo.uid;
        UidState uidState = outUidStates.get(uid);
        if (uidState == null) {
            uidState = new UidState();
            outUidStates.put(uid, uidState);
        }
        for (String requestedPermission : packageInfo.requestedPermissions) {
            if (pregrantedPerms.contains(requestedPermission)) {
                uidState.addGrantedPermission(packageInfo.packageName, reason, requestedPermission,
                        fixed);
            }
        }
    }

    public void logPregrantUidStates(SparseArray<UidState> pregrantUidStates) {
        Log.i(LOG_TAG, ""PREGRANT UID STATES"");
        for (int i = 0; i < pregrantUidStates.size(); i++) {
            Log.i(LOG_TAG, ""uid: "" + pregrantUidStates.keyAt(i) + "" {"");
            pregrantUidStates.valueAt(i).log();
            Log.i(LOG_TAG, ""}"");
        }
    }

    public void checkDefaultGrantsInCorrectState(Map<String, PackageInfo> packagesToVerify,
            SparseArray<UidState> pregrantUidStates,
            Map<String, ArrayMap<String, ArraySet<String>>> violations) {
        PackageManager packageManager = getInstrumentation().getContext().getPackageManager();
        for (PackageInfo packageInfo : packagesToVerify.values()) {
            final int uid = packageInfo.applicationInfo.uid;
            UidState uidState = pregrantUidStates.get(uid);
            if (uidState == null) {
                continue;
            }

            final int grantCount = uidState.grantedPermissions.size();
            // make a modifiable list
            List<String> requestedPermissions = new ArrayList<>(
                    Arrays.asList(packageInfo.requestedPermissions));
            for (int i = 0; i < grantCount; i++) {
                String permission = uidState.grantedPermissions.keyAt(i);

                // If the package did not request this permissions, skip as
                // it is requested by another package in the same UID.
                if (!requestedPermissions.contains(permission)) {
                    continue;
                }

                // Not granting the permission is OK, as we want to catch excessive grants
                if (packageManager.checkPermission(permission, packageInfo.packageName)
                        != PackageManager.PERMISSION_GRANTED) {
                    continue;
                }

                boolean grantBackFineLocation = false;

                // Special case: fine location implies coarse location, so we revoke
                // fine location when verifying coarse to avoid interference.
                if (permission.equals(Manifest.permission.ACCESS_COARSE_LOCATION)
                        && packageManager.checkPermission(Manifest.permission.ACCESS_FINE_LOCATION,
                        packageInfo.packageName) == PackageManager.PERMISSION_GRANTED) {
                    setPermissionGrantState(packageInfo.packageName,
                            Manifest.permission.ACCESS_FINE_LOCATION, false);
                    grantBackFineLocation = true;
                }

                setPermissionGrantState(packageInfo.packageName, permission, false);

                Boolean fixed = uidState.grantedPermissions.valueAt(i);

                // Weaker grant is fine, e.g. not-fixed instead of fixed.
                if (!fixed && packageManager.checkPermission(permission, packageInfo.packageName)
                        == PackageManager.PERMISSION_GRANTED) {
                    addViolation(violations, packageInfo.packageName, permission,
                            ""granted by default should be revocable"");
                }

                setPermissionGrantState(packageInfo.packageName, permission, true);

                if (grantBackFineLocation) {
                    setPermissionGrantState(packageInfo.packageName,
                            Manifest.permission.ACCESS_FINE_LOCATION, true);
                }

                // Now a small trick - pretend the package does not request this permission
                // as we will later treat each granted runtime permissions as a violation.
                requestedPermissions.remove(permission);
                packageInfo.requestedPermissions = requestedPermissions.toArray(
                        new String[requestedPermissions.size()]);
            }
        }
    }

    public void checkPackagesForUnexpectedGrants(Map<String, PackageInfo> packagesToVerify,
            Set<String> runtimePermNames,
            Map<String, ArrayMap<String, ArraySet<String>>> violations,
            boolean preGrantsOnly) throws Exception {
        PackageManager packageManager = getInstrumentation().getContext().getPackageManager();
        for (PackageInfo packageInfo : packagesToVerify.values()) {
            for (String requestedPermission : packageInfo.requestedPermissions) {
                // If another package in the UID can get the permission
                // then it is fine for this package to have it - skip.
                if (runtimePermNames.contains(requestedPermission)
                        && packageManager.checkPermission(requestedPermission,
                        packageInfo.packageName) == PackageManager.PERMISSION_GRANTED
                        && (!preGrantsOnly || (callWithShellPermissionIdentity(() ->
                        packageManager.getPermissionFlags(
                                requestedPermission,
                                packageInfo.packageName,
                                getInstrumentation().getTargetContext().getUser())
                                & PackageManager.FLAG_PERMISSION_GRANTED_BY_DEFAULT)
                        != 0))) {
                    addViolation(violations,
                            packageInfo.packageName, requestedPermission,
                            ""cannot be granted by default to package"");
                }
            }
        }
    }

    public String createViolationsErrorString(
            ArrayMap<String, ArrayMap<String, ArraySet<String>>> violations) {
        StringBuilder sb = new StringBuilder();

        for (String packageName : violations.keySet()) {
            sb.append(""packageName: "" + packageName + "" {\n"");
            for (Map.Entry<String, Object> property
                    : getPackageProperties(packageName).entrySet()) {
                sb.append(""  "" + property.getKey() + "": ""
                        + property.getValue().toString().trim() + ""\n"");
            }
            for (String message : violations.get(packageName).keySet()) {
                sb.append(""  message: "" + message + "" {\n"");
                for (String permission : violations.get(packageName).get(message)) {
                    sb.append(""    permission: "" + permission + ""\n"");
                }
                sb.append(""  }\n"");
            }
            sb.append(""}\n"");
        }

        return sb.toString();
    }

    public static class UidState {
        public class GrantReason {
            public final String reason;
            public final boolean override;
            public final Boolean fixed;

            GrantReason(String reason, boolean override, Boolean fixed) {
                this.reason = reason;
                this.override = override;
                this.fixed = fixed;
            }

            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                GrantReason that = (GrantReason) o;
                return override == that.override
                        && Objects.equals(reason, that.reason)
                        && Objects.equals(fixed, that.fixed);
            }

            @Override
            public int hashCode() {
                return Objects.hash(reason, override, fixed);
            }
        }

        // packageName -> permission -> [reason]
        public ArrayMap<String, ArrayMap<String, ArraySet<GrantReason>>> mGrantReasons =
                new ArrayMap<>();
        public ArrayMap<String, Boolean> grantedPermissions = new ArrayMap<>();

        public void log() {
            for (String packageName : mGrantReasons.keySet()) {
                Log.i(LOG_TAG, ""  packageName: "" + packageName + "" {"");

                for (Map.Entry<String, Object> property :
                        getPackageProperties(packageName).entrySet()) {
                    Log.i(LOG_TAG, ""    "" + property.getKey() + "": "" + property.getValue());
                }

                // Resort permission -> reason into reason -> permission
                ArrayMap<String, ArraySet<GrantReason>> permissionsToReasons =
                        mGrantReasons.get(packageName);
                ArrayMap<GrantReason, List<String>> reasonsToPermissions = new ArrayMap<>();
                for (String permission : permissionsToReasons.keySet()) {
                    for (GrantReason reason : permissionsToReasons.get(permission)) {
                        if (!reasonsToPermissions.containsKey(reason)) {
                            reasonsToPermissions.put(reason, new ArrayList<>());
                        }

                        reasonsToPermissions.get(reason).add(permission);
                    }
                }

                for (Map.Entry<GrantReason, List<String>> reasonEntry
                        : reasonsToPermissions.entrySet()) {
                    GrantReason reason = reasonEntry.getKey();
                    Log.i(LOG_TAG, ""    reason: "" + reason.reason + "" {"");
                    Log.i(LOG_TAG, ""      override: "" + reason.override);
                    Log.i(LOG_TAG, ""      fixed: "" + reason.fixed);

                    Log.i(LOG_TAG, ""      permissions: ["");
                    for (String permission : reasonEntry.getValue()) {
                        Log.i(LOG_TAG, ""        "" + permission + "","");
                    }
                    Log.i(LOG_TAG, ""      ]"");
                    Log.i(LOG_TAG, ""    }"");

                    // Do not overwhelm log
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        // ignored
                    }
                }

                Log.i(LOG_TAG, ""  }"");
            }
        }

        public void addGrantedPermission(String packageName, String reason, String permission,
                Boolean fixed) {
            Context context = getInstrumentation().getTargetContext();

            // Add permissions split off from the permission to granted
            try {
                PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
                int targetSdk = info.applicationInfo.targetSdkVersion;

                for (String extendedPerm : extendBySplitPermissions(permission, targetSdk)) {
                    mergeGrantedPermission(packageName, extendedPerm.equals(permission) ? reason
                                    : reason + "" (split from "" + permission + "")"", extendedPerm,
                            fixed, false);
                }
            } catch (PackageManager.NameNotFoundException e) {
                // ignore
            }
        }

        public void overrideGrantedPermission(String packageName, String reason, String permission,
                Boolean fixed) {
            mergeGrantedPermission(packageName, reason, permission, fixed, true);
        }

        public void mergeGrantedPermission(String packageName, String reason, String permission,
                Boolean fixed, boolean override) {
            if (!mGrantReasons.containsKey(packageName)) {
                mGrantReasons.put(packageName, new ArrayMap<>());
            }

            if (!mGrantReasons.get(packageName).containsKey(permission)) {
                mGrantReasons.get(packageName).put(permission, new ArraySet<>());
            }

            mGrantReasons.get(packageName).get(permission).add(new GrantReason(reason, override,
                    fixed));

            Boolean oldFixed = grantedPermissions.get(permission);
            if (oldFixed == null) {
                grantedPermissions.put(permission, fixed);
            } else {
                if (override) {
                    if (oldFixed == Boolean.FALSE && fixed == Boolean.TRUE) {
                        Log.w(LOG_TAG, ""override already granted permission "" + permission + ""(""
                                + fixed + "") for "" + packageName);
                        grantedPermissions.put(permission, fixed);
                    }
                } else {
                    if (oldFixed == Boolean.TRUE && fixed == Boolean.FALSE) {
                        Log.w(LOG_TAG, ""add already granted permission "" + permission + ""(""
                                + fixed + "") to "" + packageName);
                        grantedPermissions.put(permission, fixed);
                    }
                }
            }
        }
    }

    public static class DefaultPermissionGrantException {

        public static final String UNSET_PLACEHOLDER = ""(UNSET)"";
        public String company;
        public String metadata;
        public String pkg;
        public String sha256;
        public boolean hasBrand; // in rare cases, brand will be specified instead of SHA256 hash
        public Map<String, Boolean> permissions = new HashMap<>();

        public boolean hasNonBrandSha256() {
            return sha256 != null && !hasBrand;
        }

        public DefaultPermissionGrantException(String pkg, String sha256,
                Map<String, Boolean> permissions) {
            this(UNSET_PLACEHOLDER, UNSET_PLACEHOLDER, pkg, sha256, permissions);
        }

        public DefaultPermissionGrantException(String company, String metadata, String pkg,
                String sha256,
                Map<String, Boolean> permissions) {
            this.company = company;
            this.metadata = metadata;
            this.pkg = pkg;
            this.sha256 = sha256;
            if (!sha256.contains("":"")) {
                hasBrand = true; // rough approximation of brand vs. SHA256 hash
            }
            this.permissions = permissions;
        }
    }

}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.OneTimePermissionTest"	"testStickyServiceMaintainsPermissionOnRestart"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/OneTimePermissionTest.java"	""	"public void testStickyServiceMaintainsPermissionOnRestart() throws Throwable {
        startApp();

        clickOneTimeButton();

        startAppForegroundService(2 * ONE_TIME_TIMEOUT_MILLIS, true);

        exitApp();

        assertGranted(5000);
        mUiDevice.waitForIdle();
        Thread.sleep(ONE_TIME_TIMEOUT_MILLIS);

        runShellCommand(""am crash "" + APP_PKG_NAME);

        eventually(() -> runWithShellPermissionIdentity(() -> {
            if (mActivityManager.getPackageImportance(APP_PKG_NAME) <= IMPORTANCE_CACHED) {
                throw new AssertionError(""App was never killed"");
            }
        }));

        eventually(() -> runWithShellPermissionIdentity(() -> {
            if (mActivityManager.getPackageImportance(APP_PKG_NAME)
                    > IMPORTANCE_FOREGROUND_SERVICE) {
                throw new AssertionError(""Foreground service never resumed"");
            }
            Assert.assertEquals(""Service resumed without permission"",
                    PackageManager.PERMISSION_GRANTED, mContext.getPackageManager()
                            .checkPermission(ACCESS_FINE_LOCATION, APP_PKG_NAME));
        }));
    }

    private void assertGrantedState(String s, int permissionGranted, long timeoutMillis) {
        eventually(() -> Assert.assertEquals(s,
                permissionGranted, mContext.getPackageManager()
                        .checkPermission(ACCESS_FINE_LOCATION, APP_PKG_NAME)), timeoutMillis);
    }

    private void assertGranted(long timeoutMillis) {
        assertGrantedState(""Permission was never granted"", PackageManager.PERMISSION_GRANTED,
                timeoutMillis);
    }

    private void assertDenied(long timeoutMillis) {
        assertGrantedState(""Permission was never revoked"", PackageManager.PERMISSION_DENIED,
                timeoutMillis);
    }

    private void assertExpectedLifespan(CompletableFuture<Long> exitTime, long expectedLifespan)
            throws InterruptedException, java.util.concurrent.ExecutionException,
            java.util.concurrent.TimeoutException {
        long grantedLength = System.currentTimeMillis() - exitTime.get(0, TimeUnit.MILLISECONDS);
        if (grantedLength + ONE_TIME_TIMER_LOWER_GRACE_PERIOD < expectedLifespan) {
            throw new AssertionError(
                    ""The one time permission lived shorter than expected. expected: ""
                            + expectedLifespan + ""ms but was: "" + grantedLength + ""ms"");
        }
    }

    private void exitApp() {
        boolean[] hasExited = {false};
        try {
            new Thread(() -> {
                while (!hasExited[0]) {
                    mUiDevice.pressHome();
                    mUiDevice.pressBack();
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                    }
                }
            }).start();
            eventually(() -> {
                runWithShellPermissionIdentity(() -> {
                    if (mActivityManager.getPackageImportance(APP_PKG_NAME)
                            <= IMPORTANCE_FOREGROUND) {
                        throw new AssertionError(""Unable to exit application"");
                    }
                });
            });
        } finally {
            hasExited[0] = true;
        }
    }

    private void clickOneTimeButton() throws Throwable {
        final UiObject2 uiObject = UiAutomatorUtils.waitFindObject(By.res(
                ""com.android.permissioncontroller:id/permission_allow_one_time_button""), 10000);
        Thread.sleep(500);
        uiObject.click();
    }

    /**
     * Start the app. The app will request the permissions.
     */
    private void startApp() {
        Intent startApp = new Intent();
        startApp.setComponent(new ComponentName(APP_PKG_NAME, APP_PKG_NAME + "".RequestPermission""));
        startApp.setFlags(FLAG_ACTIVITY_NEW_TASK);

        mContext.startActivity(startApp);
    }

    private void startAppForegroundService(long lifespanMillis, boolean sticky) {
        Intent intent = new Intent()
                .setComponent(new ComponentName(
                APP_PKG_NAME, APP_PKG_NAME + "".KeepAliveForegroundService""))
                .putExtra(EXTRA_FOREGROUND_SERVICE_LIFESPAN, lifespanMillis)
                .putExtra(EXTRA_FOREGROUND_SERVICE_STICKY, sticky);
        mContext.startService(intent);
    }

    private CompletableFuture<Long> registerAppExitListener() {
        CompletableFuture<Long> exitTimeCallback = new CompletableFuture<>();
        try {
            int uid = mContext.getPackageManager().getPackageUid(APP_PKG_NAME, 0);
            runWithShellPermissionIdentity(() ->
                    mActivityManager.addOnUidImportanceListener(new SingleAppExitListener(
                            uid, IMPORTANCE_FOREGROUND, exitTimeCallback), IMPORTANCE_FOREGROUND));
        } catch (PackageManager.NameNotFoundException e) {
            throw new AssertionError(""Package not found."", e);
        }
        return exitTimeCallback;
    }

    private class SingleAppExitListener implements ActivityManager.OnUidImportanceListener {

        private final int mUid;
        private final int mImportance;
        private final CompletableFuture<Long> mCallback;

        SingleAppExitListener(int uid, int importance, CompletableFuture<Long> callback) {
            mUid = uid;
            mImportance = importance;
            mCallback = callback;
        }

        @Override
        public void onUidImportance(int uid, int importance) {
            if (uid == mUid && importance > mImportance) {
                mCallback.complete(System.currentTimeMillis());
                mActivityManager.removeOnUidImportanceListener(this);
            }
        }
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsPublishWithAuthorizedErrorResponse"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	"public void testRcsPublishWithAuthorizedErrorResponse() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Trigger carrier config change
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot get the ImsManager"");
        }
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to the ImsService
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        final UiAutomation automation = InstrumentationRegistry.getInstrumentation()
                .getUiAutomation();
        try {
            automation.adoptShellPermissionIdentity();
            uceAdapter.addOnPublishStateChangedListener(getContext().getMainExecutor(),
                    publishStateCallback);
            // Verify receiving the publish state callback after registering the callback.
            assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                    waitForIntResult(publishStateQueue));
        } finally {
            publishStateQueue.clear();
            automation.dropShellPermissionIdentity();
        }

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Setup the response of the publish request.
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 200;
            String reason = ""OK"";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // IMS registers
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);

        // Notify framework that the RCS capability status is changed and PRESENCE UCE is enabled.
        RcsImsCapabilities capabilities =
                new RcsImsCapabilities(RcsUceAdapter.CAPABILITY_TYPE_PRESENCE_UCE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(capabilities);

        CapabilityExchangeEventListener eventListener =
                sServiceConnector.getCarrierService().getRcsFeature().getEventListener();

        // Notify framework to send the PUBLISH request to the ImsService.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        // Verify ImsService receive the publish request from framework.
        assertTrue(sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_UCE_REQUEST_PUBLISH));

        try {
            // Verify the publish state callback is received.
            assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, waitForIntResult(publishStateQueue));
            // Verify the value of getting from the API is PUBLISH_STATE_OK
            automation.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_OK, publishState);
        } finally {
            publishStateQueue.clear();
            automation.dropShellPermissionIdentity();
        }

        // Reply the SIP code 403 FORBIDDEN
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 403;
            String reason = ""FORBIDDEN"";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // Notify framework to send the PUBLISH request to the ImsService.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        try {
            // Verify the publish state callback is received.
            assertEquals(RcsUceAdapter.PUBLISH_STATE_RCS_PROVISION_ERROR,
                    waitForIntResult(publishStateQueue));
            // Verify the value of getting from the API is PUBLISH_STATE_RCS_PROVISION_ERROR
            automation.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_RCS_PROVISION_ERROR, publishState);
        } finally {
            publishStateQueue.clear();
            automation.dropShellPermissionIdentity();
        }

        LinkedBlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMilliseconds);
            }
        };

        capExchangeImpl.setSubscribeOperation((uris, cb) -> {
            fail(""Should not received the SUBSCRIBE request"");
        });

        Collection<Uri> contacts = Collections.singletonList(
                Uri.fromParts(PhoneAccount.SCHEME_SIP, ""test"", null));

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestCapabilities(contacts, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE. ""
                    + ""Exception: "" + e);
        } catch (ImsException e) {
            fail(""requestCapabilities failed "" + e);
        }

        // Verify the capability request should fail
        try {
            assertEquals(RcsUceAdapter.ERROR_NOT_AUTHORIZED, waitForIntResult(errorQueue));
            assertEquals(Long.valueOf(0L), waitForResult(errorRetryQueue));
        } catch (Exception e) {
            fail(""requestCapabilities with command error failed: "" + e);
        } finally {
            errorQueue.clear();
            errorRetryQueue.clear();
        }

        // Reset the UCE device state
        try {
            sServiceConnector.removeUceRequestDisallowedStatus(sTestSlot);
        } catch (Exception e) {
            fail(""Cannot remove request disallowed status: "" + e);
        }

        // Reply the SIP code 404 NOT FOUND
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 404;
            String reason = ""NOT FOUND"";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // Notify framework to send the PUBLISH request to the ImsService.
        eventListener.onRequestPublishCapabilities(
                RcsUceAdapter.CAPABILITY_UPDATE_TRIGGER_MOVE_TO_WLAN);

        try {
            // Verify the value of getting from the API is PUBLISH_STATE_RCS_PROVISION_ERROR
            automation.adoptShellPermissionIdentity();
            int publishState = uceAdapter.getUcePublishState();
            assertEquals(RcsUceAdapter.PUBLISH_STATE_RCS_PROVISION_ERROR, publishState);
        } finally {
            publishStateQueue.clear();
            automation.dropShellPermissionIdentity();
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestCapabilities(contacts, Runnable::run, callback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE. ""
                    + ""Exception: "" + e);
        } catch (ImsException e) {
            fail(""requestCapabilities failed "" + e);
        }

        // Reset the UCE device state
        try {
            sServiceConnector.removeUceRequestDisallowedStatus(sTestSlot);
        } catch (Exception e) {
            fail(""Cannot remove request disallowed status: "" + e);
        }

        overrideCarrierConfig(null);
    }"	""	""	"android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.PermissionControllerTest"	"OnRevokeRuntimePermissionsCallback"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PermissionControllerTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_COARSE_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.Manifest.permission.BODY_SENSORS;
import static android.Manifest.permission.READ_CALENDAR;
import static android.Manifest.permission.READ_CONTACTS;
import static android.Manifest.permission.WRITE_CALENDAR;
import static android.app.AppOpsManager.MODE_ALLOWED;
import static android.app.AppOpsManager.MODE_FOREGROUND;
import static android.app.AppOpsManager.permissionToOp;
import static android.content.pm.PackageManager.PERMISSION_DENIED;
import static android.permission.PermissionControllerManager.COUNT_ONLY_WHEN_GRANTED;
import static android.permission.PermissionControllerManager.REASON_INSTALLER_POLICY_VIOLATION;
import static android.permission.PermissionControllerManager.REASON_MALWARE;
import static android.permission.cts.PermissionUtils.grantPermission;
import static android.permission.cts.PermissionUtils.isGranted;
import static android.permission.cts.PermissionUtils.isPermissionGranted;

import static com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity;
import static com.android.compatibility.common.util.SystemUtil.eventually;
import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static com.google.common.truth.Truth.assertThat;

import static java.util.Collections.singletonList;

import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.content.Context;
import android.content.pm.PermissionGroupInfo;
import android.permission.PermissionControllerManager;
import android.permission.RuntimePermissionPresentationInfo;
import android.platform.test.annotations.AppModeFull;

import androidx.annotation.NonNull;
import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Test {@link PermissionControllerManager}
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot talk to permission controller"")
public class PermissionControllerTest {
    private static final String APK =
            ""/data/local/tmp/cts/permissions/CtsAppThatAccessesLocationOnCommand.apk"";
    private static final String APP = ""android.permission.cts.appthataccesseslocation"";
    private static final String APK2 =
            ""/data/local/tmp/cts/permissions/""
                    + ""CtsAppThatRequestsCalendarContactsBodySensorCustomPermission.apk"";
    private static final String APP2 = ""android.permission.cts.appthatrequestcustompermission"";
    private static final String CUSTOM_PERMISSION =
            ""android.permission.cts.appthatrequestcustompermission.TEST_PERMISSION"";

    private static final UiAutomation sUiAutomation =
            InstrumentationRegistry.getInstrumentation().getUiAutomation();
    private static final Context sContext = InstrumentationRegistry.getTargetContext();
    private static final PermissionControllerManager sController =
            sContext.getSystemService(PermissionControllerManager.class);

    @Before
    @After
    public void resetAppState() {
        runWithShellPermissionIdentity(() -> {
            sUiAutomation.grantRuntimePermission(APP, ACCESS_FINE_LOCATION);
            sUiAutomation.grantRuntimePermission(APP, ACCESS_BACKGROUND_LOCATION);
            setAppOp(APP, ACCESS_FINE_LOCATION, MODE_ALLOWED);
        });
    }

    @BeforeClass
    public static void installApp() {
        runShellCommand(""pm install -r -g "" + APK);
        runShellCommand(""pm install -r "" + APK2);
    }

    @AfterClass
    public static void uninstallApp() {
        runShellCommand(""pm uninstall "" + APP);
        runShellCommand(""pm uninstall "" + APP2);
    }

    private @NonNull Map<String, List<String>> revokePermissions(
            @NonNull Map<String, List<String>> request, boolean doDryRun, int reason,
            @NonNull Executor executor) throws Exception {
        AtomicReference<Map<String, List<String>>> result = new AtomicReference<>();

        sController.revokeRuntimePermissions(request, doDryRun, reason, executor,
                new PermissionControllerManager.OnRevokeRuntimePermissionsCallback() {
                    @Override
                    public void onRevokeRuntimePermissions(@NonNull Map<String, List<String>> r) {
                        synchronized (result) {
                            result.set(r);
                            result.notifyAll();
                        }
                    }
                });

        synchronized (result) {
            while (result.get() == null) {
                result.wait();
            }
        }

        return result.get();
    }

    private @NonNull Map<String, List<String>> revokePermissions(
            @NonNull Map<String, List<String>> request, boolean doDryRun, boolean adoptShell)
            throws Exception {
        if (adoptShell) {
            Map<String, List<String>> revokeRet =
                    callWithShellPermissionIdentity(() -> revokePermissions(
                            request, doDryRun, REASON_MALWARE, sContext.getMainExecutor()));
            return revokeRet;
        }
        return revokePermissions(request, doDryRun, REASON_MALWARE, sContext.getMainExecutor());
    }

    private @NonNull Map<String, List<String>> revokePermissions(
            @NonNull Map<String, List<String>> request, boolean doDryRun) throws Exception {
        return revokePermissions(request, doDryRun, true);
    }

    private void setAppOp(@NonNull String pkg, @NonNull String perm, int mode) throws Exception {
        sContext.getSystemService(AppOpsManager.class).setUidMode(permissionToOp(perm),
                sContext.getPackageManager().getPackageUid(pkg, 0), mode);
    }

    private Map<String, List<String>> buildRevokeRequest(@NonNull String app,
            @NonNull String permission) {
        return Collections.singletonMap(app, singletonList(permission));
    }

    private void assertRuntimePermissionLabelsAreValid(List<String> runtimePermissions,
            List<RuntimePermissionPresentationInfo> permissionInfos, int expectedRuntimeGranted,
            String app) throws Exception {
        int numRuntimeGranted = 0;
        for (String permission : runtimePermissions) {
            if (isPermissionGranted(app, permission)) {
                numRuntimeGranted++;
            }
        }
        assertThat(numRuntimeGranted).isEqualTo(expectedRuntimeGranted);

        ArrayList<CharSequence> maybeStandardPermissionLabels = new ArrayList<>();
        ArrayList<CharSequence> nonStandardPermissionLabels = new ArrayList<>();
        for (PermissionGroupInfo permGroup : sContext.getPackageManager().getAllPermissionGroups(
                0)) {
            CharSequence permissionGroupLabel = permGroup.loadLabel(sContext.getPackageManager());
            if (permGroup.packageName.equals(""android"")) {
                maybeStandardPermissionLabels.add(permissionGroupLabel);
            } else {
                nonStandardPermissionLabels.add(permissionGroupLabel);
            }
        }

        int numInfosGranted = 0;

        for (RuntimePermissionPresentationInfo permissionInfo : permissionInfos) {
            CharSequence permissionGroupLabel = permissionInfo.getLabel();

            // PermissionInfo should be included in exactly one of existing (possibly) standard
            // or nonstandard permission groups
            if (permissionInfo.isStandard()) {
                assertThat(maybeStandardPermissionLabels).contains(permissionGroupLabel);
            } else {
                assertThat(nonStandardPermissionLabels).contains(permissionGroupLabel);
            }
            if (permissionInfo.isGranted()) {
                numInfosGranted++;
            }
        }

        // Each permissionInfo represents one or more runtime permissions, but we don't have a
        // mapping, so we check that we have at least as many runtimePermissions as permissionInfos
        assertThat(numRuntimeGranted).isAtLeast(numInfosGranted);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.PermissionControllerTest"	"revokePermissionsDoNotAlreadyRevokedPermission"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PermissionControllerTest.java"	""	"public void revokePermissionsDoNotAlreadyRevokedPermission() throws Exception {
        // Properly revoke the permission
        runWithShellPermissionIdentity(() -> {
            sUiAutomation.revokeRuntimePermission(APP, ACCESS_BACKGROUND_LOCATION);
            setAppOp(APP, ACCESS_FINE_LOCATION, MODE_FOREGROUND);
        });

        Map<String, List<String>> request = buildRevokeRequest(APP, ACCESS_BACKGROUND_LOCATION);
        Map<String, List<String>> result = revokePermissions(request, false);

        assertThat(result).isEmpty();
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.PermissionControllerTest"	"revokePermissionsDryRunForegroundPermission"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PermissionControllerTest.java"	""	"public void revokePermissionsDryRunForegroundPermission() throws Exception {
        Map<String, List<String>> request = buildRevokeRequest(APP, ACCESS_FINE_LOCATION);

        Map<String, List<String>> result = revokePermissions(request, true);

        assertThat(result.size()).isEqualTo(1);
        assertThat(result.get(APP)).isNotNull();
        assertThat(result.get(APP)).containsExactly(ACCESS_FINE_LOCATION,
                ACCESS_BACKGROUND_LOCATION, ACCESS_COARSE_LOCATION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.PermissionControllerTest"	"revokePermissionsPolicyViolationFromWrongPackage"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PermissionControllerTest.java"	""	"public void revokePermissionsPolicyViolationFromWrongPackage() throws Exception {
        Map<String, List<String>> request = buildRevokeRequest(APP, ACCESS_FINE_LOCATION);
        Map<String, List<String>> result = callWithShellPermissionIdentity(
                () -> revokePermissions(request,
                        false, REASON_INSTALLER_POLICY_VIOLATION, sContext.getMainExecutor()));
        assertThat(result).isEmpty();
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.PermissionControllerTest"	"revokePermissionsWithNullPkg"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PermissionControllerTest.java"	""	"(expected = NullPointerException.class)
    public void revokePermissionsWithNullPkg() throws Exception {
        Map<String, List<String>> request = Collections.singletonMap(null,
                singletonList(ACCESS_FINE_LOCATION));

        revokePermissions(request, true);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.PermissionControllerTest"	"countPermissionAppsGranted"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PermissionControllerTest.java"	""	"public void countPermissionAppsGranted() {
        runWithShellPermissionIdentity(
                () -> {
                    CompletableFuture<Integer> numApps = new CompletableFuture<>();

                    sController.countPermissionApps(singletonList(ACCESS_FINE_LOCATION),
                            COUNT_ONLY_WHEN_GRANTED, numApps::complete, null);

                    // TODO: Better would be to count before, grant a permission, count again and
                    //       then compare before and after
                    assertThat(numApps.get()).isAtLeast(1);
                });
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.PermissionControllerTest"	"countPermissionAppsInvalidFlags"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PermissionControllerTest.java"	""	"(expected = IllegalArgumentException.class)
    public void countPermissionAppsInvalidFlags() {
        sController.countPermissionApps(singletonList(ACCESS_FINE_LOCATION), -1, (n) -> { }, null);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.PermissionControllerTest"	"countPermissionAppsNullCallback"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PermissionControllerTest.java"	""	"(expected = NullPointerException.class)
    public void countPermissionAppsNullCallback() {
        sController.countPermissionApps(singletonList(ACCESS_FINE_LOCATION), 0, null, null);
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesRenouncePermissionTest"	"isEnabled"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesRenouncePermissionTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.app.AppOpsManager.OPSTR_FINE_LOCATION;

import static androidx.test.core.app.ApplicationProvider.getApplicationContext;

import static com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.app.AppOpsManager;
import android.app.AsyncNotedAppOp;
import android.app.SyncNotedAppOp;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.bluetooth.cts.BTAdapterUtils;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanResult;
import android.content.AttributionSource;
import android.content.Context;
import android.content.ContextParams;
import android.content.pm.PackageManager;
import android.os.Process;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.util.ArraySet;
import android.util.Base64;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Tests behaviour when performing bluetooth scans with renounced location permission.
 */
public class NearbyDevicesRenouncePermissionTest {

    private static final String TAG = ""NearbyDevicesRenouncePermissionTest"";
    private static final String OPSTR_BLUETOOTH_SCAN = ""android:bluetooth_scan"";

    private AppOpsManager mAppOpsManager;
    private int mLocationNoteCount;
    private int mScanNoteCount;
    private Context mContext = InstrumentationRegistry.getInstrumentation().getContext();
    private BluetoothAdapter mBluetoothAdapter;
    private boolean mBluetoothAdapterWasEnabled;

    private enum Result {
        UNKNOWN, EXCEPTION, EMPTY, FILTERED, FULL
    }

    private enum Scenario {
        DEFAULT, RENOUNCE, RENOUNCE_MIDDLE, RENOUNCE_END
    }

    @Before
    public void enableBluetooth() {
        assumeTrue(supportsBluetooth());
        mBluetoothAdapter = mContext.getSystemService(BluetoothManager.class).getAdapter();
        mBluetoothAdapterWasEnabled = mBluetoothAdapter.isEnabled();
        assertTrue(BTAdapterUtils.enableAdapter(mBluetoothAdapter, mContext));
        enableTestMode();
    }

    @After
    public void disableBluetooth() {
        assumeTrue(supportsBluetooth());
        disableTestMode();
        if (!mBluetoothAdapterWasEnabled) {
            assertTrue(BTAdapterUtils.disableAdapter(mBluetoothAdapter, mContext));
        }
    }

    @Before
    public void setUp() {
        mAppOpsManager = getApplicationContext().getSystemService(AppOpsManager.class);
        mAppOpsManager.setOnOpNotedCallback(getApplicationContext().getMainExecutor(),
                new AppOpsManager.OnOpNotedCallback() {
                    @Override
                    public void onNoted(SyncNotedAppOp op) {
                        switch (op.getOp()) {
                            case OPSTR_FINE_LOCATION:
                                mLocationNoteCount++;
                                break;
                            case OPSTR_BLUETOOTH_SCAN:
                                mScanNoteCount++;
                                break;
                            default:
                        }
                    }

                    @Override
                    public void onSelfNoted(SyncNotedAppOp op) {
                    }

                    @Override
                    public void onAsyncNoted(AsyncNotedAppOp asyncOp) {
                        switch (asyncOp.getOp()) {
                            case OPSTR_FINE_LOCATION:
                                mLocationNoteCount++;
                                break;
                            case OPSTR_BLUETOOTH_SCAN:
                                mScanNoteCount++;
                                break;
                            default:
                        }
                    }
                });
    }

    @After
    public void tearDown() {
        mAppOpsManager.setOnOpNotedCallback(null, null);
    }

    private void clearNoteCounts() {
        mLocationNoteCount = 0;
        mScanNoteCount = 0;
    }

    @AppModeFull"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.NearbyDevicesRenouncePermissionTest"	"enableTestMode"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesRenouncePermissionTest.java"	""	"public void scanRenouncingAtEndOfChainNotesBluetoothButNotLocation() throws Exception {
        clearNoteCounts();
        assertThat(performScan(Scenario.RENOUNCE_END)).isEqualTo(Result.FILTERED);
        SystemUtil.eventually(() -> {
            assertThat(mLocationNoteCount).isEqualTo(0);
            assertThat(mScanNoteCount).isGreaterThan(0);
        });
    }

    private Result performScan(Scenario scenario) {
        try {
            Context context = createContext(scenario, getApplicationContext());

            final BluetoothManager bm = context.getSystemService(BluetoothManager.class);
            final BluetoothLeScanner scanner = bm.getAdapter().getBluetoothLeScanner();

            final HashSet<String> observed = new HashSet<>();

            ScanCallback callback = new ScanCallback() {
                public void onScanResult(int callbackType, ScanResult result) {
                    Log.v(TAG, String.valueOf(result));
                    observed.add(Base64.encodeToString(result.getScanRecord().getBytes(), 0));
                }

                public void onBatchScanResults(List<ScanResult> results) {
                    for (ScanResult result : results) {
                        onScanResult(0, result);
                    }
                }
            };
            scanner.startScan(callback);

            // Wait a few seconds to figure out what we actually observed
            SystemClock.sleep(3000);
            scanner.stopScan(callback);
            switch (observed.size()) {
                case 0: return Result.EMPTY;
                case 1: return Result.FILTERED;
                case 5: return Result.FULL;
                default: return Result.UNKNOWN;
            }
        } catch (Throwable t) {
            Log.v(TAG, ""Failed to scan"", t);
            return Result.EXCEPTION;
        }
    }

    private Context createContext(Scenario scenario, Context context) throws Exception {
        if (scenario == Scenario.DEFAULT) {
            return context;
        }

        Set<String> renouncedPermissions = new ArraySet<>();
        renouncedPermissions.add(ACCESS_FINE_LOCATION);

        switch (scenario) {
            case RENOUNCE:
                return SystemUtil.callWithShellPermissionIdentity(() ->
                        context.createContext(
                                new ContextParams.Builder()
                                        .setRenouncedPermissions(renouncedPermissions)
                                        .setAttributionTag(context.getAttributionTag())
                                        .build())
                );
            case RENOUNCE_MIDDLE:
                AttributionSource nextAttrib = new AttributionSource(
                        Process.SHELL_UID, ""com.android.shell"", null, (Set<String>) null, null);
                return SystemUtil.callWithShellPermissionIdentity(() ->
                        context.createContext(
                                new ContextParams.Builder()
                                        .setRenouncedPermissions(renouncedPermissions)
                                        .setAttributionTag(context.getAttributionTag())
                                        .setNextAttributionSource(nextAttrib)
                                        .build())
                );
            case RENOUNCE_END:
                nextAttrib = new AttributionSource(
                        Process.SHELL_UID, ""com.android.shell"", null, renouncedPermissions, null);
                return SystemUtil.callWithShellPermissionIdentity(() ->
                        context.createContext(
                                new ContextParams.Builder()
                                        .setAttributionTag(context.getAttributionTag())
                                        .setNextAttributionSource(nextAttrib)
                                        .build())
                );
            default:
                throw new IllegalStateException();
        }
    }


    private boolean supportsBluetooth() {
        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH);
    }

    private void enableTestMode() {
        runShellCommandOrThrow(""dumpsys activity service""
                + "" com.android.bluetooth/.btservice.AdapterService set-test-mode enabled"");
    }

    private void disableTestMode() {
        runShellCommandOrThrow(""dumpsys activity service""
                + "" com.android.bluetooth/.btservice.AdapterService set-test-mode disabled"");
    }

}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyLocationTests"	"testCellLocationFinePermission"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	"public void testCellLocationFinePermission() {
        if (!mShouldTest) return;
        Runnable cellLocationAccess = () -> {
            try {
                Bundle cellLocationBundle = (Bundle) performLocationAccessCommand(
                        CtsLocationAccessService.COMMAND_GET_CELL_LOCATION);
                CellLocation cellLocation = cellLocationBundle == null ? null :
                        CellLocation.newFromBundle(cellLocationBundle);
                assertTrue(cellLocation == null || cellLocation.isEmpty());
            } catch (SecurityException e) {
                // expected
            }

            try {
                List cis = (List) performLocationAccessCommand(
                        CtsLocationAccessService.COMMAND_GET_CELL_INFO);
                assertTrue(cis == null || cis.isEmpty());
            } catch (SecurityException e) {
                // expected
            }
        };

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE,
                cellLocationAccess, Manifest.permission.ACCESS_FINE_LOCATION);
        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, cellLocationAccess,
                Manifest.permission.ACCESS_BACKGROUND_LOCATION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyLocationTests"	"testServiceStateLocationSanitization"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	"public void testServiceStateLocationSanitization() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    ServiceState ss = (ServiceState) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_GET_SERVICE_STATE);
                    assertServiceStateSanitization(ss, true);

                    withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                                ServiceState ss1 = (ServiceState) performLocationAccessCommand(
                                        CtsLocationAccessService.COMMAND_GET_SERVICE_STATE);
                                assertServiceStateSanitization(ss1, false);
                            },
                            Manifest.permission.ACCESS_COARSE_LOCATION);
                },
                Manifest.permission.ACCESS_FINE_LOCATION);

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    ServiceState ss1 = (ServiceState) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_GET_SERVICE_STATE);
                    assertServiceStateSanitization(ss1, false);
                },
                Manifest.permission.ACCESS_BACKGROUND_LOCATION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyLocationTests"	"testServiceStateListeningWithoutPermissions"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	"public void testServiceStateListeningWithoutPermissions() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    ServiceState ss = (ServiceState) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_GET_SERVICE_STATE_FROM_LISTENER);
                    assertServiceStateSanitization(ss, true);

                    withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                                ServiceState ss1 = (ServiceState) performLocationAccessCommand(
                                        CtsLocationAccessService
                                                .COMMAND_GET_SERVICE_STATE_FROM_LISTENER);
                                assertServiceStateSanitization(ss1, false);
                            },
                            Manifest.permission.ACCESS_COARSE_LOCATION);
                },
                Manifest.permission.ACCESS_FINE_LOCATION);

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    ServiceState ss1 = (ServiceState) performLocationAccessCommand(
                            CtsLocationAccessService
                                    .COMMAND_GET_SERVICE_STATE_FROM_LISTENER);
                    assertServiceStateSanitization(ss1, false);
                },
                Manifest.permission.ACCESS_BACKGROUND_LOCATION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyLocationTests"	"testSdk28ServiceStateListeningWithoutPermissions"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	"public void testSdk28ServiceStateListeningWithoutPermissions() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
                    ServiceState ss = (ServiceState) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_GET_SERVICE_STATE_FROM_LISTENER);
                    assertNotNull(ss);
                    assertNotEquals(ss, ss.createLocationInfoSanitizedCopy(false));

                    withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
                                ServiceState ss1 = (ServiceState) performLocationAccessCommand(
                                        CtsLocationAccessService
                                                .COMMAND_GET_SERVICE_STATE_FROM_LISTENER);
                                assertNotNull(ss1);
                                assertNotEquals(ss1, ss1.createLocationInfoSanitizedCopy(true));
                            },
                            Manifest.permission.ACCESS_COARSE_LOCATION);
                },
                Manifest.permission.ACCESS_FINE_LOCATION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyLocationTests"	"testRegistryPermissionsForCellLocation"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	"public void testRegistryPermissionsForCellLocation() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    CellLocation cellLocation = (CellLocation) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_LISTEN_CELL_LOCATION);
                    assertNull(cellLocation);
                },
                Manifest.permission.ACCESS_FINE_LOCATION);

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    CellLocation cellLocation = (CellLocation) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_LISTEN_CELL_LOCATION);
                    assertNull(cellLocation);
                },
                Manifest.permission.ACCESS_BACKGROUND_LOCATION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyLocationTests"	"testRegistryPermissionsForCellInfo"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	"public void testRegistryPermissionsForCellInfo() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    CellLocation cellLocation = (CellLocation) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_LISTEN_CELL_INFO);
                    assertNull(cellLocation);
                },
                Manifest.permission.ACCESS_FINE_LOCATION);

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    CellLocation cellLocation = (CellLocation) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_LISTEN_CELL_INFO);
                    assertNull(cellLocation);
                },
                Manifest.permission.ACCESS_BACKGROUND_LOCATION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyLocationTests"	"testSdk28CellLocation"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	"public void testSdk28CellLocation() {
        if (!mShouldTest) return;

        // Verify that a target-sdk 28 app can access cell location with ACCESS_COARSE_LOCATION, but
        // not with no location permissions at all.
        withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
            try {
                performLocationAccessCommandSdk28(
                        CtsLocationAccessService.COMMAND_GET_CELL_LOCATION);
            } catch (SecurityException e) {
                fail(""SDK28 should have access to cell location with coarse permission"");
            }

            withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
                try {
                    Bundle cellLocationBundle = (Bundle) performLocationAccessCommandSdk28(
                            CtsLocationAccessService.COMMAND_GET_CELL_LOCATION);
                    CellLocation cellLocation = cellLocationBundle == null ? null :
                            CellLocation.newFromBundle(cellLocationBundle);
                    assertTrue(cellLocation == null || cellLocation.isEmpty());
                } catch (SecurityException e) {
                    // expected
                }
            }, Manifest.permission.ACCESS_COARSE_LOCATION);
        }, Manifest.permission.ACCESS_FINE_LOCATION);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.cts.TelephonyLocationTests"	"testSdk28CellInfoUpdate"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	"public void testSdk28CellInfoUpdate() {
        if (!mShouldTest) return;

        // Verify that a target-sdk 28 app still requires fine location access
        // to call requestCellInfoUpdate
        withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
            try {
                List<CellInfo> cis = (List<CellInfo>) performLocationAccessCommandSdk28(
                        CtsLocationAccessService.COMMAND_REQUEST_CELL_INFO_UPDATE);
                assertTrue(cis == null || cis.isEmpty());
            } catch (SecurityException e) {
                // expected
            }
        }, Manifest.permission.ACCESS_FINE_LOCATION);
    }

    private ICtsLocationAccessControl getLocationAccessAppControl() {
        Intent bindIntent = new Intent(CtsLocationAccessService.CONTROL_ACTION);
        bindIntent.setComponent(new ComponentName(
                LOCATION_ACCESS_APP_CURRENT_PACKAGE,
                CtsLocationAccessService.class.getName()));

        return bindLocationAccessControl(bindIntent);
    }

    private ICtsLocationAccessControl getLocationAccessAppControlSdk28() {
        Intent bindIntent = new Intent(CtsLocationAccessService.CONTROL_ACTION);
        bindIntent.setComponent(new ComponentName(
                LOCATION_ACCESS_APP_SDK28_PACKAGE,
                CtsLocationAccessService.class.getName()));

        return bindLocationAccessControl(bindIntent);
    }

    private ICtsLocationAccessControl bindLocationAccessControl(Intent bindIntent) {
        LinkedBlockingQueue<ICtsLocationAccessControl> pipe =
                new LinkedBlockingQueue<>();
        InstrumentationRegistry.getContext().bindService(bindIntent, new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                pipe.offer(ICtsLocationAccessControl.Stub.asInterface(service));
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {

            }
        }, Context.BIND_AUTO_CREATE);

        try {
            return pipe.poll(TEST_TIMEOUT, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            fail(""interrupted"");
        }
        fail(""Unable to connect to location access test app"");
        return null;
    }

    private Object performLocationAccessCommand(String command) {
        int tries = 0;
        while (tries < 5) {
            ICtsLocationAccessControl control = getLocationAccessAppControl();
            try {
                List ret = control.performCommand(command);
                if (!ret.isEmpty()) return ret.get(0);
            } catch (RemoteException e) {
                tries++;
            }
        }
        fail(""Too many remote exceptions"");
        return null;
    }

    private Object performLocationAccessCommandSdk28(String command) {
        ICtsLocationAccessControl control = getLocationAccessAppControlSdk28();
        try {
            List ret = control.performCommand(command);
            if (!ret.isEmpty()) return ret.get(0);
        } catch (RemoteException e) {
            fail(""Remote exception"");
        }
        return null;
    }

    private void withRevokedPermission(String packageName, Runnable r, String permission) {
        // Bind to the appropriate testapp first so that we know when the permission has been fully
        // revoked -- that way after we bind again we know it's not going to be killed
        // due to a race condition.

        Intent bindIntent = new Intent(CtsLocationAccessService.CONTROL_ACTION);
        bindIntent.setComponent(new ComponentName(packageName,
                CtsLocationAccessService.class.getName()));

        CompletableFuture<Void> bindSuccess = new CompletableFuture<>();
        CompletableFuture<Void> serviceKilled = new CompletableFuture<>();
        InstrumentationRegistry.getContext().bindService(bindIntent, new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                bindSuccess.complete(null);
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                serviceKilled.complete(null);
            }
        }, Context.BIND_AUTO_CREATE);

        try {
            bindSuccess.get(TEST_TIMEOUT, TimeUnit.MILLISECONDS);
        } catch (Exception e) {
            fail(""unable to perform initial bind probe when revoking permissions:"" + e);
        }

        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation().revokeRuntimePermission(packageName, permission);

        try {
            try {
                serviceKilled.get(TEST_TIMEOUT, TimeUnit.MILLISECONDS);
            } catch (Exception e) {
                fail(""unable to verify disconnect of initial bind probe when""
                        + "" revoking permissions:"" + e);
            }

            r.run();
        } finally {
            InstrumentationRegistry.getInstrumentation()
                    .getUiAutomation().grantRuntimePermission(packageName, permission);
        }
    }

    private void assertServiceStateSanitization(ServiceState state, boolean sanitizedForFineOnly) {
        if (state == null) return;

        if (state.getNetworkRegistrationInfoList() != null) {
            for (NetworkRegistrationInfo nrs : state.getNetworkRegistrationInfoList()) {
                assertNull(nrs.getCellIdentity());
            }
        }

        if (sanitizedForFineOnly) return;

        assertTrue(TextUtils.isEmpty(state.getOperatorAlphaLong()));
        assertTrue(TextUtils.isEmpty(state.getOperatorAlphaShort()));
        assertTrue(TextUtils.isEmpty(state.getOperatorNumeric()));
    }

}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.EabControllerTest"	"testRequestExpiredAvailabilities"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/EabControllerTest.java"	""	"public void testRequestExpiredAvailabilities() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Set availability expiration time
        setProvisioningIntValue(ProvisioningManager.KEY_RCS_AVAILABILITY_CACHE_EXPIRATION_SEC,
                EXPIRATION_TIME_IN_SEC);

        fakeNetworkResult(getPidfXmlData(
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                true,
                false,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY));
        // Request availabilities for saving availabilities to EAB provider
        requestAvailability(sTestNumberUri);
        mErrorQueue.clear();
        mCompleteQueue.clear();
        mCapabilityQueue.clear();

        // Waiting availabilities expire
        waitingEabCapabilityExpire();

        // Request availabilities again
        RcsContactUceCapability capability = requestAvailability(sTestNumberUri);

        // Verify that return the availabilities from network instead of the EAB provider
        verifyCapabilityResult(capability,
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                REQUEST_RESULT_FOUND,
                RcsContactUceCapability.SOURCE_TYPE_NETWORK,
                true,
                false,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY);

        // Verify the onCompleted is called
        waitForResult(mCompleteQueue);
    }

    private RcsContactUceCapability requestAvailability(Uri contact) throws Exception {
        // Request capabilities by calling the API requestCapabilities.
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestAvailability(contact, Runnable::run,
                            mCallback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE.""
                 + e);
        } catch (ImsException e) {
            fail(""requestCapabilities failed "" + e);
        }

        // Verify that all the contact's capabilities are received
        return waitForResult(mCapabilityQueue);
    }

    private RcsContactUceCapability requestCapabilities(List<Uri> contact) throws Exception {
        // Request capabilities by calling the API requestCapabilities.
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    uceAdapter,
                    adapter -> adapter.requestCapabilities(contact, Runnable::run, mCallback),
                    ImsException.class,
                    ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""requestCapabilities should succeed with ACCESS_RCS_USER_CAPABILITY_EXCHANGE.""
                 + e);
        } catch (ImsException e) {
            fail(""requestCapabilities failed "" + e);
        }

        // Verify that all the contact's capabilities are received
        return waitForResult(mCapabilityQueue);
    }

    private static void overrideCarrierConfig() throws Exception {
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);


        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL,
                true);
        overrideCarrierConfig(bundle);
    }

    private void fakeNetworkResult(String pidfXml) {
        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        ArrayList<String> pidfXmlList = new ArrayList<>(1);
        pidfXmlList.add(pidfXml);

        // Setup the network response is 200 OK and notify capabilities update
        int networkRespCode = 200;
        String networkRespReason = ""OK"";
        capabilityExchangeImpl.setSubscribeOperation((uris, cb) -> {
            cb.onNetworkResponse(networkRespCode, networkRespReason);
            cb.onNotifyCapabilitiesUpdate(pidfXmlList);
            cb.onTerminated("""", 0L);
        });
    }

    private String getPidfXmlData(Uri contact,
            String serviceDescription,
            String serviceStatus,
            boolean audioSupported,
            boolean videoSupported,
            String supportedDuplexMode,
            String unSupportedDuplexMode) {
        GregorianCalendar date = new GregorianCalendar();
        String timeStamp = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssXXX"")
                .format(date.getTime());

        String pidfBuilder = ""<?xml version='1.0' encoding='utf-8' standalone='yes' ?>""
                + ""<presence entity=\"""" + contact + ""\""""
                + "" xmlns=\""urn:ietf:params:xml:ns:pidf\""""
                + "" xmlns:op=\""urn:oma:xml:prs:pidf:oma-pres\""""
                + "" xmlns:caps=\""urn:ietf:params:xml:ns:pidf:caps\"">""
                + ""<tuple id=\""tid0\"">""
                // status
                + ""<status><basic>"" + serviceStatus + ""</basic></status>""
                // timestamp
                + ""<timestamp>"" + timeStamp + ""</timestamp>""

                // service description
                + ""<op:service-description>""
                + ""<op:service-id>service_id_01</op:service-id>""
                + ""<op:version>1.0</op:version>""
                + ""<op:description>"" + serviceDescription + ""</op:description>""
                + ""</op:service-description>""

                // service capabilities
                + ""<caps:servcaps>""
                // audio capabilities
                + ""<caps:audio>"" + audioSupported + ""</caps:audio>""
                // video capabilities
                + ""<caps:video>"" + videoSupported + ""</caps:video>""

                // duplex mode
                + ""<caps:duplex>""
                // support duplex mode
                + ""<caps:supported>""
                + ""<caps:"" + supportedDuplexMode + ""/>""
                + ""</caps:supported>""

                // unsupported duplex mode
                + ""<caps:notsupported>""
                + ""<caps:"" + unSupportedDuplexMode + ""/>""
                + ""</caps:notsupported>""
                + ""</caps:duplex>""
                + ""</caps:servcaps>""
                + ""<contact>"" + contact + ""</contact>""
                + ""</tuple>""
                + ""</presence>"";
        return pidfBuilder;
    }

    private void verifyCapabilityResult(RcsContactUceCapability resultCapability,
            Uri expectedUri,
            String serviceDescription,
            String serviceStatus,
            int expectedResult,
            int expectedSourceType,
            boolean expectedAudioSupported,
            boolean expectedVideoSupported,
            String expectedSupportedDuplexMode,
            String expectedUnSupportedDuplexMode) {
        // Verify the contact URI
        assertEquals(expectedUri, resultCapability.getContactUri());

        // Verify the source type is the network type.
        assertEquals(expectedSourceType, resultCapability.getSourceType());

        // Verify the request result is expected.
        final int requestResult = resultCapability.getRequestResult();
        assertEquals(requestResult, expectedResult);

        // Verify the mechanism is presence
        assertEquals(RcsContactUceCapability.CAPABILITY_MECHANISM_PRESENCE,
                resultCapability.getCapabilityMechanism());

        RcsContactPresenceTuple presenceTuple =
                resultCapability.getCapabilityTuple(""service_id_01"");
        assertNotNull(""Contact Presence tuple should not be null!"", presenceTuple);

        RcsContactPresenceTuple.ServiceCapabilities capabilities =
                presenceTuple.getServiceCapabilities();
        assertNotNull(""Service capabilities should not be null!"", capabilities);

        // Verify timestamp
        assertNotNull(""Timestamp should not be null!"", presenceTuple.getTime());

        // Verify service id
        assertEquals(""service_id_01"", presenceTuple.getServiceId());

        // Verify service status
        assertEquals(serviceStatus, presenceTuple.getStatus());

        // Verify service description
        assertEquals(serviceDescription, presenceTuple.getServiceDescription());

        // Verify audio
        assertEquals(expectedAudioSupported, capabilities.isAudioCapable());

        // Verify video
        assertEquals(expectedVideoSupported, capabilities.isVideoCapable());

        // Verify Supported Duplex Mode
        assertEquals(expectedSupportedDuplexMode, capabilities.getSupportedDuplexModes().get(0));

        // Verify UnSupported Duplex Mode
        assertEquals(expectedUnSupportedDuplexMode,
                capabilities.getUnsupportedDuplexModes().get(0));
    }

    private <T> T waitForResult(BlockingQueue<T> queue) throws Exception {
        return queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }

    private static void connectTestImsService() throws Exception {
        assertTrue(sServiceConnector.connectCarrierImsService(new ImsFeatureConfiguration.Builder()
                .addFeature(sTestSlot, ImsFeature.FEATURE_RCS)
                .addFeature(sTestSlot, ImsFeature.FEATURE_MMTEL)
                .build()));

        // The RcsFeature is created when the ImsService is bound. If it wasn't created, then the
        // Framework did not call it.
        assertTrue(""Did not receive createRcsFeature"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_CREATE_RCS));
        assertTrue(""Did not receive RcsFeature#onReady"", sServiceConnector.getCarrierService()
                .waitForLatchCountdown(TestImsService.LATCH_RCS_READY));
        // Make sure the RcsFeature was created in the test service.
        assertNotNull(""Device ImsService created, but TestDeviceImsService#createRcsFeature was not""
                + ""called!"", sServiceConnector.getCarrierService().getRcsFeature());
        assertTrue(""Did not receive RcsFeature#setCapabilityExchangeEventListener"",
                sServiceConnector.getCarrierService().waitForLatchCountdown(
                        TestImsService.LATCH_UCE_LISTENER_SET));
        int serviceSlot = sServiceConnector.getCarrierService().getRcsFeature().getSlotIndex();
        assertEquals(""The slot specified for the test ("" + sTestSlot + "") does not match the ""
                        + ""assigned slot ("" + serviceSlot + ""+ for the associated RcsFeature"",
                sTestSlot, serviceSlot);
    }

    private static void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getInstrumentation()
                .getContext().getSystemService(CarrierConfigManager.class);
        sReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(sTestSub, bundle));
        sReceiver.waitForCarrierConfigChanged();
    }

    private static void removeTestContactFromEab() {
        try {
            sServiceConnector.removeEabContacts(sTestSlot, sTestPhoneNumber);
        } catch (Exception e) {
            Log.w(""RcsUceAdapterTest"", ""Cannot remove test contacts from eab database: "" + e);
        }
    }

    private static String formatNumber(Context context, String number) {
        TelephonyManager manager = context.getSystemService(TelephonyManager.class);
        String simCountryIso = manager.getSimCountryIso();
        if (simCountryIso != null) {
            simCountryIso = simCountryIso.toUpperCase();
            PhoneNumberUtil util = PhoneNumberUtil.getInstance();
            try {
                Phonenumber.PhoneNumber phoneNumber = util.parse(number, simCountryIso);
                return util.format(phoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164);
            } catch (NumberParseException e) {
                Log.w(TAG, ""formatNumber: could not format "" + number + "", error: "" + e);
            }
        }
        return number;
    }

    private String getEabCapabilities(String phoneNum) throws Exception {
        StringBuilder cmdBuilder = new StringBuilder();
        cmdBuilder.append(COMMAND_BASE).append(COMMAND_GET_EAB_CONTACT)
                .append("" "").append(phoneNum);
        return TelephonyUtils.executeShellCommand(InstrumentationRegistry.getInstrumentation(),
                cmdBuilder.toString());
    }

    private void setProvisioningIntValue(int key, int value) {
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            ProvisioningManager provisioningManager =
                    ProvisioningManager.createForSubscriptionId(sTestSub);
            provisioningManager.setProvisioningIntValue(key, value);
        } finally {
            automan.dropShellPermissionIdentity();
        }
    }

    private void waitingEabCapabilityExpire() throws Exception {
        int retryTimes = POLLING_RETRY_TIMES;
        long expirationTime;
        do {
            String capabilities = getEabCapabilities(formatNumber(getContext(), sTestPhoneNumber));
            String[] capabilityInfo = capabilities.split("","");
            assertTrue(capabilityInfo.length > 4);
            Thread.sleep(WAITING_IN_MILLI_SEC);
            expirationTime = Long.parseLong(capabilityInfo[2]);
            retryTimes--;
        } while (retryTimes > 0 && Instant.now().getEpochSecond() < expirationTime);
    }
}"	""	""	"android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.packages.PackageTest"	"TestApis"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/packages/PackageTest.java"	""	"/*
 *.
 */

package com.android.bedstead.nene.packages;

import static com.google.common.truth.Truth.assertThat;

import android.content.Context;

import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.users.UserReference;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.io.File;

@RunWith(JUnit4.class)
public class PackageTest {

    // Controlled by AndroidTest.xml
    private static final String TEST_APP_PACKAGE_NAME =
            ""com.android.bedstead.nene.testapps.TestApp1"";
    private static final File TEST_APP_APK_FILE =
            new File(""/data/local/tmp/NeneTestApp1.apk"");

    private static final String ACCESS_NETWORK_STATE_PERMISSION =
            ""android.permission.ACCESS_NETWORK_STATE"";

    private static final TestApis sTestApis = new TestApis();
    private static final Context sContext = sTestApis.context().instrumentedContext();
    private static final UserReference sUser = sTestApis.users().instrumented();"	""	""	"android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.carrierapi.cts.NetworkScanApiTest"	"werePreconditionsSatisfied"	"CtsCarrierApiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	"/*
 *.
 */
package android.carrierapi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.fail;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Message;
import android.os.Parcel;
import android.os.Process;
import android.os.UserHandle;
import android.telephony.AccessNetworkConstants;
import android.telephony.CellInfo;
import android.telephony.CellInfoGsm;
import android.telephony.CellInfoLte;
import android.telephony.CellInfoWcdma;
import android.telephony.NetworkScan;
import android.telephony.NetworkScanRequest;
import android.telephony.RadioAccessSpecifier;
import android.telephony.TelephonyManager;
import android.telephony.TelephonyScanManager;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Unit tests for {@link TelephonyManager}'s network scan APIs.
 *
 * <p>Test using `atest CtsCarrierApiTestCases:NetworkScanApiTest` or `make cts -j64 && cts-tradefed
 * run cts -m CtsCarrierApiTestCases --test android.carrierapi.cts.NetworkScanApiTest`
 */
@RunWith(AndroidJUnit4.class)
public class NetworkScanApiTest extends BaseCarrierApiTest {
    private static final String TAG = ""NetworkScanApiTest"";

    private TelephonyManager mTelephonyManager;
    private int mNetworkScanStatus;
    private static final int EVENT_NETWORK_SCAN_START = 100;
    private static final int EVENT_NETWORK_SCAN_RESULTS = 200;
    private static final int EVENT_NETWORK_SCAN_RESTRICTED_RESULTS = 201;
    private static final int EVENT_NETWORK_SCAN_ERROR = 300;
    private static final int EVENT_NETWORK_SCAN_COMPLETED = 400;
    private static final int EVENT_SCAN_DENIED = 500;
    private List<CellInfo> mScanResults = null;
    private NetworkScanHandlerThread mTestHandlerThread;
    private Handler mHandler;
    private NetworkScan mNetworkScan;
    private NetworkScanRequest mNetworkScanRequest;
    private NetworkScanCallbackImpl mNetworkScanCallback;
    private static final int LOCATION_SETTING_CHANGE_WAIT_MS = 1000;
    private static final int MAX_CELLINFO_WAIT_MILLIS = 5000; // 5 seconds
    private static final int SCAN_SEARCH_TIME_SECONDS = 60;
    // Wait one second longer than the max scan search time to give the test time to receive the
    // results.
    private static final int MAX_INIT_WAIT_MS = (SCAN_SEARCH_TIME_SECONDS + 1) * 1000;
    private Object mLock = new Object();
    private boolean mReady;
    private int mErrorCode;
    /* All the following constants are used to construct NetworkScanRequest*/
    private static final int SCAN_TYPE = NetworkScanRequest.SCAN_TYPE_ONE_SHOT;
    private static final boolean INCREMENTAL_RESULTS = true;
    private static final int SEARCH_PERIODICITY_SEC = 5;
    private static final int MAX_SEARCH_TIME_SEC = 300;
    private static final int INCREMENTAL_RESULTS_PERIODICITY_SEC = 3;
    private static final ArrayList<String> MCC_MNC = new ArrayList<>();
    private static final RadioAccessSpecifier[] RADIO_ACCESS_SPECIFIERS = {
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.GERAN,
                null /* bands */,
                null /* channels */),
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.EUTRAN,
                null /* bands */,
                null /* channels */),
        new RadioAccessSpecifier(
                AccessNetworkConstants.AccessNetworkType.UTRAN,
                null /* bands */,
                null /* channels */)
    };

    // Needed because NETWORK_SCAN_PERMISSION is a systemapi
    public static final String NETWORK_SCAN_PERMISSION = ""android.permission.NETWORK_SCAN"";

    @Before
    public void setUp() throws Exception {
        mTelephonyManager = getContext().getSystemService(TelephonyManager.class);
        String selfPackageName = getContext().getPackageName();
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .grantRuntimePermission(selfPackageName, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .grantRuntimePermission(selfPackageName, ACCESS_BACKGROUND_LOCATION);
        mTestHandlerThread = new NetworkScanHandlerThread(TAG);
        mTestHandlerThread.start();
    }

    @After
    public void tearDown() throws Exception {
        if (!werePreconditionsSatisfied()) return;

        // Revoking runtime permissions makes ActivityManager kill our process, so we don't do it,
        // as the test harness will eventually uninstall this APK after testing completes anyway, so
        // we aren't really leaking anything long-term.
        mTestHandlerThread.quit();
    }

    private void waitUntilReady() {
        synchronized (mLock) {
            try {
                mLock.wait(MAX_INIT_WAIT_MS);
            } catch (InterruptedException ie) {
            }

            assertWithMessage(""NetworkScanApiTest failed to initialize"").that(mReady).isTrue();
        }
    }

    private void setReady(boolean ready) {
        synchronized (mLock) {
            mReady = ready;
            mLock.notifyAll();
        }
    }

    private class NetworkScanHandlerThread extends HandlerThread {

        public NetworkScanHandlerThread(String name) {
            super(name);
        }

        @Override
        public void onLooperPrepared() {
            /* create a custom handler for the Handler Thread */
            mHandler =
                    new Handler(mTestHandlerThread.getLooper()) {
                        @Override
                        public void handleMessage(Message msg) {
                            switch (msg.what) {
                                case EVENT_NETWORK_SCAN_START:
                                    Log.d(TAG, ""request network scan"");
                                    boolean useShellIdentity = (Boolean) msg.obj;
                                    if (useShellIdentity) {
                                        InstrumentationRegistry.getInstrumentation()
                                                .getUiAutomation()
                                                .adoptShellPermissionIdentity();
                                    }
                                    try {
                                        mNetworkScan =
                                                mTelephonyManager.requestNetworkScan(
                                                        mNetworkScanRequest,
                                                        AsyncTask.SERIAL_EXECUTOR,
                                                        mNetworkScanCallback);
                                        if (mNetworkScan == null) {
                                            mNetworkScanStatus = EVENT_SCAN_DENIED;
                                            setReady(true);
                                        }
                                    } catch (SecurityException e) {
                                        mNetworkScanStatus = EVENT_SCAN_DENIED;
                                        setReady(true);
                                    } finally {
                                        if (useShellIdentity) {
                                            InstrumentationRegistry.getInstrumentation()
                                                    .getUiAutomation()
                                                    .dropShellPermissionIdentity();
                                        }
                                    }
                                    break;
                                default:
                                    Log.d(TAG, ""Unknown Event "" + msg.what);
                            }
                        }
                    };
        }
    }

    private class NetworkScanCallbackImpl extends TelephonyScanManager.NetworkScanCallback {
        @Override
        public void onResults(List<CellInfo> results) {
            Log.d(TAG, ""onResults: "" + results.toString());
            mNetworkScanStatus = EVENT_NETWORK_SCAN_RESULTS;
            mScanResults = results;
        }

        @Override
        public void onComplete() {
            Log.d(TAG, ""onComplete"");
            mNetworkScanStatus = EVENT_NETWORK_SCAN_COMPLETED;
            setReady(true);
        }

        @Override
        public void onError(int error) {
            Log.d(TAG, ""onError: "" + String.valueOf(error));
            mNetworkScanStatus = EVENT_NETWORK_SCAN_ERROR;
            mErrorCode = error;
            setReady(true);
        }
    }

    private class CellInfoResultsCallback extends TelephonyManager.CellInfoCallback {
        public List<CellInfo> cellInfo;

        @Override
        public synchronized void onCellInfo(List<CellInfo> cellInfo) {
            this.cellInfo = cellInfo;
            notifyAll();
        }

        public synchronized void wait(int millis) throws InterruptedException {
            if (cellInfo == null) {
                super.wait(millis);
            }
        }
    }

    private List<RadioAccessSpecifier> getRadioAccessSpecifier(List<CellInfo> allCellInfo) {
        List<RadioAccessSpecifier> radioAccessSpecifier = new ArrayList<>();
        List<Integer> lteChannels = new ArrayList<>();
        List<Integer> wcdmaChannels = new ArrayList<>();
        List<Integer> gsmChannels = new ArrayList<>();
        for (int i = 0; i < allCellInfo.size(); i++) {
            CellInfo cellInfo = allCellInfo.get(i);
            if (cellInfo instanceof CellInfoLte) {
                lteChannels.add(((CellInfoLte) cellInfo).getCellIdentity().getEarfcn());
            } else if (cellInfo instanceof CellInfoWcdma) {
                wcdmaChannels.add(((CellInfoWcdma) cellInfo).getCellIdentity().getUarfcn());
            } else if (cellInfo instanceof CellInfoGsm) {
                gsmChannels.add(((CellInfoGsm) cellInfo).getCellIdentity().getArfcn());
            }
        }
        if (!lteChannels.isEmpty()) {
            Log.d(TAG, ""lte channels"" + lteChannels.toString());
            int ranLte = AccessNetworkConstants.AccessNetworkType.EUTRAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranLte,
                            null /* bands */,
                            lteChannels.stream().mapToInt(i -> i).toArray()));
        }
        if (!wcdmaChannels.isEmpty()) {
            Log.d(TAG, ""wcdma channels"" + wcdmaChannels.toString());
            int ranWcdma = AccessNetworkConstants.AccessNetworkType.UTRAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranWcdma,
                            null /* bands */,
                            wcdmaChannels.stream().mapToInt(i -> i).toArray()));
        }
        if (!gsmChannels.isEmpty()) {
            Log.d(TAG, ""gsm channels"" + gsmChannels.toString());
            int ranGsm = AccessNetworkConstants.AccessNetworkType.GERAN;
            radioAccessSpecifier.add(
                    new RadioAccessSpecifier(
                            ranGsm,
                            null /* bands */,
                            gsmChannels.stream().mapToInt(i -> i).toArray()));
        }
        return radioAccessSpecifier;
    }

    /** Tests that the device properly requests a network scan. */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.EphemeralTest"	"testReadPhoneNumbersPermission"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	"public void testReadPhoneNumbersPermission() throws Exception {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testReadPhoneNumbersPermission"");
    }

    /** Test for android.permission.ACCESS_COARSE_LOCATION */"	""	""	"android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testExpeditedJobDoesNotBypassSimultaneousFirewalls_withDataSaver"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	"public void testExpeditedJobDoesNotBypassSimultaneousFirewalls_withDataSaver()
            throws Exception {
        if (!BatteryUtils.isBatterySaverSupported()) {
            Log.d(TAG, ""Skipping test that requires battery saver support"");
            return;
        }
        if (mHasWifi) {
            setWifiMeteredState(true);
        } else if (checkDeviceSupportsMobileData()) {
            disconnectWifiToConnectToMobile();
        } else {
            Log.d(TAG, ""Skipping test that requires a metered network."");
            return;
        }
        if (!AppStandbyUtils.isAppStandbyEnabled()) {
            Log.d(TAG, ""App standby not enabled"");
            return;
        }

        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");
        SystemUtil.runShellCommand(""am set-standby-bucket ""
                + kJobServiceComponent.getPackageName() + "" restricted"");
        BatteryUtils.runDumpsysBatteryUnplug();
        BatteryUtils.enableBatterySaver(true);
        setDataSaverEnabled(true);

        mTestAppInterface = new TestAppInterface(mContext, CONNECTIVITY_JOB_ID);

        mTestAppInterface.scheduleJob(false,  JobInfo.NETWORK_TYPE_ANY, true);
        mTestAppInterface.runSatisfiedJob();

        assertFalse(""Expedited job fired with multiple firewalls, including data saver."",
                mTestAppInterface.awaitJobStart(DEFAULT_TIMEOUT_MILLIS));
    }

    // --------------------------------------------------------------------------------------------
    // Utility methods
    // --------------------------------------------------------------------------------------------

    /**
     * Determine whether the device running these CTS tests should be subject to tests involving
     * mobile data.
     * @return True if this device will support a mobile data connection.
     */
    private boolean checkDeviceSupportsMobileData() {
        if (!mHasTelephony) {
            Log.d(TAG, ""Skipping test that requires telephony features, not supported by this"" +
                    "" device"");
            return false;
        }
        Network[] networks = mCm.getAllNetworks();
        for (Network network : networks) {
            if (mCm.getNetworkCapabilities(network)
                    .hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
                return true;
            }
        }
        Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
        return false;
    }

    private String unquoteSSID(String ssid) {
        // SSID is returned surrounded by quotes if it can be decoded as UTF-8.
        // Otherwise it's guaranteed not to start with a quote.
        if (ssid.charAt(0) == '""') {
            return ssid.substring(1, ssid.length() - 1);
        } else {
            return ssid;
        }
    }

    private String getWifiSSID() {
        final AtomicReference<String> ssid = new AtomicReference<>();
        SystemUtil.runWithShellPermissionIdentity(() -> {
            ssid.set(mWifiManager.getConnectionInfo().getSSID());
        }, Manifest.permission.ACCESS_FINE_LOCATION);
        return unquoteSSID(ssid.get());
    }

    // Returns ""true"", ""false"" or ""none""
    private String getWifiMeteredStatus(String ssid) {
        // Interestingly giving the SSID as an argument to list wifi-networks
        // only works iff the network in question has the ""false"" policy.
        // Also unfortunately runShellCommand does not pass the command to the interpreter
        // so it's not possible to | grep the ssid.
        final String command = ""cmd netpolicy list wifi-networks"";
        final String policyString = SystemUtil.runShellCommand(command);

        final Matcher m = Pattern.compile(""^"" + ssid + "";(true|false|none)$"",
                Pattern.MULTILINE | Pattern.UNIX_LINES).matcher(policyString);
        if (!m.find()) {
            fail(""Unexpected format from cmd netpolicy (when looking for "" + ssid + ""): ""
                    + policyString);
        }
        return m.group(1);
    }

    private void setWifiMeteredState(boolean metered) throws Exception {
        if (metered) {
            // Make sure unmetered cellular networks don't interfere.
            setAirplaneMode(true);
            setWifiState(true, mCm, mWifiManager);
        }
        final String ssid = getWifiSSID();
        setWifiMeteredState(ssid, metered ? ""true"" : ""false"");
    }

    // metered should be ""true"", ""false"" or ""none""
    private void setWifiMeteredState(String ssid, String metered) {
        if (metered.equals(getWifiMeteredStatus(ssid))) {
            return;
        }
        SystemUtil.runShellCommand(""cmd netpolicy set metered-network "" + ssid + "" "" + metered);
        assertEquals(getWifiMeteredStatus(ssid), metered);
    }

    /**
     * Ensure WiFi is enabled, and block until we've verified that we are in fact connected.
     */
    private void connectToWifi()
            throws InterruptedException {
        setWifiState(true, mCm, mWifiManager);
    }

    /**
     * Ensure WiFi is disabled, and block until we've verified that we are in fact disconnected.
     */
    private void disconnectFromWifi()
            throws InterruptedException {
        setWifiState(false, mCm, mWifiManager);
    }

    /** Ensures that the device has a wifi network saved. */
    static void ensureSavedWifiNetwork(WifiManager wifiManager) {
        final List<WifiConfiguration> savedNetworks =
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        wifiManager, WifiManager::getConfiguredNetworks);
        assertFalse(""Need at least one saved wifi network"", savedNetworks.isEmpty());
    }

    /**
     * Set Wifi connection to specific state, and block until we've verified
     * that we are in the state.
     * Taken from {@link android.net.http.cts.ApacheHttpClientTest}.
     */
    static void setWifiState(final boolean enable,
            final ConnectivityManager cm, final WifiManager wm) throws InterruptedException {
        if (enable != isWiFiConnected(cm, wm)) {
            NetworkRequest nr = new NetworkRequest.Builder().clearCapabilities().build();
            NetworkCapabilities nc = new NetworkCapabilities.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .build();
            NetworkTracker tracker = new NetworkTracker(nc, enable, cm);
            cm.registerNetworkCallback(nr, tracker);

            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
                //noinspection deprecation
                SystemUtil.runWithShellPermissionIdentity(wm::reconnect,
                        android.Manifest.permission.NETWORK_SETTINGS);
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }

            tracker.waitForStateChange();

            assertTrue(""Wifi must be "" + (enable ? ""connected to"" : ""disconnected from"")
                            + "" an access point for this test."",
                    enable == isWiFiConnected(cm, wm));

            cm.unregisterNetworkCallback(tracker);
        }
    }

    static boolean isWiFiConnected(final ConnectivityManager cm, final WifiManager wm) {
        if (!wm.isWifiEnabled()) {
            return false;
        }
        final Network network = cm.getActiveNetwork();
        if (network == null) {
            return false;
        }
        final NetworkCapabilities networkCapabilities = cm.getNetworkCapabilities(network);
        return networkCapabilities != null && networkCapabilities.hasTransport(TRANSPORT_WIFI);
    }

    /**
     * Disconnect from WiFi in an attempt to connect to cellular data. Worth noting that this is
     * best effort - there are no public APIs to force connecting to cell data. We disable WiFi
     * and wait for a broadcast that we're connected to cell.
     * We will not call into this function if the device doesn't support telephony.
     * @see #mHasTelephony
     * @see #checkDeviceSupportsMobileData()
     */
    private void disconnectWifiToConnectToMobile() throws Exception {
        setAirplaneMode(false);
        if (mHasWifi && mWifiManager.isWifiEnabled()) {
            NetworkRequest nr = new NetworkRequest.Builder().clearCapabilities().build();
            NetworkCapabilities nc = new NetworkCapabilities.Builder()
                    .addTransportType(TRANSPORT_CELLULAR)
                    .build();
            NetworkTracker tracker = new NetworkTracker(nc, true, mCm);
            mCm.registerNetworkCallback(nr, tracker);

            disconnectFromWifi();

            assertTrue(""Device must have access to a metered network for this test."",
                    tracker.waitForStateChange());

            mCm.unregisterNetworkCallback(tracker);
        }
    }

    /**
     * Ensures that restrict background data usage policy is turned off.
     * If the policy is on, it interferes with tests that relies on metered connection.
     */
    private void setDataSaverEnabled(boolean enabled) throws Exception {
        SystemUtil.runShellCommand(getInstrumentation(),
                enabled ? RESTRICT_BACKGROUND_ON_CMD : RESTRICT_BACKGROUND_OFF_CMD);
    }

    private boolean isAirplaneModeOn() throws Exception {
        final String output = SystemUtil.runShellCommand(getInstrumentation(),
                ""cmd connectivity airplane-mode"").trim();
        return ""enabled"".equals(output);
    }

    private void setAirplaneMode(boolean on) throws Exception {
        if (isAirplaneModeOn() == on) {
            return;
        }
        final CallbackAsserter airplaneModeBroadcastAsserter = CallbackAsserter.forBroadcast(
                new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
        SystemUtil.runShellCommand(getInstrumentation(),
                ""cmd connectivity airplane-mode "" + (on ? ""enable"" : ""disable""));
        airplaneModeBroadcastAsserter.assertCalled(""Didn't get airplane mode changed broadcast"",
                15 /* 15 seconds */);
        waitUntil(""Networks didn't change to "" + (!on ? "" on"" : "" off""), 60 /* seconds */,
                () -> {
                    if (on) {
                        return mCm.getActiveNetwork() == null
                                && (!mHasWifi || !isWiFiConnected(mCm, mWifiManager));
                    } else {
                        return mCm.getActiveNetwork() != null;
                    }
                });
        // Wait some time for the network changes to propagate. Can't use
        // waitUntil(isAirplaneModeOn() == on) because the response quickly gives the new
        // airplane mode status even though the network changes haven't propagated all the way to
        // JobScheduler.
        Thread.sleep(5000);
    }

    private static class NetworkTracker extends ConnectivityManager.NetworkCallback {
        private static final int MSG_CHECK_ACTIVE_NETWORK = 1;
        private final ConnectivityManager mCm;

        private final CountDownLatch mReceiveLatch = new CountDownLatch(1);

        private final NetworkCapabilities mExpectedCapabilities;

        private final boolean mExpectedConnected;

        private final Handler mHandler = new Handler(Looper.getMainLooper()) {
            @Override
            public void handleMessage(Message msg) {
                if (msg.what == MSG_CHECK_ACTIVE_NETWORK) {
                    checkActiveNetwork();
                }
            }
        };

        private NetworkTracker(NetworkCapabilities expectedCapabilities, boolean expectedConnected,
                ConnectivityManager cm) {
            mExpectedCapabilities = expectedCapabilities;
            mExpectedConnected = expectedConnected;
            mCm = cm;
        }

        @Override
        public void onAvailable(Network network) {
            // Available doesn't mean it's the active network. We need to check that separately.
            checkActiveNetwork();
        }

        @Override
        public void onLost(Network network) {
            checkActiveNetwork();
        }

        boolean waitForStateChange() throws InterruptedException {
            checkActiveNetwork();
            return mReceiveLatch.await(60, TimeUnit.SECONDS);
        }

        private void checkActiveNetwork() {
            mHandler.removeMessages(MSG_CHECK_ACTIVE_NETWORK);
            if (mReceiveLatch.getCount() == 0) {
                return;
            }

            Network activeNetwork = mCm.getActiveNetwork();
            if (mExpectedConnected) {
                if (activeNetwork != null && mExpectedCapabilities.satisfiedByNetworkCapabilities(
                        mCm.getNetworkCapabilities(activeNetwork))) {
                    mReceiveLatch.countDown();
                } else {
                    mHandler.sendEmptyMessageDelayed(MSG_CHECK_ACTIVE_NETWORK, 5000);
                }
            } else {
                if (activeNetwork == null
                        || !mExpectedCapabilities.satisfiedByNetworkCapabilities(
                        mCm.getNetworkCapabilities(activeNetwork))) {
                    mReceiveLatch.countDown();
                } else {
                    mHandler.sendEmptyMessageDelayed(MSG_CHECK_ACTIVE_NETWORK, 5000);
                }
            }
        }
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.CommandReceiverActivity"	"isKeyguardSecure"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/CommandReceiverActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_HOME;
import static android.app.admin.DevicePolicyManager.MAKE_USER_EPHEMERAL;
import static android.app.admin.DevicePolicyManager.SKIP_SETUP_WIZARD;

import android.Manifest;
import android.app.Activity;
import android.app.KeyguardManager;
import android.app.PendingIntent;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.graphics.BitmapFactory;
import android.net.ProxyInfo;
import android.os.Bundle;
import android.os.PersistableBundle;
import android.os.UserHandle;
import android.os.UserManager;
import android.provider.ContactsContract;
import android.provider.MediaStore;
import android.provider.Settings;
import android.util.Log;
import android.view.inputmethod.InputMethodInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.Toast;

import com.android.bedstead.dpmwrapper.TestAppSystemServiceFactory;
import com.android.cts.verifier.R;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class CommandReceiverActivity extends Activity {
    private static final String TAG = ""CommandReceiverActivity"";

    public static final String ACTION_EXECUTE_COMMAND =
            ""com.android.cts.verifier.managedprovisioning.action.EXECUTE_COMMAND"";
    public static final String EXTRA_COMMAND =
            ""com.android.cts.verifier.managedprovisioning.extra.COMMAND"";

    public static final String COMMAND_SET_USER_RESTRICTION = ""set-user_restriction"";
    public static final String COMMAND_DISALLOW_KEYGUARD_UNREDACTED_NOTIFICATIONS =
            ""disallow-keyguard-unredacted-notifications"";
    public static final String COMMAND_SET_AUTO_TIME_REQUIRED = ""set-auto-time-required"";
    public static final String COMMAND_SET_GLOBAL_SETTING =
            ""set-global-setting"";
    public static final String COMMAND_SET_MAXIMUM_TO_LOCK = ""set-maximum-time-to-lock"";
    public static final String COMMAND_SET_KEYGUARD_DISABLED = ""set-keyguard-disabled"";
    public static final String COMMAND_SET_LOCK_SCREEN_INFO = ""set-lock-screen-info"";
    public static final String COMMAND_SET_STATUSBAR_DISABLED = ""set-statusbar-disabled"";
    public static final String COMMAND_SET_LOCK_TASK_FEATURES = ""set-lock-task-features"";
    public static final String COMMAND_ALLOW_ONLY_SYSTEM_INPUT_METHODS =
            ""allow-only-system-input-methods"";
    public static final String COMMAND_ALLOW_ONLY_SYSTEM_ACCESSIBILITY_SERVICES =
            ""allow-only-system-accessibility-services"";
    public static final String COMMAND_CLEAR_POLICIES = ""clear-policies"";
    public static final String COMMAND_REMOVE_DEVICE_OWNER = ""remove-device-owner"";
    public static final String COMMAND_REQUEST_BUGREPORT = ""request-bugreport"";
    public static final String COMMAND_SET_USER_ICON = ""set-user-icon"";
    public static final String COMMAND_RETRIEVE_NETWORK_LOGS = ""retrieve-network-logs"";
    public static final String COMMAND_RETRIEVE_SECURITY_LOGS = ""retrieve-security-logs"";
    public static final String COMMAND_SET_ORGANIZATION_NAME = ""set-organization-name"";
    public static final String COMMAND_ENABLE_NETWORK_LOGGING = ""enable-network-logging"";
    public static final String COMMAND_DISABLE_NETWORK_LOGGING = ""disable-network-logging"";
    public static final String COMMAND_INSTALL_HELPER_PACKAGE = ""install-helper-package"";
    public static final String COMMAND_UNINSTALL_HELPER_PACKAGE = ""uninstall-helper-package"";
    public static final String COMMAND_SET_PERMISSION_GRANT_STATE = ""set-permission-grant-state"";
    public static final String COMMAND_ADD_PERSISTENT_PREFERRED_ACTIVITIES =
            ""add-persistent-preferred-activities"";
    public static final String COMMAND_CLEAR_PERSISTENT_PREFERRED_ACTIVITIES =
            ""clear-persistent-preferred-activities"";
    public static final String COMMAND_CREATE_MANAGED_PROFILE = ""create-managed-profile"";
    public static final String COMMAND_REMOVE_MANAGED_PROFILE = ""remove-managed-profile"";
    public static final String COMMAND_SET_ALWAYS_ON_VPN = ""set-always-on-vpn"";
    public static final String COMMAND_CLEAR_ALWAYS_ON_VPN = ""clear-always-on-vpn"";
    public static final String COMMAND_SET_GLOBAL_HTTP_PROXY = ""set-global-http-proxy"";
    public static final String COMMAND_CLEAR_GLOBAL_HTTP_PROXY = ""clear-global-http-proxy"";
    public static final String COMMAND_INSTALL_CA_CERT = ""install-ca-cert"";
    public static final String COMMAND_CLEAR_CA_CERT = ""clear-ca-cert"";
    public static final String COMMAND_SET_MAXIMUM_PASSWORD_ATTEMPTS =
            ""set-maximum-password-attempts"";
    public static final String COMMAND_CLEAR_MAXIMUM_PASSWORD_ATTEMPTS =
            ""clear-maximum-password-attempts"";
    public static final String COMMAND_SET_DEFAULT_IME = ""set-default-ime"";
    public static final String COMMAND_CLEAR_DEFAULT_IME = ""clear-default-ime"";
    public static final String COMMAND_CREATE_MANAGED_USER = ""create-managed-user"";
    public static final String COMMAND_CREATE_MANAGED_USER_WITHOUT_SETUP =
            ""create-managed-user-without-setup"";
    public static final String COMMAND_REMOVE_SECONDARY_USERS = ""remove-secondary-users"";
    public static final String COMMAND_WITH_USER_SWITCHER_MESSAGE = ""with-user-switcher-message"";
    public static final String COMMAND_WITHOUT_USER_SWITCHER_MESSAGE =
            ""without-user-switcher-message"";
    public static final String COMMAND_ENABLE_LOGOUT = ""enable-logout"";
    public static final String COMMAND_DISABLE_USB_DATA_SIGNALING = ""disable-usb-data-signaling"";
    public static final String COMMAND_ENABLE_USB_DATA_SIGNALING = ""enable-usb-data-signaling"";
    public static final String COMMAND_SET_REQUIRED_PASSWORD_COMPLEXITY =
            ""set-required-password-complexity"";

    public static final String EXTRA_USER_RESTRICTION =
            ""com.android.cts.verifier.managedprovisioning.extra.USER_RESTRICTION"";
    public static final String EXTRA_USE_CURRENT_USER_DPM =
            ""com.android.cts.verifier.managedprovisioning.extra.USE_CURRENT_USER_DPM"";
    public static final String EXTRA_SETTING =
            ""com.android.cts.verifier.managedprovisioning.extra.SETTING"";
    // This extra can be used along with a command extra to set policy to
    // specify if that policy is enforced or not.
    public static final String EXTRA_ENFORCED =
            ""com.android.cts.verifier.managedprovisioning.extra.ENFORCED"";
    public static final String EXTRA_VALUE =
            ""com.android.cts.verifier.managedprovisioning.extra.VALUE"";
    public static final String EXTRA_ORGANIZATION_NAME =
            ""com.android.cts.verifier.managedprovisioning.extra.ORGANIZATION_NAME"";
    public static final String EXTRA_PERMISSION =
            ""com.android.cts.verifier.managedprovisioning.extra.PERMISSION"";
    public static final String EXTRA_GRANT_STATE =
            ""com.android.cts.verifier.managedprovisioning.extra.GRANT_STATE"";

    // We care about installing and uninstalling only. It does not matter what apk is used.
    // NotificationBot.apk is a good choice because it comes bundled with the CTS verifier.
    protected static final String HELPER_APP_LOCATION = ""/sdcard/NotificationBot.apk"";
    protected static final String HELPER_APP_PKG = ""com.android.cts.robot"";

    public static final String ACTION_INSTALL_COMPLETE =
            ""com.android.cts.verifier.managedprovisioning.action.ACTION_INSTALL_COMPLETE"";
    public static final String ACTION_UNINSTALL_COMPLETE =
            ""com.android.cts.verifier.managedprovisioning.action.ACTION_UNINSTALL_COMPLETE"";

    /*
     * The CA cert below is the content of cacert.pem as generated by:
     *
     * openssl req -new -x509 -days 3650 -extensions v3_ca -keyout cakey.pem -out cacert.pem
     */
    private static final String TEST_CA =
            ""-----BEGIN CERTIFICATE-----\n"" +
            ""MIIDXTCCAkWgAwIBAgIJAK9Tl/F9V8kSMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\n"" +
            ""BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX\n"" +
            ""aWRnaXRzIFB0eSBMdGQwHhcNMTUwMzA2MTczMjExWhcNMjUwMzAzMTczMjExWjBF\n"" +
            ""MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50\n"" +
            ""ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"" +
            ""CgKCAQEAvItOutsE75WBTgTyNAHt4JXQ3JoseaGqcC3WQij6vhrleWi5KJ0jh1/M\n"" +
            ""Rpry7Fajtwwb4t8VZa0NuM2h2YALv52w1xivql88zce/HU1y7XzbXhxis9o6SCI+\n"" +
            ""oVQSbPeXRgBPppFzBEh3ZqYTVhAqw451XhwdA4Aqs3wts7ddjwlUzyMdU44osCUg\n"" +
            ""kVg7lfPf9sTm5IoHVcfLSCWH5n6Nr9sH3o2ksyTwxuOAvsN11F/a0mmUoPciYPp+\n"" +
            ""q7DzQzdi7akRG601DZ4YVOwo6UITGvDyuAAdxl5isovUXqe6Jmz2/myTSpAKxGFs\n"" +
            ""jk9oRoG6WXWB1kni490GIPjJ1OceyQIDAQABo1AwTjAdBgNVHQ4EFgQUH1QIlPKL\n"" +
            ""p2OQ/AoLOjKvBW4zK3AwHwYDVR0jBBgwFoAUH1QIlPKLp2OQ/AoLOjKvBW4zK3Aw\n"" +
            ""DAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAcMi4voMMJHeQLjtq8Oky\n"" +
            ""Azpyk8moDwgCd4llcGj7izOkIIFqq/lyqKdtykVKUWz2bSHO5cLrtaOCiBWVlaCV\n"" +
            ""DYAnnVLM8aqaA6hJDIfaGs4zmwz0dY8hVMFCuCBiLWuPfiYtbEmjHGSmpQTG6Qxn\n"" +
            ""ZJlaK5CZyt5pgh5EdNdvQmDEbKGmu0wpCq9qjZImwdyAul1t/B0DrsWApZMgZpeI\n"" +
            ""d2od0VBrCICB1K4p+C51D93xyQiva7xQcCne+TAnGNy9+gjQ/MyR8MRpwRLv5ikD\n"" +
            ""u0anJCN8pXo6IMglfMAsoton1J6o5/ae5uhC6caQU8bNUsCK570gpNfjkzo6rbP0\n"" +
            ""wQ==\n"" +
            ""-----END CERTIFICATE-----"";

    private ComponentName mAdmin;
    private DevicePolicyManager mDpm;
    private UserManager mUm;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final Intent intent = getIntent();
        try {
            // On phones, the test runs on user 0, which is the Device Owner, but on headless system
            // user mode it runs in a different user.
            // Most DPM operations must be set on device owner user, but a few - like adding user
            // restrictions - must be set in the current user.

            boolean useCurrentUserDpm = intent.getBooleanExtra(EXTRA_USE_CURRENT_USER_DPM, false);
            mDpm = useCurrentUserDpm
                    ? getSystemService(DevicePolicyManager.class)
                    : TestAppSystemServiceFactory.getDevicePolicyManager(this,
                            DeviceAdminTestReceiver.class);

            mUm = (UserManager) getSystemService(Context.USER_SERVICE);
            mAdmin = DeviceAdminTestReceiver.getReceiverComponentName();
            final String command = getIntent().getStringExtra(EXTRA_COMMAND);
            Log.i(TAG, ""Command: "" + command);
            switch (command) {
                case COMMAND_SET_USER_RESTRICTION: {
                    String restrictionKey = intent.getStringExtra(EXTRA_USER_RESTRICTION);
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    Log.i(TAG, ""Setting '"" + restrictionKey + ""'="" + enforced + "" using "" + mDpm
                            + "" on user "" + UserHandle.myUserId());
                    if (enforced) {
                        mDpm.addUserRestriction(mAdmin, restrictionKey);
                    } else {
                        mDpm.clearUserRestriction(mAdmin, restrictionKey);
                    }
                } break;
                case COMMAND_DISALLOW_KEYGUARD_UNREDACTED_NOTIFICATIONS: {
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    mDpm.setKeyguardDisabledFeatures(mAdmin, enforced
                            ? DevicePolicyManager.KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS
                            : 0);
                } break;
                case COMMAND_SET_AUTO_TIME_REQUIRED: {
                    mDpm.setAutoTimeRequired(mAdmin,
                            intent.getBooleanExtra(EXTRA_ENFORCED, false));
                    break;
                }
                case COMMAND_SET_LOCK_SCREEN_INFO: {
                    mDpm.setDeviceOwnerLockScreenInfo(mAdmin, intent.getStringExtra(EXTRA_VALUE));
                    break;
                }
                case COMMAND_SET_MAXIMUM_TO_LOCK: {
                    final long timeInSeconds = Long.parseLong(intent.getStringExtra(EXTRA_VALUE));
                    mDpm.setMaximumTimeToLock(mAdmin,
                            TimeUnit.SECONDS.toMillis(timeInSeconds) /* in milliseconds */);
                } break;
                case COMMAND_SET_KEYGUARD_DISABLED: {
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    KeyguardManager km = this.getSystemService(KeyguardManager.class);
                    if (km.isKeyguardSecure()) {
                        Toast.makeText(this, getString(R.string.device_owner_lockscreen_secure),
                                Toast.LENGTH_SHORT).show();
                    } else {
                        mDpm.setKeyguardDisabled(mAdmin, enforced);
                    }
                } break;
                case COMMAND_SET_STATUSBAR_DISABLED: {
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    mDpm.setStatusBarDisabled(mAdmin, enforced);
                } break;
                case COMMAND_SET_LOCK_TASK_FEATURES: {
                    int flags = intent.getIntExtra(EXTRA_VALUE,
                            DevicePolicyManager.LOCK_TASK_FEATURE_NONE);
                    mDpm.setLockTaskFeatures(mAdmin, flags);
                    // If feature HOME is used, we need to allow the current launcher
                    if ((flags & LOCK_TASK_FEATURE_HOME) != 0) {
                        mDpm.setLockTaskPackages(mAdmin,
                                new String[] {getPackageName(), getCurrentLauncherPackage()});
                    } else {
                        mDpm.setLockTaskPackages(mAdmin, new String[] {getPackageName()});
                    }
                } break;
                case COMMAND_ALLOW_ONLY_SYSTEM_INPUT_METHODS: {
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    mDpm.setPermittedInputMethods(mAdmin,
                            enforced ? getEnabledNonSystemImes() : null);
                } break;
                case COMMAND_ALLOW_ONLY_SYSTEM_ACCESSIBILITY_SERVICES: {
                    boolean enforced = intent.getBooleanExtra(EXTRA_ENFORCED, false);
                    mDpm.setPermittedAccessibilityServices(mAdmin,
                            enforced ? new ArrayList() : null);
                } break;
                case COMMAND_SET_GLOBAL_SETTING: {
                    final String setting = intent.getStringExtra(EXTRA_SETTING);
                    final String value = intent.getStringExtra(EXTRA_VALUE);
                    mDpm.setGlobalSetting(mAdmin, setting, value);
                } break;
                case COMMAND_REMOVE_DEVICE_OWNER: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        Log.e(TAG, COMMAND_REMOVE_DEVICE_OWNER + "": "" + getPackageName()
                                + "" is not DO for user "" + UserHandle.myUserId());
                        return;
                    }
                    clearAllPoliciesAndRestrictions();
                    mDpm.clearDeviceOwnerApp(getPackageName());

                    // TODO(b/179100903): temporarily removing PO, should be done automatically
                    if (UserManager.isHeadlessSystemUserMode()) {
                        Log.i(TAG, ""Disabling PO on user "" + UserHandle.myUserId());
                        DevicePolicyManager localDpm = getSystemService(DevicePolicyManager.class);
                        localDpm.clearProfileOwner(mAdmin);
                    }

                } break;
                case COMMAND_REQUEST_BUGREPORT: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    final boolean bugreportStarted = mDpm.requestBugreport(mAdmin);
                    if (!bugreportStarted) {
                        Utils.showBugreportNotification(this, getString(
                                R.string.bugreport_already_in_progress),
                                Utils.BUGREPORT_NOTIFICATION_ID);
                    }
                } break;
                case COMMAND_CLEAR_POLICIES: {
                    int mode = intent.getIntExtra(PolicyTransparencyTestListActivity.EXTRA_MODE,
                            PolicyTransparencyTestListActivity.MODE_DEVICE_OWNER);
                    if (mode == PolicyTransparencyTestListActivity.MODE_DEVICE_OWNER) {
                        if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                            return;
                        }
                        clearAllPoliciesAndRestrictions();
                    } else if (mode == PolicyTransparencyTestListActivity.MODE_MANAGED_PROFILE
                            || mode == PolicyTransparencyTestListActivity.MODE_MANAGED_USER) {
                        if (!mDpm.isProfileOwnerApp(getPackageName())) {
                            return;
                        }
                        clearProfileOwnerRelatedPoliciesAndRestrictions(mode);
                    }
                    // No policies need to be cleared for COMP at the moment.
                } break;
                case COMMAND_SET_USER_ICON: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    int iconRes = intent.getIntExtra(EXTRA_VALUE,
                            com.android.cts.verifier.R.drawable.icon);
                    mDpm.setUserIcon(mAdmin, BitmapFactory.decodeResource(getResources(), iconRes));
                } break;
                case COMMAND_RETRIEVE_NETWORK_LOGS: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setNetworkLoggingEnabled(mAdmin, true);
                    mDpm.retrieveNetworkLogs(mAdmin, 0 /* batchToken */);
                    mDpm.setNetworkLoggingEnabled(mAdmin, false);
                } break;
                case COMMAND_RETRIEVE_SECURITY_LOGS: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setSecurityLoggingEnabled(mAdmin, true);
                    mDpm.retrieveSecurityLogs(mAdmin);
                    mDpm.setSecurityLoggingEnabled(mAdmin, false);
                } break;
                case COMMAND_SET_ORGANIZATION_NAME: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setOrganizationName(mAdmin,
                            intent.getStringExtra(EXTRA_ORGANIZATION_NAME));
                } break;
                case COMMAND_ENABLE_NETWORK_LOGGING: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setNetworkLoggingEnabled(mAdmin, true);
                } break;
                case COMMAND_DISABLE_NETWORK_LOGGING: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setNetworkLoggingEnabled(mAdmin, false);
                } break;
                case COMMAND_INSTALL_HELPER_PACKAGE: {
                    installHelperPackage();
                } break;
                case COMMAND_UNINSTALL_HELPER_PACKAGE: {
                    uninstallHelperPackage();
                } break;
                case COMMAND_SET_PERMISSION_GRANT_STATE: {
                    mDpm.setPermissionGrantState(mAdmin, getPackageName(),
                            intent.getStringExtra(EXTRA_PERMISSION),
                            intent.getIntExtra(EXTRA_GRANT_STATE,
                                    DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT));
                } break;
                case COMMAND_ADD_PERSISTENT_PREFERRED_ACTIVITIES: {
                    final ComponentName componentName =
                            EnterprisePrivacyTestDefaultAppActivity.COMPONENT_NAME;
                    IntentFilter filter;
                    // Camera
                    filter = new IntentFilter();
                    filter.addAction(MediaStore.ACTION_IMAGE_CAPTURE);
                    filter.addAction(MediaStore.ACTION_VIDEO_CAPTURE);
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    // Map
                    filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_VIEW);
                    filter.addDataScheme(""geo"");
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    // E-mail
                    filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_SENDTO);
                    filter.addAction(Intent.ACTION_SEND);
                    filter.addAction(Intent.ACTION_SEND_MULTIPLE);
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    // Calendar
                    filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_INSERT);
                    filter.addDataType(""vnd.android.cursor.dir/event"");
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    // Contacts
                    filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_PICK);
                    filter.addDataType(ContactsContract.Contacts.CONTENT_TYPE);
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    // Dialer
                    filter = new IntentFilter();
                    filter.addAction(Intent.ACTION_DIAL);
                    filter.addAction(Intent.ACTION_CALL);
                    mDpm.addPersistentPreferredActivity(mAdmin, filter, componentName);
                    getPackageManager().setComponentEnabledSetting(componentName,
                            PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                            PackageManager.DONT_KILL_APP);
                } break;
                case COMMAND_CLEAR_PERSISTENT_PREFERRED_ACTIVITIES: {
                    mDpm.clearPackagePersistentPreferredActivities(mAdmin, getPackageName());
                    getPackageManager().setComponentEnabledSetting(
                            EnterprisePrivacyTestDefaultAppActivity.COMPONENT_NAME,
                            PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,
                            PackageManager.DONT_KILL_APP);
                } break;
                case COMMAND_SET_ALWAYS_ON_VPN: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setAlwaysOnVpnPackage(mAdmin, getPackageName(),
                            false /* lockdownEnabled */);
                } break;
                case COMMAND_CLEAR_ALWAYS_ON_VPN: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setAlwaysOnVpnPackage(mAdmin, null /* vpnPackage */,
                            false /* lockdownEnabled */);
                } break;
                case COMMAND_SET_GLOBAL_HTTP_PROXY: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setRecommendedGlobalProxy(mAdmin,
                            ProxyInfo.buildDirectProxy(""example.com"", 123));
                } break;
                case COMMAND_CLEAR_GLOBAL_HTTP_PROXY: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setRecommendedGlobalProxy(mAdmin, null);
                } break;
                case COMMAND_INSTALL_CA_CERT: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.installCaCert(mAdmin, TEST_CA.getBytes());
                } break;
                case COMMAND_CLEAR_CA_CERT: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.uninstallCaCert(mAdmin, TEST_CA.getBytes());
                } break;
                case COMMAND_SET_MAXIMUM_PASSWORD_ATTEMPTS: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setMaximumFailedPasswordsForWipe(mAdmin, 100);
                } break;
                case COMMAND_CLEAR_MAXIMUM_PASSWORD_ATTEMPTS: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setMaximumFailedPasswordsForWipe(mAdmin, 0);
                } break;
                case COMMAND_SET_DEFAULT_IME: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setSecureSetting(mAdmin, Settings.Secure.DEFAULT_INPUT_METHOD,
                            getPackageName());
                } break;
                case COMMAND_CLEAR_DEFAULT_IME: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.setSecureSetting(mAdmin, Settings.Secure.DEFAULT_INPUT_METHOD, null);
                } break;
                case COMMAND_CREATE_MANAGED_USER:{
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    PersistableBundle extras = new PersistableBundle();
                    extras.putBoolean(DeviceAdminTestReceiver.EXTRA_MANAGED_USER_TEST, true);
                    UserHandle userHandle = mDpm.createAndManageUser(mAdmin, ""managed user"", mAdmin,
                            extras,
                            SKIP_SETUP_WIZARD | MAKE_USER_EPHEMERAL);
                    mDpm.setAffiliationIds(mAdmin,
                            Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));
                    mDpm.startUserInBackground(mAdmin, userHandle);
                } break;
                case COMMAND_CREATE_MANAGED_USER_WITHOUT_SETUP:{
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    PersistableBundle extras = new PersistableBundle();
                    extras.putBoolean(DeviceAdminTestReceiver.EXTRA_MANAGED_USER_TEST, true);
                    mDpm.createAndManageUser(mAdmin, ""managed user"", mAdmin, extras, /* flags */ 0);
                } break;
                case COMMAND_REMOVE_SECONDARY_USERS: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    for (UserHandle secondaryUser : mDpm.getSecondaryUsers(mAdmin)) {
                        mDpm.removeUser(mAdmin, secondaryUser);
                    }
                } break;
                case COMMAND_WITH_USER_SWITCHER_MESSAGE: {
                    createAndSwitchUserWithMessage(""Start user session"", ""End user session"");
                } break;
                case COMMAND_WITHOUT_USER_SWITCHER_MESSAGE: {
                    createAndSwitchUserWithMessage(null, null);
                } break;
                case COMMAND_ENABLE_LOGOUT: {
                    if (!mDpm.isDeviceOwnerApp(getPackageName())) {
                        return;
                    }
                    mDpm.addUserRestriction(mAdmin, UserManager.DISALLOW_USER_SWITCH);
                    mDpm.setLogoutEnabled(mAdmin, true);
                    UserHandle userHandle = mDpm.createAndManageUser(mAdmin, ""managed user"", mAdmin,
                            null, SKIP_SETUP_WIZARD | MAKE_USER_EPHEMERAL);
                    mDpm.switchUser(mAdmin, userHandle);
                } break;
                case COMMAND_DISABLE_USB_DATA_SIGNALING: {
                    mDpm.setUsbDataSignalingEnabled(false);
                    break;
                }
                case COMMAND_ENABLE_USB_DATA_SIGNALING: {
                    mDpm.setUsbDataSignalingEnabled(true);
                    break;
                }
                case COMMAND_SET_REQUIRED_PASSWORD_COMPLEXITY: {
                    int complexity = intent.getIntExtra(EXTRA_VALUE,
                            DevicePolicyManager.PASSWORD_COMPLEXITY_NONE);
                    mDpm.setRequiredPasswordComplexity(complexity);
                }
            }
        } catch (Exception e) {
            Log.e(TAG, ""Failed to execute command: "" + intent, e);
        } finally {
            finish();
        }
    }

    private void installHelperPackage() throws Exception {
        LogAndSelfUnregisterBroadcastReceiver.register(this, ACTION_INSTALL_COMPLETE);
        final PackageInstaller packageInstaller = getPackageManager().getPackageInstaller();
        final PackageInstaller.Session session = packageInstaller.openSession(
                packageInstaller.createSession(new PackageInstaller.SessionParams(
                        PackageInstaller.SessionParams.MODE_FULL_INSTALL)));
        final File file = new File(HELPER_APP_LOCATION);
        Log.i(TAG, ""installing helper package from "" + file);
        final InputStream in = new FileInputStream(file);
        final OutputStream out = session.openWrite(""CommandReceiverActivity"", 0, file.length());
        final byte[] buffer = new byte[65536];
        int count;
        while ((count = in.read(buffer)) != -1) {
            out.write(buffer, 0, count);
        }
        session.fsync(out);
        in.close();
        out.close();
        session.commit(PendingIntent
                .getBroadcast(this, 0, new Intent(ACTION_INSTALL_COMPLETE),
                        PendingIntent.FLAG_MUTABLE_UNAUDITED)
                .getIntentSender());
    }

    private void uninstallHelperPackage() {
        LogAndSelfUnregisterBroadcastReceiver.register(this, ACTION_UNINSTALL_COMPLETE);
        PackageInstaller packageInstaller = getPackageManager().getPackageInstaller();
        Log.i(TAG, ""Uninstalling package "" + HELPER_APP_PKG + "" using "" + packageInstaller);
        try {
            packageInstaller.uninstall(HELPER_APP_PKG, PendingIntent.getBroadcast(this,
                    /* requestCode= */ 0, new Intent(ACTION_UNINSTALL_COMPLETE),
                    PendingIntent.FLAG_MUTABLE_UNAUDITED).getIntentSender());
        } catch (IllegalArgumentException e) {
            // The package is not installed: that's fine
        }
    }

    private void clearAllPoliciesAndRestrictions() throws Exception {
        clearProfileOwnerRelatedPolicies();
        clearPolicyTransparencyUserRestriction(
                PolicyTransparencyTestListActivity.MODE_DEVICE_OWNER);

        // There are a few user restrictions that are used, but not for policy transparency
        mDpm.clearUserRestriction(mAdmin, UserManager.DISALLOW_CONFIG_BLUETOOTH);
        mDpm.clearUserRestriction(mAdmin, UserManager.DISALLOW_CONFIG_VPN);
        mDpm.clearUserRestriction(mAdmin, UserManager.DISALLOW_DATA_ROAMING);
        mDpm.clearUserRestriction(mAdmin, UserManager.DISALLOW_USER_SWITCH);

        mDpm.setDeviceOwnerLockScreenInfo(mAdmin, null);
        mDpm.setKeyguardDisabled(mAdmin, false);
        mDpm.setAutoTimeRequired(mAdmin, false);
        mDpm.setStatusBarDisabled(mAdmin, false);
        mDpm.setOrganizationName(mAdmin, null);
        mDpm.setNetworkLoggingEnabled(mAdmin, false);
        mDpm.setSecurityLoggingEnabled(mAdmin, false);
        mDpm.setPermissionGrantState(mAdmin, getPackageName(),
                Manifest.permission.ACCESS_FINE_LOCATION,
                DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT);
        mDpm.setPermissionGrantState(mAdmin, getPackageName(), Manifest.permission.RECORD_AUDIO,
                DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT);
        mDpm.setPermissionGrantState(mAdmin, getPackageName(), Manifest.permission.CAMERA,
                DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT);
        mDpm.clearPackagePersistentPreferredActivities(mAdmin, getPackageName());
        mDpm.setAlwaysOnVpnPackage(mAdmin, null, false);
        mDpm.setRecommendedGlobalProxy(mAdmin, null);
        mDpm.uninstallCaCert(mAdmin, TEST_CA.getBytes());
        mDpm.setMaximumFailedPasswordsForWipe(mAdmin, 0);
        mDpm.setSecureSetting(mAdmin, Settings.Secure.DEFAULT_INPUT_METHOD, null);
        mDpm.setStartUserSessionMessage(mAdmin, null);
        mDpm.setEndUserSessionMessage(mAdmin, null);
        mDpm.setLogoutEnabled(mAdmin, false);

        uninstallHelperPackage();

        // Must wait until package is uninstalled to reset affiliation ids, otherwise the package
        // cannot be removed on headless system user mode (as caller must be an affiliated PO)
        mDpm.setAffiliationIds(mAdmin, Collections.emptySet());

        removeManagedProfile();
        getPackageManager().setComponentEnabledSetting(
                EnterprisePrivacyTestDefaultAppActivity.COMPONENT_NAME,
                PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,
                PackageManager.DONT_KILL_APP);
    }

    private void clearProfileOwnerRelatedPoliciesAndRestrictions(int mode) {
        clearPolicyTransparencyUserRestriction(mode);
        clearProfileOwnerRelatedPolicies();
    }

    private void clearProfileOwnerRelatedPolicies() {
        mDpm.setKeyguardDisabledFeatures(mAdmin, 0);
        mDpm.setPasswordQuality(mAdmin, 0);
        mDpm.setMaximumTimeToLock(mAdmin, 0);
        mDpm.setPermittedAccessibilityServices(mAdmin, null);
        mDpm.setPermittedInputMethods(mAdmin, null);
    }

    private void clearPolicyTransparencyUserRestriction(int mode) {
        for (String userRestriction : UserRestrictions.getUserRestrictionsForPolicyTransparency(
                mode)) {
            mDpm.clearUserRestriction(mAdmin, userRestriction);
        }
    }

    private void removeManagedProfile() {
        for (final UserHandle userHandle : mUm.getUserProfiles()) {
            mDpm.removeUser(mAdmin, userHandle);
        }
    }

    /**
     * Creates an intent to set the given user restriction using the device owner's {@code dpm}.
     */
    public static Intent createSetDeviceOwnerUserRestrictionIntent(String restriction,
            boolean enforced) {
        return createSetUserRestrictionIntent(restriction, enforced, /* currentUserDpm= */ false);
    }

    /**
     * Creates an intent to set the given user restriction using the current user's {@code dpm}.
     */
    public static Intent createSetCurrentUserRestrictionIntent(String restriction,
            boolean enforced) {
        return createSetUserRestrictionIntent(restriction, enforced, /* currentUserDpm= */ true);
    }

    private static Intent createSetUserRestrictionIntent(String restriction, boolean enforced,
            boolean forceCurrentUserDpm) {
        Intent intent = new Intent(ACTION_EXECUTE_COMMAND);
        if (forceCurrentUserDpm) {
            intent.putExtra(EXTRA_USE_CURRENT_USER_DPM, true);
        }
        return intent
                .putExtra(EXTRA_COMMAND, COMMAND_SET_USER_RESTRICTION)
                .putExtra(EXTRA_USER_RESTRICTION, restriction)
                .putExtra(EXTRA_ENFORCED, enforced);
    }

    private List<String> getEnabledNonSystemImes() {
        InputMethodManager inputMethodManager = getSystemService(InputMethodManager.class);
        final List<InputMethodInfo> inputMethods = inputMethodManager.getEnabledInputMethodList();
        return inputMethods.stream()
                .filter(inputMethodInfo -> !isSystemInputMethodInfo(inputMethodInfo))
                .map(inputMethodInfo -> inputMethodInfo.getPackageName())
                .filter(packageName -> !packageName.equals(getPackageName()))
                .distinct()
                .collect(Collectors.toList());
    }

    private boolean isSystemInputMethodInfo(InputMethodInfo inputMethodInfo) {
        final ApplicationInfo applicationInfo = inputMethodInfo.getServiceInfo().applicationInfo;
        return (applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
    }

    private void createAndSwitchUserWithMessage(String startUserSessionMessage,
            String endUserSessionMessage) {
        if (!mDpm.isDeviceOwnerApp(getPackageName())) {
            return;
        }
        mDpm.setStartUserSessionMessage(mAdmin, startUserSessionMessage);
        mDpm.setEndUserSessionMessage(mAdmin, endUserSessionMessage);
        mDpm.setAffiliationIds(mAdmin,
                Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));

        PersistableBundle extras = new PersistableBundle();
        extras.putBoolean(DeviceAdminTestReceiver.EXTRA_LOGOUT_ON_START, true);
        UserHandle userHandle = mDpm.createAndManageUser(mAdmin, ""managed user"", mAdmin,
                extras,
                SKIP_SETUP_WIZARD | MAKE_USER_EPHEMERAL);
        mDpm.switchUser(mAdmin, userHandle);
    }

    private String getCurrentLauncherPackage() {
        ResolveInfo resolveInfo = getPackageManager()
            .resolveActivity(new Intent(Intent.ACTION_MAIN)
                .addCategory(Intent.CATEGORY_HOME), PackageManager.MATCH_DEFAULT_ONLY);
        if (resolveInfo == null || resolveInfo.activityInfo == null) {
            return null;
        }

        return resolveInfo.activityInfo.packageName;
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.telephony.ims.cts.ImsRcsManagerTest"	"testMethodPermissions"	"CtsTelephonyTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsRcsManagerTest.java"	""	"public void testMethodPermissions() throws Exception {
        if (!ImsUtils.shouldTestTelephony()) {
            return;
        }

        // This verifies the permission checking in ITelephony,
        // not the IMS service's behavior.
        // Since SecurityException has the highest priority,
        // DEFAULT_SUBSCRIPTION_ID is enough to check permissions.
        // Though it throws an ImsException, we ignore that.
        if (sTestSub == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
            sTestSub = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsRcsManager rcsManager = imsManager.getImsRcsManager(sTestSub);

        ImsStateCallback callback = new ImsStateCallback() {
            @Override
            public void onUnavailable(int reason) { }
            @Override
            public void onAvailable() { }
            @Override
            public void onError() { }
        };

        try {
            rcsManager.registerImsStateCallback(Runnable::run, callback);
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE, ""
                    + ""ACCESS_RCS_USER_CAPABILITY_EXCHANGE or ""
                    + ""READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        } catch (ImsException ie) {
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE, ""
                    + ""ACCESS_RCS_USER_CAPABILITY_EXCHANGE or ""
                    + ""READ_PRIVILEGED_PHONE_STATE permission."");
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(rcsManager,
                    m -> m.registerImsStateCallback(Runnable::run, callback),
                    ImsException.class, ""android.permission.READ_PRECISE_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (ImsException ignore) {
            // don't care, permission check passed
        }

        try {
            rcsManager.unregisterImsStateCallback(callback);
        } catch (SecurityException e) {
            fail(""uregisterImsStateCallback requires no permission."");
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(rcsManager,
                    m -> m.registerImsStateCallback(Runnable::run, callback),
                    ImsException.class, ""android.permission.ACCESS_RCS_USER_CAPABILITY_EXCHANGE"");
        } catch (SecurityException e) {
            fail(""registerImsStateCallback requires ""
                    + ""ACCESS_RCS_USER_CAPABILITY_EXCHANGE permission."");
        } catch (ImsException ignore) {
            // don't care, permission check passed
        }

        try {
            rcsManager.unregisterImsStateCallback(callback);
        } catch (SecurityException e) {
            // unreachable, already passed permission check
            fail(""uregisterImsStateCallback requires no permission."");
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(rcsManager,
                    m -> m.registerImsStateCallback(Runnable::run, callback),
                    ImsException.class, ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""registerImsStateCallback requires READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (ImsException ignore) {
            // don't care, permission check passed
        }

        try {
            rcsManager.unregisterImsStateCallback(callback);
        } catch (SecurityException e) {
            // unreachable, already passed permission check
            fail(""uregisterImsStateCallback requires no permission."");
        }
    }

    private static Context getContext() {
        return InstrumentationRegistry.getInstrumentation().getContext();
    }
}"	""	""	"android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictingStopReason_Doze"	"CtsJobSchedulerTestCases"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	"public void testRestrictingStopReason_Doze() throws Exception {
        assumeTrue(""device idle not enabled"", mDeviceIdleEnabled);

        toggleDozeState(false);
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_NONE, false);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        toggleDozeState(true);
        assertTrue(""Job did not stop on entering doze"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_DEVICE_STATE,
                mTestAppInterface.getLastParams().getStopReason());
    }

    @After
    public void tearDown() throws Exception {
        AppOpsUtils.reset(TEST_APP_PACKAGE);
        // Lock thermal service to not throttling
        ThermalUtils.overrideThermalNotThrottling();
        if (mDeviceIdleEnabled) {
            toggleDozeState(false);
        }
        mTestAppInterface.cleanup();
        BatteryUtils.runDumpsysBatteryReset();
        BatteryUtils.enableBatterySaver(false);
        removeTestAppFromTempWhitelist();

        // Ensure that we leave WiFi in its previous state.
        if (mHasWifi && mWifiManager.isWifiEnabled() != mInitialWiFiState) {
            try {
                setWifiState(mInitialWiFiState, mCm, mWifiManager);
            } catch (AssertionFailedError e) {
                // Don't fail the test just because wifi state wasn't set in tearDown.
                Log.e(TAG, ""Failed to return wifi state to "" + mInitialWiFiState, e);
            }
        }
        mDeviceConfigStateHelper.restoreOriginalValues();
        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, mInitialRestrictedBucketEnabled);
        if (isAirplaneModeOn() != mInitialAirplaneModeState) {
            setAirplaneMode(mInitialAirplaneModeState);
        }
        mUiDevice.executeShellCommand(
                ""cmd jobscheduler reset-execution-quota -u "" + UserHandle.myUserId()
                        + "" "" + TEST_APP_PACKAGE);

        Settings.System.putString(
                mContext.getContentResolver(), SCREEN_OFF_TIMEOUT, mInitialDisplayTimeout);
    }

    private void setTestPackageRestricted(boolean restricted) throws Exception {
        AppOpsUtils.setOpMode(TEST_APP_PACKAGE, ""RUN_ANY_IN_BACKGROUND"",
                restricted ? AppOpsManager.MODE_IGNORED : AppOpsManager.MODE_ALLOWED);
    }

    private void setRestrictedBucketEnabled(boolean enabled) {
        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, enabled ? ""1"" : ""0"");
    }

    private boolean isTestAppTempWhitelisted() throws Exception {
        final String output = mUiDevice.executeShellCommand(""cmd deviceidle tempwhitelist"").trim();
        for (String line : output.split(""\n"")) {
            if (line.contains(""UID="" + mTestPackageUid)) {
                return true;
            }
        }
        return false;
    }

    private void sendScheduleJobBroadcast(boolean allowWhileIdle) throws Exception {
        mTestAppInterface.scheduleJob(allowWhileIdle, NETWORK_TYPE_NONE, false);
    }

    private void toggleDozeState(final boolean idle) throws Exception {
        mUiDevice.executeShellCommand(""cmd deviceidle "" + (idle ? ""force-idle"" : ""unforce""));
        if (!idle) {
            // Make sure the device doesn't stay idle, even after unforcing.
            mUiDevice.executeShellCommand(""cmd deviceidle motion"");
        }
        assertTrue(""Could not change device idle state to "" + idle,
                waitUntilTrue(SHELL_TIMEOUT, () -> {
                    synchronized (JobThrottlingTest.this) {
                        return mDeviceInDoze == idle;
                    }
                }));
    }

    private void tempWhitelistTestApp(long duration) throws Exception {
        mUiDevice.executeShellCommand(""cmd deviceidle tempwhitelist -d "" + duration
                + "" "" + TEST_APP_PACKAGE);
    }

    private void makeTestPackageIdle() throws Exception {
        mUiDevice.executeShellCommand(""am make-uid-idle --user current "" + TEST_APP_PACKAGE);
    }

    void setTestPackageStandbyBucket(Bucket bucket) throws Exception {
        setTestPackageStandbyBucket(mUiDevice, bucket);
    }

    static void setTestPackageStandbyBucket(UiDevice uiDevice, Bucket bucket) throws Exception {
        final String bucketName;
        switch (bucket) {
            case ACTIVE:
                bucketName = ""active"";
                break;
            case WORKING_SET:
                bucketName = ""working"";
                break;
            case FREQUENT:
                bucketName = ""frequent"";
                break;
            case RARE:
                bucketName = ""rare"";
                break;
            case RESTRICTED:
                bucketName = ""restricted"";
                break;
            case NEVER:
                bucketName = ""never"";
                break;
            default:
                throw new IllegalArgumentException(""Requested unknown bucket "" + bucket);
        }
        uiDevice.executeShellCommand(""am set-standby-bucket "" + TEST_APP_PACKAGE
                + "" "" + bucketName);
    }

    private boolean removeTestAppFromTempWhitelist() throws Exception {
        mUiDevice.executeShellCommand(""cmd deviceidle tempwhitelist -r "" + TEST_APP_PACKAGE);
        return waitUntilTrue(SHELL_TIMEOUT, () -> !isTestAppTempWhitelisted());
    }

    /**
     * Set the screen state.
     */
    private void setScreenState(boolean on) throws Exception {
        if (on) {
            mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
            mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        } else {
            mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        }
        // Wait a little bit to make sure the screen state has changed.
        Thread.sleep(2_000);
    }

    /**
     * Trigger job idle (not device idle);
     */
    private void triggerJobIdle() throws Exception {
        mUiDevice.executeShellCommand(""cmd activity idle-maintenance"");
        // Wait a moment to let that happen before proceeding.
        Thread.sleep(2_000);
    }

    /** Asks (not forces) JobScheduler to run the job if constraints are met. */
    private void runJob() throws Exception {
        // Since connectivity is a functional constraint, calling the ""run"" command without force
        // will only get the job to run if the constraint is satisfied.
        mUiDevice.executeShellCommand(""cmd jobscheduler run -s""
                + "" -u "" + UserHandle.myUserId() + "" "" + TEST_APP_PACKAGE + "" "" + mTestJobId);
    }

    private boolean isAirplaneModeOn() throws IOException {
        final String output =
                mUiDevice.executeShellCommand(""cmd connectivity airplane-mode"").trim();
        return ""enabled"".equals(output);
    }

    private void setAirplaneMode(boolean on) throws Exception {
        final CallbackAsserter airplaneModeBroadcastAsserter = CallbackAsserter.forBroadcast(
                new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
        mUiDevice.executeShellCommand(
                ""cmd connectivity airplane-mode "" + (on ? ""enable"" : ""disable""));
        airplaneModeBroadcastAsserter.assertCalled(""Didn't get airplane mode changed broadcast"",
                15 /* 15 seconds */);
        if (!on && mHasWifi) {
            // Force wifi to connect ASAP.
            mUiDevice.executeShellCommand(""svc wifi enable"");
            //noinspection deprecation
            SystemUtil.runWithShellPermissionIdentity(mWifiManager::reconnect,
                    android.Manifest.permission.NETWORK_SETTINGS);
        }
        waitUntil(""Networks didn't change to "" + (!on ? ""on"" : ""off""), 60 /* seconds */,
                () -> {
                    if (on) {
                        return mCm.getActiveNetwork() == null
                                && (!mHasWifi || !isWiFiConnected(mCm, mWifiManager));
                    } else {
                        return mCm.getActiveNetwork() != null;
                    }
                });
        // Wait some time for the network changes to propagate. Can't use
        // waitUntil(isAirplaneModeOn() == on) because the response quickly gives the new
        // airplane mode status even though the network changes haven't propagated all the way to
        // JobScheduler.
        Thread.sleep(5000);
    }

    private static String unquoteSSID(String ssid) {
        // SSID is returned surrounded by quotes if it can be decoded as UTF-8.
        // Otherwise it's guaranteed not to start with a quote.
        if (ssid.charAt(0) == '""') {
            return ssid.substring(1, ssid.length() - 1);
        } else {
            return ssid;
        }
    }

    private String getWifiSSID() {
        final AtomicReference<String> ssid = new AtomicReference<>();
        SystemUtil.runWithShellPermissionIdentity(() -> {
            ssid.set(mWifiManager.getConnectionInfo().getSSID());
        }, Manifest.permission.ACCESS_FINE_LOCATION);
        return unquoteSSID(ssid.get());
    }

    // Returns ""true"", ""false"" or ""none""
    private String getWifiMeteredStatus(String ssid) {
        // Interestingly giving the SSID as an argument to list wifi-networks
        // only works iff the network in question has the ""false"" policy.
        // Also unfortunately runShellCommand does not pass the command to the interpreter
        // so it's not possible to | grep the ssid.
        final String command = ""cmd netpolicy list wifi-networks"";
        final String policyString = SystemUtil.runShellCommand(command);

        final Matcher m = Pattern.compile(""^"" + ssid + "";(true|false|none)$"",
                Pattern.MULTILINE | Pattern.UNIX_LINES).matcher(policyString);
        if (!m.find()) {
            fail(""Unexpected format from cmd netpolicy (when looking for "" + ssid + ""): ""
                    + policyString);
        }
        return m.group(1);
    }

    private void setWifiMeteredState(boolean metered) throws Exception {
        if (metered) {
            // Make sure unmetered cellular networks don't interfere.
            setAirplaneMode(true);
            setWifiState(true, mCm, mWifiManager);
        }
        final String ssid = getWifiSSID();
        setWifiMeteredState(ssid, metered ? ""true"" : ""false"");
    }

    // metered should be ""true"", ""false"" or ""none""
    private void setWifiMeteredState(String ssid, String metered) {
        if (metered.equals(getWifiMeteredStatus(ssid))) {
            return;
        }
        SystemUtil.runShellCommand(""cmd netpolicy set metered-network "" + ssid + "" "" + metered);
        assertEquals(getWifiMeteredStatus(ssid), metered);
    }

    private String getJobState() throws Exception {
        return mUiDevice.executeShellCommand(""cmd jobscheduler get-job-state --user cur ""
                + TEST_APP_PACKAGE + "" "" + mTestJobId).trim();
    }

    private void assertJobWaiting() throws Exception {
        String state = getJobState();
        assertTrue(""Job unexpectedly not waiting, in state: "" + state, state.contains(""waiting""));
    }

    private void assertJobNotReady() throws Exception {
        String state = getJobState();
        assertFalse(""Job unexpectedly ready, in state: "" + state, state.contains(""ready""));
    }

    private void assertJobReady() throws Exception {
        String state = getJobState();
        assertTrue(""Job unexpectedly not ready, in state: "" + state, state.contains(""ready""));
    }

    private boolean waitUntilTrue(long maxWait, Condition condition) throws Exception {
        final long deadLine = SystemClock.uptimeMillis() + maxWait;
        do {
            Thread.sleep(POLL_INTERVAL);
        } while (!condition.isTrue() && SystemClock.uptimeMillis() < deadLine);
        return condition.isTrue();
    }

    private interface Condition {
        boolean isTrue() throws Exception;
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.SplitPermissionsSystemTest"	"getSplitPermissions"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SplitPermissionsSystemTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_COARSE_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.Manifest.permission.ACCESS_MEDIA_LOCATION;
import static android.Manifest.permission.BLUETOOTH;
import static android.Manifest.permission.BLUETOOTH_ADMIN;
import static android.Manifest.permission.BLUETOOTH_CONNECT;
import static android.Manifest.permission.BLUETOOTH_SCAN;
import static android.Manifest.permission.READ_CALL_LOG;
import static android.Manifest.permission.READ_CONTACTS;
import static android.Manifest.permission.READ_EXTERNAL_STORAGE;
import static android.Manifest.permission.READ_PHONE_STATE;
import static android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE;
import static android.Manifest.permission.WRITE_CALL_LOG;
import static android.Manifest.permission.WRITE_CONTACTS;
import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertEquals;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.os.Build;
import android.permission.PermissionManager;
import android.permission.PermissionManager.SplitPermissionInfo;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.ApiLevelUtil;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@RunWith(AndroidJUnit4.class)
public class SplitPermissionsSystemTest {

    private static final int NO_TARGET = Build.VERSION_CODES.CUR_DEVELOPMENT + 1;

    private List<SplitPermissionInfo> mSplitPermissions;

    @Before
    public void before() {
        Context context = InstrumentationRegistry.getContext();
        PermissionManager permissionManager = (PermissionManager) context.getSystemService(
                Context.PERMISSION_SERVICE);
        mSplitPermissions = permissionManager.getSplitPermissions();
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.SplitPermissionsSystemTest"	"getSplitPermission"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SplitPermissionsSystemTest.java"	""	"public void validateAndroidSystem() {
        assumeTrue(ApiLevelUtil.isAtLeast(Build.VERSION_CODES.Q));

        Set<SplitPermissionInfo> seenSplits = new HashSet<>(6);

        for (SplitPermissionInfo split : mSplitPermissions) {
            String splitPermission = split.getSplitPermission();
            boolean isAndroid = splitPermission.startsWith(""android"");

            if (!isAndroid) {
                continue;
            }

            assertThat(seenSplits).doesNotContain(split);
            seenSplits.add(split);

            List<String> newPermissions = split.getNewPermissions();

            switch (splitPermission) {
                case ACCESS_FINE_LOCATION:
                    // Q declares multiple for ACCESS_FINE_LOCATION, so assert both exist
                    if (newPermissions.contains(ACCESS_COARSE_LOCATION)) {
                        assertSplit(split, NO_TARGET, ACCESS_COARSE_LOCATION);
                    } else {
                        assertSplit(split, Build.VERSION_CODES.Q, ACCESS_BACKGROUND_LOCATION);
                    }
                    break;
                case WRITE_EXTERNAL_STORAGE:
                    assertSplit(split, NO_TARGET, READ_EXTERNAL_STORAGE);
                    break;
                case READ_CONTACTS:
                    assertSplit(split, Build.VERSION_CODES.JELLY_BEAN, READ_CALL_LOG);
                    break;
                case WRITE_CONTACTS:
                    assertSplit(split, Build.VERSION_CODES.JELLY_BEAN, WRITE_CALL_LOG);
                    break;
                case ACCESS_COARSE_LOCATION:
                    assertSplit(split, Build.VERSION_CODES.Q, ACCESS_BACKGROUND_LOCATION);
                    break;
                case READ_EXTERNAL_STORAGE:
                    assertSplit(split, Build.VERSION_CODES.Q, ACCESS_MEDIA_LOCATION);
                    break;
                case READ_PRIVILEGED_PHONE_STATE:
                    assertSplit(split, NO_TARGET, READ_PHONE_STATE);
                    break;
                case BLUETOOTH_CONNECT:
                    // STOPSHIP(b/184180558): replace with ""S"" once SDK is finalized
                    assertSplit(split, Build.VERSION_CODES.R + 1, BLUETOOTH, BLUETOOTH_ADMIN);
                    break;
                case BLUETOOTH_SCAN:
                    // STOPSHIP(b/184180558): replace with ""S"" once SDK is finalized
                    assertSplit(split, Build.VERSION_CODES.R + 1, BLUETOOTH, BLUETOOTH_ADMIN);
                    break;
            }
        }

        assertEquals(13, seenSplits.size());
    }

    private void assertSplit(SplitPermissionInfo split, int targetSdk, String... permission) {
        assertThat(split.getNewPermissions()).containsExactlyElementsIn(permission);
        assertThat(split.getTargetSdk()).isEqualTo(targetSdk);
    }
}"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.content.pm.cts.PackageManagerTest"	"testGetInstalledPackages"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	"public void testGetInstalledPackages() throws Exception {
        List<PackageInfo> pkgs = mPackageManager.getInstalledPackages(GET_META_DATA
                | GET_PERMISSIONS | GET_ACTIVITIES | GET_PROVIDERS | GET_SERVICES | GET_RECEIVERS);

        PackageInfo pkgInfo = findPackageOrFail(pkgs, PACKAGE_NAME);
        assertTestPackageInfo(pkgInfo);
    }

    /**
     * Asserts that the pkgInfo object correctly describes the {@link #PACKAGE_NAME} package.
     */
    private void assertTestPackageInfo(PackageInfo pkgInfo) {
        // Check metadata
        ApplicationInfo appInfo = pkgInfo.applicationInfo;
        assertEquals(APPLICATION_NAME, appInfo.name);
        assertEquals(""Android TestCase"", appInfo.loadLabel(mPackageManager));
        assertEquals(PACKAGE_NAME, appInfo.packageName);
        assertTrue(appInfo.enabled);
        // The process name defaults to the package name when not set.
        assertEquals(PACKAGE_NAME, appInfo.processName);
        assertEquals(0, appInfo.flags & FLAG_SYSTEM);
        assertEquals(FLAG_INSTALLED, appInfo.flags & FLAG_INSTALLED);
        assertEquals(FLAG_HAS_CODE, appInfo.flags & FLAG_HAS_CODE);

        // Check required permissions
        List<String> requestedPermissions = Arrays.asList(pkgInfo.requestedPermissions);
        assertThat(requestedPermissions).containsAtLeast(
                ""android.permission.MANAGE_ACCOUNTS"",
                ""android.permission.ACCESS_NETWORK_STATE"",
                ""android.content.cts.permission.TEST_GRANTED"");

        // Check usesPermissionFlags
        for (int i = 0; i < pkgInfo.requestedPermissions.length; i++) {
            final String name = pkgInfo.requestedPermissions[i];
            final int flags = pkgInfo.requestedPermissionsFlags[i];
            final boolean neverForLocation = (flags
                    & PackageInfo.REQUESTED_PERMISSION_NEVER_FOR_LOCATION) != 0;
            if (""android.content.cts.permission.TEST_GRANTED"".equals(name)) {
                assertTrue(name + "" with flags "" + flags, neverForLocation);
            } else {
                assertFalse(name + "" with flags "" + flags, neverForLocation);
            }
        }

        // Check declared permissions
        PermissionInfo declaredPermission = (PermissionInfo) findPackageItemOrFail(
                pkgInfo.permissions, CALL_ABROAD_PERMISSION_NAME);
        assertEquals(""Call abroad"", declaredPermission.loadLabel(mPackageManager));
        assertEquals(PERMISSIONGROUP_NAME, declaredPermission.group);
        assertEquals(PermissionInfo.PROTECTION_NORMAL, declaredPermission.protectionLevel);

        // Check if number of activities in PackageInfo matches number of activities in manifest,
        // to make sure no synthesized activities not in the manifest are returned.
        assertEquals(""Number of activities in manifest != Number of activities in PackageInfo"",
                NUM_OF_ACTIVITIES_IN_MANIFEST, pkgInfo.activities.length);
        // Check activities
        ActivityInfo activity = findPackageItemOrFail(pkgInfo.activities, ACTIVITY_NAME);
        assertTrue(activity.enabled);
        assertTrue(activity.exported); // Has intent filters - export by default.
        assertEquals(PACKAGE_NAME, activity.taskAffinity);
        assertEquals(ActivityInfo.LAUNCH_SINGLE_TOP, activity.launchMode);

        // Check services
        ServiceInfo service = findPackageItemOrFail(pkgInfo.services, SERVICE_NAME);
        assertTrue(service.enabled);
        assertTrue(service.exported); // Has intent filters - export by default.
        assertEquals(PACKAGE_NAME, service.packageName);
        assertEquals(CALL_ABROAD_PERMISSION_NAME, service.permission);

        // Check ContentProviders
        ProviderInfo provider = findPackageItemOrFail(pkgInfo.providers, PROVIDER_NAME);
        assertTrue(provider.enabled);
        assertFalse(provider.exported); // Don't export by default.
        assertEquals(PACKAGE_NAME, provider.packageName);
        assertEquals(""ctstest"", provider.authority);

        // Check Receivers
        ActivityInfo receiver = findPackageItemOrFail(pkgInfo.receivers, RECEIVER_NAME);
        assertTrue(receiver.enabled);
        assertTrue(receiver.exported); // Has intent filters - export by default.
        assertEquals(PACKAGE_NAME, receiver.packageName);
    }

    // Tests that other packages can be queried."	""	""	"android.permission.ACCESS"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.BackgroundPermissionsTest"	"uninstallTestApp"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/BackgroundPermissionsTest.java"	""	"/*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_COARSE_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.app.AppOpsManager.MODE_ALLOWED;
import static android.app.AppOpsManager.MODE_FOREGROUND;
import static android.app.AppOpsManager.MODE_IGNORED;
import static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;
import static android.content.pm.PermissionInfo.PROTECTION_INTERNAL;
import static android.permission.cts.PermissionUtils.getAppOp;
import static android.permission.cts.PermissionUtils.grantPermission;
import static android.permission.cts.PermissionUtils.install;
import static android.permission.cts.PermissionUtils.uninstallApp;

import static com.android.compatibility.common.util.SystemUtil.eventually;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PermissionInfo;
import android.platform.test.annotations.AppModeFull;
import android.util.ArrayMap;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class BackgroundPermissionsTest {
    private static final String LOG_TAG = BackgroundPermissionsTest.class.getSimpleName();

    /** The package name of all apps used in the test */
    private static final String APP_PKG = ""android.permission.cts.appthatrequestpermission"";

    private static final String TMP_DIR = ""/data/local/tmp/cts/permissions/"";
    private static final String APK_LOCATION_BACKGROUND_29 =
            TMP_DIR + ""CtsAppThatRequestsLocationAndBackgroundPermission29.apk"";
    private static final String APK_LOCATION_29v4 =
            TMP_DIR + ""CtsAppThatRequestsLocationPermission29v4.apk"";

    private static final Context sContext =
            InstrumentationRegistry.getInstrumentation().getTargetContext();
    private static final UiAutomation sUiAutomation =
            InstrumentationRegistry.getInstrumentation().getUiAutomation();

    @After
    public void uninstallTestApp() {
        uninstallApp(APP_PKG);
    }"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.BackgroundPermissionsTest"	"appOpIsSetIfOnlyFineLocPermIsGranted"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/BackgroundPermissionsTest.java"	""	"@AppModeFull(reason = ""Instant apps cannot read properties of other packages which is needed ""
            + ""to grant permissions to them. Also instant apps are never updated, hence the test ""
            + ""is useless."")
    public void appOpIsSetIfOnlyFineLocPermIsGranted() {
        install(APK_LOCATION_BACKGROUND_29);
        sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_FINE_LOCATION);

        // Wait until the system sets the app-op automatically
        // Fine location uses background location to limit access
        eventually(() -> assertWithMessage(""loc app-op"").that(
                getAppOp(APP_PKG, ACCESS_COARSE_LOCATION)).isEqualTo(MODE_FOREGROUND));
    }

    /**
     * Make sure location switch-op is set if fine location with background access is granted.
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.BackgroundPermissionsTest"	"appOpIsSetIfFineAndBgLocPermIsGranted"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/BackgroundPermissionsTest.java"	""	"@AppModeFull(reason = ""Instant apps cannot read properties of other packages which is needed ""
            + ""to grant permissions to them. Also instant apps are never updated, hence the test ""
            + ""is useless."")
    public void appOpIsSetIfFineAndBgLocPermIsGranted() {
        install(APK_LOCATION_BACKGROUND_29);
        sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_FINE_LOCATION);
        sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_BACKGROUND_LOCATION);

        // Wait until the system sets the app-op automatically
        eventually(() -> assertWithMessage(""loc app-op"").that(
                getAppOp(APP_PKG, ACCESS_COARSE_LOCATION)).isEqualTo(MODE_ALLOWED));
    }

    /**
     * Make sure location switch-op is set if fine and coarse location access is granted.
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.BackgroundPermissionsTest"	"appOpIsSetIfFineAndCoarseLocPermIsGranted"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/BackgroundPermissionsTest.java"	""	"@AppModeFull(reason = ""Instant apps cannot read properties of other packages which is needed ""
            + ""to grant permissions to them. Also instant apps are never updated, hence the test ""
            + ""is useless."")
    public void appOpIsSetIfFineAndCoarseLocPermIsGranted() {
        install(APK_LOCATION_BACKGROUND_29);
        sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_FINE_LOCATION);
        sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_COARSE_LOCATION);

        // Wait until the system sets the app-op automatically
        eventually(() -> assertWithMessage(""loc app-op"").that(
                getAppOp(APP_PKG, ACCESS_COARSE_LOCATION)).isEqualTo(MODE_FOREGROUND));
    }

    /**
     * Make sure location switch-op is set if fine and coarse location with background access is
     * granted.
     */"	""	""	"ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
"7.4.3  . Bluetooth"	"7.4.3"	"C-6-2"	"7.4.3/C-6-2"	"07040300.670602"	"""C-6-2] MUST gate Bluetooth access behind the android.permission.ACCESS_FINE_LOCATION. <h4 id=""744_near-field_communications"" """	""	""	"ACCESS_FINE_LOCATION BluetoothRestrictionTest android.permission.ACCESS"	""	""	""	""	""	""	""	""	"android.permission.cts.BackgroundPermissionsTest"	"appOpIsSetIfFineCoarseAndBgLocPermIsGranted"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/BackgroundPermissionsTest.java"	""	"@AppModeFull(reason = ""Instant apps cannot read properties of other packages which is needed ""
            + ""to grant permissions to them. Also instant apps are never updated, hence the test ""
            + ""is useless."")
    public void appOpIsSetIfFineCoarseAndBgLocPermIsGranted() {
        install(APK_LOCATION_BACKGROUND_29);
        sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_FINE_LOCATION);
        sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_COARSE_LOCATION);
        sUiAutomation.grantRuntimePermission(APP_PKG, ACCESS_BACKGROUND_LOCATION);

        // Wait until the system sets the app-op automatically
        eventually(() -> assertWithMessage(""loc app-op"").that(
                getAppOp(APP_PKG, ACCESS_COARSE_LOCATION)).isEqualTo(MODE_ALLOWED));
    }
}"	""	""	"ACCESS_FINE_LOCATION ACCESS_FINE_LOCATION"	""	""	""	""	""	""	""	""	""	""
