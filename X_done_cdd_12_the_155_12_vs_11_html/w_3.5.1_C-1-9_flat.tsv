"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testSoftErrorRetriesActiveApp"	""	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	"@FlakyTest
    public void testSoftErrorRetriesActiveApp() throws Exception {
        removeAllAccounts();

        // Let the initial sync happen.
        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        writeSyncConfig(2, 1, 2, 3);

        clearSyncInvocations(APP1_PACKAGE);

        AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_ACTIVE);

        // Set soft error.
        mRpc.invoke(APP1_PACKAGE, rb ->
                rb.setSetResult(SetResult.newBuilder().setResult(Result.SOFT_ERROR)));

        Bundle b = makeBundle(
                ""testSoftErrorRetriesActiveApp"", true,
                ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);

        ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);

        // First sync + 3 retries == 4, so should be called more than 4 times.
        // But it's active, so it should retry more than that.
        waitUntil(""Should retry more than 3 times."", DEFAULT_TIMEOUT_SECONDS, () -> {
            final Response res = mRpc.invoke(APP1_PACKAGE,
                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
            final int calls = res.getSyncInvocations().getSyncInvocationsCount();
            Log.i(TAG, ""NumSyncInvocations="" + calls);
            return calls > 4; // Arbitrarily bigger than 4.
        });
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testExpeditedJobSync"	""	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	"public void testExpeditedJobSync() throws Exception {
        setDozeState(false);
        removeAllAccounts();

        // Let the initial sync happen.
        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        writeSyncConfig(2, 1, 2, 3);

        clearSyncInvocations(APP1_PACKAGE);

        AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_RARE);

        Bundle b = makeBundle(ContentResolver.SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB, true,
                ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);

        ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);

        waitUntil(""Expedited job sync didn't run in Doze"", 30, () -> {
            final Response res = mRpc.invoke(APP1_PACKAGE,
                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
            final int calls = res.getSyncInvocations().getSyncInvocationsCount();
            Log.i(TAG, ""NumSyncInvocations="" + calls);
            return calls == 1;
        });
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testExpeditedJobSync_InDoze"	""	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	"public void testExpeditedJobSync_InDoze() throws Exception {
        assumeTrue(isDozeFeatureEnabled());

        setDozeState(false);
        removeAllAccounts();

        // Let the initial sync happen.
        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        writeSyncConfig(2, 1, 2, 3);

        clearSyncInvocations(APP1_PACKAGE);

        AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_RARE);

        setDozeState(true);
        Bundle b = makeBundle(ContentResolver.SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB, true,
                ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);

        ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);

        waitUntil(""Expedited job sync should still run in Doze"", 30, () -> {
            final Response res = mRpc.invoke(APP1_PACKAGE,
                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
            final int calls = res.getSyncInvocations().getSyncInvocationsCount();
            Log.i(TAG, ""NumSyncInvocations="" + calls);
            return calls == 1;
        });
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testInitialSyncInNeverBucket"	""	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	"public void testInitialSyncInNeverBucket() throws Exception {
        removeAllAccounts();

        AmUtils.setStandbyBucket(APP1_PACKAGE, STANDBY_BUCKET_NEVER);

        mRpc.invoke(APP1_PACKAGE, rb -> rb.setClearSyncInvocations(
                ClearSyncInvocations.newBuilder()));

        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        // App should be brought out of the NEVER bucket to handle the sync
        assertTrue(""Standby bucket should be WORKING_SET or better"",
                AmUtils.getStandbyBucket(APP1_PACKAGE)
                        <= UsageStatsManager.STANDBY_BUCKET_WORKING_SET);

        // Check the sync request parameters.
        Response res = mRpc.invoke(APP1_PACKAGE,
                rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
        assertEquals(1, res.getSyncInvocations().getSyncInvocationsCount());

        SyncInvocation si = res.getSyncInvocations().getSyncInvocations(0);

        assertEquals(ACCOUNT_1_A.name, si.getAccountName());
        assertEquals(ACCOUNT_1_A.type, si.getAccountType());
        assertEquals(APP1_AUTHORITY, si.getAuthority());

        Bundle extras = ParcelUtils.fromBytes(si.getExtras().toByteArray());
        assertTrue(extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE));
    }

    private static boolean isDozeFeatureEnabled() {
        final String output = ShellUtils.runShellCommand(""cmd deviceidle enabled deep"").trim();
        return Integer.parseInt(output) != 0;
    }

    private void setDozeState(final boolean on) throws Exception {
        ShellUtils.runShellCommand(""cmd deviceidle "" + (on ? ""force-idle"" : ""unforce""));
        if (!on) {
            // Make sure the device doesn't stay idle, even after unforcing.
            ShellUtils.runShellCommand(""cmd deviceidle motion"");
        }
        final PowerManager powerManager =
                InstrumentationRegistry.getContext().getSystemService(PowerManager.class);
        waitUntil(""Doze mode didn't change to "" + (on ? ""on"" : ""off""), 10,
                () -> powerManager.isDeviceIdleMode() == on);
    }

    // WIP This test doesn't work yet.
//"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testSoftErrorRetriesFrequentApp"	""	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	"//    public void testSoftErrorRetriesFrequentApp() throws Exception {
//        runTest(() -> {
//            removeAllAccounts();
//
//            // Let the initial sync happen.
//            addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);
//
//            writeSyncConfig(2, 1, 2, 3);
//
//            clearSyncInvocations(APP1_PACKAGE);
//
//            AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_FREQUENT);
//
//            // Set soft error.
//            mRpc.invoke(APP1_PACKAGE, rb ->
//                    rb.setSetResult(SetResult.newBuilder().setResult(Result.SOFT_ERROR)));
//
//            Bundle b = makeBundle(
//                    ""testSoftErrorRetriesFrequentApp"", true,
//                    ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
//
//            ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);
//
//            waitUntil(""Should retry more than 3 times."", () -> {
//                final Response res = mRpc.invoke(APP1_PACKAGE,
//                        rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
//                final int calls =  res.getSyncInvocations().getSyncInvocationsCount();
//                Log.i(TAG, ""NumSyncInvocations="" + calls);
//                return calls >= 4; // First sync + 3 retries == 4, so at least 4 times.
//            });
//
//            Thread.sleep(10_000);
//
//            // One more retry is okay because of how the job scheduler throttle jobs, but no further.
//            final Response res = mRpc.invoke(APP1_PACKAGE,
//                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
//            final int calls =  res.getSyncInvocations().getSyncInvocationsCount();
//            assertTrue(""# of syncs must be equal or less than 5, but was "" + calls, calls <= 5);
//        });
//    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.dumpsys.cts.StoragedDumpsysTest"	"testStoragedOutput"	"CtsDumpsysHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/dumpsys/src/android/dumpsys/cts/StoragedDumpsysTest.java"	""	"public void testStoragedOutput() throws Exception {
        String result = mDevice.executeShellCommand(""stat /proc/uid_io/stats"");
        if(result.contains(""No such file or directory"")) {
            return;
        }

        if (mDevice.getAppPackageInfo(DEVICE_SIDE_TEST_APK) != null) {
            getDevice().uninstallPackage(DEVICE_SIDE_TEST_PACKAGE);
        }

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        mDevice.installPackage(buildHelper.getTestFile(DEVICE_SIDE_TEST_APK), true);

        mDevice.executeShellCommand(""dumpsys storaged --force"");

        String logcatDate = getCurrentLogcatDate();

        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE,
                ""com.android.server.cts.storaged.StoragedTest"",
                ""testBackgroundIO"");
        String log = mDevice.executeAdbCommand(
                ""logcat"", ""-v"", ""brief"", ""-d"", ""-t"", logcatDate,
                ""SimpleIOService:I"", ""*:S"");
        String serviceCgroup = getCgroupFromLog(log);
        if (serviceCgroup != null && serviceCgroup.equals(""/top"")) {
            System.out.println(""WARNING: Service was not in the correct cgroup; ActivityManager may be unresponsive."");
        }

        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE,
                ""com.android.server.cts.storaged.StoragedTest"",
                ""testForegroundIO"");

        String output = mDevice.executeShellCommand(""dumpsys storaged --force --hours 0.01"");
        assertNotNull(output);
        assertTrue(output.length() > 0);

        boolean hasTestIO = false;
        try (BufferedReader reader = new BufferedReader(
                new StringReader(output))) {

            String line;
            String[] parts;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty()) {
                    continue;
                }

                if (line.contains("","")) {
                    parts = line.split("","");
                    assertTrue(parts.length == 2);
                    if (!parts[0].isEmpty()) {
                        assertInteger(parts[0]);
                    }
                    assertInteger(parts[1]);
                    continue;
                }

                parts = line.split("" "");
                assertTrue(parts.length == 9);
                for (int i = 1; i < parts.length; i++) {
                    assertInteger(parts[i]);
                }

                if (parts[0].equals(DEVICE_SIDE_TEST_PACKAGE)) {
                    /*
                     * order of parts in StoragedService::dumpUidRecords
                     *  [0] DEVICE_SIDE_TEST_PACKAGE
                     *  [1] read foreground charger_off
                     *  [2] write foreground charger_off
                     *  [3] read background charger_off
                     *  [4] write background charger_off
                     *  [5] read foreground charger_on
                     *  [6] write foreground charger_on
                     *  [7] read background charger_on
                     *  [8] write background charger_on
                     */
                    if ((Integer.parseInt(parts[6]) >= 8192 && Integer.parseInt(parts[8]) == 0) ||
                        (Integer.parseInt(parts[2]) >= 8192 && Integer.parseInt(parts[4]) == 0)) {
                        System.out.print(""WARNING: Background I/O was attributed to the ""
                                + ""foreground. This could indicate a broken or malfunctioning ""
                                + ""ActivityManager or UsageStatsService.\n"");
                    } else if ((Integer.parseInt(parts[2]) >= 4096 && Integer.parseInt(parts[4]) >= 4096) ||
                                    Integer.parseInt(parts[4]) >= 8192) {
                        System.out.print(""WARNING: charger on I/O was attributed to ""
                                + ""charger off. This could indicate a broken or malfunctioning ""
                                + ""ADB USB connection, or device that refuses to charge at the ""
                                + ""typical 500mA because it is less than 0.05C.\n"");
                    } else {
                        assertTrue((Integer.parseInt(parts[6]) >= 4096 && Integer.parseInt(parts[8]) >= 4096) ||
                                    Integer.parseInt(parts[8]) >= 8192);
                    }
                    hasTestIO = true;
                }
            }

            assertTrue(hasTestIO);
        }
    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"com.android.cts.profileowner.AppUsageObserverTest"	"testAppUsageObserver_MinTimeLimit"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ProfileOwner/src/com/android/cts/profileowner/AppUsageObserverTest.java"	""	"public void testAppUsageObserver_MinTimeLimit() throws Exception {
        final String[] packages = {""not.real.package.name""};
        final int obsId = 0;
        UsageStatsManager usm = mContext.getSystemService(UsageStatsManager.class);

        Intent intent = new Intent(Intent.ACTION_MAIN);
        PendingIntent pendingIntent = PendingIntent.getActivity(
                InstrumentationRegistry.getContext(),
                1, intent, PendingIntent.FLAG_MUTABLE_UNAUDITED);

        usm.registerAppUsageObserver(obsId, packages, 60, TimeUnit.SECONDS, pendingIntent);
        usm.unregisterAppUsageObserver(obsId);
        try {
            usm.registerAppUsageObserver(obsId, packages, 59, TimeUnit.SECONDS, pendingIntent);
            fail(""Should have thrown an IllegalArgumentException"");
        } catch (IllegalArgumentException expected) {
            // Do nothing. Exception is expected.
        }
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"com.android.cts.profileowner.AppUsageObserverTest"	"testUsageSessionObserver_MinTimeLimit"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ProfileOwner/src/com/android/cts/profileowner/AppUsageObserverTest.java"	""	"public void testUsageSessionObserver_MinTimeLimit() throws Exception {
        final String[] packages = {""not.real.package.name""};
        final int obsId = 0;
        UsageStatsManager usm = mContext.getSystemService(UsageStatsManager.class);

        Intent intent = new Intent(Intent.ACTION_MAIN);
        PendingIntent pendingIntent = PendingIntent.getActivity(
                InstrumentationRegistry.getContext(),
                1, intent, PendingIntent.FLAG_MUTABLE_UNAUDITED);

        usm.registerUsageSessionObserver(obsId, packages, Duration.ofSeconds(60),
                Duration.ofSeconds(10), pendingIntent, null);
        usm.unregisterUsageSessionObserver(obsId);
        try {
            usm.registerUsageSessionObserver(obsId, packages, Duration.ofSeconds(59),
                    Duration.ofSeconds(10), pendingIntent, null);
            fail(""Should have thrown an IllegalArgumentException"");
        } catch (IllegalArgumentException expected) {
            // Do nothing. Exception is expected.
        }
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"com.android.cts.profileowner.AppUsageObserverTest"	"testObserverLimit"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ProfileOwner/src/com/android/cts/profileowner/AppUsageObserverTest.java"	""	"public void testObserverLimit() throws Exception {
        final String[] packages = {""not.real.package.name""};
        UsageStatsManager usm = mContext.getSystemService(UsageStatsManager.class);

        Intent intent = new Intent(Intent.ACTION_MAIN);
        PendingIntent pendingIntent = PendingIntent.getActivity(
                InstrumentationRegistry.getContext(),
                1, intent, PendingIntent.FLAG_MUTABLE_UNAUDITED);

        // Register too many AppUsageObservers
        for (int obsId = 0; obsId < OBSERVER_LIMIT; obsId++) {
            usm.registerAppUsageObserver(obsId, packages, 60, TimeUnit.MINUTES, pendingIntent);
        }
        try {
            usm.registerAppUsageObserver(OBSERVER_LIMIT, packages, 60, TimeUnit.MINUTES,
                    pendingIntent);
            fail(""Should have thrown an IllegalStateException"");
        } catch (IllegalStateException expected) {
            // Do nothing. Exception is expected.
        }

        // Register too many UsageSessionObservers.
        for (int obsId = 0; obsId < OBSERVER_LIMIT; obsId++) {
            usm.registerUsageSessionObserver(obsId, packages, Duration.ofSeconds(60),
                    Duration.ofSeconds(10), pendingIntent, null);
        }
        try {
            usm.registerUsageSessionObserver(OBSERVER_LIMIT, packages, Duration.ofSeconds(60),
                    Duration.ofSeconds(10), pendingIntent, null);
            fail(""Should have thrown an IllegalStateException"");
        } catch (IllegalStateException expected) {
            // Do nothing. Exception is expected.
        }

        for (int obsId = 0; obsId < OBSERVER_LIMIT; obsId++) {
            usm.unregisterAppUsageObserver(obsId);
        }

        for (int obsId = 0; obsId < OBSERVER_LIMIT; obsId++) {
            usm.unregisterUsageSessionObserver(obsId);
        }
    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.AppIdleHostTest"	"testAppIsNotIdleAfterBeingLaunched"	"CtsAppUsageHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/usage/src/android/app/usage/cts/AppIdleHostTest.java"	""	"public void testAppIsNotIdleAfterBeingLaunched() throws Exception {
        startAndStopTestApp();
        assertFalse(isAppIdle(TEST_APP_PACKAGE));
    }

    private void setAppStandbyBucket(String packageName, int bucket) throws Exception {
        mDevice.executeShellCommand(
                String.format(""am set-standby-bucket %s %s"", packageName, bucket));
    }

    private boolean isAppStandbyEnabled() throws DeviceNotAvailableException {
        final String result = mDevice.executeShellCommand(
                ""dumpsys usagestats is-app-standby-enabled"").trim();
        return Boolean.parseBoolean(result);
    }

    private int getAppStandbyBucket(String packageName) throws Exception {
        String bucketString = mDevice.executeShellCommand(
                String.format(""am get-standby-bucket %s"", packageName));
        try {
            return Integer.parseInt(bucketString.trim());
        } catch (NumberFormatException nfe) {
        }
        return -1;
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.ExactAlarmsTest"	"removeFromWhitelists"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/ExactAlarmsTest.java"	""	"/*
 *.
 */

package android.alarmmanager.cts;

import static android.alarmmanager.cts.AppStandbyTests.setTestAppStandbyBucket;
import static android.app.usage.UsageStatsManager.STANDBY_BUCKET_ACTIVE;
import static android.app.usage.UsageStatsManager.STANDBY_BUCKET_WORKING_SET;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeFalse;

import android.alarmmanager.alarmtestapp.cts.sdk30.TestReceiver;
import android.alarmmanager.util.AlarmManagerDeviceConfigHelper;
import android.app.Activity;
import android.alarmmanager.alarmtestapp.cts.PermissionStateChangedReceiver;
import android.app.AlarmManager;
import android.app.AppOpsManager;
import android.app.PendingIntent;
import android.app.compat.CompatChanges;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.PowerWhitelistManager;
import android.os.Process;
import android.os.SystemClock;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.provider.Settings;
import android.util.Log;

import com.android.compatibility.common.util.AppOpsUtils;
import com.android.compatibility.common.util.AppStandbyUtils;
import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.ShellUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.TestUtils;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.Description;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

@AppModeFull
@RunWith(AndroidJUnit4.class)
public class ExactAlarmsTest {
    /**
     * TODO (b/182835530): Add more tests for the following:
     *
     * Pre-S apps can:
     * - use setAlarmClock freely -- no temp-allowlist
     * - use setExactAndAWI with 7 / hr quota with standby and temp-allowlist
     * - use setInexactAndAWI with 7 / hr quota with standby-bucket ""ACTIVE"" and temp-allowlist
     *
     * S+ apps with permission can:
     * - use setInexactAWI with low quota + standby and *no* temp-allowlist.
     */
    private static final String TAG = ExactAlarmsTest.class.getSimpleName();

    private static final int ALLOW_WHILE_IDLE_QUOTA = 5;
    private static final long ALLOW_WHILE_IDLE_WINDOW = 10_000;
    private static final int ALLOW_WHILE_IDLE_COMPAT_QUOTA = 3;

    /**
     * Waiting generously long for success because the system can sometimes be slow to
     * provide expected behavior.
     * A different and shorter duration should be used while waiting for no-failure, because
     * even if the system is slow to fail in some cases, it would still cause some
     * flakiness and get flagged for investigation.
     */
    private static final long DEFAULT_WAIT_FOR_SUCCESS = 30_000;

    private static final String TEST_APP_PACKAGE = ""android.alarmmanager.alarmtestapp.cts"";

    private static final Context sContext = InstrumentationRegistry.getTargetContext();
    private final AlarmManager mAlarmManager = sContext.getSystemService(AlarmManager.class);
    private final AppOpsManager mAppOpsManager = sContext.getSystemService(AppOpsManager.class);
    private final PowerWhitelistManager mWhitelistManager = sContext.getSystemService(
            PowerWhitelistManager.class);
    private final PackageManager mPackageManager = sContext.getPackageManager();
    private final ComponentName mPermissionChangeReceiver = new ComponentName(TEST_APP_PACKAGE,
            PermissionStateChangedReceiver.class.getName());

    private final AlarmManagerDeviceConfigHelper mDeviceConfigHelper =
            new AlarmManagerDeviceConfigHelper();
    private final Random mIdGenerator = new Random(6789);

    @Rule
    public DumpLoggerRule mFailLoggerRule = new DumpLoggerRule(TAG) {
        @Override
        protected void failed(Throwable e, Description description) {
            super.failed(e, description);
            AlarmReceiver.dumpState();
        }
    };

    @Before
    @After
    public void resetAppOp() throws IOException {
        AppOpsUtils.reset(sContext.getOpPackageName());
        AppOpsUtils.reset(TEST_APP_PACKAGE);
    }

    @Before
    public void updateAlarmManagerConstants() {
        mDeviceConfigHelper.with(""min_futurity"", 0L)
                .with(""allow_while_idle_quota"", ALLOW_WHILE_IDLE_QUOTA)
                .with(""allow_while_idle_compat_quota"", ALLOW_WHILE_IDLE_COMPAT_QUOTA)
                .with(""allow_while_idle_window"", ALLOW_WHILE_IDLE_WINDOW)
                .with(""crash_non_clock_apps"", true)
                .with(""kill_on_schedule_exact_alarm_revoked"", false)
                .commitAndAwaitPropagation();
    }

    @Before
    public void putDeviceToIdle() {
        SystemUtil.runShellCommandForNoOutput(""dumpsys battery reset"");
        SystemUtil.runShellCommand(""cmd deviceidle force-idle deep"");
    }

    @Before
    public void enableChange() {
        if (!CompatChanges.isChangeEnabled(AlarmManager.REQUIRE_EXACT_ALARM_PERMISSION)) {
            SystemUtil.runShellCommand(""am compat enable --no-kill REQUIRE_EXACT_ALARM_PERMISSION ""
                    + sContext.getOpPackageName(), output -> output.contains(""Enabled""));
        }
    }

    @After
    public void resetChanges() {
        // This is needed because compat persists the overrides beyond package uninstall
        SystemUtil.runShellCommand(""am compat reset --no-kill REQUIRE_EXACT_ALARM_PERMISSION ""
                + sContext.getOpPackageName());
    }

    @After
    public void removeFromWhitelists() {
        removeFromWhitelists(sContext.getOpPackageName());
    }

    private void removeFromWhitelists(String packageName) {
        SystemUtil.runWithShellPermissionIdentity(
                () -> mWhitelistManager.removeFromWhitelist(packageName));
        SystemUtil.runShellCommand(""cmd deviceidle tempwhitelist -r "" + packageName);
    }

    @After
    public void restoreBatteryState() {
        SystemUtil.runShellCommand(""cmd deviceidle unforce"");
        SystemUtil.runShellCommandForNoOutput(""dumpsys battery reset"");
    }

    @After
    public void restorePermissionReceiverState() {
        SystemUtil.runWithShellPermissionIdentity(
                () -> mPackageManager.setComponentEnabledSetting(mPermissionChangeReceiver,
                        PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,
                        PackageManager.DONT_KILL_APP));
    }

    @After
    public void restoreAlarmManagerConstants() {
        mDeviceConfigHelper.restoreAll();
    }

    private void revokeAppOp() {
        revokeAppOp(sContext.getOpPackageName());
    }

    private void revokeAppOp(String packageName) {
        setAppOp(packageName, AppOpsManager.MODE_IGNORED);
    }

    private void setAppOp(String packageName, int mode) {
        final int uid = getPackageUid(packageName);

        SystemUtil.runWithShellPermissionIdentity(
                () -> {
                    mAppOpsManager.setUidMode(AppOpsManager.OPSTR_SCHEDULE_EXACT_ALARM, uid, mode);
                    return null;
                }
        );
    }

    private int getPackageUid(String packageName) {
        try {
            return sContext.getPackageManager().getPackageUid(packageName, 0);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static PendingIntent getAlarmSender(int id, boolean quotaed) {
        final Intent alarmAction = new Intent(AlarmReceiver.ALARM_ACTION)
                .setClass(sContext, AlarmReceiver.class)
                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND)
                .putExtra(AlarmReceiver.EXTRA_ALARM_ID, id)
                .putExtra(AlarmReceiver.EXTRA_QUOTAED, quotaed);
        return PendingIntent.getBroadcast(sContext, 0, alarmAction,
                PendingIntent.FLAG_MUTABLE | PendingIntent.FLAG_UPDATE_CURRENT);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.battery.IgnoreBatteryOptimizationsTestActivity"	"getTests"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/battery/IgnoreBatteryOptimizationsTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.battery;

import android.app.usage.UsageStatsManager;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.PowerManager;
import android.provider.Settings;
import android.view.View;

import com.android.cts.verifier.OrderedTestActivity;
import com.android.cts.verifier.R;

/** Test activity to check fulfillment of the ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS intent. */
public class IgnoreBatteryOptimizationsTestActivity extends OrderedTestActivity {
    private PowerManager mPowerManager;
    private UsageStatsManager mUsageStatsManager;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setInfoResources(R.string.ibo_test, R.string.ibo_test_info, -1);

        mPowerManager = getSystemService(PowerManager.class);
        mUsageStatsManager = getSystemService(UsageStatsManager.class);
    }

    @Override
    protected Test[] getTests() {
        return new Test[]{
                mConfirmNotExemptedAtStart,
                mRequestExemption,
                mIntermediate,
                mConfirmIsExempted,
                mRemoveExemption,
                mIntermediate,
                mConfirmIsNotExempted,
                mOpenAppExemptionListToExempt,
                mIntermediate,
                mConfirmIsExempted,
                mOpenAppExemptionListToUnexempt,
                mIntermediate,
                mConfirmIsNotExempted
        };
    }

    private boolean isExempted() {
        return mPowerManager.isIgnoringBatteryOptimizations(getPackageName())
                && mUsageStatsManager.getAppStandbyBucket()
                == UsageStatsManager.STANDBY_BUCKET_EXEMPTED;
    }

    private boolean isFullyNotExempted() {
        // Use an OR so we check both values to make sure neither of them say the app is exempted.
        if (mPowerManager.isIgnoringBatteryOptimizations(getPackageName())
                || mUsageStatsManager.getAppStandbyBucket()
                == UsageStatsManager.STANDBY_BUCKET_EXEMPTED) {
            return false;
        }
        return true;
    }

    private void openAppInfoPage() {
        Intent appInfoIntent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
        appInfoIntent.setData(Uri.parse(""package:"" + getPackageName()));
        startActivity(appInfoIntent);
    }

    private void openIgnoreBatteryOptimizationsAppList() {
        Intent intent = new Intent(Settings.ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS);
        startActivity(intent);
    }

    private final Test mConfirmNotExemptedAtStart = new Test(R.string.ibo_test_start_unexempt_app) {
        @Override
        protected void run() {
            super.run();

            if (isFullyNotExempted()) {
                succeed();
            }
        }

        @Override
        protected void onNextClick() {
            if (isExempted()) {
                openAppInfoPage();
            } else {
                succeed();
            }
        }
    };

    private final Test mRequestExemption = new Test(R.string.ibo_exempt_app_request) {
        @Override
        protected void onNextClick() {
            Intent request = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);
            request.setData(Uri.parse(""package:"" + getPackageName()));
            startActivity(request);
            succeed();
        }
    };

    private final Test mIntermediate = new Test(R.string.ibo_next_to_confirm) {
        @Override
        protected void onNextClick() {
            succeed();
        }
    };

    private final Test mConfirmIsExempted = new Test(R.string.ibo_app_not_exempted) {
        @Override
        protected void run() {
            super.run();

            if (isExempted()) {
                succeed();
            } else {
                findViewById(R.id.btn_next).setVisibility(View.GONE);
            }
        }
    };

    private final Test mRemoveExemption = new Test(R.string.ibo_unexempt_app) {
        @Override
        protected void run() {
            super.run();

            if (isFullyNotExempted()) {
                succeed();
            }
        }

        @Override
        protected void onNextClick() {
            if (isExempted()) {
                openAppInfoPage();
            } else {
                succeed();
            }
        }
    };

    private final Test mConfirmIsNotExempted = new Test(R.string.ibo_app_is_exempted) {
        @Override
        protected void run() {
            super.run();

            if (isFullyNotExempted()) {
                succeed();
            } else {
                findViewById(R.id.btn_next).setVisibility(View.GONE);
            }
        }
    };

    private final Test mOpenAppExemptionListToExempt = new Test(R.string.ibo_exempt_app_list) {
        @Override
        protected void onNextClick() {
            openIgnoreBatteryOptimizationsAppList();
            succeed();
        }
    };

    private final Test mOpenAppExemptionListToUnexempt = new Test(R.string.ibo_unexempt_app_list) {
        @Override
        protected void onNextClick() {
            openIgnoreBatteryOptimizationsAppList();
            succeed();
        }
    };
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.batterystats.BatteryUsageStatsTests"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/batterystats/BatteryUsageStatsTests.java"	""	"public void test/*
 *.
 */

package android.cts.statsdatom.batterystats;

import static com.google.common.truth.Truth.assertThat;

import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;

import com.android.internal.os.StatsdConfigProto;
import com.android.os.AtomsProto;
import com.android.os.AtomsProto.BatteryUsageStatsAtomsProto;
import com.android.os.AtomsProto.BatteryUsageStatsAtomsProto.BatteryConsumerData;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.util.List;
import java.util.function.Function;

public class BatteryUsageStatsTests extends DeviceTestCase implements IBuildReceiver {
    private IBuildInfo mCtsBuild;

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        super.tearDown();
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.batterystats.BatteryUsageStatsTests"	"testBatteryUsageStatsSinceReset"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/batterystats/BatteryUsageStatsTests.java"	""	"public void testBatteryUsageStatsSinceReset() throws Exception {
        if (!hasBattery()) {
            return;
        }

        runBatteryUsageStatsAtomTest(AtomsProto.Atom.BATTERY_USAGE_STATS_SINCE_RESET_FIELD_NUMBER,
                atom -> atom.getBatteryUsageStatsSinceReset().getBatteryUsageStats());
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.batterystats.BatteryUsageStatsTests"	"testBatteryUsageStatsSinceResetUsingPowerProfileModel"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/batterystats/BatteryUsageStatsTests.java"	""	"public void testBatteryUsageStatsSinceResetUsingPowerProfileModel() throws Exception {
        if (!hasBattery()) {
            return;
        }

        runBatteryUsageStatsAtomTest(
                AtomsProto.Atom.BATTERY_USAGE_STATS_SINCE_RESET_USING_POWER_PROFILE_MODEL_FIELD_NUMBER,
                atom -> atom.getBatteryUsageStatsSinceResetUsingPowerProfileModel()
                        .getBatteryUsageStats());
    }

    private void runBatteryUsageStatsAtomTest(int atomFieldNumber,
            Function<AtomsProto.Atom, BatteryUsageStatsAtomsProto> getter) throws Exception {
        unplugDevice();
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);
        try {
            DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                    ""StatsdCtsForegroundActivity"", ""action"", ""action.drain_power"", 5_000);
        } finally {
            plugInDevice();
        }

        StatsdConfigProto.StatsdConfig.Builder config =
                ConfigUtils.createConfigBuilder(DeviceUtils.STATSD_ATOM_TEST_PKG);
        ConfigUtils.addGaugeMetric(config, atomFieldNumber);
        ConfigUtils.uploadConfig(getDevice(), config);

        // Trigger atom pull.
        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        final List<AtomsProto.Atom> atoms = ReportUtils.getGaugeMetricAtoms(getDevice());
        assertThat(atoms.size()).isAtLeast(1);
        for (final AtomsProto.Atom atom : atoms) {
            final BatteryUsageStatsAtomsProto batteryUsageStats = getter.apply(atom);
            assertBatteryUsageStatsAtom(batteryUsageStats);
        }
    }

    private void assertBatteryUsageStatsAtom(BatteryUsageStatsAtomsProto batteryUsageStats)
            throws Exception {
        assertThat(batteryUsageStats.getSessionEndMillis()).isGreaterThan(
                getDeviceTimeMs() - 5 * 60 * 1000);
        assertThat(batteryUsageStats.getSessionDurationMillis()).isGreaterThan(0);

        final BatteryConsumerData deviceBatteryConsumer =
                batteryUsageStats.getDeviceBatteryConsumer();
        assertThat(deviceBatteryConsumer.getTotalConsumedPowerDeciCoulombs()).isAtLeast(0);
        for (BatteryConsumerData.PowerComponentUsage powerComponent :
                deviceBatteryConsumer.getPowerComponentsList()) {
            assertThat(powerComponent.getDurationMillis()).isAtLeast(0);
            assertThat(powerComponent.getPowerDeciCoulombs()).isAtLeast(0);
        }

        boolean hasAppData = false;
        final List<BatteryUsageStatsAtomsProto.UidBatteryConsumer> uidBatteryConsumers =
                batteryUsageStats.getUidBatteryConsumersList();
        for (BatteryUsageStatsAtomsProto.UidBatteryConsumer consumer : uidBatteryConsumers) {
            if (consumer.getBatteryConsumerData().getTotalConsumedPowerDeciCoulombs() > 0
                    || consumer.getTimeInForegroundMillis() > 0
                    || consumer.getTimeInBackgroundMillis() > 0) {
                hasAppData = true;
                break;
            }
        }

        assertThat(hasAppData).isTrue();
    }

    private boolean hasBattery() throws DeviceNotAvailableException  {
        final String batteryinfo = getDevice().executeShellCommand(""dumpsys battery"");
        return batteryinfo.contains(""present: true"");
    }

    private void unplugDevice() throws Exception {
        DeviceUtils.unplugDevice(getDevice());
        getDevice().executeShellCommand(""dumpsys battery suspend_input"");
    }

    private void plugInDevice() throws Exception {
        DeviceUtils.resetBatteryStatus(getDevice());
    }

    private long getDeviceTimeMs() throws Exception {
        final String timeMs = getDevice().executeShellCommand(""date +%s%3N"");
        return Long.parseLong(timeMs.trim());
    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"getIsDefault"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void test/**
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package android.app.usage.cts;

import android.app.AppOpsManager;
import android.app.usage.NetworkStatsManager;
import android.app.usage.NetworkStats;
import android.content.Context;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TrafficStats;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.RemoteException;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.telephony.TelephonyManager;
import android.test.InstrumentationTestCase;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.UnknownHostException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Scanner;
import java.net.HttpURLConnection;

import libcore.io.IoUtils;
import libcore.io.Streams;

import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_ALL;
import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_NO;
import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_YES;
import static android.app.usage.NetworkStats.Bucket.METERED_ALL;
import static android.app.usage.NetworkStats.Bucket.METERED_YES;
import static android.app.usage.NetworkStats.Bucket.METERED_NO;
import static android.app.usage.NetworkStats.Bucket.STATE_ALL;
import static android.app.usage.NetworkStats.Bucket.STATE_DEFAULT;
import static android.app.usage.NetworkStats.Bucket.STATE_FOREGROUND;
import static android.app.usage.NetworkStats.Bucket.TAG_NONE;
import static android.app.usage.NetworkStats.Bucket.UID_ALL;

public class NetworkUsageStatsTest extends InstrumentationTestCase {
    private static final String LOG_TAG = ""NetworkUsageStatsTest"";
    private static final String APPOPS_SET_SHELL_COMMAND = ""appops set {0} {1} {2}"";
    private static final String APPOPS_GET_SHELL_COMMAND = ""appops get {0} {1}"";

    private static final long MINUTE = 1000 * 60;
    private static final int TIMEOUT_MILLIS = 15000;

    private static final String CHECK_CONNECTIVITY_URL = ""http://www.265.com/"";
    private static final int HOST_RESOLUTION_RETRIES = 4;
    private static final int HOST_RESOLUTION_INTERVAL_MS = 500;

    private static final int NETWORK_TAG = 0xf00d;
    private static final long THRESHOLD_BYTES = 2 * 1024 * 1024;  // 2 MB

    private abstract class NetworkInterfaceToTest {
        private boolean mMetered;
        private boolean mIsDefault;

        abstract int getNetworkType();
        abstract int getTransportType();

        public boolean getMetered() {
            return mMetered;
        }

        public void setMetered(boolean metered) {
            this.mMetered = metered;
        }

        public boolean getIsDefault() {
            return mIsDefault;
        }

        public void setIsDefault(boolean isDefault) {
            mIsDefault = isDefault;
        }

        abstract String getSystemFeature();
        abstract String getErrorMessage();
    }

    private final NetworkInterfaceToTest[] mNetworkInterfacesToTest =
            new NetworkInterfaceToTest[] {
                    new NetworkInterfaceToTest() {
                        @Override
                        public int getNetworkType() {
                            return ConnectivityManager.TYPE_WIFI;
                        }

                        @Override
                        public int getTransportType() {
                            return NetworkCapabilities.TRANSPORT_WIFI;
                        }

                        @Override
                        public String getSystemFeature() {
                            return PackageManager.FEATURE_WIFI;
                        }

                        @Override
                        public String getErrorMessage() {
                            return "" Please make sure you are connected to a WiFi access point."";
                        }
                    },
                    new NetworkInterfaceToTest() {
                        @Override
                        public int getNetworkType() {
                            return ConnectivityManager.TYPE_MOBILE;
                        }

                        @Override
                        public int getTransportType() {
                            return NetworkCapabilities.TRANSPORT_CELLULAR;
                        }

                        @Override
                        public String getSystemFeature() {
                            return PackageManager.FEATURE_TELEPHONY;
                        }

                        @Override
                        public String getErrorMessage() {
                            return "" Please make sure you have added a SIM card with data plan to"" +
                                    "" your phone, have enabled data over cellular and in case of"" +
                                    "" dual SIM devices, have selected the right SIM "" +
                                    ""for data connection."";
                        }
                    }
    };

    private String mPkg;
    private NetworkStatsManager mNsm;
    private ConnectivityManager mCm;
    private PackageManager mPm;
    private long mStartTime;
    private long mEndTime;

    private long mBytesRead;
    private String mWriteSettingsMode;
    private String mUsageStatsMode;

    private void exerciseRemoteHost(Network network, URL url) throws Exception {
        NetworkInfo networkInfo = mCm.getNetworkInfo(network);
        if (networkInfo == null) {
            Log.w(LOG_TAG, ""Network info is null"");
        } else {
            Log.w(LOG_TAG, ""Network: "" + networkInfo.toString());
        }
        InputStreamReader in = null;
        HttpURLConnection urlc = null;
        String originalKeepAlive = System.getProperty(""http.keepAlive"");
        System.setProperty(""http.keepAlive"", ""false"");
        try {
            TrafficStats.setThreadStatsTag(NETWORK_TAG);
            urlc = (HttpURLConnection) network.openConnection(url);
            urlc.setConnectTimeout(TIMEOUT_MILLIS);
            urlc.setUseCaches(false);
            // Disable compression so we generate enough traffic that assertWithinPercentage will
            // not be affected by the small amount of traffic (5-10kB) sent by the test harness.
            urlc.setRequestProperty(""Accept-Encoding"", ""identity"");
            urlc.connect();
            boolean ping = urlc.getResponseCode() == 200;
            if (ping) {
                in = new InputStreamReader(
                        (InputStream) urlc.getContent());

                mBytesRead = 0;
                while (in.read() != -1) ++mBytesRead;
            }
        } catch (Exception e) {
            Log.i(LOG_TAG, ""Badness during exercising remote server: "" + e);
        } finally {
            TrafficStats.clearThreadStatsTag();
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    // don't care
                }
            }
            if (urlc != null) {
                urlc.disconnect();
            }
            if (originalKeepAlive == null) {
                System.clearProperty(""http.keepAlive"");
            } else {
                System.setProperty(""http.keepAlive"", originalKeepAlive);
            }
        }
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mNsm = (NetworkStatsManager) getInstrumentation().getContext()
                .getSystemService(Context.NETWORK_STATS_SERVICE);
        mNsm.setPollForce(true);

        mCm = (ConnectivityManager) getInstrumentation().getContext()
                .getSystemService(Context.CONNECTIVITY_SERVICE);

        mPm = getInstrumentation().getContext().getPackageManager();

        mPkg = getInstrumentation().getContext().getPackageName();

        mWriteSettingsMode = getAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS);
        setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, ""allow"");
        mUsageStatsMode = getAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS);
    }

    @Override
    protected void tearDown() throws Exception {
        if (mWriteSettingsMode != null) {
            setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, mWriteSettingsMode);
        }
        if (mUsageStatsMode != null) {
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, mUsageStatsMode);
        }
        super.tearDown();
    }

    private void setAppOpsMode(String appop, String mode) throws Exception {
        final String command = MessageFormat.format(APPOPS_SET_SHELL_COMMAND, mPkg, appop, mode);
        SystemUtil.runShellCommand(command);
    }

    private String getAppOpsMode(String appop) throws Exception {
        final String command = MessageFormat.format(APPOPS_GET_SHELL_COMMAND, mPkg, appop);
        String result = SystemUtil.runShellCommand(command);
        if (result == null) {
            Log.w(LOG_TAG, ""App op "" + appop + "" could not be read."");
        }
        return result;
    }

    private boolean isInForeground() throws IOException {
        String result = SystemUtil.runShellCommand(getInstrumentation(),
                ""cmd activity get-uid-state "" + Process.myUid());
        return result.contains(""FOREGROUND"");
    }

    private class NetworkCallback extends ConnectivityManager.NetworkCallback {
        private long mTolerance;
        private URL mUrl;
        public boolean success;
        public boolean metered;
        public boolean isDefault;

        NetworkCallback(long tolerance, URL url) {
            mTolerance = tolerance;
            mUrl = url;
            success = false;
            metered = false;
            isDefault = false;
        }

        // The test host only has IPv4. So on a dual-stack network where IPv6 connects before IPv4,
        // we need to wait until IPv4 is available or the test will spuriously fail.
        private void waitForHostResolution(Network network) {
            for (int i = 0; i < HOST_RESOLUTION_RETRIES; i++) {
                try {
                    network.getAllByName(mUrl.getHost());
                    return;
                } catch (UnknownHostException e) {
                    SystemClock.sleep(HOST_RESOLUTION_INTERVAL_MS);
                }
            }
            fail(String.format(""%s could not be resolved on network %s (%d attempts %dms apart)"",
                  mUrl.getHost(), network, HOST_RESOLUTION_RETRIES, HOST_RESOLUTION_INTERVAL_MS));
        }

        @Override
        public void onAvailable(Network network) {
            try {
                mStartTime = System.currentTimeMillis() - mTolerance;
                isDefault = network.equals(mCm.getActiveNetwork());
                waitForHostResolution(network);
                exerciseRemoteHost(network, mUrl);
                mEndTime = System.currentTimeMillis() + mTolerance;
                success = true;
                metered = !mCm.getNetworkCapabilities(network)
                        .hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
                synchronized(NetworkUsageStatsTest.this) {
                    NetworkUsageStatsTest.this.notify();
                }
            } catch (Exception e) {
                Log.w(LOG_TAG, ""exercising remote host failed."", e);
                success = false;
            }
        }
    }

    private boolean shouldTestThisNetworkType(int networkTypeIndex, final long tolerance)
            throws Exception {
        boolean hasFeature = mPm.hasSystemFeature(
                mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature());
        if (!hasFeature) {
            return false;
        }
        NetworkCallback callback = new NetworkCallback(tolerance, new URL(CHECK_CONNECTIVITY_URL));
        mCm.requestNetwork(new NetworkRequest.Builder()
                .addTransportType(mNetworkInterfacesToTest[networkTypeIndex].getTransportType())
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .build(), callback);
        synchronized(this) {
            try {
                wait((int)(TIMEOUT_MILLIS * 1.2));
            } catch (InterruptedException e) {
            }
        }
        if (callback.success) {
            mNetworkInterfacesToTest[networkTypeIndex].setMetered(callback.metered);
            mNetworkInterfacesToTest[networkTypeIndex].setIsDefault(callback.isDefault);
            return true;
        }

        // This will always fail at this point as we know 'hasFeature' is true.
        assertFalse (mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature() +
                "" is a reported system feature, "" +
                ""however no corresponding connected network interface was found or the attempt "" +
                ""to connect has timed out (timeout = "" + TIMEOUT_MILLIS + ""ms)."" +
                mNetworkInterfacesToTest[networkTypeIndex].getErrorMessage(), hasFeature);
        return false;
    }

    private String getSubscriberId(int networkIndex) {
        int networkType = mNetworkInterfacesToTest[networkIndex].getNetworkType();
        if (ConnectivityManager.TYPE_MOBILE == networkType) {
            TelephonyManager tm = (TelephonyManager) getInstrumentation().getContext()
                    .getSystemService(Context.TELEPHONY_SERVICE);
            return ShellIdentityUtils.invokeMethodWithShellPermissions(tm,
                    (telephonyManager) -> telephonyManager.getSubscriberId());
        }
        return """";
    }

    @AppModeFull"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageReportingTest"	"testUsageStartAndStopReporting"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testUsageStartAndStopReporting() throws Exception {
        launchActivity(new ComponentName(mTargetPackage, Activities.ActivityOne.class.getName()));

        Activity activity;
        synchronized ( Activities.startedActivities) {
            activity = Activities.startedActivities.valueAt(0);
        }

        mUsageStatsManager.reportUsageStart(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, true);

        mUsageStatsManager.reportUsageStop(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, false);


        mUsageStatsManager.reportUsageStart(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, true);

        mUsageStatsManager.reportUsageStop(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, false);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageReportingTest"	"testUsagePastReporting"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testUsagePastReporting() throws Exception {
        launchActivity(new ComponentName(mTargetPackage, Activities.ActivityOne.class.getName()));

        Activity activity;
        synchronized ( Activities.startedActivities) {
            activity = Activities.startedActivities.valueAt(0);
        }

        mUsageStatsManager.reportUsageStart(activity, TOKEN_0, 100);
        assertAppOrTokenUsed(mFullToken0, true);

        mUsageStatsManager.reportUsageStop(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, false);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageReportingTest"	"testUsageReportingMissingStop"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testUsageReportingMissingStop() throws Exception {
        launchActivity(new ComponentName(mTargetPackage, Activities.ActivityOne.class.getName()));

        Activity activity;
        synchronized ( Activities.startedActivities) {
            activity = Activities.startedActivities.valueAt(0);
        }

        mUsageStatsManager.reportUsageStart(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, true);

        // Send the device to sleep to get onStop called for the token reporting activities.
        mUiDevice.executeShellCommand(DEVICE_SLEEP_COMMAND);
        Thread.sleep(1000);

        assertAppOrTokenUsed(mFullToken0, false);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageReportingTest"	"testExceptionOnRepeatReport"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testExceptionOnRepeatReport() throws Exception {
        launchActivity(new ComponentName(mTargetPackage, Activities.ActivityOne.class.getName()));

        Activity activity;
        synchronized ( Activities.startedActivities) {
            activity = Activities.startedActivities.valueAt(0);
        }

        mUsageStatsManager.reportUsageStart(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, true);

        try {
            mUsageStatsManager.reportUsageStart(activity, TOKEN_0);
            fail(""Should have thrown an IllegalArgumentException for double reporting start"");
        } catch (IllegalArgumentException iae) {
            //Expected exception
        }
        assertAppOrTokenUsed(mFullToken0, true);

        mUsageStatsManager.reportUsageStop(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, false);


        try {
            mUsageStatsManager.reportUsageStop(activity, TOKEN_0);
            fail(""Should have thrown an IllegalArgumentException for double reporting stop"");
        } catch (IllegalArgumentException iae) {
            //Expected exception
        }

        // One more cycle of reporting just to make sure there was no underflow
        mUsageStatsManager.reportUsageStart(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, true);

        mUsageStatsManager.reportUsageStop(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, false);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageReportingTest"	"testMultipleTokenUsageReporting"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testMultipleTokenUsageReporting() throws Exception {
        launchActivity(new ComponentName(mTargetPackage, Activities.ActivityOne.class.getName()));

        Activity activity;
        synchronized ( Activities.startedActivities) {
            activity = Activities.startedActivities.valueAt(0);
        }

        mUsageStatsManager.reportUsageStart(activity, TOKEN_0);
        mUsageStatsManager.reportUsageStart(activity, TOKEN_1);
        assertAppOrTokenUsed(mFullToken0, true);
        assertAppOrTokenUsed(mFullToken1, true);

        mUsageStatsManager.reportUsageStop(activity, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, false);
        assertAppOrTokenUsed(mFullToken1, true);

        mUsageStatsManager.reportUsageStop(activity, TOKEN_1);
        assertAppOrTokenUsed(mFullToken0, false);
        assertAppOrTokenUsed(mFullToken1, false);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageReportingTest"	"testMultipleTokenMissingStop"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testMultipleTokenMissingStop() throws Exception {
        launchActivity(new ComponentName(mTargetPackage, Activities.ActivityOne.class.getName()));

        Activity activity;
        synchronized ( Activities.startedActivities) {
            activity = Activities.startedActivities.valueAt(0);
        }

        mUsageStatsManager.reportUsageStart(activity, TOKEN_0);
        mUsageStatsManager.reportUsageStart(activity, TOKEN_1);
        assertAppOrTokenUsed(mFullToken0, true);
        assertAppOrTokenUsed(mFullToken1, true);


        // Send the device to sleep to get onStop called for the token reporting activities.
        mUiDevice.executeShellCommand(DEVICE_SLEEP_COMMAND);
        Thread.sleep(1000);

        assertAppOrTokenUsed(mFullToken0, false);
        assertAppOrTokenUsed(mFullToken1, false);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageReportingTest"	"testSplitscreenUsageReporting"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testSplitscreenUsageReporting() throws Exception {
        if (!supportsSplitScreenMultiWindow()) {
            // Skipping test: no multi-window support
            return;
        }

        launchActivitiesInSplitScreen(
                getLaunchActivityBuilder().setTargetActivity(
                        new ComponentName(mTargetPackage,
                                Activities.ActivityOne.class.getName())),
                getLaunchActivityBuilder().setTargetActivity(
                        new ComponentName(mTargetPackage,
                                Activities.ActivityTwo.class.getName())));
        Thread.sleep(500);

        Activity activity0;
        Activity activity1;
        synchronized ( Activities.startedActivities) {
            activity0 = Activities.startedActivities.valueAt(0);
            activity1 = Activities.startedActivities.valueAt(1);
        }

        mUsageStatsManager.reportUsageStart(activity0, TOKEN_0);
        mUsageStatsManager.reportUsageStart(activity1, TOKEN_1);
        assertAppOrTokenUsed(mFullToken0, true);
        assertAppOrTokenUsed(mFullToken1, true);

        mUsageStatsManager.reportUsageStop(activity0, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, false);
        assertAppOrTokenUsed(mFullToken1, true);

        mUsageStatsManager.reportUsageStop(activity1, TOKEN_1);
        assertAppOrTokenUsed(mFullToken0, false);
        assertAppOrTokenUsed(mFullToken1, false);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageReportingTest"	"testSplitscreenSameToken"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testSplitscreenSameToken() throws Exception {
        if (!supportsSplitScreenMultiWindow()) {
            // Skipping test: no multi-window support
            return;
        }

        launchActivitiesInSplitScreen(
                getLaunchActivityBuilder().setTargetActivity(
                        new ComponentName(mTargetPackage,
                                Activities.ActivityOne.class.getName())),
                getLaunchActivityBuilder().setTargetActivity(
                        new ComponentName(mTargetPackage,
                                Activities.ActivityTwo.class.getName())));
        Thread.sleep(500);

        Activity activity0;
        Activity activity1;
        synchronized ( Activities.startedActivities) {
            activity0 = Activities.startedActivities.valueAt(0);
            activity1 = Activities.startedActivities.valueAt(1);
        }

        mUsageStatsManager.reportUsageStart(activity0, TOKEN_0);
        mUsageStatsManager.reportUsageStart(activity1, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, true);

        mUsageStatsManager.reportUsageStop(activity0, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, true);

        mUsageStatsManager.reportUsageStop(activity1, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, false);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageReportingTest"	"testSplitscreenSameTokenOneMissedStop"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testSplitscreenSameTokenOneMissedStop() throws Exception {
        if (!supportsSplitScreenMultiWindow()) {
            // Skipping test: no multi-window support
            return;
        }

        launchActivitiesInSplitScreen(
                getLaunchActivityBuilder().setTargetActivity(
                        new ComponentName(mTargetPackage,
                                Activities.ActivityOne.class.getName())),
                getLaunchActivityBuilder().setTargetActivity(
                        new ComponentName(mTargetPackage,
                                Activities.ActivityTwo.class.getName())));
        Thread.sleep(500);

        Activity activity0;
        Activity activity1;
        synchronized ( Activities.startedActivities) {
            activity0 = Activities.startedActivities.valueAt(0);
            activity1 = Activities.startedActivities.valueAt(1);
        }

        mUsageStatsManager.reportUsageStart(activity0, TOKEN_0);
        mUsageStatsManager.reportUsageStart(activity1, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, true);

        mUsageStatsManager.reportUsageStop(activity0, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, true);

        // Send the device to keyguard to get onStop called for the token reporting activities.
        try (final LockScreenSession lockScreenSession = new LockScreenSession()) {
            lockScreenSession.gotoKeyguard();
            Thread.sleep(1000);
            assertAppOrTokenUsed(mFullToken0, false);
        }
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageReportingTest"	"testSplitscreenSameTokenTwoMissedStop"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageReportingTest.java"	""	"public void testSplitscreenSameTokenTwoMissedStop() throws Exception {
        if (!supportsSplitScreenMultiWindow()) {
            // Skipping test: no multi-window support
            return;
        }

        launchActivitiesInSplitScreen(
                getLaunchActivityBuilder().setTargetActivity(
                        new ComponentName(mTargetPackage,
                                Activities.ActivityOne.class.getName())),
                getLaunchActivityBuilder().setTargetActivity(
                        new ComponentName(mTargetPackage,
                                Activities.ActivityTwo.class.getName())));
        Thread.sleep(500);

        Activity activity0;
        Activity activity1;
        synchronized ( Activities.startedActivities) {
            activity0 = Activities.startedActivities.valueAt(0);
            activity1 = Activities.startedActivities.valueAt(1);
        }

        mUsageStatsManager.reportUsageStart(activity0, TOKEN_0);
        mUsageStatsManager.reportUsageStart(activity1, TOKEN_0);
        assertAppOrTokenUsed(mFullToken0, true);

        // Send the device to keyguard to get onStop called for the token reporting activities.
        try (final LockScreenSession lockScreenSession = new LockScreenSession()) {
            lockScreenSession.gotoKeyguard();
            Thread.sleep(1000);
            assertAppOrTokenUsed(mFullToken0, false);
        }
    }

    private void assertAppOrTokenUsed(String entity, boolean expected) throws Exception {
        final String failMessage;
        if (expected) {
            failMessage = entity + "" not found in list of active activities and tokens"";
        } else {
            failMessage = entity + "" found in list of active activities and tokens"";
        }

        TestUtils.waitUntil(failMessage, ASSERT_TIMEOUT_SECONDS, () -> {
            final String activeUsages =
                    mUiDevice.executeShellCommand(""dumpsys usagestats apptimelimit actives"");
            final String[] actives = activeUsages.split(""\n"");
            boolean found = false;

            for (String active: actives) {
                if (active.equals(entity)) {
                    found = true;
                    break;
                }
            }
            return found == expected;
        });
    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"isAppStandbyEnabled"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"/**
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package android.app.usage.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.KeyguardManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.usage.EventStats;
import android.app.usage.UsageEvents;
import android.app.usage.UsageEvents.Event;
import android.app.usage.UsageStats;
import android.app.usage.UsageStatsManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.Parcel;
import android.os.SystemClock;
import android.os.UserHandle;
import android.os.UserManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AppModeInstant;
import android.provider.Settings;
import android.server.wm.WindowManagerState;
import android.server.wm.WindowManagerStateHelper;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.Until;
import android.text.format.DateUtils;
import android.util.Log;
import android.util.SparseArray;
import android.util.SparseLongArray;
import android.view.KeyEvent;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AppStandbyUtils;
import com.android.compatibility.common.util.BatteryUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.text.MessageFormat;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.function.BooleanSupplier;

/**
 * Test the UsageStats API. It is difficult to test the entire surface area
 * of the API, as a lot of the testing depends on what data is already present
 * on the device and for how long that data has been aggregating.
 *
 * These tests perform simple checks that each interval is of the correct duration,
 * and that events do appear in the event log.
 *
 * Tests to add that are difficult to add now:
 * - Invoking a device configuration change and then watching for it in the event log.
 * - Changing the system time and verifying that all data has been correctly shifted
 *   along with the new time.
 * - Proper eviction of old data.
 */
@RunWith(AndroidJUnit4.class)
public class UsageStatsTest {
    private static final boolean DEBUG = false;
    private static final String TAG = ""UsageStatsTest"";

    private static final String APPOPS_SET_SHELL_COMMAND = ""appops set {0} "" +
            AppOpsManager.OPSTR_GET_USAGE_STATS + "" {1}"";

    private static final String GET_SHELL_COMMAND = ""settings get global "";

    private static final String SET_SHELL_COMMAND = ""settings put global "";

    private static final String DELETE_SHELL_COMMAND = ""settings delete global "";

    private static final String JOBSCHEDULER_RUN_SHELL_COMMAND = ""cmd jobscheduler run"";

    private static final String TEST_APP_PKG = ""android.app.usage.cts.test1"";
    private static final String TEST_APP_CLASS = ""android.app.usage.cts.test1.SomeActivity"";
    private static final String TEST_APP_CLASS_LOCUS
            = ""android.app.usage.cts.test1.SomeActivityWithLocus"";
    private static final String TEST_APP_CLASS_SERVICE
            = ""android.app.usage.cts.test1.TestService"";
    private static final String TEST_APP2_PKG = ""android.app.usage.cts.test2"";
    private static final String TEST_APP2_CLASS_FINISHING_TASK_ROOT =
            ""android.app.usage.cts.test2.FinishingTaskRootActivity"";
    private static final String TEST_APP2_CLASS_PIP =
            ""android.app.usage.cts.test2.PipActivity"";
    private static final ComponentName TEST_APP2_PIP_COMPONENT = new ComponentName(TEST_APP2_PKG,
            TEST_APP2_CLASS_PIP);

    private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);
    private static final long MINUTE = TimeUnit.MINUTES.toMillis(1);
    private static final long DAY = TimeUnit.DAYS.toMillis(1);
    private static final long WEEK = 7 * DAY;
    private static final long MONTH = 30 * DAY;
    private static final long YEAR = 365 * DAY;
    private static final long TIME_DIFF_THRESHOLD = 200;
    private static final String CHANNEL_ID = ""my_channel"";

    private static final long TIMEOUT_BINDER_SERVICE_SEC = 2;

    private Context mContext;
    private UiDevice mUiDevice;
    private ActivityManager mAm;
    private UsageStatsManager mUsageStatsManager;
    private KeyguardManager mKeyguardManager;
    private String mTargetPackage;
    private String mCachedUsageSourceSetting;
    private String mCachedEnableRestrictedBucketSetting;
    private int mOtherUser;
    private Context mOtherUserContext;
    private UsageStatsManager mOtherUsageStats;
    private WindowManagerStateHelper mWMStateHelper;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mAm = mContext.getSystemService(ActivityManager.class);
        mUsageStatsManager = (UsageStatsManager) mContext.getSystemService(
                Context.USAGE_STATS_SERVICE);
        mKeyguardManager = mContext.getSystemService(KeyguardManager.class);
        mTargetPackage = mContext.getPackageName();

        mWMStateHelper = new WindowManagerStateHelper();

        assumeTrue(""App Standby not enabled on device"", AppStandbyUtils.isAppStandbyEnabled());
        setAppOpsMode(""allow"");
        mCachedUsageSourceSetting = getSetting(Settings.Global.APP_TIME_LIMIT_USAGE_SOURCE);
        mCachedEnableRestrictedBucketSetting = getSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET);
    }

    @After
    public void cleanUp() throws Exception {
        if (mCachedUsageSourceSetting != null &&
                !mCachedUsageSourceSetting.equals(
                    getSetting(Settings.Global.APP_TIME_LIMIT_USAGE_SOURCE))) {
            setUsageSourceSetting(mCachedUsageSourceSetting);
        }
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, mCachedEnableRestrictedBucketSetting);
        // Force stop test package to avoid any running test code from carrying over to the next run
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP2_PKG));
        mUiDevice.pressHome();
        // Destroy the other user if created
        if (mOtherUser != 0) {
            stopUser(mOtherUser, true, true);
            removeUser(mOtherUser);
            mOtherUser = 0;
        }
    }

    private static void assertLessThan(long left, long right) {
        assertTrue(""Expected "" + left + "" to be less than "" + right, left < right);
    }

    private static void assertLessThanOrEqual(long left, long right) {
        assertTrue(""Expected "" + left + "" to be less than "" + right, left <= right);
    }

    private void setAppOpsMode(String mode) throws Exception {
        executeShellCmd(MessageFormat.format(APPOPS_SET_SHELL_COMMAND, mTargetPackage, mode));
    }

    private String getSetting(String name) throws Exception {
        return executeShellCmd(GET_SHELL_COMMAND + name);
    }

    private void setSetting(String name, String setting) throws Exception {
        if (setting == null || setting.equals(""null"")) {
            executeShellCmd(DELETE_SHELL_COMMAND + name);
        } else {
            executeShellCmd(SET_SHELL_COMMAND + name + "" "" + setting);
        }
    }

    private void setUsageSourceSetting(String value) throws Exception {
        setSetting(Settings.Global.APP_TIME_LIMIT_USAGE_SOURCE, value);
        mUsageStatsManager.forceUsageSourceSettingRead();
    }

    private void launchSubActivity(Class<? extends Activity> clazz) {
        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.setClassName(mTargetPackage, clazz.getName());
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
        mUiDevice.wait(Until.hasObject(By.clazz(clazz)), TIMEOUT);
    }

    private Intent createTestActivityIntent(String pkgName, String className) {
        final Intent intent = new Intent();
        intent.setClassName(pkgName, className);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        return intent;
    }

    private void launchTestActivity(String pkgName, String className) {
        mContext.startActivity(createTestActivityIntent(pkgName, className));
        mUiDevice.wait(Until.hasObject(By.clazz(pkgName, className)), TIMEOUT);
    }

    private void launchSubActivities(Class<? extends Activity>[] activityClasses) {
        for (Class<? extends Activity> clazz : activityClasses) {
            launchSubActivity(clazz);
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testLastTimeAnyComponentUsed_bindServiceShouldBeDetected"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testLastTimeAnyComponentUsed_bindServiceShouldBeDetected() throws Exception {
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.

        final long startTime = System.currentTimeMillis();
        bindToTestService();
        final long endTime = System.currentTimeMillis();

        verifyLastTimeAnyComponentUsedWithinRange(startTime, endTime, TEST_APP_PKG);
    }

    private void verifyLastTimeAnyComponentUsedWithinRange(
            long startTime, long endTime, String targetPackage) {
        final Map<String, UsageStats> map = mUsageStatsManager.queryAndAggregateUsageStats(
                startTime, endTime);
        final UsageStats stats = map.get(targetPackage);
        assertNotNull(stats);
        final long lastTimeAnyComponentUsed = stats.getLastTimeAnyComponentUsed();
        assertLessThan(startTime, lastTimeAnyComponentUsed);
        assertLessThan(lastTimeAnyComponentUsed, endTime);

        SystemUtil.runWithShellPermissionIdentity(()-> {
            final long lastDayAnyComponentUsedGlobal =
                    mUsageStatsManager.getLastTimeAnyComponentUsed(targetPackage) / DAY;
            assertLessThanOrEqual(startTime / DAY, lastDayAnyComponentUsedGlobal);
            assertLessThanOrEqual(lastDayAnyComponentUsedGlobal, endTime / DAY);
        });
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testLastTimeAnyComponentUsed_JobServiceShouldBeIgnored"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testLastTimeAnyComponentUsed_JobServiceShouldBeIgnored() throws Exception {
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.

        final long startTime = System.currentTimeMillis();
        runJobImmediately();
        waitUntil(TestJob.hasJobStarted, /* expected */ true);

        final Map<String, UsageStats> map = mUsageStatsManager.queryAndAggregateUsageStats(
                startTime, System.currentTimeMillis());
        final UsageStats stats = map.get(mTargetPackage);
        if (stats != null) {
            final long lastTimeAnyComponentUsed = stats.getLastTimeAnyComponentUsed();
            // Check that the usage is NOT detected.
            assertLessThanOrEqual(lastTimeAnyComponentUsed, startTime);
        }

        SystemUtil.runWithShellPermissionIdentity(()-> {
            final long lastDayAnyComponentUsedGlobal =
                    mUsageStatsManager.getLastTimeAnyComponentUsed(mTargetPackage) / DAY;
            // Check that the usage is NOT detected.
            assertLessThanOrEqual(lastDayAnyComponentUsedGlobal, startTime / DAY);
        });
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testLastTimeAnyComponentUsedGlobal_withoutPermission"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testLastTimeAnyComponentUsedGlobal_withoutPermission() throws Exception {
        try{
            mUsageStatsManager.getLastTimeAnyComponentUsed(mTargetPackage);
            fail(""Query across users should require INTERACT_ACROSS_USERS permission"");
        } catch (SecurityException se) {
            // Expected
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testOrderedActivityLaunchSequenceInEventLog"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testOrderedActivityLaunchSequenceInEventLog() throws Exception {
        @SuppressWarnings(""unchecked"")
        Class<? extends Activity>[] activitySequence = new Class[] {
                Activities.ActivityOne.class,
                Activities.ActivityTwo.class,
                Activities.ActivityThree.class,
        };
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.

        final long startTime = System.currentTimeMillis();
        // Launch the series of Activities.
        launchSubActivities(activitySequence);
        final long endTime = System.currentTimeMillis();
        UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        // Only look at events belongs to mTargetPackage.
        ArrayList<UsageEvents.Event> eventList = new ArrayList<>();
        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            if (mTargetPackage.equals(event.getPackageName())) {
                eventList.add(event);
            }
        }

        final int activityCount = activitySequence.length;
        for (int i = 0; i < activityCount; i++) {
            String className = activitySequence[i].getName();
            ArrayList<UsageEvents.Event> activityEvents = new ArrayList<>();
            final int size = eventList.size();
            for (int j = 0; j < size; j++) {
                Event evt = eventList.get(j);
                if (className.equals(evt.getClassName())) {
                    activityEvents.add(evt);
                }
            }
            // We expect 3 events per Activity launched (ACTIVITY_RESUMED + ACTIVITY_PAUSED
            // + ACTIVITY_STOPPED) except for the last Activity, which only has
            // ACTIVITY_RESUMED event.
            if (i < activityCount - 1) {
                assertEquals(3, activityEvents.size());
                assertEquals(Event.ACTIVITY_RESUMED, activityEvents.get(0).getEventType());
                assertEquals(Event.ACTIVITY_PAUSED, activityEvents.get(1).getEventType());
                assertEquals(Event.ACTIVITY_STOPPED, activityEvents.get(2).getEventType());
            } else {
                // The last activity
                assertEquals(1, activityEvents.size());
                assertEquals(Event.ACTIVITY_RESUMED, activityEvents.get(0).getEventType());
            }
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testActivityOnHomeButton"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testActivityOnHomeButton() throws Exception {
        testActivityOnButton(mUiDevice::pressHome);
    }

    private void testActivityOnButton(Runnable pressButton) throws Exception {
        mUiDevice.wakeUp();
        final long startTime = System.currentTimeMillis();
        final Class clazz = Activities.ActivityOne.class;
        launchSubActivity(clazz);
        pressButton.run();
        Thread.sleep(1000);
        final long endTime = System.currentTimeMillis();
        UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        ArrayList<UsageEvents.Event> eventList = new ArrayList<>();
        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            if (mTargetPackage.equals(event.getPackageName())
                && clazz.getName().equals(event.getClassName())) {
                eventList.add(event);
            }
        }
        assertEquals(3, eventList.size());
        assertEquals(Event.ACTIVITY_RESUMED, eventList.get(0).getEventType());
        assertEquals(Event.ACTIVITY_PAUSED, eventList.get(1).getEventType());
        assertEquals(Event.ACTIVITY_STOPPED, eventList.get(2).getEventType());
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testAppLaunchCount"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testAppLaunchCount() throws Exception {
        long endTime = System.currentTimeMillis();
        long startTime = endTime - DateUtils.DAY_IN_MILLIS;
        Map<String,UsageStats> events = mUsageStatsManager.queryAndAggregateUsageStats(
                startTime, endTime);
        UsageStats stats = events.get(mTargetPackage);
        int startingCount = stats.getAppLaunchCount();
        launchSubActivity(Activities.ActivityOne.class);
        launchSubActivity(Activities.ActivityTwo.class);
        endTime = System.currentTimeMillis();
        events = mUsageStatsManager.queryAndAggregateUsageStats(
                startTime, endTime);
        stats = events.get(mTargetPackage);
        assertEquals(startingCount + 1, stats.getAppLaunchCount());
        mUiDevice.pressHome();
        launchSubActivity(Activities.ActivityOne.class);
        launchSubActivity(Activities.ActivityTwo.class);
        launchSubActivity(Activities.ActivityThree.class);
        endTime = System.currentTimeMillis();
        events = mUsageStatsManager.queryAndAggregateUsageStats(
                startTime, endTime);
        stats = events.get(mTargetPackage);
        assertEquals(startingCount + 2, stats.getAppLaunchCount());
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testStandbyBucketChangeLog"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testStandbyBucketChangeLog() throws Exception {
        final long startTime = System.currentTimeMillis();
        setStandByBucket(mTargetPackage, ""rare"");

        final long endTime = System.currentTimeMillis();
        UsageEvents events = mUsageStatsManager.queryEvents(startTime - 1_000, endTime + 1_000);

        boolean found = false;
        // Check all the events.
        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            if (event.getEventType() == UsageEvents.Event.STANDBY_BUCKET_CHANGED) {
                found |= event.getAppStandbyBucket() == UsageStatsManager.STANDBY_BUCKET_RARE;
            }
        }

        assertTrue(found);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testGetAppStandbyBuckets"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testGetAppStandbyBuckets() throws Exception {
        final boolean origValue = AppStandbyUtils.isAppStandbyEnabledAtRuntime();
        AppStandbyUtils.setAppStandbyEnabledAtRuntime(true);
        try {
            assumeTrue(""Skip GetAppStandby test: app standby is disabled."",
                    AppStandbyUtils.isAppStandbyEnabled());

            setStandByBucket(mTargetPackage, ""rare"");
            Map<String, Integer> bucketMap = mUsageStatsManager.getAppStandbyBuckets();
            assertTrue(""No bucket data returned"", bucketMap.size() > 0);
            final int bucket = bucketMap.getOrDefault(mTargetPackage, -1);
            assertEquals(""Incorrect bucket returned for "" + mTargetPackage, bucket,
                    UsageStatsManager.STANDBY_BUCKET_RARE);
        } finally {
            AppStandbyUtils.setAppStandbyEnabledAtRuntime(origValue);
        }
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testGetAppStandbyBucket"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testGetAppStandbyBucket() throws Exception {
        // App should be at least active, since it's running instrumentation tests
        assertLessThanOrEqual(UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket());
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testQueryEventsForSelf"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testQueryEventsForSelf() throws Exception {
        setAppOpsMode(""ignore""); // To ensure permission is not required
        // Time drifts of 2s are expected inside usage stats
        final long start = System.currentTimeMillis() - 2_000;
        setStandByBucket(mTargetPackage, ""rare"");
        Thread.sleep(100);
        setStandByBucket(mTargetPackage, ""working_set"");
        Thread.sleep(100);
        final long end = System.currentTimeMillis() + 2_000;
        final UsageEvents events = mUsageStatsManager.queryEventsForSelf(start, end);
        long rareTimeStamp = end + 1; // Initializing as rareTimeStamp > workingTimeStamp
        long workingTimeStamp = start - 1;
        int numEvents = 0;
        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            numEvents++;
            assertEquals(""Event for a different package"", mTargetPackage, event.getPackageName());
            if (event.getEventType() == Event.STANDBY_BUCKET_CHANGED) {
                if (event.getAppStandbyBucket() == UsageStatsManager.STANDBY_BUCKET_RARE) {
                    rareTimeStamp = event.getTimeStamp();
                }
                else if (event.getAppStandbyBucket() == UsageStatsManager
                        .STANDBY_BUCKET_WORKING_SET) {
                    workingTimeStamp = event.getTimeStamp();
                }
            }
        }
        assertTrue(""Only "" + numEvents + "" events returned"", numEvents >= 2);
        assertLessThan(rareTimeStamp, workingTimeStamp);
    }

    /**
     * We can't run this test because we are unable to change the system time.
     * It would be nice to add a shell command or other to allow the shell user
     * to set the time, thereby allowing this test to set the time using the UIAutomator.
     */
    @Ignore"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"ignore_testStatsAreShiftedInTimeWhenSystemTimeChanges"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void ignore_testStatsAreShiftedInTimeWhenSystemTimeChanges() throws Exception {
        launchSubActivity(Activities.ActivityOne.class);
        launchSubActivity(Activities.ActivityThree.class);

        long endTime = System.currentTimeMillis();
        long startTime = endTime - MINUTE;
        Map<String, UsageStats> statsMap = mUsageStatsManager.queryAndAggregateUsageStats(startTime,
                endTime);
        assertFalse(statsMap.isEmpty());
        assertTrue(statsMap.containsKey(mTargetPackage));
        final UsageStats before = statsMap.get(mTargetPackage);

        SystemClock.setCurrentTimeMillis(System.currentTimeMillis() - (DAY / 2));
        try {
            endTime = System.currentTimeMillis();
            startTime = endTime - MINUTE;
            statsMap = mUsageStatsManager.queryAndAggregateUsageStats(startTime, endTime);
            assertFalse(statsMap.isEmpty());
            assertTrue(statsMap.containsKey(mTargetPackage));
            final UsageStats after = statsMap.get(mTargetPackage);
            assertEquals(before.getPackageName(), after.getPackageName());

            long diff = before.getFirstTimeStamp() - after.getFirstTimeStamp();
            assertLessThan(Math.abs(diff - (DAY / 2)), TIME_DIFF_THRESHOLD);

            assertEquals(before.getLastTimeStamp() - before.getFirstTimeStamp(),
                    after.getLastTimeStamp() - after.getFirstTimeStamp());
            assertEquals(before.getLastTimeUsed() - before.getFirstTimeStamp(),
                    after.getLastTimeUsed() - after.getFirstTimeStamp());
            assertEquals(before.getTotalTimeInForeground(), after.getTotalTimeInForeground());
        } finally {
            SystemClock.setCurrentTimeMillis(System.currentTimeMillis() + (DAY / 2));
        }
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUsageEventsParceling"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUsageEventsParceling() throws Exception {
        final long startTime = System.currentTimeMillis() - MINUTE;

        // Ensure some data is in the UsageStats log.
        @SuppressWarnings(""unchecked"")
        Class<? extends Activity>[] activityClasses = new Class[] {
                Activities.ActivityTwo.class,
                Activities.ActivityOne.class,
                Activities.ActivityThree.class,
        };
        launchSubActivities(activityClasses);

        final long endTime = System.currentTimeMillis();
        UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);
        assertTrue(events.getNextEvent(new UsageEvents.Event()));

        Parcel p = Parcel.obtain();
        p.setDataPosition(0);
        events.writeToParcel(p, 0);
        p.setDataPosition(0);

        UsageEvents reparceledEvents = UsageEvents.CREATOR.createFromParcel(p);

        UsageEvents.Event e1 = new UsageEvents.Event();
        UsageEvents.Event e2 = new UsageEvents.Event();
        while (events.hasNextEvent() && reparceledEvents.hasNextEvent()) {
            events.getNextEvent(e1);
            reparceledEvents.getNextEvent(e2);
            assertEquals(e1.getPackageName(), e2.getPackageName());
            assertEquals(e1.getClassName(), e2.getClassName());
            assertEquals(e1.getConfiguration(), e2.getConfiguration());
            assertEquals(e1.getEventType(), e2.getEventType());
            assertEquals(e1.getTimeStamp(), e2.getTimeStamp());
        }

        assertEquals(events.hasNextEvent(), reparceledEvents.hasNextEvent());
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testPackageUsageStatsIntervals"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testPackageUsageStatsIntervals() throws Exception {
        final long beforeTime = System.currentTimeMillis();

        // Launch an Activity.
        launchSubActivity(Activities.ActivityFour.class);
        launchSubActivity(Activities.ActivityThree.class);

        final long endTime = System.currentTimeMillis();

        final SparseLongArray intervalLengths = new SparseLongArray();
        intervalLengths.put(UsageStatsManager.INTERVAL_DAILY, DAY);
        intervalLengths.put(UsageStatsManager.INTERVAL_WEEKLY, WEEK);
        intervalLengths.put(UsageStatsManager.INTERVAL_MONTHLY, MONTH);
        intervalLengths.put(UsageStatsManager.INTERVAL_YEARLY, YEAR);

        final int intervalCount = intervalLengths.size();
        for (int i = 0; i < intervalCount; i++) {
            final int intervalType = intervalLengths.keyAt(i);
            final long intervalDuration = intervalLengths.valueAt(i);
            final long startTime = endTime - (2 * intervalDuration);
            final List<UsageStats> statsList = mUsageStatsManager.queryUsageStats(intervalType,
                    startTime, endTime);
            assertFalse(statsList.isEmpty());

            boolean foundPackage = false;
            for (UsageStats stats : statsList) {
                // Verify that each period is a day long.
                assertLessThanOrEqual(stats.getLastTimeStamp() - stats.getFirstTimeStamp(),
                        intervalDuration);
                if (stats.getPackageName().equals(mTargetPackage) &&
                        stats.getLastTimeUsed() >= beforeTime - TIME_DIFF_THRESHOLD) {
                    foundPackage = true;
                }
            }

            assertTrue(""Did not find package "" + mTargetPackage + "" in interval "" + intervalType,
                    foundPackage);
        }
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testNoAccessSilentlyFails"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testNoAccessSilentlyFails() throws Exception {
        final long startTime = System.currentTimeMillis() - MINUTE;

        launchSubActivity(android.app.usage.cts.Activities.ActivityOne.class);
        launchSubActivity(android.app.usage.cts.Activities.ActivityThree.class);

        final long endTime = System.currentTimeMillis();
        List<UsageStats> stats = mUsageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_BEST,
                startTime, endTime);
        assertFalse(stats.isEmpty());

        // We set the mode to ignore because our package has the PACKAGE_USAGE_STATS permission,
        // and default would allow in this case.
        setAppOpsMode(""ignore"");

        stats = mUsageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_BEST,
                startTime, endTime);
        assertTrue(stats.isEmpty());
    }

    private void generateAndSendNotification() throws Exception {
        final NotificationManager mNotificationManager =
                (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
        final NotificationChannel mChannel = new NotificationChannel(CHANNEL_ID, ""Channel"",
                NotificationManager.IMPORTANCE_DEFAULT);
        // Configure the notification channel.
        mChannel.setDescription(""Test channel"");
        mNotificationManager.createNotificationChannel(mChannel);
        final Notification.Builder mBuilder =
                new Notification.Builder(mContext, CHANNEL_ID)
                        .setSmallIcon(R.drawable.ic_notification)
                        .setContentTitle(""My notification"")
                        .setContentText(""Hello World!"");
        final PendingIntent pi = PendingIntent.getActivity(mContext, 1,
                new Intent(Settings.ACTION_SETTINGS), PendingIntent.FLAG_IMMUTABLE);
        mBuilder.setContentIntent(pi);
        mNotificationManager.notify(1, mBuilder.build());
        Thread.sleep(500);
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testNotificationInterruptionEventsObfuscation"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testNotificationInterruptionEventsObfuscation() throws Exception {
        final long startTime = System.currentTimeMillis();

        // Skip the test for wearable devices and televisions; neither has a notification shade.
        assumeFalse(""Test cannot run on a watch- notification shade is not shown"",
                mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH));
        assumeFalse(""Test cannot run on a television- notifications are not shown"",
                mContext.getPackageManager().hasSystemFeature(
                        PackageManager.FEATURE_LEANBACK_ONLY));

        generateAndSendNotification();
        final long endTime = System.currentTimeMillis();

        final UsageEvents obfuscatedEvents = mUsageStatsManager.queryEvents(startTime, endTime);
        final UsageEvents unobfuscatedEvents = queryEventsAsShell(startTime, endTime);
        verifyNotificationInterruptionEvent(obfuscatedEvents, true);
        verifyNotificationInterruptionEvent(unobfuscatedEvents, false);
    }

    private void verifyNotificationInterruptionEvent(UsageEvents events, boolean obfuscated) {
        boolean found = false;
        Event event = new Event();
        while (events.hasNextEvent()) {
            events.getNextEvent(event);
            if (event.getEventType() == Event.NOTIFICATION_INTERRUPTION) {
                found = true;
                break;
            }
        }
        assertTrue(found);
        if (obfuscated) {
            assertEquals(""Notification channel id was not obfuscated."",
                    UsageEvents.OBFUSCATED_NOTIFICATION_CHANNEL_ID, event.mNotificationChannelId);
        } else {
            assertEquals(""Failed to verify notification channel id."",
                    CHANNEL_ID, event.mNotificationChannelId);
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUserUnlockedEventExists"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUserUnlockedEventExists() throws Exception {
        final UsageEvents events = mUsageStatsManager.queryEvents(0, System.currentTimeMillis());
        while (events.hasNextEvent()) {
            final Event event = new Event();
            events.getNextEvent(event);
            if (event.mEventType == Event.USER_UNLOCKED) {
                return;
            }
        }
        fail(""Couldn't find a user unlocked event."");
    }

    @AppModeFull(reason = ""No usage stats access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testCrossUserQuery_withPermission"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testCrossUserQuery_withPermission() throws Exception {
        assumeTrue(UserManager.supportsMultipleUsers());
        final long startTime = System.currentTimeMillis();
        // Create user
        final int userId = createUser(""Test User"");
        startUser(userId, true);
        installExistingPackageAsUser(mContext.getPackageName(), userId);

        // Query as Shell
        SystemUtil.runWithShellPermissionIdentity(() -> {
            final UserHandle otherUser = UserHandle.of(userId);
            final Context userContext = mContext.createContextAsUser(otherUser, 0);

            final UsageStatsManager usmOther = userContext.getSystemService(
                    UsageStatsManager.class);

            waitUntil(() -> {
                final List<UsageStats> stats = usmOther.queryUsageStats(
                        UsageStatsManager.INTERVAL_DAILY, startTime, System.currentTimeMillis());
                return stats.isEmpty();
            }, false);
        });
        // user cleanup done in @After
    }

    @AppModeFull(reason = ""No usage stats access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testCrossUserQuery_withoutPermission"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testCrossUserQuery_withoutPermission() throws Exception {
        assumeTrue(UserManager.supportsMultipleUsers());
        final long startTime = System.currentTimeMillis();
        // Create user
        final int userId = createUser(""Test User"");
        startUser(userId, true);
        installExistingPackageAsUser(mContext.getPackageName(), userId);

        SystemUtil.runWithShellPermissionIdentity(() -> {
            mOtherUserContext = mContext.createContextAsUser(UserHandle.of(userId), 0);
            mOtherUsageStats = mOtherUserContext.getSystemService(UsageStatsManager.class);
        });

        try {
            mOtherUsageStats.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, startTime,
                    System.currentTimeMillis());
            fail(""Query across users should require INTERACT_ACROSS_USERS permission"");
        } catch (SecurityException se) {
            // Expected
        }

        // user cleanup done in @After
    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	Test Available, Incomplete	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUserForceIntoRestricted"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUserForceIntoRestricted() throws Exception {
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");

        launchSubActivity(TaskRootActivity.class);
        assertEquals(""Activity launch didn't bring app up to ACTIVE bucket"",
                UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

        // User force shouldn't have to deal with the timeout.
        setStandByBucket(mTargetPackage, ""restricted"");
        assertEquals(""User was unable to force an ACTIVE app down into RESTRICTED bucket"",
                UsageStatsManager.STANDBY_BUCKET_RESTRICTED,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"UsageStats"	""	""	""	""	"There is no indication of an list of ""all"" restriction being exercised and checking if they show up in UsageStats."	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUserForceIntoRestricted_BucketDisabled"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUserForceIntoRestricted_BucketDisabled() throws Exception {
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, ""0"");

        launchSubActivity(TaskRootActivity.class);
        assertEquals(""Activity launch didn't bring app up to ACTIVE bucket"",
                UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

        // User force shouldn't have to deal with the timeout.
        setStandByBucket(mTargetPackage, ""restricted"");
        assertNotEquals(""User was able to force into RESTRICTED bucket when bucket disabled"",
                UsageStatsManager.STANDBY_BUCKET_RESTRICTED,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUserLaunchRemovesFromRestricted"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUserLaunchRemovesFromRestricted() throws Exception {
        setSetting(Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");

        setStandByBucket(mTargetPackage, ""restricted"");
        assertEquals(""User was unable to force an app into RESTRICTED bucket"",
                UsageStatsManager.STANDBY_BUCKET_RESTRICTED,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));

        launchSubActivity(TaskRootActivity.class);
        assertEquals(""Activity launch didn't bring RESTRICTED app into ACTIVE bucket"",
                UsageStatsManager.STANDBY_BUCKET_ACTIVE,
                mUsageStatsManager.getAppStandbyBucket(mTargetPackage));
    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testIsAppInactive"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testIsAppInactive() throws Exception {
        assumeTrue(""Test only works on devices with a battery"", BatteryUtils.hasBattery());

        setStandByBucket(mTargetPackage, ""rare"");

        try {
            BatteryUtils.runDumpsysBatteryUnplug();

            waitUntil(() -> mUsageStatsManager.isAppInactive(mTargetPackage), true);
            assertFalse(
                    ""App without PACKAGE_USAGE_STATS permission should always receive false for ""
                            + ""isAppInactive"",
                    isAppInactiveAsPermissionlessApp(mTargetPackage));

            launchSubActivity(Activities.ActivityOne.class);

            waitUntil(() -> mUsageStatsManager.isAppInactive(mTargetPackage), false);
            assertFalse(
                    ""App without PACKAGE_USAGE_STATS permission should always receive false for ""
                            + ""isAppInactive"",
                    isAppInactiveAsPermissionlessApp(mTargetPackage));

            mUiDevice.pressHome();
            setStandByBucket(TEST_APP_PKG, ""rare"");
            // Querying for self does not require the PACKAGE_USAGE_STATS
            waitUntil(() -> mUsageStatsManager.isAppInactive(TEST_APP_PKG), true);
            assertTrue(
                    ""App without PACKAGE_USAGE_STATS permission should be able to call ""
                            + ""isAppInactive for itself"",
                    isAppInactiveAsPermissionlessApp(TEST_APP_PKG));

            launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS);

            waitUntil(() -> mUsageStatsManager.isAppInactive(TEST_APP_PKG), false);
            assertFalse(
                    ""App without PACKAGE_USAGE_STATS permission should be able to call ""
                            + ""isAppInactive for itself"",
                    isAppInactiveAsPermissionlessApp(TEST_APP_PKG));

        } finally {
            BatteryUtils.runDumpsysBatteryReset();
        }
    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testIsAppInactive_Charging"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testIsAppInactive_Charging() throws Exception {
        assumeTrue(""Test only works on devices with a battery"", BatteryUtils.hasBattery());

        setStandByBucket(TEST_APP_PKG, ""rare"");

        try {
            BatteryUtils.runDumpsysBatteryUnplug();
            // Plug/unplug change takes a while to propagate inside the system.
            waitUntil(() -> mUsageStatsManager.isAppInactive(TEST_APP_PKG), true);

            BatteryUtils.runDumpsysBatterySetPluggedIn(true);
            BatteryUtils.runDumpsysBatterySetLevel(100);
            // Plug/unplug change takes a while to propagate inside the system.
            waitUntil(() -> mUsageStatsManager.isAppInactive(TEST_APP_PKG), false);
        } finally {
            BatteryUtils.runDumpsysBatteryReset();
        }
    }

    private static final int[] INTERACTIVE_EVENTS = new int[] {
            Event.SCREEN_INTERACTIVE,
            Event.SCREEN_NON_INTERACTIVE
    };

    private static final int[] KEYGUARD_EVENTS = new int[] {
            Event.KEYGUARD_SHOWN,
            Event.KEYGUARD_HIDDEN
    };

    private static final int[] ALL_EVENTS = new int[] {
            Event.SCREEN_INTERACTIVE,
            Event.SCREEN_NON_INTERACTIVE,
            Event.KEYGUARD_SHOWN,
            Event.KEYGUARD_HIDDEN
    };

    private static final int[] PAUSED_EVENT = new int[] {
            Event.ACTIVITY_PAUSED
    };

    private static final int[] STOPPED_EVENT = new int[] {
            Event.ACTIVITY_STOPPED
    };

    private long getEvents(int[] whichEvents, long startTime, List<Event> out, String packageName) {
        final long endTime = System.currentTimeMillis();
        if (DEBUG) {
            Log.i(TAG, ""Looking for events "" + Arrays.toString(whichEvents)
                    + "" between "" + startTime + "" and "" + endTime);
        }
        UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        long latestTime = 0;

        // Find events.
        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            final int ev = event.getEventType();
            for (int which : whichEvents) {
                if (ev == which) {
                    if (packageName != null && !packageName.equals(event.getPackageName())) {
                        break;
                    }

                    if (out != null) {
                        out.add(event);
                    }
                    if (DEBUG) Log.i(TAG, ""Next event type "" + event.getEventType()
                            + "" time="" + event.getTimeStamp());
                    if (latestTime < event.getTimeStamp()) {
                        latestTime = event.getTimeStamp();
                    }
                    break;
                }
            }
        }

        return latestTime;
    }


    private ArrayList<Event> waitForEventCount(int[] whichEvents, long startTime, int count) {
        return waitForEventCount(whichEvents, startTime, count, null);
    }

    private ArrayList<Event> waitForEventCount(int[] whichEvents, long startTime, int count,
            String packageName) {
        final ArrayList<Event> events = new ArrayList<>();
        final long endTime = SystemClock.uptimeMillis() + TIMEOUT;
        do {
            events.clear();
            getEvents(whichEvents, startTime, events, packageName);
            if (events.size() == count) {
                return events;
            }
            if (events.size() > count) {
                fail(""Found too many events: got "" + events.size() + "", expected "" + count);
                return events;
            }
            SystemClock.sleep(10);
        } while (SystemClock.uptimeMillis() < endTime);

        fail(""Timed out waiting for "" + count + "" events, only reached "" + events.size());
        return events;
    }

    private void waitUntil(BooleanSupplier condition, boolean expected) throws Exception {
        final long sleepTimeMs = 500;
        final int count = 10;
        for (int i = 0; i < count; ++i) {
            if (condition.getAsBoolean() == expected) {
                return;
            }
            Thread.sleep(sleepTimeMs);
        }
        fail(""Condition wasn't satisfied after "" + (sleepTimeMs * count) + ""ms"");
    }

    static class AggrEventData {
        final String label;
        int count;
        long duration;
        long lastEventTime;

        AggrEventData(String label) {
            this.label = label;
        }
    }

    static class AggrAllEventsData {
        final AggrEventData interactive = new AggrEventData(""Interactive"");
        final AggrEventData nonInteractive = new AggrEventData(""Non-interactive"");
        final AggrEventData keyguardShown = new AggrEventData(""Keyguard shown"");
        final AggrEventData keyguardHidden = new AggrEventData(""Keyguard hidden"");
    }

    private SparseArray<AggrAllEventsData> getAggrEventData() {
        final long endTime = System.currentTimeMillis();

        final SparseLongArray intervalLengths = new SparseLongArray();
        intervalLengths.put(UsageStatsManager.INTERVAL_DAILY, DAY);
        intervalLengths.put(UsageStatsManager.INTERVAL_WEEKLY, WEEK);
        intervalLengths.put(UsageStatsManager.INTERVAL_MONTHLY, MONTH);
        intervalLengths.put(UsageStatsManager.INTERVAL_YEARLY, YEAR);

        final SparseArray<AggrAllEventsData> allAggr = new SparseArray<>();

        final int intervalCount = intervalLengths.size();
        for (int i = 0; i < intervalCount; i++) {
            final int intervalType = intervalLengths.keyAt(i);
            final long intervalDuration = intervalLengths.valueAt(i);
            final long startTime = endTime - (2 * intervalDuration);
            List<EventStats> statsList = mUsageStatsManager.queryEventStats(intervalType,
                    startTime, endTime);
            assertFalse(statsList.isEmpty());

            final AggrAllEventsData aggr = new AggrAllEventsData();
            allAggr.put(intervalType, aggr);

            boolean foundEvent = false;
            for (EventStats stats : statsList) {
                // Verify that each period is a day long.
                //assertLessThanOrEqual(stats.getLastTimeStamp() - stats.getFirstTimeStamp(),
                //        intervalDuration);
                AggrEventData data = null;
                switch (stats.getEventType()) {
                    case Event.SCREEN_INTERACTIVE:
                        data = aggr.interactive;
                        break;
                    case Event.SCREEN_NON_INTERACTIVE:
                        data = aggr.nonInteractive;
                        break;
                    case Event.KEYGUARD_HIDDEN:
                        data = aggr.keyguardHidden;
                        break;
                    case Event.KEYGUARD_SHOWN:
                        data = aggr.keyguardShown;
                        break;
                }
                if (data != null) {
                    foundEvent = true;
                    data.count += stats.getCount();
                    data.duration += stats.getTotalTime();
                    if (data.lastEventTime < stats.getLastEventTime()) {
                        data.lastEventTime = stats.getLastEventTime();
                    }
                }
            }

            assertTrue(""Did not find event data in interval "" + intervalType,
                    foundEvent);
        }

        return allAggr;
    }

    private void verifyCount(int oldCount, int newCount, boolean larger, String label,
            int interval) {
        if (larger) {
            if (newCount <= oldCount) {
                fail(label + "" count newer "" + newCount
                        + "" expected to be larger than older "" + oldCount
                        + "" @ interval "" + interval);
            }
        } else {
            if (newCount != oldCount) {
                fail(label + "" count newer "" + newCount
                        + "" expected to be same as older "" + oldCount
                        + "" @ interval "" + interval);
            }
        }
    }

    private void verifyDuration(long oldDur, long newDur, boolean larger, String label,
            int interval) {
        if (larger) {
            if (newDur <= oldDur) {
                fail(label + "" duration newer "" + newDur
                        + "" expected to be larger than older "" + oldDur
                        + "" @ interval "" + interval);
            }
        } else {
            if (newDur != oldDur) {
                fail(label + "" duration newer "" + newDur
                        + "" expected to be same as older "" + oldDur
                        + "" @ interval "" + interval);
            }
        }
    }

    private void verifyAggrEventData(AggrEventData older, AggrEventData newer,
            boolean countLarger, boolean durationLarger, int interval) {
        verifyCount(older.count, newer.count, countLarger, older.label, interval);
        verifyDuration(older.duration, newer.duration, durationLarger, older.label, interval);
    }

    private void verifyAggrInteractiveEventData(SparseArray<AggrAllEventsData> older,
            SparseArray<AggrAllEventsData> newer, boolean interactiveLarger,
            boolean nonInteractiveLarger) {
        for (int i = 0; i < older.size(); i++) {
            AggrAllEventsData o = older.valueAt(i);
            AggrAllEventsData n = newer.valueAt(i);
            // When we are told something is larger, that means we have transitioned
            // *out* of that state -- so the duration of that state is expected to
            // increase, but the count should stay the same (and the count of the state
            // we transition to is increased).
            final int interval = older.keyAt(i);
            verifyAggrEventData(o.interactive, n.interactive, nonInteractiveLarger,
                    interactiveLarger, interval);
            verifyAggrEventData(o.nonInteractive, n.nonInteractive, interactiveLarger,
                    nonInteractiveLarger, interval);
        }
    }

    private void verifyAggrKeyguardEventData(SparseArray<AggrAllEventsData> older,
            SparseArray<AggrAllEventsData> newer, boolean hiddenLarger,
            boolean shownLarger) {
        for (int i = 0; i < older.size(); i++) {
            AggrAllEventsData o = older.valueAt(i);
            AggrAllEventsData n = newer.valueAt(i);
            // When we are told something is larger, that means we have transitioned
            // *out* of that state -- so the duration of that state is expected to
            // increase, but the count should stay the same (and the count of the state
            // we transition to is increased).
            final int interval = older.keyAt(i);
            verifyAggrEventData(o.keyguardHidden, n.keyguardHidden, shownLarger,
                    hiddenLarger, interval);
            verifyAggrEventData(o.keyguardShown, n.keyguardShown, hiddenLarger,
                    shownLarger, interval);
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testIgnoreNonexistentPackage"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testIgnoreNonexistentPackage() throws Exception {
        final String fakePackageName = ""android.fake.package.name"";
        final int defaultValue = -1;

        setStandByBucket(fakePackageName, ""rare"");
        // Verify the above does not add a new entry to the App Standby bucket map
        Map<String, Integer> bucketMap = mUsageStatsManager.getAppStandbyBuckets();
        int bucket = bucketMap.getOrDefault(fakePackageName, defaultValue);
        assertFalse(""Meaningful bucket value "" + bucket + "" returned for "" + fakePackageName
                + "" after set-standby-bucket"", bucket > 0);

        executeShellCmd(""am get-standby-bucket "" + fakePackageName);
        // Verify the above does not add a new entry to the App Standby bucket map
        bucketMap = mUsageStatsManager.getAppStandbyBuckets();
        bucket = bucketMap.getOrDefault(fakePackageName, defaultValue);
        assertFalse(""Meaningful bucket value "" + bucket + "" returned for "" + fakePackageName
                + "" after get-standby-bucket"", bucket > 0);
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testObserveUsagePermissionForRegisterObserver"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testObserveUsagePermissionForRegisterObserver() {
        final int observerId = 0;
        final String[] packages = new String[] {""com.android.settings""};

        try {
            mUsageStatsManager.registerAppUsageObserver(observerId, packages,
                    1, java.util.concurrent.TimeUnit.HOURS, null);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }

        try {
            mUsageStatsManager.registerUsageSessionObserver(observerId, packages,
                    Duration.ofHours(1), Duration.ofSeconds(10), null, null);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }

        try {
            mUsageStatsManager.registerAppUsageLimitObserver(observerId, packages,
                    Duration.ofHours(1), Duration.ofHours(0), null);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testObserveUsagePermissionForUnregisterObserver"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testObserveUsagePermissionForUnregisterObserver() {
        final int observerId = 0;

        try {
            mUsageStatsManager.unregisterAppUsageObserver(observerId);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }

        try {
            mUsageStatsManager.unregisterUsageSessionObserver(observerId);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }

        try {
            mUsageStatsManager.unregisterAppUsageLimitObserver(observerId);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testForegroundService"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testForegroundService() throws Exception {
        // This test start a foreground service then stop it. The event list should have one
        // FOREGROUND_SERVICE_START and one FOREGROUND_SERVICE_STOP event.
        final long startTime = System.currentTimeMillis();
        mContext.startService(new Intent(mContext, TestService.class));
        mUiDevice.wait(Until.hasObject(By.clazz(TestService.class)), TIMEOUT);
        final long sleepTime = 500;
        SystemClock.sleep(sleepTime);
        mContext.stopService(new Intent(mContext, TestService.class));
        mUiDevice.wait(Until.gone(By.clazz(TestService.class)), TIMEOUT);
        final long endTime = System.currentTimeMillis();
        UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        int numStarts = 0;
        int numStops = 0;
        int startIdx = -1;
        int stopIdx = -1;
        int i = 0;
        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            if (mTargetPackage.equals(event.getPackageName())
                    || TestService.class.getName().equals(event.getClassName())) {
                if (event.getEventType() == Event.FOREGROUND_SERVICE_START) {
                    numStarts++;
                    startIdx = i;
                } else if (event.getEventType() == Event.FOREGROUND_SERVICE_STOP) {
                    numStops++;
                    stopIdx = i;
                }
                i++;
            }
        }
        // One FOREGROUND_SERVICE_START event followed by one FOREGROUND_SERVICE_STOP event.
        assertEquals(numStarts, 1);
        assertEquals(numStops, 1);
        assertLessThan(startIdx, stopIdx);

        final Map<String, UsageStats> map = mUsageStatsManager.queryAndAggregateUsageStats(
            startTime, endTime);
        final UsageStats stats = map.get(mTargetPackage);
        assertNotNull(stats);
        final long lastTimeUsed = stats.getLastTimeForegroundServiceUsed();
        // lastTimeUsed should be falling between startTime and endTime.
        assertLessThan(startTime, lastTimeUsed);
        assertLessThan(lastTimeUsed, endTime);
        final long totalTimeUsed = stats.getTotalTimeForegroundServiceUsed();
        // because we slept for 500 milliseconds earlier, we know the totalTimeUsed must be more
        // more than 500 milliseconds.
        assertLessThan(sleepTime, totalTimeUsed);
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testTaskRootEventField"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testTaskRootEventField() throws Exception {
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.

        final long startTime = System.currentTimeMillis();
        launchSubActivity(TaskRootActivity.class);
        final long endTime = System.currentTimeMillis();
        UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            if (TaskRootActivity.TEST_APP_PKG.equals(event.getPackageName())
                    && TaskRootActivity.TEST_APP_CLASS.equals(event.getClassName())) {
                assertEquals(mTargetPackage, event.getTaskRootPackageName());
                assertEquals(TaskRootActivity.class.getCanonicalName(),
                        event.getTaskRootClassName());
                return;
            }
        }
        fail(""Did not find nested activity name in usage events"");
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testUsageSourceAttribution"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testUsageSourceAttribution() throws Exception {
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.
        mUiDevice.pressHome();

        setUsageSourceSetting(Integer.toString(UsageStatsManager.USAGE_SOURCE_CURRENT_ACTIVITY));
        launchSubActivity(TaskRootActivity.class);
        // Usage should be attributed to the test app package
        assertAppOrTokenUsed(TaskRootActivity.TEST_APP_PKG, true, TIMEOUT);

        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));

        setUsageSourceSetting(Integer.toString(UsageStatsManager.USAGE_SOURCE_TASK_ROOT_ACTIVITY));
        launchSubActivity(TaskRootActivity.class);
        // Usage should be attributed to this package
        assertAppOrTokenUsed(mTargetPackage, true, TIMEOUT);
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testTaskRootAttribution_finishingTaskRoot"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testTaskRootAttribution_finishingTaskRoot() throws Exception {
        setUsageSourceSetting(Integer.toString(UsageStatsManager.USAGE_SOURCE_TASK_ROOT_ACTIVITY));
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.

        launchTestActivity(TEST_APP2_PKG, TEST_APP2_CLASS_FINISHING_TASK_ROOT);
        // Wait until the nested activity gets started
        mUiDevice.wait(Until.hasObject(By.clazz(TEST_APP_PKG, TEST_APP_CLASS)), TIMEOUT);

        // Usage should be attributed to the task root app package
        assertAppOrTokenUsed(TEST_APP_PKG, false, TIMEOUT);
        assertAppOrTokenUsed(TEST_APP2_PKG, true, TIMEOUT);
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        mUiDevice.wait(Until.gone(By.clazz(TEST_APP_PKG, TEST_APP_CLASS)), TIMEOUT);

        // Usage should no longer be tracked
        assertAppOrTokenUsed(TEST_APP_PKG, false, TIMEOUT);
        assertAppOrTokenUsed(TEST_APP2_PKG, false, TIMEOUT);
    }

    @AppModeInstant"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testInstantAppUsageEventsObfuscated"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testInstantAppUsageEventsObfuscated() throws Exception {
        @SuppressWarnings(""unchecked"")
        final Class<? extends Activity>[] activitySequence = new Class[] {
                Activities.ActivityOne.class,
                Activities.ActivityTwo.class,
                Activities.ActivityThree.class,
        };
        mUiDevice.wakeUp();
        mUiDevice.pressHome();

        final long startTime = System.currentTimeMillis();
        // Launch the series of Activities.
        launchSubActivities(activitySequence);
        SystemClock.sleep(250);

        final long endTime = System.currentTimeMillis();
        final UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        int resumes = 0;
        int pauses = 0;
        int stops = 0;

        // Only look at events belongs to mTargetPackage.
        while (events.hasNextEvent()) {
            final UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            // There should be no events with this packages name
            assertNotEquals(""Instant app package name found in usage event list"",
                    mTargetPackage, event.getPackageName());

            // Look for the obfuscated instant app string instead
            if(UsageEvents.INSTANT_APP_PACKAGE_NAME.equals(event.getPackageName())) {
                switch (event.mEventType) {
                    case Event.ACTIVITY_RESUMED:
                        resumes++;
                        break;
                    case Event.ACTIVITY_PAUSED:
                        pauses++;
                        break;
                    case Event.ACTIVITY_STOPPED:
                        stops++;
                        break;
                }
            }
        }
        assertEquals(""Unexpected number of activity resumes"", 3, resumes);
        assertEquals(""Unexpected number of activity pauses"", 2, pauses);
        assertEquals(""Unexpected number of activity stops"", 2, stops);
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testSuddenDestroy"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testSuddenDestroy() throws Exception {
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.
        mUiDevice.pressHome();

        final long startTime = System.currentTimeMillis();

        launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS);
        SystemClock.sleep(500);

        // Destroy the activity
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        mUiDevice.wait(Until.gone(By.clazz(TEST_APP_PKG, TEST_APP_CLASS)), TIMEOUT);
        SystemClock.sleep(500);

        final long endTime = System.currentTimeMillis();
        final UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        int resumes = 0;
        int stops = 0;

        while (events.hasNextEvent()) {
            final UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));

            if(TEST_APP_PKG.equals(event.getPackageName())) {
                switch (event.mEventType) {
                    case Event.ACTIVITY_RESUMED:
                        assertNotNull(""ACTIVITY_RESUMED event Task Root should not be null"",
                                event.getTaskRootPackageName());
                        resumes++;
                        break;
                    case Event.ACTIVITY_STOPPED:
                        assertNotNull(""ACTIVITY_STOPPED event Task Root should not be null"",
                                event.getTaskRootPackageName());
                        stops++;
                        break;
                }
            }
        }
        assertEquals(""Unexpected number of activity resumes"", 1, resumes);
        assertEquals(""Unexpected number of activity stops"", 1, stops);
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testPipActivity"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testPipActivity() throws Exception {
        assumeTrue(""Test cannot run without Picture in Picture support"",
                mContext.getPackageManager().hasSystemFeature(
                        PackageManager.FEATURE_PICTURE_IN_PICTURE));
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.
        mUiDevice.pressHome();

        final long startTime = System.currentTimeMillis();

        launchTestActivity(TEST_APP2_PKG, TEST_APP2_CLASS_PIP);
        SystemClock.sleep(500);

        // TEST_APP_PKG should take focus, pausing the TEST_APP2_CLASS_PIP activity.
        launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS);
        SystemClock.sleep(500);

        mWMStateHelper.waitForActivityState(TEST_APP2_PIP_COMPONENT,
                WindowManagerState.STATE_PAUSED);

        mWMStateHelper.assertActivityDisplayed(TEST_APP2_PIP_COMPONENT);
        mWMStateHelper.assertNotFocusedActivity(""Pip activity should not be in focus"",
                TEST_APP2_PIP_COMPONENT);

        final long endTime = System.currentTimeMillis();
        final UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        int resumes = 0;
        int pauses = 0;
        int stops = 0;

        while (events.hasNextEvent()) {
            final UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));

            if(TEST_APP2_PKG.equals(event.getPackageName())) {
                switch (event.mEventType) {
                    case Event.ACTIVITY_RESUMED:
                        assertNotNull(""ACTIVITY_RESUMED event Task Root should not be null"",
                                event.getTaskRootPackageName());
                        resumes++;
                        break;
                    case Event.ACTIVITY_PAUSED:
                        assertNotNull(""ACTIVITY_PAUSED event Task Root should not be null"",
                                event.getTaskRootPackageName());
                        pauses++;
                        break;
                    case Event.ACTIVITY_STOPPED:
                        assertNotNull(""ACTIVITY_STOPPED event Task Root should not be null"",
                                event.getTaskRootPackageName());
                        stops++;
                        break;
                }
            }
        }
        assertEquals(""Unexpected number of activity resumes"", 1, resumes);
        assertEquals(""Unexpected number of activity pauses"", 1, pauses);
        assertEquals(""Unexpected number of activity stops"", 0, stops);
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testPipActivity_StopToPause"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testPipActivity_StopToPause() throws Exception {
        assumeTrue(""Test cannot run without Picture in Picture support"",
                mContext.getPackageManager().hasSystemFeature(
                        PackageManager.FEATURE_PICTURE_IN_PICTURE));
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.
        mUiDevice.pressHome();

        launchTestActivity(TEST_APP2_PKG, TEST_APP2_CLASS_PIP);
        SystemClock.sleep(500);

        // TEST_APP_PKG should take focus, pausing the TEST_APP2_CLASS_PIP activity.
        launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS);
        SystemClock.sleep(500);

        mWMStateHelper.assertActivityDisplayed(TEST_APP2_PIP_COMPONENT);
        mWMStateHelper.assertNotFocusedActivity(""Pip activity should not be in focus"",
                TEST_APP2_PIP_COMPONENT);

        // Sleeping the device should cause the Pip activity to stop.
        final long sleepTime = System.currentTimeMillis();
        sleepDevice();
        mWMStateHelper.waitForActivityState(TEST_APP2_PIP_COMPONENT,
                WindowManagerState.STATE_STOPPED);

        // Pip activity stop should show up in UsageStats.
        final ArrayList<Event> stoppedEvent = waitForEventCount(STOPPED_EVENT, sleepTime, 1,
                TEST_APP2_PKG);
        assertEquals(Event.ACTIVITY_STOPPED, stoppedEvent.get(0).getEventType());

        // Waking the device should cause the stopped Pip to return to the paused state.
        final long wakeTime = System.currentTimeMillis();
        mUiDevice.wakeUp();
        dismissKeyguard();
        mWMStateHelper.waitForActivityState(TEST_APP2_PIP_COMPONENT,
                WindowManagerState.STATE_PAUSED);

        mWMStateHelper.assertActivityDisplayed(TEST_APP2_PIP_COMPONENT);
        mWMStateHelper.assertNotFocusedActivity(""Pip activity should not be in focus"",
                TEST_APP2_PIP_COMPONENT);

        // Sleeping the device should cause the Pip activity to stop again.
        final long secondSleepTime = System.currentTimeMillis();
        sleepDevice();
        mWMStateHelper.waitForActivityState(TEST_APP2_PIP_COMPONENT,
                WindowManagerState.STATE_STOPPED);

        // Pip activity stop should show up in UsageStats again.
        final ArrayList<Event> secondStoppedEvent = waitForEventCount(STOPPED_EVENT,
                secondSleepTime, 1,
                TEST_APP2_PKG);
        assertEquals(Event.ACTIVITY_STOPPED, secondStoppedEvent.get(0).getEventType());
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testLocusIdEventsVisibility"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testLocusIdEventsVisibility() throws Exception {
        final long startTime = System.currentTimeMillis();
        startAndDestroyActivityWithLocus();
        final long endTime = System.currentTimeMillis();

        final UsageEvents restrictedEvents = mUsageStatsManager.queryEvents(startTime, endTime);
        final UsageEvents allEvents = queryEventsAsShell(startTime, endTime);
        verifyLocusIdEventVisibility(restrictedEvents, false);
        verifyLocusIdEventVisibility(allEvents, true);
    }

    private void startAndDestroyActivityWithLocus() {
        launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS_LOCUS);
        SystemClock.sleep(500);

        // Destroy the activity
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        mUiDevice.wait(Until.gone(By.clazz(TEST_APP_PKG, TEST_APP_CLASS_LOCUS)), TIMEOUT);
        SystemClock.sleep(500);
    }

    private void verifyLocusIdEventVisibility(UsageEvents events, boolean hasPermission) {
        int locuses = 0;
        while (events.hasNextEvent()) {
            final Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));

            if (TEST_APP_PKG.equals(event.getPackageName())
                    && event.mEventType == Event.LOCUS_ID_SET) {
                locuses++;
            }
        }

        if (hasPermission) {
            assertEquals(""LOCUS_ID_SET events were not visible."", 2, locuses);
        } else {
            assertEquals(""LOCUS_ID_SET events were visible."", 0, locuses);
        }
    }

    /**
     * Assert on an app or token's usage state.
     *
     * @param entity name of the app or token
     * @param expected expected usage state, true for in use, false for not in use
     */
    private void assertAppOrTokenUsed(String entity, boolean expected, long timeout)
            throws IOException {
        final long realtimeTimeout = SystemClock.elapsedRealtime() + timeout;
        String activeUsages;
        boolean found;
        do {
            activeUsages = executeShellCmd(""dumpsys usagestats apptimelimit actives"");
            final String[] actives = activeUsages.split(""\n"");
            found = Arrays.asList(actives).contains(entity);
        } while (found != expected && SystemClock.elapsedRealtime() <= realtimeTimeout);

        if (expected) {
            assertTrue(entity + "" not found in list of active activities and tokens\n""
                    + activeUsages, found);
        } else {
            assertFalse(entity + "" found in list of active activities and tokens\n""
                    + activeUsages, found);
        }
    }

    private void dismissKeyguard() throws Exception {
        if (mKeyguardManager.isKeyguardLocked()) {
            final long startTime = getEvents(KEYGUARD_EVENTS, 0, null, null) + 1;
            executeShellCmd(""wm dismiss-keyguard"");
            final ArrayList<Event> events = waitForEventCount(KEYGUARD_EVENTS, startTime, 1);
            assertEquals(Event.KEYGUARD_HIDDEN, events.get(0).getEventType());
            SystemClock.sleep(500);
        }
    }

    private void setStandByBucket(String packageName, String bucket) throws IOException {
        executeShellCmd(""am set-standby-bucket "" + packageName + "" "" + bucket);
    }

    private String executeShellCmd(String command) throws IOException {
        return mUiDevice.executeShellCommand(command);
    }

    private UsageEvents queryEventsAsShell(long start, long end) {
        return SystemUtil.runWithShellPermissionIdentity(() ->
                mUsageStatsManager.queryEvents(start, end));
    }

    private ITestReceiver bindToTestService() throws Exception {
        final TestServiceConnection connection = new TestServiceConnection();
        final Intent intent = new Intent().setComponent(
                new ComponentName(TEST_APP_PKG, TEST_APP_CLASS_SERVICE));
        mContext.bindService(intent, connection, Context.BIND_AUTO_CREATE);
        return ITestReceiver.Stub.asInterface(connection.getService());
    }

    private class TestServiceConnection implements ServiceConnection {
        private BlockingQueue<IBinder> mBlockingQueue = new LinkedBlockingQueue<>();

        public void onServiceConnected(ComponentName componentName, IBinder service) {
            mBlockingQueue.offer(service);
        }

        public void onServiceDisconnected(ComponentName componentName) {
        }

        public IBinder getService() throws Exception {
            final IBinder service = mBlockingQueue.poll(TIMEOUT_BINDER_SERVICE_SEC,
                    TimeUnit.SECONDS);
            return service;
        }
    }

    private void runJobImmediately() throws Exception {
        TestJob.schedule(mContext);
        executeShellCmd(JOBSCHEDULER_RUN_SHELL_COMMAND
                + "" "" + mContext.getPackageName()
                + "" "" + TestJob.TEST_JOB_ID);
    }

    private boolean isAppInactiveAsPermissionlessApp(String pkg) throws Exception {
        final ITestReceiver testService = bindToTestService();
        return testService.isAppInactive(pkg);
    }

    private int createUser(String name) throws Exception {
        final String output = executeShellCmd(
                ""pm create-user "" + name);
        if (output.startsWith(""Success"")) {
            return mOtherUser = Integer.parseInt(output.substring(output.lastIndexOf("" "")).trim());
        }
        throw new IllegalStateException(String.format(""Failed to create user: %s"", output));
    }

    private boolean removeUser(final int userId) throws Exception {
        final String output = executeShellCmd(String.format(""pm remove-user %s"", userId));
        if (output.startsWith(""Error"")) {
            return false;
        }
        return true;
    }

    private boolean startUser(int userId, boolean waitFlag) throws Exception {
        String cmd = ""am start-user "" + (waitFlag ? ""-w "" : """") + userId;

        final String output = executeShellCmd(cmd);
        if (output.startsWith(""Error"")) {
            return false;
        }
        if (waitFlag) {
            String state = executeShellCmd(""am get-started-user-state "" + userId);
            if (!state.contains(""RUNNING_UNLOCKED"")) {
                return false;
            }
        }
        return true;
    }

    private boolean stopUser(int userId, boolean waitFlag, boolean forceFlag)
            throws Exception {
        StringBuilder cmd = new StringBuilder(""am stop-user "");
        if (waitFlag) {
            cmd.append(""-w "");
        }
        if (forceFlag) {
            cmd.append(""-f "");
        }
        cmd.append(userId);

        final String output = executeShellCmd(cmd.toString());
        if (output.contains(""Error: Can't stop system user"")) {
            return false;
        }
        return true;
    }

    private void installExistingPackageAsUser(String packageName, int userId)
            throws Exception {
        executeShellCmd(
                String.format(""pm install-existing --user %d --wait %s"", userId, packageName));
    }

    private void sleepDevice() throws Exception {
        if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            mUiDevice.pressKeyCode(KeyEvent.KEYCODE_SLEEP);
        } else {
            mUiDevice.sleep();
        }

        waitUntil(() -> {
            try {
                return mUiDevice.isScreenOn();
            } catch(Exception e) {
                return true;
            }
        }, false);
    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.content.pm.cts.LauncherAppsTest"	"testGetActivityInfo"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/LauncherAppsTest.java"	""	"@AppModeFull(reason = ""Need special permission"")
    public void testGetActivityInfo() {
        LauncherActivityInfo info = mLauncherApps.resolveActivity(
                new Intent().setComponent(FULL_COMPONENT_NAME), USER_HANDLE);
        assertNotNull(info);
        assertNotNull(info.getActivityInfo());
        assertEquals(info.getName(), info.getActivityInfo().name);
        assertEquals(info.getComponentName().getPackageName(), info.getActivityInfo().packageName);
    }

    private void registerDefaultObserver() {
        registerObserver(DEFAULT_OBSERVER_ID, Duration.ofMinutes(DEFAULT_TIME_LIMIT),
                Duration.ofMinutes(0));
    }

    private void registerObserver(int observerId, Duration timeLimit, Duration timeUsed) {
        SystemUtil.runWithShellPermissionIdentity(() ->
                mUsageStatsManager.registerAppUsageLimitObserver(
                        observerId, SETTINGS_PACKAGE_GROUP, timeLimit, timeUsed,
                        PendingIntent.getActivity(mContext, -1, new Intent(), PendingIntent.FLAG_MUTABLE_UNAUDITED)));
    }

    private void unregisterObserver(int observerId) {
        SystemUtil.runWithShellPermissionIdentity(() ->
                mUsageStatsManager.unregisterAppUsageLimitObserver(observerId));
    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.util.AppStandbyUtils"	"isAppStandbyEnabled"	""	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/AppStandbyUtils.java"	""	"public void test/*
 *.
 */

package com.android.compatibility.common.util;

import android.app.usage.UsageStatsManager;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

public class AppStandbyUtils {
    private static final String TAG = ""CtsAppStandbyUtils"";
    private static final UsageStatsManager sUsageStatsManager = InstrumentationRegistry
            .getTargetContext().getSystemService(UsageStatsManager.class);

    /**
     * Returns if app standby is enabled.
     *
     * @return true if enabled; or false if disabled.
     */
    public static boolean isAppStandbyEnabled() {
        final String result = SystemUtil.runShellCommand(
                ""dumpsys usagestats is-app-standby-enabled"").trim();
        return Boolean.parseBoolean(result);
    }

    /**
     * Sets enabled state for app standby feature for runtime switch.
     *
     * App standby feature has 2 switches. This one affects the switch at runtime. If the build
     * switch is off, enabling the runtime switch will not enable App standby.
     *
     * @param enabled if App standby is enabled.
     */
    public static void setAppStandbyEnabledAtRuntime(boolean enabled) {
        final String value = enabled ? ""1"" : ""0"";
        Log.d(TAG, ""Setting AppStandby "" + (enabled ? ""enabled"" : ""disabled"") + "" at runtime."");
        SettingsUtils.putGlobalSetting(""app_standby_enabled"", value);
    }

    /**
     * Returns if app standby is enabled at runtime. Note {@link #isAppStandbyEnabled()} may still
     * return {@code false} if this method returns {@code true}, because app standby can be disabled
     * at build time as well.
     *
     * @return true if enabled at runtime; or false if disabled at runtime.
     */
    public static boolean isAppStandbyEnabledAtRuntime() {
        final String result =
                SystemUtil.runShellCommand(""settings get global app_standby_enabled"").trim();
        final boolean boolResult = result.equals(""1"") || result.equals(""null"");
        Log.d(TAG, ""AppStandby is "" + (boolResult ? ""enabled"" : ""disabled"") + "" at runtime."");
        return boolResult;
    }

    /** Returns the current standby-bucket of the package on the device */
    public static int getAppStandbyBucket(String packageName) {
        try {
            return SystemUtil.callWithShellPermissionIdentity(
                    () -> sUsageStatsManager.getAppStandbyBucket(packageName));
        } catch (Exception e) {
            throw new RuntimeException(""Could not get standby-bucket for "" + packageName, e);
        }
    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.app.usage.cts.CacheQuotaHintTest"	"testCacheQuotaHintParcelizeDeparcelize"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/CacheQuotaHintTest.java"	""	"public void testCacheQuotaHintParcelizeDeparcelize() throws Exception {
        final CacheQuotaHint hint =
                buildHint(/* volumeUuid= */ ""uuid"", /* uid= */ 0, /* quota= */ 100);

        final Parcel p = Parcel.obtain();
        hint.writeToParcel(p, 0);
        p.setDataPosition(0);

        final CacheQuotaHint targetHint = CacheQuotaHint.CREATOR.createFromParcel(p);
        p.recycle();

        assertCacheQuotaHint(targetHint);
    }

    private CacheQuotaHint buildHint(String volumeUuid, int uid, long quota) {
        return new CacheQuotaHint.Builder()
                .setVolumeUuid(volumeUuid)
                .setUid(uid)
                .setQuota(quota)
                .setUsageStats(new UsageStats()).build();
    }

    private void assertCacheQuotaHint(CacheQuotaHint hint) {
        assertEquals(""uuid"", hint.getVolumeUuid());
        assertEquals(0, hint.getUid());
        assertEquals(100, hint.getQuota());
        assertNotNull(hint.getUsageStats());
    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.provider.cts.contacts.ContactsContract_ContactsTest"	"testContactUpdate_usageStats"	"CtsContactsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/contactsprovider/src/android/provider/cts/contacts/ContactsContract_ContactsTest.java"	""	"public void testContactUpdate_usageStats() throws Exception {
        final TestRawContact rawContact = mBuilder.newRawContact().insert().load();
        final TestContact contact = rawContact.getContact().load();

        contact.load();
        assertEquals(0L, contact.getLong(Contacts.TIMES_CONTACTED));
        assertEquals(0L, contact.getLong(Contacts.LAST_TIME_CONTACTED));

        final long now = System.currentTimeMillis();

        ContentValues values = new ContentValues();
        values.clear();
        values.put(Contacts.TIMES_CONTACTED, 3);
        values.put(Contacts.LAST_TIME_CONTACTED, now);
        ContactUtil.update(mResolver, contact.getId(), values);

        contact.load();
        assertEquals(0, contact.getLong(Contacts.TIMES_CONTACTED));
        assertEquals(0, contact.getLong(Contacts.LAST_TIME_CONTACTED));

        // This is also the same as markAsContacted().
        values.clear();
        values.put(Contacts.LAST_TIME_CONTACTED, now);
        ContactUtil.update(mResolver, contact.getId(), values);

        contact.load();
        assertEquals(0, contact.getLong(Contacts.TIMES_CONTACTED));
        assertEquals(0, contact.getLong(Contacts.LAST_TIME_CONTACTED));

        values.clear();
        values.put(Contacts.TIMES_CONTACTED, 10);

        ContactUtil.update(mResolver, contact.getId(), values);

        contact.load();
        assertEquals(0, contact.getLong(Contacts.TIMES_CONTACTED));
        assertEquals(0, contact.getLong(Contacts.LAST_TIME_CONTACTED));
    }

    /**
     * Make sure the rounded usage stats values are also what the callers would see in where
     * clauses.
     *
     * This tests both contacts and raw_contacts.
     */"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.provider.cts.contacts.ContactsContract_ContactsTest"	"testContactUpdateDelete_usageStats_visibilityInWhere"	"CtsContactsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/contactsprovider/src/android/provider/cts/contacts/ContactsContract_ContactsTest.java"	""	"public void testContactUpdateDelete_usageStats_visibilityInWhere() throws Exception {
        final TestRawContact rawContact = mBuilder.newRawContact().insert().load();
        final TestContact contact = rawContact.getContact().load();

        // To make things more predictable, inline markAsContacted here with a known timestamp.
        final long now = (System.currentTimeMillis() / 86400 * 86400) + 86400 * 5 + 123;

        ContentValues values = new ContentValues();
        values.put(Contacts.LAST_TIME_CONTACTED, now);

        // This makes the internal TIMES_CONTACTED 35.  But the visible value is still 30.
        for (int i = 0; i < 35; i++) {
            ContactUtil.update(mResolver, contact.getId(), values);
        }

        contact.load();
        rawContact.load();

        assertEquals(0, contact.getLong(Contacts.LAST_TIME_CONTACTED));
        assertEquals(0, contact.getLong(Contacts.TIMES_CONTACTED));

        assertEquals(0, rawContact.getLong(Contacts.LAST_TIME_CONTACTED));
        assertEquals(0, rawContact.getLong(Contacts.TIMES_CONTACTED));
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerUsageTest"	"getTestContext"	"CtsShortcutManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerUsageTest.java"	""	"public void test/*
 *.
 */
package android.content.pm.cts.shortcutmanager;

import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.appOps;
import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.list;
import static com.android.server.pm.shortcutmanagertest.ShortcutManagerTestUtils.retryUntil;

import android.app.AppOpsManager;
import android.app.usage.UsageEvents;
import android.app.usage.UsageEvents.Event;
import android.app.usage.UsageStatsManager;
import android.content.Context;
import android.content.pm.cts.shortcutmanager.common.Constants;
import android.test.suitebuilder.annotation.SmallTest;
import android.text.format.Time;

import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.ShellIdentityUtils;

@CddTest(requirement=""3.8.1/C-4-1"")
@SmallTest
public class ShortcutManagerUsageTest extends ShortcutManagerCtsTestsBase {
    private static final String APPOPS_SET_SHELL_COMMAND = ""appops set {0} "" +
            AppOpsManager.OPSTR_GET_USAGE_STATS + "" {1}"";

    // We need some allowance due to b/30415390.
    private static long USAGE_STATS_RANGE_ALLOWANCE = 60 * 1000;

    private UsageStatsManager mUsageStatsManager;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        appOps(getInstrumentation(), getTestContext().getPackageName(),
                AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");

        mUsageStatsManager = getTestContext().getSystemService(UsageStatsManager.class);
    }

    @Override
    protected void tearDown() throws Exception {
        appOps(getInstrumentation(), getTestContext().getPackageName(),
                AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");

        super.tearDown();
    }

    private static String generateRandomId(String signature) {
        Time tobj = new Time();
        tobj.set(System.currentTimeMillis());
        return tobj.format(""%Y-%m-%d %H:%M:%S"") + ""."" + signature + "".""
                + Constants.sRandom.nextLong();
    }

    private boolean hasEvent(UsageEvents events, String packageName, String id) {
        final Event e = new Event();
        while (events.hasNextEvent()) {
            if (!events.getNextEvent(e)) {
                break;
            }
            if (e.getEventType() == Event.SHORTCUT_INVOCATION
                    && packageName.equals(e.getPackageName())
                    && id.equals(e.getShortcutId())) {
                return true;
            }
        }
        return false;
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerUsageTest"	"testReportShortcutUsed"	"CtsShortcutManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerUsageTest.java"	""	"public void testReportShortcutUsed() throws InterruptedException {

        runWithCallerWithStrictMode(mPackageContext1, () -> {
            enableManifestActivity(""Launcher_manifest_2"", true);

            retryUntil(() -> getManager().getManifestShortcuts().size() > 0,
                    ""Manifest shortcuts didn't show up"");
        });

        final String id1 = generateRandomId(""id1"");
        final String id2 = generateRandomId(""id2"");
        final String id3 = generateRandomId(""id3"");

        final String idManifest = ""ms21"";
        final String idNonexistance = ""nonexistence"";

        runWithCallerWithStrictMode(mPackageContext1, () -> {
            assertTrue(getManager().setDynamicShortcuts(list(
                    makeShortcut(id1),
                    makeShortcut(id2)
            )));
        });
        runWithCallerWithStrictMode(mPackageContext2, () -> {
            assertTrue(getManager().setDynamicShortcuts(list(
                    makeShortcut(id1),
                    makeShortcut(id3)
            )));
        });

        // Report usage.
        final long start1 = System.currentTimeMillis() - USAGE_STATS_RANGE_ALLOWANCE;
        runWithCallerWithStrictMode(mPackageContext2, () -> getManager().reportShortcutUsed(id3));
        final long end1 = System.currentTimeMillis() + USAGE_STATS_RANGE_ALLOWANCE;

        // Check the log.
        checkEventReported(start1, end1, mPackageContext2, id3, ""Events weren't populated"");

        // Report usage.
        final long start2 = System.currentTimeMillis() - USAGE_STATS_RANGE_ALLOWANCE;
        runWithCallerWithStrictMode(mPackageContext1, () -> getManager().reportShortcutUsed(id1));
        final long end2 = System.currentTimeMillis() + USAGE_STATS_RANGE_ALLOWANCE;

        // Check the log.
        checkEventReported(start2, end2, mPackageContext1, id1, ""Events weren't populated"");

        // Report usage.
        final long start3 = System.currentTimeMillis() - USAGE_STATS_RANGE_ALLOWANCE;
        runWithCallerWithStrictMode(mPackageContext1, () -> getManager().reportShortcutUsed(idNonexistance));
        runWithCallerWithStrictMode(mPackageContext1, () -> getManager().reportShortcutUsed(idManifest));
        final long end3 = System.currentTimeMillis() + USAGE_STATS_RANGE_ALLOWANCE;

        // Check the log.
        checkEventReported(start3, end3, mPackageContext1, idManifest, ""Events weren't populated"");
        // Ensure that the nonexistent shortcut is not reported, even after the other one is.
        assertFalse(hasEvent(ShellIdentityUtils.invokeMethodWithShellPermissions(
                mUsageStatsManager, (usm) -> usm.queryEvents(start3, end3)),
                mPackageContext1.getPackageName(), idNonexistance));
    }"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerUsageTest"	"testShortcutInvocationEventIsNotVisible"	"CtsShortcutManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerUsageTest.java"	""	"public void testShortcutInvocationEventIsNotVisible() {
        final String id1 = generateRandomId(""id1"");
        final String id2 = generateRandomId(""id2"");
        runWithCallerWithStrictMode(mPackageContext1,
                () -> assertTrue(getManager().setDynamicShortcuts(
                        list(makeShortcut(id1), makeShortcut(id2)))));

        // report shortcut usage
        final long start = System.currentTimeMillis() - USAGE_STATS_RANGE_ALLOWANCE;
        runWithCallerWithStrictMode(mPackageContext1, () -> getManager().reportShortcutUsed(id1));
        final long end = System.currentTimeMillis() + USAGE_STATS_RANGE_ALLOWANCE;

        // SHORTCUT_INVOCATION event should not be visible
        assertFalse(""SHORTCUT_INVOCATION event was visible."",
                hasEvent(mUsageStatsManager.queryEvents(start, end),
                        mPackageContext1.getPackageName(), id1));
    }

    private void checkEventReported(long start, long end, Context packageContext, String id,
            String failureMessage) {
        retryUntil(() -> hasEvent(
                ShellIdentityUtils.invokeMethodWithShellPermissions(mUsageStatsManager,
                        (usm) -> usm.queryEvents(start, end)), packageContext.getPackageName(), id),
                failureMessage);
    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
"3.5.1  . Application Restriction"	"3.5.1"	"C-1-9"	"3.5.1/C-1-9"	"03050100.670109"	"""C-1-9] MUST report all app restriction events via UsageStats."""	""	""	"UsageStats"	""	""	""	""	""	""	""	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerUsageTest"	"testShortcutInvocationEventIsNotVisible"	"CtsShortcutManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerUsageTest.java"	""	"public void testShortcutInvocationEventIsNotVisible() {
        final String id1 = generateRandomId(""id1"");
        final String id2 = generateRandomId(""id2"");
        runWithCallerWithStrictMode(mPackageContext1,
                () -> assertTrue(getManager().setDynamicShortcuts(
                        list(makeShortcut(id1), makeShortcut(id2)))));

        // report shortcut usage
        final long start = System.currentTimeMillis() - USAGE_STATS_RANGE_ALLOWANCE;
        runWithCallerWithStrictMode(mPackageContext1, () -> getManager().reportShortcutUsed(id1));
        final long end = System.currentTimeMillis() + USAGE_STATS_RANGE_ALLOWANCE;

        // SHORTCUT_INVOCATION event should not be visible
        assertFalse(""SHORTCUT_INVOCATION event was visible."",
                hasEvent(mUsageStatsManager.queryEvents(start, end),
                        mPackageContext1.getPackageName(), id1));
    }

    private void checkEventReported(long start, long end, Context packageContext, String id,
            String failureMessage) {
        retryUntil(() -> hasEvent(
                ShellIdentityUtils.invokeMethodWithShellPermissions(mUsageStatsManager,
                        (usm) -> usm.queryEvents(start, end)), packageContext.getPackageName(), id),
                failureMessage);
    }
}"	""	""	"UsageStats"	""	""	""	""	""	""	""	""	""	""
