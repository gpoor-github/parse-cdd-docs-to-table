"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-1"	"3.2.3.5/C-5-1"	"03020305.670501"	"""C-5-1] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_ENABLE’](https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#action_request_enable) intent and show a system activity to allow the user to turn on Bluetooth.  """	""	""	"android.bluetooth.adapter.action.REQUEST Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.admin.DeviceAdminUninstallTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/admin/DeviceAdminUninstallTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.admin;

import android.app.admin.DevicePolicyManager;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;
import android.provider.Settings;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

/**
 * Test that checks that active device admins can be easily uninstalled via the app details screen
 */
public class DeviceAdminUninstallTestActivity extends PassFailButtons.Activity implements
        View.OnClickListener {

    private static final String TAG = DeviceAdminUninstallTestActivity.class.getSimpleName();
    private static final String ADMIN_PACKAGE_NAME = ""com.android.cts.emptydeviceadmin"";
    private static final String ADMIN_RECEIVER_CLASS_NAME =
            ""com.android.cts.emptydeviceadmin.EmptyDeviceAdmin"";
    private static final String ADMIN_INSTALLED_BUNDLE_KEY = ""admin_installed"";
    private static final String ADMIN_ACTIVATED_BUNDLE_KEY = ""admin_activated"";
    private static final String ADMIN_REMOVED_BUNDLE_KEY = ""admin_removed"";

    private static final int REQUEST_ENABLE_ADMIN = 1;
    private static final int REQUEST_UNINSTALL_ADMIN = 2;

    private DevicePolicyManager mDevicePolicyManager;

    private ImageView mInstallStatus;
    private TextView mInstallAdminText;
    private Button mAddDeviceAdminButton;
    private ImageView mEnableStatus;
    private Button mUninstallAdminButton;
    private ImageView mUninstallStatus;
    private boolean mAdminInstalled;
    private boolean mAdminActivated;
    private boolean mAdminRemoved;
    private ComponentName mAdmin;
    private final BroadcastReceiver mPackageAddedListener = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final Uri uri = intent.getData();
            if (uri != null && ADMIN_PACKAGE_NAME.equals(uri.getSchemeSpecificPart())) {
                onAdminPackageInstalled();
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.da_uninstall_test_main);
        setInfoResources(R.string.da_uninstall_test, R.string.da_uninstall_test_info, -1);
        setPassFailButtonClickListeners();
        mAdmin = new ComponentName(ADMIN_PACKAGE_NAME, ADMIN_RECEIVER_CLASS_NAME);
        mDevicePolicyManager = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);

        if (savedInstanceState != null) {
            mAdminInstalled = savedInstanceState.getBoolean(ADMIN_INSTALLED_BUNDLE_KEY, false);
            mAdminActivated = savedInstanceState.getBoolean(ADMIN_ACTIVATED_BUNDLE_KEY, false);
            mAdminRemoved = savedInstanceState.getBoolean(ADMIN_REMOVED_BUNDLE_KEY, false);
        } else {
            mAdminInstalled = isPackageInstalled(ADMIN_PACKAGE_NAME);
            mAdminActivated = mDevicePolicyManager.isAdminActive(mAdmin);
        }
        mInstallStatus = findViewById(R.id.install_admin_status);
        mInstallAdminText = findViewById(R.id.install_admin_instructions);
        if (!mAdminInstalled) {
            final IntentFilter packageAddedFilter = new IntentFilter(Intent.ACTION_PACKAGE_ADDED);
            packageAddedFilter.addDataScheme(""package"");
            registerReceiver(mPackageAddedListener, packageAddedFilter);
        }

        mEnableStatus = findViewById(R.id.enable_admin_status);
        mAddDeviceAdminButton = findViewById(R.id.enable_device_admin_button);
        mAddDeviceAdminButton.setOnClickListener(this);

        mUninstallStatus = findViewById(R.id.uninstall_admin_status);
        mUninstallAdminButton = findViewById(R.id.open_app_details_button);
        mUninstallAdminButton.setOnClickListener(this);
    }

    private void onAdminPackageInstalled() {
        mAdminInstalled = true;
        updateWidgets();
        unregisterReceiver(mPackageAddedListener);
    }

    private boolean isPackageInstalled(String packageName) {
        PackageInfo packageInfo = null;
        try {
            packageInfo = getPackageManager().getPackageInfo(packageName, 0);
        } catch (PackageManager.NameNotFoundException exc) {
            // Expected.
        }
        return packageInfo != null;
    }

    @Override
    public void onClick(View v) {
        if (v == mAddDeviceAdminButton) {
            Intent securitySettingsIntent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);
            securitySettingsIntent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, mAdmin);
            startActivityForResult(securitySettingsIntent, REQUEST_ENABLE_ADMIN);
        } else if (v == mUninstallAdminButton) {
            Intent appDetails = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
            appDetails.setData(Uri.parse(""package:"" + ADMIN_PACKAGE_NAME));
            startActivityForResult(appDetails, REQUEST_UNINSTALL_ADMIN);
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REQUEST_ENABLE_ADMIN) {
            mAdminActivated = mDevicePolicyManager.isAdminActive(mAdmin);
        } else if (requestCode == REQUEST_UNINSTALL_ADMIN) {
            mAdminRemoved = !isPackageInstalled(ADMIN_PACKAGE_NAME);
        }
    }

    @Override
    public void onResume() {
        super.onResume();
        updateWidgets();
    }

    @Override
    public void onSaveInstanceState(Bundle icicle) {
        icicle.putBoolean(ADMIN_INSTALLED_BUNDLE_KEY, mAdminInstalled);
        icicle.putBoolean(ADMIN_ACTIVATED_BUNDLE_KEY, mAdminActivated);
        icicle.putBoolean(ADMIN_REMOVED_BUNDLE_KEY, mAdminRemoved);
    }

    private void updateWidgets() {
        mInstallStatus.setImageResource(
                mAdminInstalled ? R.drawable.fs_good : R.drawable.fs_indeterminate);
        mInstallAdminText.setText(mAdminInstalled ? R.string.da_admin_installed_status_text
                : R.string.da_install_admin_instructions);
        mInstallStatus.invalidate();
        mAddDeviceAdminButton.setEnabled(mAdminInstalled && !mAdminActivated);
        mEnableStatus.setImageResource(
                mAdminActivated ? R.drawable.fs_good : R.drawable.fs_indeterminate);
        mEnableStatus.invalidate();

        mUninstallAdminButton.setEnabled(mAdminActivated && !mAdminRemoved);
        mUninstallStatus.setImageResource(
                mAdminRemoved ? R.drawable.fs_good : R.drawable.fs_indeterminate);
        mUninstallStatus.invalidate();

        getPassButton().setEnabled(mAdminRemoved);
    }
}"	""	""	"REQUEST_ENABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-1"	"3.2.3.5/C-5-1"	"03020305.670501"	"""C-5-1] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_ENABLE’](https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#action_request_enable) intent and show a system activity to allow the user to turn on Bluetooth.  """	Test Available	""	"android.bluetooth.adapter.action.REQUEST Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.BluetoothToggleActivity"	"disable"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BluetoothToggleActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ToggleButton;

/**
 * Activity for testing that Bluetooth can be disabled and enabled properly. The activity shows
 * a button that toggles Bluetooth by disabling it via {@link BluetoothAdapter#disable()} and
 * enabling it via the Intent action {@link BluetoothAdapter#ACTION_REQUEST_ENABLE}.
 */
public class BluetoothToggleActivity extends PassFailButtons.Activity {

    private static final String TAG = BluetoothToggleActivity.class.getName();

    private static final int START_ENABLE_BLUETOOTH_REQUEST = 1;

    private BluetoothAdapter mBluetoothAdapter;

    private BluetoothBroadcastReceiver mReceiver;

    private ProgressDialog mDisablingDialog;

    private ToggleButton mToggleButton;

    private int mNumDisabledTimes = 0;

    private int mNumEnabledTimes = 0;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_toggle);
        setPassFailButtonClickListeners();

        mReceiver = new BluetoothBroadcastReceiver();
        IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
        registerReceiver(mReceiver, filter);

        mDisablingDialog = new ProgressDialog(this);
        mDisablingDialog.setMessage(getString(R.string.bt_disabling));

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();

        getPassButton().setEnabled(false);

        mToggleButton = (ToggleButton) findViewById(R.id.bt_toggle_button);
        mToggleButton.setChecked(mBluetoothAdapter.isEnabled());
        mToggleButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                if (mToggleButton.isChecked()) {
                    enableBluetooth();
                } else {
                    disableBluetooth();
                }
            }
        });
    }

    private void enableBluetooth() {
        mDisablingDialog.dismiss();
        mToggleButton.setEnabled(false);
        Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
        startActivityForResult(intent, START_ENABLE_BLUETOOTH_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case START_ENABLE_BLUETOOTH_REQUEST:
                boolean enabledBluetooth = RESULT_OK == resultCode;
                mToggleButton.setChecked(enabledBluetooth);
                mToggleButton.setEnabled(true);
                break;
        }
    }

    private void disableBluetooth() {
        mDisablingDialog.show();
        mToggleButton.setEnabled(false);
        if (!mBluetoothAdapter.disable()) {
            mDisablingDialog.dismiss();
            mToggleButton.setEnabled(true);
            new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setMessage(R.string.bt_disabling_error)
                .setPositiveButton(android.R.string.ok, null)
                .show();
        }
    }

    class BluetoothBroadcastReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, -1);
            int newState = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -1);
            Log.i(TAG, ""Previous state: "" + previousState + "" New state: "" + newState);

            if (BluetoothAdapter.STATE_OFF == newState
                    && (BluetoothAdapter.STATE_ON == previousState
                            || BluetoothAdapter.STATE_TURNING_OFF == previousState)) {
                mNumDisabledTimes++;
            }

            if (BluetoothAdapter.STATE_ON == newState
                    && (BluetoothAdapter.STATE_OFF == previousState
                            || BluetoothAdapter.STATE_TURNING_ON == previousState)) {
                mNumEnabledTimes++;
            }

            if (BluetoothAdapter.STATE_OFF == newState) {
                mDisablingDialog.dismiss();
                mToggleButton.setEnabled(true);
            }

            mToggleButton.setChecked(mBluetoothAdapter.isEnabled());
            getPassButton().setEnabled(mNumDisabledTimes > 0 &&  mNumEnabledTimes > 0);
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(mReceiver);
    }
}"	""	""	"Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	"This is one of the CTS tests, there is a enableBluetooth too, but it is private. For these tests the behavior of the test App must be reverse engineered. There is not a ""testX"" method to find."	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-1"	"3.2.3.5/C-5-1"	"03020305.670501"	"""C-5-1] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_ENABLE’](https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#action_request_enable) intent and show a system activity to allow the user to turn on Bluetooth.  """	""	""	"android.bluetooth.adapter.action.REQUEST Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.MessageTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/MessageTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestResult;

import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class MessageTestActivity extends PassFailButtons.Activity {

    /** Broadcast action that should only be fired when pairing for a secure connection. */
    private static final String ACTION_PAIRING_REQUEST =
            ""android.bluetooth.device.action.PAIRING_REQUEST"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;
    private static final int PICK_SERVER_DEVICE_REQUEST = 2;

    private static final String MESSAGE_DELIMITER = ""\n"";
    private static final Pattern MESSAGE_PATTERN = Pattern.compile(""Message (\\d+) to .*"");

    private BluetoothAdapter mBluetoothAdapter;
    private PairingActionReceiver mPairingActionReceiver;
    private BluetoothChatService mChatService;

    private ArrayAdapter<String> mReceivedMessagesAdapter;
    private ArrayAdapter<String> mSentMessagesAdapter;

    private ListView mReceivedMessages;
    private ListView mSentMessages;

    private TextView mEmptyReceivedView;
    private TextView mEmptySentView;

    private AlertDialog mInstructionsDialog;

    private ProgressBar mProgressBar;

    private String mDeviceAddress;

    private final boolean mSecure;
    private final boolean mServer;
    private final UUID mUuid;

    private String mRemoteDeviceName = """";
    private StringBuilder mMessageBuffer = new StringBuilder();

    MessageTestActivity(boolean secure, boolean server, UUID uuid) {
        mSecure = secure;
        mServer = server;
        mUuid = uuid;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_messages);
        setPassFailButtonClickListeners();

        mProgressBar = (ProgressBar) findViewById(R.id.bt_progress_bar);

        if (mServer) {
            setTitle(mSecure ? R.string.bt_secure_server : R.string.bt_insecure_server);
        } else {
            setTitle(mSecure ? R.string.bt_secure_client : R.string.bt_insecure_client);
        }

        mReceivedMessages = (ListView) findViewById(R.id.bt_received_messages);
        mReceivedMessagesAdapter = new ArrayAdapter<String>(this, R.layout.bt_message_row);
        mReceivedMessages.setAdapter(mReceivedMessagesAdapter);

        mSentMessages = (ListView) findViewById(R.id.bt_sent_messages);
        mSentMessagesAdapter = new ArrayAdapter<String>(this, R.layout.bt_message_row);
        mSentMessages.setAdapter(mSentMessagesAdapter);

        mEmptyReceivedView = (TextView) findViewById(R.id.bt_empty_received_messages);
        mReceivedMessages.setEmptyView(mEmptyReceivedView);

        mEmptySentView = (TextView) findViewById(R.id.bt_empty_sent_messages);
        mSentMessages.setEmptyView(mEmptySentView);

        setEmptyViewText(R.string.bt_no_messages);

        Button makeDiscoverableButton = (Button) findViewById(R.id.bt_make_discoverable_button);
        makeDiscoverableButton.setVisibility(mServer ? View.VISIBLE : View.GONE);
        makeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        getPassButton().setEnabled(false);

        mPairingActionReceiver = new PairingActionReceiver();
        IntentFilter intentFilter = new IntentFilter(ACTION_PAIRING_REQUEST);
        registerReceiver(mPairingActionReceiver, intentFilter);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (!mServer) {
            Intent intent = new Intent(this, DevicePickerActivity.class);
            startActivityForResult(intent, PICK_SERVER_DEVICE_REQUEST);
        } else {
            if (mBluetoothAdapter.isEnabled()) {
                startChatService();
            } else {
                Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
                startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
            }
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;

            case PICK_SERVER_DEVICE_REQUEST:
                if (resultCode == RESULT_OK) {
                    mDeviceAddress = data.getStringExtra(DevicePickerActivity.EXTRA_DEVICE_ADDRESS);
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;
        }
    }

    private void startChatService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(), mUuid);
        if (mServer) {
            mChatService.start(mSecure);
        } else {
            BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(mDeviceAddress);
            mChatService.connect(device, mSecure);
        }
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;
                case BluetoothChatService.MESSAGE_READ:
                    handleMessageRead(msg);
                    break;
                case BluetoothChatService.MESSAGE_WRITE:
                    handleMessageWrite(msg);
                    break;
                case BluetoothChatService.MESSAGE_DEVICE_NAME:
                    handleDeviceName(msg);
                    break;
                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_LISTEN:
                setEmptyViewText(R.string.bt_waiting);
                mProgressBar.setVisibility(View.VISIBLE);
                showInstructionsDialog();
                break;

            case BluetoothChatService.STATE_CONNECTING:
                setEmptyViewText(R.string.bt_connecting);
                mProgressBar.setVisibility(View.VISIBLE);
                break;

            case BluetoothChatService.STATE_CONNECTED:
                setEmptyViewText(R.string.bt_no_messages);
                mProgressBar.setVisibility(View.INVISIBLE);

                hideInstructionsDialog();
                sendInitialMessageFromClient();
                break;

            case BluetoothChatService.STATE_NONE:
                setEmptyViewText(R.string.bt_no_messages);
                mProgressBar.setVisibility(View.INVISIBLE);
                break;
        }
    }

    private void setEmptyViewText(int textId) {
        mEmptyReceivedView.setText(textId);
        mEmptySentView.setText(textId);
    }

    private void showInstructionsDialog() {
        if (mInstructionsDialog == null) {
            mInstructionsDialog = new AlertDialog.Builder(this)
                    .setIcon(android.R.drawable.ic_dialog_info)
                    .setTitle(getString(R.string.bt_waiting))
                    .setMessage(getString(mSecure
                            ? R.string.bt_secure_server_instructions
                            : R.string.bt_insecure_server_instructions))
                    .setPositiveButton(android.R.string.ok, null)
                    .create();
        }
        mInstructionsDialog.show();
    }

    private void hideInstructionsDialog() {
        if (mInstructionsDialog != null) {
            mInstructionsDialog.hide();
        }
    }

    private void sendInitialMessageFromClient() {
        if (!mServer) {
            sendMessage(0);
        }
    }

    private void sendMessage(int number) {
        String message = ""Message "" + number + "" to ""
                + (mRemoteDeviceName != null ? mRemoteDeviceName : """")
                + MESSAGE_DELIMITER;
        mChatService.write(message.getBytes());
    }

    private void handleMessageRead(Message msg) {
        String chunk = new String((byte[]) msg.obj, 0, msg.arg1);
        mMessageBuffer.append(chunk);

        int delimiterIndex = mMessageBuffer.indexOf(MESSAGE_DELIMITER);
        if (delimiterIndex != -1) {
            String message = mMessageBuffer.substring(0, delimiterIndex); // Chop off delimiter
            mMessageBuffer.delete(0, delimiterIndex + 1);
            addNewMessage(message);
        }
    }

    private void addNewMessage(String msg) {
        mReceivedMessagesAdapter.add(msg);
        Matcher matcher = MESSAGE_PATTERN.matcher(msg);
        if (matcher.matches()) {
            int number = Integer.valueOf(matcher.group(1));
            if (mServer && number == 10 || !mServer && number == 11) {
                getPassButton().setEnabled(true);
            }
            if (number <= 10) {
                sendMessage(number + 1);
            }
        }
    }

    private void handleMessageWrite(Message msg) {
        String sentMessage = new String((byte[]) msg.obj).trim(); // Chop off delimiter
        mSentMessagesAdapter.add(sentMessage);
    }

    private void handleDeviceName(Message msg) {
        mRemoteDeviceName = msg.getData().getString(BluetoothChatService.DEVICE_NAME);
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_LONG).show();
    }

    class PairingActionReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (!mSecure && ACTION_PAIRING_REQUEST.equals(intent.getAction())) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        showPairingErrorDialog();
                    }
                });
            }
        }
    }

    private void showPairingErrorDialog() {
        new AlertDialog.Builder(MessageTestActivity.this)
            .setIcon(android.R.drawable.ic_dialog_alert)
            .setTitle(R.string.bt_insecure_pairing_error_title)
            .setMessage(R.string.bt_insecure_pairing_error_message)
            .setPositiveButton(android.R.string.ok,
                    new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    TestResult.setFailedResult(MessageTestActivity.this, getTestId(), null);
                    finish();
                }
            })
            .setCancelable(false)
            .show();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mChatService != null) {
            mChatService.stop();
        }
        unregisterReceiver(mPairingActionReceiver);
    }
}"	""	""	"Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-1"	"3.2.3.5/C-5-1"	"03020305.670501"	"""C-5-1] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_ENABLE’](https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#action_request_enable) intent and show a system activity to allow the user to turn on Bluetooth.  """	""	""	"android.bluetooth.adapter.action.REQUEST Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.DevicePickerActivity"	"PairedDeviceClickListener"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/DevicePickerActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.R;

import android.app.Activity;
import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.AdapterView.OnItemClickListener;

import java.util.Set;

/**
 * {@link Activity} that shows a list of paired and new devices and returns the device selected
 * by the user. When the user selects a paired device, it forwards them to the Bluetooth settings
 * page, so that they can unpair it for the test.
 */
public class DevicePickerActivity extends Activity {

    public static final String EXTRA_DEVICE_ADDRESS = ""deviceAddress"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;

    private BluetoothAdapter mBluetoothAdapter;

    private DiscoveryReceiver mReceiver;

    private ArrayAdapter<Device> mNewDevicesAdapter;

    private ArrayAdapter<Device> mPairedDevicesAdapter;

    private TextView mEmptyNewView;

    private ProgressBar mProgressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.bt_device_picker);

        mProgressBar = (ProgressBar) findViewById(R.id.bt_progress_bar);

        mPairedDevicesAdapter = new ArrayAdapter<Device>(this, R.layout.bt_device_name);
        ListView pairedDevicesListView = (ListView) findViewById(R.id.bt_paired_devices);
        pairedDevicesListView.setAdapter(mPairedDevicesAdapter);
        pairedDevicesListView.setOnItemClickListener(new PairedDeviceClickListener());

        View emptyPairedView = findViewById(R.id.bt_empty_paired_devices);
        pairedDevicesListView.setEmptyView(emptyPairedView);

        mNewDevicesAdapter = new ArrayAdapter<Device>(this, R.layout.bt_device_name);
        ListView newDevicesListView = (ListView) findViewById(R.id.bt_new_devices);
        newDevicesListView.setAdapter(mNewDevicesAdapter);
        newDevicesListView.setOnItemClickListener(new NewDeviceClickListener());

        mEmptyNewView = (TextView) findViewById(R.id.bt_empty_new_devices);
        newDevicesListView.setEmptyView(mEmptyNewView);

        mReceiver = new DiscoveryReceiver();
        IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
        filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
        filter.addAction(BluetoothDevice.ACTION_FOUND);
        registerReceiver(mReceiver, filter);

        Button scanButton = (Button) findViewById(R.id.bt_scan_button);
        scanButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                scan();
            }
        });

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (mBluetoothAdapter.isEnabled()) {
            scan();
        } else {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == ENABLE_BLUETOOTH_REQUEST) {
            if (resultCode == RESULT_OK) {
                scan();
            } else {
                setResult(RESULT_CANCELED);
                finish();
            }
        }
    }

    private void scan() {
        populatePairedDevices();
        mNewDevicesAdapter.clear();
        if (mBluetoothAdapter.isDiscovering()) {
            mBluetoothAdapter.cancelDiscovery();
        }
        mBluetoothAdapter.startDiscovery();
    }

    private void populatePairedDevices() {
        mPairedDevicesAdapter.clear();
        Set<BluetoothDevice> pairedDevices = mBluetoothAdapter.getBondedDevices();
        for (BluetoothDevice device : pairedDevices) {
            mPairedDevicesAdapter.add(Device.fromBluetoothDevice(device));
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mBluetoothAdapter != null) {
            mBluetoothAdapter.cancelDiscovery();
        }
        unregisterReceiver(mReceiver);
    }

    class NewDeviceClickListener implements OnItemClickListener {
        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            Intent data = new Intent();
            Device device = (Device) parent.getItemAtPosition(position);
            data.putExtra(EXTRA_DEVICE_ADDRESS, device.mAddress);
            setResult(RESULT_OK, data);
            finish();
        }
    }

    class PairedDeviceClickListener implements OnItemClickListener {
        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            new AlertDialog.Builder(DevicePickerActivity.this)
                .setIcon(android.R.drawable.ic_dialog_alert)
                .setMessage(R.string.bt_unpair)
                .setPositiveButton(R.string.bt_settings, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        if (mBluetoothAdapter != null) {
                            mBluetoothAdapter.cancelDiscovery();
                        }
                        Intent intent = new Intent();
                        intent.setAction(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                        startActivity(intent);
                    }
                })
                .show();
        }
    }

    class DiscoveryReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (BluetoothAdapter.ACTION_DISCOVERY_STARTED.equals(intent.getAction())) {
                mEmptyNewView.setText(R.string.bt_scanning);
                mProgressBar.setVisibility(View.VISIBLE);
            } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(intent.getAction())) {
                mEmptyNewView.setText(R.string.bt_no_devices);
                mProgressBar.setVisibility(View.INVISIBLE);
            } else if (BluetoothDevice.ACTION_FOUND.equals(intent.getAction())) {
                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                if (device.getBondState() != BluetoothDevice.BOND_BONDED) {
                    mNewDevicesAdapter.add(Device.fromBluetoothDevice(device));
                }
            }
        }
    }

    static class Device {

        String mName;

        String mAddress;

        Device(String name, String address) {
            mName = name;
            mAddress = address;
        }

        @Override
        public String toString() {
            return mName + ""\n"" + mAddress;
        }

        static Device fromBluetoothDevice(BluetoothDevice device) {
            return new Device(device.getName() != null ? device.getName() : """",
                    device.getAddress());
        }
    }
}"	""	""	"Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-1"	"3.2.3.5/C-5-1"	"03020305.670501"	"""C-5-1] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_ENABLE’](https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#action_request_enable) intent and show a system activity to allow the user to turn on Bluetooth.  """	""	""	"android.bluetooth.adapter.action.REQUEST Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.ConnectionAccessServerActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/ConnectionAccessServerActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.app.AlertDialog;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.provider.Settings;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

public class ConnectionAccessServerActivity extends PassFailButtons.Activity {

    private static final String ACTION_CONNECTION_ACCESS_REQUEST =
            ""android.bluetooth.device.action.CONNECTION_ACCESS_REQUEST"";

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;

    private BluetoothAdapter mBluetoothAdapter;
    private ConnectionAccessRequestReceiver mConnectionAccessRequestReceiver;
    private BluetoothChatService mChatService;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        setContentView(R.layout.bt_connection_access);
        setInfoResources(R.string.bt_connection_access_server,
                R.string.bt_connection_access_server_info, 0);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        View settings = findViewById(R.id.bt_settings);
        settings.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                startActivity(new Intent(Settings.ACTION_BLUETOOTH_SETTINGS));
            }
        });

        Button makeDiscoverableButton = (Button) findViewById(R.id.bt_make_discoverable_button);
        makeDiscoverableButton.setVisibility(View.VISIBLE);
        makeDiscoverableButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                makeDiscoverable();
            }
        });

        mConnectionAccessRequestReceiver = new ConnectionAccessRequestReceiver();
        IntentFilter intentFilter = new IntentFilter(ACTION_CONNECTION_ACCESS_REQUEST);
        registerReceiver(mConnectionAccessRequestReceiver, intentFilter);

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (mBluetoothAdapter.isEnabled()) {
            startChatService();
        } else {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
            startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    startChatService();
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;
        }
    }

    private void startChatService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(),
                BluetoothChatService.HANDSFREE_INSECURE_UUID);
        boolean secure = false;
        mChatService.start(secure);
    }

    private void makeDiscoverable() {
        if (mBluetoothAdapter.getScanMode() !=
                BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
            Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
            intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 30);
            startActivity(intent);
        }
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;

                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_LISTEN:
                setProgressBarIndeterminateVisibility(true);
                Toast.makeText(this, R.string.bt_listening, Toast.LENGTH_SHORT).show();
                break;
        }
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_LONG).show();
    }

    class ConnectionAccessRequestReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            new AlertDialog.Builder(ConnectionAccessServerActivity.this)
                    .setMessage(R.string.bt_ca_dialog)
                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            getPassButton().setEnabled(true);
                        }
                    })
                    .setNegativeButton(android.R.string.cancel,
                            new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            getPassButton().setEnabled(false);
                        }
                    })
                    .show();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mChatService != null) {
            mChatService.stop();
        }
        unregisterReceiver(mConnectionAccessRequestReceiver);
    }
}"	""	""	"Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-1"	"3.2.3.5/C-5-1"	"03020305.670501"	"""C-5-1] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_ENABLE’](https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#action_request_enable) intent and show a system activity to allow the user to turn on Bluetooth.  """	""	""	"android.bluetooth.adapter.action.REQUEST Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.admin.tapjacking.DeviceAdminTapjackingTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/admin/tapjacking/DeviceAdminTapjackingTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.admin.tapjacking;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Bundle;
import android.os.SystemClock;
import android.util.Log;
import android.view.View;
import android.widget.Button;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

/**
 * Test that checks that device admin activate button does not allow taps when another window
 * is obscuring the device admin details
 */
public class DeviceAdminTapjackingTestActivity extends PassFailButtons.Activity implements
        View.OnClickListener {

    private static final String TAG = DeviceAdminTapjackingTestActivity.class.getSimpleName();
    private static final String ADMIN_ACTIVATED_BUNDLE_KEY = ""admin_activated"";
    private static final String ACTIVITIES_FINISHED_IN_ORDER_KEY = ""activities_finished_in_order"";
    private static final int REQUEST_ENABLE_ADMIN = 0;
    private static final int REQUEST_OVERLAY_ACTIVITY = 1;
    private static final long REMOVE_ADMIN_TIMEOUT = 5000;

    private DevicePolicyManager mDevicePolicyManager;
    private Button mAddDeviceAdminButton;
    private boolean mAdminActivated;
    private boolean mActivitiesFinishedInOrder;
    private boolean mOverlayFinished;
    private ComponentName mAdmin;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.da_tapjacking_test_main);
        setInfoResources(R.string.da_tapjacking_test, R.string.da_tapjacking_test_info, -1);
        setPassFailButtonClickListeners();

        mAdmin = new ComponentName(this, EmptyDeviceAdminReceiver.class);
        mDevicePolicyManager = (DevicePolicyManager) getSystemService(DEVICE_POLICY_SERVICE);

        if (savedInstanceState != null) {
            mAdminActivated = savedInstanceState.getBoolean(ADMIN_ACTIVATED_BUNDLE_KEY, false);
            mActivitiesFinishedInOrder = savedInstanceState.getBoolean(
                    ACTIVITIES_FINISHED_IN_ORDER_KEY, false);
        } else if (isActiveAdminAfterTimeout()) {
            Log.e(TAG, ""Could not remove active admin. Cannot proceed with test"");
            finish();
        }
        mAddDeviceAdminButton = findViewById(R.id.enable_admin_overlay_button);
        mAddDeviceAdminButton.setOnClickListener(this);
    }

    private boolean isActiveAdminAfterTimeout() {
        final long timeOut = SystemClock.uptimeMillis() + REMOVE_ADMIN_TIMEOUT;
        while (mDevicePolicyManager.isAdminActive(mAdmin)
                && SystemClock.uptimeMillis() < timeOut ) {
            try {
                Thread.sleep(1000);
            } catch(InterruptedException exc) {
            }
        }
        return mDevicePolicyManager.isAdminActive(mAdmin);
    }

    @Override
    public void onClick(View v) {
        if (v == mAddDeviceAdminButton) {
            Intent securitySettingsIntent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);
            securitySettingsIntent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, mAdmin);
            startActivityForResult(securitySettingsIntent, REQUEST_ENABLE_ADMIN);
            try {
                Thread.sleep(2000);
            } catch (InterruptedException exc) {
            }
            startActivityForResult(new Intent(this, OverlayingActivity.class),
                    REQUEST_OVERLAY_ACTIVITY);
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REQUEST_ENABLE_ADMIN) {
            mActivitiesFinishedInOrder = mOverlayFinished;
            if (resultCode == RESULT_OK) {
                mAdminActivated = true;
                Log.e(TAG, ""Admin was activated. Restart the Test"");
            }
        }
        else if (requestCode == REQUEST_OVERLAY_ACTIVITY) {
            mOverlayFinished = true;
        }
    }

    @Override
    public void onResume() {
        super.onResume();
        updateWidgets();
    }

    @Override
    public void onSaveInstanceState(Bundle icicle) {
        icicle.putBoolean(ADMIN_ACTIVATED_BUNDLE_KEY, mAdminActivated);
        icicle.putBoolean(ACTIVITIES_FINISHED_IN_ORDER_KEY, mActivitiesFinishedInOrder);
    }

    private void updateWidgets() {
        mAddDeviceAdminButton.setEnabled(!mActivitiesFinishedInOrder && !mAdminActivated);
        getPassButton().setEnabled(!mAdminActivated && mActivitiesFinishedInOrder);
    }
}"	""	""	"REQUEST_ENABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-1"	"3.2.3.5/C-5-1"	"03020305.670501"	"""C-5-1] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_ENABLE’](https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#action_request_enable) intent and show a system activity to allow the user to turn on Bluetooth.  """	""	""	"android.bluetooth.adapter.action.REQUEST Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.bluetooth.ConnectionAccessClientActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/ConnectionAccessClientActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.provider.Settings;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

public class ConnectionAccessClientActivity extends PassFailButtons.Activity {

    private static final int ENABLE_BLUETOOTH_REQUEST = 1;
    private static final int PICK_SERVER_DEVICE_REQUEST = 2;

    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothChatService mChatService;
    private String mDeviceAddress;
    private Button mPickServerButton;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
        setContentView(R.layout.bt_connection_access);
        setInfoResources(R.string.bt_connection_access_client,
                R.string.bt_connection_access_client_info, 0);
        setPassFailButtonClickListeners();

        View settings = findViewById(R.id.bt_settings);
        settings.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                startActivity(new Intent(Settings.ACTION_BLUETOOTH_SETTINGS));
            }
        });

        mPickServerButton = (Button) findViewById(R.id.bt_pick_server_button);
        mPickServerButton.setVisibility(View.VISIBLE);
        mPickServerButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                startDevicePickerActivity();
            }
        });

        mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
        if (!mBluetoothAdapter.isEnabled()) {
            mPickServerButton.setEnabled(false);
            startEnableBluetoothActivity();
        }
    }

    private void startDevicePickerActivity() {
        Intent intent = new Intent(this, DevicePickerActivity.class);
        startActivityForResult(intent, PICK_SERVER_DEVICE_REQUEST);
    }

    private void startEnableBluetoothActivity() {
        Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
        startActivityForResult(intent, ENABLE_BLUETOOTH_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        switch (requestCode) {
            case ENABLE_BLUETOOTH_REQUEST:
                if (resultCode == RESULT_OK) {
                    mPickServerButton.setEnabled(true);
                } else {
                    setResult(RESULT_CANCELED);
                    finish();
                }
                break;

            case PICK_SERVER_DEVICE_REQUEST:
                if (resultCode == RESULT_OK) {
                    mDeviceAddress = data.getStringExtra(DevicePickerActivity.EXTRA_DEVICE_ADDRESS);
                    startChartService();
                }
                break;
        }
    }

    private void startChartService() {
        mChatService = new BluetoothChatService(this, new ChatHandler(),
                BluetoothChatService.HANDSFREE_INSECURE_UUID);
        BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(mDeviceAddress);
        mChatService.connect(device, false);
    }

    private class ChatHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what) {
                case BluetoothChatService.MESSAGE_STATE_CHANGE:
                    handleStateChange(msg);
                    break;

                case BluetoothChatService.MESSAGE_DEVICE_NAME:
                    handleDeviceName(msg);
                    break;

                case BluetoothChatService.MESSAGE_TOAST:
                    handleToast(msg);
                    break;
            }
        }
    }

    private void handleStateChange(Message msg) {
        int state = msg.arg1;
        switch (state) {
            case BluetoothChatService.STATE_CONNECTING:
                setProgressBarIndeterminateVisibility(true);
                Toast.makeText(this, R.string.bt_connecting, Toast.LENGTH_SHORT).show();
                break;

            case BluetoothChatService.STATE_CONNECTED:
                setProgressBarIndeterminateVisibility(false);
                Toast.makeText(this, R.string.bt_connected, Toast.LENGTH_SHORT).show();
                break;

            case BluetoothChatService.STATE_NONE:
                setProgressBarIndeterminateVisibility(false);
                break;
        }
    }

    private void handleDeviceName(Message msg) {
        mDeviceAddress = msg.getData().getString(BluetoothChatService.DEVICE_NAME);
    }

    private void handleToast(Message msg) {
        String toast = msg.getData().getString(BluetoothChatService.TOAST);
        Toast.makeText(this, toast, Toast.LENGTH_SHORT).show();
    }
}"	""	""	"Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	""	""
"3.2.3.5  Conditional Application Intents"	"3.2.3.5"	"C-5-1"	"3.2.3.5/C-5-1"	"03020305.670501"	"""C-5-1] MUST honor the [‘android.bluetooth.adapter.action.REQUEST_ENABLE’](https://developer.android.com/reference/kotlin/android/bluetooth/BluetoothAdapter#action_request_enable) intent and show a system activity to allow the user to turn on Bluetooth.  """	""	""	"android.bluetooth.adapter.action.REQUEST Adapter.ACTION_REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	"android.content.cts.AvailableIntentsTest"	"testRequestEnableContentCaptureIntent"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/AvailableIntentsTest.java"	""	"public void testRequestEnableContentCaptureIntent() {
        if (!hasService(Context.CONTENT_CAPTURE_MANAGER_SERVICE)) return;

        Intent intent = new Intent(Settings.ACTION_REQUEST_ENABLE_CONTENT_CAPTURE);
        assertCanBeHandled(intent);
    }"	""	""	"REQUEST_ENABLE REQUEST_ENABLE"	""	""	""	""	""	""	""	""	""	""
