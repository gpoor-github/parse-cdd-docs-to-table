"Section"	"section_id"	"req_id"	"Test Availability"	"class_def"	"method"	"module"	"method_text"	"full_key"	"requirement"	"key_as_number"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"matched_terms"	"search_roots"	"qualified_method"	"max_matches"	"file_name"	"matched_files"	"methods_string"	"urls"	"protected"	"Area"	"Shortened"	"Test Level"
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-1"	""	"android.controls.cts.CtsControlsServiceTest"	"testRequestAddControl"	"CtsControlsDeviceTestCases"	""	"3.8.16/H-2-1"	""">3.8.16/H-2-1] MUST report null for the ControlsProviderService and the Control APIs. [<a href=""#3_8_user_interface_compatibility"""""	""	"ControlsProviderService"	""	""	""	"ControlsProviderService"	""	""	""	"/home/gpoor/cts-source/cts/tests/controls/src/android/controls/cts/CtsControlsServiceTest.java"	""	"public void testRequestAddControl() {         Resources res = mock(Resources.class);         when(res.getString(anyInt())).thenReturn("""");          final ComponentName testComponent = new ComponentName(""TestPkg"", ""TestClass"");         final Control control = new Control.StatelessBuilder(mControlsService.buildMower(false))                 .build();          Context context = new MockContext() {             public Resources getResources() {                 return res;             }              public void sendBroadcast(Intent intent, String receiverPermission) {                 assertEquals(intent.getAction(), ACTION_ADD_CONTROL);                 assertEquals((ComponentName) intent.getParcelableExtra(Intent.EXTRA_COMPONENT_NAME),                         testComponent);                 assertEquals((Control) intent.getParcelableExtra(EXTRA_CONTROL), control);                 assertEquals(receiverPermission, ""android.permission.BIND_CONTROLS"");             }         };          ControlsProviderService.requestAddControl(context, testComponent, control);     }      private Consumer<Integer> assertConsumer(int expectedStatus) {         return (status) -> {             ControlAction.isValidResponse(status);             assertEquals((int) status, expectedStatus);         };     }      private void subscribe(Publisher<Control> publisher, final int request,             final List<Control> addToList) {         publisher.subscribe(new Subscriber<Control>() {                 public void onSubscribe(Subscription s) {                     s.request(request);                 }                  public void onNext(Control c) {                     addToList.add(c);                 }                  public void onError(Throwable t) {                     throw new IllegalStateException(""onError should not be called here"");                 }                  public void onComplete() {                  }             });     }      private void assertControlsList(List<Control> actualControls, List<Control> expectedControls) {         assertEquals(actualControls.size(), expectedControls.size());          for (int i = 0; i < actualControls.size(); i++) {             assertControlEquals(actualControls.get(i), expectedControls.get(i));         }     }      private void assertControlEquals(Control c1, Control c2) {         assertEquals(c1.getTitle(), c2.getTitle());         assertEquals(c1.getSubtitle(), c2.getSubtitle());         assertEquals(c1.getStructure(), c2.getStructure());         assertEquals(c1.getZone(), c2.getZone());         assertEquals(c1.getDeviceType(), c2.getDeviceType());         assertEquals(c1.getStatus(), c2.getStatus());         assertEquals(c1.getControlId(), c2.getControlId());         assertEquals(c1.getCustomIcon(), c2.getCustomIcon());         assertEquals(c1.getCustomColor(), c2.getCustomColor());          assertTemplateEquals(c1.getControlTemplate(), c2.getControlTemplate());     }      private void assertTemplateEquals(ControlTemplate ct1, ControlTemplate ct2) {         if (ct1 == null) {             assertNull(ct2);             return;         } else {             assertNotNull(ct2);         }          assertNotEquals(ct1, ControlTemplate.getErrorTemplate());         assertNotEquals(ct2, ControlTemplate.getErrorTemplate());         assertEquals(ct1.getTemplateType(), ct2.getTemplateType());         assertEquals(ct1.getTemplateId(), ct2.getTemplateId());          switch (ct1.getTemplateType()) {             case ControlTemplate.TYPE_TOGGLE:                 assertToggleTemplate((ToggleTemplate) ct1, (ToggleTemplate) ct2);                 break;             case ControlTemplate.TYPE_RANGE:                 assertRangeTemplate((RangeTemplate) ct1, (RangeTemplate) ct2);                 break;             case ControlTemplate.TYPE_TEMPERATURE:                 assertTemperatureControlTemplate((TemperatureControlTemplate) ct1,                         (TemperatureControlTemplate) ct2);                 break;             case ControlTemplate.TYPE_TOGGLE_RANGE:                 assertToggleRangeTemplate((ToggleRangeTemplate) ct1, (ToggleRangeTemplate) ct2);                 break;         }     }      private void assertToggleTemplate(ToggleTemplate t1, ToggleTemplate t2) {         assertEquals(t1.isChecked(), t2.isChecked());         assertEquals(t1.getContentDescription(), t2.getContentDescription());     }      private void assertRangeTemplate(RangeTemplate t1, RangeTemplate t2) {         assertEquals(t1.getMinValue(), t2.getMinValue(), 0.0f);         assertEquals(t1.getMaxValue(), t2.getMaxValue(), 0.0f);         assertEquals(t1.getCurrentValue(), t2.getCurrentValue(), 0.0f);         assertEquals(t1.getStepValue(), t2.getStepValue(), 0.0f);         assertEquals(t1.getFormatString(), t2.getFormatString());     }      private void assertTemperatureControlTemplate(TemperatureControlTemplate t1,             TemperatureControlTemplate t2) {         assertEquals(t1.getCurrentMode(), t2.getCurrentMode());         assertEquals(t1.getCurrentActiveMode(), t2.getCurrentActiveMode());         assertEquals(t1.getModes(), t2.getModes());         assertTemplateEquals(t1.getTemplate(), t2.getTemplate());     }      private void assertToggleRangeTemplate(ToggleRangeTemplate t1, ToggleRangeTemplate t2) {         assertEquals(t1.isChecked(), t2.isChecked());         assertEquals(t1.getActionDescription(), t2.getActionDescription());         assertRangeTemplate(t1.getRange(), t2.getRange());     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEndToEndTest"	"testTypeNotificationStateChangedAccessibilityEvent"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEndToEndTest.java"	""	"public void testTypeNotificationStateChangedAccessibilityEvent() throws Throwable {         // No notification UI on televisions.         if ((mActivity.getResources().getConfiguration().uiMode                 & Configuration.UI_MODE_TYPE_MASK) == Configuration.UI_MODE_TYPE_TELEVISION) {             Log.i(LOG_TAG, ""Skipping: testTypeNotificationStateChangedAccessibilityEvent"" +                     "" - No notification UI on televisions."");             return;         }         PackageManager pm = sInstrumentation.getTargetContext().getPackageManager();         if (pm.hasSystemFeature(pm.FEATURE_WATCH)) {             Log.i(LOG_TAG, ""Skipping: testTypeNotificationStateChangedAccessibilityEvent"" +                     "" - Watches have different notification system."");             return;         }         if (pm.hasSystemFeature(pm.FEATURE_AUTOMOTIVE)) {             Log.i(LOG_TAG, ""Skipping: testTypeNotificationStateChangedAccessibilityEvent"" +                     "" - Automotive handle notifications differently."");             return;         }          String message = mActivity.getString(R.string.notification_message);          final NotificationManager notificationManager =                 (NotificationManager) mActivity.getSystemService(Service.NOTIFICATION_SERVICE);         final NotificationChannel channel =                 new NotificationChannel(""id"", ""name"", NotificationManager.IMPORTANCE_DEFAULT);         try {             // create the notification to send             channel.enableVibration(true);             channel.enableLights(true);             channel.setBypassDnd(true);             notificationManager.createNotificationChannel(channel);             NotificationChannel created =                     notificationManager.getNotificationChannel(channel.getId());             final int notificationId = 1;             final Notification notification =                     new Notification.Builder(mActivity, channel.getId())                             .setSmallIcon(android.R.drawable.stat_notify_call_mute)                             .setContentIntent(PendingIntent.getActivity(mActivity, 0,                                     new Intent(),                                     PendingIntent.FLAG_CANCEL_CURRENT))                             .setTicker(message)                             .setContentTitle("""")                             .setContentText("""")                             .setPriority(Notification.PRIORITY_MAX)                             // Mark the notification as ""interruptive"" by specifying a vibration                             // pattern. This ensures it's announced properly on watch-type devices.                             .setVibrate(new long[]{})                             .build();              // create and populate the expected event             final AccessibilityEvent expected = AccessibilityEvent.obtain();             expected.setEventType(AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);             expected.setClassName(Notification.class.getName());             expected.setPackageName(mActivity.getPackageName());             expected.getText().add(message);             expected.setParcelableData(notification);              AccessibilityEvent awaitedEvent =                     sUiAutomation.executeAndWaitForEvent(                             new Runnable() {                                 @Override                                 public void run() {                                     // trigger the event                                     mActivity.runOnUiThread(new Runnable() {                                         @Override                                         public void run() {                                             // trigger the event                                             notificationManager                                                     .notify(notificationId, notification);                                             mActivity.finish();                                         }                                     });                                 }                             },                             new UiAutomation.AccessibilityEventFilter() {                                 // check the received event                                 @Override                                 public boolean accept(AccessibilityEvent event) {                                     return equalsAccessiblityEvent(event, expected);                                 }                             },                             DEFAULT_TIMEOUT_MS);             assertNotNull(""Did not receive expected event: "" + expected, awaitedEvent);         } finally {             notificationManager.deleteNotificationChannel(channel.getId());         }     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEndToEndTest"	"testInterrupt_notifiesService"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEndToEndTest.java"	""	"public void testInterrupt_notifiesService() {         sInstrumentation                 .getUiAutomation(UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);         InstrumentedAccessibilityService service =                 enableService(InstrumentedAccessibilityService.class);          try {             assertFalse(service.wasOnInterruptCalled());              mActivity.runOnUiThread(() -> {                 AccessibilityManager accessibilityManager = (AccessibilityManager) mActivity                         .getSystemService(Service.ACCESSIBILITY_SERVICE);                 accessibilityManager.interrupt();             });              Object waitObject = service.getInterruptWaitObject();             synchronized (waitObject) {                 if (!service.wasOnInterruptCalled()) {                     try {                         waitObject.wait(DEFAULT_TIMEOUT_MS);                     } catch (InterruptedException e) {                         // Do nothing                     }                 }             }             assertTrue(service.wasOnInterruptCalled());         } finally {             service.disableSelfAndRemove();         }     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEndToEndTest"	"testA11yActionTriggerMotionEventActionOutside"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEndToEndTest.java"	""	"public void testA11yActionTriggerMotionEventActionOutside() throws Exception {         final View.OnTouchListener listener = mock(View.OnTouchListener.class);         final AccessibilityNodeInfo button = sUiAutomation.getRootInActiveWindow()                 .findAccessibilityNodeInfosByViewId(                         ""android.accessibilityservice.cts:id/button"")                 .get(0);         final String title = sInstrumentation.getContext().getString(R.string.alert_title);          // Add a dialog that is watching outside touch         sUiAutomation.executeAndWaitForEvent(                 () -> sInstrumentation.runOnMainSync(() -> {                             final AlertDialog dialog = new AlertDialog.Builder(mActivity)                                     .setTitle(R.string.alert_title)                                     .setMessage(R.string.alert_message)                                     .create();                             final Window window = dialog.getWindow();                             window.addFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL                                     | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);                             window.getDecorView().setOnTouchListener(listener);                             window.setTitle(title);                             dialog.show();                     }),                 (event) -> {                     // Ensure the dialog is shown over the activity                     final AccessibilityWindowInfo dialog = findWindowByTitle(                             sUiAutomation, title);                     final AccessibilityWindowInfo activity = findWindowByTitle(                             sUiAutomation, getActivityTitle(sInstrumentation, mActivity));                     return (dialog != null && activity != null)                             && (dialog.getLayer() > activity.getLayer());                 }, DEFAULT_TIMEOUT_MS);          // Perform an action and wait for an event         sUiAutomation.executeAndWaitForEvent(                 () -> button.performAction(AccessibilityNodeInfo.ACTION_CLICK),                 filterForEventType(AccessibilityEvent.TYPE_VIEW_CLICKED), DEFAULT_TIMEOUT_MS);          // Make sure the MotionEvent.ACTION_OUTSIDE is received.         verify(listener, timeout(DEFAULT_TIMEOUT_MS).atLeastOnce()).onTouch(any(View.class),                 argThat(event -> event.getActionMasked() == MotionEvent.ACTION_OUTSIDE));     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEndToEndTest"	"testTouchDelegateCoverParentWithEbt_HoverChildAndBack_FocusTargetAgain"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEndToEndTest.java"	""	"public void testTouchDelegateCoverParentWithEbt_HoverChildAndBack_FocusTargetAgain()             throws Throwable {         mActivity.waitForEnterAnimationComplete();          final int touchableSize = 48;         final Resources resources = sInstrumentation.getTargetContext().getResources();         final String targetResourceName = resources.getResourceName(R.id.buttonDelegated);         final View textView = mActivity.findViewById(R.id.delegateText);         final Button target = mActivity.findViewById(R.id.buttonDelegated);         int[] location = new int[2];         textView.getLocationOnScreen(location);         final int textX = location[0] + touchableSize/2;         final int textY = location[1] + textView.getHeight() / 2;         final int delegateX = location[0] - touchableSize/2;         final int targetX = target.getWidth() / 2;         final int targetY = target.getHeight() / 2;         final View.OnHoverListener listener = CtsMouseUtil.installHoverListener(target, false);         enableTouchExploration(sInstrumentation, true);          try {             final long downTime = SystemClock.uptimeMillis();             // Like switch bar, it has a text view, a button and a delegate covers parent layout.             // hover the delegate, text and delegate again.             sUiAutomation.executeAndWaitForEvent(                     () -> injectHoverEvent(downTime, false, delegateX, textY),                     filterForEventTypeWithResource(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER,                            targetResourceName), DEFAULT_TIMEOUT_MS);             assertTrue(target.isHovered());             sUiAutomation.executeAndWaitForEvent(                     () -> injectHoverEvent(downTime, true, textX, textY),                     filterForEventTypeWithResource(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT,                            targetResourceName), DEFAULT_TIMEOUT_MS);             sUiAutomation.executeAndWaitForEvent(                     () -> injectHoverEvent(downTime, true, delegateX, textY),                     filterForEventTypeWithResource(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER,                            targetResourceName), DEFAULT_TIMEOUT_MS);             assertTrue(target.isHovered());              CtsMouseUtil.clearHoverListener(target);             View.OnHoverListener verifier = inOrder(listener).verify(listener);             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_ENTER, targetX, targetY));             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_MOVE, targetX, targetY));             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_MOVE, textX, textY));             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_EXIT, targetX, targetY));             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_ENTER, targetX, targetY));             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_MOVE, targetX, targetY));         } catch (TimeoutException e) {             fail(""Accessibility events should be received as expected "" + e.getMessage());         } finally {             enableTouchExploration(sInstrumentation, false);         }     }      private static void assertPackageName(AccessibilityNodeInfo node, String packageName) {         if (node == null) {             return;         }         assertEquals(packageName, node.getPackageName());         final int childCount = node.getChildCount();         for (int i = 0; i < childCount; i++) {             AccessibilityNodeInfo child = node.getChild(i);             if (child != null) {                 assertPackageName(child, packageName);             }         }     }      private static void enableTouchExploration(Instrumentation instrumentation, boolean enabled)             throws InterruptedException {         final int TIMEOUT_FOR_SERVICE_ENABLE = 10000; // millis; 10s         final Object waitObject = new Object();         final AtomicBoolean atomicBoolean = new AtomicBoolean(!enabled);         AccessibilityManager.TouchExplorationStateChangeListener serviceListener = (boolean b) -> {             synchronized (waitObject) {                 atomicBoolean.set(b);                 waitObject.notifyAll();             }         };         final AccessibilityManager manager =                 (AccessibilityManager) instrumentation.getContext().getSystemService(                         Service.ACCESSIBILITY_SERVICE);         manager.addTouchExplorationStateChangeListener(serviceListener);          final UiAutomation uiAutomation = instrumentation.getUiAutomation();         final AccessibilityServiceInfo info = uiAutomation.getServiceInfo();         assert info != null;         if (enabled) {             info.flags |= AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE;         } else {             info.flags &= ~AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE;         }         uiAutomation.setServiceInfo(info);          final long timeoutTime = System.currentTimeMillis() + TIMEOUT_FOR_SERVICE_ENABLE;         synchronized (waitObject) {             while ((enabled != atomicBoolean.get()) && (System.currentTimeMillis() < timeoutTime)) {                 waitObject.wait(timeoutTime - System.currentTimeMillis());             }         }         if (enabled) {             assertTrue(""Touch exploration state listener not called when services enabled"",                     atomicBoolean.get());             assertTrue(""Timed out enabling accessibility"",                     manager.isEnabled() && manager.isTouchExplorationEnabled());         } else {             assertFalse(""Touch exploration state listener not called when services disabled"",                     atomicBoolean.get());             assertFalse(""Timed out disabling accessibility"",                     manager.isEnabled() && manager.isTouchExplorationEnabled());         }         manager.removeTouchExplorationStateChangeListener(serviceListener);     }      private static MotionEvent matchHover(int action, int x, int y) {         return argThat(new CtsMouseUtil.PositionMatcher(action, x, y));     }      private static void injectHoverEvent(long downTime, boolean isFirstHoverEvent,             int xOnScreen, int yOnScreen) {         final long eventTime = isFirstHoverEvent ? SystemClock.uptimeMillis() : downTime;         MotionEvent event = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_HOVER_MOVE,                 xOnScreen, yOnScreen, 0);         event.setSource(InputDevice.SOURCE_TOUCHSCREEN);         sUiAutomation.injectInputEvent(event, true);         event.recycle();     }      private AppWidgetProviderInfo getAppWidgetProviderInfo() {         final ComponentName componentName = new ComponentName(                 ""foo.bar.baz"", ""foo.bar.baz.MyAppWidgetProvider"");         final List<AppWidgetProviderInfo> providers = getAppWidgetManager().getInstalledProviders();         final int providerCount = providers.size();         for (int i = 0; i < providerCount; i++) {             final AppWidgetProviderInfo provider = providers.get(i);             if (componentName.equals(provider.provider)                     && Process.myUserHandle().equals(provider.getProfile())) {                 return provider;             }         }         return null;     }      private void grantBindAppWidgetPermission() throws Exception {         ShellCommandBuilder.execShellCommand(sUiAutomation,                 GRANT_BIND_APP_WIDGET_PERMISSION_COMMAND + getCurrentUser());     }      private void revokeBindAppWidgetPermission() throws Exception {         ShellCommandBuilder.execShellCommand(sUiAutomation,                 REVOKE_BIND_APP_WIDGET_PERMISSION_COMMAND + getCurrentUser());     }      private AppWidgetManager getAppWidgetManager() {         return (AppWidgetManager) sInstrumentation.getTargetContext()                 .getSystemService(Context.APPWIDGET_SERVICE);     }      private boolean hasAppWidgets() {         return sInstrumentation.getTargetContext().getPackageManager()                 .hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS);     }      /**      * Compares all properties of the <code>first</code> and the      * <code>second</code>.      */     private boolean equalsAccessiblityEvent(AccessibilityEvent first, AccessibilityEvent second) {          return first.getEventType() == second.getEventType()             && first.isChecked() == second.isChecked()             && first.getCurrentItemIndex() == second.getCurrentItemIndex()             && first.isEnabled() == second.isEnabled()             && first.getFromIndex() == second.getFromIndex()             && first.getItemCount() == second.getItemCount()             && first.isPassword() == second.isPassword()             && first.getRemovedCount() == second.getRemovedCount()             && first.isScrollable()== second.isScrollable()             && first.getToIndex() == second.getToIndex()             && first.getRecordCount() == second.getRecordCount()             && first.getScrollX() == second.getScrollX()             && first.getScrollY() == second.getScrollY()             && first.getAddedCount() == second.getAddedCount()             && TextUtils.equals(first.getBeforeText(), second.getBeforeText())             && TextUtils.equals(first.getClassName(), second.getClassName())             && TextUtils.equals(first.getContentDescription(), second.getContentDescription())             && equalsNotificationAsParcelableData(first, second)             && equalsText(first, second);     }      /**      * Compares the {@link android.os.Parcelable} data of the      * <code>first</code> and <code>second</code>.      */     private boolean equalsNotificationAsParcelableData(AccessibilityEvent first,             AccessibilityEvent second) {         Notification firstNotification = (Notification) first.getParcelableData();         Notification secondNotification = (Notification) second.getParcelableData();         if (firstNotification == null) {             return (secondNotification == null);         } else if (secondNotification == null) {             return false;         }         return TextUtils.equals(firstNotification.tickerText, secondNotification.tickerText);     }      /**      * Compares the text of the <code>first</code> and <code>second</code> text.      */     private boolean equalsText(AccessibilityEvent first, AccessibilityEvent second) {         List<CharSequence> firstText = first.getText();         List<CharSequence> secondText = second.getText();         if (firstText.size() != secondText.size()) {             return false;         }         Iterator<CharSequence> firstIterator = firstText.iterator();         Iterator<CharSequence> secondIterator = secondText.iterator();         for (int i = 0; i < firstText.size(); i++) {             if (!firstIterator.next().toString().equals(secondIterator.next().toString())) {                 return false;             }         }         return true;     }      private boolean hasTooltipShowing(int id) {         return getOnMain(sInstrumentation, () -> {             final View viewWithTooltip = mActivity.findViewById(id);             if (viewWithTooltip == null) {                 return false;             }             final View tooltipView = viewWithTooltip.getTooltipView();             return (tooltipView != null) && (tooltipView.getParent() != null);         });     }      private static int getCurrentUser() {         return android.os.Process.myUserHandle().getIdentifier();     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEndToEndTest"	"postTestTearDown"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEndToEndTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibility.cts.common.InstrumentedAccessibilityService.enableService; import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterForEventType; import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterForEventTypeWithResource; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.findWindowByTitle; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.getActivityTitle; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS; import static android.accessibilityservice.cts.utils.RunOnMainUtils.getOnMain; import static android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction.ACTION_HIDE_TOOLTIP; import static android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction.ACTION_SHOW_TOOLTIP;  import static org.hamcrest.Matchers.in; import static org.hamcrest.Matchers.not; import static org.hamcrest.core.IsEqual.equalTo; import static org.hamcrest.core.IsNull.notNullValue; import static org.hamcrest.core.IsNull.nullValue; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertThat; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.mockito.ArgumentMatchers.any; import static org.mockito.ArgumentMatchers.argThat; import static org.mockito.ArgumentMatchers.eq; import static org.mockito.Mockito.inOrder; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.timeout; import static org.mockito.Mockito.verify;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityService; import android.accessibility.cts.common.ShellCommandBuilder; import android.accessibilityservice.AccessibilityServiceInfo; import android.accessibilityservice.cts.activities.AccessibilityEndToEndActivity; import android.app.Activity; import android.app.AlertDialog; import android.app.Instrumentation; import android.app.Notification; import android.app.NotificationChannel; import android.app.NotificationManager; import android.app.PendingIntent; import android.app.Service; import android.app.UiAutomation; import android.appwidget.AppWidgetHost; import android.appwidget.AppWidgetManager; import android.appwidget.AppWidgetProviderInfo; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.pm.PackageManager; import android.content.res.Configuration; import android.content.res.Resources; import android.graphics.Rect; import android.graphics.Region; import android.os.Process; import android.os.SystemClock; import android.platform.test.annotations.AppModeFull; import android.platform.test.annotations.Presubmit; import android.test.suitebuilder.annotation.MediumTest; import android.text.TextUtils; import android.util.Log; import android.view.InputDevice; import android.view.MotionEvent; import android.view.TouchDelegate; import android.view.View; import android.view.Window; import android.view.WindowManager; import android.view.accessibility.AccessibilityEvent; import android.view.accessibility.AccessibilityManager; import android.view.accessibility.AccessibilityNodeInfo; import android.view.accessibility.AccessibilityWindowInfo; import android.widget.Button; import android.widget.EditText; import android.widget.ListView;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.CtsMouseUtil;  import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.Iterator; import java.util.List; import java.util.concurrent.TimeoutException; import java.util.concurrent.atomic.AtomicBoolean;  /**  * This class performs end-to-end testing of the accessibility feature by  * creating an {@link Activity} and poking around so {@link AccessibilityEvent}s  * are generated and their correct dispatch verified.  */ @RunWith(AndroidJUnit4.class) public class AccessibilityEndToEndTest {      private static final String LOG_TAG = ""AccessibilityEndToEndTest"";      private static final String GRANT_BIND_APP_WIDGET_PERMISSION_COMMAND =             ""appwidget grantbind --package android.accessibilityservice.cts --user "";      private static final String REVOKE_BIND_APP_WIDGET_PERMISSION_COMMAND =             ""appwidget revokebind --package android.accessibilityservice.cts --user "";      private static final String APP_WIDGET_PROVIDER_PACKAGE = ""foo.bar.baz"";      private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private AccessibilityEndToEndActivity mActivity;      private ActivityTestRule<AccessibilityEndToEndActivity> mActivityRule =             new ActivityTestRule<>(AccessibilityEndToEndActivity.class, false, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mDumpOnFailureRule);      @BeforeClass     public static void oneTimeSetup() throws Exception {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation();     }      @AfterClass     public static void postTestTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         mActivity = launchActivityAndWaitForItToBeOnscreen(                 sInstrumentation, sUiAutomation, mActivityRule);     }      @MediumTest     @Presubmit"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEndToEndTest"	"testTypeNotificationStateChangedAccessibilityEvent"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEndToEndTest.java"	""	"public void testTypeNotificationStateChangedAccessibilityEvent() throws Throwable {         // No notification UI on televisions.         if ((mActivity.getResources().getConfiguration().uiMode                 & Configuration.UI_MODE_TYPE_MASK) == Configuration.UI_MODE_TYPE_TELEVISION) {             Log.i(LOG_TAG, ""Skipping: testTypeNotificationStateChangedAccessibilityEvent"" +                     "" - No notification UI on televisions."");             return;         }         PackageManager pm = sInstrumentation.getTargetContext().getPackageManager();         if (pm.hasSystemFeature(pm.FEATURE_WATCH)) {             Log.i(LOG_TAG, ""Skipping: testTypeNotificationStateChangedAccessibilityEvent"" +                     "" - Watches have different notification system."");             return;         }         if (pm.hasSystemFeature(pm.FEATURE_AUTOMOTIVE)) {             Log.i(LOG_TAG, ""Skipping: testTypeNotificationStateChangedAccessibilityEvent"" +                     "" - Automotive handle notifications differently."");             return;         }          String message = mActivity.getString(R.string.notification_message);          final NotificationManager notificationManager =                 (NotificationManager) mActivity.getSystemService(Service.NOTIFICATION_SERVICE);         final NotificationChannel channel =                 new NotificationChannel(""id"", ""name"", NotificationManager.IMPORTANCE_DEFAULT);         try {             // create the notification to send             channel.enableVibration(true);             channel.enableLights(true);             channel.setBypassDnd(true);             notificationManager.createNotificationChannel(channel);             NotificationChannel created =                     notificationManager.getNotificationChannel(channel.getId());             final int notificationId = 1;             final Notification notification =                     new Notification.Builder(mActivity, channel.getId())                             .setSmallIcon(android.R.drawable.stat_notify_call_mute)                             .setContentIntent(PendingIntent.getActivity(mActivity, 0,                                     new Intent(),                                     PendingIntent.FLAG_CANCEL_CURRENT))                             .setTicker(message)                             .setContentTitle("""")                             .setContentText("""")                             .setPriority(Notification.PRIORITY_MAX)                             // Mark the notification as ""interruptive"" by specifying a vibration                             // pattern. This ensures it's announced properly on watch-type devices.                             .setVibrate(new long[]{})                             .build();              // create and populate the expected event             final AccessibilityEvent expected = AccessibilityEvent.obtain();             expected.setEventType(AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);             expected.setClassName(Notification.class.getName());             expected.setPackageName(mActivity.getPackageName());             expected.getText().add(message);             expected.setParcelableData(notification);              AccessibilityEvent awaitedEvent =                     sUiAutomation.executeAndWaitForEvent(                             new Runnable() {                                 @Override                                 public void run() {                                     // trigger the event                                     mActivity.runOnUiThread(new Runnable() {                                         @Override                                         public void run() {                                             // trigger the event                                             notificationManager                                                     .notify(notificationId, notification);                                             mActivity.finish();                                         }                                     });                                 }                             },                             new UiAutomation.AccessibilityEventFilter() {                                 // check the received event                                 @Override                                 public boolean accept(AccessibilityEvent event) {                                     return equalsAccessiblityEvent(event, expected);                                 }                             },                             DEFAULT_TIMEOUT_MS);             assertNotNull(""Did not receive expected event: "" + expected, awaitedEvent);         } finally {             notificationManager.deleteNotificationChannel(channel.getId());         }     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEndToEndTest"	"testTouchDelegateCoverParentWithEbt_HoverChildAndBack_FocusTargetAgain"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEndToEndTest.java"	""	"public void testTouchDelegateCoverParentWithEbt_HoverChildAndBack_FocusTargetAgain()             throws Throwable {         mActivity.waitForEnterAnimationComplete();          final int touchableSize = 48;         final Resources resources = sInstrumentation.getTargetContext().getResources();         final String targetResourceName = resources.getResourceName(R.id.buttonDelegated);         final View textView = mActivity.findViewById(R.id.delegateText);         final Button target = mActivity.findViewById(R.id.buttonDelegated);         int[] location = new int[2];         textView.getLocationOnScreen(location);         final int textX = location[0] + touchableSize/2;         final int textY = location[1] + textView.getHeight() / 2;         final int delegateX = location[0] - touchableSize/2;         final int targetX = target.getWidth() / 2;         final int targetY = target.getHeight() / 2;         final View.OnHoverListener listener = CtsMouseUtil.installHoverListener(target, false);         enableTouchExploration(sInstrumentation, true);          try {             final long downTime = SystemClock.uptimeMillis();             // Like switch bar, it has a text view, a button and a delegate covers parent layout.             // hover the delegate, text and delegate again.             sUiAutomation.executeAndWaitForEvent(                     () -> injectHoverEvent(downTime, false, delegateX, textY),                     filterForEventTypeWithResource(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER,                            targetResourceName), DEFAULT_TIMEOUT_MS);             assertTrue(target.isHovered());             sUiAutomation.executeAndWaitForEvent(                     () -> injectHoverEvent(downTime, true, textX, textY),                     filterForEventTypeWithResource(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT,                            targetResourceName), DEFAULT_TIMEOUT_MS);             sUiAutomation.executeAndWaitForEvent(                     () -> injectHoverEvent(downTime, true, delegateX, textY),                     filterForEventTypeWithResource(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER,                            targetResourceName), DEFAULT_TIMEOUT_MS);             assertTrue(target.isHovered());              CtsMouseUtil.clearHoverListener(target);             View.OnHoverListener verifier = inOrder(listener).verify(listener);             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_ENTER, targetX, targetY));             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_MOVE, targetX, targetY));             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_MOVE, textX, textY));             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_EXIT, targetX, targetY));             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_ENTER, targetX, targetY));             verifier.onHover(eq(target),                     matchHover(MotionEvent.ACTION_HOVER_MOVE, targetX, targetY));         } catch (TimeoutException e) {             fail(""Accessibility events should be received as expected "" + e.getMessage());         } finally {             enableTouchExploration(sInstrumentation, false);         }     }      private static void assertPackageName(AccessibilityNodeInfo node, String packageName) {         if (node == null) {             return;         }         assertEquals(packageName, node.getPackageName());         final int childCount = node.getChildCount();         for (int i = 0; i < childCount; i++) {             AccessibilityNodeInfo child = node.getChild(i);             if (child != null) {                 assertPackageName(child, packageName);             }         }     }      private static void enableTouchExploration(Instrumentation instrumentation, boolean enabled)             throws InterruptedException {         final int TIMEOUT_FOR_SERVICE_ENABLE = 10000; // millis; 10s         final Object waitObject = new Object();         final AtomicBoolean atomicBoolean = new AtomicBoolean(!enabled);         AccessibilityManager.TouchExplorationStateChangeListener serviceListener = (boolean b) -> {             synchronized (waitObject) {                 atomicBoolean.set(b);                 waitObject.notifyAll();             }         };         final AccessibilityManager manager =                 (AccessibilityManager) instrumentation.getContext().getSystemService(                         Service.ACCESSIBILITY_SERVICE);         manager.addTouchExplorationStateChangeListener(serviceListener);          final UiAutomation uiAutomation = instrumentation.getUiAutomation();         final AccessibilityServiceInfo info = uiAutomation.getServiceInfo();         assert info != null;         if (enabled) {             info.flags |= AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE;         } else {             info.flags &= ~AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE;         }         uiAutomation.setServiceInfo(info);          final long timeoutTime = System.currentTimeMillis() + TIMEOUT_FOR_SERVICE_ENABLE;         synchronized (waitObject) {             while ((enabled != atomicBoolean.get()) && (System.currentTimeMillis() < timeoutTime)) {                 waitObject.wait(timeoutTime - System.currentTimeMillis());             }         }         if (enabled) {             assertTrue(""Touch exploration state listener not called when services enabled"",                     atomicBoolean.get());             assertTrue(""Timed out enabling accessibility"",                     manager.isEnabled() && manager.isTouchExplorationEnabled());         } else {             assertFalse(""Touch exploration state listener not called when services disabled"",                     atomicBoolean.get());             assertFalse(""Timed out disabling accessibility"",                     manager.isEnabled() && manager.isTouchExplorationEnabled());         }         manager.removeTouchExplorationStateChangeListener(serviceListener);     }      private static MotionEvent matchHover(int action, int x, int y) {         return argThat(new CtsMouseUtil.PositionMatcher(action, x, y));     }      private static void injectHoverEvent(long downTime, boolean isFirstHoverEvent,             int xOnScreen, int yOnScreen) {         final long eventTime = isFirstHoverEvent ? SystemClock.uptimeMillis() : downTime;         MotionEvent event = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_HOVER_MOVE,                 xOnScreen, yOnScreen, 0);         event.setSource(InputDevice.SOURCE_TOUCHSCREEN);         sUiAutomation.injectInputEvent(event, true);         event.recycle();     }      private AppWidgetProviderInfo getAppWidgetProviderInfo() {         final ComponentName componentName = new ComponentName(                 ""foo.bar.baz"", ""foo.bar.baz.MyAppWidgetProvider"");         final List<AppWidgetProviderInfo> providers = getAppWidgetManager().getInstalledProviders();         final int providerCount = providers.size();         for (int i = 0; i < providerCount; i++) {             final AppWidgetProviderInfo provider = providers.get(i);             if (componentName.equals(provider.provider)                     && Process.myUserHandle().equals(provider.getProfile())) {                 return provider;             }         }         return null;     }      private void grantBindAppWidgetPermission() throws Exception {         ShellCommandBuilder.execShellCommand(sUiAutomation,                 GRANT_BIND_APP_WIDGET_PERMISSION_COMMAND + getCurrentUser());     }      private void revokeBindAppWidgetPermission() throws Exception {         ShellCommandBuilder.execShellCommand(sUiAutomation,                 REVOKE_BIND_APP_WIDGET_PERMISSION_COMMAND + getCurrentUser());     }      private AppWidgetManager getAppWidgetManager() {         return (AppWidgetManager) sInstrumentation.getTargetContext()                 .getSystemService(Context.APPWIDGET_SERVICE);     }      private boolean hasAppWidgets() {         return sInstrumentation.getTargetContext().getPackageManager()                 .hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS);     }      /**      * Compares all properties of the <code>first</code> and the      * <code>second</code>.      */     private boolean equalsAccessiblityEvent(AccessibilityEvent first, AccessibilityEvent second) {          return first.getEventType() == second.getEventType()             && first.isChecked() == second.isChecked()             && first.getCurrentItemIndex() == second.getCurrentItemIndex()             && first.isEnabled() == second.isEnabled()             && first.getFromIndex() == second.getFromIndex()             && first.getItemCount() == second.getItemCount()             && first.isPassword() == second.isPassword()             && first.getRemovedCount() == second.getRemovedCount()             && first.isScrollable()== second.isScrollable()             && first.getToIndex() == second.getToIndex()             && first.getRecordCount() == second.getRecordCount()             && first.getScrollX() == second.getScrollX()             && first.getScrollY() == second.getScrollY()             && first.getAddedCount() == second.getAddedCount()             && TextUtils.equals(first.getBeforeText(), second.getBeforeText())             && TextUtils.equals(first.getClassName(), second.getClassName())             && TextUtils.equals(first.getContentDescription(), second.getContentDescription())             && equalsNotificationAsParcelableData(first, second)             && equalsText(first, second);     }      /**      * Compares the {@link android.os.Parcelable} data of the      * <code>first</code> and <code>second</code>.      */     private boolean equalsNotificationAsParcelableData(AccessibilityEvent first,             AccessibilityEvent second) {         Notification firstNotification = (Notification) first.getParcelableData();         Notification secondNotification = (Notification) second.getParcelableData();         if (firstNotification == null) {             return (secondNotification == null);         } else if (secondNotification == null) {             return false;         }         return TextUtils.equals(firstNotification.tickerText, secondNotification.tickerText);     }      /**      * Compares the text of the <code>first</code> and <code>second</code> text.      */     private boolean equalsText(AccessibilityEvent first, AccessibilityEvent second) {         List<CharSequence> firstText = first.getText();         List<CharSequence> secondText = second.getText();         if (firstText.size() != secondText.size()) {             return false;         }         Iterator<CharSequence> firstIterator = firstText.iterator();         Iterator<CharSequence> secondIterator = secondText.iterator();         for (int i = 0; i < firstText.size(); i++) {             if (!firstIterator.next().toString().equals(secondIterator.next().toString())) {                 return false;             }         }         return true;     }      private boolean hasTooltipShowing(int id) {         return getOnMain(sInstrumentation, () -> {             final View viewWithTooltip = mActivity.findViewById(id);             if (viewWithTooltip == null) {                 return false;             }             final View tooltipView = viewWithTooltip.getTooltipView();             return (tooltipView != null) && (tooltipView.getParent() != null);         });     }      private static int getCurrentUser() {         return android.os.Process.myUserHandle().getIdentifier();     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityButtonTest"	"testUpdateRequestAccessibilityButtonFlag_targetSdkGreaterThanQ_ignoresUpdate"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityButtonTest.java"	""	"@AppModeFull     public void testUpdateRequestAccessibilityButtonFlag_targetSdkGreaterThanQ_ignoresUpdate() {         final AccessibilityServiceInfo serviceInfo = mService.getServiceInfo();         assertTrue((serviceInfo.flags & FLAG_REQUEST_ACCESSIBILITY_BUTTON)                 == FLAG_REQUEST_ACCESSIBILITY_BUTTON);         assertTrue(mService.getApplicationInfo().targetSdkVersion > Build.VERSION_CODES.Q);          serviceInfo.flags &= ~FLAG_REQUEST_ACCESSIBILITY_BUTTON;         mService.setServiceInfo(serviceInfo);         assertTrue(""Update flagRequestAccessibilityButton should fail"",                 (mService.getServiceInfo().flags & FLAG_REQUEST_ACCESSIBILITY_BUTTON)                         == FLAG_REQUEST_ACCESSIBILITY_BUTTON);     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEmbeddedDisplayTest"	"testA11yWindowNotifyWhenResizeWindowInActivityViewAfterServiceOffAndOn"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEmbeddedDisplayTest.java"	""	"public void testA11yWindowNotifyWhenResizeWindowInActivityViewAfterServiceOffAndOn()             throws Exception {         // Clears window access flag to disable the A11y window tracking.         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags &= ~AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;         sUiAutomation.setServiceInfo(info);          // Only needs to make sure the windows cannot be accessed for UiAutomation service         // because other A11y services had been disabled when calling the method, getUiAutomation().         assertTrue(sUiAutomation.getWindows().isEmpty());          // Sets window access flag to enable the A11y window tracking.         sUiAutomation.executeAndWaitForEvent(                 () -> sInstrumentation.runOnMainSync(() -> {                     // Make sure we get window events, so we'll know when the window appears                     info.flags |= AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;                     sUiAutomation.setServiceInfo(info);                 }),                 filterWindowsChangeTypesAndWindowTitle(sUiAutomation, WINDOWS_CHANGE_ADDED,                         mActivityTitle),                 DEFAULT_TIMEOUT_MS);          testA11yWindowNotifyAfterResizeWindowInActivityView();     }      private void testA11yWindowNotifyAfterResizeWindowInActivityView() throws Exception {         final AccessibilityWindowInfo oldActivityWindow =                 findWindowByTitle(sUiAutomation, mActivityTitle);         final Rect activityBound = new Rect();         oldActivityWindow.getBoundsInScreen(activityBound);          final int width = activityBound.width() / 2;         final int height = activityBound.height() / 2;         sUiAutomation.executeAndWaitForEvent(() -> sInstrumentation.runOnMainSync(                 () -> mEmbeddedDisplayActivity.getWindow().setLayout(width, height)),                 filterWindowsChangeTypesAndWindowTitle(sUiAutomation, WINDOWS_CHANGE_BOUNDS,                         mActivityTitle),                 DEFAULT_TIMEOUT_MS);          final AccessibilityWindowInfo newActivityWindow =                 findWindowByTitle(sUiAutomation, mActivityTitle);         newActivityWindow.getBoundsInScreen(activityBound);          assertEquals(height, activityBound.height());         assertEquals(width, activityBound.width());     }      private void launchActivityInActivityView() throws Exception {         final Instrumentation.ActivityMonitor am = sInstrumentation.addMonitor(                 EmbeddedDisplayActivity.class.getName(), null, false);         final Rect bounds = new Rect();         sUiAutomation.executeAndWaitForEvent(                 () -> sInstrumentation.runOnMainSync(() -> {                     Intent intent = new Intent(mContext, EmbeddedDisplayActivity.class);                     intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);                     SystemUtil.runWithShellPermissionIdentity(                             () -> mActivityView.startActivity(intent));                 }),                 (event) -> {                     // Ensure the target activity is shown                     final AccessibilityWindowInfo window =                             findWindowByTitle(sUiAutomation, mActivityTitle);                     if (window == null) {                         return false;                     }                     window.getBoundsInScreen(bounds);                     return !bounds.isEmpty();                 }, DEFAULT_TIMEOUT_MS);         mEmbeddedDisplayActivity = (EmbeddedDisplayActivity)                 am.waitForActivityWithTimeout(DEFAULT_TIMEOUT_MS);         assertNotNull(mEmbeddedDisplayActivity);     }      public static class EmbeddedDisplayParentActivity extends Activity {         private ActivityView mActivityView;          @Override         public void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             mActivityView = new ActivityView(this, null, 0, false, true);             setContentView(mActivityView);         }          ActivityView getActivityView() {             return mActivityView;         }     }      public static class EmbeddedDisplayActivity extends AccessibilityTestActivity {          @Override         public void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             setContentView(R.layout.accessibility_embedded_display_test);         }     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEmbeddedDisplayTest"	"postTestTearDown"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEmbeddedDisplayTest.java"	""	"/*  *  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterWindowsChangeTypesAndWindowTitle; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.findWindowByTitle; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.supportsMultiDisplay; import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS; import static android.content.pm.PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ADDED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_BOUNDS;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assume.assumeTrue;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibilityservice.AccessibilityServiceInfo; import android.accessibilityservice.cts.activities.AccessibilityTestActivity; import android.app.Activity; import android.app.ActivityView; import android.app.Instrumentation; import android.app.UiAutomation; import android.content.Context; import android.content.Intent; import android.graphics.Rect; import android.os.Bundle; import android.platform.test.annotations.Presubmit; import android.view.accessibility.AccessibilityNodeInfo; import android.view.accessibility.AccessibilityWindowInfo;  import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.SystemUtil;  import org.junit.After; import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  /**  * Tests that AccessibilityWindowInfos and AccessibilityNodeInfos from a window on an embedded  * display that is re-parented to another window are properly populated.  */ @RunWith(AndroidJUnit4.class) public class AccessibilityEmbeddedDisplayTest {     private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private EmbeddedDisplayParentActivity mActivity;     private EmbeddedDisplayActivity mEmbeddedDisplayActivity;     private ActivityView mActivityView;     private Context mContext;      private String mParentActivityTitle;     private String mActivityTitle;      private final ActivityTestRule<EmbeddedDisplayParentActivity> mActivityRule =             new ActivityTestRule<>(EmbeddedDisplayParentActivity.class, false, false);      private final AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mDumpOnFailureRule);      @BeforeClass     public static void oneTimeSetup() {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation();     }      @AfterClass     public static void postTestTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         mContext = sInstrumentation.getContext();         assumeTrue(supportsMultiDisplay(mContext));          mParentActivityTitle = mContext.getString(                 R.string.accessibility_embedded_display_test_parent_activity);         mActivityTitle = mContext.getString(R.string.accessibility_embedded_display_test_activity);          SystemUtil.runWithShellPermissionIdentity(() -> {             mActivity = launchActivityAndWaitForItToBeOnscreen(                     sInstrumentation, sUiAutomation, mActivityRule);             mActivityView = mActivity.getActivityView();         });          launchActivityInActivityView();     }      @After     public void tearDown() throws Exception {         mEmbeddedDisplayActivity = null;         if (mActivityView != null) {             SystemUtil.runWithShellPermissionIdentity(() -> mActivityView.release());         }     }      @Presubmit"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.MagnificationGestureHandlerTest"	"EventCapturingTouchListener"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/MagnificationGestureHandlerTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.AsyncUtils.await; import static android.accessibilityservice.cts.utils.AsyncUtils.waitOn; import static android.accessibilityservice.cts.utils.GestureUtils.add; import static android.accessibilityservice.cts.utils.GestureUtils.click; import static android.accessibilityservice.cts.utils.GestureUtils.dispatchGesture; import static android.accessibilityservice.cts.utils.GestureUtils.distance; import static android.accessibilityservice.cts.utils.GestureUtils.doubleTap; import static android.accessibilityservice.cts.utils.GestureUtils.drag; import static android.accessibilityservice.cts.utils.GestureUtils.endTimeOf; import static android.accessibilityservice.cts.utils.GestureUtils.lastPointOf; import static android.accessibilityservice.cts.utils.GestureUtils.longClick; import static android.accessibilityservice.cts.utils.GestureUtils.path; import static android.accessibilityservice.cts.utils.GestureUtils.pointerDown; import static android.accessibilityservice.cts.utils.GestureUtils.pointerUp; import static android.accessibilityservice.cts.utils.GestureUtils.startingAt; import static android.accessibilityservice.cts.utils.GestureUtils.swipe; import static android.accessibilityservice.cts.utils.GestureUtils.tripleTap; import static android.view.MotionEvent.ACTION_DOWN; import static android.view.MotionEvent.ACTION_MOVE; import static android.view.MotionEvent.ACTION_UP;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityService; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.accessibilityservice.GestureDescription; import android.accessibilityservice.GestureDescription.StrokeDescription; import android.accessibilityservice.cts.AccessibilityGestureDispatchTest.GestureDispatchActivity; import android.accessibilityservice.cts.utils.EventCapturingTouchListener; import android.app.Instrumentation; import android.content.pm.PackageManager; import android.graphics.PointF; import android.platform.test.annotations.AppModeFull; import android.provider.Settings; import android.view.ViewConfiguration; import android.widget.TextView;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  /**  * Class for testing magnification.  */ @RunWith(AndroidJUnit4.class) @AppModeFull public class MagnificationGestureHandlerTest {      private static final double MIN_SCALE = 1.2;      private InstrumentedAccessibilityService mService;     private Instrumentation mInstrumentation;     private EventCapturingTouchListener mTouchListener = new EventCapturingTouchListener();     float mCurrentScale = 1f;     PointF mCurrentZoomCenter = null;     PointF mTapLocation;     PointF mTapLocation2;     float mPan;     private boolean mHasTouchscreen;     private boolean mOriginalIsMagnificationEnabled;      private final Object mZoomLock = new Object();      private ActivityTestRule<GestureDispatchActivity> mActivityRule =             new ActivityTestRule<>(GestureDispatchActivity.class);      private InstrumentedAccessibilityServiceTestRule<StubMagnificationAccessibilityService>             mServiceRule = new InstrumentedAccessibilityServiceTestRule<>(                     StubMagnificationAccessibilityService.class, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mServiceRule)             .around(mDumpOnFailureRule);      @Before     public void setUp() throws Exception {         mInstrumentation = InstrumentationRegistry.getInstrumentation();         PackageManager pm = mInstrumentation.getContext().getPackageManager();         mHasTouchscreen = pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)                 || pm.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH);         if (!mHasTouchscreen) return;          mOriginalIsMagnificationEnabled =                 Settings.Secure.getInt(mInstrumentation.getContext().getContentResolver(),                         Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED, 0) == 1;         setMagnificationEnabled(true);          mService = mServiceRule.enableService();         mService.getMagnificationController().addListener(                 (controller, region, scale, centerX, centerY) -> {                     mCurrentScale = scale;                     mCurrentZoomCenter = isZoomed() ? new PointF(centerX, centerY) : null;                      synchronized (mZoomLock) {                         mZoomLock.notifyAll();                     }                 });          TextView view = mActivityRule.getActivity().findViewById(R.id.full_screen_text_view);         mInstrumentation.runOnMainSync(() -> {             view.setOnTouchListener(mTouchListener);             int[] xy = new int[2];             view.getLocationOnScreen(xy);             mTapLocation = new PointF(xy[0] + view.getWidth() / 2, xy[1] + view.getHeight() / 2);             mTapLocation2 = add(mTapLocation, 31, 29);             mPan = view.getWidth() / 4;         });     }      @After     public void tearDown() throws Exception {         if (!mHasTouchscreen) return;          setMagnificationEnabled(mOriginalIsMagnificationEnabled);     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.view.accessibility.cts.AccessibilityServiceInfoTest"	"testAccessibilityServiceInfoForEnabledService"	"CtsAccessibilityTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityServiceInfoTest.java"	""	"public void testAccessibilityServiceInfoForEnabledService() {         final List<AccessibilityServiceInfo> enabledServices =                 mAccessibilityManager.getEnabledAccessibilityServiceList(                         AccessibilityServiceInfo.FEEDBACK_SPOKEN);         assertSame(/* message= */ ""There should be one speaking service."",                 /* expected= */ 1, enabledServices.size());         final AccessibilityServiceInfo speakingService = enabledServices.get(0);         assertSame(AccessibilityEvent.TYPES_ALL_MASK, speakingService.eventTypes);         assertSame(AccessibilityServiceInfo.FEEDBACK_SPOKEN, speakingService.feedbackType);          int serviceFlags = AccessibilityServiceInfo.DEFAULT                 | AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS                 | AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE                 | AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS                 | AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS                 | AccessibilityServiceInfo.FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK;          assertEquals(speakingService.flags & FLAGS_MASK, serviceFlags);          assertSame(/* expected= */ 0l, speakingService.notificationTimeout);         assertEquals(/* expected= */ ""Some description"", speakingService.getDescription());         assertNull(speakingService.packageNames /*all packages*/);         assertNotNull(speakingService.getId());         assertSame(speakingService.getCapabilities(),                 AccessibilityServiceInfo.CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS                 | AccessibilityServiceInfo.CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION                 | AccessibilityServiceInfo.CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT);         assertEquals(""foo.bar.Activity"", speakingService.getSettingsActivityName());         assertEquals(/* expected= */ ""Some description"",                 speakingService.loadDescription(mPackageManager));         assertEquals(/* expected= */ ""Some summary"",                 speakingService.loadSummary(mPackageManager));         assertNotNull(speakingService.getResolveInfo());         assertEquals(/* expected= */ 6000,                 speakingService.getInteractiveUiTimeoutMillis());         assertEquals(/* expected= */ 1000,                 speakingService.getNonInteractiveUiTimeoutMillis());     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityOverlayTest"	"testA11yServiceShowsOverlayOnVirtualDisplay_shouldAppear"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityOverlayTest.java"	""	"public void testA11yServiceShowsOverlayOnVirtualDisplay_shouldAppear() throws Exception {         try (DisplayUtils.VirtualDisplaySession displaySession =                      new DisplayUtils.VirtualDisplaySession()) {             Display newDisplay = displaySession.createDisplayWithDefaultDisplayMetricsAndWait(                     mService, false);             final int displayId = newDisplay.getDisplayId();             final Context newDisplayContext = mService.createDisplayContext(newDisplay);             final String overlayTitle = ""Overlay title on virtualDisplay"";              sUiAutomation.executeAndWaitForEvent(() -> mService.runOnServiceSync(() -> {                 addOverlayWindow(newDisplayContext, overlayTitle);             }), (event) -> findOverlayWindow(displayId) != null, AsyncUtils.DEFAULT_TIMEOUT_MS);              assertTrue(TextUtils.equals(findOverlayWindow(displayId).getTitle(), overlayTitle));         }     }      private void addOverlayWindow(Context context, String overlayTitle) {         final Button button = new Button(context);         button.setText(""Button"");         final WindowManager.LayoutParams params = new WindowManager.LayoutParams();         params.width = WindowManager.LayoutParams.MATCH_PARENT;         params.height = WindowManager.LayoutParams.MATCH_PARENT;         params.flags = WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN                 | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;         params.type = WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY;         params.setTitle(overlayTitle);         context.getSystemService(WindowManager.class).addView(button, params);     }      private AccessibilityWindowInfo findOverlayWindow(int displayId) {         final SparseArray<List<AccessibilityWindowInfo>> allWindows =                 sUiAutomation.getWindowsOnAllDisplays();         final int index = allWindows.indexOfKey(displayId);         final List<AccessibilityWindowInfo> windows = allWindows.valueAt(index);         if (windows != null) {             for (AccessibilityWindowInfo window : windows) {                 if (window.getType() == AccessibilityWindowInfo.TYPE_ACCESSIBILITY_OVERLAY) {                     return window;                 }             }         }         return null;     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.view.accessibility.cts.AccessibilityShortcutTest"	"postTestTearDown"	"CtsAccessibilityTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityShortcutTest.java"	""	"/*  *.  */  package android.view.accessibility.cts;  import static android.accessibility.cts.common.AccessibilityShortcutSettingsRule.ACCESSIBILITY_BUTTON; import static android.accessibility.cts.common.InstrumentedAccessibilityService.TIMEOUT_SERVICE_ENABLE; import static android.app.UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES;  import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;  import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.AccessibilityShortcutSettingsRule; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.accessibilityservice.AccessibilityButtonController; import android.accessibilityservice.AccessibilityButtonController.AccessibilityButtonCallback; import android.accessibilityservice.AccessibilityService; import android.app.Activity; import android.app.Instrumentation; import android.app.Instrumentation.ActivityMonitor; import android.app.Service; import android.app.UiAutomation; import android.content.ComponentName; import android.content.Context; import android.platform.test.annotations.AppModeFull; import android.view.accessibility.AccessibilityManager;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.TestUtils;  import org.junit.After; import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.Arrays; import java.util.Collections; import java.util.concurrent.atomic.AtomicBoolean;  /**  * Tests accessibility shortcut related functionality  */ @AppModeFull @RunWith(AndroidJUnit4.class) public class AccessibilityShortcutTest {     private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private final InstrumentedAccessibilityServiceTestRule<SpeakingAccessibilityService>             mServiceRule = new InstrumentedAccessibilityServiceTestRule<>(                     SpeakingAccessibilityService.class, false);      private final InstrumentedAccessibilityServiceTestRule<AccessibilityButtonService>             mA11yButtonServiceRule = new InstrumentedAccessibilityServiceTestRule<>(             AccessibilityButtonService.class, false);      private final AccessibilityShortcutSettingsRule mShortcutSettingsRule =             new AccessibilityShortcutSettingsRule();      private final AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mServiceRule)             .around(mA11yButtonServiceRule)             .around(mShortcutSettingsRule)             .around(mDumpOnFailureRule);      private AccessibilityManager mAccessibilityManager;     private ActivityMonitor mActivityMonitor;     private Activity mShortcutTargetActivity;      private String mSpeakingA11yServiceName;     private String mShortcutTargetActivityName;     private String mA11yButtonServiceName;      @BeforeClass     public static void oneTimeSetup() {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation(FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);     }      @AfterClass     public static void postTestTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() {         final Context context = sInstrumentation.getTargetContext();         mAccessibilityManager = (AccessibilityManager) context.getSystemService(                 Service.ACCESSIBILITY_SERVICE);         mSpeakingA11yServiceName = new ComponentName(context,                 SpeakingAccessibilityService.class).flattenToString();         mShortcutTargetActivityName = new ComponentName(context,                 AccessibilityShortcutTargetActivity.class).flattenToString();         mA11yButtonServiceName = new ComponentName(context,                 AccessibilityButtonService.class).flattenToString();         mActivityMonitor = new ActivityMonitor(                 AccessibilityShortcutTargetActivity.class.getName(), null, false);         sInstrumentation.addMonitor(mActivityMonitor);     }      @After     public void tearDown() {         if (mActivityMonitor != null) {             sInstrumentation.removeMonitor(mActivityMonitor);         }         if (mShortcutTargetActivity != null) {             sInstrumentation.runOnMainSync(() -> mShortcutTargetActivity.finish());         }     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowReportingTest"	"perDisplayFocusEnabled"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowReportingTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterWindowsChangeTypesAndWindowTitle; import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterWindowsChangedWithChangeTypes; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.findWindowByTitle; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.findWindowByTitleAndDisplay; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.getActivityTitle; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.supportsMultiDisplay; import static android.accessibilityservice.cts.utils.DisplayUtils.VirtualDisplaySession; import static android.accessibilityservice.cts.utils.DisplayUtils.getStatusBarHeight; import static android.content.pm.PackageManager.FEATURE_PICTURE_IN_PICTURE; import static android.view.accessibility.AccessibilityEvent.TYPE_WINDOWS_CHANGED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ACCESSIBILITY_FOCUSED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ACTIVE; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ADDED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_BOUNDS; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_CHILDREN; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_FOCUSED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_REMOVED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_TITLE;  import static junit.framework.TestCase.assertTrue;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assume.assumeTrue;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibilityservice.AccessibilityServiceInfo; import android.accessibilityservice.cts.activities.AccessibilityWindowReportingActivity; import android.accessibilityservice.cts.utils.DisplayUtils; import android.app.Activity; import android.app.Instrumentation; import android.app.UiAutomation; import android.graphics.Rect; import android.os.SystemClock; import android.view.Display; import android.view.Gravity; import android.view.InputDevice; import android.view.MotionEvent; import android.view.View; import android.view.WindowManager; import android.view.accessibility.AccessibilityNodeInfo; import android.view.accessibility.AccessibilityWindowInfo; import android.widget.ArrayAdapter; import android.widget.AutoCompleteTextView; import android.widget.Button;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.List; import java.util.concurrent.TimeoutException;  /**  * Tests that window changes produce the correct events and that AccessibilityWindowInfos are  * properly populated  */ @RunWith(AndroidJUnit4.class) public class AccessibilityWindowReportingTest {     private static final int TIMEOUT_ASYNC_PROCESSING = 5000;     private static final CharSequence TOP_WINDOW_TITLE =             ""android.accessibilityservice.cts.AccessibilityWindowReportingTest.TOP_WINDOW_TITLE"";      private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;     private Activity mActivity;     private CharSequence mActivityTitle;      private ActivityTestRule<AccessibilityWindowReportingActivity> mActivityRule =             new ActivityTestRule<>(AccessibilityWindowReportingActivity.class, false, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mDumpOnFailureRule);      @BeforeClass     public static void oneTimeSetup() throws Exception {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation();         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags |= AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;         sUiAutomation.setServiceInfo(info);     }      @AfterClass     public static void finalTearDown() throws Exception {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         mActivity = launchActivityAndWaitForItToBeOnscreen(                 sInstrumentation, sUiAutomation, mActivityRule);         mActivityTitle = getActivityTitle(sInstrumentation, mActivity);     }      private static boolean perDisplayFocusEnabled() {         return sInstrumentation.getTargetContext().getResources()                 .getBoolean(android.R.bool.config_perDisplayFocusEnabled);     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowReportingTest"	"testChangeAccessibilityFocusWindow_getEvent"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowReportingTest.java"	""	"public void testChangeAccessibilityFocusWindow_getEvent() throws Exception {         final AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags |= AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE;         sUiAutomation.setServiceInfo(info);          try {             showTopWindowAndWaitForItToShowUp();              final AccessibilityWindowInfo activityWindow =                     findWindowByTitle(sUiAutomation, mActivityTitle);             final AccessibilityWindowInfo topWindow =                     findWindowByTitle(sUiAutomation, TOP_WINDOW_TITLE);             final AccessibilityNodeInfo win2Node =                     topWindow.getRoot().findAccessibilityNodeInfosByText(                             sInstrumentation.getContext().getString(R.string.button1)).get(0);             final AccessibilityNodeInfo win1Node = activityWindow.getRoot()                     .findAccessibilityNodeInfosByViewId(                             ""android.accessibilityservice.cts:id/autoCompleteLayout"")                     .get(0);              sUiAutomation.executeAndWaitForEvent(                     () -> {                         win2Node.performAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);                         win1Node.performAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);                     },                     filterWindowsChangedWithChangeTypes(WINDOWS_CHANGE_ACCESSIBILITY_FOCUSED),                     TIMEOUT_ASYNC_PROCESSING);         } finally {             info.flags &= ~AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE;             sUiAutomation.setServiceInfo(info);         }     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowReportingTest"	"testGetAnchorForDropDownForAutoCompleteTextView_returnsTextViewNode"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowReportingTest.java"	""	"public void testGetAnchorForDropDownForAutoCompleteTextView_returnsTextViewNode() {         final AutoCompleteTextView autoCompleteTextView =                 (AutoCompleteTextView) mActivity.findViewById(R.id.autoCompleteLayout);         final AccessibilityNodeInfo autoCompleteTextInfo = sUiAutomation.getRootInActiveWindow()                 .findAccessibilityNodeInfosByViewId(                         ""android.accessibilityservice.cts:id/autoCompleteLayout"")                 .get(0);          // For the drop-down         final String[] COUNTRIES = new String[] {""Belgium"", ""France"", ""Italy"", ""Germany"", ""Spain""};          try {             sUiAutomation.executeAndWaitForEvent(() -> sInstrumentation.runOnMainSync(                     () -> {                         final ArrayAdapter<String> adapter = new ArrayAdapter<>(                                 mActivity, android.R.layout.simple_dropdown_item_1line, COUNTRIES);                         autoCompleteTextView.setAdapter(adapter);                         autoCompleteTextView.showDropDown();                     }),                     filterWindowsChangeTypesAndWindowTitle(sUiAutomation, WINDOWS_CHANGE_CHILDREN,                             mActivityTitle.toString()), TIMEOUT_ASYNC_PROCESSING);         } catch (TimeoutException exception) {             throw new RuntimeException(                     ""Failed to get window changed event when showing dropdown"", exception);         }          // Find the pop-up window         boolean foundPopup = false;         final List<AccessibilityWindowInfo> windows = sUiAutomation.getWindows();         for (int i = 0; i < windows.size(); i++) {             final AccessibilityWindowInfo window = windows.get(i);             if (window.getAnchor() == null) {                 continue;             }             assertEquals(autoCompleteTextInfo, window.getAnchor());             assertFalse(""Found multiple pop-ups anchored to one text view"", foundPopup);             foundPopup = true;         }         assertTrue(""Failed to find accessibility window for auto-complete pop-up"", foundPopup);     }      private View showTopWindowAndWaitForItToShowUp() throws TimeoutException {         final WindowManager.LayoutParams paramsForTop = layoutParmsForWindowOnTop();         final Button button = new Button(mActivity);         button.setText(R.string.button1);         sUiAutomation.executeAndWaitForEvent(() -> sInstrumentation.runOnMainSync(                 () -> mActivity.getWindowManager().addView(button, paramsForTop)),                 (event) -> {                     return (event.getEventType() == TYPE_WINDOWS_CHANGED)                             && (findWindowByTitle(sUiAutomation, mActivityTitle) != null)                             && (findWindowByTitle(sUiAutomation, TOP_WINDOW_TITLE) != null);                 },                 TIMEOUT_ASYNC_PROCESSING);         return button;     }      private WindowManager.LayoutParams layoutParmsForWindowOnTop() {         final WindowManager.LayoutParams params = layoutParmsForTestWindow();         params.gravity = Gravity.TOP;         params.setTitle(TOP_WINDOW_TITLE);         sInstrumentation.runOnMainSync(() -> {             params.y = getStatusBarHeight(mActivity);         });         return params;     }      private WindowManager.LayoutParams layoutParmsForWindowOnBottom() {         final WindowManager.LayoutParams params = layoutParmsForTestWindow();         params.gravity = Gravity.BOTTOM;         return params;     }      private WindowManager.LayoutParams layoutParmsForTestWindow() {         final WindowManager.LayoutParams params = new WindowManager.LayoutParams();         params.width = WindowManager.LayoutParams.MATCH_PARENT;         params.height = WindowManager.LayoutParams.WRAP_CONTENT;         params.flags = WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN                 | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL                 | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;         params.type = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;         sInstrumentation.runOnMainSync(() -> {             params.token = mActivity.getWindow().getDecorView().getWindowToken();         });         return params;     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowReportingTest"	"perDisplayFocusEnabled"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowReportingTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterWindowsChangeTypesAndWindowTitle; import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterWindowsChangedWithChangeTypes; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.findWindowByTitle; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.findWindowByTitleAndDisplay; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.getActivityTitle; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.supportsMultiDisplay; import static android.accessibilityservice.cts.utils.DisplayUtils.VirtualDisplaySession; import static android.accessibilityservice.cts.utils.DisplayUtils.getStatusBarHeight; import static android.content.pm.PackageManager.FEATURE_PICTURE_IN_PICTURE; import static android.view.accessibility.AccessibilityEvent.TYPE_WINDOWS_CHANGED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ACCESSIBILITY_FOCUSED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ACTIVE; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ADDED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_BOUNDS; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_CHILDREN; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_FOCUSED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_REMOVED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_TITLE;  import static junit.framework.TestCase.assertTrue;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assume.assumeTrue;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibilityservice.AccessibilityServiceInfo; import android.accessibilityservice.cts.activities.AccessibilityWindowReportingActivity; import android.accessibilityservice.cts.utils.DisplayUtils; import android.app.Activity; import android.app.Instrumentation; import android.app.UiAutomation; import android.graphics.Rect; import android.os.SystemClock; import android.view.Display; import android.view.Gravity; import android.view.InputDevice; import android.view.MotionEvent; import android.view.View; import android.view.WindowManager; import android.view.accessibility.AccessibilityNodeInfo; import android.view.accessibility.AccessibilityWindowInfo; import android.widget.ArrayAdapter; import android.widget.AutoCompleteTextView; import android.widget.Button;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.List; import java.util.concurrent.TimeoutException;  /**  * Tests that window changes produce the correct events and that AccessibilityWindowInfos are  * properly populated  */ @RunWith(AndroidJUnit4.class) public class AccessibilityWindowReportingTest {     private static final int TIMEOUT_ASYNC_PROCESSING = 5000;     private static final CharSequence TOP_WINDOW_TITLE =             ""android.accessibilityservice.cts.AccessibilityWindowReportingTest.TOP_WINDOW_TITLE"";      private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;     private Activity mActivity;     private CharSequence mActivityTitle;      private ActivityTestRule<AccessibilityWindowReportingActivity> mActivityRule =             new ActivityTestRule<>(AccessibilityWindowReportingActivity.class, false, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mDumpOnFailureRule);      @BeforeClass     public static void oneTimeSetup() throws Exception {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation();         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags |= AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;         sUiAutomation.setServiceInfo(info);     }      @AfterClass     public static void finalTearDown() throws Exception {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         mActivity = launchActivityAndWaitForItToBeOnscreen(                 sInstrumentation, sUiAutomation, mActivityRule);         mActivityTitle = getActivityTitle(sInstrumentation, mActivity);     }      private static boolean perDisplayFocusEnabled() {         return sInstrumentation.getTargetContext().getResources()                 .getBoolean(android.R.bool.config_perDisplayFocusEnabled);     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowReportingTest"	"isInPictureInPictureMode"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowReportingTest.java"	""	"public void putWindowInPictureInPicture_generatesEventAndReportsProperty() throws Exception {         if (!sInstrumentation.getContext().getPackageManager()                 .hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {             return;         }         sUiAutomation.executeAndWaitForEvent(                 () -> sInstrumentation.runOnMainSync(() -> mActivity.enterPictureInPictureMode()),                 (event) -> {                     if (event.getEventType() != TYPE_WINDOWS_CHANGED) return false;                     // Look for a picture-in-picture window                     final List<AccessibilityWindowInfo> windows = sUiAutomation.getWindows();                     final int windowCount = windows.size();                     for (int i = 0; i < windowCount; i++) {                         if (windows.get(i).isInPictureInPictureMode()) {                             return true;                         }                     }                     return false;                 }, TIMEOUT_ASYNC_PROCESSING);          // There should be exactly one picture-in-picture window now         int numPictureInPictureWindows = 0;         final List<AccessibilityWindowInfo> windows = sUiAutomation.getWindows();         final int windowCount = windows.size();         for (int i = 0; i < windowCount; i++) {             final AccessibilityWindowInfo window = windows.get(i);             if (window.isInPictureInPictureMode()) {                 numPictureInPictureWindows++;             }         }         assertTrue(numPictureInPictureWindows >= 1);     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.TouchExplorerTest"	"EventCapturingClickListener"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/TouchExplorerTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.AsyncUtils.await; import static android.accessibilityservice.cts.utils.GestureUtils.add; import static android.accessibilityservice.cts.utils.GestureUtils.click; import static android.accessibilityservice.cts.utils.GestureUtils.dispatchGesture; import static android.accessibilityservice.cts.utils.GestureUtils.doubleTap; import static android.accessibilityservice.cts.utils.GestureUtils.doubleTapAndHold; import static android.accessibilityservice.cts.utils.GestureUtils.multiTap; import static android.accessibilityservice.cts.utils.GestureUtils.secondFingerMultiTap; import static android.accessibilityservice.cts.utils.GestureUtils.swipe; import static android.view.MotionEvent.ACTION_DOWN; import static android.view.MotionEvent.ACTION_HOVER_ENTER; import static android.view.MotionEvent.ACTION_HOVER_EXIT; import static android.view.MotionEvent.ACTION_HOVER_MOVE; import static android.view.MotionEvent.ACTION_MOVE; import static android.view.MotionEvent.ACTION_POINTER_DOWN; import static android.view.MotionEvent.ACTION_POINTER_UP; import static android.view.MotionEvent.ACTION_UP; import static android.view.accessibility.AccessibilityEvent.TYPE_GESTURE_DETECTION_END; import static android.view.accessibility.AccessibilityEvent.TYPE_GESTURE_DETECTION_START; import static android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_END; import static android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_START; import static android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_INTERACTION_END; import static android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_INTERACTION_START; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_CLICKED; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_LONG_CLICKED;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityService; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.accessibility.cts.common.ShellCommandBuilder; import android.accessibilityservice.GestureDescription; import android.accessibilityservice.GestureDescription.StrokeDescription; import android.accessibilityservice.cts.AccessibilityGestureDispatchTest.GestureDispatchActivity; import android.accessibilityservice.cts.utils.EventCapturingClickListener; import android.accessibilityservice.cts.utils.EventCapturingHoverListener; import android.accessibilityservice.cts.utils.EventCapturingLongClickListener; import android.accessibilityservice.cts.utils.EventCapturingTouchListener; import android.app.Instrumentation; import android.app.UiAutomation; import android.content.Context; import android.content.pm.PackageManager; import android.graphics.PointF; import android.graphics.Region; import android.platform.test.annotations.AppModeFull; import android.provider.Settings; import android.util.DisplayMetrics; import android.util.TypedValue; import android.view.Display; import android.view.View; import android.view.ViewConfiguration; import android.view.WindowManager; import android.view.accessibility.AccessibilityNodeInfo;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  /**  * A set of tests for testing touch exploration. Each test dispatches a gesture and checks for the  * appropriate hover and/or touch events followed by the appropriate accessibility events. Some  * tests will then check for events from the view.  */ @RunWith(AndroidJUnit4.class) @AppModeFull public class TouchExplorerTest {     // Constants     private static final float GESTURE_LENGTH_MMS = 10.0f;     private TouchExplorationStubAccessibilityService mService;     private Instrumentation mInstrumentation;     private UiAutomation mUiAutomation;     private boolean mHasTouchscreen;     private boolean mScreenBigEnough;     private long mSwipeTimeMillis;     private String mEnabledServices;     private EventCapturingHoverListener mHoverListener = new EventCapturingHoverListener(false);     private EventCapturingTouchListener mTouchListener = new EventCapturingTouchListener(false);     private EventCapturingClickListener mClickListener = new EventCapturingClickListener();     private EventCapturingLongClickListener mLongClickListener =             new EventCapturingLongClickListener();      private ActivityTestRule<GestureDispatchActivity> mActivityRule =             new ActivityTestRule<>(GestureDispatchActivity.class, false);      private InstrumentedAccessibilityServiceTestRule<TouchExplorationStubAccessibilityService>             mServiceRule =                     new InstrumentedAccessibilityServiceTestRule<>(                             TouchExplorationStubAccessibilityService.class, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain =             RuleChain.outerRule(mActivityRule).around(mServiceRule).around(mDumpOnFailureRule);      PointF mTapLocation; // Center of activity. Gestures all start from around this point.     float mSwipeDistance;     View mView;      @Before     public void setUp() throws Exception {         mInstrumentation = InstrumentationRegistry.getInstrumentation();         // Save enabled accessibility services before disabling them so they can be re-enabled after         // the test.         mEnabledServices = Settings.Secure.getString(                 mInstrumentation.getContext().getContentResolver(),                 Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);         // Disable all services before enabling Accessibility service to prevent flakiness         // that depends on which services are enabled.         InstrumentedAccessibilityService.disableAllServices();         mUiAutomation =                 mInstrumentation.getUiAutomation(                         UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);         PackageManager pm = mInstrumentation.getContext().getPackageManager();         mHasTouchscreen =                 pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)                         || pm.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH);         // Find window size, check that it is big enough for gestures.         // Gestures will start in the center of the window, so we need enough horiz/vert space.         mService = mServiceRule.enableService();         mView = mActivityRule.getActivity().findViewById(R.id.full_screen_text_view);         WindowManager windowManager =                 (WindowManager)                         mInstrumentation.getContext().getSystemService(Context.WINDOW_SERVICE);         final DisplayMetrics metrics = new DisplayMetrics();         windowManager.getDefaultDisplay().getRealMetrics(metrics);         mScreenBigEnough = mView.getWidth() / 2 >  TypedValue.applyDimension(                 TypedValue.COMPLEX_UNIT_MM, GESTURE_LENGTH_MMS, metrics);         if (!mHasTouchscreen || !mScreenBigEnough) return;          mView.setOnHoverListener(mHoverListener);         mView.setOnTouchListener(mTouchListener);         mInstrumentation.runOnMainSync(                 () -> {                     int[] viewLocation = new int[2];                     mView = mActivityRule.getActivity().findViewById(R.id.full_screen_text_view);                     final int midX = mView.getWidth() / 2;                     final int midY = mView.getHeight() / 2;                     mView.getLocationOnScreen(viewLocation);                     mTapLocation = new PointF(viewLocation[0] + midX, viewLocation[1] + midY);                     mSwipeDistance = mView.getWidth() / 4;                      // This must be slower than 10mm per 150ms to be detected as touch exploration.                     final double swipeDistanceMm = mSwipeDistance / metrics.xdpi * 25.4;                     mSwipeTimeMillis = (long) swipeDistanceMm * 20;                      mView.setOnClickListener(mClickListener);                     mView.setOnLongClickListener(mLongClickListener);                 });     }      @After     public void postTestTearDown() {         ShellCommandBuilder.create(mUiAutomation)                 .putSecureSetting(Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, mEnabledServices)                 .run();     }      /** Test a slow swipe which should initiate touch exploration. */"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.TouchExplorerTest"	"EventCapturingClickListener"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/TouchExplorerTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.AsyncUtils.await; import static android.accessibilityservice.cts.utils.GestureUtils.add; import static android.accessibilityservice.cts.utils.GestureUtils.click; import static android.accessibilityservice.cts.utils.GestureUtils.dispatchGesture; import static android.accessibilityservice.cts.utils.GestureUtils.doubleTap; import static android.accessibilityservice.cts.utils.GestureUtils.doubleTapAndHold; import static android.accessibilityservice.cts.utils.GestureUtils.multiTap; import static android.accessibilityservice.cts.utils.GestureUtils.secondFingerMultiTap; import static android.accessibilityservice.cts.utils.GestureUtils.swipe; import static android.view.MotionEvent.ACTION_DOWN; import static android.view.MotionEvent.ACTION_HOVER_ENTER; import static android.view.MotionEvent.ACTION_HOVER_EXIT; import static android.view.MotionEvent.ACTION_HOVER_MOVE; import static android.view.MotionEvent.ACTION_MOVE; import static android.view.MotionEvent.ACTION_POINTER_DOWN; import static android.view.MotionEvent.ACTION_POINTER_UP; import static android.view.MotionEvent.ACTION_UP; import static android.view.accessibility.AccessibilityEvent.TYPE_GESTURE_DETECTION_END; import static android.view.accessibility.AccessibilityEvent.TYPE_GESTURE_DETECTION_START; import static android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_END; import static android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_START; import static android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_INTERACTION_END; import static android.view.accessibility.AccessibilityEvent.TYPE_TOUCH_INTERACTION_START; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_CLICKED; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_LONG_CLICKED;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityService; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.accessibility.cts.common.ShellCommandBuilder; import android.accessibilityservice.GestureDescription; import android.accessibilityservice.GestureDescription.StrokeDescription; import android.accessibilityservice.cts.AccessibilityGestureDispatchTest.GestureDispatchActivity; import android.accessibilityservice.cts.utils.EventCapturingClickListener; import android.accessibilityservice.cts.utils.EventCapturingHoverListener; import android.accessibilityservice.cts.utils.EventCapturingLongClickListener; import android.accessibilityservice.cts.utils.EventCapturingTouchListener; import android.app.Instrumentation; import android.app.UiAutomation; import android.content.Context; import android.content.pm.PackageManager; import android.graphics.PointF; import android.graphics.Region; import android.platform.test.annotations.AppModeFull; import android.provider.Settings; import android.util.DisplayMetrics; import android.util.TypedValue; import android.view.Display; import android.view.View; import android.view.ViewConfiguration; import android.view.WindowManager; import android.view.accessibility.AccessibilityNodeInfo;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  /**  * A set of tests for testing touch exploration. Each test dispatches a gesture and checks for the  * appropriate hover and/or touch events followed by the appropriate accessibility events. Some  * tests will then check for events from the view.  */ @RunWith(AndroidJUnit4.class) @AppModeFull public class TouchExplorerTest {     // Constants     private static final float GESTURE_LENGTH_MMS = 10.0f;     private TouchExplorationStubAccessibilityService mService;     private Instrumentation mInstrumentation;     private UiAutomation mUiAutomation;     private boolean mHasTouchscreen;     private boolean mScreenBigEnough;     private long mSwipeTimeMillis;     private String mEnabledServices;     private EventCapturingHoverListener mHoverListener = new EventCapturingHoverListener(false);     private EventCapturingTouchListener mTouchListener = new EventCapturingTouchListener(false);     private EventCapturingClickListener mClickListener = new EventCapturingClickListener();     private EventCapturingLongClickListener mLongClickListener =             new EventCapturingLongClickListener();      private ActivityTestRule<GestureDispatchActivity> mActivityRule =             new ActivityTestRule<>(GestureDispatchActivity.class, false);      private InstrumentedAccessibilityServiceTestRule<TouchExplorationStubAccessibilityService>             mServiceRule =                     new InstrumentedAccessibilityServiceTestRule<>(                             TouchExplorationStubAccessibilityService.class, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain =             RuleChain.outerRule(mActivityRule).around(mServiceRule).around(mDumpOnFailureRule);      PointF mTapLocation; // Center of activity. Gestures all start from around this point.     float mSwipeDistance;     View mView;      @Before     public void setUp() throws Exception {         mInstrumentation = InstrumentationRegistry.getInstrumentation();         // Save enabled accessibility services before disabling them so they can be re-enabled after         // the test.         mEnabledServices = Settings.Secure.getString(                 mInstrumentation.getContext().getContentResolver(),                 Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);         // Disable all services before enabling Accessibility service to prevent flakiness         // that depends on which services are enabled.         InstrumentedAccessibilityService.disableAllServices();         mUiAutomation =                 mInstrumentation.getUiAutomation(                         UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);         PackageManager pm = mInstrumentation.getContext().getPackageManager();         mHasTouchscreen =                 pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)                         || pm.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH);         // Find window size, check that it is big enough for gestures.         // Gestures will start in the center of the window, so we need enough horiz/vert space.         mService = mServiceRule.enableService();         mView = mActivityRule.getActivity().findViewById(R.id.full_screen_text_view);         WindowManager windowManager =                 (WindowManager)                         mInstrumentation.getContext().getSystemService(Context.WINDOW_SERVICE);         final DisplayMetrics metrics = new DisplayMetrics();         windowManager.getDefaultDisplay().getRealMetrics(metrics);         mScreenBigEnough = mView.getWidth() / 2 >  TypedValue.applyDimension(                 TypedValue.COMPLEX_UNIT_MM, GESTURE_LENGTH_MMS, metrics);         if (!mHasTouchscreen || !mScreenBigEnough) return;          mView.setOnHoverListener(mHoverListener);         mView.setOnTouchListener(mTouchListener);         mInstrumentation.runOnMainSync(                 () -> {                     int[] viewLocation = new int[2];                     mView = mActivityRule.getActivity().findViewById(R.id.full_screen_text_view);                     final int midX = mView.getWidth() / 2;                     final int midY = mView.getHeight() / 2;                     mView.getLocationOnScreen(viewLocation);                     mTapLocation = new PointF(viewLocation[0] + midX, viewLocation[1] + midY);                     mSwipeDistance = mView.getWidth() / 4;                      // This must be slower than 10mm per 150ms to be detected as touch exploration.                     final double swipeDistanceMm = mSwipeDistance / metrics.xdpi * 25.4;                     mSwipeTimeMillis = (long) swipeDistanceMm * 20;                      mView.setOnClickListener(mClickListener);                     mView.setOnLongClickListener(mLongClickListener);                 });     }      @After     public void postTestTearDown() {         ShellCommandBuilder.create(mUiAutomation)                 .putSecureSetting(Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, mEnabledServices)                 .run();     }      /** Test a slow swipe which should initiate touch exploration. */"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityTakeScreenshotTest"	"testTakeScreenshotWithSecureWindow_GetScreenshotAndVerifyBitmap"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityTakeScreenshotTest.java"	""	"public void testTakeScreenshotWithSecureWindow_GetScreenshotAndVerifyBitmap() throws Throwable {         final Activity activity = launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(                 sInstrumentation, sUiAutomation, AccessibilityWindowQueryActivity.class,                 Display.DEFAULT_DISPLAY);          final ImageView image = new ImageView(activity);         image.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE                 | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION                 | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN                 | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION                 | View.SYSTEM_UI_FLAG_FULLSCREEN);         image.setImageDrawable(new ColorDrawable(SECURE_WINDOW_CONTENT_COLOR));          final WindowManager.LayoutParams params = new WindowManager.LayoutParams();         params.width = WindowManager.LayoutParams.MATCH_PARENT;         params.height = WindowManager.LayoutParams.MATCH_PARENT;         params.layoutInDisplayCutoutMode = LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES;         params.flags = WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN                 | WindowManager.LayoutParams.FLAG_SECURE;          sUiAutomation.executeAndWaitForEvent(() -> sInstrumentation.runOnMainSync(                 () -> {                     activity.getWindowManager().addView(image, params);                 }),                 filterWindowsChangedWithChangeTypes(WINDOWS_CHANGE_ADDED),                 DEFAULT_TIMEOUT_MS);         takeScreenshot(Display.DEFAULT_DISPLAY);          verify(mCallback, timeout(TIMEOUT_TAKE_SCREENSHOT_DONE_MILLIS)).onSuccess(                 mSuccessResultArgumentCaptor.capture());          final AccessibilityService.ScreenshotResult newScreenshot =                 mSuccessResultArgumentCaptor.getValue();         final Bitmap bitmap = Bitmap.wrapHardwareBuffer(newScreenshot.getHardwareBuffer(),                 newScreenshot.getColorSpace());          assertTrue(doesBitmapDisplaySecureContent(activity, bitmap, SECURE_WINDOW_CONTENT_COLOR));     }      private boolean doesBitmapDisplaySecureContent(Activity activity, Bitmap screenshot, int color) {         final Display display = activity.getWindowManager().getDefaultDisplay();         final Point displaySize = new Point();         display.getRealSize(displaySize);          final int[] pixels = new int[displaySize.x * displaySize.y];         final Bitmap bitmap = screenshot.copy(Bitmap.Config.ARGB_8888, false);         bitmap.getPixels(pixels, 0, displaySize.x, 0, 0, displaySize.x,                 displaySize.y);         for (int pixel : pixels) {             if ((Color.red(pixel) == Color.red(color))                     && (Color.green(pixel) == Color.green(color))                     && (Color.blue(pixel) == Color.blue(color))) {                 return false;             }         }          return true;     }      private void takeScreenshot(int displayId) {         mStartTestingTime = SystemClock.uptimeMillis();         mService.takeScreenshot(displayId, mContext.getMainExecutor(),                 mCallback);     }      private void verifyScreenshotResult(AccessibilityService.ScreenshotResult screenshot) {         assertNotNull(screenshot);         final HardwareBuffer hardwareBuffer = screenshot.getHardwareBuffer();         assertEquals(mDisplaySize.x, hardwareBuffer.getWidth());         assertEquals(mDisplaySize.y, hardwareBuffer.getHeight());          // The colorSpace should not be null for taking the screenshot case.         final ColorSpace colorSpace = screenshot.getColorSpace();         assertNotNull(colorSpace);          final long finishTestingTime = screenshot.getTimestamp();         assertTrue(finishTestingTime > mStartTestingTime);          // The bitmap should not be null for ScreenshotResult's payload.         final Bitmap bitmap = Bitmap.wrapHardwareBuffer(hardwareBuffer, colorSpace);         assertNotNull(bitmap);     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"postTestTearDown"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterForEventType; import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterWindowsChangTypesAndWindowId; import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterWindowsChangedWithChangeTypes; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.supportsMultiDisplay; import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS; import static android.accessibilityservice.cts.utils.DisplayUtils.getStatusBarHeight; import static android.accessibilityservice.cts.utils.DisplayUtils.VirtualDisplaySession; import static android.app.WindowConfiguration.WINDOWING_MODE_SPLIT_SCREEN_PRIMARY; import static android.app.WindowConfiguration.WINDOWING_MODE_SPLIT_SCREEN_SECONDARY; import static android.content.pm.PackageManager.FEATURE_PICTURE_IN_PICTURE; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_CLICKED; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_FOCUSED; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_LONG_CLICKED; import static android.view.accessibility.AccessibilityEvent.TYPE_WINDOWS_CHANGED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ACCESSIBILITY_FOCUSED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ADDED; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_CLEAR_FOCUS; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_CLEAR_SELECTION; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_CLICK; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_FOCUS; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_LONG_CLICK; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_SELECT;  import static junit.framework.TestCase.assertNull;  import static org.hamcrest.Matchers.lessThan; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertThat; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibilityservice.AccessibilityService; import android.accessibilityservice.AccessibilityServiceInfo; import android.accessibilityservice.cts.activities.AccessibilityWindowQueryActivity; import android.app.Activity; import android.app.ActivityTaskManager; import android.app.Instrumentation; import android.app.UiAutomation; import android.content.pm.PackageManager; import android.graphics.Rect; import android.platform.test.annotations.AppModeFull; import android.test.suitebuilder.annotation.MediumTest; import android.text.TextUtils; import android.util.SparseArray; import android.view.Display; import android.view.Gravity; import android.view.View; import android.view.WindowManager; import android.view.accessibility.AccessibilityEvent; import android.view.accessibility.AccessibilityNodeInfo; import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction; import android.view.accessibility.AccessibilityWindowInfo; import android.widget.Button;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.TestUtils;  import org.hamcrest.Description; import org.hamcrest.TypeSafeMatcher; import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; import java.util.concurrent.TimeoutException; import java.util.concurrent.atomic.AtomicReference; import java.util.function.Consumer; import java.util.function.Function;  /**  * Test cases for testing the accessibility APIs for querying of the screen content.  * These APIs allow exploring the screen and requesting an action to be performed  * on a given view from an AccessibilityService.  */ @AppModeFull @RunWith(AndroidJUnit4.class) public class AccessibilityWindowQueryTest {     private static final String LOG_TAG = ""AccessibilityWindowQueryTest"";     private static String CONTENT_VIEW_RES_NAME =             ""android.accessibilityservice.cts:id/added_content"";     private static final long TIMEOUT_WINDOW_STATE_IDLE = 500;     private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private AccessibilityWindowQueryActivity mActivity;     private Activity mActivityOnVirtualDisplay;      private ActivityTestRule<AccessibilityWindowQueryActivity> mActivityRule =             new ActivityTestRule<>(AccessibilityWindowQueryActivity.class, false, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mDumpOnFailureRule);      @BeforeClass     public static void oneTimeSetup() throws Exception {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation();         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags |= AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE;         sUiAutomation.setServiceInfo(info);     }      @AfterClass     public static void postTestTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         mActivity = launchActivityAndWaitForItToBeOnscreen(                 sInstrumentation, sUiAutomation, mActivityRule);     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"testNoWindowsAccessIfFlagNotSet"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	"public void testNoWindowsAccessIfFlagNotSet() throws Exception {         // Clear window access flag         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags &= ~AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;         sUiAutomation.setServiceInfo(info);          // Make sure the windows cannot be accessed.         assertTrue(sUiAutomation.getWindows().isEmpty());          // Find a button to click on.         final AccessibilityNodeInfo button1 = sUiAutomation.getRootInActiveWindow()                 .findAccessibilityNodeInfosByViewId(                         ""android.accessibilityservice.cts:id/button1"").get(0);          // Click the button to generate an event         AccessibilityEvent event = sUiAutomation.executeAndWaitForEvent(                 () -> button1.performAction(ACTION_CLICK),                 filterForEventType(TYPE_VIEW_CLICKED), DEFAULT_TIMEOUT_MS);          // Make sure the source window cannot be accessed.         assertNull(event.getSource().getWindow());     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"testTraverseAllWindows"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	"public void testTraverseAllWindows() throws Exception {         setAccessInteractiveWindowsFlag();         try {             List<AccessibilityWindowInfo> windows = sUiAutomation.getWindows();             Rect boundsInScreen = new Rect();              final int windowCount = windows.size();             for (int i = 0; i < windowCount; i++) {                 AccessibilityWindowInfo window = windows.get(i);                 // Skip other Apps windows since their state might not be stable while querying.                 if (window.getType() == AccessibilityWindowInfo.TYPE_APPLICATION                         && !TextUtils.equals(window.getTitle(), mActivity.getTitle())) {                     continue;                 }                 window.getBoundsInScreen(boundsInScreen);                 assertFalse(boundsInScreen.isEmpty()); // Varies on screen size, emptiness check.                 assertNull(window.getParent());                 assertSame(0, window.getChildCount());                 assertNull(window.getParent());                 assertNotNull(window.getRoot());                  if (window.getType() == AccessibilityWindowInfo.TYPE_APPLICATION) {                     assertTrue(window.isFocused());                     assertTrue(window.isActive());                     verifyNodesInAppWindow(window.getRoot());                 } else if (window.getType() == AccessibilityWindowInfo.TYPE_SYSTEM) {                     assertFalse(window.isFocused());                     assertFalse(window.isActive());                 }             }         } finally {             clearAccessInteractiveWindowsFlag();         }     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"testTraverseWindowFromEvent"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	"public void testTraverseWindowFromEvent() throws Exception {         setAccessInteractiveWindowsFlag();         try {             // Find a button to click on.             final AccessibilityNodeInfo button1 = sUiAutomation.getRootInActiveWindow()                     .findAccessibilityNodeInfosByViewId(                             ""android.accessibilityservice.cts:id/button1"").get(0);              // Click the button.             AccessibilityEvent event = sUiAutomation.executeAndWaitForEvent(                     () -> button1.performAction(ACTION_CLICK),                     filterForEventType(TYPE_VIEW_CLICKED), DEFAULT_TIMEOUT_MS);              // Get the source window.             AccessibilityWindowInfo window = event.getSource().getWindow();              // Verify the application window.             Rect boundsInScreen = new Rect();             window.getBoundsInScreen(boundsInScreen);             assertFalse(boundsInScreen.isEmpty()); // Varies on screen size, so just emptiness check             assertSame(window.getType(), AccessibilityWindowInfo.TYPE_APPLICATION);             assertTrue(window.isFocused());             assertTrue(window.isActive());             assertNull(window.getParent());             assertSame(0, window.getChildCount());             assertNotNull(window.getRoot());              // Verify the window content.             verifyNodesInAppWindow(window.getRoot());         } finally {             clearAccessInteractiveWindowsFlag();         }     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"testInteractWithAppWindow"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	"public void testInteractWithAppWindow() throws Exception {         setAccessInteractiveWindowsFlag();         try {             // Find a button to click on.             final AccessibilityNodeInfo button1 = sUiAutomation.getRootInActiveWindow()                     .findAccessibilityNodeInfosByViewId(                             ""android.accessibilityservice.cts:id/button1"").get(0);              // Click the button.             AccessibilityEvent event = sUiAutomation.executeAndWaitForEvent(                     () -> button1.performAction(ACTION_CLICK),                     filterForEventType(TYPE_VIEW_CLICKED), DEFAULT_TIMEOUT_MS);              // Get the source window.             AccessibilityWindowInfo window = event.getSource().getWindow();              // Find a another button from the event's window.             final AccessibilityNodeInfo button2 = window.getRoot()                     .findAccessibilityNodeInfosByViewId(                             ""android.accessibilityservice.cts:id/button2"").get(0);              // Click the second button.             sUiAutomation.executeAndWaitForEvent(() -> button2.performAction(ACTION_CLICK),                     filterForEventType(TYPE_VIEW_CLICKED), DEFAULT_TIMEOUT_MS);         } finally {             clearAccessInteractiveWindowsFlag();         }     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"testSingleAccessibilityFocusAcrossWindows"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	"public void testSingleAccessibilityFocusAcrossWindows() throws Exception {         try {             // Add two more windows.             final View views[];             views = addTwoAppPanelWindows(mActivity);              try {                 // Put accessibility focus in the first app window.                 ensureAppWindowFocusedOrFail(0);                 // Make sure there only one accessibility focus.                 assertSingleAccessibilityFocus();                  // Put accessibility focus in the second app window.                 ensureAppWindowFocusedOrFail(1);                 // Make sure there only one accessibility focus.                 assertSingleAccessibilityFocus();                  // Put accessibility focus in the third app window.                 ensureAppWindowFocusedOrFail(2);                 // Make sure there only one accessibility focus.                 assertSingleAccessibilityFocus();             } finally {                 // Clean up panel windows                 sInstrumentation.runOnMainSync(() -> {                     WindowManager wm =                             sInstrumentation.getContext().getSystemService(WindowManager.class);                     for (View view : views) {                         wm.removeView(view);                     }                 });             }         } finally {             ensureAccessibilityFocusCleared();             clearAccessInteractiveWindowsFlag();         }     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"testObjectContract"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	"public void testObjectContract() throws Exception {         try {             AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();             info.flags |= AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;             sUiAutomation.setServiceInfo(info);              // find a view and make sure it is not focused             AccessibilityNodeInfo button = sUiAutomation                     .getRootInActiveWindow().findAccessibilityNodeInfosByText(                             mActivity.getString(R.string.button5)).get(0);             AccessibilityNodeInfo parent = button.getParent();             final int childCount = parent.getChildCount();             for (int i = 0; i < childCount; i++) {                 AccessibilityNodeInfo child = parent.getChild(i);                 assertNotNull(child);                 if (child.equals(button)) {                     assertEquals(""Equal objects must have same hasCode."", button.hashCode(),                             child.hashCode());                     return;                 }             }             fail(""Parent's children do not have the info whose parent is the parent."");         } finally {             AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();             info.flags &= ~AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;             sUiAutomation.setServiceInfo(info);         }     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"testGetWindowsOnAllDisplays_resultIsSortedByLayerDescending"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	"public void testGetWindowsOnAllDisplays_resultIsSortedByLayerDescending() throws Exception {         assumeTrue(supportsMultiDisplay(sInstrumentation.getContext()));          addTwoAppPanelWindows(mActivity);         // Creates a virtual display.         try (final VirtualDisplaySession displaySession = new VirtualDisplaySession()) {             final int virtualDisplayId =                     displaySession.createDisplayWithDefaultDisplayMetricsAndWait(                             sInstrumentation.getContext(), false).getDisplayId();             // Launches an activity on virtual display.             mActivityOnVirtualDisplay = launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(                     sInstrumentation, sUiAutomation,                     AccessibilityEmbeddedDisplayTest.EmbeddedDisplayActivity.class,                     virtualDisplayId);             // Adds two app panel windows on activity of virtual display.             addTwoAppPanelWindows(mActivityOnVirtualDisplay);              // Gets all windows.             SparseArray<List<AccessibilityWindowInfo>> allWindows =                     sUiAutomation.getWindowsOnAllDisplays();             assertNotNull(allWindows);              // Gets windows on default display.             assertTrue(allWindows.contains(Display.DEFAULT_DISPLAY));             List<AccessibilityWindowInfo> windowsOnDefaultDisplay =                     allWindows.get(Display.DEFAULT_DISPLAY);             assertNotNull(windowsOnDefaultDisplay);             assertTrue(windowsOnDefaultDisplay.size() > 0);              AccessibilityWindowInfo windowAddedFirst =                     findWindow(windowsOnDefaultDisplay, R.string.button1);             AccessibilityWindowInfo windowAddedSecond =                     findWindow(windowsOnDefaultDisplay, R.string.button2);             assertThat(windowAddedFirst.getLayer(), lessThan(windowAddedSecond.getLayer()));             assertThat(windowsOnDefaultDisplay,                     new IsSortedBy<>(w -> w.getLayer(), /* ascending */ false));              // Gets windows on virtual display.             assertTrue(allWindows.contains(virtualDisplayId));             List<AccessibilityWindowInfo> windowsOnVirtualDisplay =                     allWindows.get(virtualDisplayId);             assertNotNull(windowsOnVirtualDisplay);             assertTrue(windowsOnVirtualDisplay.size() > 0);              AccessibilityWindowInfo windowAddedFirstOnVirtualDisplay =                     findWindow(windowsOnVirtualDisplay, R.string.button1);             AccessibilityWindowInfo windowAddedSecondOnVirtualDisplay =                     findWindow(windowsOnVirtualDisplay, R.string.button2);             assertThat(windowAddedFirstOnVirtualDisplay.getLayer(),                     lessThan(windowAddedSecondOnVirtualDisplay.getLayer()));             assertThat(windowsOnVirtualDisplay,                     new IsSortedBy<>(w -> w.getLayer(), /* ascending */ false));              mActivityOnVirtualDisplay.finish();         }     }      private AccessibilityWindowInfo findWindow(List<AccessibilityWindowInfo> windows,             int btnTextRes) {         return windows.stream()                 .filter(w -> w.getRoot()                         .findAccessibilityNodeInfosByText(                                 sInstrumentation.getTargetContext().getString(btnTextRes))                         .size() == 1)                 .findFirst()                 .get();     }      private void assertSingleAccessibilityFocus() {         List<AccessibilityWindowInfo> windows = sUiAutomation.getWindows();         AccessibilityWindowInfo focused = null;          final int windowCount = windows.size();         for (int i = 0; i < windowCount; i++) {             AccessibilityWindowInfo window = windows.get(i);              if (window.isAccessibilityFocused()) {                 if (focused == null) {                     focused = window;                      AccessibilityNodeInfo root = window.getRoot();                     assertEquals(sUiAutomation.findFocus(                             AccessibilityNodeInfo.FOCUS_ACCESSIBILITY), root);                     assertEquals(root.findFocus(                             AccessibilityNodeInfo.FOCUS_ACCESSIBILITY), root);                 } else {                     throw new AssertionError(""Duplicate accessibility focus"");                 }             } else {                 AccessibilityNodeInfo root = window.getRoot();                 if (root != null) {                     assertNull(root.findFocus(                             AccessibilityNodeInfo.FOCUS_ACCESSIBILITY));                 }             }         }     }      private void ensureAppWindowFocusedOrFail(int appWindowIndex) throws TimeoutException {         List<AccessibilityWindowInfo> windows = sUiAutomation.getWindows();         AccessibilityWindowInfo focusTarget = null;          int visitedAppWindows = -1;         final int windowCount = windows.size();         for (int i = 0; i < windowCount; i++) {             AccessibilityWindowInfo window = windows.get(i);             if (window.getType() == AccessibilityWindowInfo.TYPE_APPLICATION) {                 visitedAppWindows++;                 if (appWindowIndex <= visitedAppWindows) {                     focusTarget = window;                     break;                 }             }         }          if (focusTarget == null) {             throw new IllegalStateException(""Couldn't find app window: "" + appWindowIndex);         }          if (focusTarget.isAccessibilityFocused()) {             return;         }          final AccessibilityWindowInfo finalFocusTarget = focusTarget;         sUiAutomation.executeAndWaitForEvent(() -> assertTrue(finalFocusTarget.getRoot()                 .performAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS)),                 filterWindowsChangTypesAndWindowId(finalFocusTarget.getId(),                         WINDOWS_CHANGE_ACCESSIBILITY_FOCUSED),                 DEFAULT_TIMEOUT_MS);          windows = sUiAutomation.getWindows();         for (int i = 0; i < windowCount; i++) {             AccessibilityWindowInfo window = windows.get(i);             if (window.getId() == focusTarget.getId()) {                 assertTrue(window.isAccessibilityFocused());                 break;             }         }     }      private View[] addTwoAppPanelWindows(Activity activity) throws TimeoutException {         setAccessInteractiveWindowsFlag();         sUiAutomation                 .waitForIdle(TIMEOUT_WINDOW_STATE_IDLE, DEFAULT_TIMEOUT_MS);          return new View[] {                 addWindow(R.string.button1, params -> {                     params.gravity = Gravity.TOP;                     params.y = getStatusBarHeight(activity);                 }, activity),                 addWindow(R.string.button2, params -> {                     params.gravity = Gravity.BOTTOM;                 }, activity)         };     }      private Button addWindow(int btnTextRes, Consumer<WindowManager.LayoutParams> configure,             Activity activity) throws TimeoutException {         AtomicReference<Button> result = new AtomicReference<>();         sUiAutomation.executeAndWaitForEvent(() -> {             sInstrumentation.runOnMainSync(() -> {                 final WindowManager.LayoutParams params = new WindowManager.LayoutParams();                 params.width = WindowManager.LayoutParams.MATCH_PARENT;                 params.height = WindowManager.LayoutParams.WRAP_CONTENT;                 params.flags = WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN                         | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR                         | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE                         | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;                 params.type = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;                 params.token = activity.getWindow().getDecorView().getWindowToken();                 configure.accept(params);                  final Button button = new Button(activity);                 button.setText(btnTextRes);                 result.set(button);                 activity.getWindowManager().addView(button, params);             });         }, filterWindowsChangedWithChangeTypes(WINDOWS_CHANGE_ADDED), DEFAULT_TIMEOUT_MS);         return result.get();     }      private void setAccessInteractiveWindowsFlag () {         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags |= AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;         sUiAutomation.setServiceInfo(info);     }      private void clearAccessInteractiveWindowsFlag () {         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags &= ~AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;         sUiAutomation.setServiceInfo(info);     }      private void ensureAccessibilityFocusCleared() {         try {             sUiAutomation.executeAndWaitForEvent(() -> {                 List<AccessibilityWindowInfo> windows = sUiAutomation.getWindows();                 final int windowCount = windows.size();                 for (int i = 0; i < windowCount; i++) {                     AccessibilityWindowInfo window = windows.get(i);                     if (window.isAccessibilityFocused()) {                         AccessibilityNodeInfo root = window.getRoot();                         if (root != null) {                             root.performAction(                                     AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);                         }                     }                 }             }, filterForEventType(TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED), DEFAULT_TIMEOUT_MS);         } catch (TimeoutException te) {             /* ignore */         }     }      private void verifyNodesInAppWindow(AccessibilityNodeInfo root) throws Exception {         try {             AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();             info.flags |= AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;             sUiAutomation.setServiceInfo(info);              root.refresh();              // make list of expected nodes             List<String> classNameAndTextList = new ArrayList<String>();             classNameAndTextList.add(""android.widget.LinearLayout"");             classNameAndTextList.add(""android.widget.LinearLayout"");             classNameAndTextList.add(""android.widget.LinearLayout"");             classNameAndTextList.add(""android.widget.LinearLayout"");             classNameAndTextList.add(""android.widget.ButtonB1"");             classNameAndTextList.add(""android.widget.ButtonB2"");             classNameAndTextList.add(""android.widget.ButtonB3"");             classNameAndTextList.add(""android.widget.ButtonB4"");             classNameAndTextList.add(""android.widget.ButtonB5"");             classNameAndTextList.add(""android.widget.ButtonB6"");             classNameAndTextList.add(""android.widget.ButtonB7"");             classNameAndTextList.add(""android.widget.ButtonB8"");             classNameAndTextList.add(""android.widget.ButtonB9"");              boolean verifyContent = false;              Queue<AccessibilityNodeInfo> fringe = new LinkedList<AccessibilityNodeInfo>();             fringe.add(root);              // do a BFS traversal and check nodes             while (!fringe.isEmpty()) {                 AccessibilityNodeInfo current = fringe.poll();                  if (!verifyContent                         && CONTENT_VIEW_RES_NAME.equals(current.getViewIdResourceName())) {                     verifyContent = true;                 }                  if (verifyContent) {                     CharSequence text = current.getText();                     String receivedClassNameAndText = current.getClassName().toString()                             + ((text != null) ? text.toString() : """");                     String expectedClassNameAndText = classNameAndTextList.remove(0);                      assertEquals(""Did not get the expected node info"",                             expectedClassNameAndText, receivedClassNameAndText);                 }                  final int childCount = current.getChildCount();                 for (int i = 0; i < childCount; i++) {                     AccessibilityNodeInfo child = current.getChild(i);                     fringe.add(child);                 }             }         } finally {             AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();             info.flags &= ~AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;             sUiAutomation.setServiceInfo(info);         }     }      private static class IsSortedBy<T> extends TypeSafeMatcher<List<T>> {          private final Function<T, ? extends Comparable> mProperty;         private final boolean mAscending;          private IsSortedBy(Function<T, ? extends Comparable> comparator, boolean ascending) {             mProperty = comparator;             mAscending = ascending;         }          @Override         public void describeTo(Description description) {             description.appendText(""is sorted"");         }          @Override         protected boolean matchesSafely(List<T> item) {             for (int i = 0; i < item.size() - 1; i++) {                 Comparable a = mProperty.apply(item.get(i));                 Comparable b = mProperty.apply(item.get(i));                 int aMinusB = a.compareTo(b);                 if (aMinusB != 0 && (aMinusB < 0) != mAscending) {                     return false;                 }             }             return true;         }     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"postTestTearDown"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterForEventType; import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterWindowsChangTypesAndWindowId; import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterWindowsChangedWithChangeTypes; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.supportsMultiDisplay; import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS; import static android.accessibilityservice.cts.utils.DisplayUtils.getStatusBarHeight; import static android.accessibilityservice.cts.utils.DisplayUtils.VirtualDisplaySession; import static android.app.WindowConfiguration.WINDOWING_MODE_SPLIT_SCREEN_PRIMARY; import static android.app.WindowConfiguration.WINDOWING_MODE_SPLIT_SCREEN_SECONDARY; import static android.content.pm.PackageManager.FEATURE_PICTURE_IN_PICTURE; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_CLICKED; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_FOCUSED; import static android.view.accessibility.AccessibilityEvent.TYPE_VIEW_LONG_CLICKED; import static android.view.accessibility.AccessibilityEvent.TYPE_WINDOWS_CHANGED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ACCESSIBILITY_FOCUSED; import static android.view.accessibility.AccessibilityEvent.WINDOWS_CHANGE_ADDED; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_CLEAR_FOCUS; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_CLEAR_SELECTION; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_CLICK; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_FOCUS; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_LONG_CLICK; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_SELECT;  import static junit.framework.TestCase.assertNull;  import static org.hamcrest.Matchers.lessThan; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertSame; import static org.junit.Assert.assertThat; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibilityservice.AccessibilityService; import android.accessibilityservice.AccessibilityServiceInfo; import android.accessibilityservice.cts.activities.AccessibilityWindowQueryActivity; import android.app.Activity; import android.app.ActivityTaskManager; import android.app.Instrumentation; import android.app.UiAutomation; import android.content.pm.PackageManager; import android.graphics.Rect; import android.platform.test.annotations.AppModeFull; import android.test.suitebuilder.annotation.MediumTest; import android.text.TextUtils; import android.util.SparseArray; import android.view.Display; import android.view.Gravity; import android.view.View; import android.view.WindowManager; import android.view.accessibility.AccessibilityEvent; import android.view.accessibility.AccessibilityNodeInfo; import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction; import android.view.accessibility.AccessibilityWindowInfo; import android.widget.Button;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.TestUtils;  import org.hamcrest.Description; import org.hamcrest.TypeSafeMatcher; import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; import java.util.concurrent.TimeoutException; import java.util.concurrent.atomic.AtomicReference; import java.util.function.Consumer; import java.util.function.Function;  /**  * Test cases for testing the accessibility APIs for querying of the screen content.  * These APIs allow exploring the screen and requesting an action to be performed  * on a given view from an AccessibilityService.  */ @AppModeFull @RunWith(AndroidJUnit4.class) public class AccessibilityWindowQueryTest {     private static final String LOG_TAG = ""AccessibilityWindowQueryTest"";     private static String CONTENT_VIEW_RES_NAME =             ""android.accessibilityservice.cts:id/added_content"";     private static final long TIMEOUT_WINDOW_STATE_IDLE = 500;     private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private AccessibilityWindowQueryActivity mActivity;     private Activity mActivityOnVirtualDisplay;      private ActivityTestRule<AccessibilityWindowQueryActivity> mActivityRule =             new ActivityTestRule<>(AccessibilityWindowQueryActivity.class, false, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mDumpOnFailureRule);      @BeforeClass     public static void oneTimeSetup() throws Exception {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation();         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags |= AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE;         sUiAutomation.setServiceInfo(info);     }      @AfterClass     public static void postTestTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         mActivity = launchActivityAndWaitForItToBeOnscreen(                 sInstrumentation, sUiAutomation, mActivityRule);     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"testFindPictureInPictureWindow"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	"public void testFindPictureInPictureWindow() throws Exception {         if (!sInstrumentation.getContext().getPackageManager()                 .hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {             return;         }         sUiAutomation.executeAndWaitForEvent(() -> {             sInstrumentation.runOnMainSync(() -> {                 mActivity.enterPictureInPictureMode();             });         }, filterForEventType(TYPE_WINDOWS_CHANGED), DEFAULT_TIMEOUT_MS);         sInstrumentation.waitForIdleSync();          // We should be able to find a picture-in-picture window now         int numPictureInPictureWindows = 0;         final List<AccessibilityWindowInfo> windows = sUiAutomation.getWindows();         final int windowCount = windows.size();         for (int i = 0; i < windowCount; i++) {             final AccessibilityWindowInfo window = windows.get(i);             if (window.isInPictureInPictureMode()) {                 numPictureInPictureWindows++;             }         }         assertTrue(numPictureInPictureWindows >= 1);     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityButtonSdk29Test"	"postTestTearDown"	"CtsAccessibilityServiceSdk29TestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/testsdk29/src/android/accessibilityservice/cts/AccessibilityButtonSdk29Test.java"	""	"/**  *.  */  package android.accessibilityservice.cts;  import static android.accessibility.cts.common.AccessibilityShortcutSettingsRule.ACCESSIBILITY_BUTTON; import static android.accessibilityservice.AccessibilityServiceInfo.FLAG_REQUEST_ACCESSIBILITY_BUTTON; import static android.app.UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES;  import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;  import static org.junit.Assert.assertTrue;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.accessibilityservice.AccessibilityServiceInfo; import android.app.Instrumentation; import android.app.Service; import android.app.UiAutomation; import android.content.ComponentName; import android.os.Build; import android.platform.test.annotations.AppModeFull; import android.text.TextUtils; import android.view.accessibility.AccessibilityManager;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.List;  /**  * Test to verify accessibility button targeting sdk 29 APIs.  */ @AppModeFull @RunWith(AndroidJUnit4.class) public class AccessibilityButtonSdk29Test {     private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private InstrumentedAccessibilityServiceTestRule<StubAccessibilityButtonSdk29Service>             mServiceRule = new InstrumentedAccessibilityServiceTestRule<>(                     StubAccessibilityButtonSdk29Service.class);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mServiceRule)             .around(mDumpOnFailureRule);      private StubAccessibilityButtonSdk29Service mService;     private AccessibilityServiceInfo mServiceInfo;     private ComponentName mServiceComponentName;     private AccessibilityManager mAccessibilityManager;      @BeforeClass     public static void oneTimeSetup() {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation(FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);     }      @AfterClass     public static void postTestTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() {         mAccessibilityManager = (AccessibilityManager) sInstrumentation.getContext()                 .getSystemService(Service.ACCESSIBILITY_SERVICE);         mService = mServiceRule.getService();         mServiceInfo = mService.getServiceInfo();         mServiceComponentName = new ComponentName(                 mServiceInfo.getResolveInfo().serviceInfo.packageName,                 mServiceInfo.getResolveInfo().serviceInfo.name);          mServiceInfo.flags |= FLAG_REQUEST_ACCESSIBILITY_BUTTON;         mService.setServiceInfo(mServiceInfo);         mServiceInfo = mService.getServiceInfo();         assertTrue(mService.getApplicationInfo().targetSdkVersion == Build.VERSION_CODES.Q);         assertTrue((mServiceInfo.flags & FLAG_REQUEST_ACCESSIBILITY_BUTTON)                 == FLAG_REQUEST_ACCESSIBILITY_BUTTON);     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityButtonSdk29Test"	"testUpdateRequestAccessibilityButtonFlag_succeeds"	"CtsAccessibilityServiceSdk29TestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/testsdk29/src/android/accessibilityservice/cts/AccessibilityButtonSdk29Test.java"	""	"public void testUpdateRequestAccessibilityButtonFlag_succeeds() {         mServiceInfo.flags &= ~FLAG_REQUEST_ACCESSIBILITY_BUTTON;         mService.setServiceInfo(mServiceInfo);         assertTrue(""Update flagRequestAccessibilityButton should succeed"",                 mService.getServiceInfo().flags == mServiceInfo.flags);     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityTextTraversalTest"	"testTextEditingActions"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityTextTraversalTest.java"	""	"public void testTextEditingActions() throws Exception {         if (!mActivity.getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_INPUT_METHODS)) {             return;         }          final EditText editText = (EditText) mActivity.findViewById(R.id.edit);         final String textContent = getString(R.string.foo_bar_baz);          sInstrumentation.runOnMainSync(new Runnable() {             @Override             public void run() {                 editText.setVisibility(View.VISIBLE);                 editText.setFocusable(true);                 editText.requestFocus();                 editText.setText(getString(R.string.foo_bar_baz));                 Selection.removeSelection(editText.getText());             }         });          final AccessibilityNodeInfo text = sUiAutomation                .getRootInActiveWindow().findAccessibilityNodeInfosByText(                        getString(R.string.foo_bar_baz)).get(0);          // Select all text.         Bundle arguments = new Bundle();         arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, 0);         arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT,                 editText.getText().length());         assertTrue(text.performAction(                 AccessibilityNodeInfo.ACTION_SET_SELECTION, arguments));          // Copy the selected text.         text.performAction(AccessibilityNodeInfo.ACTION_COPY);          // Set selection at the end.         final int textLength = editText.getText().length();         arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, textLength);         arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, textLength);         // Don't check the return value, because the copy action could move the selection and the         // operation will fail if the selection is already at the end.         text.performAction(AccessibilityNodeInfo.ACTION_SET_SELECTION, arguments);          // Verify the selection position.         assertEquals(textLength, Selection.getSelectionStart(editText.getText()));         assertEquals(textLength, Selection.getSelectionEnd(editText.getText()));          // Paste the selected text.         assertTrue(text.performAction(                 AccessibilityNodeInfo.ACTION_PASTE));          // Verify the content.         assertEquals(editText.getText().toString(), textContent + textContent);          // Select all text.         arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, 0);         arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT,                 editText.getText().length());         assertTrue(text.performAction(                 AccessibilityNodeInfo.ACTION_SET_SELECTION, arguments));          // Cut the selected text.         assertTrue(text.performAction(                 AccessibilityNodeInfo.ACTION_CUT));          // Verify the content.         assertTrue(TextUtils.isEmpty(editText.getText()));     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityGlobalActionsTest"	"postTestTearDown"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGlobalActionsTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.homeScreenOrBust;  import static org.junit.Assert.assertTrue;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibilityservice.AccessibilityService; import android.accessibilityservice.AccessibilityServiceInfo; import android.app.Instrumentation; import android.app.UiAutomation; import android.os.SystemClock; import android.platform.test.annotations.AppModeFull; import android.platform.test.annotations.Presubmit;  import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.filters.MediumTest; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.concurrent.TimeoutException;  /**  * Test global actions  */ @Presubmit @AppModeFull @RunWith(AndroidJUnit4.class) public class AccessibilityGlobalActionsTest {     /**      * Timeout required for pending Binder calls or event processing to      * complete.      */     private static final long TIMEOUT_ASYNC_PROCESSING = 5000;      /**      * The timeout since the last accessibility event to consider the device idle.      */     private static final long TIMEOUT_ACCESSIBILITY_STATE_IDLE = 500;      private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      @Rule     public final AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @BeforeClass     public static void oneTimeSetup() {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation();         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags |= AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;         sUiAutomation.setServiceInfo(info);     }      @AfterClass     public static void postTestTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         // Make sure we start test on home screen so we can know if clean up is successful         // or not in the end.         homeScreenOrBust(sInstrumentation.getContext(), sUiAutomation);     }      @After     public void tearDown() throws Exception {         // Make sure we clean up and back to home screen again, or let test fail...         homeScreenOrBust(sInstrumentation.getContext(), sUiAutomation);     }      @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule"	"testWithEnabledAccessibilityService"	""	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibility/common/src/android/accessibility/cts/common/InstrumentedAccessibilityServiceTestRule.java"	""	"public void testWithEnabledAccessibilityService() {  *     MyService service = mServiceRule.enableService();  *     //do something  *     assertTrue(""True wasn't returned"", service.doSomethingToReturnTrue());  * }  * </pre>  *  * @param <T> The instrumented accessibility service class under test  */ public class InstrumentedAccessibilityServiceTestRule<T extends InstrumentedAccessibilityService>         implements TestRule {      private static final String TAG = ""InstrA11yServiceTestRule"";      private final Class<T> mAccessibilityServiceClass;      private final boolean mEnableService;      /**      * Creates a {@link InstrumentedAccessibilityServiceTestRule} with the specified class of      * instrumented accessibility service and enable the service automatically.      *      * @param clazz The instrumented accessibility service under test. This must be a class in the      *     instrumentation targetPackage specified in the AndroidManifest.xml      */     public InstrumentedAccessibilityServiceTestRule(@NonNull Class<T> clazz) {         this(clazz, true);     }      /**      * Creates a {@link InstrumentedAccessibilityServiceTestRule} with the specified class of      * instrumented accessibility service, and enable the service automatically or not according to      * given {@code enableService}.      *      * @param clazz The instrumented accessibility service under test. This must be a class in the      *     instrumentation targetPackage specified in the AndroidManifest.xml      * @param enableService true if the service should be enabled once per <a      *     href=""http://junit.org/javadoc/latest/org/junit/Test.html""><code>Test</code></a> method.      *     It will be enabled before the first <a      *     href=""http://junit.sourceforge.net/javadoc/org/junit/Before.html""><code>Before</code></a>      *     method, and terminated after the last <a      *     href=""http://junit.sourceforge.net/javadoc/org/junit/After.html""><code>After</code></a>      *     method.      */     public InstrumentedAccessibilityServiceTestRule(@NonNull Class<T> clazz,             boolean enableService) {         mAccessibilityServiceClass = clazz;         mEnableService = enableService;     }      /**      * Enable the instrumented accessibility service under test.      *      * <p>Don't call this method directly, unless you explicitly requested not to lazily enable the      * service manually using the enableService flag in {@link      * #InstrumentedAccessibilityServiceTestRule(Class, boolean)}.      *      * <p>Usage:      *      * <pre>      *    &#064;Test      *    public void enableAccessibilityService() {      *        service = mServiceRule.enableService();      *    }      * </pre>      *      * @return the instrumented accessibility service enabled by this rule.      */     @NonNull     public T enableService() {         return InstrumentedAccessibilityService.enableService(mAccessibilityServiceClass);     }      /**      * Override this method to do your own service specific clean up or shutdown.      * The method is called after each test method is executed including any method annotated with      * <a href=""http://junit.sourceforge.net/javadoc/org/junit/After.html""><code>After</code></a>      * and after necessary calls to stop (or unbind) the service under test were called.      */     protected void disableService() {         callFinishOnServiceSync();     }      /**      * Returns the reference to the instrumented accessibility service instance.      *      * <p>If the service wasn't enabled yet or already disabled, {@code null} will be returned.      */     @Nullable     public T getService() {         final T instance = InstrumentedAccessibilityService.getInstanceForClass(                 mAccessibilityServiceClass,                 InstrumentedAccessibilityService.TIMEOUT_SERVICE_ENABLE);         if (instance == null) {             Log.i(TAG, String.format(                     ""Accessibility service %s wasn't enabled yet or already disabled"",                     mAccessibilityServiceClass.getSimpleName()));         }         return instance;     }      private void callFinishOnServiceSync() {         final T service = InstrumentedAccessibilityService.getInstanceForClass(                 mAccessibilityServiceClass);         if (service != null) {             service.runOnServiceSync(service::disableSelfAndRemove);         }     }      @Override     public Statement apply(Statement base, Description description) {         return new ServiceStatement(base);     }      /**      * {@link Statement} that executes the service lifecycle methods before and after the execution      * of the test.      */     private class ServiceStatement extends Statement {         private final Statement base;          public ServiceStatement(Statement base) {             this.base = base;         }          @Override         public void evaluate() throws Throwable {             try {                 if (mEnableService) {                     enableService();                 }                 base.evaluate();             } finally {                 disableService();             }         }     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.view.accessibility.cts.AccessibilityManagerTest"	"testGetRecommendedTimeoutMillis"	"CtsAccessibilityTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityManagerTest.java"	""	"public void testGetRecommendedTimeoutMillis() throws Exception {         mSpeakingAccessibilityServiceRule.enableService();         mVibratingAccessibilityServiceRule.enableService();         waitForAccessibilityEnabled();         UiAutomation automan = sInstrumentation.getUiAutomation(                 UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);         try {             // SpeakingA11yService interactive/nonInteractive timeout is 6000/1000             // vibratingA11yService interactive/nonInteractive timeout is 5000/2000             turnOffRecommendedUiTimoutSettings(automan);             PollingCheck.waitFor(() -> sameRecommendedTimeout(6000, 2000));             turnOnRecommendedUiTimoutSettings(automan, 7000, 0);             PollingCheck.waitFor(() -> sameRecommendedTimeout(7000, 2000));             turnOnRecommendedUiTimoutSettings(automan, 0, 4000);             PollingCheck.waitFor(() -> sameRecommendedTimeout(6000, 4000));             turnOnRecommendedUiTimoutSettings(automan, 9000, 8000);             PollingCheck.waitFor(() -> sameRecommendedTimeout(9000, 8000));             turnOffRecommendedUiTimoutSettings(automan);             PollingCheck.waitFor(() -> sameRecommendedTimeout(6000, 2000));             assertEquals(""Should return original timeout"", 3000,                     mAccessibilityManager.getRecommendedTimeoutMillis(3000,                             AccessibilityManager.FLAG_CONTENT_ICONS));             assertEquals(""Should return original timeout"", 7000,                     mAccessibilityManager.getRecommendedTimeoutMillis(7000,                             AccessibilityManager.FLAG_CONTENT_CONTROLS));         } finally {             automan.destroy();         }     }      private void assertAtomicBooleanBecomes(AtomicBoolean atomicBoolean,             boolean expectedValue, Object waitObject, String message)             throws Exception {         long timeoutTime =                 System.currentTimeMillis() + TIMEOUT_SERVICE_ENABLE;         synchronized (waitObject) {             while ((atomicBoolean.get() != expectedValue)                     && (System.currentTimeMillis() < timeoutTime)) {                 waitObject.wait(timeoutTime - System.currentTimeMillis());             }         }         assertTrue(message, atomicBoolean.get() == expectedValue);     }      private void waitForAccessibilityEnabled() throws InterruptedException {         final Object waitObject = new Object();          AccessibilityStateChangeListener listener = (boolean b) -> {             synchronized (waitObject) {                 waitObject.notifyAll();             }         };         mAccessibilityManager.addAccessibilityStateChangeListener(listener);         long timeoutTime =                 System.currentTimeMillis() + TIMEOUT_SERVICE_ENABLE;         synchronized (waitObject) {             while (!mAccessibilityManager.isEnabled()                     && (System.currentTimeMillis() < timeoutTime)) {                 waitObject.wait(timeoutTime - System.currentTimeMillis());             }         }         mAccessibilityManager.removeAccessibilityStateChangeListener(listener);         assertTrue(""Timed out enabling accessibility"", mAccessibilityManager.isEnabled());     }      private void turnOffRecommendedUiTimoutSettings(UiAutomation automan) {         putSecureSetting(automan, ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS, null);         putSecureSetting(automan, ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS, null);     }      private void turnOnRecommendedUiTimoutSettings(UiAutomation automan,             int interactiveUiTimeout, int nonInteractiveUiTimeout) {         putSecureSetting(automan, ACCESSIBILITY_INTERACTIVE_UI_TIMEOUT_MS,                 Integer.toString(interactiveUiTimeout));         putSecureSetting(automan, ACCESSIBILITY_NON_INTERACTIVE_UI_TIMEOUT_MS,                 Integer.toString(nonInteractiveUiTimeout));     }      private boolean sameRecommendedTimeout(int interactiveUiTimeout,             int nonInteractiveUiTimeout) {         final int currentInteractiveUiTimeout = mAccessibilityManager                 .getRecommendedTimeoutMillis(0, AccessibilityManager.FLAG_CONTENT_CONTROLS);         final int currentNonInteractiveUiTimeout = mAccessibilityManager                 .getRecommendedTimeoutMillis(0, AccessibilityManager.FLAG_CONTENT_ICONS);         return (currentInteractiveUiTimeout == interactiveUiTimeout                 && currentNonInteractiveUiTimeout == nonInteractiveUiTimeout);     }      private void putSecureSetting(UiAutomation automan, String name, String value) {         final StringBuilder cmd = new StringBuilder(""settings put secure "")                 .append(name).append("" "")                 .append(value);         try {             SystemUtil.runShellCommand(automan, cmd.toString());         } catch (IOException e) {             fail(""Fail to run shell command"");         }     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityVolumeTest"	"isVolumeFixed"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityVolumeTest.java"	""	"/**  *.  */ package android.accessibilityservice.cts;  import static android.content.Context.AUDIO_SERVICE;  import static org.junit.Assert.assertEquals;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityService; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.app.Instrumentation; import android.content.pm.PackageManager; import android.media.AudioManager; import android.platform.test.annotations.AppModeFull; import android.platform.test.annotations.Presubmit;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  /**  * Verify that accessibility services can control the accessibility volume.  */ @RunWith(AndroidJUnit4.class) public class AccessibilityVolumeTest {     Instrumentation mInstrumentation;     AudioManager mAudioManager;     // If a platform collects all volumes into one, these tests aren't relevant     boolean mSingleVolume;     // If a11y volume is stuck at a single value, don't run the tests     boolean mFixedA11yVolume;      private InstrumentedAccessibilityServiceTestRule<InstrumentedAccessibilityService>             mServiceRule = new InstrumentedAccessibilityServiceTestRule<>(                     InstrumentedAccessibilityService.class, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mServiceRule)             .around(mDumpOnFailureRule);      @Before     public void setUp() {         mInstrumentation = InstrumentationRegistry.getInstrumentation();         mAudioManager =                 (AudioManager) mInstrumentation.getContext().getSystemService(AUDIO_SERVICE);         // TVs and fixed volume devices have a single volume         PackageManager pm = mInstrumentation.getContext().getPackageManager();         mSingleVolume = (pm != null) && (pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)                 || pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION))                 || mAudioManager.isVolumeFixed();         final int MIN = mAudioManager.getStreamMinVolume(AudioManager.STREAM_ACCESSIBILITY);         final int MAX = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_ACCESSIBILITY);         mFixedA11yVolume = (MIN == MAX);     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.view.accessibility.cts.AccessibilityNodeInfoTest"	"testIsHeadingTakesOldApiIntoAccount"	"CtsAccessibilityTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityNodeInfoTest.java"	""	"public void testIsHeadingTakesOldApiIntoAccount() {         final AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();         assertFalse(info.isHeading());         final CollectionItemInfo headingItemInfo = CollectionItemInfo.obtain(0, 1, 0, 1, true);         info.setCollectionItemInfo(headingItemInfo);         assertTrue(info.isHeading());         final CollectionItemInfo nonHeadingItemInfo = CollectionItemInfo.obtain(0, 1, 0, 1, false);         info.setCollectionItemInfo(nonHeadingItemInfo);         assertFalse(info.isHeading());     }      /**      * Fully populates the {@link AccessibilityNodeInfo} to marshal.      *      * @param info The node info to populate.      */     private void fullyPopulateAccessibilityNodeInfo(AccessibilityNodeInfo info) {         // Populate 10 fields         info.setBoundsInParent(new Rect(1,1,1,1));         info.setBoundsInScreen(new Rect(2,2,2,2));         info.setClassName(""foo.bar.baz.Class"");         info.setContentDescription(""content description"");         info.setStateDescription(""state description"");         info.setTooltipText(""tooltip"");         info.setPackageName(""foo.bar.baz"");         // setText is 2 fields         info.setText(""text"");         info.setHintText(""hint"");          // 2 children = 1 field         info.addChild(new View(getContext()));         info.addChild(new View(getContext()), 1);         // Leashed child = 1 field         info.addChild(new MockBinder());         // 2 built-in actions and 2 custom actions, but all are in 1 field         info.addAction(AccessibilityNodeInfo.ACTION_FOCUS);         info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_FOCUS);         info.addAction(new AccessibilityAction(AccessibilityNodeInfo.ACTION_FOCUS, ""Foo""));         info.addAction(new AccessibilityAction(R.id.foo_custom_action, ""Foo""));          // Populate 10 fields         info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE);         info.setViewIdResourceName(""foo.bar:id/baz"");         info.setDrawingOrder(5);         info.setAvailableExtraData(                 Arrays.asList(AccessibilityNodeInfo.EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY));         info.setPaneTitle(""Pane title"");         info.setError(""Error text"");         info.setMaxTextLength(42);         // Text selection is 2 fields         info.setTextSelection(3, 7);         info.setLiveRegion(View.ACCESSIBILITY_LIVE_REGION_POLITE);          // Populate 11 fields         Bundle extras = info.getExtras();         extras.putBoolean(""areCassowariesAwesome"", true);         info.setInputType(InputType.TYPE_CLASS_TEXT);         info.setRangeInfo(RangeInfo.obtain(RangeInfo.RANGE_TYPE_FLOAT, 0.05f, 1.0f, 0.01f));         info.setCollectionInfo(                 CollectionInfo.obtain(2, 2, true, CollectionInfo.SELECTION_MODE_MULTIPLE));         info.setCollectionItemInfo(CollectionItemInfo.obtain(1, 2, 3, 4, true, true));         info.setParent(new View(getContext()));         info.setSource(new View(getContext())); // Populates 2 fields: source and window id         info.setLeashedParent(new MockBinder(), 1); // Populates 2 fields         info.setTraversalBefore(new View(getContext()));         info.setTraversalAfter(new View(getContext()));          // Populate 3 fields         info.setLabeledBy(new View(getContext()));         info.setLabelFor(new View(getContext()));         populateTouchDelegateTargetMap(info);          // And Boolean properties are another field. Total is 38          // 10 Boolean properties         info.setCheckable(true);         info.setChecked(true);         info.setFocusable(true);         info.setFocused(true);         info.setSelected(true);         info.setClickable(true);         info.setLongClickable(true);         info.setEnabled(true);         info.setPassword(true);         info.setScrollable(true);          // 10 Boolean properties         info.setAccessibilityFocused(true);         info.setVisibleToUser(true);         info.setEditable(true);         info.setCanOpenPopup(true);         info.setDismissable(true);         info.setMultiLine(true);         info.setContentInvalid(true);         info.setContextClickable(true);         info.setImportantForAccessibility(true);         info.setScreenReaderFocusable(true);          // 3 Boolean properties         info.setShowingHintText(true);         info.setHeading(true);         info.setTextEntryKey(true);     }      /**      * Populates touch delegate target map.      */     private void populateTouchDelegateTargetMap(AccessibilityNodeInfo info) {         final ArrayMap<Region, View> targetMap = new ArrayMap<>(3);         final Rect rect1 = new Rect(1, 1, 10, 10);         final Rect rect2 = new Rect(2, 2, 20, 20);         final Rect rect3 = new Rect(3, 3, 30, 30);         targetMap.put(new Region(rect1), new View(getContext()));         targetMap.put(new Region(rect2), new View(getContext()));         targetMap.put(new Region(rect3), new View(getContext()));          final TouchDelegateInfo touchDelegateInfo = new TouchDelegateInfo(targetMap);         info.setTouchDelegateInfo(touchDelegateInfo);     }      private static void assertEqualsTouchDelegateInfo(String message,             AccessibilityNodeInfo.TouchDelegateInfo expected,             AccessibilityNodeInfo.TouchDelegateInfo actual) {         if (expected == actual) return;         assertEquals(message, expected.getRegionCount(), actual.getRegionCount());         for (int i = 0; i < expected.getRegionCount(); i++) {             final Region expectedRegion = expected.getRegionAt(i);             final Long expectedId = expected.getAccessibilityIdForRegion(expectedRegion);             boolean matched = false;             for (int j = 0; j < actual.getRegionCount(); j++) {                 final Region actualRegion = actual.getRegionAt(j);                 final Long actualId = actual.getAccessibilityIdForRegion(actualRegion);                 if (expectedRegion.equals(actualRegion) && expectedId.equals(actualId)) {                     matched = true;                     break;                 }             }             assertTrue(message, matched);         }     }      /**      * Compares all properties of the <code>expectedInfo</code> and the      * <code>receivedInfo</code> to verify that the received node info is      * the one that is expected.      */     public static void assertEqualsAccessibilityNodeInfo(AccessibilityNodeInfo expectedInfo,             AccessibilityNodeInfo receivedInfo) {         // Check 9 fields         Rect expectedBounds = new Rect();         Rect receivedBounds = new Rect();         expectedInfo.getBoundsInParent(expectedBounds);         receivedInfo.getBoundsInParent(receivedBounds);         assertEquals(""boundsInParent has incorrect value"", expectedBounds, receivedBounds);         expectedInfo.getBoundsInScreen(expectedBounds);         receivedInfo.getBoundsInScreen(receivedBounds);         assertEquals(""boundsInScreen has incorrect value"", expectedBounds, receivedBounds);         assertEquals(""className has incorrect value"", expectedInfo.getClassName(),                 receivedInfo.getClassName());         assertEquals(""contentDescription has incorrect value"", expectedInfo.getContentDescription(),                 receivedInfo.getContentDescription());         assertEquals(""stateDescription has incorrect value"", expectedInfo.getStateDescription(),                 receivedInfo.getStateDescription());         assertEquals(""tooltip text has incorrect value"", expectedInfo.getTooltipText(),                 receivedInfo.getTooltipText());         assertEquals(""packageName has incorrect value"", expectedInfo.getPackageName(),                 receivedInfo.getPackageName());         assertEquals(""text has incorrect value"", expectedInfo.getText(), receivedInfo.getText());         assertEquals(""Hint text has incorrect value"",                 expectedInfo.getHintText(), receivedInfo.getHintText());          // Check 2 fields         assertSame(""childCount has incorrect value"", expectedInfo.getChildCount(),                 receivedInfo.getChildCount());         // Actions is just 1 field, but we check it 2 ways         assertSame(""actions has incorrect value"", expectedInfo.getActions(),                 receivedInfo.getActions());         assertEquals(""actionsSet has incorrect value"", expectedInfo.getActionList(),                 receivedInfo.getActionList());          // Check 10 fields         assertSame(""movementGranularities has incorrect value"",                 expectedInfo.getMovementGranularities(),                 receivedInfo.getMovementGranularities());         assertEquals(""viewId has incorrect value"", expectedInfo.getViewIdResourceName(),                 receivedInfo.getViewIdResourceName());         assertEquals(""drawing order has incorrect value"", expectedInfo.getDrawingOrder(),                 receivedInfo.getDrawingOrder());         assertEquals(""Extra data flags have incorrect value"", expectedInfo.getAvailableExtraData(),                 receivedInfo.getAvailableExtraData());         assertEquals(""Pane title has incorrect value"", expectedInfo.getPaneTitle(),                 receivedInfo.getPaneTitle());         assertEquals(""Error text has incorrect value"", expectedInfo.getError(),                 receivedInfo.getError());         assertEquals(""Max text length has incorrect value"", expectedInfo.getMaxTextLength(),                 receivedInfo.getMaxTextLength());         assertEquals(""Text selection start has incorrect value"",                 expectedInfo.getTextSelectionStart(), receivedInfo.getTextSelectionStart());         assertEquals(""Text selection end has incorrect value"",                 expectedInfo.getTextSelectionEnd(), receivedInfo.getTextSelectionEnd());         assertEquals(""Live region has incorrect value"", expectedInfo.getLiveRegion(),                 receivedInfo.getLiveRegion());          // Check 2 fields         // Extras is a Bundle, and Bundle doesn't declare equals. Comparing the keyset gets us         // what we need, though         assertEquals(""Extras have incorrect value"", expectedInfo.getExtras().keySet(),                 receivedInfo.getExtras().keySet());         assertEquals(""InputType has incorrect value"", expectedInfo.getInputType(),                 receivedInfo.getInputType());          // Check 3 fields with sub-objects         RangeInfo expectedRange = expectedInfo.getRangeInfo();         RangeInfo receivedRange = receivedInfo.getRangeInfo();         assertEquals(""Range info has incorrect value"", (expectedRange != null),                 (receivedRange != null));         if (expectedRange != null) {             assertEquals(""RangeInfo#getCurrent has incorrect value"", expectedRange.getCurrent(),                     receivedRange.getCurrent(), 0.0);             assertEquals(""RangeInfo#getMin has incorrect value"", expectedRange.getMin(),                     receivedRange.getMin(), 0.0);             assertEquals(""RangeInfo#getMax has incorrect value"", expectedRange.getMax(),                     receivedRange.getMax(), 0.0);             assertEquals(""RangeInfo#getType has incorrect value"", expectedRange.getType(),                     receivedRange.getType());         }          CollectionInfo expectedCollectionInfo = expectedInfo.getCollectionInfo();         CollectionInfo receivedCollectionInfo = receivedInfo.getCollectionInfo();         assertEquals(""Collection info has incorrect value"", (expectedCollectionInfo != null),                 (receivedCollectionInfo != null));         if (expectedCollectionInfo != null) {             assertEquals(""CollectionInfo#getColumnCount has incorrect value"",                     expectedCollectionInfo.getColumnCount(),                     receivedCollectionInfo.getColumnCount());             assertEquals(""CollectionInfo#getRowCount has incorrect value"",                     expectedCollectionInfo.getRowCount(), receivedCollectionInfo.getRowCount());             assertEquals(""CollectionInfo#getSelectionMode has incorrect value"",                     expectedCollectionInfo.getSelectionMode(),                     receivedCollectionInfo.getSelectionMode());         }          CollectionItemInfo expectedItemInfo = expectedInfo.getCollectionItemInfo();         CollectionItemInfo receivedItemInfo = receivedInfo.getCollectionItemInfo();         assertEquals(""Collection item info has incorrect value"", (expectedItemInfo != null),                 (receivedItemInfo != null));         if (expectedItemInfo != null) {             assertEquals(""CollectionItemInfo#getColumnIndex has incorrect value"",                     expectedItemInfo.getColumnIndex(),                     receivedItemInfo.getColumnIndex());             assertEquals(""CollectionItemInfo#getColumnSpan has incorrect value"",                     expectedItemInfo.getColumnSpan(),                     receivedItemInfo.getColumnSpan());             assertEquals(""CollectionItemInfo#getRowIndex has incorrect value"",                     expectedItemInfo.getRowIndex(),                     receivedItemInfo.getRowIndex());             assertEquals(""CollectionItemInfo#getRowSpan has incorrect value"",                     expectedItemInfo.getRowSpan(),                     receivedItemInfo.getRowSpan());         }          // Check 1 field         assertEqualsTouchDelegateInfo(""TouchDelegate target map has incorrect value"",                 expectedInfo.getTouchDelegateInfo(),                 receivedInfo.getTouchDelegateInfo());          // And the boolean properties are another field, for a total of 28         // Missing parent: Tested end-to-end in AccessibilityWindowTraversalTest#testObjectContract         //                 (getting a child is also checked there)         //         traversalbefore: AccessibilityEndToEndTest         //                          #testTraversalBeforeReportedToAccessibility         //         traversalafter: AccessibilityEndToEndTest         //                         #testTraversalAfterReportedToAccessibility         //         labelfor: AccessibilityEndToEndTest#testLabelForReportedToAccessibility         //         labeledby: AccessibilityEndToEndTest#testLabelForReportedToAccessibility         //         windowid: Not directly observable         //         sourceid: Not directly observable         //         leashedChild: Not directly accessible         //         leashedParent: Not directly accessible         //         leashedParentNodeId: Not directly accessible         // Which brings us to a total of 38          // 10 Boolean properties         assertSame(""checkable has incorrect value"", expectedInfo.isCheckable(),                 receivedInfo.isCheckable());         assertSame(""checked has incorrect value"", expectedInfo.isChecked(),                 receivedInfo.isChecked());         assertSame(""focusable has incorrect value"", expectedInfo.isFocusable(),                 receivedInfo.isFocusable());         assertSame(""focused has incorrect value"", expectedInfo.isFocused(),                 receivedInfo.isFocused());         assertSame(""selected has incorrect value"", expectedInfo.isSelected(),                 receivedInfo.isSelected());         assertSame(""clickable has incorrect value"", expectedInfo.isClickable(),                 receivedInfo.isClickable());         assertSame(""longClickable has incorrect value"", expectedInfo.isLongClickable(),                 receivedInfo.isLongClickable());         assertSame(""enabled has incorrect value"", expectedInfo.isEnabled(),                 receivedInfo.isEnabled());         assertSame(""password has incorrect value"", expectedInfo.isPassword(),                 receivedInfo.isPassword());         assertSame(""scrollable has incorrect value"", expectedInfo.isScrollable(),                 receivedInfo.isScrollable());          // 10 Boolean properties         assertSame(""AccessibilityFocused has incorrect value"",                 expectedInfo.isAccessibilityFocused(),                 receivedInfo.isAccessibilityFocused());         assertSame(""VisibleToUser has incorrect value"", expectedInfo.isVisibleToUser(),                 receivedInfo.isVisibleToUser());         assertSame(""Editable has incorrect value"", expectedInfo.isEditable(),                 receivedInfo.isEditable());         assertSame(""canOpenPopup has incorrect value"", expectedInfo.canOpenPopup(),                 receivedInfo.canOpenPopup());         assertSame(""Dismissable has incorrect value"", expectedInfo.isDismissable(),                 receivedInfo.isDismissable());         assertSame(""Multiline has incorrect value"", expectedInfo.isMultiLine(),                 receivedInfo.isMultiLine());         assertSame(""ContentInvalid has incorrect value"", expectedInfo.isContentInvalid(),                 receivedInfo.isContentInvalid());         assertSame(""contextClickable has incorrect value"", expectedInfo.isContextClickable(),                 receivedInfo.isContextClickable());         assertSame(""importantForAccessibility has incorrect value"",                 expectedInfo.isImportantForAccessibility(),                 receivedInfo.isImportantForAccessibility());         assertSame(""isScreenReaderFocusable has incorrect value"",                 expectedInfo.isScreenReaderFocusable(), receivedInfo.isScreenReaderFocusable());          // 3 Boolean properties         assertSame(""isShowingHint has incorrect value"",                 expectedInfo.isShowingHintText(), receivedInfo.isShowingHintText());         assertSame(""isHeading has incorrect value"",                 expectedInfo.isHeading(), receivedInfo.isHeading());         assertSame(""isTextEntryKey has incorrect value"",                 expectedInfo.isTextEntryKey(), receivedInfo.isTextEntryKey());     }      /**      * Asserts that an {@link AccessibilityNodeInfo} is cleared.      *      * @param info The node info to check.      */     public static void assertAccessibilityNodeInfoCleared(AccessibilityNodeInfo info) {         // Check 11 fields         Rect bounds = new Rect();         info.getBoundsInParent(bounds);         assertTrue(""boundsInParent not properly recycled"", bounds.isEmpty());         info.getBoundsInScreen(bounds);         assertTrue(""boundsInScreen not properly recycled"", bounds.isEmpty());         assertNull(""className not properly recycled"", info.getClassName());         assertNull(""contentDescription not properly recycled"", info.getContentDescription());         assertNull(""stateDescription not properly recycled"", info.getStateDescription());         assertNull(""tooltiptext not properly recycled"", info.getTooltipText());         assertNull(""packageName not properly recycled"", info.getPackageName());         assertNull(""text not properly recycled"", info.getText());         assertNull(""Hint text not properly recycled"", info.getHintText());         assertEquals(""Children list not properly recycled"", 0, info.getChildCount());         // Actions are in one field         assertSame(""actions not properly recycled"", 0, info.getActions());         assertTrue(""action list not properly recycled"", info.getActionList().isEmpty());          // Check 10 fields         assertSame(""movementGranularities not properly recycled"", 0,                 info.getMovementGranularities());         assertNull(""viewId not properly recycled"", info.getViewIdResourceName());         assertEquals(0, info.getDrawingOrder());         assertTrue(info.getAvailableExtraData().isEmpty());         assertNull(""Pane title not properly recycled"", info.getPaneTitle());         assertNull(""Error text not properly recycled"", info.getError());         assertEquals(""Max text length not properly recycled"", -1, info.getMaxTextLength());         assertEquals(""Text selection start not properly recycled"",                 -1, info.getTextSelectionStart());         assertEquals(""Text selection end not properly recycled"", -1, info.getTextSelectionEnd());         assertEquals(""Live region not properly recycled"", 0, info.getLiveRegion());          // Check 6 fields         assertEquals(""Extras not properly recycled"", 0, info.getExtras().keySet().size());         assertEquals(""Input type not properly recycled"", 0, info.getInputType());         assertNull(""Range info not properly recycled"", info.getRangeInfo());         assertNull(""Collection info not properly recycled"", info.getCollectionInfo());         assertNull(""Collection item info not properly recycled"", info.getCollectionItemInfo());         assertNull(""TouchDelegate target map not recycled"", info.getTouchDelegateInfo());          // And Boolean properties brings up to 28 fields         // Missing:         //  parent (can't be performed on sealed instance, even if null)         //  traversalbefore (can't be performed on sealed instance, even if null)         //  traversalafter (can't be performed on sealed instance, even if null)         //  labelfor (can't be performed on sealed instance, even if null)         //  labeledby (can't be performed on sealed instance, even if null)         //  sourceId (not directly observable)         //  windowId (not directly observable)         //  leashedChild (not directly observable)         //  leashedParent (not directly observable)         //  leashedParentNodeId (not directly observable)         // a total of 38          // 10 Boolean properties         assertFalse(""checkable not properly recycled"", info.isCheckable());         assertFalse(""checked not properly recycled"", info.isChecked());         assertFalse(""focusable not properly recycled"", info.isFocusable());         assertFalse(""focused not properly recycled"", info.isFocused());         assertFalse(""selected not properly recycled"", info.isSelected());         assertFalse(""clickable not properly recycled"", info.isClickable());         assertFalse(""longClickable not properly recycled"", info.isLongClickable());         assertFalse(""enabled not properly recycled"", info.isEnabled());         assertFalse(""password not properly recycled"", info.isPassword());         assertFalse(""scrollable not properly recycled"", info.isScrollable());          // 10 Boolean properties         assertFalse(""accessibility focused not properly recycled"", info.isAccessibilityFocused());         assertFalse(""VisibleToUser not properly recycled"", info.isVisibleToUser());         assertFalse(""Editable not properly recycled"", info.isEditable());         assertFalse(""canOpenPopup not properly recycled"", info.canOpenPopup());         assertFalse(""Dismissable not properly recycled"", info.isDismissable());         assertFalse(""Multiline not properly recycled"", info.isMultiLine());         assertFalse(""ContentInvalid not properly recycled"", info.isContentInvalid());         assertFalse(""contextClickable not properly recycled"", info.isContextClickable());         assertFalse(""importantForAccessibility not properly recycled"",                 info.isImportantForAccessibility());         assertFalse(""ScreenReaderFocusable not properly recycled"", info.isScreenReaderFocusable());          // 3 Boolean properties         assertFalse(""isShowingHint not properly reset"", info.isShowingHintText());         assertFalse(""isHeading not properly reset"", info.isHeading());         assertFalse(""isTextEntryKey not properly reset"", info.isTextEntryKey());     }      private static class MockBinder extends Binder {     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityTextActionTest"	"testImageSpan_accessibilityServiceShouldSeeContentDescription"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityTextActionTest.java"	""	"public void testImageSpan_accessibilityServiceShouldSeeContentDescription() {         final TextView textView = (TextView) mActivity.findViewById(R.id.text);         final Bitmap bitmap = Bitmap.createBitmap(/* width= */10, /* height= */10,                 Bitmap.Config.ARGB_8888);         final ImageSpan imageSpan = new ImageSpan(mActivity, bitmap);         final String contentDescription = mActivity.getString(R.string.contentDescription);         imageSpan.setContentDescription(contentDescription);         final SpannableString textWithImageSpan =                 new SpannableString(mActivity.getString(R.string.a_b));         textWithImageSpan.setSpan(imageSpan, /* start= */0, /* end= */1, /* flags= */0);         makeTextViewVisibleAndSetText(textView, textWithImageSpan);          ReplacementSpan replacementSpanFromA11y = findSingleSpanInViewWithText(R.string.a_b,                 ReplacementSpan.class);          assertEquals(contentDescription, replacementSpanFromA11y.getContentDescription());     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityServiceInfoTest"	"testFeedbackTypeToString"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityServiceInfoTest.java"	""	"public void testFeedbackTypeToString() {         assertEquals(""[FEEDBACK_AUDIBLE]"", AccessibilityServiceInfo.feedbackTypeToString(                 AccessibilityServiceInfo.FEEDBACK_AUDIBLE));         assertEquals(""[FEEDBACK_GENERIC]"", AccessibilityServiceInfo.feedbackTypeToString(                 AccessibilityServiceInfo.FEEDBACK_GENERIC));         assertEquals(""[FEEDBACK_HAPTIC]"", AccessibilityServiceInfo.feedbackTypeToString(                 AccessibilityServiceInfo.FEEDBACK_HAPTIC));         assertEquals(""[FEEDBACK_SPOKEN]"", AccessibilityServiceInfo.feedbackTypeToString(                 AccessibilityServiceInfo.FEEDBACK_SPOKEN));         assertEquals(""[FEEDBACK_VISUAL]"", AccessibilityServiceInfo.feedbackTypeToString(                 AccessibilityServiceInfo.FEEDBACK_VISUAL));         assertEquals(""[FEEDBACK_BRAILLE]"", AccessibilityServiceInfo.feedbackTypeToString(                 AccessibilityServiceInfo.FEEDBACK_BRAILLE));         assertEquals(""[FEEDBACK_SPOKEN, FEEDBACK_HAPTIC, FEEDBACK_AUDIBLE, FEEDBACK_VISUAL,""                 + "" FEEDBACK_GENERIC, FEEDBACK_BRAILLE]"",                 AccessibilityServiceInfo.feedbackTypeToString(                         AccessibilityServiceInfo.FEEDBACK_ALL_MASK));     }      /**      * Tests whether a flag is correctly transformed to a string.      */     @MediumTest"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityServiceInfoTest"	"testFlagToString"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityServiceInfoTest.java"	""	"public void testFlagToString() {         assertEquals(""DEFAULT"", AccessibilityServiceInfo.flagToString(                 AccessibilityServiceInfo.DEFAULT));         assertEquals(""FLAG_INCLUDE_NOT_IMPORTANT_VIEWS"", AccessibilityServiceInfo.flagToString(                 AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS));         assertEquals(""FLAG_REPORT_VIEW_IDS"", AccessibilityServiceInfo.flagToString(                 AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS));         assertEquals(""FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY"", AccessibilityServiceInfo                 .flagToString(AccessibilityServiceInfo.FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY));         assertEquals(""FLAG_REQUEST_FILTER_KEY_EVENTS"", AccessibilityServiceInfo.flagToString(                 AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS));         assertEquals(""FLAG_REQUEST_TOUCH_EXPLORATION_MODE"", AccessibilityServiceInfo.flagToString(                 AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE));         assertEquals(""FLAG_RETRIEVE_INTERACTIVE_WINDOWS"", AccessibilityServiceInfo.flagToString(                 AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS));         assertEquals(""FLAG_ENABLE_ACCESSIBILITY_VOLUME"", AccessibilityServiceInfo.flagToString(                 AccessibilityServiceInfo.FLAG_ENABLE_ACCESSIBILITY_VOLUME));         assertEquals(""FLAG_REQUEST_ACCESSIBILITY_BUTTON"", AccessibilityServiceInfo.flagToString(                 AccessibilityServiceInfo.FLAG_REQUEST_ACCESSIBILITY_BUTTON));         assertEquals(""FLAG_REQUEST_FINGERPRINT_GESTURES"", AccessibilityServiceInfo.flagToString(                 AccessibilityServiceInfo.FLAG_REQUEST_FINGERPRINT_GESTURES));         assertEquals(""FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK"", AccessibilityServiceInfo.flagToString(                 AccessibilityServiceInfo.FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK));      }      /**      * Fully populates the {@link AccessibilityServiceInfo} to marshal.      *      * @param sentInfo The service info to populate.      */     private void fullyPopulateSentAccessibilityServiceInfo(AccessibilityServiceInfo sentInfo) {         sentInfo.eventTypes = AccessibilityEvent.TYPE_VIEW_CLICKED;         sentInfo.feedbackType = AccessibilityServiceInfo.FEEDBACK_SPOKEN;         sentInfo.flags = AccessibilityServiceInfo.DEFAULT;         sentInfo.notificationTimeout = 1000;         sentInfo.packageNames = new String[] {             ""foo.bar.baz""         };         sentInfo.setInteractiveUiTimeoutMillis(2000);         sentInfo.setNonInteractiveUiTimeoutMillis(4000);     }      /**      * Compares all properties of the <code>sentInfo</code> and the      * <code>receviedInfo</code> to make sure marshaling is correctly      * implemented.      */     private void assertAllFieldsProperlyMarshalled(AccessibilityServiceInfo sentInfo,             AccessibilityServiceInfo receivedInfo) {         assertEquals(""eventTypes not marshalled properly"", sentInfo.eventTypes,                 receivedInfo.eventTypes);         assertEquals(""feedbackType not marshalled properly"", sentInfo.feedbackType,                 receivedInfo.feedbackType);         assertEquals(""flags not marshalled properly"", sentInfo.flags, receivedInfo.flags);         assertEquals(""notificationTimeout not marshalled properly"", sentInfo.notificationTimeout,                 receivedInfo.notificationTimeout);         assertEquals(""packageNames not marshalled properly"", sentInfo.packageNames.length,                 receivedInfo.packageNames.length);         assertEquals(""packageNames not marshalled properly"", sentInfo.packageNames[0],                 receivedInfo.packageNames[0]);         assertEquals(""interactiveUiTimeout not marshalled properly"",                 sentInfo.getInteractiveUiTimeoutMillis(),                 receivedInfo.getInteractiveUiTimeoutMillis());         assertEquals(""nonInteractiveUiTimeout not marshalled properly"",                 sentInfo.getNonInteractiveUiTimeoutMillis(),                 receivedInfo.getNonInteractiveUiTimeoutMillis());     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityViewTreeReportingTest"	"testUnhideView_receiveSubtreeEvent"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityViewTreeReportingTest.java"	""	"public void testUnhideView_receiveSubtreeEvent() throws Throwable {         final View view = mActivity.findViewById(R.id.hiddenButton);         AccessibilityEvent awaitedEvent =                 sUiAutomation.executeAndWaitForEvent(                         () -> mActivity.runOnUiThread(() -> view.setVisibility(View.VISIBLE)),                         (event) -> {                             boolean isContentChanged = event.getEventType()                                     == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED;                             int isSubTree = (event.getContentChangeTypes()                                     & AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);                             boolean isFromThisPackage = TextUtils.equals(event.getPackageName(),                                     mActivity.getPackageName());                             return isContentChanged && (isSubTree != 0) && isFromThisPackage;                         }, TIMEOUT_ASYNC_PROCESSING);         awaitedEvent.recycle();     }       private void setGetNonImportantViews(boolean getNonImportantViews) {         AccessibilityServiceInfo serviceInfo = sUiAutomation.getServiceInfo();         serviceInfo.flags &= ~AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;         serviceInfo.flags |= getNonImportantViews ?                 AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS : 0;         sUiAutomation.setServiceInfo(serviceInfo);     }      private AccessibilityNodeInfo getNodeByText(int stringId) {         return sUiAutomation.getRootInActiveWindow().findAccessibilityNodeInfosByText(                 sInstrumentation.getContext().getString(stringId)).get(0);     }      class LinearLayoutWithDrawingOrder extends LinearLayout {         public int[] childDrawingOrder;         LinearLayoutWithDrawingOrder(Context context) {             super(context);             setChildrenDrawingOrderEnabled(true);         }          @Override         protected int getChildDrawingOrder(int childCount, int i) {             return childDrawingOrder[i];         }     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityMagnificationTest"	"testA11yNodeInfoVisibility_whenOutOfMagnifiedArea_shouldVisible"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityMagnificationTest.java"	""	"public void testA11yNodeInfoVisibility_whenOutOfMagnifiedArea_shouldVisible()             throws Exception{         final UiAutomation uiAutomation = mInstrumentation.getUiAutomation(                 UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);         final Activity activity = launchActivityAndWaitForItToBeOnscreen(                 mInstrumentation, uiAutomation, mActivityRule);         final MagnificationController controller = mService.getMagnificationController();         final Rect magnifyBounds = controller.getMagnificationRegion().getBounds();         final float scale = 8.0f;         final Button button = activity.findViewById(R.id.button1);         adjustViewBoundsIfNeeded(button, scale, magnifyBounds);          final AccessibilityNodeInfo buttonNode = uiAutomation.getRootInActiveWindow()                 .findAccessibilityNodeInfosByViewId(                         ""android.accessibilityservice.cts:id/button1"").get(0);         assertNotNull(""Can't find button on the screen"", buttonNode);         assertTrue(""Button should be visible"", buttonNode.isVisibleToUser());          // Get right-bottom center position         final float centerX = magnifyBounds.left + (((float) magnifyBounds.width() / (2.0f * scale))                 * ((2.0f * scale) - 1.0f));         final float centerY = magnifyBounds.top + (((float) magnifyBounds.height() / (2.0f * scale))                 * ((2.0f * scale) - 1.0f));         try {             waitOnMagnificationChanged(controller, scale, centerX, centerY);             // Waiting for UI refresh             mInstrumentation.waitForIdleSync();             buttonNode.refresh();              final Rect boundsInScreen = new Rect();             final DisplayMetrics displayMetrics = new DisplayMetrics();             buttonNode.getBoundsInScreen(boundsInScreen);             activity.getDisplay().getMetrics(displayMetrics);             final Rect displayRect = new Rect(0, 0,                     displayMetrics.widthPixels, displayMetrics.heightPixels);             // The boundsInScreen of button is adjusted to outside of screen by framework,             // for example, Rect(-xxx, -xxx, -xxx, -xxx). Intersection of button and screen             // should be empty.             assertFalse(""Button shouldn't be on the screen, screen is "" + displayRect                             + "", button bounds is "" + boundsInScreen,                     Rect.intersects(displayRect, boundsInScreen));             assertTrue(""Button should be visible"", buttonNode.isVisibleToUser());         } finally {             mService.runOnServiceSync(() -> controller.reset(false));         }     }      private void waitOnMagnificationChanged(MagnificationController controller, float newScale,             float newCenterX, float newCenterY) {         final Object waitLock = new Object();         final AtomicBoolean notified = new AtomicBoolean();         final OnMagnificationChangedListener listener = (c, region, scale, centerX, centerY) -> {             final float delta = 5.0f;             synchronized (waitLock) {                 if (newScale == scale                         && (centerX > newCenterX - delta) && (centerY > newCenterY - delta)) {                     notified.set(true);                     waitLock.notifyAll();                 }             }         };         controller.addListener(listener);         try {             final AtomicBoolean setScale = new AtomicBoolean();             final AtomicBoolean setCenter = new AtomicBoolean();             mService.runOnServiceSync(() -> {                 setScale.set(controller.setScale(newScale, false));                 setCenter.set(controller.setCenter(newCenterX, newCenterY, false));             });             assertTrue(""Failed to set scale"", setScale.get());             assertEquals(""Failed to apply scale"", newScale, controller.getScale(), 0f);             assertTrue(""Failed to set center"", setCenter.get());             waitOn(waitLock, () -> notified.get(), LISTENER_TIMEOUT_MILLIS,                     ""waitOnMagnificationChanged"");         } finally {             controller.removeListener(listener);         }     }      /**      * Adjust top-left view bounds if it's still in the magnified viewport after sets magnification      * scale and move centers to bottom-right.      */     private void adjustViewBoundsIfNeeded(View topLeftview, float scale, Rect magnifyBounds) {         final Point magnifyViewportTopLeft = new Point();         magnifyViewportTopLeft.x = (int)((scale - 1.0f) * ((float) magnifyBounds.width() / scale));         magnifyViewportTopLeft.y = (int)((scale - 1.0f) * ((float) magnifyBounds.height() / scale));         magnifyViewportTopLeft.offset(magnifyBounds.left, magnifyBounds.top);          final int[] viewLocation = new int[2];         topLeftview.getLocationOnScreen(viewLocation);         final Rect viewBounds = new Rect(viewLocation[0], viewLocation[1],                 viewLocation[0] + topLeftview.getWidth(),                 viewLocation[1] + topLeftview.getHeight());         if (viewBounds.right < magnifyViewportTopLeft.x                 && viewBounds.bottom < magnifyViewportTopLeft.y) {             // no need             return;         }          final ViewGroup.LayoutParams layoutParams = topLeftview.getLayoutParams();         if (viewBounds.right >= magnifyViewportTopLeft.x) {             layoutParams.width = topLeftview.getWidth() - 1                     - (viewBounds.right - magnifyViewportTopLeft.x);             assertTrue(""Needs to fix layout"", layoutParams.width > 0);         }         if (viewBounds.bottom >= magnifyViewportTopLeft.y) {             layoutParams.height = topLeftview.getHeight() - 1                     - (viewBounds.bottom - magnifyViewportTopLeft.y);             assertTrue(""Needs to fix layout"", layoutParams.height > 0);         }         mInstrumentation.runOnMainSync(() -> topLeftview.setLayoutParams(layoutParams));         // Waiting for UI refresh         mInstrumentation.waitForIdleSync();     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"testClickAt_producesDownThenUp"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	"public void testClickAt_producesDownThenUp() throws InterruptedException {         if (!mHasTouchScreen) {             return;         }          PointF clickPoint = new PointF(mStartPoint.x, mStartPoint.y);         dispatch(clickWithinView(clickPoint), GESTURE_COMPLETION_TIMEOUT);         waitForMotionEvents(any(MotionEvent.class), 2);          assertEquals(2, mMotionEvents.size());         MotionEvent clickDown = mMotionEvents.get(0);         MotionEvent clickUp = mMotionEvents.get(1);         assertThat(clickDown, both(IS_ACTION_DOWN).and(isAtPoint(clickPoint)));         assertThat(clickUp, both(IS_ACTION_UP).and(isAtPoint(clickPoint)));          // Verify other MotionEvent fields in this test to make sure they get initialized.         assertEquals(0, clickDown.getActionIndex());         assertEquals(VIRTUAL_KEYBOARD, clickDown.getDeviceId());         assertEquals(0, clickDown.getEdgeFlags());         assertEquals(1F, clickDown.getXPrecision(), 0F);         assertEquals(1F, clickDown.getYPrecision(), 0F);         assertEquals(1, clickDown.getPointerCount());         assertEquals(1F, clickDown.getPressure(), 0F);          // Verify timing matches click         assertEquals(clickDown.getDownTime(), clickDown.getEventTime());         assertEquals(clickDown.getDownTime(), clickUp.getDownTime());         assertEquals(ViewConfiguration.getTapTimeout(),                 clickUp.getEventTime() - clickUp.getDownTime());         assertTrue(clickDown.getEventTime() + ViewConfiguration.getLongPressTimeout()                 > clickUp.getEventTime());     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"MyTouchListener"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	"/**  *.  */  package android.accessibilityservice.cts;  import static android.accessibility.cts.common.InstrumentedAccessibilityService.enableService; import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.AsyncUtils.await; import static android.accessibilityservice.cts.utils.AsyncUtils.awaitCancellation; import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_CANCEL; import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_DOWN; import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_MOVE; import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_POINTER_DOWN; import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_POINTER_UP; import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_UP; import static android.accessibilityservice.cts.utils.GestureUtils.add; import static android.accessibilityservice.cts.utils.GestureUtils.ceil; import static android.accessibilityservice.cts.utils.GestureUtils.click; import static android.accessibilityservice.cts.utils.GestureUtils.diff; import static android.accessibilityservice.cts.utils.GestureUtils.dispatchGesture; import static android.accessibilityservice.cts.utils.GestureUtils.isAtPoint; import static android.accessibilityservice.cts.utils.GestureUtils.longClick; import static android.accessibilityservice.cts.utils.GestureUtils.path; import static android.accessibilityservice.cts.utils.GestureUtils.times; import static android.view.KeyCharacterMap.VIRTUAL_KEYBOARD;  import static androidx.test.InstrumentationRegistry.getInstrumentation;  import static org.hamcrest.CoreMatchers.allOf; import static org.hamcrest.CoreMatchers.any; import static org.hamcrest.CoreMatchers.both; import static org.hamcrest.CoreMatchers.everyItem; import static org.hamcrest.CoreMatchers.hasItem; import static org.hamcrest.MatcherAssert.assertThat; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue;  import static java.util.concurrent.TimeUnit.MILLISECONDS;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.accessibilityservice.AccessibilityService; import android.accessibilityservice.GestureDescription; import android.accessibilityservice.GestureDescription.StrokeDescription; import android.accessibilityservice.cts.activities.AccessibilityTestActivity; import android.app.Instrumentation; import android.content.Context; import android.content.pm.PackageManager; import android.graphics.Matrix; import android.graphics.Path; import android.graphics.PointF; import android.os.Bundle; import android.os.SystemClock; import android.platform.test.annotations.AppModeFull; import android.util.Log; import android.view.Display; import android.view.MotionEvent; import android.view.View; import android.view.ViewConfiguration; import android.view.WindowManager; import android.widget.TextView;  import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import org.hamcrest.Matcher; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.ArrayList; import java.util.List; import java.util.concurrent.atomic.AtomicBoolean;  /**  * Verify that gestures dispatched from an accessibility service show up in the current UI  */ @AppModeFull @RunWith(AndroidJUnit4.class) public class AccessibilityGestureDispatchTest {     private static final String TAG = AccessibilityGestureDispatchTest.class.getSimpleName();      private static final int GESTURE_COMPLETION_TIMEOUT = 5000; // millis     private static final int MOTION_EVENT_TIMEOUT = 1000; // millis      private ActivityTestRule<GestureDispatchActivity> mActivityRule =             new ActivityTestRule<>(GestureDispatchActivity.class, false, false);      private InstrumentedAccessibilityServiceTestRule<StubGestureAccessibilityService> mServiceRule =             new InstrumentedAccessibilityServiceTestRule<>(                     StubGestureAccessibilityService.class, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mServiceRule)             .around(mDumpOnFailureRule);      final List<MotionEvent> mMotionEvents = new ArrayList<>();     StubGestureAccessibilityService mService;     MyTouchListener mMyTouchListener = new MyTouchListener();     TextView mFullScreenTextView;     int[] mViewLocation = new int[2];  // The location of TextView on the screen.     PointF mStartPoint = new PointF(); // The relative location from mViewLocation.     boolean mGotUpEvent;     // Without a touch screen, there's no point in testing this feature     boolean mHasTouchScreen;     boolean mHasMultiTouch;      private GestureDispatchActivity mActivity;      @Before     public void setUp() throws Exception {         Instrumentation instrumentation = getInstrumentation();         PackageManager pm = instrumentation.getContext().getPackageManager();         mHasTouchScreen = pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)                 || pm.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH);         if (!mHasTouchScreen) {             return;         }          mActivity = launchActivityAndWaitForItToBeOnscreen(instrumentation,                 instrumentation.getUiAutomation(), mActivityRule);          mHasMultiTouch = pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH)                 || pm.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT);          mFullScreenTextView = mActivity.findViewById(R.id.full_screen_text_view);         getInstrumentation().runOnMainSync(() -> {             final int midX = mFullScreenTextView.getWidth() / 2;             final int midY = mFullScreenTextView.getHeight() / 2;             mFullScreenTextView.getLocationOnScreen(mViewLocation);             mFullScreenTextView.setOnTouchListener(mMyTouchListener);             mStartPoint.set(midX, midY);         });          mService = mServiceRule.enableService();          mMotionEvents.clear();         mGotUpEvent = false;     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilitySystemActionTest"	"dropShellPermissionIdentity"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySystemActionTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS; import static android.app.UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES; import static org.junit.Assert.fail;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.accessibilityservice.AccessibilityService; import android.app.Instrumentation; import android.app.PendingIntent; import android.app.RemoteAction; import android.app.UiAutomation; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.graphics.drawable.Icon; import android.platform.test.annotations.AppModeFull; import android.view.accessibility.AccessibilityManager; import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction;  import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit;  @RunWith(AndroidJUnit4.class) public class AccessibilitySystemActionTest {     // intent actions to trigger system action callbacks     private final static String INTENT_ACTION_SYSTEM_ACTION_CALLBACK_OVERRIDE_BACK = ""android.accessibility.cts.end2endtests.action.system_action_callback_override_back"";     private final static String INTENT_ACTION_SYSTEM_ACTION_CALLBACK_NEW = ""android.accessibility.cts.end2endtests.action.system_action_callback_new"";      private final static int NEW_ACTION_ID = 111;     private final static String MANAGE_ACCESSIBILITY_PERMISSION = ""android.permission.MANAGE_ACCESSIBILITY"";      private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private Context mContext;     private AccessibilityManager mAccessibilityManager;      private InstrumentedAccessibilityServiceTestRule<StubSystemActionsAccessibilityService>             mServiceRule = new InstrumentedAccessibilityServiceTestRule<>(             StubSystemActionsAccessibilityService.class, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mServiceRule)             .around(mDumpOnFailureRule);      StubSystemActionsAccessibilityService mService;      @BeforeClass     public static void oneTimeSetup() {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation(FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);         sUiAutomation.adoptShellPermissionIdentity(MANAGE_ACCESSIBILITY_PERMISSION);     }      @AfterClass     public static void finalTearDown() {         sUiAutomation.dropShellPermissionIdentity();         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         mContext = InstrumentationRegistry.getInstrumentation().getContext();         mAccessibilityManager =                 (AccessibilityManager) mContext.getSystemService(Context.ACCESSIBILITY_SERVICE);         // Start stub accessibility service.         mService = mServiceRule.enableService();     }      @After     public void tearDown() throws Exception {         mService.setLatch(null);     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityGestureDetectorTest"	"DisplayMetrics"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDetectorTest.java"	""	"/**  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.DisplayUtils.VirtualDisplaySession; import static android.accessibilityservice.cts.utils.GestureUtils.add; import static android.accessibilityservice.cts.utils.GestureUtils.click; import static android.accessibilityservice.cts.utils.GestureUtils.diff; import static android.accessibilityservice.cts.utils.GestureUtils.endTimeOf; import static android.accessibilityservice.cts.utils.GestureUtils.getGestureBuilder; import static android.accessibilityservice.cts.utils.GestureUtils.longClick; import static android.accessibilityservice.cts.utils.GestureUtils.startingAt; import static android.app.UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES;  import static org.junit.Assume.assumeTrue; import static org.mockito.Mockito.any; import static org.mockito.Mockito.timeout; import static org.mockito.Mockito.verify;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.accessibilityservice.AccessibilityService; import android.accessibilityservice.GestureDescription; import android.accessibilityservice.GestureDescription.StrokeDescription; import android.accessibilityservice.cts.activities.AccessibilityWindowQueryActivity; import android.accessibilityservice.cts.utils.GestureUtils; import android.app.Activity; import android.app.Instrumentation; import android.app.UiAutomation; import android.content.Context; import android.content.pm.PackageManager; import android.graphics.Path; import android.graphics.Point; import android.graphics.PointF; import android.platform.test.annotations.AppModeFull; import android.util.DisplayMetrics; import android.view.Display; import android.view.WindowManager; import android.view.accessibility.AccessibilityEvent;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations;  /** Verify that motion events are recognized as accessibility gestures. */ @RunWith(AndroidJUnit4.class) public class AccessibilityGestureDetectorTest {      // Constants     private static final float GESTURE_LENGTH_INCHES = 1.0f;     // The movement should exceed the threshold 1 cm in 150 ms defined in Swipe.java. It means the     // swipe velocity in testing should be greater than 2.54 cm / 381 ms. Therefore the     // duration should be smaller than 381.     private static final long STROKE_MS = 300;     private static final long GESTURE_DISPATCH_TIMEOUT_MS = 3000;     private static final long EVENT_DISPATCH_TIMEOUT_MS = 3000;     private static final PointF FINGER_OFFSET_PX = new PointF(100f, -50f);      private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private InstrumentedAccessibilityServiceTestRule<GestureDetectionStubAccessibilityService>             mServiceRule = new InstrumentedAccessibilityServiceTestRule<>(                     GestureDetectionStubAccessibilityService.class, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mServiceRule)             .around(mDumpOnFailureRule);      // Test AccessibilityService that collects gestures.     GestureDetectionStubAccessibilityService mService;      boolean mHasTouchScreen;     boolean mScreenBigEnough;     int mStrokeLenPxX; // Gesture stroke size, in pixels     int mStrokeLenPxY;     Point mCenter; // Center of screen. Gestures all start from this point.     PointF mTapLocation;     @Mock AccessibilityService.GestureResultCallback mGestureDispatchCallback;      @BeforeClass     public static void oneTimeSetup() {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation(FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);     }      @AfterClass     public static void finalTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         MockitoAnnotations.initMocks(this);          // Check that device has a touch screen.         PackageManager pm = sInstrumentation.getContext().getPackageManager();         mHasTouchScreen = pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)                 || pm.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH);         if (!mHasTouchScreen) {             return;         }          // Find screen size, check that it is big enough for gestures.         // Gestures will start in the center of the screen, so we need enough horiz/vert space.         WindowManager windowManager = (WindowManager) sInstrumentation.getContext()                 .getSystemService(Context.WINDOW_SERVICE);         final DisplayMetrics metrics = new DisplayMetrics();         windowManager.getDefaultDisplay().getRealMetrics(metrics);         mCenter = new Point((int) metrics.widthPixels / 2, (int) metrics.heightPixels / 2);         mTapLocation = new PointF(mCenter);         mStrokeLenPxX = (int) (GESTURE_LENGTH_INCHES * metrics.xdpi);         // The threshold is determined by xdpi.         mStrokeLenPxY = mStrokeLenPxX;         final boolean screenWideEnough = metrics.widthPixels / 2 > mStrokeLenPxX;         final boolean screenHighEnough =  metrics.heightPixels / 2 > mStrokeLenPxY;         mScreenBigEnough = screenWideEnough && screenHighEnough;         if (!mScreenBigEnough) {             return;         }         // Start stub accessibility service.         mService = mServiceRule.enableService();     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityGestureDetectorTest"	"DisplayMetrics"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDetectorTest.java"	""	"/**  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.DisplayUtils.VirtualDisplaySession; import static android.accessibilityservice.cts.utils.GestureUtils.add; import static android.accessibilityservice.cts.utils.GestureUtils.click; import static android.accessibilityservice.cts.utils.GestureUtils.diff; import static android.accessibilityservice.cts.utils.GestureUtils.endTimeOf; import static android.accessibilityservice.cts.utils.GestureUtils.getGestureBuilder; import static android.accessibilityservice.cts.utils.GestureUtils.longClick; import static android.accessibilityservice.cts.utils.GestureUtils.startingAt; import static android.app.UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES;  import static org.junit.Assume.assumeTrue; import static org.mockito.Mockito.any; import static org.mockito.Mockito.timeout; import static org.mockito.Mockito.verify;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule; import android.accessibilityservice.AccessibilityService; import android.accessibilityservice.GestureDescription; import android.accessibilityservice.GestureDescription.StrokeDescription; import android.accessibilityservice.cts.activities.AccessibilityWindowQueryActivity; import android.accessibilityservice.cts.utils.GestureUtils; import android.app.Activity; import android.app.Instrumentation; import android.app.UiAutomation; import android.content.Context; import android.content.pm.PackageManager; import android.graphics.Path; import android.graphics.Point; import android.graphics.PointF; import android.platform.test.annotations.AppModeFull; import android.util.DisplayMetrics; import android.view.Display; import android.view.WindowManager; import android.view.accessibility.AccessibilityEvent;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.MockitoAnnotations;  /** Verify that motion events are recognized as accessibility gestures. */ @RunWith(AndroidJUnit4.class) public class AccessibilityGestureDetectorTest {      // Constants     private static final float GESTURE_LENGTH_INCHES = 1.0f;     // The movement should exceed the threshold 1 cm in 150 ms defined in Swipe.java. It means the     // swipe velocity in testing should be greater than 2.54 cm / 381 ms. Therefore the     // duration should be smaller than 381.     private static final long STROKE_MS = 300;     private static final long GESTURE_DISPATCH_TIMEOUT_MS = 3000;     private static final long EVENT_DISPATCH_TIMEOUT_MS = 3000;     private static final PointF FINGER_OFFSET_PX = new PointF(100f, -50f);      private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private InstrumentedAccessibilityServiceTestRule<GestureDetectionStubAccessibilityService>             mServiceRule = new InstrumentedAccessibilityServiceTestRule<>(                     GestureDetectionStubAccessibilityService.class, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mServiceRule)             .around(mDumpOnFailureRule);      // Test AccessibilityService that collects gestures.     GestureDetectionStubAccessibilityService mService;      boolean mHasTouchScreen;     boolean mScreenBigEnough;     int mStrokeLenPxX; // Gesture stroke size, in pixels     int mStrokeLenPxY;     Point mCenter; // Center of screen. Gestures all start from this point.     PointF mTapLocation;     @Mock AccessibilityService.GestureResultCallback mGestureDispatchCallback;      @BeforeClass     public static void oneTimeSetup() {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation(FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);     }      @AfterClass     public static void finalTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         MockitoAnnotations.initMocks(this);          // Check that device has a touch screen.         PackageManager pm = sInstrumentation.getContext().getPackageManager();         mHasTouchScreen = pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)                 || pm.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH);         if (!mHasTouchScreen) {             return;         }          // Find screen size, check that it is big enough for gestures.         // Gestures will start in the center of the screen, so we need enough horiz/vert space.         WindowManager windowManager = (WindowManager) sInstrumentation.getContext()                 .getSystemService(Context.WINDOW_SERVICE);         final DisplayMetrics metrics = new DisplayMetrics();         windowManager.getDefaultDisplay().getRealMetrics(metrics);         mCenter = new Point((int) metrics.widthPixels / 2, (int) metrics.heightPixels / 2);         mTapLocation = new PointF(mCenter);         mStrokeLenPxX = (int) (GESTURE_LENGTH_INCHES * metrics.xdpi);         // The threshold is determined by xdpi.         mStrokeLenPxY = mStrokeLenPxX;         final boolean screenWideEnough = metrics.widthPixels / 2 > mStrokeLenPxX;         final boolean screenHighEnough =  metrics.heightPixels / 2 > mStrokeLenPxY;         mScreenBigEnough = screenWideEnough && screenHighEnough;         if (!mScreenBigEnough) {             return;         }         // Start stub accessibility service.         mService = mServiceRule.enableService();     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityGestureDetectorTest"	"testRecognizeGesturePathOnVirtualDisplay"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDetectorTest.java"	""	"@AppModeFull     public void testRecognizeGesturePathOnVirtualDisplay() throws Exception {         assumeTrue(sInstrumentation.getContext().getPackageManager()                 .hasSystemFeature(PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS));          if (!mHasTouchScreen || !mScreenBigEnough) {             return;         }          try (final VirtualDisplaySession displaySession = new VirtualDisplaySession()) {             final int displayId = displaySession.createDisplayWithDefaultDisplayMetricsAndWait(                     sInstrumentation.getTargetContext(), false).getDisplayId();             // Launches an activity on virtual display to meet a real situation.             final Activity activity = launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(                     sInstrumentation, sUiAutomation, AccessibilityWindowQueryActivity.class,                     displayId);              try {                 runGestureDetectionTestOnDisplay(displayId);                 runMultiFingerGestureDetectionTestOnDisplay(displayId);             } finally {                 sInstrumentation.runOnMainSync(() -> {                     activity.finish();                 });                 sInstrumentation.waitForIdleSync();             }         }     }      private void runGestureDetectionTestOnDisplay(int displayId) {         // Compute gesture stroke lengths, in pixels.         final int dx = mStrokeLenPxX;         final int dy = mStrokeLenPxY;          // Test recognizing various gestures.         testGesture(                 doubleTap(displayId),                 AccessibilityService.GESTURE_DOUBLE_TAP,                 displayId);         testGesture(                 doubleTapAndHold(displayId),                 AccessibilityService.GESTURE_DOUBLE_TAP_AND_HOLD,                 displayId);         testPath(p(-dx, +0), AccessibilityService.GESTURE_SWIPE_LEFT, displayId);         testPath(p(+dx, +0), AccessibilityService.GESTURE_SWIPE_RIGHT, displayId);         testPath(p(+0, -dy), AccessibilityService.GESTURE_SWIPE_UP, displayId);         testPath(p(+0, +dy), AccessibilityService.GESTURE_SWIPE_DOWN, displayId);          testPath(p(-dx, +0), p(+0, +0), AccessibilityService.GESTURE_SWIPE_LEFT_AND_RIGHT,                 displayId);         testPath(p(-dx, +0), p(-dx, -dy), AccessibilityService.GESTURE_SWIPE_LEFT_AND_UP,                 displayId);         testPath(p(-dx, +0), p(-dx, +dy), AccessibilityService.GESTURE_SWIPE_LEFT_AND_DOWN,                 displayId);          testPath(p(+dx, +0), p(+0, +0), AccessibilityService.GESTURE_SWIPE_RIGHT_AND_LEFT,                 displayId);         testPath(p(+dx, +0), p(+dx, -dy), AccessibilityService.GESTURE_SWIPE_RIGHT_AND_UP,                 displayId);         testPath(p(+dx, +0), p(+dx, +dy), AccessibilityService.GESTURE_SWIPE_RIGHT_AND_DOWN,                 displayId);          testPath(p(+0, -dy), p(-dx, -dy), AccessibilityService.GESTURE_SWIPE_UP_AND_LEFT,                 displayId);         testPath(p(+0, -dy), p(+dx, -dy), AccessibilityService.GESTURE_SWIPE_UP_AND_RIGHT,                 displayId);         testPath(p(+0, -dy), p(+0, +0), AccessibilityService.GESTURE_SWIPE_UP_AND_DOWN,                 displayId);          testPath(p(+0, +dy), p(-dx, +dy), AccessibilityService.GESTURE_SWIPE_DOWN_AND_LEFT,                 displayId);         testPath(p(+0, +dy), p(+dx, +dy), AccessibilityService.GESTURE_SWIPE_DOWN_AND_RIGHT,                 displayId);         testPath(p(+0, +dy), p(+0, +0), AccessibilityService.GESTURE_SWIPE_DOWN_AND_UP,                 displayId);     }      private void runMultiFingerGestureDetectionTestOnDisplay(int displayId) {         // Compute gesture stroke lengths, in pixels.         final int dx = mStrokeLenPxX;         final int dy = mStrokeLenPxY;         testGesture(                 twoFingerSingleTap(displayId),                 AccessibilityService.GESTURE_2_FINGER_SINGLE_TAP,                 displayId);         testGesture(                 twoFingerDoubleTap(displayId),                 AccessibilityService.GESTURE_2_FINGER_DOUBLE_TAP,                 displayId);                 testGesture(                 twoFingerDoubleTapAndHold(displayId),                 AccessibilityService.GESTURE_2_FINGER_DOUBLE_TAP_AND_HOLD,                 displayId);         testGesture(                 twoFingerTripleTap(displayId),                 AccessibilityService.GESTURE_2_FINGER_TRIPLE_TAP,                 displayId);          testGesture(                 threeFingerSingleTap(displayId),                 AccessibilityService.GESTURE_3_FINGER_SINGLE_TAP,                 displayId);         testGesture(                 threeFingerDoubleTap(displayId),                 AccessibilityService.GESTURE_3_FINGER_DOUBLE_TAP,                 displayId);                 testGesture(                 threeFingerDoubleTapAndHold(displayId),                 AccessibilityService.GESTURE_3_FINGER_DOUBLE_TAP_AND_HOLD,                 displayId);         testGesture(                 threeFingerTripleTap(displayId),                 AccessibilityService.GESTURE_3_FINGER_TRIPLE_TAP,                 displayId);          testGesture(                 fourFingerSingleTap(displayId),                 AccessibilityService.GESTURE_4_FINGER_SINGLE_TAP,                 displayId);         testGesture(                 fourFingerDoubleTap(displayId),                 AccessibilityService.GESTURE_4_FINGER_DOUBLE_TAP,                 displayId);                 testGesture(                 fourFingerDoubleTapAndHold(displayId),                 AccessibilityService.GESTURE_4_FINGER_DOUBLE_TAP_AND_HOLD,                 displayId);         testGesture(                 fourFingerTripleTap(displayId),                 AccessibilityService.GESTURE_4_FINGER_TRIPLE_TAP,                 displayId);          testGesture(                 MultiFingerSwipe(displayId, 3, 0, dy),                 AccessibilityService.GESTURE_3_FINGER_SWIPE_DOWN,                 displayId);         testGesture(                 MultiFingerSwipe(displayId, 3, -dx, 0),                 AccessibilityService.GESTURE_3_FINGER_SWIPE_LEFT,                 displayId);         testGesture(                 MultiFingerSwipe(displayId, 3, dx, 0),                 AccessibilityService.GESTURE_3_FINGER_SWIPE_RIGHT,                 displayId);         testGesture(                 MultiFingerSwipe(displayId, 3, 0, -dy),                 AccessibilityService.GESTURE_3_FINGER_SWIPE_UP,                 displayId);         testGesture(                 MultiFingerSwipe(displayId, 4, 0, dy),                 AccessibilityService.GESTURE_4_FINGER_SWIPE_DOWN,                 displayId);         testGesture(                 MultiFingerSwipe(displayId, 4, -dx, 0),                 AccessibilityService.GESTURE_4_FINGER_SWIPE_LEFT,                 displayId);         testGesture(                 MultiFingerSwipe(displayId, 4, dx, 0),                 AccessibilityService.GESTURE_4_FINGER_SWIPE_RIGHT,                 displayId);         testGesture(                 MultiFingerSwipe(displayId, 4, 0, -dy),                 AccessibilityService.GESTURE_4_FINGER_SWIPE_UP,                 displayId);     }      /** Convenient short alias to make a Point. */     private static Point p(int x, int y) {         return new Point(x, y);     }      /** Test recognizing path from PATH_START to PATH_START+delta on default display. */     private void testPath(Point delta, int gestureId) {         testPath(delta, null, gestureId, Display.DEFAULT_DISPLAY);     }      /** Test recognizing path from PATH_START to PATH_START+delta on specified display. */     private void testPath(Point delta, int gestureId, int displayId) {         testPath(delta, null, gestureId, displayId);     }     /** Test recognizing path from PATH_START to PATH_START+delta on default display. */     private void testPath(Point delta1, Point delta2, int gestureId) {         testPath(delta1, delta2, gestureId, Display.DEFAULT_DISPLAY);     }      /**      * Test recognizing path from PATH_START to PATH_START+delta1 to PATH_START+delta2. on specified      * display.      */     private void testPath(Point delta1, Point delta2, int gestureId, int displayId) {         // Create gesture motions.         int numPathSegments = (delta2 == null) ? 1 : 2;         long pathDurationMs = numPathSegments * STROKE_MS;         GestureDescription gesture = new GestureDescription.Builder()                 .addStroke(new StrokeDescription(                 linePath(mCenter, delta1, delta2), 0, pathDurationMs, false))                 .setDisplayId(displayId)                 .build();          testGesture(gesture, gestureId, displayId);     }      /** Dispatch a gesture and make sure it is detected as the specified gesture id. */     private void testGesture(GestureDescription gesture, int gestureId, int displayId) {         // Dispatch gesture motions to specified  display with GestureDescription..         // Use AccessibilityService.dispatchGesture() instead of Instrumentation.sendPointerSync()         // because accessibility services read gesture events upstream from the point where         // sendPointerSync() injects events.         mService.clearGestures();         mService.runOnServiceSync(() ->         mService.dispatchGesture(gesture, mGestureDispatchCallback, null));         verify(mGestureDispatchCallback, timeout(GESTURE_DISPATCH_TIMEOUT_MS).atLeastOnce())                 .onCompleted(any());          // Wait for gesture recognizer, and check recognized gesture.         mService.assertGestureReceived(gestureId, displayId);     }     /** Create a path from startPoint, moving by delta1, then delta2. (delta2 may be null.) */     Path linePath(Point startPoint, Point delta1, Point delta2) {         Path path = new Path();         path.moveTo(startPoint.x, startPoint.y);         path.lineTo(startPoint.x + delta1.x, startPoint.y + delta1.y);         if (delta2 != null) {             path.lineTo(startPoint.x + delta2.x, startPoint.y + delta2.y);         }         return path;     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityGestureDetectorTest"	"testVerifyGestureTouchEventOnVirtualDisplay"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDetectorTest.java"	""	"@AppModeFull     public void testVerifyGestureTouchEventOnVirtualDisplay() throws Exception {         assumeTrue(sInstrumentation.getContext().getPackageManager()                 .hasSystemFeature(PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS));         if (!mHasTouchScreen || !mScreenBigEnough) {             return;         }          try (final VirtualDisplaySession displaySession = new VirtualDisplaySession()) {             final int displayId = displaySession.createDisplayWithDefaultDisplayMetricsAndWait(                     sInstrumentation.getTargetContext(),                     false).getDisplayId();              // Launches an activity on virtual display to meet a real situation.             final Activity activity = launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(                     sInstrumentation, sUiAutomation, AccessibilityWindowQueryActivity.class,                     displayId);             try {                 verifyGestureTouchEventOnDisplay(displayId);                 verifyMultiFingerGestureTouchEventOnDisplay(displayId);             } finally {                 sInstrumentation.runOnMainSync(() -> {                     activity.finish();                 });                 sInstrumentation.waitForIdleSync();             }         }     }      private void verifyGestureTouchEventOnDisplay(int displayId) {         assertEventAfterGesture(swipe(displayId),                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_START,                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);          assertEventAfterGesture(tap(displayId),                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_START,                 AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_START,                 AccessibilityEvent.TYPE_TOUCH_EXPLORATION_GESTURE_END,                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);          assertEventAfterGesture(doubleTap(displayId),                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_START,                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);          assertEventAfterGesture(doubleTapAndHold(displayId),                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_START,                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);     }      private void verifyMultiFingerGestureTouchEventOnDisplay(int displayId) {         assertEventAfterGesture(twoFingerSingleTap(displayId),                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_START,                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);         assertEventAfterGesture(twoFingerDoubleTap(displayId),                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_START,                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);         assertEventAfterGesture(twoFingerTripleTap(displayId),                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_START,                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);          assertEventAfterGesture(threeFingerSingleTap(displayId),                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_START,                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);         assertEventAfterGesture(threeFingerDoubleTap(displayId),                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_START,                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);         assertEventAfterGesture(threeFingerTripleTap(displayId),                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_START,                 AccessibilityEvent.TYPE_TOUCH_INTERACTION_END);     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityGestureDetectorTest"	"testDispatchGesture_privateDisplay_gestureCancelled"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDetectorTest.java"	""	"@AppModeFull     public void testDispatchGesture_privateDisplay_gestureCancelled() throws Exception{         assumeTrue(sInstrumentation.getContext().getPackageManager()             .hasSystemFeature(PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS));         if (!mHasTouchScreen || !mScreenBigEnough) {             return;         }          try (final VirtualDisplaySession displaySession = new VirtualDisplaySession()) {             final int displayId = displaySession.createDisplayWithDefaultDisplayMetricsAndWait                     (sInstrumentation.getTargetContext(),                             true).getDisplayId();             GestureDescription gesture = swipe(displayId);             mService.clearGestures();             mService.runOnServiceSync(() ->                     mService.dispatchGesture(gesture, mGestureDispatchCallback, null));             verify(mGestureDispatchCallback, timeout(GESTURE_DISPATCH_TIMEOUT_MS).atLeastOnce())                     .onCancelled(any());         }     }      /** Test touch for accessibility events */     private void assertEventAfterGesture(GestureDescription gesture, int... events) {         mService.clearEvents();         mService.runOnServiceSync(                 () -> mService.dispatchGesture(gesture, mGestureDispatchCallback, null));         verify(mGestureDispatchCallback, timeout(EVENT_DISPATCH_TIMEOUT_MS).atLeastOnce())                 .onCompleted(any());          mService.assertPropagated(events);     }      private GestureDescription swipe(int displayId) {         StrokeDescription swipe = new StrokeDescription(                 linePath(mCenter, p(0, mStrokeLenPxY), null), 0, STROKE_MS, false);         return getGestureBuilder(displayId, swipe).build();     }      private GestureDescription tap(int displayId) {         StrokeDescription tap = click(mTapLocation);         return getGestureBuilder(displayId, tap).build();     }      private GestureDescription doubleTap(int displayId) {         StrokeDescription tap1 = click(mTapLocation);         StrokeDescription tap2 = startingAt(endTimeOf(tap1) + 20, click(mTapLocation));         return getGestureBuilder(displayId, tap1, tap2).build();     }      private GestureDescription doubleTapAndHold(int displayId) {         StrokeDescription tap1 = click(mTapLocation);         StrokeDescription tap2 = startingAt(endTimeOf(tap1) + 20, longClick(mTapLocation));         return getGestureBuilder(displayId, tap1, tap2).build();     }      private GestureDescription twoFingerSingleTap(int displayId) {         return multiFingerMultiTap(2, 1, displayId);     }      private GestureDescription twoFingerDoubleTap(int displayId) {         return multiFingerMultiTap(2, 2, displayId);     }      private GestureDescription twoFingerDoubleTapAndHold(int displayId) {         return multiFingerMultiTapAndHold(2, 2, displayId);     }       private GestureDescription twoFingerTripleTap(int displayId) {         return multiFingerMultiTap(2, 3, displayId);     }      private GestureDescription threeFingerSingleTap(int displayId) {         return multiFingerMultiTap(3, 1, displayId);     }      private GestureDescription threeFingerDoubleTap(int displayId) {         return multiFingerMultiTap(3, 2, displayId);     }      private GestureDescription threeFingerDoubleTapAndHold(int displayId) {         return multiFingerMultiTapAndHold(3, 2, displayId);     }      private GestureDescription threeFingerTripleTap(int displayId) {         return multiFingerMultiTap(3, 3, displayId);     }      private GestureDescription fourFingerSingleTap(int displayId) {         return multiFingerMultiTap(4, 1, displayId);     }      private GestureDescription fourFingerDoubleTap(int displayId) {         return multiFingerMultiTap(4, 2, displayId);     }      private GestureDescription fourFingerDoubleTapAndHold(int displayId) {         return multiFingerMultiTapAndHold(4, 2, displayId);     }      private GestureDescription fourFingerTripleTap(int displayId) {         return multiFingerMultiTap(4, 3, displayId);     }      private GestureDescription multiFingerMultiTap(int fingerCount, int tapCount, int displayId) {         // We dispatch the first finger, base, placed at left down side by an offset         // from the center of the display and the rest ones at right up side by delta         // from the base.         final PointF base = diff(mTapLocation, FINGER_OFFSET_PX);         return GestureUtils.multiFingerMultiTap(                 base, FINGER_OFFSET_PX, fingerCount, tapCount, /* slop= */ 0, displayId);     }      private GestureDescription multiFingerMultiTapAndHold(             int fingerCount, int tapCount, int displayId) {         // We dispatch the first finger, base, placed at left down side by an offset         // from the center of the display and the rest ones at right up side by delta         // from the base.         final PointF base = diff(mTapLocation, FINGER_OFFSET_PX);         return GestureUtils.multiFingerMultiTapAndHold(                 base, FINGER_OFFSET_PX, fingerCount, tapCount, /* slop= */ 0, displayId);     }      private GestureDescription MultiFingerSwipe(             int displayId, int fingerCount, float dx, float dy) {         float fingerOffset = 10f;         GestureDescription.Builder builder = new GestureDescription.Builder();         builder.setDisplayId(displayId);         for (int currentFinger = 0; currentFinger < fingerCount; ++currentFinger) {             builder.addStroke(                     GestureUtils.swipe(                             add(mTapLocation, fingerOffset * currentFinger, 0),                             add(mTapLocation, dx + (fingerOffset * currentFinger), dy),                             STROKE_MS));         }         return builder.build();     } }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityFocusAndInputFocusSyncTest"	"postTestTearDown"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityFocusAndInputFocusSyncTest.java"	""	"/**  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS; import static android.view.accessibility.AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibilityservice.AccessibilityServiceInfo; import android.accessibilityservice.cts.activities.AccessibilityFocusAndInputFocusSyncActivity; import android.app.Instrumentation; import android.app.UiAutomation; import android.platform.test.annotations.Presubmit; import android.test.suitebuilder.annotation.MediumTest; import android.view.View; import android.view.accessibility.AccessibilityEvent; import android.view.accessibility.AccessibilityNodeInfo;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.LinkedList; import java.util.Queue; import java.util.concurrent.atomic.AtomicBoolean;  /**  * Test cases for testing the accessibility focus APIs exposed to accessibility  * services. These APIs allow moving accessibility focus in the view tree from  * an AccessiiblityService. Specifically, this activity is for verifying the the  * sync between accessibility and input focus.  */ @RunWith(AndroidJUnit4.class) public class AccessibilityFocusAndInputFocusSyncTest {     private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private AccessibilityFocusAndInputFocusSyncActivity mActivity;      private ActivityTestRule<AccessibilityFocusAndInputFocusSyncActivity> mActivityRule =             new ActivityTestRule<>(AccessibilityFocusAndInputFocusSyncActivity.class, false, false);      private AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mDumpOnFailureRule);      @BeforeClass     public static void oneTimeSetup() throws Exception {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation();         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags |= AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE;         info.flags &= ~AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;         sUiAutomation.setServiceInfo(info);     }      @AfterClass     public static void postTestTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Exception {         mActivity = launchActivityAndWaitForItToBeOnscreen(                 sInstrumentation, sUiAutomation, mActivityRule);     }      @MediumTest     @Presubmit"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEmbeddedHierarchyTest"	"postTestTearDown"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"flag"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEmbeddedHierarchyTest.java"	""	"/*  *.  */  package android.accessibilityservice.cts;  import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen; import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue;  import android.accessibility.cts.common.AccessibilityDumpOnFailureRule; import android.accessibilityservice.AccessibilityServiceInfo; import android.accessibilityservice.cts.activities.AccessibilityTestActivity; import android.app.Instrumentation; import android.app.UiAutomation; import android.graphics.Point; import android.graphics.Rect; import android.hardware.display.DisplayManager; import android.os.Bundle; import android.util.DisplayMetrics; import android.view.Display; import android.view.SurfaceControlViewHost; import android.view.SurfaceHolder; import android.view.SurfaceView; import android.view.View; import android.view.accessibility.AccessibilityNodeInfo; import android.view.accessibility.AccessibilityWindowInfo;  import androidx.test.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Rule; import org.junit.Test; import org.junit.rules.RuleChain; import org.junit.runner.RunWith;  import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException;  /**  * Tests that AccessibilityNodeInfos from an embedded hierarchy that is present to another  * hierarchy are properly populated.  */ @RunWith(AndroidJUnit4.class) public class AccessibilityEmbeddedHierarchyTest {     private static Instrumentation sInstrumentation;     private static UiAutomation sUiAutomation;      private final ActivityTestRule<AccessibilityEmbeddedHierarchyActivity> mActivityRule =             new ActivityTestRule<>(AccessibilityEmbeddedHierarchyActivity.class, false, false);      private static final String HOST_VIEW_RESOURCE_NAME =             ""android.accessibilityservice.cts:id/host_surfaceview"";     private static final String EMBEDDED_VIEW_RESOURCE_NAME =             ""android.accessibilityservice.cts:id/embedded_button"";      private final AccessibilityDumpOnFailureRule mDumpOnFailureRule =             new AccessibilityDumpOnFailureRule();      private AccessibilityEmbeddedHierarchyActivity mActivity;      @Rule     public final RuleChain mRuleChain = RuleChain             .outerRule(mActivityRule)             .around(mDumpOnFailureRule);      @BeforeClass     public static void oneTimeSetup() {         sInstrumentation = InstrumentationRegistry.getInstrumentation();         sUiAutomation = sInstrumentation.getUiAutomation();         AccessibilityServiceInfo info = sUiAutomation.getServiceInfo();         info.flags |= AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE;         sUiAutomation.setServiceInfo(info);     }      @AfterClass     public static void postTestTearDown() {         sUiAutomation.destroy();     }      @Before     public void setUp() throws Throwable {         mActivity = launchActivityAndWaitForItToBeOnscreen(sInstrumentation, sUiAutomation,                 mActivityRule);         mActivity.waitForEmbeddedHierarchy();     }"	""	""	""	""	""
"83:338286) 3.8.16  . Device Controls"	"3.8.16"	"H-2-2"	""	"android.accessibilityservice.cts.AccessibilityEmbeddedHierarchyTest"	"testEmbeddedViewIsInvisibleAfterMovingOutOfScreen"	"CtsAccessibilityServiceTestCases"	""	"3.8.16/H-2-2"	""">3.8.16/H-2-2] MUST declare the feature flag android.software.controls and set it to false. Handheld device implementations: [<a href=""#3_10_accessibility"""""	""	"flag android.software.controls feature"	""	""	""	"feature"	""	""	""	"/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEmbeddedHierarchyTest.java"	""	"public void testEmbeddedViewIsInvisibleAfterMovingOutOfScreen() throws TimeoutException {         final AccessibilityNodeInfo target =                 findEmbeddedAccessibilityNodeInfo(sUiAutomation.getRootInActiveWindow());         assertTrue(""Embedded view should be visible at beginning."",                 target.isVisibleToUser());          // Move Host SurfaceView out of screen         final Point screenSize = getScreenSize();         mActivity.requestNewLayoutForTest(screenSize.x, screenSize.y);          target.refresh();         assertFalse(""Embedded view should be invisible after moving out of screen."",                 target.isVisibleToUser());     }      private AccessibilityNodeInfo findEmbeddedAccessibilityNodeInfo(AccessibilityNodeInfo root) {         final int childCount = root.getChildCount();         for (int i = 0; i < childCount; i++) {             final AccessibilityNodeInfo info = root.getChild(i);             if (info == null) {                 continue;             }             if (EMBEDDED_VIEW_RESOURCE_NAME.equals(info.getViewIdResourceName())) {                 return info;             }             if (info.getChildCount() != 0) {                 return findEmbeddedAccessibilityNodeInfo(info);             }         }         return null;     }      private Point getScreenSize() {         final DisplayManager dm = sInstrumentation.getContext().getSystemService(                 DisplayManager.class);         final Display display = dm.getDisplay(Display.DEFAULT_DISPLAY);         final DisplayMetrics metrics = new DisplayMetrics();         display.getRealMetrics(metrics);         return new Point(metrics.widthPixels, metrics.heightPixels);     }      /**      * This class is an dummy {@link android.app.Activity} used to perform embedded hierarchy      * testing of the accessibility feature by interaction with the UI widgets.      */     public static class AccessibilityEmbeddedHierarchyActivity extends             AccessibilityTestActivity implements SurfaceHolder.Callback {         private final CountDownLatch mCountDownLatch = new CountDownLatch(1);          private static final int DEFAULT_WIDTH = 150;         private static final int DEFAULT_HEIGHT = 150;          private SurfaceView mSurfaceView;         private SurfaceControlViewHost mViewHost;          @Override         protected void onCreate(Bundle savedInstanceState) {             super.onCreate(savedInstanceState);             setContentView(R.layout.accessibility_embedded_hierarchy_test_host_side);             mSurfaceView = findViewById(R.id.host_surfaceview);             mSurfaceView.getHolder().addCallback(this);         }          @Override         public void surfaceCreated(SurfaceHolder holder) {             mViewHost = new SurfaceControlViewHost(this, this.getDisplay(),                     mSurfaceView.getHostToken());              mSurfaceView.setChildSurfacePackage(mViewHost.getSurfacePackage());              View layout = getLayoutInflater().inflate(                     R.layout.accessibility_embedded_hierarchy_test_embedded_side, null);             mViewHost.setView(layout, DEFAULT_WIDTH, DEFAULT_HEIGHT);             mCountDownLatch.countDown();         }          @Override         public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {             // No-op         }          @Override         public void surfaceDestroyed(SurfaceHolder holder) {             // No-op         }          public void waitForEmbeddedHierarchy() {             try {                 assertTrue(""timed out waiting for embedded hierarchy to init."",                         mCountDownLatch.await(3, TimeUnit.SECONDS));             } catch (InterruptedException e) {                 throw new AssertionError(e);             }         }          public void requestNewLayoutForTest(int x, int y) throws TimeoutException {             sUiAutomation.executeAndWaitForEvent(                     () -> sInstrumentation.runOnMainSync(() -> {                         mSurfaceView.setX(x);                         mSurfaceView.setY(y);                         mSurfaceView.requestLayout();                     }),                     (event) -> {                         final Rect boundsInScreen = new Rect();                         final AccessibilityWindowInfo window =                                 sUiAutomation.getRootInActiveWindow().getWindow();                         window.getBoundsInScreen(boundsInScreen);                         return !boundsInScreen.isEmpty();                     }, DEFAULT_TIMEOUT_MS);         }     } }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.ipv6.cts.PingTest"	"testLoopbackPing"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/ipv6/cts/PingTest.java"	""	"public void testLoopbackPing() throws ErrnoException, IOException {         // Generate a random ping packet and send it to localhost.         InetAddress ipv6Loopback = InetAddress.getByName(null);         assertEquals(""::1"", ipv6Loopback.getHostAddress());          for (int i = 0; i < NUM_PACKETS; i++) {             byte[] packet = pingPacket((int) (Math.random() * (MAX_SIZE - ICMP_HEADER_SIZE)));             FileDescriptor s = createPingSocket();             // Use both recvfrom and read().             sendPing(s, ipv6Loopback, packet);             checkResponse(s, ipv6Loopback, packet, true);             sendPing(s, ipv6Loopback, packet);             checkResponse(s, ipv6Loopback, packet, false);             // Check closing the socket doesn't raise an exception.             Os.close(s);         }     } }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.ipsec.ike.cts.IkeIdentificationTest"	"testIkeIpv6AddrIdentification"	"CtsIkeTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/ipsec/src/android/net/ipsec/ike/cts/IkeIdentificationTest.java"	""	"public void testIkeIpv6AddrIdentification() throws Exception {         IkeIpv6AddrIdentification ikeId = new IkeIpv6AddrIdentification(IPV6_ADDRESS_LOCAL);         assertEquals(IPV6_ADDRESS_LOCAL, ikeId.ipv6Address);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.DnsTest"	"testNativeDns"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsTest.java"	""	"public void test/*  *.  */  package android.net.cts;  import android.content.Context; import android.content.pm.PackageManager; import android.net.ConnectivityManager; import android.net.ConnectivityManager.NetworkCallback; import android.net.LinkProperties; import android.net.Network; import android.net.NetworkInfo; import android.os.SystemClock; import android.test.AndroidTestCase; import android.util.Log;  import com.android.testutils.SkipPresubmit;  import java.net.Inet4Address; import java.net.Inet6Address; import java.net.InetAddress; import java.net.UnknownHostException; import java.util.ArrayList; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit;  public class DnsTest extends AndroidTestCase {      static {         System.loadLibrary(""nativedns_jni"");     }      private static final boolean DBG = false;     private static final String TAG = ""DnsTest"";     private static final String PROXY_NETWORK_TYPE = ""PROXY"";      private ConnectivityManager mCm;      public void setUp() {         mCm = getContext().getSystemService(ConnectivityManager.class);     }      /**      * @return true on success      */     private static native boolean testNativeDns();      /**      * Verify:      * DNS works - forwards and backwards, giving ipv4 and ipv6      * Test that DNS work on v4 and v6 networks      * Test Native dns calls (4)      * Todo:      * Cache is flushed when we change networks      * have per-network caches      * No cache when there's no network      * Perf - measure size of first and second tier caches and their effect      * Assert requires network permission      */     @SkipPresubmit(reason = ""IPv6 support may be missing on presubmit virtual hardware"")"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.DnsTest"	"testDnsWorks"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsTest.java"	""	"public void testDnsWorks() throws Exception {         ensureIpv6Connectivity();          InetAddress addrs[] = {};         try {             addrs = InetAddress.getAllByName(""www.google.com"");         } catch (UnknownHostException e) {}         assertTrue(""[RERUN] DNS could not resolve www.google.com. Check internet connection"",                 addrs.length != 0);         boolean foundV4 = false, foundV6 = false;         for (InetAddress addr : addrs) {             if (addr instanceof Inet4Address) foundV4 = true;             else if (addr instanceof Inet6Address) foundV6 = true;             if (DBG) Log.e(TAG, ""www.google.com gave "" + addr.toString());         }          // We should have at least one of the addresses to connect!         assertTrue(""www.google.com must have IPv4 and/or IPv6 address"", foundV4 || foundV6);          // Skip the rest of the test if the active network for watch is PROXY.         // TODO: Check NetworkInfo type in addition to type name once ag/601257 is merged.         if (getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)                 && activeNetworkInfoIsProxy()) {             Log.i(TAG, ""Skipping test because the active network type name is PROXY."");             return;         }          // Clear test state so we don't get confused with the previous results.         addrs = new InetAddress[0];         foundV4 = foundV6 = false;         try {             addrs = InetAddress.getAllByName(""ipv6.google.com"");         } catch (UnknownHostException e) {}         String msg =             ""[RERUN] DNS could not resolve ipv6.google.com, check the network supports IPv6. lp="" +             mCm.getActiveLinkProperties();         assertTrue(msg, addrs.length != 0);         for (InetAddress addr : addrs) {             msg = ""[RERUN] ipv6.google.com returned IPv4 address: "" + addr.getHostAddress() +                     "", check your network's DNS server. lp="" + mCm.getActiveLinkProperties();             assertFalse (msg, addr instanceof Inet4Address);             foundV6 |= (addr instanceof Inet6Address);             if (DBG) Log.e(TAG, ""ipv6.google.com gave "" + addr.toString());         }          assertTrue(foundV6);          assertTrue(testNativeDns());     }      private static final String[] URLS = { ""www.google.com"", ""ipv6.google.com"", ""www.yahoo.com"",             ""facebook.com"", ""youtube.com"", ""blogspot.com"", ""baidu.com"", ""wikipedia.org"", // live.com fails rev lookup.             ""twitter.com"", ""qq.com"", ""msn.com"", ""yahoo.co.jp"", ""linkedin.com"",             ""taobao.com"", ""google.co.in"", ""sina.com.cn"", ""amazon.com"", ""wordpress.com"",             ""google.co.uk"", ""ebay.com"", ""yandex.ru"", ""163.com"", ""google.co.jp"", ""google.fr"",             ""microsoft.com"", ""paypal.com"", ""google.com.br"", ""flickr.com"",             ""mail.ru"", ""craigslist.org"", ""fc2.com"", ""google.it"", // ""apple.com"", fails rev lookup             ""google.es"",             ""imdb.com"", ""google.ru"", ""soho.com"", ""bbc.co.uk"", ""vkontakte.ru"", ""ask.com"",             ""tumblr.com"", ""weibo.com"", ""go.com"", ""xvideos.com"", ""livejasmin.com"", ""cnn.com"",             ""youku.com"", ""blogspot.com"", ""soso.com"", ""google.ca"", ""aol.com"", ""tudou.com"",             ""xhamster.com"", ""megaupload.com"", ""ifeng.com"", ""zedo.com"", ""mediafire.com"", ""ameblo.jp"",             ""pornhub.com"", ""google.co.id"", ""godaddy.com"", ""adobe.com"", ""rakuten.co.jp"", ""about.com"",             ""espn.go.com"", ""4shared.com"", ""alibaba.com"",""ebay.de"", ""yieldmanager.com"",             ""wordpress.org"", ""livejournal.com"", ""google.com.tr"", ""google.com.mx"", ""renren.com"",            ""livedoor.com"", ""google.com.au"", ""youporn.com"", ""uol.com.br"", ""cnet.com"", ""conduit.com"",             ""google.pl"", ""myspace.com"", ""nytimes.com"", ""ebay.co.uk"", ""chinaz.com"", ""hao123.com"",             ""thepiratebay.org"", ""doubleclick.com"", ""alipay.com"", ""netflix.com"", ""cnzz.com"",             ""huffingtonpost.com"", ""twitpic.com"", ""weather.com"", ""babylon.com"", ""amazon.de"",             ""dailymotion.com"", ""orkut.com"", ""orkut.com.br"", ""google.com.sa"", ""odnoklassniki.ru"",             ""amazon.co.jp"", ""google.nl"", ""goo.ne.jp"", ""stumbleupon.com"", ""tube8.com"", ""tmall.com"",             ""imgur.com"", ""globo.com"", ""secureserver.net"", ""fileserve.com"", ""tianya.cn"", ""badoo.com"",             ""ehow.com"", ""photobucket.com"", ""imageshack.us"", ""xnxx.com"", ""deviantart.com"",             ""filestube.com"", ""addthis.com"", ""douban.com"", ""vimeo.com"", ""sogou.com"",             ""stackoverflow.com"", ""reddit.com"", ""dailymail.co.uk"", ""redtube.com"", ""megavideo.com"",             ""taringa.net"", ""pengyou.com"", ""amazon.co.uk"", ""fbcdn.net"", ""aweber.com"", ""spiegel.de"",             ""rapidshare.com"", ""mixi.jp"", ""360buy.com"", ""google.cn"", ""digg.com"", ""answers.com"",             ""bit.ly"", ""indiatimes.com"", ""skype.com"", ""yfrog.com"", ""optmd.com"", ""google.com.eg"",             ""google.com.pk"", ""58.com"", ""hotfile.com"", ""google.co.th"",             ""bankofamerica.com"", ""sourceforge.net"", ""maktoob.com"", ""warriorforum.com"", ""rediff.com"",             ""google.co.za"", ""56.com"", ""torrentz.eu"", ""clicksor.com"", ""avg.com"",             ""download.com"", ""ku6.com"", ""statcounter.com"", ""foxnews.com"", ""google.com.ar"",             ""nicovideo.jp"", ""reference.com"", ""liveinternet.ru"", ""ucoz.ru"", ""xinhuanet.com"",             ""xtendmedia.com"", ""naver.com"", ""youjizz.com"", ""domaintools.com"", ""sparkstudios.com"",             ""rambler.ru"", ""scribd.com"", ""kaixin001.com"", ""mashable.com"", ""adultfirendfinder.com"",             ""files.wordpress.com"", ""guardian.co.uk"", ""bild.de"", ""yelp.com"", ""wikimedia.org"",             ""chase.com"", ""onet.pl"", ""ameba.jp"", ""pconline.com.cn"", ""free.fr"", ""etsy.com"",             ""typepad.com"", ""youdao.com"", ""megaclick.com"", ""digitalpoint.com"", ""blogfa.com"",             ""salesforce.com"", ""adf.ly"", ""ganji.com"", ""wikia.com"", ""archive.org"", ""terra.com.br"",             ""w3schools.com"", ""ezinearticles.com"", ""wjs.com"", ""google.com.my"", ""clickbank.com"",             ""squidoo.com"", ""hulu.com"", ""repubblica.it"", ""google.be"", ""allegro.pl"", ""comcast.net"",             ""narod.ru"", ""zol.com.cn"", ""orange.fr"", ""soufun.com"", ""hatena.ne.jp"", ""google.gr"",             ""in.com"", ""techcrunch.com"", ""orkut.co.in"", ""xunlei.com"",             ""reuters.com"", ""google.com.vn"", ""hostgator.com"", ""kaskus.us"", ""espncricinfo.com"",             ""hootsuite.com"", ""qiyi.com"", ""gmx.net"", ""xing.com"", ""php.net"", ""soku.com"", ""web.de"",             ""libero.it"", ""groupon.com"", ""51.la"", ""slideshare.net"", ""booking.com"", ""seesaa.net"",             ""126.com"", ""telegraph.co.uk"", ""wretch.cc"", ""twimg.com"", ""rutracker.org"", ""angege.com"",             ""nba.com"", ""dell.com"", ""leboncoin.fr"", ""people.com"", ""google.com.tw"", ""walmart.com"",             ""daum.net"", ""2ch.net"", ""constantcontact.com"", ""nifty.com"", ""mywebsearch.com"",             ""tripadvisor.com"", ""google.se"", ""paipai.com"", ""google.com.ua"", ""ning.com"", ""hp.com"",             ""google.at"", ""joomla.org"", ""icio.us"", ""hudong.com"", ""csdn.net"", ""getfirebug.com"",             ""ups.com"", ""cj.com"", ""google.ch"", ""camzap.com"", ""wordreference.com"", ""tagged.com"",             ""wp.pl"", ""mozilla.com"", ""google.ru"", ""usps.com"", ""china.com"", ""themeforest.net"",             ""search-results.com"", ""tribalfusion.com"", ""thefreedictionary.com"", ""isohunt.com"",             ""linkwithin.com"", ""cam4.com"", ""plentyoffish.com"", ""wellsfargo.com"", ""metacafe.com"",             ""depositfiles.com"", ""freelancer.com"", ""opendns.com"", ""homeway.com"", ""engadget.com"",             ""10086.cn"", ""360.cn"", ""marca.com"", ""dropbox.com"", ""ign.com"", ""match.com"", ""google.pt"",             ""facemoods.com"", ""hardsextube.com"", ""google.com.ph"", ""lockerz.com"", ""istockphoto.com"",             ""partypoker.com"", ""netlog.com"", ""outbrain.com"", ""elpais.com"", ""fiverr.com"",             ""biglobe.ne.jp"", ""corriere.it"", ""love21cn.com"", ""yesky.com"", ""spankwire.com"",             ""ig.com.br"", ""imagevenue.com"", ""hubpages.com"", ""google.co.ve""};  // TODO - this works, but is slow and cts doesn't do anything with the result. // Maybe require a min performance, a min cache size (detectable) and/or move // to perf testing     private static final int LOOKUP_COUNT_GOAL = URLS.length;     public void skiptestDnsPerf() {         ArrayList<String> results = new ArrayList<String>();         int failures = 0;         try {             for (int numberOfUrls = URLS.length; numberOfUrls > 0; numberOfUrls--) {                 failures = 0;                 int iterationLimit = LOOKUP_COUNT_GOAL / numberOfUrls;                 long startTime = SystemClock.elapsedRealtimeNanos();                 for (int iteration = 0; iteration < iterationLimit; iteration++) {                     for (int urlIndex = 0; urlIndex < numberOfUrls; urlIndex++) {                         try {                             InetAddress addr = InetAddress.getByName(URLS[urlIndex]);                         } catch (UnknownHostException e) {                             Log.e(TAG, ""failed first lookup of "" + URLS[urlIndex]);                             failures++;                             try {                                 InetAddress addr = InetAddress.getByName(URLS[urlIndex]);                             } catch (UnknownHostException ee) {                                 failures++;                                 Log.e(TAG, ""failed SECOND lookup of "" + URLS[urlIndex]);                             }                         }                     }                 }                 long endTime = SystemClock.elapsedRealtimeNanos();                 float nsPer = ((float)(endTime-startTime) / iterationLimit) / numberOfUrls/ 1000;                 String thisResult = new String(""getByName for "" + numberOfUrls + "" took "" +                         (endTime - startTime)/1000 + ""("" + nsPer + "") with "" +                         failures + "" failures\n"");                 Log.d(TAG, thisResult);                 results.add(thisResult);             }             // build up a list of addresses             ArrayList<byte[]> addressList = new ArrayList<byte[]>();             for (String url : URLS) {                 try {                     InetAddress addr = InetAddress.getByName(url);                     addressList.add(addr.getAddress());                 } catch (UnknownHostException e) {                     Log.e(TAG, ""Exception making reverseDNS list: "" + e.toString());                 }             }             for (int numberOfAddrs = addressList.size(); numberOfAddrs > 0; numberOfAddrs--) {                 int iterationLimit = LOOKUP_COUNT_GOAL / numberOfAddrs;                 failures = 0;                 long startTime = SystemClock.elapsedRealtimeNanos();                 for (int iteration = 0; iteration < iterationLimit; iteration++) {                     for (int addrIndex = 0; addrIndex < numberOfAddrs; addrIndex++) {                         try {                             InetAddress addr = InetAddress.getByAddress(addressList.get(addrIndex));                             String hostname = addr.getHostName();                         } catch (UnknownHostException e) {                             failures++;                             Log.e(TAG, ""Failure doing reverse DNS lookup: "" + e.toString());                             try {                                 InetAddress addr =                                         InetAddress.getByAddress(addressList.get(addrIndex));                                 String hostname = addr.getHostName();                              } catch (UnknownHostException ee) {                                 failures++;                                 Log.e(TAG, ""Failure doing SECOND reverse DNS lookup: "" +                                         ee.toString());                             }                         }                     }                 }                 long endTime = SystemClock.elapsedRealtimeNanos();                 float nsPer = ((endTime-startTime) / iterationLimit) / numberOfAddrs / 1000;                 String thisResult = new String(""getHostName for "" + numberOfAddrs + "" took "" +                         (endTime - startTime)/1000 + ""("" + nsPer + "") with "" +                         failures + "" failures\n"");                 Log.d(TAG, thisResult);                 results.add(thisResult);             }             for (String result : results) Log.d(TAG, result);              InetAddress exit = InetAddress.getByName(""exitrightnow.com"");             Log.e(TAG, "" exit address= ""+exit.toString());          } catch (Exception e) {             Log.e(TAG, ""bad URL in testDnsPerf: "" + e.toString());         }     }      private boolean activeNetworkInfoIsProxy() {         NetworkInfo info = mCm.getActiveNetworkInfo();         if (PROXY_NETWORK_TYPE.equals(info.getTypeName())) {             return true;         }          return false;     }      private void ensureIpv6Connectivity() throws InterruptedException {         CountDownLatch latch = new CountDownLatch(1);         final int TIMEOUT_MS = 5_000;          final NetworkCallback callback = new NetworkCallback() {             @Override             public void onLinkPropertiesChanged(Network network, LinkProperties lp) {                 if (lp.hasGlobalIpv6Address()) {                     latch.countDown();                 }             }         };         mCm.registerDefaultNetworkCallback(callback);          String msg = ""Default network did not provide IPv6 connectivity after "" + TIMEOUT_MS                 + ""ms. Please connect to an IPv6-capable network. lp=""                 + mCm.getActiveLinkProperties();         try {             assertTrue(msg, latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));         } finally {             mCm.unregisterNetworkCallback(callback);         }     } }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.media.cts.SoundPoolTest"	"testAutoPauseResume"	"CtsMediaTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"simultaneously"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/SoundPoolTest.java"	""	"public void testAutoPauseResume() throws Exception {         // The number of possible SoundPool streams simultaneously active is limited by         // track resources. Generally this is no greater than 32, but the actual         // amount may be less depending on concurrently running applications.         // Here we attempt to create more streams than what is normally possible;         // SoundPool should gracefully degrade to play those streams it can.         //         // Try to keep the maxStreams less than the number required to be active         // and certainly less than 20 to be cooperative to other applications.         final int TEST_STREAMS = 40;         SoundPool soundPool = null;         try {             soundPool = new SoundPool.Builder()                     .setAudioAttributes(getAudioAttributes())                     .setMaxStreams(TEST_STREAMS)                     .build();              // get our sounds             final int[] sounds = getSounds();              // set our completion listener             final int[] loadIds = new int[TEST_STREAMS];             final Object done = new Object();             final int[] loaded = new int[1]; // used as a ""pointer"" to an integer             final SoundPool fpool = soundPool; // final reference in scope of try block             soundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() {                     @Override                     public void onLoadComplete(SoundPool pool, int sampleId, int status) {                         assertEquals(fpool, pool);                         assertEquals(0 /* success */, status);                         synchronized(done) {                             loadIds[loaded[0]++] = sampleId;                             if (loaded[0] == loadIds.length) {                                 done.notify();                             }                         }                     }                 });              // initiate loading             final int[] soundIds = new int[TEST_STREAMS];             for (int i = 0; i < soundIds.length; i++) {                 soundIds[i] = soundPool.load(mContext, sounds[i % sounds.length], PRIORITY);             }              // wait for all sounds to load,             // it usually takes about 33 seconds and 100 seconds is used to have some headroom.             final long LOAD_TIMEOUT_IN_MS = 100000;             final long startTime = System.currentTimeMillis();             synchronized(done) {                 while (loaded[0] != soundIds.length) {                     final long waitTime =                             LOAD_TIMEOUT_IN_MS - (System.currentTimeMillis() - startTime);                     assertTrue(waitTime > 0);                     done.wait(waitTime);                 }             }              // verify the Ids match (actually does sorting too)             Arrays.sort(loadIds);             Arrays.sort(soundIds);             assertTrue(Arrays.equals(loadIds, soundIds));              // play - should hear the following:             // 1 second of sound             // 1 second of silence             // 1 second of sound.             int[] streamIds = new int[soundIds.length];             for (int i = 0; i < soundIds.length; i++) {                 streamIds[i] = soundPool.play(soundIds[i],                         0.5f /* leftVolume */, 0.5f /* rightVolume */, PRIORITY,                         -1 /* loop (infinite) */, 1.0f /* rate */);             }             Thread.sleep(1000 /* millis */);             soundPool.autoPause();             Thread.sleep(1000 /* millis */);             soundPool.autoResume();             Thread.sleep(1000 /* millis */);              // clean up             for (int stream : streamIds) {                 assertTrue(stream != 0);                 soundPool.stop(stream);             }             for (int sound : soundIds) {                 assertEquals(true, soundPool.unload(sound));             }             // check to see we're really unloaded             for (int sound : soundIds) {                 assertEquals(false, soundPool.unload(sound));             }         } finally {             if (soundPool != null) {                 soundPool.release();                 soundPool = null;             }         }     }      /**      * Load a sample and wait until it is ready to be played.      * @return The sample ID.      * @throws InterruptedException      */     private int loadSampleSync(int sampleId, int prio) throws InterruptedException {         int sample = mSoundPool.load(mContext, sampleId, prio);         waitUntilLoaded(sample);         return sample;     }      /**      * Wait until the specified sample is loaded.      * @param sampleId The sample ID.      * @throws InterruptedException      */     private void waitUntilLoaded(int sampleId) throws InterruptedException {         int stream = 0;         while (stream == 0) {             Thread.sleep(500);             stream = mSoundPool.play(sampleId, SILENT, SILENT, 1, 0, 1);         }         mSoundPool.stop(stream);     } }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.MacAddressTest"	"testLinkLocalFromMacGeneration"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/MacAddressTest.java"	""	"public void testLinkLocalFromMacGeneration() {         final MacAddress mac = MacAddress.fromString(""52:74:f2:b1:a8:7f"");         final byte[] inet6ll = {(byte) 0xfe, (byte) 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50,                 0x74, (byte) 0xf2, (byte) 0xff, (byte) 0xfe, (byte) 0xb1, (byte) 0xa8, 0x7f};         final Inet6Address llv6 = mac.getLinkLocalIpv6FromEui48Mac();         assertTrue(llv6.isLinkLocalAddress());         assertArrayEquals(inet6ll, llv6.getAddress());     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTunnelTest"	"testSecurityExceptionCreateTunnelInterfaceWithoutAppop"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTunnelTest.java"	""	"public void testSecurityExceptionCreateTunnelInterfaceWithoutAppop() throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          // Ensure we don't have the appop. Permission is not requested in the Manifest         mCtsNetUtils.setAppopPrivileged(OP_MANAGE_IPSEC_TUNNELS, false);          // Security exceptions are thrown regardless of IPv4/IPv6. Just test one         try {             mISM.createIpSecTunnelInterface(LOCAL_INNER_6, REMOTE_INNER_6, sTunNetwork);             fail(""Did not throw SecurityException for Tunnel creation without appop"");         } catch (SecurityException expected) {         }     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTunnelTest"	"testSecurityExceptionBuildTunnelTransformWithoutAppop"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTunnelTest.java"	""	"public void testSecurityExceptionBuildTunnelTransformWithoutAppop() throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          // Ensure we don't have the appop. Permission is not requested in the Manifest         mCtsNetUtils.setAppopPrivileged(OP_MANAGE_IPSEC_TUNNELS, false);          // Security exceptions are thrown regardless of IPv4/IPv6. Just test one         try (IpSecManager.SecurityParameterIndex spi =                         mISM.allocateSecurityParameterIndex(LOCAL_INNER_4);                 IpSecTransform transform =                         new IpSecTransform.Builder(sContext)                                 .buildTunnelModeTransform(REMOTE_INNER_4, spi)) {             fail(""Did not throw SecurityException for Transform creation without appop"");         } catch (SecurityException expected) {         }     }      /* Test runnables for callbacks after IPsec tunnels are set up. */     private abstract class IpSecTunnelTestRunnable {         /**          * Runs the test code, and returns the inner socket port, if any.          *          * @param ipsecNetwork The IPsec Interface based Network for binding sockets on          * @return the integer port of the inner socket if outbound, or 0 if inbound          *     IpSecTunnelTestRunnable          * @throws Exception if any part of the test failed.          */         public abstract int run(Network ipsecNetwork) throws Exception;     }      private int getPacketSize(             int innerFamily, int outerFamily, boolean useEncap, boolean transportInTunnelMode) {         int expectedPacketSize = TEST_DATA.length + UDP_HDRLEN;          // Inner Transport mode packet size         if (transportInTunnelMode) {             expectedPacketSize =                     PacketUtils.calculateEspPacketSize(                             expectedPacketSize,                             AES_CBC_IV_LEN,                             AES_CBC_BLK_SIZE,                             AUTH_KEY.length * 4);         }          // Inner IP Header         expectedPacketSize += innerFamily == AF_INET ? IP4_HDRLEN : IP6_HDRLEN;          // Tunnel mode transform size         expectedPacketSize =                 PacketUtils.calculateEspPacketSize(                         expectedPacketSize, AES_CBC_IV_LEN, AES_CBC_BLK_SIZE, AUTH_KEY.length * 4);          // UDP encap size         expectedPacketSize += useEncap ? UDP_HDRLEN : 0;          // Outer IP Header         expectedPacketSize += outerFamily == AF_INET ? IP4_HDRLEN : IP6_HDRLEN;          return expectedPacketSize;     }      private interface IpSecTunnelTestRunnableFactory {         IpSecTunnelTestRunnable getIpSecTunnelTestRunnable(                 boolean transportInTunnelMode,                 int spi,                 InetAddress localInner,                 InetAddress remoteInner,                 InetAddress localOuter,                 InetAddress remoteOuter,                 IpSecTransform inTransportTransform,                 IpSecTransform outTransportTransform,                 int encapPort,                 int innerSocketPort,                 int expectedPacketSize)                 throws Exception;     }      private class OutputIpSecTunnelTestRunnableFactory implements IpSecTunnelTestRunnableFactory {         public IpSecTunnelTestRunnable getIpSecTunnelTestRunnable(                 boolean transportInTunnelMode,                 int spi,                 InetAddress localInner,                 InetAddress remoteInner,                 InetAddress localOuter,                 InetAddress remoteOuter,                 IpSecTransform inTransportTransform,                 IpSecTransform outTransportTransform,                 int encapPort,                 int unusedInnerSocketPort,                 int expectedPacketSize) {             return new IpSecTunnelTestRunnable() {                 @Override                 public int run(Network ipsecNetwork) throws Exception {                     // Build a socket and send traffic                     JavaUdpSocket socket = new JavaUdpSocket(localInner);                     ipsecNetwork.bindSocket(socket.mSocket);                     int innerSocketPort = socket.getPort();                      // For Transport-In-Tunnel mode, apply transform to socket                     if (transportInTunnelMode) {                         mISM.applyTransportModeTransform(                                 socket.mSocket, IpSecManager.DIRECTION_IN, inTransportTransform);                         mISM.applyTransportModeTransform(                                 socket.mSocket, IpSecManager.DIRECTION_OUT, outTransportTransform);                     }                      socket.sendTo(TEST_DATA, remoteInner, socket.getPort());                      // Verify that an encrypted packet is sent. As of right now, checking encrypted                     // body is not possible, due to the test not knowing some of the fields of the                     // inner IP header (flow label, flags, etc)                     sTunUtils.awaitEspPacketNoPlaintext(                             spi, TEST_DATA, encapPort != 0, expectedPacketSize);                      socket.close();                      return innerSocketPort;                 }             };         }     }      private class InputReflectedIpSecTunnelTestRunnableFactory             implements IpSecTunnelTestRunnableFactory {         public IpSecTunnelTestRunnable getIpSecTunnelTestRunnable(                 boolean transportInTunnelMode,                 int spi,                 InetAddress localInner,                 InetAddress remoteInner,                 InetAddress localOuter,                 InetAddress remoteOuter,                 IpSecTransform inTransportTransform,                 IpSecTransform outTransportTransform,                 int encapPort,                 int innerSocketPort,                 int expectedPacketSize)                 throws Exception {             return new IpSecTunnelTestRunnable() {                 @Override                 public int run(Network ipsecNetwork) throws Exception {                     // Build a socket and receive traffic                     JavaUdpSocket socket = new JavaUdpSocket(localInner, innerSocketPort);                     ipsecNetwork.bindSocket(socket.mSocket);                      // For Transport-In-Tunnel mode, apply transform to socket                     if (transportInTunnelMode) {                         mISM.applyTransportModeTransform(                                 socket.mSocket, IpSecManager.DIRECTION_IN, outTransportTransform);                         mISM.applyTransportModeTransform(                                 socket.mSocket, IpSecManager.DIRECTION_OUT, inTransportTransform);                     }                      sTunUtils.reflectPackets();                      // Receive packet from socket, and validate that the payload is correct                     receiveAndValidatePacket(socket);                      socket.close();                      return 0;                 }             };         }     }      private class InputPacketGeneratorIpSecTunnelTestRunnableFactory             implements IpSecTunnelTestRunnableFactory {         public IpSecTunnelTestRunnable getIpSecTunnelTestRunnable(                 boolean transportInTunnelMode,                 int spi,                 InetAddress localInner,                 InetAddress remoteInner,                 InetAddress localOuter,                 InetAddress remoteOuter,                 IpSecTransform inTransportTransform,                 IpSecTransform outTransportTransform,                 int encapPort,                 int innerSocketPort,                 int expectedPacketSize)                 throws Exception {             return new IpSecTunnelTestRunnable() {                 @Override                 public int run(Network ipsecNetwork) throws Exception {                     // Build a socket and receive traffic                     JavaUdpSocket socket = new JavaUdpSocket(localInner);                     ipsecNetwork.bindSocket(socket.mSocket);                      // For Transport-In-Tunnel mode, apply transform to socket                     if (transportInTunnelMode) {                         mISM.applyTransportModeTransform(                                 socket.mSocket, IpSecManager.DIRECTION_IN, outTransportTransform);                         mISM.applyTransportModeTransform(                                 socket.mSocket, IpSecManager.DIRECTION_OUT, inTransportTransform);                     }                      byte[] pkt;                     if (transportInTunnelMode) {                         pkt =                                 getTransportInTunnelModePacket(                                         spi,                                         spi,                                         remoteInner,                                         localInner,                                         remoteOuter,                                         localOuter,                                         socket.getPort(),                                         encapPort);                     } else {                         pkt =                                 getTunnelModePacket(                                         spi,                                         remoteInner,                                         localInner,                                         remoteOuter,                                         localOuter,                                         socket.getPort(),                                         encapPort);                     }                     sTunUtils.injectPacket(pkt);                      // Receive packet from socket, and validate                     receiveAndValidatePacket(socket);                      socket.close();                      return 0;                 }             };         }     }      private void checkTunnelOutput(             int innerFamily, int outerFamily, boolean useEncap, boolean transportInTunnelMode)             throws Exception {         checkTunnel(                 innerFamily,                 outerFamily,                 useEncap,                 transportInTunnelMode,                 new OutputIpSecTunnelTestRunnableFactory());     }      private void checkTunnelInput(             int innerFamily, int outerFamily, boolean useEncap, boolean transportInTunnelMode)             throws Exception {         checkTunnel(                 innerFamily,                 outerFamily,                 useEncap,                 transportInTunnelMode,                 new InputPacketGeneratorIpSecTunnelTestRunnableFactory());     }      /**      * Validates that the kernel can talk to itself.      *      * <p>This test takes an outbound IPsec packet, reflects it (by flipping IP src/dst), and      * injects it back into the TUN. This test then verifies that a packet with the correct payload      * is found on the specified socket/port.      */     public void checkTunnelReflected(             int innerFamily, int outerFamily, boolean useEncap, boolean transportInTunnelMode)             throws Exception {         InetAddress localInner = innerFamily == AF_INET ? LOCAL_INNER_4 : LOCAL_INNER_6;         InetAddress remoteInner = innerFamily == AF_INET ? REMOTE_INNER_4 : REMOTE_INNER_6;          InetAddress localOuter = outerFamily == AF_INET ? LOCAL_OUTER_4 : LOCAL_OUTER_6;         InetAddress remoteOuter = outerFamily == AF_INET ? REMOTE_OUTER_4 : REMOTE_OUTER_6;          // Preselect both SPI and encap port, to be used for both inbound and outbound tunnels.         int spi = getRandomSpi(localOuter, remoteOuter);         int expectedPacketSize =                 getPacketSize(innerFamily, outerFamily, useEncap, transportInTunnelMode);          try (IpSecManager.SecurityParameterIndex inTransportSpi =                         mISM.allocateSecurityParameterIndex(localInner, spi);                 IpSecManager.SecurityParameterIndex outTransportSpi =                         mISM.allocateSecurityParameterIndex(remoteInner, spi);                 IpSecTransform inTransportTransform =                         buildIpSecTransform(sContext, inTransportSpi, null, remoteInner);                 IpSecTransform outTransportTransform =                         buildIpSecTransform(sContext, outTransportSpi, null, localInner);                 UdpEncapsulationSocket encapSocket = mISM.openUdpEncapsulationSocket()) {              // Run output direction tests             IpSecTunnelTestRunnable outputIpSecTunnelTestRunnable =                     new OutputIpSecTunnelTestRunnableFactory()                             .getIpSecTunnelTestRunnable(                                     transportInTunnelMode,                                     spi,                                     localInner,                                     remoteInner,                                     localOuter,                                     remoteOuter,                                     inTransportTransform,                                     outTransportTransform,                                     useEncap ? encapSocket.getPort() : 0,                                     0,                                     expectedPacketSize);             int innerSocketPort =                     buildTunnelNetworkAndRunTests(                     localInner,                     remoteInner,                     localOuter,                     remoteOuter,                     spi,                     useEncap ? encapSocket : null,                     outputIpSecTunnelTestRunnable);              // Input direction tests, with matching inner socket ports.             IpSecTunnelTestRunnable inputIpSecTunnelTestRunnable =                     new InputReflectedIpSecTunnelTestRunnableFactory()                             .getIpSecTunnelTestRunnable(                                     transportInTunnelMode,                                     spi,                                     remoteInner,                                     localInner,                                     localOuter,                                     remoteOuter,                                     inTransportTransform,                                     outTransportTransform,                                     useEncap ? encapSocket.getPort() : 0,                                     innerSocketPort,                                     expectedPacketSize);             buildTunnelNetworkAndRunTests(                     remoteInner,                     localInner,                     localOuter,                     remoteOuter,                     spi,                     useEncap ? encapSocket : null,                     inputIpSecTunnelTestRunnable);         }     }      public void checkTunnel(             int innerFamily,             int outerFamily,             boolean useEncap,             boolean transportInTunnelMode,             IpSecTunnelTestRunnableFactory factory)             throws Exception {          InetAddress localInner = innerFamily == AF_INET ? LOCAL_INNER_4 : LOCAL_INNER_6;         InetAddress remoteInner = innerFamily == AF_INET ? REMOTE_INNER_4 : REMOTE_INNER_6;          InetAddress localOuter = outerFamily == AF_INET ? LOCAL_OUTER_4 : LOCAL_OUTER_6;         InetAddress remoteOuter = outerFamily == AF_INET ? REMOTE_OUTER_4 : REMOTE_OUTER_6;          // Preselect both SPI and encap port, to be used for both inbound and outbound tunnels.         // Re-uses the same SPI to ensure that even in cases of symmetric SPIs shared across tunnel         // and transport mode, packets are encrypted/decrypted properly based on the src/dst.         int spi = getRandomSpi(localOuter, remoteOuter);         int expectedPacketSize =                 getPacketSize(innerFamily, outerFamily, useEncap, transportInTunnelMode);          try (IpSecManager.SecurityParameterIndex inTransportSpi =                         mISM.allocateSecurityParameterIndex(localInner, spi);                 IpSecManager.SecurityParameterIndex outTransportSpi =                         mISM.allocateSecurityParameterIndex(remoteInner, spi);                 IpSecTransform inTransportTransform =                         buildIpSecTransform(sContext, inTransportSpi, null, remoteInner);                 IpSecTransform outTransportTransform =                         buildIpSecTransform(sContext, outTransportSpi, null, localInner);                 UdpEncapsulationSocket encapSocket = mISM.openUdpEncapsulationSocket()) {              buildTunnelNetworkAndRunTests(                     localInner,                     remoteInner,                     localOuter,                     remoteOuter,                     spi,                     useEncap ? encapSocket : null,                     factory.getIpSecTunnelTestRunnable(                             transportInTunnelMode,                             spi,                             localInner,                             remoteInner,                             localOuter,                             remoteOuter,                             inTransportTransform,                             outTransportTransform,                             useEncap ? encapSocket.getPort() : 0,                             0,                             expectedPacketSize));         }     }      private int buildTunnelNetworkAndRunTests(             InetAddress localInner,             InetAddress remoteInner,             InetAddress localOuter,             InetAddress remoteOuter,             int spi,             UdpEncapsulationSocket encapSocket,             IpSecTunnelTestRunnable test)             throws Exception {         int innerPrefixLen = localInner instanceof Inet6Address ? IP6_PREFIX_LEN : IP4_PREFIX_LEN;         TestNetworkCallback testNetworkCb = null;         int innerSocketPort;          try (IpSecManager.SecurityParameterIndex inSpi =                         mISM.allocateSecurityParameterIndex(localOuter, spi);                 IpSecManager.SecurityParameterIndex outSpi =                         mISM.allocateSecurityParameterIndex(remoteOuter, spi);                 IpSecManager.IpSecTunnelInterface tunnelIface =                         mISM.createIpSecTunnelInterface(localOuter, remoteOuter, sTunNetwork)) {             // Build the test network             tunnelIface.addAddress(localInner, innerPrefixLen);             testNetworkCb = mCtsNetUtils.setupAndGetTestNetwork(tunnelIface.getInterfaceName());             testNetworkCb.waitForAvailable();             Network testNetwork = testNetworkCb.currentNetwork;              // Check interface was created             assertNotNull(NetworkInterface.getByName(tunnelIface.getInterfaceName()));              // Verify address was added             final NetworkInterface netIface = NetworkInterface.getByInetAddress(localInner);             assertNotNull(netIface);             assertEquals(tunnelIface.getInterfaceName(), netIface.getDisplayName());              // Configure Transform parameters             IpSecTransform.Builder transformBuilder = new IpSecTransform.Builder(sContext);             transformBuilder.setEncryption(                     new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY));             transformBuilder.setAuthentication(                     new IpSecAlgorithm(                             IpSecAlgorithm.AUTH_HMAC_SHA256, AUTH_KEY, AUTH_KEY.length * 4));              if (encapSocket != null) {                 transformBuilder.setIpv4Encapsulation(encapSocket, encapSocket.getPort());             }              // Apply transform and check that traffic is properly encrypted             try (IpSecTransform inTransform =                             transformBuilder.buildTunnelModeTransform(remoteOuter, inSpi);                     IpSecTransform outTransform =                             transformBuilder.buildTunnelModeTransform(localOuter, outSpi)) {                 mISM.applyTunnelModeTransform(tunnelIface, IpSecManager.DIRECTION_IN, inTransform);                 mISM.applyTunnelModeTransform(                         tunnelIface, IpSecManager.DIRECTION_OUT, outTransform);                  innerSocketPort = test.run(testNetwork);             }              // Teardown the test network             sTNM.teardownTestNetwork(testNetwork);              // Remove addresses and check that interface is still present, but fails lookup-by-addr             tunnelIface.removeAddress(localInner, innerPrefixLen);             assertNotNull(NetworkInterface.getByName(tunnelIface.getInterfaceName()));             assertNull(NetworkInterface.getByInetAddress(localInner));              // Check interface was cleaned up             tunnelIface.close();             assertNull(NetworkInterface.getByName(tunnelIface.getInterfaceName()));         } finally {             if (testNetworkCb != null) {                 sCM.unregisterNetworkCallback(testNetworkCb);             }         }          return innerSocketPort;     }      private static void receiveAndValidatePacket(JavaUdpSocket socket) throws Exception {         byte[] socketResponseBytes = socket.receive();         assertArrayEquals(TEST_DATA, socketResponseBytes);     }      private int getRandomSpi(InetAddress localOuter, InetAddress remoteOuter) throws Exception {         // Try to allocate both in and out SPIs using the same requested SPI value.         try (IpSecManager.SecurityParameterIndex inSpi =                         mISM.allocateSecurityParameterIndex(localOuter);                 IpSecManager.SecurityParameterIndex outSpi =                         mISM.allocateSecurityParameterIndex(remoteOuter, inSpi.getSpi()); ) {             return inSpi.getSpi();         }     }      private EspHeader buildTransportModeEspPacket(             int spi, InetAddress src, InetAddress dst, int port, Payload payload) throws Exception {         IpHeader preEspIpHeader = getIpHeader(payload.getProtocolId(), src, dst, payload);          return new EspHeader(                 payload.getProtocolId(),                 spi,                 1, // sequence number                 CRYPT_KEY, // Same key for auth and crypt                 payload.getPacketBytes(preEspIpHeader));     }      private EspHeader buildTunnelModeEspPacket(             int spi,             InetAddress srcInner,             InetAddress dstInner,             InetAddress srcOuter,             InetAddress dstOuter,             int port,             int encapPort,             Payload payload)             throws Exception {         IpHeader innerIp = getIpHeader(payload.getProtocolId(), srcInner, dstInner, payload);         return new EspHeader(                 innerIp.getProtocolId(),                 spi,                 1, // sequence number                 CRYPT_KEY, // Same key for auth and crypt                 innerIp.getPacketBytes());     }      private IpHeader maybeEncapPacket(             InetAddress src, InetAddress dst, int encapPort, EspHeader espPayload)             throws Exception {          Payload payload = espPayload;         if (encapPort != 0) {             payload = new UdpHeader(encapPort, encapPort, espPayload);         }          return getIpHeader(payload.getProtocolId(), src, dst, payload);     }      private byte[] getTunnelModePacket(             int spi,             InetAddress srcInner,             InetAddress dstInner,             InetAddress srcOuter,             InetAddress dstOuter,             int port,             int encapPort)             throws Exception {         UdpHeader udp = new UdpHeader(port, port, new BytePayload(TEST_DATA));          EspHeader espPayload =                 buildTunnelModeEspPacket(                         spi, srcInner, dstInner, srcOuter, dstOuter, port, encapPort, udp);         return maybeEncapPacket(srcOuter, dstOuter, encapPort, espPayload).getPacketBytes();     }      private byte[] getTransportInTunnelModePacket(             int spiInner,             int spiOuter,             InetAddress srcInner,             InetAddress dstInner,             InetAddress srcOuter,             InetAddress dstOuter,             int port,             int encapPort)             throws Exception {         UdpHeader udp = new UdpHeader(port, port, new BytePayload(TEST_DATA));          EspHeader espPayload = buildTransportModeEspPacket(spiInner, srcInner, dstInner, port, udp);         espPayload =                 buildTunnelModeEspPacket(                         spiOuter,                         srcInner,                         dstInner,                         srcOuter,                         dstOuter,                         port,                         encapPort,                         espPayload);         return maybeEncapPacket(srcOuter, dstOuter, encapPort, espPayload).getPacketBytes();     }      // Transport-in-Tunnel mode tests"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecBaseTest"	"currentTimeMillis"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecBaseTest.java"	""	"/*  *.  */  package android.net.cts;  import static org.junit.Assert.assertArrayEquals;  import android.content.Context; import android.net.ConnectivityManager; import android.net.IpSecAlgorithm; import android.net.IpSecManager; import android.net.IpSecTransform; import android.platform.test.annotations.AppModeFull; import android.system.Os; import android.system.OsConstants; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import java.io.FileDescriptor; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.Inet6Address; import java.net.InetAddress; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; import java.net.SocketException; import java.util.Arrays; import java.util.concurrent.atomic.AtomicInteger;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  @RunWith(AndroidJUnit4.class) public class IpSecBaseTest {      private static final String TAG = IpSecBaseTest.class.getSimpleName();      protected static final String IPV4_LOOPBACK = ""127.0.0.1"";     protected static final String IPV6_LOOPBACK = ""::1"";     protected static final String[] LOOPBACK_ADDRS = new String[] {IPV4_LOOPBACK, IPV6_LOOPBACK};     protected static final int[] DIRECTIONS =             new int[] {IpSecManager.DIRECTION_IN, IpSecManager.DIRECTION_OUT};      protected static final byte[] TEST_DATA = ""Best test data ever!"".getBytes();     protected static final int DATA_BUFFER_LEN = 4096;     protected static final int SOCK_TIMEOUT = 500;      private static final byte[] KEY_DATA = {         0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,         0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,         0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,         0x20, 0x21, 0x22, 0x23     };      protected static final byte[] AUTH_KEY = getKey(256);     protected static final byte[] CRYPT_KEY = getKey(256);      protected ConnectivityManager mCM;     protected IpSecManager mISM;      @Before     public void setUp() throws Exception {         mISM =                 (IpSecManager)                         InstrumentationRegistry.getContext()                                 .getSystemService(Context.IPSEC_SERVICE);         mCM =                 (ConnectivityManager)                         InstrumentationRegistry.getContext()                                 .getSystemService(Context.CONNECTIVITY_SERVICE);     }      protected static byte[] getKey(int bitLength) {         return Arrays.copyOf(KEY_DATA, bitLength / 8);     }      protected static int getDomain(InetAddress address) {         int domain;         if (address instanceof Inet6Address) {             domain = OsConstants.AF_INET6;         } else {             domain = OsConstants.AF_INET;         }         return domain;     }      protected static int getPort(FileDescriptor sock) throws Exception {         return ((InetSocketAddress) Os.getsockname(sock)).getPort();     }      public static interface GenericSocket extends AutoCloseable {         void send(byte[] data) throws Exception;          byte[] receive() throws Exception;          int getPort() throws Exception;          void close() throws Exception;          void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception;          void removeTransportModeTransforms(IpSecManager ism) throws Exception;     }      public static interface GenericTcpSocket extends GenericSocket {}      public static interface GenericUdpSocket extends GenericSocket {         void sendTo(byte[] data, InetAddress dstAddr, int port) throws Exception;     }      public abstract static class NativeSocket implements GenericSocket {         public FileDescriptor mFd;          public NativeSocket(FileDescriptor fd) {             mFd = fd;         }          @Override         public void send(byte[] data) throws Exception {             Os.write(mFd, data, 0, data.length);         }          @Override         public byte[] receive() throws Exception {             byte[] in = new byte[DATA_BUFFER_LEN];             AtomicInteger bytesRead = new AtomicInteger(-1);              Thread readSockThread = new Thread(() -> {                 long startTime = System.currentTimeMillis();                 while (bytesRead.get() < 0 && System.currentTimeMillis() < startTime + SOCK_TIMEOUT) {                     try {                         bytesRead.set(Os.recvfrom(mFd, in, 0, DATA_BUFFER_LEN, 0, null));                     } catch (Exception e) {                         Log.e(TAG, ""Error encountered reading from socket"", e);                     }                 }             });              readSockThread.start();             readSockThread.join(SOCK_TIMEOUT);              if (bytesRead.get() < 0) {                 throw new IOException(""No data received from socket"");             }              return Arrays.copyOfRange(in, 0, bytesRead.get());         }          @Override         public int getPort() throws Exception {             return IpSecBaseTest.getPort(mFd);         }          @Override         public void close() throws Exception {             Os.close(mFd);         }          @Override         public void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception {             ism.applyTransportModeTransform(mFd, direction, transform);         }          @Override         public void removeTransportModeTransforms(IpSecManager ism) throws Exception {             ism.removeTransportModeTransforms(mFd);         }     }      public static class NativeTcpSocket extends NativeSocket implements GenericTcpSocket {         public NativeTcpSocket(FileDescriptor fd) {             super(fd);         }     }      public static class NativeUdpSocket extends NativeSocket implements GenericUdpSocket {         public NativeUdpSocket(FileDescriptor fd) {             super(fd);         }          @Override         public void sendTo(byte[] data, InetAddress dstAddr, int port) throws Exception {             Os.sendto(mFd, data, 0, data.length, 0, dstAddr, port);         }     }      public static class JavaUdpSocket implements GenericUdpSocket {         public final DatagramSocket mSocket;          public JavaUdpSocket(InetAddress localAddr, int port) {             try {                 mSocket = new DatagramSocket(port, localAddr);                 mSocket.setSoTimeout(SOCK_TIMEOUT);             } catch (SocketException e) {                 // Fail loudly if we can't set up sockets properly. And without the timeout, we                 // could easily end up in an endless wait.                 throw new RuntimeException(e);             }         }          public JavaUdpSocket(InetAddress localAddr) {             try {                 mSocket = new DatagramSocket(0, localAddr);                 mSocket.setSoTimeout(SOCK_TIMEOUT);             } catch (SocketException e) {                 // Fail loudly if we can't set up sockets properly. And without the timeout, we                 // could easily end up in an endless wait.                 throw new RuntimeException(e);             }         }          @Override         public void send(byte[] data) throws Exception {             mSocket.send(new DatagramPacket(data, data.length));         }          @Override         public void sendTo(byte[] data, InetAddress dstAddr, int port) throws Exception {             mSocket.send(new DatagramPacket(data, data.length, dstAddr, port));         }          @Override         public int getPort() throws Exception {             return mSocket.getLocalPort();         }          @Override         public void close() throws Exception {             mSocket.close();         }          @Override         public byte[] receive() throws Exception {             DatagramPacket data = new DatagramPacket(new byte[DATA_BUFFER_LEN], DATA_BUFFER_LEN);             mSocket.receive(data);             return Arrays.copyOfRange(data.getData(), 0, data.getLength());         }          @Override         public void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception {             ism.applyTransportModeTransform(mSocket, direction, transform);         }          @Override         public void removeTransportModeTransforms(IpSecManager ism) throws Exception {             ism.removeTransportModeTransforms(mSocket);         }     }      public static class JavaTcpSocket implements GenericTcpSocket {         public final Socket mSocket;          public JavaTcpSocket(Socket socket) {             mSocket = socket;             try {                 mSocket.setSoTimeout(SOCK_TIMEOUT);             } catch (SocketException e) {                 // Fail loudly if we can't set up sockets properly. And without the timeout, we                 // could easily end up in an endless wait.                 throw new RuntimeException(e);             }         }          @Override         public void send(byte[] data) throws Exception {             mSocket.getOutputStream().write(data);         }          @Override         public byte[] receive() throws Exception {             byte[] in = new byte[DATA_BUFFER_LEN];             int bytesRead = mSocket.getInputStream().read(in);             return Arrays.copyOfRange(in, 0, bytesRead);         }          @Override         public int getPort() throws Exception {             return mSocket.getLocalPort();         }          @Override         public void close() throws Exception {             mSocket.close();         }          @Override         public void applyTransportModeTransform(                 IpSecManager ism, int direction, IpSecTransform transform) throws Exception {             ism.applyTransportModeTransform(mSocket, direction, transform);         }          @Override         public void removeTransportModeTransforms(IpSecManager ism) throws Exception {             ism.removeTransportModeTransforms(mSocket);         }     }      public static class SocketPair<T> {         public final T mLeftSock;         public final T mRightSock;          public SocketPair(T leftSock, T rightSock) {             mLeftSock = leftSock;             mRightSock = rightSock;         }     }      protected static void applyTransformBidirectionally(             IpSecManager ism, IpSecTransform transform, GenericSocket socket) throws Exception {         for (int direction : DIRECTIONS) {             socket.applyTransportModeTransform(ism, direction, transform);         }     }      public static SocketPair<NativeUdpSocket> getNativeUdpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform, boolean connected)             throws Exception {         int domain = getDomain(localAddr);          NativeUdpSocket leftSock = new NativeUdpSocket(             Os.socket(domain, OsConstants.SOCK_DGRAM, OsConstants.IPPROTO_UDP));         NativeUdpSocket rightSock = new NativeUdpSocket(             Os.socket(domain, OsConstants.SOCK_DGRAM, OsConstants.IPPROTO_UDP));          for (NativeUdpSocket sock : new NativeUdpSocket[] {leftSock, rightSock}) {             applyTransformBidirectionally(ism, transform, sock);             Os.bind(sock.mFd, localAddr, 0);         }          if (connected) {             Os.connect(leftSock.mFd, localAddr, rightSock.getPort());             Os.connect(rightSock.mFd, localAddr, leftSock.getPort());         }          return new SocketPair<>(leftSock, rightSock);     }      public static SocketPair<NativeTcpSocket> getNativeTcpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform) throws Exception {         int domain = getDomain(localAddr);          NativeTcpSocket server = new NativeTcpSocket(                 Os.socket(domain, OsConstants.SOCK_STREAM, OsConstants.IPPROTO_TCP));         NativeTcpSocket client = new NativeTcpSocket(                 Os.socket(domain, OsConstants.SOCK_STREAM, OsConstants.IPPROTO_TCP));          Os.bind(server.mFd, localAddr, 0);          applyTransformBidirectionally(ism, transform, server);         applyTransformBidirectionally(ism, transform, client);          Os.listen(server.mFd, 10);         Os.connect(client.mFd, localAddr, server.getPort());         NativeTcpSocket accepted = new NativeTcpSocket(Os.accept(server.mFd, null));          applyTransformBidirectionally(ism, transform, accepted);         server.close();          return new SocketPair<>(client, accepted);     }      public static SocketPair<JavaUdpSocket> getJavaUdpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform, boolean connected)             throws Exception {         JavaUdpSocket leftSock = new JavaUdpSocket(localAddr);         JavaUdpSocket rightSock = new JavaUdpSocket(localAddr);          applyTransformBidirectionally(ism, transform, leftSock);         applyTransformBidirectionally(ism, transform, rightSock);          if (connected) {             leftSock.mSocket.connect(localAddr, rightSock.mSocket.getLocalPort());             rightSock.mSocket.connect(localAddr, leftSock.mSocket.getLocalPort());         }          return new SocketPair<>(leftSock, rightSock);     }      public static SocketPair<JavaTcpSocket> getJavaTcpSocketPair(             InetAddress localAddr, IpSecManager ism, IpSecTransform transform) throws Exception {         JavaTcpSocket clientSock = new JavaTcpSocket(new Socket());         ServerSocket serverSocket = new ServerSocket();         serverSocket.bind(new InetSocketAddress(localAddr, 0));          // While technically the client socket does not need to be bound, the OpenJDK implementation         // of Socket only allocates an FD when bind() or connect() or other similar methods are         // called. So we call bind to force the FD creation, so that we can apply a transform to it         // prior to socket connect.         clientSock.mSocket.bind(new InetSocketAddress(localAddr, 0));          // IpSecService doesn't support serverSockets at the moment; workaround using FD         FileDescriptor serverFd = serverSocket.getImpl().getFD$();          applyTransformBidirectionally(ism, transform, new NativeTcpSocket(serverFd));         applyTransformBidirectionally(ism, transform, clientSock);          clientSock.mSocket.connect(new InetSocketAddress(localAddr, serverSocket.getLocalPort()));         JavaTcpSocket acceptedSock = new JavaTcpSocket(serverSocket.accept());          applyTransformBidirectionally(ism, transform, acceptedSock);         serverSocket.close();          return new SocketPair<>(clientSock, acceptedSock);     }      private void checkSocketPair(GenericSocket left, GenericSocket right) throws Exception {         left.send(TEST_DATA);         assertArrayEquals(TEST_DATA, right.receive());          right.send(TEST_DATA);         assertArrayEquals(TEST_DATA, left.receive());          left.close();         right.close();     }      private void checkUnconnectedUdpSocketPair(             GenericUdpSocket left, GenericUdpSocket right, InetAddress localAddr) throws Exception {         left.sendTo(TEST_DATA, localAddr, right.getPort());         assertArrayEquals(TEST_DATA, right.receive());          right.sendTo(TEST_DATA, localAddr, left.getPort());         assertArrayEquals(TEST_DATA, left.receive());          left.close();         right.close();     }      protected static IpSecTransform buildIpSecTransform(             Context context,             IpSecManager.SecurityParameterIndex spi,             IpSecManager.UdpEncapsulationSocket encapSocket,             InetAddress remoteAddr)             throws Exception {         IpSecTransform.Builder builder =                 new IpSecTransform.Builder(context)                         .setEncryption(new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY))                         .setAuthentication(                                 new IpSecAlgorithm(                                         IpSecAlgorithm.AUTH_HMAC_SHA256,                                         AUTH_KEY,                                         AUTH_KEY.length * 4));          if (encapSocket != null) {             builder.setIpv4Encapsulation(encapSocket, encapSocket.getPort());         }          return builder.buildTransportModeTransform(remoteAddr, spi);     }      private IpSecTransform buildDefaultTransform(InetAddress localAddr) throws Exception {         try (IpSecManager.SecurityParameterIndex spi =                 mISM.allocateSecurityParameterIndex(localAddr)) {             return buildIpSecTransform(InstrumentationRegistry.getContext(), spi, null, localAddr);         }     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.ipsec.ike.cts.ChildSessionParamsTest"	"testBuildChildSessionParamsWithConfigReq"	"CtsIkeTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/ipsec/src/android/net/ipsec/ike/cts/ChildSessionParamsTest.java"	""	"public void testBuildChildSessionParamsWithConfigReq() {         TunnelModeChildSessionParams childParams =                 new TunnelModeChildSessionParams.Builder()                         .addSaProposal(mSaProposal)                         .addInternalAddressRequest(AF_INET)                         .addInternalAddressRequest(AF_INET6)                         .addInternalAddressRequest(AF_INET6)                         .addInternalAddressRequest(IPV4_ADDRESS_REMOTE)                         .addInternalAddressRequest(IPV6_ADDRESS_REMOTE, IP6_PREFIX_LEN)                         .addInternalDnsServerRequest(AF_INET)                         .addInternalDnsServerRequest(AF_INET6)                         .addInternalDhcpServerRequest(AF_INET)                         .addInternalDhcpServerRequest(AF_INET)                         .build();          verifyTunnelModeChildParamsWithDefaultValues(childParams);          // Verify config request types and number of requests for each type         Map<Class<? extends TunnelModeChildConfigRequest>, Integer> expectedAttributeCounts =                 new HashMap<>();         expectedAttributeCounts.put(ConfigRequestIpv4Address.class, 2);         expectedAttributeCounts.put(ConfigRequestIpv6Address.class, 3);         expectedAttributeCounts.put(ConfigRequestIpv4Netmask.class, 1);         expectedAttributeCounts.put(ConfigRequestIpv4DnsServer.class, 1);         expectedAttributeCounts.put(ConfigRequestIpv6DnsServer.class, 1);         expectedAttributeCounts.put(ConfigRequestIpv4DhcpServer.class, 2);         verifyConfigRequestTypes(expectedAttributeCounts, childParams.getConfigurationRequests());          // Verify specific IPv4 address request         Set<Inet4Address> expectedV4Addresses = new HashSet<>();         expectedV4Addresses.add(IPV4_ADDRESS_REMOTE);         verifySpecificV4AddrConfigReq(expectedV4Addresses, childParams);          // Verify specific IPv6 address request         Set<LinkAddress> expectedV6Addresses = new HashSet<>();         expectedV6Addresses.add(new LinkAddress(IPV6_ADDRESS_REMOTE, IP6_PREFIX_LEN));         verifySpecificV6AddrConfigReq(expectedV6Addresses, childParams);     }      protected void verifySpecificV4AddrConfigReq(             Set<Inet4Address> expectedAddresses, TunnelModeChildSessionParams childParams) {         for (TunnelModeChildConfigRequest req : childParams.getConfigurationRequests()) {             if (req instanceof ConfigRequestIpv4Address                     && ((ConfigRequestIpv4Address) req).getAddress() != null) {                 Inet4Address address = ((ConfigRequestIpv4Address) req).getAddress();                  // Fail if expectedAddresses does not contain this address                 assertTrue(expectedAddresses.remove(address));             }         }          // Fail if any expected address is not found in result         assertTrue(expectedAddresses.isEmpty());     }      protected void verifySpecificV6AddrConfigReq(             Set<LinkAddress> expectedAddresses, TunnelModeChildSessionParams childParams) {         for (TunnelModeChildConfigRequest req : childParams.getConfigurationRequests()) {             if (req instanceof ConfigRequestIpv6Address                     && ((ConfigRequestIpv6Address) req).getAddress() != null) {                 ConfigRequestIpv6Address ipv6AddrReq = (ConfigRequestIpv6Address) req;                  // Fail if expectedAddresses does not contain this address                 LinkAddress address =                         new LinkAddress(ipv6AddrReq.getAddress(), ipv6AddrReq.getPrefixLength());                 assertTrue(expectedAddresses.remove(address));             }         }          // Fail if any expected address is not found in result         assertTrue(expectedAddresses.isEmpty());     } }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.ipsec.ike.cts.IkeSessionParamsTest"	"tearDownTestNetwork"	"CtsIkeTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/ipsec/src/android/net/ipsec/ike/cts/IkeSessionParamsTest.java"	""	"/*  *.  */  package android.net.ipsec.ike.cts;  import static android.net.ipsec.ike.IkeSessionParams.IKE_OPTION_ACCEPT_ANY_REMOTE_ID; import static android.net.ipsec.ike.IkeSessionParams.IKE_OPTION_EAP_ONLY_AUTH; import static android.net.ipsec.ike.IkeSessionParams.IkeAuthConfig; import static android.net.ipsec.ike.IkeSessionParams.IkeAuthDigitalSignLocalConfig; import static android.net.ipsec.ike.IkeSessionParams.IkeAuthDigitalSignRemoteConfig; import static android.net.ipsec.ike.IkeSessionParams.IkeAuthEapConfig; import static android.net.ipsec.ike.IkeSessionParams.IkeAuthPskConfig; import static android.system.OsConstants.AF_INET; import static android.system.OsConstants.AF_INET6; import static android.telephony.TelephonyManager.APPTYPE_USIM;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.net.eap.EapSessionConfig; import android.net.ipsec.ike.IkeFqdnIdentification; import android.net.ipsec.ike.IkeIdentification; import android.net.ipsec.ike.IkeSaProposal; import android.net.ipsec.ike.IkeSessionParams; import android.net.ipsec.ike.IkeSessionParams.ConfigRequestIpv4PcscfServer; import android.net.ipsec.ike.IkeSessionParams.ConfigRequestIpv6PcscfServer; import android.net.ipsec.ike.IkeSessionParams.IkeConfigRequest;  import androidx.test.ext.junit.runners.AndroidJUnit4;  import com.android.internal.net.ipsec.ike.testutils.CertUtils;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.net.InetAddress; import java.security.cert.X509Certificate; import java.security.interfaces.RSAPrivateKey; import java.util.Arrays; import java.util.Collections; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.TimeUnit;  @RunWith(AndroidJUnit4.class) public final class IkeSessionParamsTest extends IkeSessionTestBase {     private static final int HARD_LIFETIME_SECONDS = (int) TimeUnit.HOURS.toSeconds(20L);     private static final int SOFT_LIFETIME_SECONDS = (int) TimeUnit.HOURS.toSeconds(10L);     private static final int DPD_DELAY_SECONDS = (int) TimeUnit.MINUTES.toSeconds(10L);     private static final int[] RETRANS_TIMEOUT_MS_LIST = new int[] {500, 500, 500, 500, 500, 500};      private static final Map<Class<? extends IkeConfigRequest>, Integer> EXPECTED_REQ_COUNT =             new HashMap<>();     private static final HashSet<InetAddress> EXPECTED_PCSCF_SERVERS = new HashSet<>();      static {         EXPECTED_REQ_COUNT.put(ConfigRequestIpv4PcscfServer.class, 3);         EXPECTED_REQ_COUNT.put(ConfigRequestIpv6PcscfServer.class, 3);          EXPECTED_PCSCF_SERVERS.add(PCSCF_IPV4_ADDRESS_1);         EXPECTED_PCSCF_SERVERS.add(PCSCF_IPV4_ADDRESS_2);         EXPECTED_PCSCF_SERVERS.add(PCSCF_IPV6_ADDRESS_1);         EXPECTED_PCSCF_SERVERS.add(PCSCF_IPV6_ADDRESS_2);     }      // Arbitrary proposal and remote ID. Local ID is chosen to match the client end cert in the     // following CL     private static final IkeSaProposal SA_PROPOSAL =             SaProposalTest.buildIkeSaProposalWithNormalModeCipher();     private static final IkeIdentification LOCAL_ID = new IkeFqdnIdentification(LOCAL_HOSTNAME);     private static final IkeIdentification REMOTE_ID = new IkeFqdnIdentification(REMOTE_HOSTNAME);      private static final EapSessionConfig EAP_ALL_METHODS_CONFIG =             createEapOnlySafeMethodsBuilder()                     .setEapMsChapV2Config(EAP_MSCHAPV2_USERNAME, EAP_MSCHAPV2_PASSWORD)                     .build();     private static final EapSessionConfig EAP_ONLY_SAFE_METHODS_CONFIG =             createEapOnlySafeMethodsBuilder().build();      private X509Certificate mServerCaCert;     private X509Certificate mClientEndCert;     private X509Certificate mClientIntermediateCaCertOne;     private X509Certificate mClientIntermediateCaCertTwo;     private RSAPrivateKey mClientPrivateKey;      @Before     public void setUp() throws Exception {         // This address is never used except for setting up the test network         setUpTestNetwork(IPV4_ADDRESS_LOCAL);          mServerCaCert = CertUtils.createCertFromPemFile(""server-a-self-signed-ca.pem"");         mClientEndCert = CertUtils.createCertFromPemFile(""client-a-end-cert.pem"");         mClientIntermediateCaCertOne =                 CertUtils.createCertFromPemFile(""client-a-intermediate-ca-one.pem"");         mClientIntermediateCaCertTwo =                 CertUtils.createCertFromPemFile(""client-a-intermediate-ca-two.pem"");         mClientPrivateKey = CertUtils.createRsaPrivateKeyFromKeyFile(""client-a-private-key.key"");     }      @After     public void tearDown() throws Exception {         tearDownTestNetwork();     }      private static EapSessionConfig.Builder createEapOnlySafeMethodsBuilder() {         return new EapSessionConfig.Builder()                 .setEapIdentity(EAP_IDENTITY)                 .setEapSimConfig(SUB_ID, APPTYPE_USIM)                 .setEapAkaConfig(SUB_ID, APPTYPE_USIM)                 .setEapAkaPrimeConfig(                         SUB_ID, APPTYPE_USIM, NETWORK_NAME, true /* allowMismatchedNetworkNames */);     }      /**      * Create a Builder that has minimum configurations to build an IkeSessionParams.      *      * <p>Authentication method is arbitrarily selected. Using other method (e.g. setAuthEap) also      * works.      */     private IkeSessionParams.Builder createIkeParamsBuilderMinimum() {         return new IkeSessionParams.Builder(sContext)                 .setNetwork(mTunNetwork)                 .setServerHostname(IPV4_ADDRESS_REMOTE.getHostAddress())                 .addSaProposal(SA_PROPOSAL)                 .setLocalIdentification(LOCAL_ID)                 .setRemoteIdentification(REMOTE_ID)                 .setAuthPsk(IKE_PSK);     }      /**      * Verify the minimum configurations to build an IkeSessionParams.      *      * @see #createIkeParamsBuilderMinimum      */     private void verifyIkeParamsMinimum(IkeSessionParams sessionParams) {         assertEquals(mTunNetwork, sessionParams.getNetwork());         assertEquals(IPV4_ADDRESS_REMOTE.getHostAddress(), sessionParams.getServerHostname());         assertEquals(Arrays.asList(SA_PROPOSAL), sessionParams.getSaProposals());         assertEquals(LOCAL_ID, sessionParams.getLocalIdentification());         assertEquals(REMOTE_ID, sessionParams.getRemoteIdentification());          IkeAuthConfig localConfig = sessionParams.getLocalAuthConfig();         assertTrue(localConfig instanceof IkeAuthPskConfig);         assertArrayEquals(IKE_PSK, ((IkeAuthPskConfig) localConfig).getPsk());         IkeAuthConfig remoteConfig = sessionParams.getRemoteAuthConfig();         assertTrue(remoteConfig instanceof IkeAuthPskConfig);         assertArrayEquals(IKE_PSK, ((IkeAuthPskConfig) remoteConfig).getPsk());     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.ipsec.ike.cts.IkeSessionParamsTest"	"testSetPcscfConfigRequests"	"CtsIkeTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/ipsec/src/android/net/ipsec/ike/cts/IkeSessionParamsTest.java"	""	"public void testSetPcscfConfigRequests() throws Exception {         IkeSessionParams sessionParams =                 createIkeParamsBuilderMinimum()                         .setRetransmissionTimeoutsMillis(RETRANS_TIMEOUT_MS_LIST)                         .addPcscfServerRequest(AF_INET)                         .addPcscfServerRequest(PCSCF_IPV4_ADDRESS_1)                         .addPcscfServerRequest(PCSCF_IPV6_ADDRESS_1)                         .addPcscfServerRequest(AF_INET6)                         .addPcscfServerRequest(PCSCF_IPV4_ADDRESS_2)                         .addPcscfServerRequest(PCSCF_IPV6_ADDRESS_2)                         .build();          verifyIkeParamsMinimum(sessionParams);         verifyConfigRequestTypes(EXPECTED_REQ_COUNT, sessionParams.getConfigurationRequests());          Set<InetAddress> resultAddresses = new HashSet<>();         for (IkeConfigRequest req : sessionParams.getConfigurationRequests()) {             if (req instanceof ConfigRequestIpv4PcscfServer                     && ((ConfigRequestIpv4PcscfServer) req).getAddress() != null) {                 resultAddresses.add(((ConfigRequestIpv4PcscfServer) req).getAddress());             } else if (req instanceof ConfigRequestIpv6PcscfServer                     && ((ConfigRequestIpv6PcscfServer) req).getAddress() != null) {                 resultAddresses.add(((ConfigRequestIpv6PcscfServer) req).getAddress());             }         }         assertEquals(EXPECTED_PCSCF_SERVERS, resultAddresses);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.security.cts.KernelSettingsTest"	"testNoIcmpRedirects"	"CtsSecurityTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/security/src/android/security/cts/KernelSettingsTest.java"	""	"public void testNoIcmpRedirects() throws IOException {         try {             assertEquals(""ICMP redirects are enabled for IPv4."",                     ""0"", getFile(""/proc/sys/net/ipv4/conf/all/accept_redirects""));         } catch (FileNotFoundException e) {             // Odd. The file doesn't exist... Assume we're ok.         }          try {             assertEquals(""ICMP redirects are enabled for IPv6."",                     ""0"", getFile(""/proc/sys/net/ipv6/conf/all/accept_redirects""));         } catch (FileNotFoundException e) {             // Odd. The file doesn't exist... Assume we're ok.         }     }      static String getFile(String filename) throws IOException {         BufferedReader in = null;         try {             in = new BufferedReader(new FileReader(filename));             return in.readLine().trim();         } finally {             if (in != null) {                 in.close();             }         }     } }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.hardware.cts.SensorDirectReportTest"	"isDirectChannelTypeSupported"	"CtsSensorTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"simultaneously"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void test/*  *.  */  package android.hardware.cts;  import android.content.Context; import android.hardware.HardwareBuffer; import android.hardware.Sensor; import android.hardware.SensorDirectChannel; import android.hardware.SensorEvent; import android.hardware.SensorEventListener; import android.hardware.SensorManager; import android.hardware.cts.helpers.SensorCtsHelper; import android.hardware.cts.helpers.SensorCtsHelper.TestResultCollector; import android.os.MemoryFile; import android.os.SystemClock; import android.util.Log;  import java.io.IOException; import java.io.UncheckedIOException; import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.concurrent.TimeUnit;  /**  * Checks Sensor Direct Report functionality  *  * This testcase tests operation of:  *   - SensorManager.createDirectChannel()  *   - SensorDirectChannel.*  *   - Sensor.getHighestDirectReportRateLevel()  *   - Sensor.isDirectChannelTypeSupported()  *  * Tests:  *   - test<Sensor><SharedMemoryType><RateLevel>  *     tests basic operation of sensor in direct report mode at various rate level specification.  *   - testRateIndependency<Sensor1><Sensor2>SingleChannel  *     tests if two sensors in the same direct channel are able to run at different rates.  *   - testRateIndependency<Sensor>MultiChannel  *     tests if a sensor is able to be configured to different rate levels for multiple channels.  *   - testRateIndependency<Sensor>MultiMode  *     tests if a sensor is able to report at different rates in direct report mode and traditional  *     report mode (polling).  *   - testTimestamp<Sensor>  *     tests if the timestamp is correct both in absolute sense and relative to traditional report.  *   - testAtomicCounter<Sensor>  *     test if atomic counter is increased as specified and if sensor event content is fully updated  *     before update of atomic counter.  *   - testRegisterMultipleChannels  *     test scenarios when multiple channels are registered simultaneously.  *   - testReconfigure  *     test channel reconfiguration (configure to a rate level; configure to stop; configure to  *     another rate level)  *   - testRegisterMultipleChannelsUsingSameMemory  *     test a negative case when the same memory is being used twice for registering sensor direct  *     channel  *   - testCloseWithoutConfigStop  *     test a common mistake in API usage and make sure no negative effect is made to system.  */ public class SensorDirectReportTest extends SensorTestCase {     private static final String TAG = ""SensorDirectReportTest"";     // nominal rates of each rate level supported     private static final float RATE_NORMAL_NOMINAL = 50;     private static final float RATE_FAST_NOMINAL = 200;     private static final float RATE_VERY_FAST_NOMINAL = 800;      // actuall value is allowed to be 55% to 220% of nominal value     private static final float FREQ_LOWER_BOUND = 0.55f;     private static final float FREQ_UPPER_BOUND = 2.2f;      // actuall value is allowed to be 90% to 200% of nominal value in poll() interface     private static final float FREQ_LOWER_BOUND_POLL = 0.90f;     private static final float FREQ_UPPER_BOUND_POLL = 2.00f;      // sensor reading assumption     private static final float GRAVITY_MIN = 9.81f - 1.0f;     private static final float GRAVITY_MAX = 9.81f + 1.0f;     private static final float GYRO_NORM_MAX = 0.1f;      // test constants     private static final int REST_PERIOD_BEFORE_TEST_MILLISEC = 3000;     private static final int TEST_RUN_TIME_PERIOD_MILLISEC = 5000;     private static final int ALLOWED_SENSOR_INIT_TIME_MILLISEC = 500;     private static final int SENSORS_EVENT_SIZE = 104;     private static final int ATOMIC_COUNTER_OFFSET = 12;     private static final int ATOMIC_COUNTER_SIZE = 4;     private static final int SENSORS_EVENT_COUNT = 10240; // 800Hz * 2.2 * 5 sec + extra     private static final int SHARED_MEMORY_SIZE = SENSORS_EVENT_COUNT * SENSORS_EVENT_SIZE;     private static final float MERCY_FACTOR = 0.1f;     private static final boolean CHECK_ABSOLUTE_LATENCY = false;      // list of rate levels being tested     private static final int[] POSSIBLE_RATE_LEVELS = new int[] {             SensorDirectChannel.RATE_NORMAL,             SensorDirectChannel.RATE_FAST,             SensorDirectChannel.RATE_VERY_FAST         };      // list of channel types being tested     private static final int[] POSSIBLE_CHANNEL_TYPES = new int [] {             SensorDirectChannel.TYPE_MEMORY_FILE,             SensorDirectChannel.TYPE_HARDWARE_BUFFER         };      // list of sensor types being tested     private static final int[] POSSIBLE_SENSOR_TYPES = new int [] {             Sensor.TYPE_ACCELEROMETER,             Sensor.TYPE_GYROSCOPE,             Sensor.TYPE_MAGNETIC_FIELD         };      // list of sampling period being tested     private static final int[] POSSIBLE_SAMPLE_PERIOD_US = new int [] {             200_000, // Normal 5 Hz             66_667,  // UI    15 Hz             20_000,  // Game  50 Hz             5_000,   // 200Hz             0        // fastest         };      private static final ByteOrder NATIVE_BYTE_ORDER = ByteOrder.nativeOrder();      private static native boolean nativeReadHardwareBuffer(HardwareBuffer hardwareBuffer,             byte[] buffer, int srcOffset, int destOffset, int count);      private boolean mNeedMemoryFile;     private MemoryFile mMemoryFile;     private MemoryFile mMemoryFileSecondary;     private boolean mNeedHardwareBuffer;     private HardwareBuffer mHardwareBuffer;     private HardwareBuffer mHardwareBufferSecondary;     private ByteBuffer mByteBuffer;     private byte[] mBuffer;      private SensorManager mSensorManager;     private SensorDirectChannel mChannel;     private SensorDirectChannel mChannelSecondary;      private EventPool mEventPool;      static {         System.loadLibrary(""cts-sensors-ndk-jni"");     }      @Override     protected void setUp() throws Exception {         super.setUp();          mByteBuffer = ByteBuffer.allocate(SHARED_MEMORY_SIZE);         mBuffer = mByteBuffer.array();         mByteBuffer.order(ByteOrder.nativeOrder());          mEventPool = new EventPool(10 * SENSORS_EVENT_COUNT);         mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);          mNeedMemoryFile = isMemoryTypeNeeded(SensorDirectChannel.TYPE_MEMORY_FILE);         mNeedHardwareBuffer = isMemoryTypeNeeded(SensorDirectChannel.TYPE_HARDWARE_BUFFER);          allocateSharedMemory();     }      @Override     protected void tearDown() throws Exception {         if (mChannel != null) {             mChannel.close();             mChannel = null;         }          if (mChannelSecondary != null) {             mChannelSecondary.close();             mChannelSecondary = null;         }          freeSharedMemory();         super.tearDown();     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.ipsec.ike.cts.IkeSessionPskTest"	"testIkeSessionSetupAndChildSessionSetupWithTunnelModeV6"	"CtsIkeTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/ipsec/src/android/net/ipsec/ike/cts/IkeSessionPskTest.java"	""	"public void testIkeSessionSetupAndChildSessionSetupWithTunnelModeV6() throws Exception {         if (!hasTunnelsFeature()) return;          final String ikeInitResp =                 ""46B8ECA1E0D72A186F7B6C2CEB77EB9021202220000000000000011822000030""                         + ""0000002C010100040300000C0100000C800E0100030000080300000C03000008""                         + ""0200000500000008040000022800008800020000DABAA04B38B491E2403F2125""                         + ""96ECF1C8EF7B1DC19A422FDD46E1756C826BB3A16404361B775D9950577B5CDF""                         + ""6AAA1642BD1427BDA8BC55354A97C1025E19C1E2EE2DF8A0C9406E545D829F52""                         + ""75695008E3B742984B8DD1770F3514213B0DF3EE8B199416DF200D248115C057""                         + ""1C193E4F96802E5EF48DD99CAC251882A8F7CCC329000024BC6F0F1D3653C2C7""                         + ""679E02CDB6A3B32B2FEE9AF52F0326D4D9AE073D56CE8922290000080000402E""                         + ""290000100000402F00020003000400050000000800004014"";         final String ikeAuthResp =                 ""46B8ECA1E0D72A186F7B6C2CEB77EB902E202320000000010000015024000134""                         + ""4D115AFDCDAD0310760BB664EB7D405A340869AD6EDF0AAEAD0663A9253DADCB""                         + ""73EBE5CD29D4FA1CDEADE0B94391B5C4CF77BCC1596ACE3CE6A7891E44888FA5""                         + ""46632C0EF4E6193C023C9DC59142C37D1C49D6EF5CD324EC6FC35C89E1721C78""                         + ""91FDCDB723D8062709950F4AA9273D26A54C9C7E86862DBC15F7B6641D2B9BAD""                         + ""E55069008201D12968D97B537B1518FE87B0FFA03C3EE6012C06721B1E2A3F68""                         + ""92108BC4A4F7063F7F94562D8B60F291A1377A836CF12BCDA7E15C1A8F3C77BB""                         + ""6DB7F2C833CCE4CDDED7506536621A3356CE2BC1874E7B1A1A9B447D7DF6AB09""                         + ""638B8AD94A781B28BB91B514B611B24DF8E8A047A10AE27BBF15C754D3D2F792""                         + ""D3E1CCADDAE934C98AE53A8FC3419C88AFF0355564F82A629C998012DA7BB704""                         + ""5307270DF326377E3E1994476902035B"";         final String deleteIkeResp =                 ""46B8ECA1E0D72A186F7B6C2CEB77EB902E202520000000020000005000000034""                         + ""CF15C299F35688E5140A48B61C95F004121BF8236201415E5CD45BA41AAB16D4""                         + ""90B44B9E6D5D92B5B97D24196A58C73F"";          mLocalAddress = IPV6_ADDRESS_LOCAL;         mRemoteAddress = IPV6_ADDRESS_REMOTE;          // Teardown current test network that uses IPv4 address and set up new network with IPv6         // address.         tearDownTestNetwork();         setUpTestNetwork(mLocalAddress);          // Open IKE Session         IkeSession ikeSession = openIkeSessionWithTunnelModeChild(mRemoteAddress);         performSetupIkeAndFirstChildBlocking(                 ikeInitResp,                 1 /* expectedAuthReqPktCnt */,                 false /* expectedAuthUseEncap */,                 ikeAuthResp);          // Local request message ID starts from 2 because there is one IKE_INIT message and a single         // IKE_AUTH message.         int expectedMsgId = 2;          verifyIkeSessionSetupBlocking();         verifyChildSessionSetupBlocking(                 mFirstChildSessionCallback,                 Arrays.asList(TUNNEL_MODE_INBOUND_TS_V6),                 Arrays.asList(TUNNEL_MODE_OUTBOUND_TS_V6),                 Arrays.asList(EXPECTED_INTERNAL_LINK_ADDR_V6),                 Arrays.asList(EXPECTED_DNS_SERVERS_ONE, EXPECTED_DNS_SERVERS_TWO));          IpSecTransformCallRecord firstTransformRecordA =                 mFirstChildSessionCallback.awaitNextCreatedIpSecTransform();         IpSecTransformCallRecord firstTransformRecordB =                 mFirstChildSessionCallback.awaitNextCreatedIpSecTransform();         verifyCreateIpSecTransformPair(firstTransformRecordA, firstTransformRecordB);          // Close IKE Session         ikeSession.close();         performCloseIkeBlocking(expectedMsgId++, false /* expectedUseEncap */, deleteIkeResp);         verifyCloseIkeAndChildBlocking(firstTransformRecordA, firstTransformRecordB);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"com.android.cts.deviceowner.NetworkLoggingTest"	"testNetworkLoggingAndRetrieval"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/NetworkLoggingTest.java"	""	"public void testNetworkLoggingAndRetrieval() throws Exception {         mBatchesRequested =                 Integer.parseInt(                         InstrumentationRegistry.getArguments().getString(ARG_BATCH_COUNT, ""1""));         mBatchCountDown = new CountDownLatch(mBatchesRequested);         // register a receiver that listens for DeviceAdminReceiver#onNetworkLogsAvailable()         final IntentFilter filterNetworkLogsAvailable = new IntentFilter(                 BasicAdminReceiver.ACTION_NETWORK_LOGS_AVAILABLE);         LocalBroadcastManager.getInstance(mContext).registerReceiver(mNetworkLogsReceiver,                 filterNetworkLogsAvailable);          // visit websites that shouldn't be logged as network logging isn't enabled yet         for (final String url : NOT_LOGGED_URLS_LIST) {             connectToWebsite(url);         }          // enable network logging and start the logging scenario         mDevicePolicyManager.setNetworkLoggingEnabled(getWho(), true);         assertTrue(mDevicePolicyManager.isNetworkLoggingEnabled(getWho()));          // TODO: here test that facts about logging are shown in the UI          // Fetch and verify the batches of events.         generateBatches();     }      private void generateBatches() throws Exception {         // visit websites to verify their dns lookups are logged         for (final String url : LOGGED_URLS_LIST) {             connectToWebsite(url);         }          // generate enough traffic to fill the batches.         int dummyReqNo = 0;         for (int i = 0; i < mBatchesRequested; i++) {             dummyReqNo += generateDummyTraffic();         }          // if DeviceAdminReceiver#onNetworkLogsAvailable() hasn't been triggered yet, wait for up to         // 3 minutes per batch just in case         final int timeoutMins = 3 * mBatchesRequested;         mBatchCountDown.await(timeoutMins, TimeUnit.MINUTES);         LocalBroadcastManager.getInstance(mContext).unregisterReceiver(mNetworkLogsReceiver);         if (mBatchCountDown.getCount() > 0) {             fail(""Generated events for "" + mBatchesRequested + "" batches and waited for ""                     + timeoutMins + "" minutes, but still didn't get""                     + "" DeviceAdminReceiver#onNetworkLogsAvailable() callback"");         }          // Verify network logs.         assertEquals(""First event has the wrong id."", 0L, mNetworkEvents.get(0).getId());         // For each of the real URLs we have two events: one DNS and one connect. Dummy requests         // don't require DNS queries.         final int eventsExpected =                 Math.min(FULL_LOG_BATCH_SIZE * mBatchesRequested,                         2 * LOGGED_URLS_LIST.length + dummyReqNo);         verifyNetworkLogs(mNetworkEvents, eventsExpected);     }      private void verifyDnsEvent(DnsEvent dnsEvent) {         // Verify that we didn't log a hostname lookup when network logging was disabled.         if (dnsEvent.getHostname().contains(NOT_LOGGED_URLS_LIST[0])                 || dnsEvent.getHostname().contains(NOT_LOGGED_URLS_LIST[1])) {             fail(""A hostname that was looked-up when network logging was disabled""                     + "" was logged."");         }          // Verify that as many IP addresses were logged as were reported (max 10).         final List<InetAddress> ips = dnsEvent.getInetAddresses();         assertThat(ips.size()).isAtMost(MAX_IP_ADDRESSES_LOGGED);         final int expectedAddressCount = Math.min(MAX_IP_ADDRESSES_LOGGED,                 dnsEvent.getTotalResolvedAddressCount());         assertThat(expectedAddressCount).isEqualTo(ips.size());          // Verify the IP addresses are valid IPv4 or IPv6 addresses.         for (final InetAddress ipAddress : ips) {             assertTrue(isIpv4OrIpv6Address(ipAddress));         }          //Verify writeToParcel.         Parcel parcel = Parcel.obtain();         try {             dnsEvent.writeToParcel(parcel, 0);             parcel.setDataPosition(0);             final DnsEvent dnsEventOut = DnsEvent.CREATOR.createFromParcel(parcel);             assertThat(dnsEventOut).isNotNull();             verifyDnsEventsEqual(dnsEvent, dnsEventOut);         } finally {             parcel.recycle();         }     }      private void verifyDnsEventsEqual(DnsEvent event1, DnsEvent event2) {         assertThat(event1.getHostname()).isEqualTo(event2.getHostname());         assertThat(new HashSet<InetAddress>(event1.getInetAddresses())).isEqualTo(                         new HashSet<InetAddress>(event2.getInetAddresses()));         assertThat(event1.getTotalResolvedAddressCount()).isEqualTo(                 event2.getTotalResolvedAddressCount());         assertThat(event1.getPackageName()).isEqualTo(event2.getPackageName());         assertThat(event1.getTimestamp()).isEqualTo(event2.getTimestamp());         assertThat(event1.getId()).isEqualTo(event2.getId());     }      private void verifyConnectEvent(ConnectEvent connectEvent) {         // Verify the IP address is a valid IPv4 or IPv6 address.         final InetAddress ip = connectEvent.getInetAddress();         assertThat(isIpv4OrIpv6Address(ip)).isTrue();          // Verify that the port is a valid port.         assertThat(connectEvent.getPort()).isAtLeast(0);         assertThat(connectEvent.getPort()).isAtMost(65535);          // Verify writeToParcel.         Parcel parcel = Parcel.obtain();         try {             connectEvent.writeToParcel(parcel, 0);             parcel.setDataPosition(0);             final ConnectEvent connectEventOut = ConnectEvent.CREATOR.createFromParcel(parcel);             assertThat(connectEventOut).isNotNull();             verifyConnectEventsEqual(connectEvent, connectEventOut);         } finally {              parcel.recycle();         }     }      private void verifyConnectEventsEqual(ConnectEvent event1, ConnectEvent event2) {         assertThat(event1.getInetAddress()).isEqualTo(event2.getInetAddress());         assertThat(event1.getPort()).isEqualTo(event2.getPort());         assertThat(event1.getPackageName()).isEqualTo(event2.getPackageName());         assertThat(event1.getTimestamp()).isEqualTo(event2.getTimestamp());         assertThat(event1.getId()).isEqualTo(event2.getId());     }      private void verifyNetworkLogs(List<NetworkEvent> networkEvents, int eventsExpected) {         // allow a batch to be slightly smaller or larger.         assertTrue(Math.abs(eventsExpected - networkEvents.size()) <= 150);         int ctsPackageNameCounter = 0;         // allow a small down margin for verification, to avoid flakiness         final int eventsExpectedWithMargin = eventsExpected - 50;         final boolean[] visited = new boolean[LOGGED_URLS_LIST.length];          for (int i = 0; i < networkEvents.size(); i++) {             final NetworkEvent currentEvent = networkEvents.get(i);             // verify that the events are in chronological order             if (i > 0) {                 assertTrue(currentEvent.getTimestamp() >= networkEvents.get(i - 1).getTimestamp());             }             // verify that the event IDs are monotonically increasing             if (i > 0) {                 assertTrue(currentEvent.getId() == (networkEvents.get(i - 1).getId() + 1));             }             // count how many events come from the CTS app             if (CTS_APP_PACKAGE_NAME.equals(currentEvent.getPackageName())) {                 ctsPackageNameCounter++;                 if (currentEvent instanceof DnsEvent) {                     final DnsEvent dnsEvent = (DnsEvent) currentEvent;                     // Mark which addresses from LOGGED_URLS_LIST were visited.                     for (int j = 0; j < LOGGED_URLS_LIST.length; j++) {                         if (dnsEvent.getHostname().contains(LOGGED_URLS_LIST[j])) {                             visited[j] = true;                             break;                         }                     }                      verifyDnsEvent(dnsEvent);                 } else if (currentEvent instanceof ConnectEvent) {                     final ConnectEvent connectEvent = (ConnectEvent) currentEvent;                     verifyConnectEvent(connectEvent);                 } else {                     fail(""An unknown NetworkEvent type logged: ""                             + currentEvent.getClass().getName());                 }             }         }          // verify that each hostname from LOGGED_URLS_LIST was looked-up         for (int i = 0; i < 10; i++) {             assertTrue(LOGGED_URLS_LIST[i] + "" wasn't visited"", visited[i]);         }         // verify that sufficient iterations done by the CTS app were logged         assertTrue(ctsPackageNameCounter >= eventsExpectedWithMargin);     }      private void connectToWebsite(String server) {         HttpURLConnection urlConnection = null;         try {             final URL url = new URL(""http://"" + server);             urlConnection = (HttpURLConnection) url.openConnection();             urlConnection.setConnectTimeout(2000);             urlConnection.setReadTimeout(2000);             urlConnection.getResponseCode();         } catch (IOException e) {             Log.w(TAG, ""Failed to connect to "" + server, e);         } finally {             if (urlConnection != null) {                 urlConnection.disconnect();             }         }     }      /** Quickly generate loads of events by repeatedly connecting to a local server. */     private int generateDummyTraffic() throws IOException, InterruptedException {         final ServerSocket serverSocket = new ServerSocket(0);         final Thread serverThread = startDummyServer(serverSocket);          final int reqNo = makeDummyRequests(serverSocket.getLocalPort());          serverSocket.close();         serverThread.join();          return reqNo;     }      private int makeDummyRequests(int port) {         int reqNo;         final String DUMMY_SERVER = ""127.0.0.1:"" + port;         for (reqNo = 0; reqNo < FULL_LOG_BATCH_SIZE && mBatchCountDown.getCount() > 0; reqNo++) {             connectToWebsite(DUMMY_SERVER);             try {                 // Just to prevent choking the server.                 Thread.sleep(10);             } catch (InterruptedException e) {                 Thread.currentThread().interrupt();             }         }         return reqNo;     }      private Thread startDummyServer(ServerSocket serverSocket) throws InterruptedException {         final Thread serverThread = new Thread(() -> {             while (!serverSocket.isClosed()) {                 try {                     final Socket socket = serverSocket.accept();                     // Consume input.                     final BufferedReader input =                             new BufferedReader(new InputStreamReader(socket.getInputStream()));                     String line;                     do {                         line = input.readLine();                     } while (line != null && !line.equals(""""));                     // Return minimum valid response.                     final PrintStream output = new PrintStream(socket.getOutputStream());                     output.println(""HTTP/1.0 200 OK"");                     output.println(""Content-Length: 0"");                     output.println();                     output.flush();                     output.close();                 } catch (IOException e) {                     if (!serverSocket.isClosed()) {                         Log.w(TAG, ""Failed to serve connection"", e);                     }                 }             }         });         serverThread.start();          // Allow the server to start accepting.         Thread.sleep(1_000);          return serverThread;     }      private boolean isIpv4OrIpv6Address(InetAddress addr) {         return ((addr instanceof Inet4Address) || (addr instanceof Inet6Address));     } }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"com.android.cts.net.ProcNetTest"	"testProcSysctls"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/src/com/android/cts/net/ProcNetTest.java"	""	"public void testProcSysctls() throws Exception {         for (String sysctl : GLOBAL_SYSCTLS) {             int value = readIntFromPath(sysctl);             assertEquals(sysctl, 1, value);         }          for (String interfaceDir : mSysctlDirs) {             String path = IPV6_SYSCTL_DIR + ""/"" + interfaceDir + ""/"" + AUTOCONF_SYSCTL;             int value = readIntFromPath(path);             assertLess(path, value, 0);         }     }      /**      * Verify that accept_ra_rt_info_{min,max}_plen exists and is set to the expected value      */"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"com.android.cts.net.ProcNetTest"	"testAcceptRaRtInfoMinMaxPlen"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/src/com/android/cts/net/ProcNetTest.java"	""	"public void testAcceptRaRtInfoMinMaxPlen() throws Exception {         for (String interfaceDir : mSysctlDirs) {             String path = IPV6_SYSCTL_DIR + ""/"" + interfaceDir + ""/"" + ""accept_ra_rt_info_min_plen"";             int value = readIntFromPath(path);             assertEquals(path, value, ACCEPT_RA_RT_INFO_MIN_PLEN_VALUE);             path = IPV6_SYSCTL_DIR + ""/"" + interfaceDir + ""/"" + ""accept_ra_rt_info_max_plen"";             value = readIntFromPath(path);             assertEquals(path, value, ACCEPT_RA_RT_INFO_MAX_PLEN_VALUE);         }     }      /**      * Verify that router_solicitations exists and is set to the expected value      * and verify that router_solicitation_max_interval exists and is in an acceptable interval.      */"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"com.android.cts.net.ProcNetTest"	"testRouterSolicitations"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/src/com/android/cts/net/ProcNetTest.java"	""	"public void testRouterSolicitations() throws Exception {         for (String interfaceDir : mSysctlDirs) {             String path = IPV6_SYSCTL_DIR + ""/"" + interfaceDir + ""/"" + ""router_solicitations"";             int value = readIntFromPath(path);             assertEquals(IPV6_WIFI_ROUTER_SOLICITATIONS, value);             path = IPV6_SYSCTL_DIR + ""/"" + interfaceDir + ""/"" + ""router_solicitation_max_interval"";             int interval = readIntFromPath(path);             final int lowerBoundSec = 15 * 60;             final int upperBoundSec = 60 * 60;             assertTrue(lowerBoundSec <= interval);             assertTrue(interval <= upperBoundSec);         }     } }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.DnsResolverTest"	"testCancelBeforeQuery"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsResolverTest.java"	""	"public void testCancelBeforeQuery() throws InterruptedException {         final String msg = ""Test cancelled RawQuery "" + TEST_DOMAIN;         for (Network network : getTestableNetworks()) {             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             final CancellationSignal cancelSignal = new CancellationSignal();             cancelSignal.cancel();             mDns.rawQuery(network, TEST_DOMAIN, CLASS_IN, TYPE_AAAA, FLAG_EMPTY,                     mExecutor, cancelSignal, callback);              assertTrue(msg + "" should not return any answers"",                     !callback.waitForAnswer(CANCEL_TIMEOUT_MS));         }     }      /**      * A query callback for InetAddress that ensures that the query is      * cancelled and that onAnswer is never called. If the query succeeds      * before it is cancelled, needRetry will return true so the      * test can retry.      */     class VerifyCancelInetAddressCallback implements DnsResolver.Callback<List<InetAddress>> {         private final CountDownLatch mLatch = new CountDownLatch(1);         private final String mMsg;         private final List<InetAddress> mAnswers;         private final CancellationSignal mCancelSignal;         private String mErrorMsg = null;          VerifyCancelInetAddressCallback(@NonNull String msg, @Nullable CancellationSignal cancel) {             this.mMsg = msg;             this.mCancelSignal = cancel;             mAnswers = new ArrayList<>();         }          public boolean waitForAnswer() throws InterruptedException {             return mLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS);         }          public boolean needRetry() throws InterruptedException {             return mLatch.await(CANCEL_TIMEOUT_MS, TimeUnit.MILLISECONDS);         }          public boolean isAnswerEmpty() {             return mAnswers.isEmpty();         }          public boolean hasIpv6Answer() {             for (InetAddress answer : mAnswers) {                 if (answer instanceof Inet6Address) return true;             }             return false;         }          public boolean hasIpv4Answer() {             for (InetAddress answer : mAnswers) {                 if (answer instanceof Inet4Address) return true;             }             return false;         }          public void assertNoError() {             assertNull(mErrorMsg);         }          @Override         public void onAnswer(@NonNull List<InetAddress> answerList, int rcode) {             if (mCancelSignal != null && mCancelSignal.isCanceled()) {                 mErrorMsg = mMsg + "" should not have returned any answers"";                 mLatch.countDown();                 return;             }             for (InetAddress addr : answerList) {                 Log.d(TAG, ""Reported addr: "" + addr.toString());             }             mAnswers.clear();             mAnswers.addAll(answerList);             mLatch.countDown();         }          @Override         public void onError(@NonNull DnsResolver.DnsException error) {             mErrorMsg = mMsg + error.getMessage();         }     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.DnsResolverTest"	"testQueryForInetAddressIpv6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsResolverTest.java"	""	"public void testQueryForInetAddressIpv6() throws Exception {         doTestQueryForInetAddressIpv6(mExecutor);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.DnsResolverTest"	"testQueryForInetAddressIpv6Inline"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsResolverTest.java"	""	"public void testQueryForInetAddressIpv6Inline() throws Exception {         doTestQueryForInetAddressIpv6(mExecutorInline);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.DnsResolverTest"	"testQueryCancelForInetAddress"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsResolverTest.java"	""	"public void testQueryCancelForInetAddress() throws InterruptedException {         final String msg = ""Test cancel query for InetAddress "" + TEST_DOMAIN;         // Start a DNS query and the cancel it immediately. Use VerifyCancelInetAddressCallback to         // expect that the query is cancelled before it succeeds. If it is not cancelled before it         // succeeds, retry the test until it is.         for (Network network : getTestableNetworks()) {             boolean retry = false;             int round = 0;             do {                 if (++round > CANCEL_RETRY_TIMES) {                     fail(msg + "" cancel failed "" + CANCEL_RETRY_TIMES + "" times"");                 }                 final CountDownLatch latch = new CountDownLatch(1);                 final CancellationSignal cancelSignal = new CancellationSignal();                 final VerifyCancelInetAddressCallback callback =                         new VerifyCancelInetAddressCallback(msg, cancelSignal);                 mDns.query(network, TEST_DOMAIN, FLAG_EMPTY, mExecutor, cancelSignal, callback);                 mExecutor.execute(() -> {                     cancelSignal.cancel();                     latch.countDown();                 });                  retry = callback.needRetry();                 assertTrue(msg + "" query was not cancelled"",                         latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));             } while (retry);         }     }      public void doTestQueryForInetAddressIpv4(Executor executor) throws InterruptedException {         final String msg = ""Test query for IPv4 InetAddress "" + TEST_DOMAIN;         for (Network network : getTestableNetworks()) {             final VerifyCancelInetAddressCallback callback =                     new VerifyCancelInetAddressCallback(msg, null);             mDns.query(network, TEST_DOMAIN, TYPE_A, FLAG_NO_CACHE_LOOKUP,                     executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertNoError();             assertTrue(msg + "" returned 0 results"", !callback.isAnswerEmpty());             assertTrue(msg + "" returned Ipv6 results"", !callback.hasIpv6Answer());         }     }      public void doTestQueryForInetAddressIpv6(Executor executor) throws InterruptedException {         final String msg = ""Test query for IPv6 InetAddress "" + TEST_DOMAIN;         for (Network network : getTestableNetworks()) {             final VerifyCancelInetAddressCallback callback =                     new VerifyCancelInetAddressCallback(msg, null);             mDns.query(network, TEST_DOMAIN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,                     executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertNoError();             assertTrue(msg + "" returned 0 results"", !callback.isAnswerEmpty());             assertTrue(msg + "" returned Ipv4 results"", !callback.hasIpv4Answer());         }     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.DnsResolverTest"	"testPrivateDnsBypass"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsResolverTest.java"	""	"public void testPrivateDnsBypass() throws InterruptedException {         final Network[] testNetworks = getTestableNetworks();          // Set an invalid private DNS server         mCtsNetUtils.setPrivateDnsStrictMode(INVALID_PRIVATE_DNS_SERVER);         final String msg = ""Test PrivateDnsBypass "" + TEST_DOMAIN;         for (Network network : testNetworks) {             // This test cannot be ran with null network because we need to explicitly pass a             // private DNS bypassable network or bind one.             if (network == null) continue;              // wait for private DNS setting propagating             mCtsNetUtils.awaitPrivateDnsSetting(msg + "" wait private DNS setting timeout"",                     network, INVALID_PRIVATE_DNS_SERVER, false);              final CountDownLatch latch = new CountDownLatch(1);             final DnsResolver.Callback<List<InetAddress>> errorCallback =                     new DnsResolver.Callback<List<InetAddress>>() {                         @Override                         public void onAnswer(@NonNull List<InetAddress> answerList, int rcode) {                             fail(msg + "" should not get valid answer"");                         }                          @Override                         public void onError(@NonNull DnsResolver.DnsException error) {                             assertEquals(DnsResolver.ERROR_SYSTEM, error.code);                             assertEquals(ETIMEDOUT, ((ErrnoException) error.getCause()).errno);                             latch.countDown();                         }                     };             // Private DNS strict mode with invalid DNS server is set             // Expect no valid answer returned but ErrnoException with ETIMEDOUT             mDns.query(network, TEST_DOMAIN, FLAG_NO_CACHE_LOOKUP, mExecutor, null, errorCallback);              assertTrue(msg + "" invalid server round. No response after "" + TIMEOUT_MS + ""ms."",                     latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));              final VerifyCancelInetAddressCallback callback =                     new VerifyCancelInetAddressCallback(msg, null);             // Bypass privateDns, expect query works fine             mDns.query(network.getPrivateDnsBypassingCopy(),                     TEST_DOMAIN, FLAG_NO_CACHE_LOOKUP, mExecutor, null, callback);              assertTrue(msg + "" bypass private DNS round. No answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertNoError();             assertTrue(msg + "" returned 0 results"", !callback.isAnswerEmpty());              // To ensure private DNS bypass still work even if passing null network.             // Bind process network with a private DNS bypassable network.             mCM.bindProcessToNetwork(network.getPrivateDnsBypassingCopy());             final VerifyCancelInetAddressCallback callbackWithNullNetwork =                     new VerifyCancelInetAddressCallback(msg + "" with null network "", null);             mDns.query(null,                     TEST_DOMAIN, FLAG_NO_CACHE_LOOKUP, mExecutor, null, callbackWithNullNetwork);              assertTrue(msg + "" with null network bypass private DNS round. No answer after "" +                     TIMEOUT_MS + ""ms."", callbackWithNullNetwork.waitForAnswer());             callbackWithNullNetwork.assertNoError();             assertTrue(msg + "" with null network returned 0 results"",                     !callbackWithNullNetwork.isAnswerEmpty());              // Reset process network to default.             mCM.bindProcessToNetwork(null);         }     }      public void doTestContinuousQueries(Executor executor) throws InterruptedException {         final String msg = ""Test continuous "" + QUERY_TIMES + "" queries "" + TEST_DOMAIN;         for (Network network : getTestableNetworks()) {             for (int i = 0; i < QUERY_TIMES ; ++i) {                 final VerifyCancelInetAddressCallback callback =                         new VerifyCancelInetAddressCallback(msg, null);                 // query v6/v4 in turn                 boolean queryV6 = (i % 2 == 0);                 mDns.query(network, TEST_DOMAIN, queryV6 ? TYPE_AAAA : TYPE_A,                         FLAG_NO_CACHE_LOOKUP, executor, null, callback);                  assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                         callback.waitForAnswer());                 callback.assertNoError();                 assertTrue(msg + "" returned 0 results"", !callback.isAnswerEmpty());                 assertTrue(msg + "" returned "" + (queryV6 ? ""Ipv4"" : ""Ipv6"") + "" results"",                         queryV6 ? !callback.hasIpv4Answer() : !callback.hasIpv6Answer());             }         }     } }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.host.systemui.TvMicrophoneCaptureIndicatorTest"	"testIndicatorShownWhileRecordingUsingBothApisSimultaneously"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"simultaneously"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/systemui/src/android/host/systemui/TvMicrophoneCaptureIndicatorTest.java"	""	"public void testIndicatorShownWhileRecordingUsingBothApisSimultaneously() throws Exception {         assumeTrue(""Not running on a Leanback (TV) device"",                 getDevice().hasFeature(FEATURE_LEANBACK_ONLY));          // Check that the indicator isn't shown initially         assertIndicatorInvisible();          // Start recording using MediaRecorder API         getDevice().executeShellCommand(SHELL_MR_START_REC);          // Wait for the application to be launched         waitForProcessToComeAlive(AUDIO_RECORDER_MR_PACKAGE_NAME);          // Wait for a second, and then check that the indicator is shown         Thread.sleep(ONE_SECOND);         assertIndicatorVisible();          // Start recording using AudioRecord API         getDevice().executeShellCommand(SHELL_AR_START_REC);          // Wait for the application to be launched         waitForProcessToComeAlive(AUDIO_RECORDER_AR_PACKAGE_NAME);          // Check that the indicator is still shown         assertIndicatorVisible();          // Check 3 more times that the indicator remains shown         for (int i = 0; i < 3; i++) {             Thread.sleep(ONE_SECOND);             assertIndicatorVisible();         }          // Stop recording using MediaRecorder API         getDevice().executeShellCommand(SHELL_MR_STOP_REC);          // check that the indicator is still shown         assertIndicatorVisible();          // Check 3 more times that the indicator remains shown         for (int i = 0; i < 3; i++) {             Thread.sleep(ONE_SECOND);             assertIndicatorVisible();         }          // Stop recording using AudioRecord API         getDevice().executeShellCommand(SHELL_AR_STOP_REC);          // Wait for five seconds and make sure that the indicator is not shown         Thread.sleep(FIVE_SECONDS);         assertIndicatorInvisible();     }      @After     public void tearDown() throws Exception {         // Kill both apps         getDevice().executeShellCommand(SHELL_AR_FORCE_STOP);         getDevice().executeShellCommand(SHELL_MR_FORCE_STOP);     }      private void runSimpleStartStopTestRoutine(String packageName, String startCommand,             String stopCommand) throws Exception {         assumeTrue(""Not running on a Leanback (TV) device"",                 getDevice().hasFeature(FEATURE_LEANBACK_ONLY));          // Check that the indicator isn't shown initially         assertIndicatorInvisible();          // Start recording using AudioRecord API         getDevice().executeShellCommand(startCommand);          // Wait for the application to be launched         waitForProcessToComeAlive(packageName);          // Wait for a second, and then check that the indicator is shown, repeat 2 more times         for (int i = 0; i < 3; i++) {             Thread.sleep(ONE_SECOND);             assertIndicatorVisible();         }          // Stop recording (this may either send a command to the app to stop recording or command         // to crash or force-stop the app)         getDevice().executeShellCommand(stopCommand);          // Wait for five seconds and make sure that the indicator is not shown         Thread.sleep(FIVE_SECONDS);         assertIndicatorInvisible();     }      private void waitForProcessToComeAlive(String appPackageName) throws Exception {         final String pidofCommand = String.format(SHELL_PID_OF, appPackageName);          long waitTime = 0;         while (waitTime < THREE_SECONDS) {             Thread.sleep(THREE_HUNDRED_MILLISECONDS);              final String pid = getDevice().executeShellCommand(pidofCommand).trim();             if (!pid.isEmpty()) {                 // Process is running                 return;             }             waitTime += THREE_HUNDRED_MILLISECONDS;         }          fail(""The process for "" + appPackageName                 + "" should have come alive within 3 secs of launching the app."");     }      private void assertIndicatorVisible() throws Exception {         final WindowStateProto window = getMicCaptureIndicatorWindow();          assertNotNull(""\""MicrophoneCaptureIndicator\"" window does not exist"", window);         assertTrue(""\""MicrophoneCaptureIndicator\"" window is not visible"",                 window.getIsVisible());         assertTrue(""\""MicrophoneCaptureIndicator\"" window is not on screen"",                 window.getIsOnScreen());     }      private void assertIndicatorInvisible() throws Exception {         final WindowStateProto window = getMicCaptureIndicatorWindow();         if (window == null) {             // If window is not present, that's fine, there is no need to check anything else.             return;         }          assertFalse(""\""MicrophoneCaptureIndicator\"" window shouldn't be visible"",                 window.getIsVisible());         assertFalse(""\""MicrophoneCaptureIndicator\"" window shouldn't be present on screen"",                 window.getIsOnScreen());     }      private WindowStateProto getMicCaptureIndicatorWindow() throws Exception {         final WindowManagerServiceDumpProto dump = getDump();         final RootWindowContainerProto rootWindowContainer = dump.getRootWindowContainer();         final WindowContainerProto windowContainer = rootWindowContainer.getWindowContainer();          final List<WindowStateProto> windows = new ArrayList<>();         collectWindowStates(windowContainer, windows);          for (WindowStateProto window : windows) {             final String title = window.getIdentifier().getTitle();             if (WINDOW_TITLE_MIC_INDICATOR.equals(title)) {                 return window;             }         }         return null;     }      private WindowManagerServiceDumpProto getDump() throws Exception {         final CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();         getDevice().executeShellCommand(SHELL_DUMPSYS_WINDOW, receiver);         return WindowManagerServiceDumpProto.parser().parseFrom(receiver.getOutput());     }      /**      * This methods implements a DFS that goes through a tree of window containers and collects all      * the WindowStateProto-s.      *      * WindowContainer is generic class that can hold windows directly or through its children in a      * hierarchy form. WindowContainer's children are WindowContainer as well. This forms a tree of      * WindowContainers.      *      * There are a few classes that extend WindowContainer: Task, DisplayContent, WindowToken etc.      * The one we are interested in is WindowState.      * Since Proto does not have concept of inheritance, {@link TaskProto}, {@link WindowTokenProto}      * etc hold a reference to a {@link WindowContainerProto} (in java code would be {@code super}      * reference).      * {@link WindowContainerProto} may a have a number of children of type      * {@link WindowContainerChildProto}, which represents a generic child of a WindowContainer: a      * WindowContainer can have multiple children of different types stored as a      * {@link WindowContainerChildProto}, but each instance of {@link WindowContainerChildProto} can      * only contain a single type.      *      * For details see /frameworks/base/core/proto/android/server/windowmanagerservice.proto      */     private void collectWindowStates(WindowContainerProto windowContainer, List<WindowStateProto> out) {         if (windowContainer == null) return;          final List<WindowContainerChildProto> children = windowContainer.getChildrenList();         for (WindowContainerChildProto child : children) {             if (child.hasWindowContainer()) {                 collectWindowStates(child.getWindowContainer(), out);             } else if (child.hasDisplayContent()) {                 final DisplayContentProto displayContent = child.getDisplayContent();                 for (WindowTokenProto windowToken : displayContent.getOverlayWindowsList()) {                     collectWindowStates(windowToken.getWindowContainer(), out);                 }                 if (displayContent.hasRootDisplayArea()) {                     final DisplayAreaProto displayArea = displayContent.getRootDisplayArea();                     collectWindowStates(displayArea.getWindowContainer(), out);                 }                 collectWindowStates(displayContent.getWindowContainer(), out);             } else if (child.hasDisplayArea()) {                 final DisplayAreaProto displayArea = child.getDisplayArea();                 collectWindowStates(displayArea.getWindowContainer(), out);             } else if (child.hasTask()) {                 final TaskProto task = child.getTask();                 collectWindowStates(task.getWindowContainer(), out);             } else if (child.hasActivity()) {                 final ActivityRecordProto activity = child.getActivity();                 if (activity.hasWindowToken()) {                     final WindowTokenProto windowToken = activity.getWindowToken();                     collectWindowStates(windowToken.getWindowContainer(), out);                 }             } else if (child.hasWindowToken()) {                 final WindowTokenProto windowToken = child.getWindowToken();                 collectWindowStates(windowToken.getWindowContainer(), out);             } else if (child.hasWindow()) {                 final WindowStateProto window = child.getWindow();                 // We found a Window!                 out.add(window);                 // ... but still aren't done                 collectWindowStates(window.getWindowContainer(), out);             }         }     } }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.ConnectivityManagerTest"	"testOpenConnection"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"@SkipPresubmit(reason = ""Virtual devices use a single internet connection for all networks"")     public void testOpenConnection() throws Exception {         boolean canRunTest = mPackageManager.hasSystemFeature(FEATURE_WIFI)                 && mPackageManager.hasSystemFeature(FEATURE_TELEPHONY);         if (!canRunTest) {             Log.i(TAG,""testOpenConnection cannot execute unless device supports both WiFi ""                     + ""and a cellular connection"");             return;         }          Network wifiNetwork = mCtsNetUtils.connectToWifi();         Network cellNetwork = mCtsNetUtils.connectToCell();         // This server returns the requestor's IP address as the response body.         URL url = new URL(""http://google-ipv6test.appspot.com/ip.js?fmt=text"");         String wifiAddressString = httpGet(wifiNetwork, url);         String cellAddressString = httpGet(cellNetwork, url);          assertFalse(String.format(""Same address '%s' on two different networks (%s, %s)"",                 wifiAddressString, wifiNetwork, cellNetwork),                 wifiAddressString.equals(cellAddressString));          // Sanity check that the IP addresses that the requests appeared to come from         // are actually on the respective networks.         assertOnNetwork(wifiAddressString, wifiNetwork);         assertOnNetwork(cellAddressString, cellNetwork);          assertFalse(""Unexpectedly equal: "" + wifiNetwork, wifiNetwork.equals(cellNetwork));     }      /**      * Performs a HTTP GET to the specified URL on the specified Network, and returns      * the response body decoded as UTF-8.      */     private static String httpGet(Network network, URL httpUrl) throws IOException {         HttpURLConnection connection = (HttpURLConnection) network.openConnection(httpUrl);         try {             InputStream inputStream = connection.getInputStream();             return Streams.readFully(new InputStreamReader(inputStream, StandardCharsets.UTF_8));         } finally {             connection.disconnect();         }     }      private void assertOnNetwork(String adressString, Network network) throws UnknownHostException {         InetAddress address = InetAddress.getByName(adressString);         LinkProperties linkProperties = mCm.getLinkProperties(network);         // To make sure that the request went out on the right network, check that         // the IP address seen by the server is assigned to the expected network.         // We can only do this for IPv6 addresses, because in IPv4 we will likely         // have a private IPv4 address, and that won't match what the server sees.         if (address instanceof Inet6Address) {             assertContains(linkProperties.getAddresses(), address);         }     }      private static<T> void assertContains(Collection<T> collection, T element) {         assertTrue(element + "" not found in "" + collection, collection.contains(element));     }      private void assertStartUsingNetworkFeatureUnsupported(int networkType, String feature) {         try {             mCm.startUsingNetworkFeature(networkType, feature);             fail(""startUsingNetworkFeature is no longer supported in the current API version"");         } catch (UnsupportedOperationException expected) {}     }      private void assertStopUsingNetworkFeatureUnsupported(int networkType, String feature) {         try {             mCm.startUsingNetworkFeature(networkType, feature);             fail(""stopUsingNetworkFeature is no longer supported in the current API version"");         } catch (UnsupportedOperationException expected) {}     }      private void assertRequestRouteToHostUnsupported(int networkType, int hostAddress) {         try {             mCm.requestRouteToHost(networkType, hostAddress);             fail(""requestRouteToHost is no longer supported in the current API version"");         } catch (UnsupportedOperationException expected) {}     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.ConnectivityManagerTest"	"testCreateTcpKeepalive"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"@SkipPresubmit(reason = ""Keepalive is not supported on virtual hardware"")     public void testCreateTcpKeepalive() throws Exception {         if (!mPackageManager.hasSystemFeature(FEATURE_WIFI)) {             Log.i(TAG, ""testCreateTcpKeepalive cannot execute unless device supports WiFi"");             return;         }          final Network network = ensureWifiConnected();         if (getSupportedKeepalivesForNet(network) == 0) return;         final InetAddress srcAddr = getFirstV4Address(network);         assumeTrue(""This test requires native IPv4"", srcAddr != null);          // If kernel < 4.8 then it doesn't support TCP keepalive, but it might still support         // NAT-T keepalive. If keepalive limits from resource overlay is not zero, TCP keepalive         // needs to be supported except if the kernel doesn't support it.         if (!isTcpKeepaliveSupportedByKernel()) {             // Sanity check to ensure the callback result is expected.             runWithShellPermissionIdentity(() -> {                 assertEquals(0, createConcurrentSocketKeepalives(network, srcAddr, 0, 1));             });             Log.i(TAG, ""testCreateTcpKeepalive is skipped for kernel ""                     + VintfRuntimeInfo.getKernelVersion());             return;         }          final byte[] requestBytes = CtsNetUtils.HTTP_REQUEST.getBytes(""UTF-8"");         // So far only ipv4 tcp keepalive offload is supported.         // TODO: add test case for ipv6 tcp keepalive offload when it is supported.         try (Socket s = getConnectedSocket(network, TEST_HOST, HTTP_PORT, AF_INET)) {              // Should able to start keep alive offload when socket is idle.             final Executor executor = mContext.getMainExecutor();             final TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback();              mUiAutomation.adoptShellPermissionIdentity();             try (SocketKeepalive sk = mCm.createSocketKeepalive(network, s, executor, callback)) {                 sk.start(MIN_KEEPALIVE_INTERVAL);                 callback.expectStarted();                  // App should not able to write during keepalive offload.                 final OutputStream out = s.getOutputStream();                 try {                     out.write(requestBytes);                     fail(""Should not able to write"");                 } catch (IOException e) { }                 // App should not able to read during keepalive offload.                 final InputStream in = s.getInputStream();                 byte[] responseBytes = new byte[4096];                 try {                     in.read(responseBytes);                     fail(""Should not able to read"");                 } catch (IOException e) { }                  // Stop.                 sk.stop();                 callback.expectStopped();             } finally {                 mUiAutomation.dropShellPermissionIdentity();             }              // Ensure socket is still connected.             assertTrue(s.isConnected());             assertFalse(s.isClosed());              // Let socket be not idle.             try {                 final OutputStream out = s.getOutputStream();                 out.write(requestBytes);             } catch (IOException e) {                 fail(""Failed to write data "" + e);             }             // Make sure response data arrives.             final MessageQueue fdHandlerQueue = Looper.getMainLooper().getQueue();             final FileDescriptor fd = s.getFileDescriptor$();             final CountDownLatch mOnReceiveLatch = new CountDownLatch(1);             fdHandlerQueue.addOnFileDescriptorEventListener(fd, EVENT_INPUT, (readyFd, events) -> {                 mOnReceiveLatch.countDown();                 return 0; // Unregister listener.             });             if (!mOnReceiveLatch.await(2, TimeUnit.SECONDS)) {                 fdHandlerQueue.removeOnFileDescriptorEventListener(fd);                 fail(""Timeout: no response data"");             }              // Should get ERROR_SOCKET_NOT_IDLE because there is still data in the receive queue             // that has not been read.             mUiAutomation.adoptShellPermissionIdentity();             try (SocketKeepalive sk = mCm.createSocketKeepalive(network, s, executor, callback)) {                 sk.start(MIN_KEEPALIVE_INTERVAL);                 callback.expectError(SocketKeepalive.ERROR_SOCKET_NOT_IDLE);             } finally {                 mUiAutomation.dropShellPermissionIdentity();             }         }     }      private ArrayList<SocketKeepalive> createConcurrentKeepalivesOfType(             int requestCount, @NonNull TestSocketKeepaliveCallback callback,             Supplier<SocketKeepalive> kaFactory) {         final ArrayList<SocketKeepalive> kalist = new ArrayList<>();          int remainingRetries = MAX_KEEPALIVE_RETRY_COUNT;          // Test concurrent keepalives with the given supplier.         while (kalist.size() < requestCount) {             final SocketKeepalive ka = kaFactory.get();             ka.start(MIN_KEEPALIVE_INTERVAL);             TestSocketKeepaliveCallback.CallbackValue cv = callback.pollCallback();             assertNotNull(cv);             if (cv.callbackType == TestSocketKeepaliveCallback.CallbackType.ON_ERROR) {                 if (kalist.size() == 0 && cv.error == SocketKeepalive.ERROR_UNSUPPORTED) {                     // Unsupported.                     break;                 } else if (cv.error == SocketKeepalive.ERROR_INSUFFICIENT_RESOURCES) {                     // Limit reached or temporary unavailable due to stopped slot is not yet                     // released.                     if (remainingRetries > 0) {                         SystemClock.sleep(INTERVAL_KEEPALIVE_RETRY_MS);                         remainingRetries--;                         continue;                     }                     break;                 }             }             if (cv.callbackType == TestSocketKeepaliveCallback.CallbackType.ON_STARTED) {                 kalist.add(ka);             } else {                 fail(""Unexpected error when creating "" + (kalist.size() + 1) + "" ""                         + ka.getClass().getSimpleName() + "": "" + cv);             }         }          return kalist;     }      private @NonNull ArrayList<SocketKeepalive> createConcurrentNattSocketKeepalives(             @NonNull Network network, @NonNull InetAddress srcAddr, int requestCount,             @NonNull TestSocketKeepaliveCallback callback)  throws Exception {          final Executor executor = mContext.getMainExecutor();          // Initialize a real NaT-T socket.         final IpSecManager mIpSec = (IpSecManager) mContext.getSystemService(Context.IPSEC_SERVICE);         final UdpEncapsulationSocket nattSocket = mIpSec.openUdpEncapsulationSocket();         final InetAddress dstAddr = getAddrByName(TEST_HOST, AF_INET);         assertNotNull(srcAddr);         assertNotNull(dstAddr);          // Test concurrent Nat-T keepalives.         try {             return createConcurrentKeepalivesOfType(requestCount,                     callback, () -> mCm.createSocketKeepalive(network, nattSocket,                             srcAddr, dstAddr, executor, callback));         } finally {             nattSocket.close();         }     }      private @NonNull ArrayList<SocketKeepalive> createConcurrentTcpSocketKeepalives(             @NonNull Network network, int requestCount,             @NonNull TestSocketKeepaliveCallback callback) {         final Executor executor = mContext.getMainExecutor();          // Create concurrent TCP keepalives.         return createConcurrentKeepalivesOfType(requestCount, callback, () -> {             // Assert that TCP connections can be established. The file descriptor of tcp             // sockets will be duplicated and kept valid in service side if the keepalives are             // successfully started.             try (Socket tcpSocket = getConnectedSocket(network, TEST_HOST, HTTP_PORT,                     AF_INET)) {                 return mCm.createSocketKeepalive(network, tcpSocket, executor, callback);             } catch (Exception e) {                 fail(""Unexpected error when creating TCP socket: "" + e);             }             return null;         });     }      /**      * Creates concurrent keepalives until the specified counts of each type of keepalives are      * reached or the expected error callbacks are received for each type of keepalives.      *      * @return the total number of keepalives created.      */     private int createConcurrentSocketKeepalives(             @NonNull Network network, @NonNull InetAddress srcAddr, int nattCount, int tcpCount)             throws Exception {         final ArrayList<SocketKeepalive> kalist = new ArrayList<>();         final TestSocketKeepaliveCallback callback = new TestSocketKeepaliveCallback();          kalist.addAll(createConcurrentNattSocketKeepalives(network, srcAddr, nattCount, callback));         kalist.addAll(createConcurrentTcpSocketKeepalives(network, tcpCount, callback));          final int ret = kalist.size();          // Clean up.         for (final SocketKeepalive ka : kalist) {             ka.stop();             callback.expectStopped();         }         kalist.clear();          return ret;     }      /**      * Verifies that the concurrent keepalive slots meet the minimum requirement, and don't      * get leaked after iterations.      */     @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.media.cts.VideoCodecTest"	"testBasic"	"CtsMediaTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"simultaneously"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/VideoCodecTest.java"	""	"public void test/*  *.  */  package android.media.cts;  import android.media.MediaCodec; import android.media.MediaCodecInfo; import android.media.MediaCodecList; import android.media.MediaFormat; import android.platform.test.annotations.AppModeFull; import android.util.Log; import android.media.cts.R;  import java.io.File; import java.nio.ByteBuffer; import java.util.ArrayList; import java.util.Arrays;  /**  * Verification test for video encoder and decoder.  *  * A raw yv12 stream is encoded at various settings and written to an IVF  * file. Encoded stream bitrate and key frame interval are checked against target values.  * The stream is later decoded by video decoder to verify frames are decodable and to  * calculate PSNR values for various bitrates.  */ @MediaHeavyPresubmitTest @AppModeFull(reason = ""TODO: evaluate and port to instant"") public class VideoCodecTest extends VideoCodecTestBase {      private static final String ENCODED_IVF_BASE = ""football"";     private static final String INPUT_YUV = null;     private static final String OUTPUT_YUV = SDCARD_DIR + File.separator +             ENCODED_IVF_BASE + ""_out.yuv"";      // YUV stream properties.     private static final int WIDTH = 320;     private static final int HEIGHT = 240;     private static final int FPS = 30;     // Default encoding bitrate.     private static final int BITRATE = 400000;     // List of bitrates used in quality and basic bitrate tests.     private static final int[] TEST_BITRATES_SET = { 300000, 500000, 700000, 900000 };     // Maximum allowed bitrate variation from the target value.     // Keep in sync with the variation at libmediandkjni/native_media_utils.h     private static final double MAX_BITRATE_VARIATION = 0.2;     // Average PSNR values for reference Google Video codec for the above bitrates.     private static final double[] REFERENCE_AVERAGE_PSNR = { 33.1, 35.2, 36.6, 37.8 };     // Minimum PSNR values for reference Google Video codec for the above bitrates.     private static final double[] REFERENCE_MINIMUM_PSNR = { 25.9, 27.5, 28.4, 30.3 };     // Maximum allowed average PSNR difference of encoder comparing to reference Google encoder.     private static final double MAX_AVERAGE_PSNR_DIFFERENCE = 2;     // Maximum allowed minimum PSNR difference of encoder comparing to reference Google encoder.     private static final double MAX_MINIMUM_PSNR_DIFFERENCE = 4;     // Maximum allowed average PSNR difference of the encoder running in a looper thread with 0 ms     // buffer dequeue timeout comparing to the encoder running in a callee's thread with 100 ms     // buffer dequeue timeout.     private static final double MAX_ASYNC_AVERAGE_PSNR_DIFFERENCE = 1.5;     // Maximum allowed minimum PSNR difference of the encoder running in a looper thread     // comparing to the encoder running in a callee's thread.     private static final double MAX_ASYNC_MINIMUM_PSNR_DIFFERENCE = 2;     // Maximum allowed average key frame interval variation from the target value.     private static final int MAX_AVERAGE_KEYFRAME_INTERVAL_VARIATION = 1;     // Maximum allowed key frame interval variation from the target value.     private static final int MAX_KEYFRAME_INTERVAL_VARIATION = 3;      /**      * A basic test for Video encoder.      *      * Encodes 9 seconds of raw stream with default configuration options,      * and then decodes it to verify the bitstream.      * Also checks the average bitrate is within MAX_BITRATE_VARIATION of the target value.      */     private void internalTestBasic(String codecMimeType, int bitRateMode) throws Exception {         int encodeSeconds = 9;         boolean skipped = true;          for (int targetBitrate : TEST_BITRATES_SET) {             EncoderOutputStreamParameters params = getDefaultEncodingParameters(                     INPUT_YUV,                     ENCODED_IVF_BASE,                     codecMimeType,                     encodeSeconds,                     WIDTH,                     HEIGHT,                     FPS,                     bitRateMode,                     targetBitrate,                     true);             ArrayList<ByteBuffer> codecConfigs = new ArrayList<>();             ArrayList<MediaCodec.BufferInfo> bufInfo = encode(params, codecConfigs);             if (bufInfo == null) {                 continue;             }             skipped = false;              VideoEncodingStatistics statistics = computeEncodingStatistics(bufInfo);              /* Allow achieved bitrate to be smaller than target bitrate for              * VIDEO_ControlRateVariable mode */             if ((params.bitrateType == VIDEO_ControlRateConstant) ||                 (statistics.mAverageBitrate > targetBitrate)) {                 assertEquals(""Stream bitrate "" + statistics.mAverageBitrate +                     "" is different from the target "" + targetBitrate,                     targetBitrate, statistics.mAverageBitrate,                     MAX_BITRATE_VARIATION * targetBitrate);             }              decode(params.outputIvfFilename, null, codecMimeType, FPS,                     params.forceGoogleEncoder, codecConfigs);         }          if (skipped) {             Log.i(TAG, ""SKIPPING testBasic(): codec is not supported"");         }     }      /**      * Asynchronous encoding test for Video encoder.      *      * Encodes 9 seconds of raw stream using synchronous and asynchronous calls.      * Checks the PSNR difference between the encoded and decoded output and reference yuv input      * does not change much for two different ways of the encoder call.      */     private void internalTestAsyncEncoding(String codecMimeType, int bitRateMode) throws Exception {         int encodeSeconds = 9;          // First test the encoder running in a looper thread with buffer callbacks enabled.         boolean syncEncoding = false;         EncoderOutputStreamParameters params = getDefaultEncodingParameters(                 INPUT_YUV,                 ENCODED_IVF_BASE,                 codecMimeType,                 encodeSeconds,                 WIDTH,                 HEIGHT,                 FPS,                 bitRateMode,                 BITRATE,                 syncEncoding);         ArrayList<ByteBuffer> codecConfigs = new ArrayList<>();         ArrayList<MediaCodec.BufferInfo> bufInfos = encodeAsync(params, codecConfigs);         if (bufInfos == null) {             Log.i(TAG, ""SKIPPING testAsyncEncoding(): no suitable encoder found"");             return;         }         computeEncodingStatistics(bufInfos);         decode(params.outputIvfFilename, OUTPUT_YUV, codecMimeType, FPS,                 params.forceGoogleEncoder, codecConfigs);         VideoDecodingStatistics statisticsAsync = computeDecodingStatistics(                 params.inputYuvFilename, R.raw.football_qvga, OUTPUT_YUV,                 params.frameWidth, params.frameHeight);           // Test the encoder running in a callee's thread.         syncEncoding = true;         params = getDefaultEncodingParameters(                 INPUT_YUV,                 ENCODED_IVF_BASE,                 codecMimeType,                 encodeSeconds,                 WIDTH,                 HEIGHT,                 FPS,                 bitRateMode,                 BITRATE,                 syncEncoding);         codecConfigs.clear();         bufInfos = encode(params, codecConfigs);         if (bufInfos == null) {             Log.i(TAG, ""SKIPPING testAsyncEncoding(): no suitable encoder found"");             return;         }         computeEncodingStatistics(bufInfos);         decode(params.outputIvfFilename, OUTPUT_YUV, codecMimeType, FPS,                 params.forceGoogleEncoder, codecConfigs);         VideoDecodingStatistics statisticsSync = computeDecodingStatistics(                 params.inputYuvFilename, R.raw.football_qvga, OUTPUT_YUV,                 params.frameWidth, params.frameHeight);          // Check PSNR difference.         Log.d(TAG, ""PSNR Average: Async: "" + statisticsAsync.mAveragePSNR +                 "". Sync: "" + statisticsSync.mAveragePSNR);         Log.d(TAG, ""PSNR Minimum: Async: "" + statisticsAsync.mMinimumPSNR +                 "". Sync: "" + statisticsSync.mMinimumPSNR);         if ((Math.abs(statisticsAsync.mAveragePSNR - statisticsSync.mAveragePSNR) >             MAX_ASYNC_AVERAGE_PSNR_DIFFERENCE) ||             (Math.abs(statisticsAsync.mMinimumPSNR - statisticsSync.mMinimumPSNR) >             MAX_ASYNC_MINIMUM_PSNR_DIFFERENCE)) {             throw new RuntimeException(""Difference between PSNRs for async and sync encoders"");         }     }      /**      * Check if MediaCodec.PARAMETER_KEY_REQUEST_SYNC_FRAME is honored.      *      * Encodes 9 seconds of raw stream and requests a sync frame every second (30 frames).      * The test does not verify the output stream.      */     private void internalTestSyncFrame(             String codecMimeType, int bitRateMode, boolean useNdk) throws Exception {         int encodeSeconds = 9;          EncoderOutputStreamParameters params = getDefaultEncodingParameters(                 INPUT_YUV,                 ENCODED_IVF_BASE,                 codecMimeType,                 encodeSeconds,                 WIDTH,                 HEIGHT,                 FPS,                 bitRateMode,                 BITRATE,                 true);         params.syncFrameInterval = encodeSeconds * FPS;         params.syncForceFrameInterval = FPS;         params.useNdk = useNdk;         ArrayList<MediaCodec.BufferInfo> bufInfo = encode(params);         if (bufInfo == null) {             Log.i(TAG, ""SKIPPING testSyncFrame(): no suitable encoder found"");             return;         }          VideoEncodingStatistics statistics = computeEncodingStatistics(bufInfo);          // First check if we got expected number of key frames.         int actualKeyFrames = statistics.mKeyFrames.size();         if (actualKeyFrames != encodeSeconds) {             throw new RuntimeException(""Number of key frames "" + actualKeyFrames +                     "" is different from the expected "" + encodeSeconds);         }          // Check key frame intervals:         // Average value should be within +/- 1 frame of the target value,         // maximum value should not be greater than target value + 3,         // and minimum value should not be less that target value - 3.         if (Math.abs(statistics.mAverageKeyFrameInterval - FPS) >             MAX_AVERAGE_KEYFRAME_INTERVAL_VARIATION ||             (statistics.mMaximumKeyFrameInterval - FPS > MAX_KEYFRAME_INTERVAL_VARIATION) ||             (FPS - statistics.mMinimumKeyFrameInterval > MAX_KEYFRAME_INTERVAL_VARIATION)) {             throw new RuntimeException(                     ""Key frame intervals are different from the expected "" + FPS);         }     }      /**      * Check if MediaCodec.PARAMETER_KEY_VIDEO_BITRATE is honored.      *      * Run the the encoder for 12 seconds. Request changes to the      * bitrate after 6 seconds and ensure the encoder responds.      */     private void internalTestDynamicBitrateChange(             String codecMimeType, int bitRateMode, boolean useNdk) throws Exception {         int encodeSeconds = 12;    // Encoding sequence duration in seconds.         int[] bitrateTargetValues = { 400000, 800000 };  // List of bitrates to test.          EncoderOutputStreamParameters params = getDefaultEncodingParameters(                 INPUT_YUV,                 ENCODED_IVF_BASE,                 codecMimeType,                 encodeSeconds,                 WIDTH,                 HEIGHT,                 FPS,                 bitRateMode,                 bitrateTargetValues[0],                 true);          // Number of seconds for each bitrate         int stepSeconds = encodeSeconds / bitrateTargetValues.length;         // Fill the bitrates values.         params.bitrateSet = new int[encodeSeconds * FPS];         for (int i = 0; i < bitrateTargetValues.length ; i++) {             Arrays.fill(params.bitrateSet,                     i * encodeSeconds * FPS / bitrateTargetValues.length,                     (i + 1) * encodeSeconds * FPS / bitrateTargetValues.length,                     bitrateTargetValues[i]);         }          params.useNdk = useNdk;         ArrayList<MediaCodec.BufferInfo> bufInfo = encode(params);         if (bufInfo == null) {             Log.i(TAG, ""SKIPPING testDynamicBitrateChange(): no suitable encoder found"");             return;         }          VideoEncodingStatistics statistics = computeEncodingStatistics(bufInfo);          // Calculate actual average bitrates  for every [stepSeconds] second.         int[] bitrateActualValues = new int[bitrateTargetValues.length];         for (int i = 0; i < bitrateTargetValues.length ; i++) {             bitrateActualValues[i] = 0;             for (int j = i * stepSeconds; j < (i + 1) * stepSeconds; j++) {                 bitrateActualValues[i] += statistics.mBitrates.get(j);             }             bitrateActualValues[i] /= stepSeconds;             Log.d(TAG, ""Actual bitrate for interval #"" + i + "" : "" + bitrateActualValues[i] +                     "". Target: "" + bitrateTargetValues[i]);              // Compare actual bitrate values to make sure at least same increasing/decreasing             // order as the target bitrate values.             for (int j = 0; j < i; j++) {                 long differenceTarget = bitrateTargetValues[i] - bitrateTargetValues[j];                 long differenceActual = bitrateActualValues[i] - bitrateActualValues[j];                 if (differenceTarget * differenceActual < 0) {                     throw new RuntimeException(""Target bitrates: "" +                             bitrateTargetValues[j] + "" , "" + bitrateTargetValues[i] +                             "". Actual bitrates: ""                             + bitrateActualValues[j] + "" , "" + bitrateActualValues[i]);                 }             }         }     }       /**       * Check if encoder and decoder can run simultaneously on different threads.       *       * Encodes and decodes 9 seconds of raw stream sequentially in CBR mode,       * and then run parallel encoding and decoding of the same streams.       * Compares average bitrate and PSNR for sequential and parallel runs.       */      private void internalTestParallelEncodingAndDecoding(String codecMimeType) throws Exception {          // check for encoder up front, as by the time we detect lack of          // encoder support, we may have already started decoding.          MediaCodecList mcl = new MediaCodecList(MediaCodecList.REGULAR_CODECS);          MediaFormat format = MediaFormat.createVideoFormat(codecMimeType, WIDTH, HEIGHT);          if (mcl.findEncoderForFormat(format) == null) {              Log.i(TAG, ""SKIPPING testParallelEncodingAndDecoding(): no suitable encoder found"");              return;          }           int encodeSeconds = 9;          final int[] bitrate = new int[1];          final double[] psnr = new double[1];          final Exception[] exceptionEncoder = new Exception[1];          final Exception[] exceptionDecoder = new Exception[1];          final EncoderOutputStreamParameters params = getDefaultEncodingParameters(                  INPUT_YUV,                  ENCODED_IVF_BASE,                  codecMimeType,                  encodeSeconds,                  WIDTH,                  HEIGHT,                  FPS,                  VIDEO_ControlRateConstant,                  BITRATE,                  true);          final String inputIvfFilename = params.outputIvfFilename;          final ArrayList<ByteBuffer> codecConfigs = new ArrayList<>();           Runnable runEncoder = new Runnable() {              public void run() {                  try {                      ArrayList<MediaCodec.BufferInfo> bufInfo;                      if (codecConfigs.isEmpty()) {                          bufInfo = encode(params, codecConfigs);                      } else {                          bufInfo = encode(params);                      }                      VideoEncodingStatistics statistics = computeEncodingStatistics(bufInfo);                      bitrate[0] = statistics.mAverageBitrate;                  } catch (Exception e) {                      Log.e(TAG, ""Encoder error: "" + e.toString());                      exceptionEncoder[0] = e;                  }              }          };          Runnable runDecoder = new Runnable() {              public void run() {                  try {                      decode(inputIvfFilename, OUTPUT_YUV, codecMimeType, FPS,                             params.forceGoogleEncoder, codecConfigs);                      VideoDecodingStatistics statistics = computeDecodingStatistics(                             params.inputYuvFilename, R.raw.football_qvga, OUTPUT_YUV,                             params.frameWidth, params.frameHeight);                      psnr[0] = statistics.mAveragePSNR;                  } catch (Exception e) {                      Log.e(TAG, ""Decoder error: "" + e.toString());                      exceptionDecoder[0] = e;                  }              }          };           // Sequential encoding and decoding.          runEncoder.run();          if (exceptionEncoder[0] != null) {              throw exceptionEncoder[0];          }          int referenceBitrate = bitrate[0];          runDecoder.run();          if (exceptionDecoder[0] != null) {              throw exceptionDecoder[0];          }          double referencePsnr = psnr[0];           // Parallel encoding and decoding.          params.outputIvfFilename = SDCARD_DIR + File.separator + ENCODED_IVF_BASE + ""_copy.ivf"";          Thread threadEncoder = new Thread(runEncoder);          Thread threadDecoder = new Thread(runDecoder);          threadEncoder.start();          threadDecoder.start();          threadEncoder.join();          threadDecoder.join();          if (exceptionEncoder[0] != null) {              throw exceptionEncoder[0];          }          if (exceptionDecoder[0] != null) {              throw exceptionDecoder[0];          }           // Compare bitrates and PSNRs for sequential and parallel cases.          Log.d(TAG, ""Sequential bitrate: "" + referenceBitrate + "". PSNR: "" + referencePsnr);          Log.d(TAG, ""Parallel bitrate: "" + bitrate[0] + "". PSNR: "" + psnr[0]);          assertEquals(""Bitrate for sequenatial encoding"" + referenceBitrate +                  "" is different from parallel encoding "" + bitrate[0],                  referenceBitrate, bitrate[0], MAX_BITRATE_VARIATION * referenceBitrate);          assertEquals(""PSNR for sequenatial encoding"" + referencePsnr +                  "" is different from parallel encoding "" + psnr[0],                  referencePsnr, psnr[0], MAX_ASYNC_AVERAGE_PSNR_DIFFERENCE);      }       /**      * Check the encoder quality for various bitrates by calculating PSNR      *      * Run the the encoder for 9 seconds for each bitrate and calculate PSNR      * for each encoded stream.      * Video streams with higher bitrates should have higher PSNRs.      * Also compares average and minimum PSNR of codec with PSNR values of reference Google codec.      */     private void internalTestEncoderQuality(String codecMimeType, int bitRateMode)             throws Exception {         int encodeSeconds = 9;      // Encoding sequence duration in seconds for each bitrate.         double[] psnrPlatformCodecAverage = new double[TEST_BITRATES_SET.length];         double[] psnrPlatformCodecMin = new double[TEST_BITRATES_SET.length];         boolean[] completed = new boolean[TEST_BITRATES_SET.length];         boolean skipped = true;          // Run platform specific encoder for different bitrates         // and compare PSNR of codec with PSNR of reference Google codec.         for (int i = 0; i < TEST_BITRATES_SET.length; i++) {             EncoderOutputStreamParameters params = getDefaultEncodingParameters(                     INPUT_YUV,                     ENCODED_IVF_BASE,                     codecMimeType,                     encodeSeconds,                     WIDTH,                     HEIGHT,                     FPS,                     bitRateMode,                     TEST_BITRATES_SET[i],                     true);             ArrayList<ByteBuffer> codecConfigs = new ArrayList<>();             if (encode(params, codecConfigs) == null) {                 // parameters not supported, try other bitrates                 completed[i] = false;                 continue;             }             completed[i] = true;             skipped = false;              decode(params.outputIvfFilename, OUTPUT_YUV, codecMimeType, FPS,                     params.forceGoogleEncoder, codecConfigs);             VideoDecodingStatistics statistics = computeDecodingStatistics(                     params.inputYuvFilename, R.raw.football_qvga, OUTPUT_YUV,                     params.frameWidth, params.frameHeight);             psnrPlatformCodecAverage[i] = statistics.mAveragePSNR;             psnrPlatformCodecMin[i] = statistics.mMinimumPSNR;         }          if (skipped) {             Log.i(TAG, ""SKIPPING testEncoderQuality(): no bitrates supported"");             return;         }          // First do a sanity check - higher bitrates should results in higher PSNR.         for (int i = 1; i < TEST_BITRATES_SET.length ; i++) {             if (!completed[i]) {                 continue;             }             for (int j = 0; j < i; j++) {                 if (!completed[j]) {                     continue;                 }                 double differenceBitrate = TEST_BITRATES_SET[i] - TEST_BITRATES_SET[j];                 double differencePSNR = psnrPlatformCodecAverage[i] - psnrPlatformCodecAverage[j];                 if (differenceBitrate * differencePSNR < 0) {                     throw new RuntimeException(""Target bitrates: "" +                             TEST_BITRATES_SET[j] + "", "" + TEST_BITRATES_SET[i] +                             "". Actual PSNRs: ""                             + psnrPlatformCodecAverage[j] + "", "" + psnrPlatformCodecAverage[i]);                 }             }         }          // Then compare average and minimum PSNR of platform codec with reference Google codec -         // average PSNR for platform codec should be no more than 2 dB less than reference PSNR         // and minumum PSNR - no more than 4 dB less than reference minimum PSNR.         // These PSNR difference numbers are arbitrary for now, will need further estimation         // when more devices with HW video codec will appear.         for (int i = 0; i < TEST_BITRATES_SET.length ; i++) {             if (!completed[i]) {                 continue;             }              Log.d(TAG, ""Bitrate "" + TEST_BITRATES_SET[i]);             Log.d(TAG, ""Reference: Average: "" + REFERENCE_AVERAGE_PSNR[i] + "". Minimum: "" +                     REFERENCE_MINIMUM_PSNR[i]);             Log.d(TAG, ""Platform:  Average: "" + psnrPlatformCodecAverage[i] + "". Minimum: "" +                     psnrPlatformCodecMin[i]);             if (psnrPlatformCodecAverage[i] < REFERENCE_AVERAGE_PSNR[i] -                     MAX_AVERAGE_PSNR_DIFFERENCE) {                 throw new RuntimeException(""Low average PSNR "" + psnrPlatformCodecAverage[i] +                         "" comparing to reference PSNR "" + REFERENCE_AVERAGE_PSNR[i] +                         "" for bitrate "" + TEST_BITRATES_SET[i]);             }             if (psnrPlatformCodecMin[i] < REFERENCE_MINIMUM_PSNR[i] -                     MAX_MINIMUM_PSNR_DIFFERENCE) {                 throw new RuntimeException(""Low minimum PSNR "" + psnrPlatformCodecMin[i] +                         "" comparing to reference PSNR "" + REFERENCE_MINIMUM_PSNR[i] +                         "" for bitrate "" + TEST_BITRATES_SET[i]);             }         }     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.hardware.camera2.cts.ImageReaderTest"	"testUsageRespected"	"CtsCameraTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"simultaneously"	""	""	""	"/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ImageReaderTest.java"	""	"public void testUsageRespected() throws Exception {         ImageReader reader = ImageReader.newInstance(1, 1, PixelFormat.RGBA_8888, 1,                 HardwareBuffer.USAGE_GPU_COLOR_OUTPUT | HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE);         Surface surface = reader.getSurface();         Canvas canvas = surface.lockHardwareCanvas();         canvas.drawColor(Color.RED);         surface.unlockCanvasAndPost(canvas);         Image image = null;         for (int i = 0; i < 100; i++) {             image = reader.acquireNextImage();             if (image != null) break;             Thread.sleep(10);         }         assertNotNull(image);         HardwareBuffer buffer = image.getHardwareBuffer();         assertNotNull(buffer);         // Mask off the upper vendor bits         int myBits = (int) (buffer.getUsage() & 0xFFFFFFF);         assertEquals(HardwareBuffer.USAGE_GPU_COLOR_OUTPUT | HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE,                 myBits);     }      /**      * Convert a rectangular patch in a YUV image to an ARGB color array.      *      * @param w width of the patch.      * @param h height of the patch.      * @param wOffset offset of the left side of the patch.      * @param hOffset offset of the top of the patch.      * @param yuvImage a YUV image to select a patch from.      * @return the image patch converted to RGB as an ARGB color array.      */     private static int[] convertPixelYuvToRgba(int w, int h, int wOffset, int hOffset,                                                Image yuvImage) {         final int CHANNELS = 3; // yuv         final float COLOR_RANGE = 255f;          assertTrue(""Invalid argument to convertPixelYuvToRgba"",                 w > 0 && h > 0 && wOffset >= 0 && hOffset >= 0);         assertNotNull(yuvImage);          int imageFormat = yuvImage.getFormat();         assertTrue(""YUV image must have YUV-type format"",                 imageFormat == ImageFormat.YUV_420_888 || imageFormat == ImageFormat.YV12 ||                         imageFormat == ImageFormat.NV21);          int height = yuvImage.getHeight();         int width = yuvImage.getWidth();          Rect imageBounds = new Rect(/*left*/0, /*top*/0, /*right*/width, /*bottom*/height);         Rect crop = new Rect(/*left*/wOffset, /*top*/hOffset, /*right*/wOffset + w,                 /*bottom*/hOffset + h);         assertTrue(""Output rectangle"" + crop + "" must lie within image bounds "" + imageBounds,                 imageBounds.contains(crop));         Image.Plane[] planes = yuvImage.getPlanes();          Image.Plane yPlane = planes[0];         Image.Plane cbPlane = planes[1];         Image.Plane crPlane = planes[2];          ByteBuffer yBuf = yPlane.getBuffer();         int yPixStride = yPlane.getPixelStride();         int yRowStride = yPlane.getRowStride();         ByteBuffer cbBuf = cbPlane.getBuffer();         int cbPixStride = cbPlane.getPixelStride();         int cbRowStride = cbPlane.getRowStride();         ByteBuffer crBuf = crPlane.getBuffer();         int crPixStride = crPlane.getPixelStride();         int crRowStride = crPlane.getRowStride();          int[] output = new int[w * h];          // TODO: Optimize this with renderscript intrinsics         byte[] yRow = new byte[yPixStride * w];         byte[] cbRow = new byte[cbPixStride * w / 2];         byte[] crRow = new byte[crPixStride * w / 2];         yBuf.mark();         cbBuf.mark();         crBuf.mark();         int initialYPos = yBuf.position();         int initialCbPos = cbBuf.position();         int initialCrPos = crBuf.position();         int outputPos = 0;         for (int i = hOffset; i < hOffset + h; i++) {             yBuf.position(initialYPos + i * yRowStride + wOffset * yPixStride);             yBuf.get(yRow);             if ((i & 1) == (hOffset & 1)) {                 cbBuf.position(initialCbPos + (i / 2) * cbRowStride + wOffset * cbPixStride / 2);                 cbBuf.get(cbRow);                 crBuf.position(initialCrPos + (i / 2) * crRowStride + wOffset * crPixStride / 2);                 crBuf.get(crRow);             }             for (int j = 0, yPix = 0, crPix = 0, cbPix = 0; j < w; j++, yPix += yPixStride) {                 float y = yRow[yPix] & 0xFF;                 float cb = cbRow[cbPix] & 0xFF;                 float cr = crRow[crPix] & 0xFF;                  // convert YUV -> RGB (from JFIF's ""Conversion to and from RGB"" section)                 int r = (int) Math.max(0.0f, Math.min(COLOR_RANGE, y + 1.402f * (cr - 128)));                 int g = (int) Math.max(0.0f,                         Math.min(COLOR_RANGE, y - 0.34414f * (cb - 128) - 0.71414f * (cr - 128)));                 int b = (int) Math.max(0.0f, Math.min(COLOR_RANGE, y + 1.772f * (cb - 128)));                  // Convert to ARGB pixel color (use opaque alpha)                 output[outputPos++] = Color.rgb(r, g, b);                  if ((j & 1) == 1) {                     crPix += crPixStride;                     cbPix += cbPixStride;                 }             }         }         yBuf.rewind();         cbBuf.rewind();         crBuf.rewind();          return output;     }      /**      * Test capture a given format stream with yuv stream simultaneously.      *      * <p>Use fixed yuv size, varies targeted format capture size. Single capture is tested.</p>      *      * @param format The capture format to be tested along with yuv format.      */     private void bufferFormatWithYuvTestByCamera(int format) throws Exception {         bufferFormatWithYuvTestByCamera(format, false);     }      /**      * Test capture a given format stream with yuv stream simultaneously.      *      * <p>Use fixed yuv size, varies targeted format capture size. Single capture is tested.</p>      *      * @param format The capture format to be tested along with yuv format.      * @param setUsageFlag The ImageReader factory method to be used (with or without specifying      *                     usage flag)      */     private void bufferFormatWithYuvTestByCamera(int format, boolean setUsageFlag)             throws Exception {         if (format != ImageFormat.JPEG && format != ImageFormat.RAW_SENSOR                 && format != ImageFormat.YUV_420_888) {             throw new IllegalArgumentException(""Unsupported format: "" + format);         }          final int NUM_SINGLE_CAPTURE_TESTED = MAX_NUM_IMAGES - 1;         Size maxYuvSz = mOrderedPreviewSizes.get(0);         Size[] targetCaptureSizes = mStaticInfo.getAvailableSizesForFormatChecked(format,                 StaticMetadata.StreamDirection.Output);          for (Size captureSz : targetCaptureSizes) {             if (VERBOSE) {                 Log.v(TAG, ""Testing yuv size "" + maxYuvSz.toString() + "" and capture size ""                         + captureSz.toString() + "" for camera "" + mCamera.getId());             }              ImageReader captureReader = null;             ImageReader yuvReader = null;             try {                 // Create YUV image reader                 SimpleImageReaderListener yuvListener  = new SimpleImageReaderListener();                 if (setUsageFlag) {                     yuvReader = createImageReader(maxYuvSz, ImageFormat.YUV_420_888, MAX_NUM_IMAGES,                             HardwareBuffer.USAGE_CPU_READ_OFTEN, yuvListener);                 } else {                     yuvReader = createImageReader(maxYuvSz, ImageFormat.YUV_420_888, MAX_NUM_IMAGES,                             yuvListener);                 }                  Surface yuvSurface = yuvReader.getSurface();                  // Create capture image reader                 SimpleImageReaderListener captureListener = new SimpleImageReaderListener();                 if (setUsageFlag) {                     captureReader = createImageReader(captureSz, format, MAX_NUM_IMAGES,                             HardwareBuffer.USAGE_CPU_READ_OFTEN, captureListener);                 } else {                     captureReader = createImageReader(captureSz, format, MAX_NUM_IMAGES,                             captureListener);                 }                 Surface captureSurface = captureReader.getSurface();                  // Capture images.                 List<Surface> outputSurfaces = new ArrayList<Surface>();                 outputSurfaces.add(yuvSurface);                 outputSurfaces.add(captureSurface);                 CaptureRequest.Builder request = prepareCaptureRequestForSurfaces(outputSurfaces,                         CameraDevice.TEMPLATE_PREVIEW);                 SimpleCaptureCallback resultListener = new SimpleCaptureCallback();                  for (int i = 0; i < NUM_SINGLE_CAPTURE_TESTED; i++) {                     startCapture(request.build(), /*repeating*/false, resultListener, mHandler);                 }                  // Verify capture result and images                 for (int i = 0; i < NUM_SINGLE_CAPTURE_TESTED; i++) {                     resultListener.getCaptureResult(CAPTURE_WAIT_TIMEOUT_MS);                     if (VERBOSE) {                         Log.v(TAG, "" Got the capture result back for "" + i + ""th capture"");                     }                      Image yuvImage = yuvListener.getImage(CAPTURE_WAIT_TIMEOUT_MS);                     if (VERBOSE) {                         Log.v(TAG, "" Got the yuv image back for "" + i + ""th capture"");                     }                      Image captureImage = captureListener.getImage(CAPTURE_WAIT_TIMEOUT_MS);                     if (VERBOSE) {                         Log.v(TAG, "" Got the capture image back for "" + i + ""th capture"");                     }                      //Validate captured images.                     CameraTestUtils.validateImage(yuvImage, maxYuvSz.getWidth(),                             maxYuvSz.getHeight(), ImageFormat.YUV_420_888, /*filePath*/null);                     CameraTestUtils.validateImage(captureImage, captureSz.getWidth(),                             captureSz.getHeight(), format, /*filePath*/null);                     yuvImage.close();                     captureImage.close();                 }                  // Stop capture, delete the streams.                 stopCapture(/*fast*/false);             } finally {                 closeImageReader(captureReader);                 captureReader = null;                 closeImageReader(yuvReader);                 yuvReader = null;             }         }     }      private void invalidAccessTestAfterClose() throws Exception {         final int FORMAT = mStaticInfo.isColorOutputSupported() ?             ImageFormat.YUV_420_888 : ImageFormat.DEPTH16;          Size[] availableSizes = mStaticInfo.getAvailableSizesForFormatChecked(FORMAT,                 StaticMetadata.StreamDirection.Output);         Image img = null;         // Create ImageReader.         mListener = new SimpleImageListener();         createDefaultImageReader(availableSizes[0], FORMAT, MAX_NUM_IMAGES, mListener);          // Start capture.         CaptureRequest request = prepareCaptureRequest();         SimpleCaptureCallback listener = new SimpleCaptureCallback();         startCapture(request, /* repeating */false, listener, mHandler);          mListener.waitForAnyImageAvailable(CAPTURE_WAIT_TIMEOUT_MS);         img = mReader.acquireNextImage();         Plane firstPlane = img.getPlanes()[0];         ByteBuffer buffer = firstPlane.getBuffer();         img.close();          imageInvalidAccessTestAfterClose(img, firstPlane, buffer);     }      /**      * Test that images captured after discarding free buffers are valid.      */     private void discardFreeBuffersTestByCamera() throws Exception {         final int FORMAT = mStaticInfo.isColorOutputSupported() ?             ImageFormat.YUV_420_888 : ImageFormat.DEPTH16;          final Size SIZE = mStaticInfo.getAvailableSizesForFormatChecked(FORMAT,                 StaticMetadata.StreamDirection.Output)[0];         // Create ImageReader.         mListener = new SimpleImageListener();         createDefaultImageReader(SIZE, FORMAT, MAX_NUM_IMAGES, mListener);          // Start capture.         final boolean REPEATING = true;         final boolean SINGLE = false;         CaptureRequest request = prepareCaptureRequest();         SimpleCaptureCallback listener = new SimpleCaptureCallback();         startCapture(request, REPEATING, listener, mHandler);          // Validate images and capture results.         validateImage(SIZE, FORMAT, NUM_FRAME_VERIFIED, REPEATING);         validateCaptureResult(FORMAT, SIZE, listener, NUM_FRAME_VERIFIED);          // Discard free buffers.         mReader.discardFreeBuffers();          // Validate images and capture resulst again.         validateImage(SIZE, FORMAT, NUM_FRAME_VERIFIED, REPEATING);         validateCaptureResult(FORMAT, SIZE, listener, NUM_FRAME_VERIFIED);          // Stop repeating request in preparation for discardFreeBuffers         mCameraSession.stopRepeating();         mCameraSessionListener.getStateWaiter().waitForState(                 BlockingSessionCallback.SESSION_READY, SESSION_READY_TIMEOUT_MS);          // Drain the reader queue and discard free buffers from the reader.         Image img = mReader.acquireLatestImage();         if (img != null) {             img.close();         }         mReader.discardFreeBuffers();          // Do a single capture for camera device to reallocate buffers         mListener.reset();         startCapture(request, SINGLE, listener, mHandler);         validateImage(SIZE, FORMAT, /*captureCount*/1, SINGLE);     }      private void bufferFormatTestByCamera(int format, boolean repeating) throws Exception {         bufferFormatTestByCamera(format, /*setUsageFlag*/ false,                 HardwareBuffer.USAGE_CPU_READ_OFTEN, repeating,                 /*checkSession*/ false, /*validateImageData*/ true);     }      private void bufferFormatTestByCamera(int format, boolean repeating, boolean checkSession)             throws Exception {         bufferFormatTestByCamera(format, /*setUsageFlag*/ false,                 HardwareBuffer.USAGE_CPU_READ_OFTEN,                 repeating, checkSession, /*validateImageData*/true);     }      private void bufferFormatTestByCamera(int format, boolean setUsageFlag, long usageFlag,             // TODO: Consider having some sort of test configuration class passed to reduce the             //       proliferation of parameters ?             boolean repeating, boolean checkSession, boolean validateImageData)             throws Exception {         Size[] availableSizes = mStaticInfo.getAvailableSizesForFormatChecked(format,                 StaticMetadata.StreamDirection.Output);          // for each resolution, test imageReader:         for (Size sz : availableSizes) {             try {                 if (VERBOSE) {                     Log.v(TAG, ""Testing size "" + sz.toString() + "" format "" + format                             + "" for camera "" + mCamera.getId());                 }                  // Create ImageReader.                 mListener  = new SimpleImageListener();                 if (setUsageFlag) {                     createDefaultImageReader(sz, format, MAX_NUM_IMAGES, usageFlag, mListener);                 } else {                     createDefaultImageReader(sz, format, MAX_NUM_IMAGES, mListener);                 }                  if (checkSession) {                     checkImageReaderSessionConfiguration(                             ""Camera capture session validation for format: "" + format + ""failed"");                 }                  // Start capture.                 CaptureRequest request = prepareCaptureRequest();                 SimpleCaptureCallback listener = new SimpleCaptureCallback();                 startCapture(request, repeating, listener, mHandler);                  int numFrameVerified = repeating ? NUM_FRAME_VERIFIED : 1;                  if (validateImageData) {                     // Validate images.                     validateImage(sz, format, numFrameVerified, repeating);                 }                  // Validate capture result.                 validateCaptureResult(format, sz, listener, numFrameVerified);                  // stop capture.                 stopCapture(/*fast*/false);             } finally {                 closeDefaultImageReader();             }          }     }      private void bufferFormatLongProcessingTimeTestByCamera(int format)             throws Exception {          final int TEST_SENSITIVITY_VALUE = mStaticInfo.getSensitivityClampToRange(204);         final long TEST_EXPOSURE_TIME_NS = mStaticInfo.getExposureClampToRange(28000000);         final long EXPOSURE_TIME_ERROR_MARGIN_NS = 100000;          Size[] availableSizes = mStaticInfo.getAvailableSizesForFormatChecked(format,                 StaticMetadata.StreamDirection.Output);          // for each resolution, test imageReader:         for (Size sz : availableSizes) {             Log.v(TAG, ""testing size "" + sz.toString());             try {                 if (VERBOSE) {                     Log.v(TAG, ""Testing long processing time: size "" + sz.toString() + "" format "" +                             format + "" for camera "" + mCamera.getId());                 }                  // Create ImageReader.                 mListener  = new SimpleImageListener();                 createDefaultImageReader(sz, format, MAX_NUM_IMAGES, mListener);                  // Setting manual controls                 List<Surface> outputSurfaces = new ArrayList<Surface>();                 outputSurfaces.add(mReader.getSurface());                 CaptureRequest.Builder requestBuilder = prepareCaptureRequestForSurfaces(                         outputSurfaces, CameraDevice.TEMPLATE_STILL_CAPTURE);                  requestBuilder.set(                         CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_OFF);                 requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);                 requestBuilder.set(CaptureRequest.CONTROL_AWB_LOCK, true);                 requestBuilder.set(CaptureRequest.CONTROL_AE_MODE,                         CaptureRequest.CONTROL_AE_MODE_OFF);                 requestBuilder.set(CaptureRequest.CONTROL_AWB_MODE,                         CaptureRequest.CONTROL_AWB_MODE_OFF);                 requestBuilder.set(CaptureRequest.SENSOR_SENSITIVITY, TEST_SENSITIVITY_VALUE);                 requestBuilder.set(CaptureRequest.SENSOR_EXPOSURE_TIME, TEST_EXPOSURE_TIME_NS);                  SimpleCaptureCallback listener = new SimpleCaptureCallback();                 startCapture(requestBuilder.build(), /*repeating*/true, listener, mHandler);                  for (int i = 0; i < NUM_LONG_PROCESS_TIME_FRAME_VERIFIED; i++) {                     mListener.waitForAnyImageAvailable(CAPTURE_WAIT_TIMEOUT_MS);                      // Verify image.                     Image img = mReader.acquireNextImage();                     assertNotNull(""Unable to acquire next image"", img);                     CameraTestUtils.validateImage(img, sz.getWidth(), sz.getHeight(), format,                             mDebugFileNameBase);                      // Verify the exposure time and iso match the requested values.                     CaptureResult result = listener.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);                      long exposureTimeDiff = TEST_EXPOSURE_TIME_NS -                             getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);                     int sensitivityDiff = TEST_SENSITIVITY_VALUE -                             getValueNotNull(result, CaptureResult.SENSOR_SENSITIVITY);                      mCollector.expectTrue(                             String.format(""Long processing frame %d format %d size %s "" +                                     ""exposure time was %d expecting %d."", i, format, sz.toString(),                                     getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME),                                     TEST_EXPOSURE_TIME_NS),                             exposureTimeDiff < EXPOSURE_TIME_ERROR_MARGIN_NS &&                             exposureTimeDiff >= 0);                      mCollector.expectTrue(                             String.format(""Long processing frame %d format %d size %s "" +                                     ""sensitivity was %d expecting %d."", i, format, sz.toString(),                                     getValueNotNull(result, CaptureResult.SENSOR_SENSITIVITY),                                     TEST_SENSITIVITY_VALUE),                             sensitivityDiff >= 0);                       // Sleep to Simulate long porcessing before closing the image.                     Thread.sleep(LONG_PROCESS_TIME_MS);                     img.close();                 }                 // Stop capture.                 // Drain the reader queue in case the full queue blocks                 // HAL from delivering new results                 ImageDropperListener imageDropperListener = new ImageDropperListener();                 mReader.setOnImageAvailableListener(imageDropperListener, mHandler);                 Image img = mReader.acquireLatestImage();                 if (img != null) {                     img.close();                 }                 stopCapture(/*fast*/false);             } finally {                 closeDefaultImageReader();             }         }     }      /**      * Validate capture results.      *      * @param format The format of this capture.      * @param size The capture size.      * @param listener The capture listener to get capture result callbacks.      */     private void validateCaptureResult(int format, Size size, SimpleCaptureCallback listener,             int numFrameVerified) {         for (int i = 0; i < numFrameVerified; i++) {             CaptureResult result = listener.getCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);              // TODO: Update this to use availableResultKeys once shim supports this.             if (mStaticInfo.isCapabilitySupported(                     CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS)) {                 Long exposureTime = getValueNotNull(result, CaptureResult.SENSOR_EXPOSURE_TIME);                 Integer sensitivity = getValueNotNull(result, CaptureResult.SENSOR_SENSITIVITY);                 mCollector.expectInRange(                         String.format(                                 ""Capture for format %d, size %s exposure time is invalid."",                                 format, size.toString()),                         exposureTime,                         mStaticInfo.getExposureMinimumOrDefault(),                         mStaticInfo.getExposureMaximumOrDefault()                 );                 mCollector.expectInRange(                         String.format(""Capture for format %d, size %s sensitivity is invalid."",                                 format, size.toString()),                         sensitivity,                         mStaticInfo.getSensitivityMinimumOrDefault(),                         mStaticInfo.getSensitivityMaximumOrDefault()                 );             }             // TODO: add more key validations.         }     }      private final class SimpleImageListener implements ImageReader.OnImageAvailableListener {         private final ConditionVariable imageAvailable = new ConditionVariable();         @Override         public void onImageAvailable(ImageReader reader) {             if (mReader != reader) {                 return;             }              if (VERBOSE) Log.v(TAG, ""new image available"");             imageAvailable.open();         }          public void waitForAnyImageAvailable(long timeout) {             if (imageAvailable.block(timeout)) {                 imageAvailable.close();             } else {                 fail(""wait for image available timed out after "" + timeout + ""ms"");             }         }          public void closePendingImages() {             Image image = mReader.acquireLatestImage();             if (image != null) {                 image.close();             }         }          public void reset() {             imageAvailable.close();         }     }      private void validateImage(Size sz, int format, int captureCount,  boolean repeating)             throws Exception {         // TODO: Add more format here, and wrap each one as a function.         Image img;         final int MAX_RETRY_COUNT = 20;         int numImageVerified = 0;         int reTryCount = 0;         while (numImageVerified < captureCount) {             assertNotNull(""Image listener is null"", mListener);             if (VERBOSE) Log.v(TAG, ""Waiting for an Image"");             mListener.waitForAnyImageAvailable(CAPTURE_WAIT_TIMEOUT_MS);             if (repeating) {                 /**                  * Acquire the latest image in case the validation is slower than                  * the image producing rate.                  */                 img = mReader.acquireLatestImage();                 /**                  * Sometimes if multiple onImageAvailable callbacks being queued,                  * acquireLatestImage will clear all buffer before corresponding callback is                  * executed. Wait for a new frame in that case.                  */                 if (img == null && reTryCount < MAX_RETRY_COUNT) {                     reTryCount++;                     continue;                 }             } else {                 img = mReader.acquireNextImage();             }             assertNotNull(""Unable to acquire the latest image"", img);             if (VERBOSE) Log.v(TAG, ""Got the latest image"");             CameraTestUtils.validateImage(img, sz.getWidth(), sz.getHeight(), format,                     mDebugFileNameBase);             HardwareBuffer hwb = img.getHardwareBuffer();             assertNotNull(""Unable to retrieve the Image's HardwareBuffer"", hwb);             if (format == ImageFormat.DEPTH_JPEG) {                 byte [] dynamicDepthBuffer = CameraTestUtils.getDataFromImage(img);                 assertTrue(""Dynamic depth validation failed!"",                         validateDynamicDepthNative(dynamicDepthBuffer));             }             if (VERBOSE) Log.v(TAG, ""finish validation of image "" + numImageVerified);             img.close();             numImageVerified++;             reTryCount = 0;         }          // Return all pending images to the ImageReader as the validateImage may         // take a while to return and there could be many images pending.         mListener.closePendingImages();     }      /** Load dynamic depth validation jni on initialization */     static {         System.loadLibrary(""ctscamera2_jni"");     }     /**      * Use the dynamic depth SDK to validate a dynamic depth file stored in the buffer.      *      * Returns false if the dynamic depth has validation errors. Validation warnings/errors      * will be printed to logcat.      */     private static native boolean validateDynamicDepthNative(byte[] dynamicDepthBuffer); }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.permission.cts.FileSystemPermissionTest"	"testProcQtaguidStatsSane"	"CtsPermissionTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	"public void testProcQtaguidStatsSane() throws Exception {         File f = new File(""/proc/net/xt_qtaguid/stats"");         assertFalse(f.canRead());         assertFalse(f.canWrite());         assertFalse(f.canExecute());          assertFileOwnedBy(f, ""root"");         assertFileOwnedByGroup(f, ""net_bw_stats"");     }      private static List<String> procNetFiles = Arrays.asList(""anycast6"", ""arp"", ""arp_tables_matches"",             ""arp_tables_names"", ""arp_tables_targets"", ""dev"", ""dev_mcast"", ""fib_trie"", ""fib_triestat"",             ""hci"", ""icmp"", ""icmp6"", ""if_inet6"", ""igmp"", ""igmp6"", ""ip6_flowlabel"",             ""ip6_tables_matches"", ""ip6_tables_names"", ""ip6_tables_targets"", ""ip_tables_matches"",             ""ip_tables_names"", ""ip_tables_targets"", ""ipv6_route"", ""l2cap"", ""mcfilter"", ""mcfilter6"",             ""netlink"", ""netstat"", ""nf_conntrack"", ""nf_conntrack_expect"", ""packet"", ""pfkey"", ""pnp"",             ""pppoe"", ""pppol2tp"", ""protocols"", ""psched"", ""ptype"", ""raw"", ""raw6"", ""route"", ""rt6_stats"",             ""rt_cache"", ""sco"", ""snmp"", ""snmp6"", ""sockstat"", ""sockstat6"", ""softnet_stat"", ""tcp"",             ""tcp6"", ""udp"", ""udp6"", ""udplite"", ""udplite6"", ""unix"", ""wireless"", ""xfrm_stat"");      private static void procNetSane(String path) {         File f = new File(path);         assertFalse(f.canRead());         assertFalse(f.canWrite());         assertFalse(f.canExecute());         assertFileOwnedBy(f, ""root"");         assertFileOwnedByGroup(f, ""root"");     }      @MediumTest"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.Ikev2VpnTest"	"Ikev2VpnTest"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"/*  *.  */  package android.net.cts;  import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET; import static android.net.NetworkCapabilities.TRANSPORT_VPN; import static android.net.cts.util.CtsNetUtils.TestNetworkCallback;  import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.Manifest; import android.annotation.NonNull; import android.app.AppOpsManager; import android.content.Context; import android.content.Intent; import android.net.ConnectivityManager; import android.net.Ikev2VpnProfile; import android.net.IpSecAlgorithm; import android.net.LinkAddress; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkRequest; import android.net.ProxyInfo; import android.net.TestNetworkInterface; import android.net.TestNetworkManager; import android.net.VpnManager; import android.net.cts.util.CtsNetUtils; import android.os.Build; import android.os.Process; import android.platform.test.annotations.AppModeFull;  import androidx.test.InstrumentationRegistry;  import com.android.internal.util.HexDump; import com.android.org.bouncycastle.x509.X509V1CertificateGenerator; import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo; import com.android.testutils.DevSdkIgnoreRunner;  import org.junit.After; import org.junit.Test; import org.junit.runner.RunWith;  import java.math.BigInteger; import java.net.InetAddress; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PrivateKey; import java.security.cert.X509Certificate; import java.util.Arrays; import java.util.Date; import java.util.List; import java.util.concurrent.TimeUnit;  import javax.security.auth.x500.X500Principal;  @RunWith(DevSdkIgnoreRunner.class) @IgnoreUpTo(Build.VERSION_CODES.Q) @AppModeFull(reason = ""Appops state changes disallowed for instant apps (OP_ACTIVATE_PLATFORM_VPN)"") public class Ikev2VpnTest {     private static final String TAG = Ikev2VpnTest.class.getSimpleName();      // Test vectors for IKE negotiation in test mode.     private static final String SUCCESSFUL_IKE_INIT_RESP_V4 =             ""46b8eca1e0d72a18b2b5d9006d47a0022120222000000000000002d0220000300000002c01010004030000""                     + ""0c0100000c800e0100030000080300000c030000080200000400000008040000102800020800""                     + ""100000b8070f159fe5141d8754ca86f72ecc28d66f514927e96cbe9eec0adb42bf2c276a0ab7""                     + ""a97fa93555f4be9218c14e7f286bb28c6b4fb13825a420f2ffc165854f200bab37d69c8963d4""                     + ""0acb831d983163aa50622fd35c182efe882cf54d6106222abcfaa597255d302f1b95ab71c142""                     + ""c279ea5839a180070bff73f9d03fab815f0d5ee2adec7e409d1e35979f8bd92ffd8aab13d1a0""                     + ""0657d816643ae767e9ae84d2ccfa2bcce1a50572be8d3748ae4863c41ae90da16271e014270f""                     + ""77edd5cd2e3299f3ab27d7203f93d770bacf816041cdcecd0f9af249033979da4369cb242dd9""                     + ""6d172e60513ff3db02de63e50eb7d7f596ada55d7946cad0af0669d1f3e2804846ab3f2a930d""                     + ""df56f7f025f25c25ada694e6231abbb87ee8cfd072c8481dc0b0f6b083fdc3bd89b080e49feb""                     + ""0288eef6fdf8a26ee2fc564a11e7385215cf2deaf2a9965638fc279c908ccdf04094988d91a2""                     + ""464b4a8c0326533aff5119ed79ecbd9d99a218b44f506a5eb09351e67da86698b4c58718db25""                     + ""d55f426fb4c76471b27a41fbce00777bc233c7f6e842e39146f466826de94f564cad8b92bfbe""                     + ""87c99c4c7973ec5f1eea8795e7da82819753aa7c4fcfdab77066c56b939330c4b0d354c23f83""                     + ""ea82fa7a64c4b108f1188379ea0eb4918ee009d804100e6bf118771b9058d42141c847d5ec37""                     + ""6e5ec591c71fc9dac01063c2bd31f9c783b28bf1182900002430f3d5de3449462b31dd28bc27""                     + ""297b6ad169bccce4f66c5399c6e0be9120166f2900001c0000400428b8df2e66f69c8584a186""                     + ""c5eac66783551d49b72900001c000040054e7a622e802d5cbfb96d5f30a6e433994370173529""                     + ""0000080000402e290000100000402f00020003000400050000000800004014"";     private static final String SUCCESSFUL_IKE_INIT_RESP_V6 =             ""46b8eca1e0d72a1800d9ea1babce26bf2120222000000000000002d0220000300000002c01010004030000""                     + ""0c0100000c800e0100030000080300000c030000080200000400000008040000102800020800""                     + ""100000ea0e6dd9ca5930a9a45c323a41f64bfd8cdef7730f5fbff37d7c377da427f489a42aa8""                     + ""c89233380e6e925990d49de35c2cdcf63a61302c731a4b3569df1ee1bf2457e55a6751838ede""                     + ""abb75cc63ba5c9e4355e8e784f383a5efe8a44727dc14aeaf8dacc2620fb1c8875416dc07739""                     + ""7fe4decc1bd514a9c7d270cf21fd734c63a25c34b30b68686e54e8a198f37f27cb491fe27235""                     + ""fab5476b036d875ccab9a68d65fbf3006197f9bebbf94de0d3802b4fafe1d48d931ce3a1a346""                     + ""2d65bd639e9bd7fa46299650a9dbaf9b324e40b466942d91a59f41ef8042f8474c4850ed0f63""                     + ""e9238949d41cd8bbaea9aefdb65443a6405792839563aa5dc5c36b5ce8326ccf8a94d9622b85""                     + ""038d390d5fc0299e14e1f022966d4ac66515f6108ca04faec44821fe5bbf2ed4f84ff5671219""                     + ""608cb4c36b44a31ba010c9088f8d5ff943bb9ff857f74be1755f57a5783874adc57f42bb174e""                     + ""4ad3215de628707014dbcb1707bd214658118fdd7a42b3e1638b991ce5b812a667f1145be811""                     + ""685e3cd3baf9b18d062657b64c206a4d19a531c252a6a51a04aeaf42c618620cdbab65baca23""                     + ""82c57ed888422aeaacf7f1bc3fe2247ff7e7eaca218b74d7b31d02f2b0afa123f802529e7e6c""                     + ""3259d418290740ddbf55686e26998d7edcbbf895664972fed666f2f20af40503aa2af436ec6d""                     + ""4ec981ab19b9088755d94ae7a7c2066ea331d4e56e290000243fefe5555fce552d57a84e682c""                     + ""d4a6dfb3f2f94a94464d5bec3d88b88e9559642900001c00004004eb4afff764e7b79bca78b1""                     + ""3a89100d36d678ae982900001c00004005d177216a3c26f782076e12570d40bfaaa148822929""                     + ""0000080000402e290000100000402f00020003000400050000000800004014"";     private static final String SUCCESSFUL_IKE_AUTH_RESP_V4 =             ""46b8eca1e0d72a18b2b5d9006d47a0022e20232000000001000000e0240000c420a2500a3da4c66fa6929e""                     + ""600f36349ba0e38de14f78a3ad0416cba8c058735712a3d3f9a0a6ed36de09b5e9e02697e7c4""                     + ""2d210ac86cfbd709503cfa51e2eab8cfdc6427d136313c072968f6506a546eb5927164200592""                     + ""6e36a16ee994e63f029432a67bc7d37ca619e1bd6e1678df14853067ecf816b48b81e8746069""                     + ""406363e5aa55f13cb2afda9dbebee94256c29d630b17dd7f1ee52351f92b6e1c3d8551c513f1""                     + ""d74ac52a80b2041397e109fe0aeb3c105b0d4be0ae343a943398764281"";     private static final String SUCCESSFUL_IKE_AUTH_RESP_V6 =             ""46b8eca1e0d72a1800d9ea1babce26bf2e20232000000001000000f0240000d4aaf6eaa6c06b50447e6f54""                     + ""827fd8a9d9d6ac8015c1ebb3e8cb03fc6e54b49a107441f50004027cc5021600828026367f03""                     + ""bc425821cd7772ee98637361300c9b76056e874fea2bd4a17212370b291894264d8c023a01d1""                     + ""c3b691fd4b7c0b534e8c95af4c4638e2d125cb21c6267e2507cd745d72e8da109c47b9259c6c""                     + ""57a26f6bc5b337b9b9496d54bdde0333d7a32e6e1335c9ee730c3ecd607a8689aa7b0577b74f""                     + ""3bf437696a9fd5fc0aee3ed346cd9e15d1dda293df89eb388a8719388a60ca7625754de12cdb""                     + ""efe4c886c5c401"";     private static final long IKE_INITIATOR_SPI = Long.parseLong(""46B8ECA1E0D72A18"", 16);      private static final InetAddress LOCAL_OUTER_4 = InetAddress.parseNumericAddress(""192.0.2.1"");     private static final InetAddress LOCAL_OUTER_6 =             InetAddress.parseNumericAddress(""2001:db8::1"");      private static final int IP4_PREFIX_LEN = 32;     private static final int IP6_PREFIX_LEN = 128;      // TODO: Use IPv6 address when we can generate test vectors (GCE does not allow IPv6 yet).     private static final String TEST_SERVER_ADDR_V4 = ""192.0.2.2"";     private static final String TEST_SERVER_ADDR_V6 = ""2001:db8::2"";     private static final String TEST_IDENTITY = ""client.cts.android.com"";     private static final List<String> TEST_ALLOWED_ALGORITHMS =             Arrays.asList(IpSecAlgorithm.AUTH_CRYPT_AES_GCM);      private static final ProxyInfo TEST_PROXY_INFO =             ProxyInfo.buildDirectProxy(""proxy.cts.android.com"", 1234);     private static final int TEST_MTU = 1300;      private static final byte[] TEST_PSK = ""ikeAndroidPsk"".getBytes();     private static final String TEST_USER = ""username"";     private static final String TEST_PASSWORD = ""pa55w0rd"";      // Static state to reduce setup/teardown     private static final Context sContext = InstrumentationRegistry.getContext();     private static final ConnectivityManager sCM =             (ConnectivityManager) sContext.getSystemService(Context.CONNECTIVITY_SERVICE);     private static final VpnManager sVpnMgr =             (VpnManager) sContext.getSystemService(Context.VPN_MANAGEMENT_SERVICE);     private static final CtsNetUtils mCtsNetUtils = new CtsNetUtils(sContext);      private final X509Certificate mServerRootCa;     private final CertificateAndKey mUserCertKey;      public Ikev2VpnTest() throws Exception {         // Build certificates         mServerRootCa = generateRandomCertAndKeyPair().cert;         mUserCertKey = generateRandomCertAndKeyPair();     }      @After     public void tearDown() {         setAppop(AppOpsManager.OP_ACTIVATE_VPN, false);         setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, false);     }      /**      * Sets the given appop using shell commands      *      * <p>This method must NEVER be called from within a shell permission, as it will attempt to      * acquire, and then drop the shell permission identity. This results in the caller losing the      * shell permission identity due to these calls not being reference counted.      */     public void setAppop(int appop, boolean allow) {         // Requires shell permission to update appops.         runWithShellPermissionIdentity(() -> {             mCtsNetUtils.setAppopPrivileged(appop, allow);         }, Manifest.permission.MANAGE_TEST_NETWORKS);     }      private Ikev2VpnProfile buildIkev2VpnProfileCommon(             Ikev2VpnProfile.Builder builder, boolean isRestrictedToTestNetworks) throws Exception {         if (isRestrictedToTestNetworks) {             builder.restrictToTestNetworks();         }          return builder.setBypassable(true)                 .setAllowedAlgorithms(TEST_ALLOWED_ALGORITHMS)                 .setProxy(TEST_PROXY_INFO)                 .setMaxMtu(TEST_MTU)                 .setMetered(false)                 .build();     }      private Ikev2VpnProfile buildIkev2VpnProfilePsk(boolean isRestrictedToTestNetworks)             throws Exception {         return buildIkev2VpnProfilePsk(TEST_SERVER_ADDR_V6, isRestrictedToTestNetworks);     }      private Ikev2VpnProfile buildIkev2VpnProfilePsk(             String remote, boolean isRestrictedToTestNetworks) throws Exception {         final Ikev2VpnProfile.Builder builder =                 new Ikev2VpnProfile.Builder(remote, TEST_IDENTITY).setAuthPsk(TEST_PSK);          return buildIkev2VpnProfileCommon(builder, isRestrictedToTestNetworks);     }      private Ikev2VpnProfile buildIkev2VpnProfileUsernamePassword(boolean isRestrictedToTestNetworks)             throws Exception {         final Ikev2VpnProfile.Builder builder =                 new Ikev2VpnProfile.Builder(TEST_SERVER_ADDR_V6, TEST_IDENTITY)                         .setAuthUsernamePassword(TEST_USER, TEST_PASSWORD, mServerRootCa);          return buildIkev2VpnProfileCommon(builder, isRestrictedToTestNetworks);     }      private Ikev2VpnProfile buildIkev2VpnProfileDigitalSignature(boolean isRestrictedToTestNetworks)             throws Exception {         final Ikev2VpnProfile.Builder builder =                 new Ikev2VpnProfile.Builder(TEST_SERVER_ADDR_V6, TEST_IDENTITY)                         .setAuthDigitalSignature(                                 mUserCertKey.cert, mUserCertKey.key, mServerRootCa);          return buildIkev2VpnProfileCommon(builder, isRestrictedToTestNetworks);     }      private void checkBasicIkev2VpnProfile(@NonNull Ikev2VpnProfile profile) throws Exception {         assertEquals(TEST_SERVER_ADDR_V6, profile.getServerAddr());         assertEquals(TEST_IDENTITY, profile.getUserIdentity());         assertEquals(TEST_PROXY_INFO, profile.getProxyInfo());         assertEquals(TEST_ALLOWED_ALGORITHMS, profile.getAllowedAlgorithms());         assertTrue(profile.isBypassable());         assertFalse(profile.isMetered());         assertEquals(TEST_MTU, profile.getMaxMtu());         assertFalse(profile.isRestrictedToTestNetworks());     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.Ikev2VpnTest"	"testStartVpnProfileNoPreviousConsent"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"public void testStartVpnProfileNoPreviousConsent() throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          setAppop(AppOpsManager.OP_ACTIVATE_VPN, false);         setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, false);          // Make sure the VpnProfile is not provisioned already.         sVpnMgr.stopProvisionedVpnProfile();          try {             sVpnMgr.startProvisionedVpnProfile();             fail(""Expected SecurityException for missing consent"");         } catch (SecurityException expected) {         }     }      private void checkStartStopVpnProfileBuildsNetworks(IkeTunUtils tunUtils, boolean testIpv6)             throws Exception {         String serverAddr = testIpv6 ? TEST_SERVER_ADDR_V6 : TEST_SERVER_ADDR_V4;         String initResp = testIpv6 ? SUCCESSFUL_IKE_INIT_RESP_V6 : SUCCESSFUL_IKE_INIT_RESP_V4;         String authResp = testIpv6 ? SUCCESSFUL_IKE_AUTH_RESP_V6 : SUCCESSFUL_IKE_AUTH_RESP_V4;         boolean hasNat = !testIpv6;          // Requires MANAGE_TEST_NETWORKS to provision a test-mode profile.         mCtsNetUtils.setAppopPrivileged(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, true);          final Ikev2VpnProfile profile =                 buildIkev2VpnProfilePsk(serverAddr, true /* isRestrictedToTestNetworks */);         assertNull(sVpnMgr.provisionVpnProfile(profile));          sVpnMgr.startProvisionedVpnProfile();          // Inject IKE negotiation         int expectedMsgId = 0;         tunUtils.awaitReqAndInjectResp(IKE_INITIATOR_SPI, expectedMsgId++, false /* isEncap */,                 HexDump.hexStringToByteArray(initResp));         tunUtils.awaitReqAndInjectResp(IKE_INITIATOR_SPI, expectedMsgId++, hasNat /* isEncap */,                 HexDump.hexStringToByteArray(authResp));          // Verify the VPN network came up         final NetworkRequest nr = new NetworkRequest.Builder()                 .clearCapabilities().addTransportType(TRANSPORT_VPN).build();          final TestNetworkCallback cb = new TestNetworkCallback();         sCM.requestNetwork(nr, cb);         cb.waitForAvailable();         final Network vpnNetwork = cb.currentNetwork;         assertNotNull(vpnNetwork);          final NetworkCapabilities caps = sCM.getNetworkCapabilities(vpnNetwork);         assertTrue(caps.hasTransport(TRANSPORT_VPN));         assertTrue(caps.hasCapability(NET_CAPABILITY_INTERNET));         assertEquals(Process.myUid(), caps.getOwnerUid());          sVpnMgr.stopProvisionedVpnProfile();         cb.waitForLost();         assertEquals(vpnNetwork, cb.lastLostNetwork);     }      private void doTestStartStopVpnProfile(boolean testIpv6) throws Exception {         // Non-final; these variables ensure we clean up properly after our test if we have         // allocated test network resources         final TestNetworkManager tnm = sContext.getSystemService(TestNetworkManager.class);         TestNetworkInterface testIface = null;         TestNetworkCallback tunNetworkCallback = null;          try {             // Build underlying test network             testIface = tnm.createTunInterface(                     new LinkAddress[] {                             new LinkAddress(LOCAL_OUTER_4, IP4_PREFIX_LEN),                             new LinkAddress(LOCAL_OUTER_6, IP6_PREFIX_LEN)});              // Hold on to this callback to ensure network does not get reaped.             tunNetworkCallback = mCtsNetUtils.setupAndGetTestNetwork(                     testIface.getInterfaceName());             final IkeTunUtils tunUtils = new IkeTunUtils(testIface.getFileDescriptor());              checkStartStopVpnProfileBuildsNetworks(tunUtils, testIpv6);         } finally {             // Make sure to stop the VPN profile. This is safe to call multiple times.             sVpnMgr.stopProvisionedVpnProfile();              if (testIface != null) {                 testIface.getFileDescriptor().close();             }              if (tunNetworkCallback != null) {                 sCM.unregisterNetworkCallback(tunNetworkCallback);             }              final Network testNetwork = tunNetworkCallback.currentNetwork;             if (testNetwork != null) {                 tnm.teardownTestNetwork(testNetwork);             }         }     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.app.usage.cts.NetworkUsageStatsTest"	"getIsDefault"	"CtsUsageStatsTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	"public void test/**  * Copyright (C) 2015 The Android Open Source Project  *  * Licensed under the Apache License, Version 2.0 (the ""License""); you may not  * use this file except in compliance with the License. You may obtain a copy  * of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations  * under the License.  */  package android.app.usage.cts;  import android.app.AppOpsManager; import android.app.usage.NetworkStatsManager; import android.app.usage.NetworkStats; import android.content.Context; import android.content.pm.PackageManager; import android.net.ConnectivityManager; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkInfo; import android.net.NetworkRequest; import android.net.TrafficStats; import android.os.Handler; import android.os.HandlerThread; import android.os.ParcelFileDescriptor; import android.os.Process; import android.os.RemoteException; import android.os.SystemClock; import android.platform.test.annotations.AppModeFull; import android.telephony.TelephonyManager; import android.test.InstrumentationTestCase; import android.util.Log;  import com.android.compatibility.common.util.ShellIdentityUtils; import com.android.compatibility.common.util.SystemUtil;  import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.URL; import java.net.UnknownHostException; import java.text.MessageFormat; import java.util.ArrayList; import java.util.Scanner; import java.net.HttpURLConnection;  import libcore.io.IoUtils; import libcore.io.Streams;  import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_ALL; import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_NO; import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_YES; import static android.app.usage.NetworkStats.Bucket.METERED_ALL; import static android.app.usage.NetworkStats.Bucket.METERED_YES; import static android.app.usage.NetworkStats.Bucket.METERED_NO; import static android.app.usage.NetworkStats.Bucket.STATE_ALL; import static android.app.usage.NetworkStats.Bucket.STATE_DEFAULT; import static android.app.usage.NetworkStats.Bucket.STATE_FOREGROUND; import static android.app.usage.NetworkStats.Bucket.TAG_NONE; import static android.app.usage.NetworkStats.Bucket.UID_ALL;  public class NetworkUsageStatsTest extends InstrumentationTestCase {     private static final String LOG_TAG = ""NetworkUsageStatsTest"";     private static final String APPOPS_SET_SHELL_COMMAND = ""appops set {0} {1} {2}"";     private static final String APPOPS_GET_SHELL_COMMAND = ""appops get {0} {1}"";      private static final long MINUTE = 1000 * 60;     private static final int TIMEOUT_MILLIS = 15000;      private static final String CHECK_CONNECTIVITY_URL = ""http://www.265.com/"";     private static final int HOST_RESOLUTION_RETRIES = 4;     private static final int HOST_RESOLUTION_INTERVAL_MS = 500;      private static final int NETWORK_TAG = 0xf00d;     private static final long THRESHOLD_BYTES = 2 * 1024 * 1024;  // 2 MB      private abstract class NetworkInterfaceToTest {         private boolean mMetered;         private boolean mIsDefault;          abstract int getNetworkType();         abstract int getTransportType();          public boolean getMetered() {             return mMetered;         }          public void setMetered(boolean metered) {             this.mMetered = metered;         }          public boolean getIsDefault() {             return mIsDefault;         }          public void setIsDefault(boolean isDefault) {             mIsDefault = isDefault;         }          abstract String getSystemFeature();         abstract String getErrorMessage();     }      private final NetworkInterfaceToTest[] mNetworkInterfacesToTest =             new NetworkInterfaceToTest[] {                     new NetworkInterfaceToTest() {                         @Override                         public int getNetworkType() {                             return ConnectivityManager.TYPE_WIFI;                         }                          @Override                         public int getTransportType() {                             return NetworkCapabilities.TRANSPORT_WIFI;                         }                          @Override                         public String getSystemFeature() {                             return PackageManager.FEATURE_WIFI;                         }                          @Override                         public String getErrorMessage() {                             return "" Please make sure you are connected to a WiFi access point."";                         }                     },                     new NetworkInterfaceToTest() {                         @Override                         public int getNetworkType() {                             return ConnectivityManager.TYPE_MOBILE;                         }                          @Override                         public int getTransportType() {                             return NetworkCapabilities.TRANSPORT_CELLULAR;                         }                          @Override                         public String getSystemFeature() {                             return PackageManager.FEATURE_TELEPHONY;                         }                          @Override                         public String getErrorMessage() {                             return "" Please make sure you have added a SIM card with data plan to"" +                                     "" your phone, have enabled data over cellular and in case of"" +                                     "" dual SIM devices, have selected the right SIM "" +                                     ""for data connection."";                         }                     }     };      private String mPkg;     private NetworkStatsManager mNsm;     private ConnectivityManager mCm;     private PackageManager mPm;     private long mStartTime;     private long mEndTime;      private long mBytesRead;     private String mWriteSettingsMode;     private String mUsageStatsMode;      private void exerciseRemoteHost(Network network, URL url) throws Exception {         NetworkInfo networkInfo = mCm.getNetworkInfo(network);         if (networkInfo == null) {             Log.w(LOG_TAG, ""Network info is null"");         } else {             Log.w(LOG_TAG, ""Network: "" + networkInfo.toString());         }         InputStreamReader in = null;         HttpURLConnection urlc = null;         String originalKeepAlive = System.getProperty(""http.keepAlive"");         System.setProperty(""http.keepAlive"", ""false"");         try {             TrafficStats.setThreadStatsTag(NETWORK_TAG);             urlc = (HttpURLConnection) network.openConnection(url);             urlc.setConnectTimeout(TIMEOUT_MILLIS);             urlc.setUseCaches(false);             // Disable compression so we generate enough traffic that assertWithinPercentage will             // not be affected by the small amount of traffic (5-10kB) sent by the test harness.             urlc.setRequestProperty(""Accept-Encoding"", ""identity"");             urlc.connect();             boolean ping = urlc.getResponseCode() == 200;             if (ping) {                 in = new InputStreamReader(                         (InputStream) urlc.getContent());                  mBytesRead = 0;                 while (in.read() != -1) ++mBytesRead;             }         } catch (Exception e) {             Log.i(LOG_TAG, ""Badness during exercising remote server: "" + e);         } finally {             TrafficStats.clearThreadStatsTag();             if (in != null) {                 try {                     in.close();                 } catch (IOException e) {                     // don't care                 }             }             if (urlc != null) {                 urlc.disconnect();             }             if (originalKeepAlive == null) {                 System.clearProperty(""http.keepAlive"");             } else {                 System.setProperty(""http.keepAlive"", originalKeepAlive);             }         }     }      @Override     protected void setUp() throws Exception {         super.setUp();         mNsm = (NetworkStatsManager) getInstrumentation().getContext()                 .getSystemService(Context.NETWORK_STATS_SERVICE);         mNsm.setPollForce(true);          mCm = (ConnectivityManager) getInstrumentation().getContext()                 .getSystemService(Context.CONNECTIVITY_SERVICE);          mPm = getInstrumentation().getContext().getPackageManager();          mPkg = getInstrumentation().getContext().getPackageName();          mWriteSettingsMode = getAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS);         setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, ""allow"");         mUsageStatsMode = getAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS);     }      @Override     protected void tearDown() throws Exception {         if (mWriteSettingsMode != null) {             setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, mWriteSettingsMode);         }         if (mUsageStatsMode != null) {             setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, mUsageStatsMode);         }         super.tearDown();     }      private void setAppOpsMode(String appop, String mode) throws Exception {         final String command = MessageFormat.format(APPOPS_SET_SHELL_COMMAND, mPkg, appop, mode);         SystemUtil.runShellCommand(command);     }      private String getAppOpsMode(String appop) throws Exception {         final String command = MessageFormat.format(APPOPS_GET_SHELL_COMMAND, mPkg, appop);         String result = SystemUtil.runShellCommand(command);         if (result == null) {             Log.w(LOG_TAG, ""App op "" + appop + "" could not be read."");         }         return result;     }      private boolean isInForeground() throws IOException {         String result = SystemUtil.runShellCommand(getInstrumentation(),                 ""cmd activity get-uid-state "" + Process.myUid());         return result.contains(""FOREGROUND"");     }      private class NetworkCallback extends ConnectivityManager.NetworkCallback {         private long mTolerance;         private URL mUrl;         public boolean success;         public boolean metered;         public boolean isDefault;          NetworkCallback(long tolerance, URL url) {             mTolerance = tolerance;             mUrl = url;             success = false;             metered = false;             isDefault = false;         }          // The test host only has IPv4. So on a dual-stack network where IPv6 connects before IPv4,         // we need to wait until IPv4 is available or the test will spuriously fail.         private void waitForHostResolution(Network network) {             for (int i = 0; i < HOST_RESOLUTION_RETRIES; i++) {                 try {                     network.getAllByName(mUrl.getHost());                     return;                 } catch (UnknownHostException e) {                     SystemClock.sleep(HOST_RESOLUTION_INTERVAL_MS);                 }             }             fail(String.format(""%s could not be resolved on network %s (%d attempts %dms apart)"",                   mUrl.getHost(), network, HOST_RESOLUTION_RETRIES, HOST_RESOLUTION_INTERVAL_MS));         }          @Override         public void onAvailable(Network network) {             try {                 mStartTime = System.currentTimeMillis() - mTolerance;                 isDefault = network.equals(mCm.getActiveNetwork());                 waitForHostResolution(network);                 exerciseRemoteHost(network, mUrl);                 mEndTime = System.currentTimeMillis() + mTolerance;                 success = true;                 metered = !mCm.getNetworkCapabilities(network)                         .hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);                 synchronized(NetworkUsageStatsTest.this) {                     NetworkUsageStatsTest.this.notify();                 }             } catch (Exception e) {                 Log.w(LOG_TAG, ""exercising remote host failed."", e);                 success = false;             }         }     }      private boolean shouldTestThisNetworkType(int networkTypeIndex, final long tolerance)             throws Exception {         boolean hasFeature = mPm.hasSystemFeature(                 mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature());         if (!hasFeature) {             return false;         }         NetworkCallback callback = new NetworkCallback(tolerance, new URL(CHECK_CONNECTIVITY_URL));         mCm.requestNetwork(new NetworkRequest.Builder()                 .addTransportType(mNetworkInterfacesToTest[networkTypeIndex].getTransportType())                 .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                 .build(), callback);         synchronized(this) {             try {                 wait((int)(TIMEOUT_MILLIS * 1.2));             } catch (InterruptedException e) {             }         }         if (callback.success) {             mNetworkInterfacesToTest[networkTypeIndex].setMetered(callback.metered);             mNetworkInterfacesToTest[networkTypeIndex].setIsDefault(callback.isDefault);             return true;         }          // This will always fail at this point as we know 'hasFeature' is true.         assertFalse (mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature() +                 "" is a reported system feature, "" +                 ""however no corresponding connected network interface was found or the attempt "" +                 ""to connect has timed out (timeout = "" + TIMEOUT_MILLIS + ""ms)."" +                 mNetworkInterfacesToTest[networkTypeIndex].getErrorMessage(), hasFeature);         return false;     }      private String getSubscriberId(int networkIndex) {         int networkType = mNetworkInterfacesToTest[networkIndex].getNetworkType();         if (ConnectivityManager.TYPE_MOBILE == networkType) {             TelephonyManager tm = (TelephonyManager) getInstrumentation().getContext()                     .getSystemService(Context.TELEPHONY_SERVICE);             return ShellIdentityUtils.invokeMethodWithShellPermissions(tm,                     (telephonyManager) -> telephonyManager.getSubscriberId());         }         return """";     }      @AppModeFull"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testIkeOverUdpEncapSocket"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testIkeOverUdpEncapSocket() throws Exception {         // IPv6 not supported for UDP-encap-ESP         InetAddress local = InetAddress.getByName(IPV4_LOOPBACK);         try (IpSecManager.UdpEncapsulationSocket encapSocket = mISM.openUdpEncapsulationSocket()) {             NativeUdpSocket wrappedEncapSocket =                     new NativeUdpSocket(encapSocket.getFileDescriptor());             checkIkePacket(wrappedEncapSocket, local);              // Now try with a transform applied to a socket using this Encap socket             IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);             IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_MD5, getKey(128), 96);              try (IpSecManager.SecurityParameterIndex spi =                             mISM.allocateSecurityParameterIndex(local);                     IpSecTransform transform =                             new IpSecTransform.Builder(InstrumentationRegistry.getContext())                                     .setEncryption(crypt)                                     .setAuthentication(auth)                                     .setIpv4Encapsulation(encapSocket, encapSocket.getPort())                                     .buildTransportModeTransform(local, spi);                     JavaUdpSocket localSocket = new JavaUdpSocket(local)) {                 applyTransformBidirectionally(mISM, transform, localSocket);                  checkIkePacket(wrappedEncapSocket, local);             }         }     }      // TODO: Check IKE over ESP sockets (IPv4, IPv6) - does this need SOCK_RAW?      /* TODO: Re-enable these when policy matcher works for reflected packets      *      * The issue here is that A sends to B, and everything is new; therefore PREROUTING counts      * correctly. But it appears that the security path is not cleared afterwards, thus when A      * sends an ACK back to B, the policy matcher flags it as a ""IPSec"" packet. See b/70635417      */      // public void testInterfaceCountersTcp4() throws Exception {     //     IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);     //     IpSecAlgorithm auth = new IpSecAlgorithm(     //             IpSecAlgorithm.AUTH_HMAC_MD5, getKey(128), 96);     //     checkTransform(IPPROTO_TCP, IPV4_LOOPBACK, crypt, auth, false, 1000);     // }      // public void testInterfaceCountersTcp6() throws Exception {     //     IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);     //     IpSecAlgorithm auth = new IpSecAlgorithm(     //             IpSecAlgorithm.AUTH_HMAC_MD5, getKey(128), 96);     //     checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, false, 1000);     // }      // public void testInterfaceCountersTcp4UdpEncap() throws Exception {     //     IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);     //     IpSecAlgorithm auth =     //             new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_MD5, getKey(128), 96);     //     checkTransform(IPPROTO_TCP, IPV4_LOOPBACK, crypt, auth, true, 1000);     // }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testInterfaceCountersUdp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testInterfaceCountersUdp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_MD5, getKey(128), 96);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1000, false);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesCbcHmacMd5Tcp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesCbcHmacMd5Tcp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_MD5, getKey(128), 96);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, null, false, 1, false);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesCbcHmacMd5Udp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesCbcHmacMd5Udp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_MD5, getKey(128), 96);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1, false);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesCbcHmacSha1Tcp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesCbcHmacSha1Tcp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA1, getKey(160), 96);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, null, false, 1, false);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesCbcHmacSha1Udp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesCbcHmacSha1Udp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA1, getKey(160), 96);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1, false);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesCbcHmacSha256Tcp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesCbcHmacSha256Tcp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA256, getKey(256), 128);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, null, false, 1, false);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesCbcHmacSha256Udp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesCbcHmacSha256Udp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA256, getKey(256), 128);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1, false);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesCbcHmacSha384Tcp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesCbcHmacSha384Tcp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA384, getKey(384), 192);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, null, false, 1, false);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesCbcHmacSha384Udp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesCbcHmacSha384Udp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA384, getKey(384), 192);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1, false);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesCbcHmacSha512Tcp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesCbcHmacSha512Tcp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA512, getKey(512), 256);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, null, false, 1, false);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesCbcHmacSha512Udp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesCbcHmacSha512Udp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA512, getKey(512), 256);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1, false);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesGcm64Tcp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesGcm64Tcp6() throws Exception {         IpSecAlgorithm authCrypt =                 new IpSecAlgorithm(IpSecAlgorithm.AUTH_CRYPT_AES_GCM, AEAD_KEY, 64);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, false);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesGcm64Udp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesGcm64Udp6() throws Exception {         IpSecAlgorithm authCrypt =                 new IpSecAlgorithm(IpSecAlgorithm.AUTH_CRYPT_AES_GCM, AEAD_KEY, 64);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, false);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesGcm96Tcp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesGcm96Tcp6() throws Exception {         IpSecAlgorithm authCrypt =                 new IpSecAlgorithm(IpSecAlgorithm.AUTH_CRYPT_AES_GCM, AEAD_KEY, 96);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, false);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesGcm96Udp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesGcm96Udp6() throws Exception {         IpSecAlgorithm authCrypt =                 new IpSecAlgorithm(IpSecAlgorithm.AUTH_CRYPT_AES_GCM, AEAD_KEY, 96);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, false);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesGcm128Tcp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesGcm128Tcp6() throws Exception {         IpSecAlgorithm authCrypt =                 new IpSecAlgorithm(IpSecAlgorithm.AUTH_CRYPT_AES_GCM, AEAD_KEY, 128);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, false);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAesGcm128Udp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAesGcm128Udp6() throws Exception {         IpSecAlgorithm authCrypt =                 new IpSecAlgorithm(IpSecAlgorithm.AUTH_CRYPT_AES_GCM, AEAD_KEY, 128);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, false);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, null, null, authCrypt, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testCryptUdp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testCryptUdp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, null, null, false, 1, false);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, crypt, null, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAuthUdp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAuthUdp6() throws Exception {         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA256, getKey(256), 128);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, null, auth, null, false, 1, false);         checkTransform(IPPROTO_UDP, IPV6_LOOPBACK, null, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testCryptTcp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testCryptTcp6() throws Exception {         IpSecAlgorithm crypt = new IpSecAlgorithm(IpSecAlgorithm.CRYPT_AES_CBC, CRYPT_KEY);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, null, null, false, 1, false);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, crypt, null, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.net.cts.IpSecManagerTest"	"testAuthTcp6"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"ipv6"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/IpSecManagerTest.java"	""	"public void testAuthTcp6() throws Exception {         IpSecAlgorithm auth = new IpSecAlgorithm(IpSecAlgorithm.AUTH_HMAC_SHA256, getKey(256), 128);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, null, auth, null, false, 1, false);         checkTransform(IPPROTO_TCP, IPV6_LOOPBACK, null, auth, null, false, 1, true);     }"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"com.android.cts.net.hostside.MixedModesTest"	"registerBroadcastReceiver"	""	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"simultaneously"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/MixedModesTest.java"	""	"/*  *.  */ package com.android.cts.net.hostside;  import static com.android.cts.net.hostside.NetworkPolicyTestUtils.setRestrictBackground; import static com.android.cts.net.hostside.Property.APP_STANDBY_MODE; import static com.android.cts.net.hostside.Property.BATTERY_SAVER_MODE; import static com.android.cts.net.hostside.Property.DATA_SAVER_MODE; import static com.android.cts.net.hostside.Property.DOZE_MODE; import static com.android.cts.net.hostside.Property.METERED_NETWORK; import static com.android.cts.net.hostside.Property.NON_METERED_NETWORK;  import android.os.SystemClock; import android.util.Log;  import org.junit.After; import org.junit.Before; import org.junit.Test;  /**  * Test cases for the more complex scenarios where multiple restrictions (like Battery Saver Mode  * and Data Saver Mode) are applied simultaneously.  * <p>  * <strong>NOTE: </strong>it might sound like the test methods on this class are testing too much,  * which would make it harder to diagnose individual failures, but the assumption is that such  * failure most likely will happen when the restriction is tested individually as well.  */ public class MixedModesTest extends AbstractRestrictBackgroundNetworkTestCase {     private static final String TAG = ""MixedModesTest"";      @Before     public void setUp() throws Exception {         super.setUp();          // Set initial state.         removeRestrictBackgroundWhitelist(mUid);         removeRestrictBackgroundBlacklist(mUid);         removePowerSaveModeWhitelist(TEST_APP2_PKG);         removePowerSaveModeExceptIdleWhitelist(TEST_APP2_PKG);          registerBroadcastReceiver();     }      @After     public void tearDown() throws Exception {         super.tearDown();          try {             setRestrictBackground(false);         } finally {             setBatterySaverMode(false);         }     }      /**      * Tests all DS ON and BS ON scenarios from network-policy-restrictions.md on metered networks.      */     @RequiredProperties({DATA_SAVER_MODE, BATTERY_SAVER_MODE, METERED_NETWORK})"	""	""	""	""	""
"203:629423) 7.4.5.2  . IPv6"	"7.4.5.2"	"C-4-1"	""	"android.telephony.cts.TelephonyManagerTest"	"testGetMaxNumberOfSimultaneouslyActiveSims"	"CtsTelephonyTestCases"	""	"7.4.5.2/C-4-1"	"""C-4-1] MUST simultaneously meet the above requirements on each network when the device is simultaneously connected to more than one network type. <h5 id="""	""	"simultaneously ipv6"	""	""	""	"simultaneously"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	"public void testGetMaxNumberOfSimultaneouslyActiveSims() {         if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {             Log.d(TAG, ""Skipping test that requires FEATURE_TELEPHONY"");             return;         }          int maxNum = mTelephonyManager.getMaxNumberOfSimultaneouslyActiveSims();         assertTrue(maxNum >= 1);     }      /**      * Tests that the device properly reports either a valid IMEI, MEID/ESN, or a valid MAC address      * if only a WiFi device. At least one of them must be valid.      */"	""	""	""	""	""
"256:742768) 9.8.10  . Connectivity Bug Report"	"9.8.10"	"C-1-3"	""	"android.cts.statsd.atom.AtomTestCase"	"getReportList"	""	""	"9.8.10/C-1-3"	"""C-1-3] MUST generate requested reports containing at least the following information: TelephonyDebugService dump TelephonyRegistry dump WifiService dump ConnectivityService dump A dump of the calling package's CarrierService instance (if bound) Radio log buffer """	""	"TelephonyDebugService"	""	""	""	"TelephonyDebugService"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/statsd/src/android/cts/statsd/atom/AtomTestCase.java"	""	"public void test/*  *.  */ package android.cts.statsd.atom;  import static android.cts.statsd.atom.DeviceAtomTestCase.DEVICE_SIDE_TEST_APK; import static android.cts.statsd.atom.DeviceAtomTestCase.DEVICE_SIDE_TEST_PACKAGE;  import static com.google.common.truth.Truth.assertThat; import static com.google.common.truth.Truth.assertWithMessage;  import android.os.BatteryStatsProto; import android.os.StatsDataDumpProto; import android.service.battery.BatteryServiceDumpProto; import android.service.batterystats.BatteryStatsServiceDumpProto; import android.service.procstats.ProcessStatsServiceDumpProto;  import com.android.annotations.Nullable; import com.android.internal.os.StatsdConfigProto.AtomMatcher; import com.android.internal.os.StatsdConfigProto.EventMetric; import com.android.internal.os.StatsdConfigProto.FieldFilter; import com.android.internal.os.StatsdConfigProto.FieldMatcher; import com.android.internal.os.StatsdConfigProto.FieldValueMatcher; import com.android.internal.os.StatsdConfigProto.GaugeMetric; import com.android.internal.os.StatsdConfigProto.Predicate; import com.android.internal.os.StatsdConfigProto.SimpleAtomMatcher; import com.android.internal.os.StatsdConfigProto.SimplePredicate; import com.android.internal.os.StatsdConfigProto.StatsdConfig; import com.android.internal.os.StatsdConfigProto.TimeUnit; import com.android.os.AtomsProto.AppBreadcrumbReported; import com.android.os.AtomsProto.Atom; import com.android.os.AtomsProto.ProcessStatsPackageProto; import com.android.os.AtomsProto.ProcessStatsProto; import com.android.os.AtomsProto.ProcessStatsStateProto; import com.android.os.StatsLog.ConfigMetricsReport; import com.android.os.StatsLog.ConfigMetricsReportList; import com.android.os.StatsLog.DurationMetricData; import com.android.os.StatsLog.EventMetricData; import com.android.os.StatsLog.GaugeBucketInfo; import com.android.os.StatsLog.GaugeMetricData; import com.android.os.StatsLog.CountMetricData; import com.android.os.StatsLog.StatsLogReport; import com.android.os.StatsLog.ValueMetricData; import com.android.tradefed.device.DeviceNotAvailableException; import com.android.tradefed.log.LogUtil; import com.android.tradefed.util.CommandResult; import com.android.tradefed.util.CommandStatus;  import com.google.common.collect.Range; import com.google.common.io.Files; import com.google.protobuf.ByteString;  import perfetto.protos.PerfettoConfig.DataSourceConfig; import perfetto.protos.PerfettoConfig.FtraceConfig; import perfetto.protos.PerfettoConfig.TraceConfig;  import java.io.File; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.Date; import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Queue; import java.util.Random; import java.util.Set; import java.util.StringTokenizer; import java.util.function.Function; import java.util.regex.Matcher; import java.util.regex.Pattern; import java.util.stream.Collectors;  /**  * Base class for testing Statsd atoms.  * Validates reporting of statsd logging based on different events  */ public class AtomTestCase extends BaseTestCase {      /**      * Run tests that are optional; they are not valid CTS tests per se, since not all devices can      * be expected to pass them, but can be run, if desired, to ensure they work when appropriate.      */     public static final boolean OPTIONAL_TESTS_ENABLED = false;      public static final String UPDATE_CONFIG_CMD = ""cmd stats config update"";     public static final String DUMP_REPORT_CMD = ""cmd stats dump-report"";     public static final String DUMP_BATTERY_CMD = ""dumpsys battery"";     public static final String DUMP_BATTERYSTATS_CMD = ""dumpsys batterystats"";     public static final String DUMPSYS_STATS_CMD = ""dumpsys stats"";     public static final String DUMP_PROCSTATS_CMD = ""dumpsys procstats"";     public static final String REMOVE_CONFIG_CMD = ""cmd stats config remove"";     /** ID of the config, which evaluates to -1572883457. */     public static final long CONFIG_ID = ""cts_config"".hashCode();      public static final String FEATURE_AUDIO_OUTPUT = ""android.hardware.audio.output"";     public static final String FEATURE_AUTOMOTIVE = ""android.hardware.type.automotive"";     public static final String FEATURE_BLUETOOTH = ""android.hardware.bluetooth"";     public static final String FEATURE_BLUETOOTH_LE = ""android.hardware.bluetooth_le"";     public static final String FEATURE_CAMERA = ""android.hardware.camera"";     public static final String FEATURE_CAMERA_FLASH = ""android.hardware.camera.flash"";     public static final String FEATURE_CAMERA_FRONT = ""android.hardware.camera.front"";     public static final String FEATURE_LEANBACK_ONLY = ""android.software.leanback_only"";     public static final String FEATURE_LOCATION_GPS = ""android.hardware.location.gps"";     public static final String FEATURE_PC = ""android.hardware.type.pc"";     public static final String FEATURE_PICTURE_IN_PICTURE = ""android.software.picture_in_picture"";     public static final String FEATURE_TELEPHONY = ""android.hardware.telephony"";     public static final String FEATURE_WATCH = ""android.hardware.type.watch"";     public static final String FEATURE_TWM = ""com.google.clockwork.hardware.traditional_watch_mode"";     public static final String FEATURE_WIFI = ""android.hardware.wifi"";     public static final String FEATURE_INCREMENTAL_DELIVERY =             ""android.software.incremental_delivery"";      // Telephony phone types     public static final int PHONE_TYPE_GSM = 1;     public static final int PHONE_TYPE_CDMA = 2;     public static final int PHONE_TYPE_CDMA_LTE = 6;      protected static final int WAIT_TIME_SHORT = 1000;     protected static final int WAIT_TIME_LONG = 2_000;      protected static final long SCREEN_STATE_CHANGE_TIMEOUT = 4000;     protected static final long SCREEN_STATE_POLLING_INTERVAL = 500;      protected static final long NS_PER_SEC = (long) 1E+9;      @Override     protected void setUp() throws Exception {         super.setUp();          // Uninstall to clear the history in case it's still on the device.         removeConfig(CONFIG_ID);         getReportList(); // Clears data.     }      @Override     protected void tearDown() throws Exception {         removeConfig(CONFIG_ID);         getDevice().uninstallPackage(DEVICE_SIDE_TEST_PACKAGE);         super.tearDown();     }      /**      * Determines whether logcat indicates that incidentd fired since the given device date.      */     protected boolean didIncidentdFireSince(String date) throws Exception {         final String INCIDENTD_TAG = ""incidentd"";         final String INCIDENTD_STARTED_STRING = ""reportIncident"";         // TODO: Do something more robust than this in case of delayed logging.         Thread.sleep(1000);         String log = getLogcatSince(date, String.format(                 ""-s %s -e %s"", INCIDENTD_TAG, INCIDENTD_STARTED_STRING));         return log.contains(INCIDENTD_STARTED_STRING);     }      protected boolean checkDeviceFor(String methodName) throws Exception {         try {             installPackage(DEVICE_SIDE_TEST_APK, true);             runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".Checkers"", methodName);             // Test passes, meaning that the answer is true.             LogUtil.CLog.d(methodName + ""() indicates true."");             return true;         } catch (AssertionError e) {             // Method is designed to fail if the answer is false.             LogUtil.CLog.d(methodName + ""() indicates false."");             return false;         }     }      /**      * Returns a protobuf-encoded perfetto config that enables the kernel      * ftrace tracer with sched_switch for 10 seconds.      */     protected ByteString getPerfettoConfig() {         TraceConfig.Builder builder = TraceConfig.newBuilder();          TraceConfig.BufferConfig buffer = TraceConfig.BufferConfig             .newBuilder()             .setSizeKb(128)             .build();         builder.addBuffers(buffer);          FtraceConfig ftraceConfig = FtraceConfig.newBuilder()             .addFtraceEvents(""sched/sched_switch"")             .build();         DataSourceConfig dataSourceConfig = DataSourceConfig.newBuilder()             .setName(""linux.ftrace"")             .setTargetBuffer(0)             .setFtraceConfig(ftraceConfig)             .build();         TraceConfig.DataSource dataSource = TraceConfig.DataSource             .newBuilder()             .setConfig(dataSourceConfig)             .build();         builder.addDataSources(dataSource);          builder.setDurationMs(10000);         builder.setAllowUserBuildTracing(true);          // To avoid being hit with guardrails firing in multiple test runs back         // to back, we set a unique session key for each config.         Random random = new Random();         StringBuilder sessionNameBuilder = new StringBuilder(""statsd-cts-"");         sessionNameBuilder.append(random.nextInt() & Integer.MAX_VALUE);         builder.setUniqueSessionName(sessionNameBuilder.toString());          return builder.build().toByteString();     }      /**      * Resets the state of the Perfetto guardrails. This avoids that the test fails if it's      * run too close of for too many times and hits the upload limit.      */     protected void resetPerfettoGuardrails() throws Exception {         final String cmd = ""perfetto --reset-guardrails"";         CommandResult cr = getDevice().executeShellV2Command(cmd);         if (cr.getStatus() != CommandStatus.SUCCESS)             throw new Exception(String.format(""Error while executing %s: %s %s"", cmd, cr.getStdout(), cr.getStderr()));     }      private String probe(String path) throws Exception {         return getDevice().executeShellCommand(""if [ -e "" + path + "" ] ; then""                 + "" cat "" + path + "" ; else echo -1 ; fi"");     }      /**      * Determines whether perfetto enabled the kernel ftrace tracer.      */     protected boolean isSystemTracingEnabled() throws Exception {         final String traceFsPath = ""/sys/kernel/tracing/tracing_on"";         String tracing_on = probe(traceFsPath);         if (tracing_on.startsWith(""0"")) return false;         if (tracing_on.startsWith(""1"")) return true;          // fallback to debugfs         LogUtil.CLog.d(""Unexpected state for %s = %s. Falling back to debugfs"", traceFsPath,                 tracing_on);          final String debugFsPath = ""/sys/kernel/debug/tracing/tracing_on"";         tracing_on = probe(debugFsPath);         if (tracing_on.startsWith(""0"")) return false;         if (tracing_on.startsWith(""1"")) return true;         throw new Exception(String.format(""Unexpected state for %s = %s"", traceFsPath, tracing_on));     }      protected static StatsdConfig.Builder createConfigBuilder() {       return StatsdConfig.newBuilder()           .setId(CONFIG_ID)           .addAllowedLogSource(""AID_SYSTEM"")           .addAllowedLogSource(""AID_BLUETOOTH"")           // TODO(b/134091167): Fix bluetooth source name issue in Auto platform.           .addAllowedLogSource(""com.android.bluetooth"")           .addAllowedLogSource(""AID_LMKD"")           .addAllowedLogSource(""AID_RADIO"")           .addAllowedLogSource(""AID_ROOT"")           .addAllowedLogSource(""AID_STATSD"")           .addAllowedLogSource(""com.android.systemui"")           .addAllowedLogSource(DeviceAtomTestCase.DEVICE_SIDE_TEST_PACKAGE)           .addDefaultPullPackages(""AID_RADIO"")           .addDefaultPullPackages(""AID_SYSTEM"")           .addWhitelistedAtomIds(Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER);     }      protected void createAndUploadConfig(int atomTag) throws Exception {         StatsdConfig.Builder conf = createConfigBuilder();         addAtomEvent(conf, atomTag);         uploadConfig(conf);     }      protected void uploadConfig(StatsdConfig.Builder config) throws Exception {         uploadConfig(config.build());     }      protected void uploadConfig(StatsdConfig config) throws Exception {         LogUtil.CLog.d(""Uploading the following config:\n"" + config.toString());         File configFile = File.createTempFile(""statsdconfig"", "".config"");         configFile.deleteOnExit();         Files.write(config.toByteArray(), configFile);         String remotePath = ""/data/local/tmp/"" + configFile.getName();         getDevice().pushFile(configFile, remotePath);         getDevice().executeShellCommand(                 String.join("" "", ""cat"", remotePath, ""|"", UPDATE_CONFIG_CMD,                         String.valueOf(CONFIG_ID)));         getDevice().executeShellCommand(""rm "" + remotePath);     }      protected void removeConfig(long configId) throws Exception {         getDevice().executeShellCommand(                 String.join("" "", REMOVE_CONFIG_CMD, String.valueOf(configId)));     }      /** Gets the statsd report and sorts it. Note that this also deletes that report from statsd. */     protected List<EventMetricData> getEventMetricDataList() throws Exception {         ConfigMetricsReportList reportList = getReportList();         return getEventMetricDataList(reportList);     }      /**      *  Gets a List of sorted ConfigMetricsReports from ConfigMetricsReportList.      */     protected List<ConfigMetricsReport> getSortedConfigMetricsReports(             ConfigMetricsReportList configMetricsReportList) {         return configMetricsReportList.getReportsList().stream()                 .sorted(Comparator.comparing(ConfigMetricsReport::getCurrentReportWallClockNanos))                 .collect(Collectors.toList());     }      /**      * Extracts and sorts the EventMetricData from the given ConfigMetricsReportList (which must      * contain a single report).      */     protected List<EventMetricData> getEventMetricDataList(ConfigMetricsReportList reportList)             throws Exception {         assertThat(reportList.getReportsCount()).isEqualTo(1);         ConfigMetricsReport report = reportList.getReports(0);          List<EventMetricData> data = new ArrayList<>();         for (StatsLogReport metric : report.getMetricsList()) {             data.addAll(metric.getEventMetrics().getDataList());         }         data.sort(Comparator.comparing(EventMetricData::getElapsedTimestampNanos));          LogUtil.CLog.d(""Get EventMetricDataList as following:\n"");         for (EventMetricData d : data) {             LogUtil.CLog.d(""Atom at "" + d.getElapsedTimestampNanos() + "":\n"" + d.getAtom().toString());         }         return data;     }      protected List<Atom> getGaugeMetricDataList() throws Exception {         return getGaugeMetricDataList(/*checkTimestampTruncated=*/false);     }      protected List<Atom> getGaugeMetricDataList(boolean checkTimestampTruncated) throws Exception {         ConfigMetricsReportList reportList = getReportList();         assertThat(reportList.getReportsCount()).isEqualTo(1);          // only config         ConfigMetricsReport report = reportList.getReports(0);         assertThat(report.getMetricsCount()).isEqualTo(1);          List<Atom> data = new ArrayList<>();         for (GaugeMetricData gaugeMetricData :                 report.getMetrics(0).getGaugeMetrics().getDataList()) {             assertThat(gaugeMetricData.getBucketInfoCount()).isEqualTo(1);             GaugeBucketInfo bucketInfo = gaugeMetricData.getBucketInfo(0);             for (Atom atom : bucketInfo.getAtomList()) {                 data.add(atom);             }             if (checkTimestampTruncated) {                 for (long timestampNs: bucketInfo.getElapsedTimestampNanosList()) {                     assertTimestampIsTruncated(timestampNs);                 }             }         }          LogUtil.CLog.d(""Get GaugeMetricDataList as following:\n"");         for (Atom d : data) {             LogUtil.CLog.d(""Atom:\n"" + d.toString());         }         return data;     }      /**      * Gets the statsd report and extract duration metric data.      * Note that this also deletes that report from statsd.      */     protected List<DurationMetricData> getDurationMetricDataList() throws Exception {         ConfigMetricsReportList reportList = getReportList();         assertThat(reportList.getReportsCount()).isEqualTo(1);         ConfigMetricsReport report = reportList.getReports(0);          List<DurationMetricData> data = new ArrayList<>();         for (StatsLogReport metric : report.getMetricsList()) {             data.addAll(metric.getDurationMetrics().getDataList());         }          LogUtil.CLog.d(""Got DurationMetricDataList as following:\n"");         for (DurationMetricData d : data) {             LogUtil.CLog.d(""Duration "" + d);         }         return data;     }      /**      * Gets the statsd report and extract count metric data.      * Note that this also deletes that report from statsd.      */     protected List<CountMetricData> getCountMetricDataList() throws Exception {         ConfigMetricsReportList reportList = getReportList();         assertThat(reportList.getReportsCount()).isEqualTo(1);         ConfigMetricsReport report = reportList.getReports(0);          List<CountMetricData> data = new ArrayList<>();         for (StatsLogReport metric : report.getMetricsList()) {             data.addAll(metric.getCountMetrics().getDataList());         }          LogUtil.CLog.d(""Got CountMetricDataList as following:\n"");         for (CountMetricData d : data) {             LogUtil.CLog.d(""Count "" + d);         }         return data;     }      /**      * Gets the statsd report and extract value metric data.      * Note that this also deletes that report from statsd.      */     protected List<ValueMetricData> getValueMetricDataList() throws Exception {         ConfigMetricsReportList reportList = getReportList();         assertThat(reportList.getReportsCount()).isEqualTo(1);         ConfigMetricsReport report = reportList.getReports(0);          List<ValueMetricData> data = new ArrayList<>();         for (StatsLogReport metric : report.getMetricsList()) {             data.addAll(metric.getValueMetrics().getDataList());         }          LogUtil.CLog.d(""Got ValueMetricDataList as following:\n"");         for (ValueMetricData d : data) {             LogUtil.CLog.d(""Value "" + d);         }         return data;     }      protected StatsLogReport getStatsLogReport() throws Exception {         ConfigMetricsReport report = getConfigMetricsReport();         assertThat(report.hasUidMap()).isTrue();         assertThat(report.getMetricsCount()).isEqualTo(1);         return report.getMetrics(0);     }      protected ConfigMetricsReport getConfigMetricsReport() throws Exception {         ConfigMetricsReportList reportList = getReportList();         assertThat(reportList.getReportsCount()).isEqualTo(1);         return reportList.getReports(0);     }      /** Gets the statsd report. Note that this also deletes that report from statsd. */     protected ConfigMetricsReportList getReportList() throws Exception {         try {             ConfigMetricsReportList reportList = getDump(ConfigMetricsReportList.parser(),                     String.join("" "", DUMP_REPORT_CMD, String.valueOf(CONFIG_ID),                             ""--include_current_bucket"", ""--proto""));             return reportList;         } catch (com.google.protobuf.InvalidProtocolBufferException e) {             LogUtil.CLog.e(""Failed to fetch and parse the statsd output report. ""                     + ""Perhaps there is not a valid statsd config for the requested ""                     + ""uid="" + getHostUid() + "", id="" + CONFIG_ID + ""."");             throw (e);         }     }      protected BatteryStatsProto getBatteryStatsProto() throws Exception {         try {             BatteryStatsProto batteryStatsProto = getDump(BatteryStatsServiceDumpProto.parser(),                     String.join("" "", DUMP_BATTERYSTATS_CMD,                             ""--proto"")).getBatterystats();             LogUtil.CLog.d(""Got batterystats:\n "" + batteryStatsProto.toString());             return batteryStatsProto;         } catch (com.google.protobuf.InvalidProtocolBufferException e) {             LogUtil.CLog.e(""Failed to dump batterystats proto"");             throw (e);         }     }      /** Gets reports from the statsd data incident section from the stats dumpsys. */     protected List<ConfigMetricsReportList> getReportsFromStatsDataDumpProto() throws Exception {         try {             StatsDataDumpProto statsProto = getDump(StatsDataDumpProto.parser(),                     String.join("" "", DUMPSYS_STATS_CMD, ""--proto""));             // statsProto holds repeated bytes, which we must parse into ConfigMetricsReportLists.             List<ConfigMetricsReportList> reports                     = new ArrayList<>(statsProto.getConfigMetricsReportListCount());             for (ByteString reportListBytes : statsProto.getConfigMetricsReportListList()) {                 reports.add(ConfigMetricsReportList.parseFrom(reportListBytes));             }             LogUtil.CLog.d(""Got dumpsys stats output:\n "" + reports.toString());             return reports;         } catch (com.google.protobuf.InvalidProtocolBufferException e) {             LogUtil.CLog.e(""Failed to dumpsys stats proto"");             throw (e);         }     }      protected List<ProcessStatsProto> getProcStatsProto() throws Exception {         try {              List<ProcessStatsProto> processStatsProtoList =                 new ArrayList<ProcessStatsProto>();             android.service.procstats.ProcessStatsSectionProto sectionProto = getDump(                     ProcessStatsServiceDumpProto.parser(),                     String.join("" "", DUMP_PROCSTATS_CMD,                             ""--proto"")).getProcstatsNow();             for (android.service.procstats.ProcessStatsProto stats :                     sectionProto.getProcessStatsList()) {                 ProcessStatsProto procStats = ProcessStatsProto.parser().parseFrom(                     stats.toByteArray());                 processStatsProtoList.add(procStats);             }             LogUtil.CLog.d(""Got procstats:\n "");             for (ProcessStatsProto processStatsProto : processStatsProtoList) {                 LogUtil.CLog.d(processStatsProto.toString());             }             return processStatsProtoList;         } catch (com.google.protobuf.InvalidProtocolBufferException e) {             LogUtil.CLog.e(""Failed to dump procstats proto"");             throw (e);         }     }      /*      * Get all procstats package data in proto      */     protected List<ProcessStatsPackageProto> getAllProcStatsProto() throws Exception {         try {             android.service.procstats.ProcessStatsSectionProto sectionProto = getDump(                     ProcessStatsServiceDumpProto.parser(),                     String.join("" "", DUMP_PROCSTATS_CMD,                             ""--proto"")).getProcstatsOver24Hrs();             List<ProcessStatsPackageProto> processStatsProtoList =                 new ArrayList<ProcessStatsPackageProto>();             for (android.service.procstats.ProcessStatsPackageProto pkgStast :                 sectionProto.getPackageStatsList()) {               ProcessStatsPackageProto pkgAtom =                   ProcessStatsPackageProto.parser().parseFrom(pkgStast.toByteArray());                 processStatsProtoList.add(pkgAtom);             }             LogUtil.CLog.d(""Got procstats:\n "");             for (ProcessStatsPackageProto processStatsProto : processStatsProtoList) {                 LogUtil.CLog.d(processStatsProto.toString());             }             return processStatsProtoList;         } catch (com.google.protobuf.InvalidProtocolBufferException e) {             LogUtil.CLog.e(""Failed to dump procstats proto"");             throw (e);         }     }      /*      * Get all processes' procstats statsd data in proto      */     protected List<android.service.procstats.ProcessStatsProto> getAllProcStatsProtoForStatsd()             throws Exception {         try {             android.service.procstats.ProcessStatsSectionProto sectionProto = getDump(                     android.service.procstats.ProcessStatsSectionProto.parser(),                     String.join("" "", DUMP_PROCSTATS_CMD,                             ""--statsd""));             List<android.service.procstats.ProcessStatsProto> processStatsProtoList                     = sectionProto.getProcessStatsList();             LogUtil.CLog.d(""Got procstats:\n "");             for (android.service.procstats.ProcessStatsProto processStatsProto                     : processStatsProtoList) {                 LogUtil.CLog.d(processStatsProto.toString());             }             return processStatsProtoList;         } catch (com.google.protobuf.InvalidProtocolBufferException e) {             LogUtil.CLog.e(""Failed to dump procstats proto"");             throw (e);         }     }      protected boolean hasBattery() throws Exception {         try {             BatteryServiceDumpProto batteryProto = getDump(BatteryServiceDumpProto.parser(),                     String.join("" "", DUMP_BATTERY_CMD, ""--proto""));             LogUtil.CLog.d(""Got battery service dump:\n "" + batteryProto.toString());             return batteryProto.getIsPresent();         } catch (com.google.protobuf.InvalidProtocolBufferException e) {             LogUtil.CLog.e(""Failed to dump batteryservice proto"");             throw (e);         }     }      /** Creates a FieldValueMatcher.Builder corresponding to the given field. */     protected static FieldValueMatcher.Builder createFvm(int field) {         return FieldValueMatcher.newBuilder().setField(field);     }      protected void addAtomEvent(StatsdConfig.Builder conf, int atomTag) throws Exception {         addAtomEvent(conf, atomTag, new ArrayList<FieldValueMatcher.Builder>());     }      /**      * Adds an event to the config for an atom that matches the given key.      *      * @param conf    configuration      * @param atomTag atom tag (from atoms.proto)      * @param fvm     FieldValueMatcher.Builder for the relevant key      */     protected void addAtomEvent(StatsdConfig.Builder conf, int atomTag,             FieldValueMatcher.Builder fvm)             throws Exception {         addAtomEvent(conf, atomTag, Arrays.asList(fvm));     }      /**      * Adds an event to the config for an atom that matches the given keys.      *      * @param conf   configuration      * @param atomId atom tag (from atoms.proto)      * @param fvms   list of FieldValueMatcher.Builders to attach to the atom. May be null.      */     protected void addAtomEvent(StatsdConfig.Builder conf, int atomId,             List<FieldValueMatcher.Builder> fvms) throws Exception {          final String atomName = ""Atom"" + System.nanoTime();         final String eventName = ""Event"" + System.nanoTime();          SimpleAtomMatcher.Builder sam = SimpleAtomMatcher.newBuilder().setAtomId(atomId);         if (fvms != null) {             for (FieldValueMatcher.Builder fvm : fvms) {                 sam.addFieldValueMatcher(fvm);             }         }         conf.addAtomMatcher(AtomMatcher.newBuilder()                 .setId(atomName.hashCode())                 .setSimpleAtomMatcher(sam));         conf.addEventMetric(EventMetric.newBuilder()                 .setId(eventName.hashCode())                 .setWhat(atomName.hashCode()));     }      /**      * Adds an atom to a gauge metric of a config      *      * @param conf        configuration      * @param atomId      atom id (from atoms.proto)      * @param gaugeMetric the gauge metric to add      */     protected void addGaugeAtom(StatsdConfig.Builder conf, int atomId,             GaugeMetric.Builder gaugeMetric) throws Exception {         final String atomName = ""Atom"" + System.nanoTime();         final String gaugeName = ""Gauge"" + System.nanoTime();         final String predicateName = ""APP_BREADCRUMB"";         SimpleAtomMatcher.Builder sam = SimpleAtomMatcher.newBuilder().setAtomId(atomId);         conf.addAtomMatcher(AtomMatcher.newBuilder()                 .setId(atomName.hashCode())                 .setSimpleAtomMatcher(sam));         final String predicateTrueName = ""APP_BREADCRUMB_1"";         final String predicateFalseName = ""APP_BREADCRUMB_2"";         conf.addAtomMatcher(AtomMatcher.newBuilder()                 .setId(predicateTrueName.hashCode())                 .setSimpleAtomMatcher(SimpleAtomMatcher.newBuilder()                         .setAtomId(Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER)                         .addFieldValueMatcher(FieldValueMatcher.newBuilder()                                 .setField(AppBreadcrumbReported.LABEL_FIELD_NUMBER)                                 .setEqInt(1)                         )                 )         )                 // Used to trigger predicate                 .addAtomMatcher(AtomMatcher.newBuilder()                         .setId(predicateFalseName.hashCode())                         .setSimpleAtomMatcher(SimpleAtomMatcher.newBuilder()                                 .setAtomId(Atom.APP_BREADCRUMB_REPORTED_FIELD_NUMBER)                                 .addFieldValueMatcher(FieldValueMatcher.newBuilder()                                         .setField(AppBreadcrumbReported.LABEL_FIELD_NUMBER)                                         .setEqInt(2)                                 )                         )                 );         conf.addPredicate(Predicate.newBuilder()                 .setId(predicateName.hashCode())                 .setSimplePredicate(SimplePredicate.newBuilder()                         .setStart(predicateTrueName.hashCode())                         .setStop(predicateFalseName.hashCode())                         .setCountNesting(false)                 )         );         gaugeMetric                 .setId(gaugeName.hashCode())                 .setWhat(atomName.hashCode())                 .setCondition(predicateName.hashCode());         conf.addGaugeMetric(gaugeMetric.build());     }      /**      * Adds an atom to a gauge metric of a config      *      * @param conf      configuration      * @param atomId    atom id (from atoms.proto)      * @param dimension dimension is needed for most pulled atoms      */     protected void addGaugeAtomWithDimensions(StatsdConfig.Builder conf, int atomId,             @Nullable FieldMatcher.Builder dimension) throws Exception {         GaugeMetric.Builder gaugeMetric = GaugeMetric.newBuilder()                 .setGaugeFieldsFilter(FieldFilter.newBuilder().setIncludeAll(true).build())                 .setSamplingType(GaugeMetric.SamplingType.CONDITION_CHANGE_TO_TRUE)                 .setMaxNumGaugeAtomsPerBucket(10000)                 .setBucket(TimeUnit.CTS);         if (dimension != null) {             gaugeMetric.setDimensionsInWhat(dimension.build());         }         addGaugeAtom(conf, atomId, gaugeMetric);     }      /**      * Asserts that each set of states in stateSets occurs at least once in data.      * Asserts that the states in data occur in the same order as the sets in stateSets.      *      * @param stateSets        A list of set of states, where each set represents an equivalent      *                         state of the device for the purpose of CTS.      * @param data             list of EventMetricData from statsd, produced by      *                         getReportMetricListData()      * @param wait             expected duration (in ms) between state changes; asserts that the      *                         actual wait      *                         time was wait/2 <= actual_wait <= 5*wait. Use 0 to ignore this      *                         assertion.      * @param getStateFromAtom expression that takes in an Atom and returns the state it contains      */     public void assertStatesOccurred(List<Set<Integer>> stateSets, List<EventMetricData> data,             int wait, Function<Atom, Integer> getStateFromAtom) {         // Sometimes, there are more events than there are states.         // Eg: When the screen turns off, it may go into OFF and then DOZE immediately.         assertWithMessage(""Too few states found"").that(data.size()).isAtLeast(stateSets.size());         int stateSetIndex = 0; // Tracks which state set we expect the data to be in.         for (int dataIndex = 0; dataIndex < data.size(); dataIndex++) {             Atom atom = data.get(dataIndex).getAtom();             int state = getStateFromAtom.apply(atom);             // If state is in the current state set, we do not assert anything.             // If it is not, we expect to have transitioned to the next state set.             if (stateSets.get(stateSetIndex).contains(state)) {                 // No need to assert anything. Just log it.                 LogUtil.CLog.i(""The following atom at dataIndex="" + dataIndex + "" is ""                         + ""in stateSetIndex "" + stateSetIndex + "":\n""                         + data.get(dataIndex).getAtom().toString());             } else {                 stateSetIndex += 1;                 LogUtil.CLog.i(""Assert that the following atom at dataIndex="" + dataIndex + "" is""                         + "" in stateSetIndex "" + stateSetIndex + "":\n""                         + data.get(dataIndex).getAtom().toString());                 assertWithMessage(""Missed first state"").that(dataIndex).isNotEqualTo(0);                 assertWithMessage(""Too many states"").that(stateSetIndex)                     .isLessThan(stateSets.size());                 assertWithMessage(String.format(""Is in wrong state (%d)"", state))                     .that(stateSets.get(stateSetIndex)).contains(state);                 if (wait > 0) {                     assertTimeDiffBetween(data.get(dataIndex - 1), data.get(dataIndex),                             wait / 2, wait * 5);                 }             }         }         assertWithMessage(""Too few states"").that(stateSetIndex).isEqualTo(stateSets.size() - 1);     }      /**      * Removes all elements from data prior to the first occurrence of an element of state. After      * this method is called, the first element of data (if non-empty) is guaranteed to be an      * element in state.      *      * @param getStateFromAtom expression that takes in an Atom and returns the state it contains      */     public void popUntilFind(List<EventMetricData> data, Set<Integer> state,             Function<Atom, Integer> getStateFromAtom) {         int firstStateIdx;         for (firstStateIdx = 0; firstStateIdx < data.size(); firstStateIdx++) {             Atom atom = data.get(firstStateIdx).getAtom();             if (state.contains(getStateFromAtom.apply(atom))) {                 break;             }         }         if (firstStateIdx == 0) {             // First first element already is in state, so there's nothing to do.             return;         }         data.subList(0, firstStateIdx).clear();     }      /**      * Removes all elements from data after to the last occurrence of an element of state. After      * this method is called, the last element of data (if non-empty) is guaranteed to be an      * element in state.      *      * @param getStateFromAtom expression that takes in an Atom and returns the state it contains      */     public void popUntilFindFromEnd(List<EventMetricData> data, Set<Integer> state,         Function<Atom, Integer> getStateFromAtom) {         int lastStateIdx;         for (lastStateIdx = data.size() - 1; lastStateIdx >= 0; lastStateIdx--) {             Atom atom = data.get(lastStateIdx).getAtom();             if (state.contains(getStateFromAtom.apply(atom))) {                 break;             }         }         if (lastStateIdx == data.size()-1) {             // Last element already is in state, so there's nothing to do.             return;         }         data.subList(lastStateIdx+1, data.size()).clear();     }      /** Returns the UID of the host, which should always either be SHELL (2000) or ROOT (0). */     protected int getHostUid() throws DeviceNotAvailableException {         String strUid = """";         try {             strUid = getDevice().executeShellCommand(""id -u"");             return Integer.parseInt(strUid.trim());         } catch (NumberFormatException e) {             LogUtil.CLog.e(""Failed to get host's uid via shell command. Found "" + strUid);             // Fall back to alternative method...             if (getDevice().isAdbRoot()) {                 return 0; // ROOT             } else {                 return 2000; // SHELL             }         }     }      protected String getProperty(String prop) throws Exception {         return getDevice().executeShellCommand(""getprop "" + prop).replace(""\n"", """");     }      protected void turnScreenOn() throws Exception {         getDevice().executeShellCommand(""input keyevent KEYCODE_WAKEUP"");         getDevice().executeShellCommand(""wm dismiss-keyguard"");     }      protected void turnScreenOff() throws Exception {         getDevice().executeShellCommand(""input keyevent KEYCODE_SLEEP"");     }      protected void setChargingState(int state) throws Exception {         getDevice().executeShellCommand(""cmd battery set status "" + state);     }      protected void unplugDevice() throws Exception {         // On batteryless devices on Android P or above, the 'unplug' command         // alone does not simulate the really unplugged state.         //         // This is because charging state is left as ""unknown"". Unless a valid         // state like 3 = BatteryManager.BATTERY_STATUS_DISCHARGING is set,         // framework does not consider the device as running on battery.         setChargingState(3);          getDevice().executeShellCommand(""cmd battery unplug"");     }      protected void plugInAc() throws Exception {         getDevice().executeShellCommand(""cmd battery set ac 1"");     }      protected void plugInUsb() throws Exception {         getDevice().executeShellCommand(""cmd battery set usb 1"");     }      protected void plugInWireless() throws Exception {         getDevice().executeShellCommand(""cmd battery set wireless 1"");     }      protected void enableLooperStats() throws Exception {         getDevice().executeShellCommand(""cmd looper_stats enable"");     }      protected void resetLooperStats() throws Exception {         getDevice().executeShellCommand(""cmd looper_stats reset"");     }      protected void disableLooperStats() throws Exception {         getDevice().executeShellCommand(""cmd looper_stats disable"");     }      protected void enableBinderStats() throws Exception {         getDevice().executeShellCommand(""dumpsys binder_calls_stats --enable"");     }      protected void resetBinderStats() throws Exception {         getDevice().executeShellCommand(""dumpsys binder_calls_stats --reset"");     }      protected void disableBinderStats() throws Exception {         getDevice().executeShellCommand(""dumpsys binder_calls_stats --disable"");     }      protected void binderStatsNoSampling() throws Exception {         getDevice().executeShellCommand(""dumpsys binder_calls_stats --no-sampling"");     }      protected void setUpLooperStats() throws Exception {         getDevice().executeShellCommand(""cmd looper_stats enable"");         getDevice().executeShellCommand(""cmd looper_stats sampling_interval 1"");         getDevice().executeShellCommand(""cmd looper_stats reset"");     }      protected void cleanUpLooperStats() throws Exception {         getDevice().executeShellCommand(""cmd looper_stats disable"");     }      public void setAppBreadcrumbPredicate() throws Exception {         doAppBreadcrumbReportedStart(1);     }      public void clearAppBreadcrumbPredicate() throws Exception {         doAppBreadcrumbReportedStart(2);     }      public void doAppBreadcrumbReportedStart(int label) throws Exception {         doAppBreadcrumbReported(label, AppBreadcrumbReported.State.START.ordinal());     }      public void doAppBreadcrumbReportedStop(int label) throws Exception {         doAppBreadcrumbReported(label, AppBreadcrumbReported.State.STOP.ordinal());     }      public void doAppBreadcrumbReported(int label) throws Exception {         doAppBreadcrumbReported(label, AppBreadcrumbReported.State.UNSPECIFIED.ordinal());     }      public void doAppBreadcrumbReported(int label, int state) throws Exception {         getDevice().executeShellCommand(String.format(                 ""cmd stats log-app-breadcrumb %d %d"", label, state));     }      protected void setBatteryLevel(int level) throws Exception {         getDevice().executeShellCommand(""cmd battery set level "" + level);     }      protected void resetBatteryStatus() throws Exception {         getDevice().executeShellCommand(""cmd battery reset"");     }      protected int getScreenBrightness() throws Exception {         return Integer.parseInt(                 getDevice().executeShellCommand(""settings get system screen_brightness"").trim());     }      protected void setScreenBrightness(int brightness) throws Exception {         getDevice().executeShellCommand(""settings put system screen_brightness "" + brightness);     }      // Gets whether ""Always on Display"" setting is enabled.     // In rare cases, this is different from whether the device can enter SCREEN_STATE_DOZE.     protected String getAodState() throws Exception {         return getDevice().executeShellCommand(""settings get secure doze_always_on"");     }      protected void setAodState(String state) throws Exception {         getDevice().executeShellCommand(""settings put secure doze_always_on "" + state);     }      protected boolean isScreenBrightnessModeManual() throws Exception {         String mode = getDevice().executeShellCommand(""settings get system screen_brightness_mode"");         return Integer.parseInt(mode.trim()) == 0;     }      protected void setScreenBrightnessMode(boolean manual) throws Exception {         getDevice().executeShellCommand(                 ""settings put system screen_brightness_mode "" + (manual ? 0 : 1));     }      protected void enterDozeModeLight() throws Exception {         getDevice().executeShellCommand(""dumpsys deviceidle force-idle light"");     }      protected void enterDozeModeDeep() throws Exception {         getDevice().executeShellCommand(""dumpsys deviceidle force-idle deep"");     }      protected void leaveDozeMode() throws Exception {         getDevice().executeShellCommand(""dumpsys deviceidle unforce"");         getDevice().executeShellCommand(""dumpsys deviceidle disable"");         getDevice().executeShellCommand(""dumpsys deviceidle enable"");     }      protected void turnBatterySaverOn() throws Exception {         unplugDevice();         getDevice().executeShellCommand(""settings put global low_power 1"");     }      protected void turnBatterySaverOff() throws Exception {         getDevice().executeShellCommand(""settings put global low_power 0"");         getDevice().executeShellCommand(""cmd battery reset"");     }      protected void rebootDevice() throws Exception {         getDevice().rebootUntilOnline();     }      /**      * Asserts that the two events are within the specified range of each other.      *      * @param d0        the event that should occur first      * @param d1        the event that should occur second      * @param minDiffMs d0 should precede d1 by at least this amount      * @param maxDiffMs d0 should precede d1 by at most this amount      */     public static void assertTimeDiffBetween(EventMetricData d0, EventMetricData d1,             int minDiffMs, int maxDiffMs) {         long diffMs = (d1.getElapsedTimestampNanos() - d0.getElapsedTimestampNanos()) / 1_000_000;         assertWithMessage(""Illegal time difference"")             .that(diffMs).isIn(Range.closed((long) minDiffMs, (long) maxDiffMs));     }      protected String getCurrentLogcatDate() throws Exception {         // TODO: Do something more robust than this for getting logcat markers.         long timestampMs = getDevice().getDeviceDate();         return new SimpleDateFormat(""MM-dd HH:mm:ss.SSS"")                 .format(new Date(timestampMs));     }      protected String getLogcatSince(String date, String logcatParams) throws Exception {         return getDevice().executeShellCommand(String.format(                 ""logcat -v threadtime -t '%s' -d %s"", date, logcatParams));     }      // TODO: Remove this and migrate all usages to createConfigBuilder()     protected StatsdConfig.Builder getPulledConfig() {         return createConfigBuilder();     }     /**      * Determines if the device has the given feature.      * Prints a warning if its value differs from requiredAnswer.      */     protected boolean hasFeature(String featureName, boolean requiredAnswer) throws Exception {         final String features = getDevice().executeShellCommand(""pm list features"");         StringTokenizer featureToken = new StringTokenizer(features, ""\n"");         boolean hasIt = false;          while (featureToken.hasMoreTokens()) {             if ((""feature:"" + featureName).equals(featureToken.nextToken())) {                  hasIt = true;                  break;             }         }          if (hasIt != requiredAnswer) {             LogUtil.CLog.w(""Device does "" + (requiredAnswer ? ""not "" : """") + ""have feature ""                     + featureName);         }         return hasIt == requiredAnswer;     }      /**      * Determines if the device has |file|.      */     protected boolean doesFileExist(String file) throws Exception {         return getDevice().doesFileExist(file);     }      protected void turnOnAirplaneMode() throws Exception {         getDevice().executeShellCommand(""cmd connectivity airplane-mode enable"");     }      protected void turnOffAirplaneMode() throws Exception {         getDevice().executeShellCommand(""cmd connectivity airplane-mode disable"");     }      /**      * Returns a list of fields and values for {@code className} from {@link TelephonyDebugService}      * output.      *      * <p>Telephony dumpsys output does not support proto at the moment. This method provides      * limited support for parsing its output. Specifically, it does not support arrays or      * multi-line values.      */     private List<Map<String, String>> getTelephonyDumpEntries(String className) throws Exception {         // Matches any line with indentation, except for lines with only spaces         Pattern indentPattern = Pattern.compile(""^(\\s*)[^ ].*$"");         // Matches pattern for class, e.g. ""    Phone:""         Pattern classNamePattern = Pattern.compile(""^(\\s*)"" + Pattern.quote(className) + "":.*$"");         // Matches pattern for key-value pairs, e.g. ""     mPhoneId=1""         Pattern keyValuePattern = Pattern.compile(""^(\\s*)([a-zA-Z]+[a-zA-Z0-9_]*)\\=(.+)$"");         String response =                 getDevice().executeShellCommand(""dumpsys activity service TelephonyDebugService"");         Queue<String> responseLines = new LinkedList<>(Arrays.asList(response.split(""[\\r\\n]+"")));          List<Map<String, String>> results = new ArrayList<>();         while (responseLines.peek() != null) {             Matcher matcher = classNamePattern.matcher(responseLines.poll());             if (matcher.matches()) {                 final int classIndentLevel = matcher.group(1).length();                 final Map<String, String> instanceEntries = new HashMap<>();                 while (responseLines.peek() != null) {                     // Skip blank lines                     matcher = indentPattern.matcher(responseLines.peek());                     if (responseLines.peek().length() == 0 || !matcher.matches()) {                         responseLines.poll();                         continue;                     }                     // Finish (without consuming the line) if already parsed past this instance                     final int indentLevel = matcher.group(1).length();                     if (indentLevel <= classIndentLevel) {                         break;                     }                     // Parse key-value pair if it belongs to the instance directly                     matcher = keyValuePattern.matcher(responseLines.poll());                     if (indentLevel == classIndentLevel + 1 && matcher.matches()) {                         instanceEntries.put(matcher.group(2), matcher.group(3));                     }                 }                 results.add(instanceEntries);             }         }         return results;     }      protected int getActiveSimSlotCount() throws Exception {         List<Map<String, String>> slots = getTelephonyDumpEntries(""UiccSlot"");         long count = slots.stream().filter(slot -> ""true"".equals(slot.get(""mActive""))).count();         return Math.toIntExact(count);     }      /**      * Returns the upper bound of active SIM profile count.      *      * <p>The value is an upper bound as eSIMs without profiles are also counted in.      */     protected int getActiveSimCountUpperBound() throws Exception {         List<Map<String, String>> slots = getTelephonyDumpEntries(""UiccSlot"");         long count = slots.stream().filter(slot ->                 ""true"".equals(slot.get(""mActive""))                 && ""CARDSTATE_PRESENT"".equals(slot.get(""mCardState""))).count();         return Math.toIntExact(count);     }      /**      * Returns the upper bound of active eSIM profile count.      *      * <p>The value is an upper bound as eSIMs without profiles are also counted in.      */     protected int getActiveEsimCountUpperBound() throws Exception {         List<Map<String, String>> slots = getTelephonyDumpEntries(""UiccSlot"");         long count = slots.stream().filter(slot ->                 ""true"".equals(slot.get(""mActive""))                 && ""CARDSTATE_PRESENT"".equals(slot.get(""mCardState""))                 && ""true"".equals(slot.get(""mIsEuicc""))).count();         return Math.toIntExact(count);     }      protected boolean hasGsmPhone() throws Exception {         // Not using log entries or ServiceState in the dump since they may or may not be present,         // which can make the test flaky         return getTelephonyDumpEntries(""Phone"").stream()                 .anyMatch(phone ->                         String.format(""%d"", PHONE_TYPE_GSM).equals(phone.get(""getPhoneType()"")));     }      protected boolean hasCdmaPhone() throws Exception {         // Not using log entries or ServiceState in the dump due to the same reason as hasGsmPhone()         return getTelephonyDumpEntries(""Phone"").stream()                 .anyMatch(phone ->                         String.format(""%d"", PHONE_TYPE_CDMA).equals(phone.get(""getPhoneType()""))                         || String.format(""%d"", PHONE_TYPE_CDMA_LTE)                                 .equals(phone.get(""getPhoneType()"")));     }      // Checks that a timestamp has been truncated to be a multiple of 5 min     protected void assertTimestampIsTruncated(long timestampNs) {         long fiveMinutesInNs = NS_PER_SEC * 5 * 60;         assertWithMessage(""Timestamp is not truncated"")                 .that(timestampNs % fiveMinutesInNs).isEqualTo(0);     } }"	""	""	""	""	""
