"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.media.cts.MediaCodecClearKeyPlayer"	"adoptShellPermissionIdentity"	""	"/home/gpoor/cts-12-source/cts/tests/tests/media/common/src/android/media/cts/MediaCodecClearKeyPlayer.java"	""	"public void test/*
 *.
 */
package android.media.cts;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.AssetFileDescriptor;
import android.media.AudioManager;
import android.media.DrmInitData;
import android.media.MediaCas;
import android.media.MediaCasException;
import android.media.MediaCasException.UnsupportedCasException;
import android.media.MediaCodec;
import android.media.MediaCodecInfo;
import android.media.MediaCodecList;
import android.media.MediaCrypto;
import android.media.MediaCryptoException;
import android.media.MediaDescrambler;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.net.Uri;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import android.view.Surface;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * JB(API 16) introduces {@link MediaCodec} API.  It allows apps have more control over
 * media playback, pushes individual frames to decoder and supports decryption via
 * {@link MediaCrypto} API.
 *
 * {@link MediaDrm} can be used to obtain keys for decrypting protected media streams,
 * in conjunction with MediaCrypto.
 */
public class MediaCodecClearKeyPlayer implements MediaTimeProvider {
    private static final String TAG = MediaCodecClearKeyPlayer.class.getSimpleName();

    private static final String FILE_SCHEME = ""file://"";

    private static final int STATE_IDLE = 1;
    private static final int STATE_PREPARING = 2;
    private static final int STATE_PLAYING = 3;
    private static final int STATE_PAUSED = 4;

    private static final UUID CLEARKEY_SCHEME_UUID =
            new UUID(0x1077efecc0b24d02L, 0xace33c1e52e2fb4bL);

    private boolean mEncryptedAudio;
    private boolean mEncryptedVideo;
    private volatile boolean mThreadStarted = false;
    private byte[] mSessionId;
    private boolean mScrambled;
    private CodecState mAudioTrackState;
    private int mMediaFormatHeight;
    private int mMediaFormatWidth;
    private int mState;
    private long mDeltaTimeUs;
    private long mDurationUs;
    private Map<Integer, CodecState> mAudioCodecStates;
    private Map<Integer, CodecState> mVideoCodecStates;
    private Map<String, String> mAudioHeaders;
    private Map<String, String> mVideoHeaders;
    private Map<UUID, byte[]> mPsshInitData;
    private MediaCrypto mCrypto;
    private MediaCas mMediaCas;
    private MediaDescrambler mAudioDescrambler;
    private MediaDescrambler mVideoDescrambler;
    private MediaExtractor mAudioExtractor;
    private MediaExtractor mVideoExtractor;
    private Deque<Surface> mSurfaces;
    private Thread mThread;
    private Uri mAudioUri;
    private Uri mVideoUri;
    private Context mContext;
    private Resources mResources;
    private Error mErrorFromThread;

    private static final byte[] PSSH = hexStringToByteArray(
            // BMFF box header (4 bytes size + 'pssh')
            ""0000003470737368"" +
            // Full box header (version = 1 flags = 0
            ""01000000"" +
            // SystemID
            ""1077efecc0b24d02ace33c1e52e2fb4b"" +
            // Number of key ids
            ""00000001"" +
            // Key id
            ""30303030303030303030303030303030"" +
            // size of data, must be zero
            ""00000000"");

    // ClearKey CAS/Descrambler test provision string
    private static final String sProvisionStr =
            ""{                                                   "" +
            ""  \""id\"": 21140844,                                 "" +
            ""  \""name\"": \""Test Title\"",                         "" +
            ""  \""lowercase_organization_name\"": \""Android\"",     "" +
            ""  \""asset_key\"": {                                  "" +
            ""  \""encryption_key\"": \""nezAr3CHFrmBR9R8Tedotw==\""  "" +
            ""  },                                                "" +
            ""  \""cas_type\"": 1,                                  "" +
            ""  \""track_types\"": [ ]                              "" +
            ""}                                                   "" ;

    // ClearKey private data (0-bytes of length 4)
    private static final byte[] sCasPrivateInfo = hexStringToByteArray(""00000000"");

    /**
     * Convert a hex string into byte array.
     */
    private static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
                    + Character.digit(s.charAt(i + 1), 16));
        }
        return data;
    }

    /*
     * Media player class to stream CENC content using MediaCodec class.
     */
    public MediaCodecClearKeyPlayer(
            List<Surface> surfaces, byte[] sessionId, boolean scrambled, Context context) {
        mSessionId = sessionId;
        mScrambled = scrambled;
        mSurfaces = new ArrayDeque<>(surfaces);
        mContext = context;
        mResources = context.getResources();
        mState = STATE_IDLE;
        mThread = new Thread(new Runnable() {
            @Override
            public void run() {
                int n = 0;
                while (mThreadStarted == true) {
                    doSomeWork();
                    if (mAudioTrackState != null) {
                        mAudioTrackState.processAudioTrack();
                    }
                    try {
                        Thread.sleep(5);
                    } catch (InterruptedException ex) {
                        Log.d(TAG, ""Thread interrupted"");
                    }
                    if(++n % 1000 == 0) {
                        cycleSurfaces();
                    }
                }
                if (mAudioTrackState != null) {
                    mAudioTrackState.stopAudioTrack();
                }
            }
        });
    }

    public void setAudioDataSource(Uri uri, Map<String, String> headers, boolean encrypted) {
        mAudioUri = uri;
        mAudioHeaders = headers;
        mEncryptedAudio = encrypted;
    }

    public void setVideoDataSource(Uri uri, Map<String, String> headers, boolean encrypted) {
        mVideoUri = uri;
        mVideoHeaders = headers;
        mEncryptedVideo = encrypted;
    }

    public final int getMediaFormatHeight() {
        return mMediaFormatHeight;
    }

    public final int getMediaFormatWidth() {
        return mMediaFormatWidth;
    }

    public final byte[] getDrmInitData() {
        for (MediaExtractor ex: new MediaExtractor[] {mVideoExtractor, mAudioExtractor}) {
            DrmInitData drmInitData = ex.getDrmInitData();
            if (drmInitData != null) {
                DrmInitData.SchemeInitData schemeInitData = drmInitData.get(CLEARKEY_SCHEME_UUID);
                if (schemeInitData != null && schemeInitData.data != null) {
                    // llama content still does not contain pssh data, return hard coded PSSH
                    return (schemeInitData.data.length > 1)? schemeInitData.data : PSSH;
                }
            }
        }
        // Should not happen after we get content that has the clear key system id.
        return PSSH;
    }

    private void prepareAudio() throws IOException, MediaCasException {
        boolean hasAudio = false;
        for (int i = mAudioExtractor.getTrackCount(); i-- > 0;) {
            MediaFormat format = mAudioExtractor.getTrackFormat(i);
            String mime = format.getString(MediaFormat.KEY_MIME);
            if (!mime.startsWith(""audio/"")) {
                continue;
            }

            Log.d(TAG, ""audio track #"" + i + "" "" + format + "" "" + mime +
                  "" Is ADTS:"" + getMediaFormatInteger(format, MediaFormat.KEY_IS_ADTS) +
                  "" Sample rate:"" + getMediaFormatInteger(format, MediaFormat.KEY_SAMPLE_RATE) +
                  "" Channel count:"" +
                  getMediaFormatInteger(format, MediaFormat.KEY_CHANNEL_COUNT));

            if (mScrambled) {
                MediaExtractor.CasInfo casInfo = mAudioExtractor.getCasInfo(i);
                if (casInfo != null && casInfo.getSession() != null) {
                    mAudioDescrambler = new MediaDescrambler(casInfo.getSystemId());
                    mAudioDescrambler.setMediaCasSession(casInfo.getSession());
                }
            }

            if (!hasAudio) {
                mAudioExtractor.selectTrack(i);
                addTrack(i, format, mEncryptedAudio);
                hasAudio = true;

                if (format.containsKey(MediaFormat.KEY_DURATION)) {
                    long durationUs = format.getLong(MediaFormat.KEY_DURATION);

                    if (durationUs > mDurationUs) {
                        mDurationUs = durationUs;
                    }
                    Log.d(TAG, ""audio track format #"" + i +
                            "" Duration:"" + mDurationUs + "" microseconds"");
                }

                if (hasAudio) {
                    break;
                }
            }
        }
    }

    private void prepareVideo() throws IOException, MediaCasException {
        boolean hasVideo = false;

        for (int i = mVideoExtractor.getTrackCount(); i-- > 0;) {
            MediaFormat format = mVideoExtractor.getTrackFormat(i);
            String mime = format.getString(MediaFormat.KEY_MIME);
            if (!mime.startsWith(""video/"")) {
                continue;
            }

            mMediaFormatHeight = getMediaFormatInteger(format, MediaFormat.KEY_HEIGHT);
            mMediaFormatWidth = getMediaFormatInteger(format, MediaFormat.KEY_WIDTH);
            Log.d(TAG, ""video track #"" + i + "" "" + format + "" "" + mime +
                  "" Width:"" + mMediaFormatWidth + "", Height:"" + mMediaFormatHeight);

            if (mScrambled) {
                MediaExtractor.CasInfo casInfo = mVideoExtractor.getCasInfo(i);
                if (casInfo != null && casInfo.getSession() != null) {
                    mVideoDescrambler = new MediaDescrambler(casInfo.getSystemId());
                    mVideoDescrambler.setMediaCasSession(casInfo.getSession());
                }
            }

            if (!hasVideo) {
                mVideoExtractor.selectTrack(i);
                addTrack(i, format, mEncryptedVideo);

                hasVideo = true;

                if (format.containsKey(MediaFormat.KEY_DURATION)) {
                    long durationUs = format.getLong(MediaFormat.KEY_DURATION);

                    if (durationUs > mDurationUs) {
                        mDurationUs = durationUs;
                    }
                    Log.d(TAG, ""track format #"" + i + "" Duration:"" +
                            mDurationUs + "" microseconds"");
                }

                if (hasVideo) {
                    break;
                }
            }
        }
    }

    private void initCasAndDescrambler(MediaExtractor extractor) throws MediaCasException {
        int trackCount = extractor.getTrackCount();
        for (int trackId = 0; trackId < trackCount; trackId++) {
            android.media.MediaFormat format = extractor.getTrackFormat(trackId);
            String mime = format.getString(android.media.MediaFormat.KEY_MIME);
            Log.d(TAG, ""track ""+ trackId + "": "" + mime);
            if (MediaFormat.MIMETYPE_VIDEO_SCRAMBLED.equals(mime) ||
                    MediaFormat.MIMETYPE_AUDIO_SCRAMBLED.equals(mime)) {
                MediaExtractor.CasInfo casInfo = extractor.getCasInfo(trackId);
                if (casInfo != null) {
                    if (!Arrays.equals(sCasPrivateInfo, casInfo.getPrivateData())) {
                        throw new Error(""Cas private data mismatch"");
                    }
                    // Need MANAGE_USERS or CREATE_USERS permission to access
                    // ActivityManager#getCurrentUse in MediaCas, then adopt it from shell.
                    InstrumentationRegistry
                        .getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
                    try {
                        mMediaCas = new MediaCas(casInfo.getSystemId());
                    } finally {
                        InstrumentationRegistry
                            .getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
                    }

                    mMediaCas.provision(sProvisionStr);
                    extractor.setMediaCas(mMediaCas);
                    break;
                }
            }
        }
    }

    public void prepare() throws IOException, MediaCryptoException, MediaCasException {
        if (null == mCrypto && (mEncryptedVideo || mEncryptedAudio)) {
            try {
                byte[] initData = new byte[0];
                mCrypto = new MediaCrypto(CLEARKEY_SCHEME_UUID, initData);
            } catch (MediaCryptoException e) {
                reset();
                Log.e(TAG, ""Failed to create MediaCrypto instance."");
                throw e;
            }
            mCrypto.setMediaDrmSession(mSessionId);
        } else {
            reset();
        }

        if (null == mAudioExtractor) {
            mAudioExtractor = new MediaExtractor();
            if (null == mAudioExtractor) {
                Log.e(TAG, ""Cannot create Audio extractor."");
                return;
            }
        }
        mAudioExtractor.setDataSource(mContext, mAudioUri, mAudioHeaders);

        if (mScrambled) {
            initCasAndDescrambler(mAudioExtractor);
            mVideoExtractor = mAudioExtractor;
        } else {
            if (null == mVideoExtractor){
                mVideoExtractor = new MediaExtractor();
                if (null == mVideoExtractor) {
                    Log.e(TAG, ""Cannot create Video extractor."");
                    return;
                }
            }
            mVideoExtractor.setDataSource(mContext, mVideoUri, mVideoHeaders);
        }

        if (null == mVideoCodecStates) {
            mVideoCodecStates = new HashMap<Integer, CodecState>();
        } else {
            mVideoCodecStates.clear();
        }

        if (null == mAudioCodecStates) {
            mAudioCodecStates = new HashMap<Integer, CodecState>();
        } else {
            mAudioCodecStates.clear();
        }

        prepareVideo();
        prepareAudio();

        mState = STATE_PAUSED;
    }

    private void addTrack(int trackIndex, MediaFormat format,
            boolean encrypted) throws IOException {
        String mime = format.getString(MediaFormat.KEY_MIME);
        boolean isVideo = mime.startsWith(""video/"");
        boolean isAudio = mime.startsWith(""audio/"");

        MediaCodec codec;

        if (encrypted && mCrypto.requiresSecureDecoderComponent(mime)) {
            codec = MediaCodec.createByCodecName(
                    getSecureDecoderNameForMime(mime));
        } else {
            codec = MediaCodec.createDecoderByType(mime);
        }

        if (!mScrambled) {
            codec.configure(
                    format,
                    isVideo ? mSurfaces.getFirst() : null,
                    mCrypto,
                    0);
        } else {
            codec.configure(
                    format,
                    isVideo ? mSurfaces.getFirst() : null,
                    0,
                    isVideo ? mVideoDescrambler : mAudioDescrambler);
        }

        CodecState state;
        if (isVideo) {
            state = new CodecState((MediaTimeProvider)this, mVideoExtractor,
                            trackIndex, format, codec, true, false,
                            AudioManager.AUDIO_SESSION_ID_GENERATE);
            mVideoCodecStates.put(Integer.valueOf(trackIndex), state);
        } else {
            state = new CodecState((MediaTimeProvider)this, mAudioExtractor,
                            trackIndex, format, codec, true, false,
                            AudioManager.AUDIO_SESSION_ID_GENERATE);
            mAudioCodecStates.put(Integer.valueOf(trackIndex), state);
        }

        if (isAudio) {
            mAudioTrackState = state;
        }
    }

    protected int getMediaFormatInteger(MediaFormat format, String key) {
        return format.containsKey(key) ? format.getInteger(key) : 0;
    }

    // Find first secure decoder for media type. If none found, return
    // the name of the first regular codec with "".secure"" suffix added.
    // If all else fails, return null.
    protected String getSecureDecoderNameForMime(String mime) {
        String firstDecoderName = null;
        int n = MediaCodecList.getCodecCount();
        for (int i = 0; i < n; ++i) {
            MediaCodecInfo info = MediaCodecList.getCodecInfoAt(i);

            if (info.isEncoder()) {
                continue;
            }

            String[] supportedTypes = info.getSupportedTypes();

            for (int j = 0; j < supportedTypes.length; ++j) {
                if (supportedTypes[j].equalsIgnoreCase(mime)) {
                    if (info.getCapabilitiesForType(mime).isFeatureSupported(
                            MediaCodecInfo.CodecCapabilities.FEATURE_AdaptivePlayback)) {
                        return info.getName();
                    } else if (firstDecoderName == null) {
                        firstDecoderName = info.getName();
                    }
                }
            }
        }
        if (firstDecoderName != null) {
            return firstDecoderName + "".secure"";
        }
        return null;
    }

    public void start() {
        Log.d(TAG, ""start"");

        if (mState == STATE_PLAYING || mState == STATE_PREPARING) {
            return;
        } else if (mState == STATE_IDLE) {
            mState = STATE_PREPARING;
            return;
        } else if (mState != STATE_PAUSED) {
            throw new IllegalStateException();
        }

        for (CodecState state : mVideoCodecStates.values()) {
            state.start();
        }

        for (CodecState state : mAudioCodecStates.values()) {
            state.start();
        }

        mDeltaTimeUs = -1;
        mState = STATE_PLAYING;
    }

    public void startWork() throws IOException, MediaCryptoException, Exception {
        try {
            // Just change state from STATE_IDLE to STATE_PREPARING.
            start();
            // Extract media information from uri asset, and change state to STATE_PAUSED.
            prepare();
            // Start CodecState, and change from STATE_PAUSED to STATE_PLAYING.
            start();
        } catch (IOException e) {
            throw e;
        } catch (MediaCryptoException e) {
            throw e;
        }

        mThreadStarted = true;
        mThread.start();
    }

    public void startThread() {
        start();
        mThreadStarted = true;
        mThread.start();
    }

    public void pause() {
        Log.d(TAG, ""pause"");

        if (mState == STATE_PAUSED) {
            return;
        } else if (mState != STATE_PLAYING) {
            throw new IllegalStateException();
        }

        for (CodecState state : mVideoCodecStates.values()) {
            state.pause();
        }

        for (CodecState state : mAudioCodecStates.values()) {
            state.pause();
        }

        mState = STATE_PAUSED;
    }

    public void reset() {
        if (mState == STATE_PLAYING) {
            mThreadStarted = false;

            try {
                mThread.join();
            } catch (InterruptedException ex) {
                Log.d(TAG, ""mThread.join "" + ex);
            }

            pause();
        }

        if (mVideoCodecStates != null) {
            for (CodecState state : mVideoCodecStates.values()) {
                state.release();
            }
            mVideoCodecStates = null;
        }

        if (mAudioCodecStates != null) {
            for (CodecState state : mAudioCodecStates.values()) {
                state.release();
            }
            mAudioCodecStates = null;
        }

        if (mAudioExtractor != null) {
            mAudioExtractor.release();
            mAudioExtractor = null;
        }

        if (mVideoExtractor != null) {
            mVideoExtractor.release();
            mVideoExtractor = null;
        }

        if (mCrypto != null) {
            mCrypto.release();
            mCrypto = null;
        }

        if (mMediaCas != null) {
            mMediaCas.close();
            mMediaCas = null;
        }

        if (mAudioDescrambler != null) {
            mAudioDescrambler.close();
            mAudioDescrambler = null;
        }

        if (mVideoDescrambler != null) {
            mVideoDescrambler.close();
            mVideoDescrambler = null;
        }

        mDurationUs = -1;
        mState = STATE_IDLE;
    }

    public boolean isEnded() {
        if (mErrorFromThread != null) {
            throw mErrorFromThread;
        }
        for (CodecState state : mVideoCodecStates.values()) {
          if (!state.isEnded()) {
            return false;
          }
        }

        for (CodecState state : mAudioCodecStates.values()) {
            if (!state.isEnded()) {
              return false;
            }
        }

        return true;
    }

    private void doSomeWork() {
        try {
            for (CodecState state : mVideoCodecStates.values()) {
                state.doSomeWork();
            }
        } catch (MediaCodec.CryptoException e) {
            mErrorFromThread = new Error(""Video CryptoException w/ errorCode ""
                    + e.getErrorCode() + "", '"" + e.getMessage() + ""'"");
            return;
        } catch (IllegalStateException e) {
            mErrorFromThread =
                new Error(""Video CodecState.feedInputBuffer IllegalStateException "" + e);
            return;
        }

        try {
            for (CodecState state : mAudioCodecStates.values()) {
                state.doSomeWork();
            }
        } catch (MediaCodec.CryptoException e) {
            mErrorFromThread = new Error(""Audio CryptoException w/ errorCode ""
                    + e.getErrorCode() + "", '"" + e.getMessage() + ""'"");
            return;
        } catch (IllegalStateException e) {
            mErrorFromThread =
                new Error(""Audio CodecState.feedInputBuffer IllegalStateException "" + e);
            return;
        }
    }

    private void cycleSurfaces() {
        if (mSurfaces.size() > 1) {
            final Surface s = mSurfaces.removeFirst();
            mSurfaces.addLast(s);
            for (CodecState c : mVideoCodecStates.values()) {
                c.setOutputSurface(mSurfaces.getFirst());
                /*
                 * Calling InputSurface.clearSurface on an old `output` surface because after
                 * MediaCodec has rendered to the old output surface, we need `edit`
                 * (i.e. draw black on) the old output surface.
                 */
                InputSurface.clearSurface(s);
                break;
            }
        }
    }

    public long getNowUs() {
        if (mAudioTrackState == null) {
            return System.currentTimeMillis() * 1000;
        }

        return mAudioTrackState.getAudioTimeUs();
    }

    public long getRealTimeUsForMediaTime(long mediaTimeUs) {
        if (mDeltaTimeUs == -1) {
            long nowUs = getNowUs();
            mDeltaTimeUs = nowUs - mediaTimeUs;
        }

        return mDeltaTimeUs + mediaTimeUs;
    }

    public int getDuration() {
        return (int)((mDurationUs + 500) / 1000);
    }

    public int getCurrentPosition() {
        if (mVideoCodecStates == null) {
                return 0;
        }

        long positionUs = 0;

        for (CodecState state : mVideoCodecStates.values()) {
            long trackPositionUs = state.getCurrentPositionUs();

            if (trackPositionUs > positionUs) {
                positionUs = trackPositionUs;
            }
        }
        return (int)((positionUs + 500) / 1000);
    }

}"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testSecondaryUser"	"CtsAppExitTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	"public void testSecondaryUser() throws Exception {
        if (!mSupportMultipleUsers) {
            return;
        }

        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        // Get the full user permission in order to start service as other user
        mInstrumentation.getUiAutomation().adoptShellPermissionIdentity(
                android.Manifest.permission.INTERACT_ACROSS_USERS,
                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);

        // Create the test user, we'll remove it during tearDown
        prepareTestUser();

        final byte[] cookie0 = {(byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03,
                (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07};
        final byte[] cookie1 = {(byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,
                (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08};
        final byte[] cookie2 = {(byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05,
                (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x01};
        final byte[] cookie3 = {(byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06,
                (byte) 0x07, (byte) 0x08, (byte) 0x01, (byte) 0x02};
        final byte[] cookie4 = {(byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07,
                (byte) 0x08, (byte) 0x01, (byte) 0x02, (byte) 0x03};
        final byte[] cookie5 = null;

        long now = System.currentTimeMillis();

        // Start a process and do nothing
        startService(ACTION_NONE, STUB_SERVICE_NAME, false, true, false, true, cookie0);
        // request to exit by itself with a different cookie
        startService(ACTION_EXIT, STUB_SERVICE_NAME, true, false, false, true, cookie1);

        long now2 = System.currentTimeMillis();

        // Start the process in a secondary user and kill itself
        startService(ACTION_KILL, STUB_SERVICE_NAME, true, true, true, true, cookie2);

        long now3 = System.currentTimeMillis();

        // Start a remote process in a secondary user and exit
        startService(ACTION_EXIT, STUB_SERVICE_REMOTE_NAME, true, true, true, true, cookie3);

        long now4 = System.currentTimeMillis();

        // Start a remote process and kill itself
        startService(ACTION_KILL, STUB_SERVICE_REMOTE_NAME, true, true, false, true, cookie4);

        long now5 = System.currentTimeMillis();
        // drop the permissions
        mInstrumentation.getUiAutomation().dropShellPermissionIdentity();

        List<ApplicationExitInfo> list = null;

        // Now try to query for all users
        try {
            list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    STUB_PACKAGE_NAME, 0, 0, UserHandle.USER_ALL,
                    this::getHistoricalProcessExitReasonsAsUser,
                    android.Manifest.permission.DUMP);
            fail(""Shouldn't be able to query all users"");
        } catch (IllegalArgumentException e) {
            // expected
        }

        // Now try to query for ""current"" user
        try {
            list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    STUB_PACKAGE_NAME, 0, 0, UserHandle.USER_CURRENT,
                    this::getHistoricalProcessExitReasonsAsUser,
                    android.Manifest.permission.DUMP);
            fail(""Shouldn't be able to query current user, explicit user-Id is expected"");
        } catch (IllegalArgumentException e) {
            // expected
        }

        // Now only try the current user
        list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, 0, 0, mCurrentUserId,
                this::getHistoricalProcessExitReasonsAsUser,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 2);
        verify(list.get(0), mStubPackageRemotePid, mStubPackageUid, STUB_REMOTE_ROCESS_NAME,
                ApplicationExitInfo.REASON_SIGNALED, OsConstants.SIGKILL, null, now4, now5,
                cookie4);
        verify(list.get(1), mStubPackagePid, mStubPackageUid, STUB_ROCESS_NAME,
                ApplicationExitInfo.REASON_EXIT_SELF, EXIT_CODE, null, now, now2, cookie1);

        // Now try the other user
        try {
            list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    STUB_PACKAGE_NAME, 0, 0, mOtherUserId,
                    this::getHistoricalProcessExitReasonsAsUser,
                    android.Manifest.permission.DUMP);
            fail(""Shouldn't be able to query other users"");
        } catch (SecurityException e) {
            // expected
        }

        // Now try the other user with proper permissions
        list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, 0, 0, mOtherUserId,
                this::getHistoricalProcessExitReasonsAsUser,
                android.Manifest.permission.DUMP,
                android.Manifest.permission.INTERACT_ACROSS_USERS);

        assertTrue(list != null && list.size() == 2);
        verify(list.get(0), mStubPackageRemoteOtherUserPid, mStubPackageOtherUid,
                STUB_REMOTE_ROCESS_NAME, ApplicationExitInfo.REASON_EXIT_SELF, EXIT_CODE,
                null, now3, now4, cookie3);
        verify(list.get(1), mStubPackageOtherUserPid, mStubPackageOtherUid, STUB_ROCESS_NAME,
                ApplicationExitInfo.REASON_SIGNALED, OsConstants.SIGKILL, null,
                now2, now3, cookie2);

        // Get the full user permission in order to start service as other user
        mInstrumentation.getUiAutomation().adoptShellPermissionIdentity(
                android.Manifest.permission.INTERACT_ACROSS_USERS,
                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);
        // Start the process in a secondary user and do nothing
        startService(ACTION_NONE, STUB_SERVICE_NAME, false, true, true, true, cookie5);
        // drop the permissions
        mInstrumentation.getUiAutomation().dropShellPermissionIdentity();

        long now6 = System.currentTimeMillis();
        // Stop the test user
        assertTrue(stopUser(mOtherUserId, true, true));
        // Wait for being killed
        waitForGone(mOtherUidWatcher);

        long now7 = System.currentTimeMillis();
        list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, 0, 1, mOtherUserId,
                this::getHistoricalProcessExitReasonsAsUser,
                android.Manifest.permission.DUMP,
                android.Manifest.permission.INTERACT_ACROSS_USERS);
        verify(list.get(0), mStubPackageOtherUserPid, mStubPackageOtherUid, STUB_ROCESS_NAME,
                ApplicationExitInfo.REASON_USER_STOPPED, null, null, now6, now7, cookie5);

        int otherUserId = mOtherUserId;
        // Now remove the other user
        removeUser(mOtherUserId);
        mOtherUidWatcher.finish();
        mOtherUserId = 0;

        // Poll userInfo to check if the user has been removed, wait up to 10 mins
        for (int i = 0; i < 600; i++) {
            if (ShellIdentityUtils.invokeMethodWithShellPermissions(otherUserId,
                    mUserManager::getUserInfo,
                    android.Manifest.permission.CREATE_USERS) != null) {
                // We can still get the userInfo, sleep 1 second and try again
                sleep(1000);
            } else {
                Log.d(TAG, ""User "" + otherUserId + "" has been removed"");
                break;
            }
        }
        // For now the ACTION_USER_REMOVED should have been sent to all receives,
        // we take an extra nap to make sure we've had the broadcast handling settled.
        sleep(15 * 1000);

        // Now query the other userId, and it should return nothing.
        final Context context = mContext.createPackageContextAsUser(""android"", 0,
                UserHandle.of(otherUserId));
        final ActivityManager am = context.getSystemService(ActivityManager.class);
        list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, 0, 0,
                am::getHistoricalProcessExitReasons,
                android.Manifest.permission.DUMP,
                android.Manifest.permission.INTERACT_ACROSS_USERS);
        assertTrue(list == null || list.size() == 0);

        // The current user shouldn't be impacted.
        list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, 0, 0, mCurrentUserId,
                this::getHistoricalProcessExitReasonsAsUser,
                android.Manifest.permission.DUMP,
                android.Manifest.permission.INTERACT_ACROSS_USERS);

        assertTrue(list != null && list.size() == 2);
        verify(list.get(0), mStubPackageRemotePid, mStubPackageUid, STUB_REMOTE_ROCESS_NAME,
                ApplicationExitInfo.REASON_SIGNALED, OsConstants.SIGKILL, null, now4, now5,
                cookie4);
        verify(list.get(1), mStubPackagePid, mStubPackageUid, STUB_ROCESS_NAME,
                ApplicationExitInfo.REASON_EXIT_SELF, EXIT_CODE, null, now, now2, cookie1);
    }

    private void verify(ApplicationExitInfo info, int pid, int uid, String processName,
            int reason, Integer status, String description, long before, long after) {
        verify(info, pid, uid, processName, reason, status, description, before, after, null);
    }

    private void verify(ApplicationExitInfo info, int pid, int uid, String processName,
            int reason, Integer status, String description, long before, long after,
            byte[] cookie) {
        assertNotNull(info);
        assertEquals(pid, info.getPid());
        assertEquals(uid, info.getRealUid());
        assertEquals(UserHandle.of(UserHandle.getUserId(uid)), info.getUserHandle());
        if (processName != null) {
            assertEquals(processName, info.getProcessName());
        }
        assertEquals(reason, info.getReason());
        if (status != null) {
            assertEquals(status.intValue(), info.getStatus());
        }
        if (description != null) {
            assertEquals(description, info.getDescription());
        }
        assertTrue(before <= info.getTimestamp());
        assertTrue(after >= info.getTimestamp());
        assertTrue(ArrayUtils.equals(info.getProcessStateSummary(), cookie,
                cookie == null ? 0 : cookie.length));
    }
}"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testCreateAndManageUser_StopUser"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	"public void testCreateAndManageUser_StopUser() throws Exception {
        assumeCanStartNewUser();

        executeCreateAndManageUserTest(""testCreateAndManageUser_StopUser"");
        assertNewUserStopped();
    }

    /**
     * Test creating an ephemeral user using the DevicePolicyManager's createAndManageUser method
     * and start the user in background, user is then stopped. The user should be removed
     * automatically even when DISALLOW_REMOVE_USER is set.
     */"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.users.UserReferenceTest"	"remove_userDoesNotExist_throwsException"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/users/UserReferenceTest.java"	""	"public void remove_userDoesNotExist_throwsException() {
        assertThrows(NeneException.class, () -> sTestApis.users().find(USER_ID).remove());
    }"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"test.java.com.android.bedstead.nene.users.UserReferenceTest"	"remove_userExists_removesUser"	""	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/nene/src/test/java/com/android/bedstead/nene/users/UserReferenceTest.java"	""	"public void remove_userExists_removesUser() {
        UserReference user = sTestApis.users().createUser().create();

        user.remove();

        assertThat(sTestApis.users().all()).doesNotContain(user);
    }"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.StartProfilesTest"	"TestApis"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/StartProfilesTest.java"	""	"/*
 *.
 */

package android.devicepolicy.cts;

import static android.Manifest.permission.CREATE_USERS;
import static android.Manifest.permission.INTERACT_ACROSS_USERS;
import static android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.testng.Assert.assertThrows;

import android.app.ActivityManager;
import android.app.UiAutomation;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.UserManager;

import androidx.test.core.app.ApplicationProvider;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.bedstead.harrier.BedsteadJUnit4;
import com.android.bedstead.harrier.DeviceState;
import com.android.bedstead.harrier.annotations.EnsureDoesNotHavePermission;
import com.android.bedstead.harrier.annotations.EnsureHasPermission;
import com.android.bedstead.harrier.annotations.EnsureHasSecondaryUser;
import com.android.bedstead.harrier.annotations.EnsureHasTvProfile;
import com.android.bedstead.harrier.annotations.EnsureHasWorkProfile;
import com.android.bedstead.harrier.annotations.RequireFeature;
import com.android.bedstead.harrier.annotations.RequireRunOnPrimaryUser;
import com.android.bedstead.harrier.annotations.Postsubmit;
import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.users.UserReference;
import com.android.compatibility.common.util.BlockingBroadcastReceiver;

import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.function.Function;

@RunWith(BedsteadJUnit4.class)
public final class StartProfilesTest {
    private static final Context sContext = ApplicationProvider.getApplicationContext();
    private static final UserManager sUserManager = sContext.getSystemService(UserManager.class);
    private static final ActivityManager sActivityManager =
            sContext.getSystemService(ActivityManager.class);

    private UiAutomation mUiAutomation =
            InstrumentationRegistry.getInstrumentation().getUiAutomation();
    private final TestApis mTestApis = new TestApis();

    @ClassRule @Rule
    public static final DeviceState sDeviceState = new DeviceState();

    private Function<Intent, Boolean> userIsEqual(UserReference user) {
        return (intent) -> user.userHandle().equals(intent.getParcelableExtra(Intent.EXTRA_USER));
    }"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.StartProfilesTest"	"isTrue"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/StartProfilesTest.java"	""	"@RequireFeature(PackageManager.FEATURE_MANAGED_USERS)
    @RequireRunOnPrimaryUser
    @EnsureHasWorkProfile
    @Postsubmit(reason=""b/181207615 flaky"")
    @EnsureHasPermission({INTERACT_ACROSS_USERS_FULL, INTERACT_ACROSS_USERS, CREATE_USERS})
    public void stopProfile_returnsTrue() {
        assertThat(sActivityManager.stopProfile(sDeviceState.workProfile().userHandle())).isTrue();
    }"	""	""	"CREATE_USER CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.StartProfilesTest"	"startProfile_broadcastIsReceived_profileIsStarted"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/StartProfilesTest.java"	""	"@RequireFeature(PackageManager.FEATURE_MANAGED_USERS)
    @RequireRunOnPrimaryUser
    @EnsureHasWorkProfile
    @EnsureHasPermission({INTERACT_ACROSS_USERS_FULL, INTERACT_ACROSS_USERS, CREATE_USERS})
    public void startProfile_broadcastIsReceived_profileIsStarted() {
        sDeviceState.workProfile().stop();
        BlockingBroadcastReceiver broadcastReceiver = sDeviceState.registerBroadcastReceiver(
                Intent.ACTION_PROFILE_ACCESSIBLE,
                userIsEqual(sDeviceState.workProfile()));
        sActivityManager.startProfile(sDeviceState.workProfile().userHandle());

        broadcastReceiver.awaitForBroadcastOrFail();

        assertThat(sUserManager.isUserRunning(sDeviceState.workProfile().userHandle())).isTrue();
    }"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.StartProfilesTest"	"stopProfile_profileIsStopped"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/StartProfilesTest.java"	""	"@RequireFeature(PackageManager.FEATURE_MANAGED_USERS)
    @RequireRunOnPrimaryUser
    @EnsureHasWorkProfile
    @Postsubmit(reason=""b/181207615 flaky"")
    @EnsureHasPermission({INTERACT_ACROSS_USERS_FULL, INTERACT_ACROSS_USERS, CREATE_USERS})
    public void stopProfile_profileIsStopped() {
        BlockingBroadcastReceiver broadcastReceiver = sDeviceState.registerBroadcastReceiver(
                Intent.ACTION_PROFILE_INACCESSIBLE, userIsEqual(sDeviceState.workProfile()));

        sActivityManager.stopProfile(sDeviceState.workProfile().userHandle());
        broadcastReceiver.awaitForBroadcastOrFail();

        assertThat(
                sUserManager.isUserRunning(sDeviceState.workProfile().userHandle())).isFalse();
    }"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.StartProfilesTest"	"startUser_immediatelyAfterStopped_profileIsStarted"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/StartProfilesTest.java"	""	"@RequireFeature(PackageManager.FEATURE_MANAGED_USERS)
    @RequireRunOnPrimaryUser
    @EnsureHasWorkProfile
    @Postsubmit(reason=""b/181207615 flaky"")
    @EnsureHasPermission({INTERACT_ACROSS_USERS_FULL, INTERACT_ACROSS_USERS, CREATE_USERS})
    public void startUser_immediatelyAfterStopped_profileIsStarted() {
        try (BlockingBroadcastReceiver broadcastReceiver = sDeviceState.registerBroadcastReceiver(
                Intent.ACTION_PROFILE_INACCESSIBLE, userIsEqual(sDeviceState.workProfile()))) {
            sActivityManager.stopProfile(sDeviceState.workProfile().userHandle());
        }

        // start profile as soon as ACTION_PROFILE_INACCESSIBLE is received
        // verify that ACTION_PROFILE_ACCESSIBLE is received if profile is re-started
        BlockingBroadcastReceiver broadcastReceiver = sDeviceState.registerBroadcastReceiver(
               Intent.ACTION_PROFILE_ACCESSIBLE, userIsEqual(sDeviceState.workProfile()));
        sActivityManager.startProfile(sDeviceState.workProfile().userHandle());
        Intent broadcast = broadcastReceiver.awaitForBroadcast();

        assertWithMessage(""Expected to receive ACTION_PROFILE_ACCESSIBLE broadcast"").that(
                broadcast).isNotNull();
        assertThat(
                sUserManager.isUserRunning(sDeviceState.workProfile().userHandle())).isTrue();
    }"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.StartProfilesTest"	"startUser_userIsStopping_profileIsStarted"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/StartProfilesTest.java"	""	"@RequireFeature(PackageManager.FEATURE_MANAGED_USERS)
    @RequireRunOnPrimaryUser
    @EnsureHasWorkProfile
    @Postsubmit(reason=""b/181207615 flaky"")
    @EnsureHasPermission({INTERACT_ACROSS_USERS_FULL, INTERACT_ACROSS_USERS, CREATE_USERS})
    public void startUser_userIsStopping_profileIsStarted() {
        sDeviceState.workProfile().start();

        // stop and restart profile without waiting for ACTION_PROFILE_INACCESSIBLE broadcast
        sActivityManager.stopProfile(sDeviceState.workProfile().userHandle());
        sActivityManager.startProfile(sDeviceState.workProfile().userHandle());

        assertThat(sUserManager.isUserRunning(sDeviceState.workProfile().userHandle())).isTrue();
    }"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.StartProfilesTest"	"startProfile_withoutPermission_throwsException"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/StartProfilesTest.java"	""	"@RequireFeature(PackageManager.FEATURE_MANAGED_USERS)
    @RequireRunOnPrimaryUser
    @EnsureHasWorkProfile
    @EnsureDoesNotHavePermission({INTERACT_ACROSS_USERS_FULL, INTERACT_ACROSS_USERS, CREATE_USERS})
    @Postsubmit(reason=""b/181207615 flaky"")
    public void startProfile_withoutPermission_throwsException() {
        assertThrows(SecurityException.class,
                () -> sActivityManager.startProfile(sDeviceState.workProfile().userHandle()));
    }"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.StartProfilesTest"	"stopProfile_withoutPermission_throwsException"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/StartProfilesTest.java"	""	"@RequireFeature(PackageManager.FEATURE_MANAGED_USERS)
    @RequireRunOnPrimaryUser
    @EnsureHasWorkProfile
    @EnsureDoesNotHavePermission({INTERACT_ACROSS_USERS_FULL, INTERACT_ACROSS_USERS, CREATE_USERS})
    public void stopProfile_withoutPermission_throwsException() {
        assertThrows(SecurityException.class,
                () -> sActivityManager.stopProfile(sDeviceState.workProfile().userHandle()));
    }"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.StartProfilesTest"	"startProfile_tvProfile_profileIsStarted"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/StartProfilesTest.java"	""	"@RequireRunOnPrimaryUser
    @EnsureHasTvProfile
    @EnsureHasPermission({INTERACT_ACROSS_USERS_FULL, INTERACT_ACROSS_USERS, CREATE_USERS})
    public void startProfile_tvProfile_profileIsStarted() {
        sDeviceState.tvProfile().stop();


        try (BlockingBroadcastReceiver broadcastReceiver = sDeviceState.registerBroadcastReceiver(
                Intent.ACTION_PROFILE_ACCESSIBLE, userIsEqual(sDeviceState.tvProfile()))) {
            assertThat(
                    sActivityManager.startProfile(sDeviceState.tvProfile().userHandle())).isTrue();
        }

        assertThat(sUserManager.isUserRunning(sDeviceState.tvProfile().userHandle())).isTrue();
    }"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.devicepolicy.cts.StartProfilesTest"	"stopProfile_tvProfile_profileIsStopped"	"CtsDevicePolicyTestCases"	"/home/gpoor/cts-12-source/cts/tests/devicepolicy/src/android/devicepolicy/cts/StartProfilesTest.java"	""	"@RequireRunOnPrimaryUser
    @EnsureHasTvProfile
    @EnsureHasPermission({INTERACT_ACROSS_USERS_FULL, INTERACT_ACROSS_USERS, CREATE_USERS})
    public void stopProfile_tvProfile_profileIsStopped() {
        BlockingBroadcastReceiver broadcastReceiver = sDeviceState.registerBroadcastReceiver(
                Intent.ACTION_PROFILE_INACCESSIBLE, userIsEqual(sDeviceState.tvProfile()));

        assertThat(
                sActivityManager.stopProfile(sDeviceState.tvProfile().userHandle())).isTrue();
        broadcastReceiver.awaitForBroadcast();

        assertThat(sUserManager.isUserRunning(sDeviceState.tvProfile().userHandle())).isFalse();
    }
}"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"isHeadlessSystemUserMode"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	"/*
 *.
 */
package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import static org.junit.Assert.assertTrue;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;

import org.junit.Test;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class UserRestrictionsTest extends BaseDevicePolicyTest {
    private static final String DEVICE_ADMIN_PKG = ""com.android.cts.deviceandprofileowner"";
    private static final String DEVICE_ADMIN_APK = ""CtsDeviceAndProfileOwnerApp.apk"";
    private static final String ADMIN_RECEIVER_TEST_CLASS
            = "".BaseDeviceAdminTest$BasicAdminReceiver"";

    private static final String GLOBAL_RESTRICTIONS_TEST_CLASS =
            ""userrestrictions.ProfileGlobalRestrictionsTest"";
    private static final String SET_GLOBAL_RESTRICTIONS_TEST =
            ""testSetProfileGlobalRestrictions"";
    private static final String CLEAR_GLOBAL_RESTRICTIONS_TEST =
            ""testClearProfileGlobalRestrictions"";
    private static final String ENSURE_GLOBAL_RESTRICTIONS_TEST =
            ""testProfileGlobalRestrictionsEnforced"";
    private static final String ENSURE_NO_GLOBAL_RESTRICTIONS_TEST =
            ""testProfileGlobalRestrictionsNotEnforced"";

    private boolean mRemoveOwnerInTearDown;
    private int mDeviceOwnerUserId;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        mRemoveOwnerInTearDown = false;
    }

    @Override
    public void tearDown() throws Exception {
        if (mRemoveOwnerInTearDown) {
            String componentName = DEVICE_ADMIN_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS;
            assertTrue(""Failed to clear owner"", removeAdmin(componentName, mDeviceOwnerUserId));
            runTests(""userrestrictions.CheckNoOwnerRestrictionsTest"", mDeviceOwnerUserId);
            if (isHeadlessSystemUserMode()) {
                boolean removed = removeAdmin(componentName, mPrimaryUserId);
                if (!removed) {
                    CLog.e(""Failed to remove %s on user %d"", componentName, mPrimaryUserId);
                }
            }
        }

        // DO/PO might have set DISALLOW_REMOVE_USER, so it needs to be done after removing
        // them.
        removeTestUsers();
        getDevice().uninstallPackage(DEVICE_ADMIN_PKG);

        super.tearDown();
    }

    private void runTests(@Nonnull String className,
            @Nullable String method, int userId) throws DeviceNotAvailableException {
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, ""."" + className, method, userId);
    }

    private void runTests(@Nonnull String className, int userId)
            throws DeviceNotAvailableException {
        runTests(className, null, userId);
    }"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testCannotRemoveUserIfRestrictionSet"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testCannotRemoveUserIfRestrictionSet() throws Exception {
        assumeCanCreateAdditionalUsers(1);
        assumeTrue(""Outside of the primary user, setting DISALLOW_REMOVE_USER would not work"",
                mUserId == getPrimaryUser());

        final int userId = createUser();
        try {
            changeUserRestrictionOrFail(DISALLOW_REMOVE_USER, true, mUserId);
            assertFalse(getDevice().removeUser(userId));
        } finally {
            changeUserRestrictionOrFail(DISALLOW_REMOVE_USER, false, mUserId);
            assertTrue(getDevice().removeUser(userId));
        }
    }"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetUserRestrictionLogged"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	"public void testSetUserRestrictionLogged() throws Exception {
        assertMetricsLogged(getDevice(), () -> {
            executeDeviceTestMethod(
                    "".DevicePolicyLoggingTest"", ""testSetUserRestrictionLogged"");
        }, new DevicePolicyEventWrapper.Builder(EventId.ADD_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_CONFIG_LOCATION, NOT_CALLED_FROM_PARENT)
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.REMOVE_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_CONFIG_LOCATION, NOT_CALLED_FROM_PARENT)
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.ADD_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_ADJUST_VOLUME, NOT_CALLED_FROM_PARENT)
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.REMOVE_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_ADJUST_VOLUME, NOT_CALLED_FROM_PARENT)
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.ADD_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_AUTOFILL, NOT_CALLED_FROM_PARENT)
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.REMOVE_USER_RESTRICTION_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setStrings(DISALLOW_AUTOFILL, NOT_CALLED_FROM_PARENT)
                    .build()
        );
    }"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.DevicePolicySafetyCheckerIntegrationTest"	"DevicePolicySafetyCheckerIntegrationTester"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/DevicePolicySafetyCheckerIntegrationTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceowner;

import static android.app.admin.DevicePolicyManager.OPERATION_CREATE_AND_MANAGE_USER;
import static android.app.admin.DevicePolicyManager.OPERATION_REBOOT;
import static android.app.admin.DevicePolicyManager.OPERATION_REMOVE_USER;
import static android.app.admin.DevicePolicyManager.OPERATION_REQUEST_BUGREPORT;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_APPLICATION_HIDDEN;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_APPLICATION_RESTRICTIONS;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_CAMERA_DISABLED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_GLOBAL_PRIVATE_DNS;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_KEEP_UNINSTALLED_PACKAGES;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_KEYGUARD_DISABLED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_LOCK_TASK_FEATURES;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_LOCK_TASK_PACKAGES;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_LOGOUT_ENABLED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_OVERRIDE_APNS_ENABLED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_PACKAGES_SUSPENDED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_STATUS_BAR_DISABLED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_SYSTEM_SETTING;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_SYSTEM_UPDATE_POLICY;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_TRUST_AGENT_CONFIGURATION;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES;
import static android.app.admin.DevicePolicyManager.OPERATION_START_USER_IN_BACKGROUND;
import static android.app.admin.DevicePolicyManager.OPERATION_STOP_USER;
import static android.app.admin.DevicePolicyManager.OPERATION_SWITCH_USER;
import static android.app.admin.DevicePolicyManager.OPERATION_UNINSTALL_CA_CERT;
import static android.app.admin.DevicePolicyManager.OPERATION_WIPE_DATA;

import android.app.admin.DevicePolicyManager;
import android.app.admin.FactoryResetProtectionPolicy;
import android.content.ComponentName;
import android.os.Bundle;
import android.os.UserHandle;

import com.android.cts.devicepolicy.DevicePolicySafetyCheckerIntegrationTester;
import com.android.internal.util.ArrayUtils;

import java.util.Arrays;
import java.util.List;

// TODO(b/174859111): move to automotive-only section
/**
 * Tests that DPM calls fail when determined by the
 * {@link android.app.admin.DevicePolicySafetyChecker}.
 */
public final class DevicePolicySafetyCheckerIntegrationTest extends BaseDeviceOwnerTest {
    private static final int NO_FLAGS = 0;
    private static final UserHandle USER_HANDLE = UserHandle.of(42);
    public static final String TEST_PACKAGE = BasicAdminReceiver.class.getPackage().getName();
    public static final ComponentName TEST_COMPONENT = new ComponentName(
            TEST_PACKAGE, BasicAdminReceiver.class.getName());
    public static final List<String> TEST_ACCOUNTS = Arrays.asList(""Account 1"");
    public static final List<String> TEST_PACKAGES = Arrays.asList(TEST_PACKAGE);
    private static final String TEST_CA =
            ""-----BEGIN CERTIFICATE-----\n""
            + ""MIICVzCCAgGgAwIBAgIJAMvnLHnnfO/IMA0GCSqGSIb3DQEBBQUAMIGGMQswCQYD\n""
            + ""VQQGEwJJTjELMAkGA1UECAwCQVAxDDAKBgNVBAcMA0hZRDEVMBMGA1UECgwMSU1G\n""
            + ""TCBQVlQgTFREMRAwDgYDVQQLDAdJTUZMIE9VMRIwEAYDVQQDDAlJTUZMLklORk8x\n""
            + ""HzAdBgkqhkiG9w0BCQEWEHJhbWVzaEBpbWZsLmluZm8wHhcNMTMwODI4MDk0NDA5\n""
            + ""WhcNMjMwODI2MDk0NDA5WjCBhjELMAkGA1UEBhMCSU4xCzAJBgNVBAgMAkFQMQww\n""
            + ""CgYDVQQHDANIWUQxFTATBgNVBAoMDElNRkwgUFZUIExURDEQMA4GA1UECwwHSU1G\n""
            + ""TCBPVTESMBAGA1UEAwwJSU1GTC5JTkZPMR8wHQYJKoZIhvcNAQkBFhByYW1lc2hA\n""
            + ""aW1mbC5pbmZvMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJ738cbTQlNIO7O6nV/f\n""
            + ""DJTMvWbPkyHYX8CQ7yXiAzEiZ5bzKJjDJmpRAkUrVinljKns2l6C4++l/5A7pFOO\n""
            + ""33kCAwEAAaNQME4wHQYDVR0OBBYEFOdbZP7LaMbgeZYPuds2CeSonmYxMB8GA1Ud\n""
            + ""IwQYMBaAFOdbZP7LaMbgeZYPuds2CeSonmYxMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n""
            + ""hvcNAQEFBQADQQBdrk6J9koyylMtl/zRfiMAc2zgeC825fgP6421NTxs1rjLs1HG\n""
            + ""VcUyQ1/e7WQgOaBHi9TefUJi+4PSVSluOXon\n""
            + ""-----END CERTIFICATE-----"";
    private final DevicePolicySafetyCheckerIntegrationTester mTester =
            new DevicePolicySafetyCheckerIntegrationTester() {

        @Override
        protected int[] getSafetyAwareOperations() {
            int[] operations = new int [] {
                    OPERATION_CREATE_AND_MANAGE_USER,
                    // TODO(b/175245108) Add test for this operation; testing
                    // dpm.installSystemUpdate will require upload a test system update file.
                    // OPERATION_INSTALL_SYSTEM_UPDATE,
                    OPERATION_REBOOT,
                    OPERATION_REMOVE_USER,
                    OPERATION_REQUEST_BUGREPORT,
                    OPERATION_SET_APPLICATION_HIDDEN,
                    OPERATION_SET_APPLICATION_RESTRICTIONS,
                    OPERATION_SET_CAMERA_DISABLED,
                    OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY,
                    OPERATION_SET_GLOBAL_PRIVATE_DNS,
                    OPERATION_SET_KEEP_UNINSTALLED_PACKAGES,
                    OPERATION_SET_KEYGUARD_DISABLED,
                    OPERATION_SET_LOCK_TASK_FEATURES,
                    OPERATION_SET_LOCK_TASK_PACKAGES,
                    OPERATION_SET_LOGOUT_ENABLED,
                    OPERATION_SET_PACKAGES_SUSPENDED,
                    OPERATION_SET_STATUS_BAR_DISABLED,
                    OPERATION_SET_SYSTEM_SETTING,
                    OPERATION_SET_SYSTEM_UPDATE_POLICY,
                    OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES,
                    OPERATION_START_USER_IN_BACKGROUND,
                    OPERATION_STOP_USER,
                    OPERATION_SWITCH_USER,
                    OPERATION_UNINSTALL_CA_CERT,
                    OPERATION_WIPE_DATA
            };

            if (mHasTelephonyFeature) {
                operations = ArrayUtils.appendInt(operations, OPERATION_SET_OVERRIDE_APNS_ENABLED);
            }
            if (mHasSecureLockScreen) {
                operations = ArrayUtils.appendInt(operations,
                        OPERATION_SET_TRUST_AGENT_CONFIGURATION);
            }

            return operations;
        }

        @Override
        protected int[] getOverloadedSafetyAwareOperations() {
            return new int [] {
                OPERATION_WIPE_DATA
            };
        }

        @Override
        protected void runOperation(DevicePolicyManager dpm, ComponentName admin, int operation,
                boolean overloaded) {
            switch (operation) {
                case OPERATION_CREATE_AND_MANAGE_USER:
                    dpm.createAndManageUser(admin, /* name= */ null, admin, /* adminExtras= */ null,
                            NO_FLAGS);
                    break;
                case OPERATION_REBOOT:
                    dpm.reboot(admin);
                    break;
                case OPERATION_REMOVE_USER:
                    dpm.removeUser(admin, USER_HANDLE);
                    break;
                case OPERATION_REQUEST_BUGREPORT:
                    dpm.requestBugreport(admin);
                    break;
                case OPERATION_SET_APPLICATION_HIDDEN:
                    dpm.setApplicationHidden(admin, TEST_PACKAGE, /* hidden= */true);
                    break;
                case OPERATION_SET_APPLICATION_RESTRICTIONS:
                    dpm.setApplicationRestrictions(admin, TEST_PACKAGE, new Bundle());
                    break;
                case OPERATION_SET_CAMERA_DISABLED:
                    dpm.setCameraDisabled(admin, /* disabled= */ true);
                    break;
                case OPERATION_SET_FACTORY_RESET_PROTECTION_POLICY:
                    dpm.setFactoryResetProtectionPolicy(admin,
                            new FactoryResetProtectionPolicy.Builder()
                                    .setFactoryResetProtectionAccounts(TEST_ACCOUNTS)
                                    .setFactoryResetProtectionEnabled(false)
                                    .build());
                    break;
                case OPERATION_SET_GLOBAL_PRIVATE_DNS:
                    dpm.setGlobalPrivateDnsModeOpportunistic(admin);
                    break;
                case OPERATION_SET_KEEP_UNINSTALLED_PACKAGES:
                    dpm.setKeepUninstalledPackages(admin, TEST_PACKAGES);
                    break;
                case OPERATION_SET_KEYGUARD_DISABLED:
                    dpm.setKeyguardDisabled(admin, true);
                    break;
                case OPERATION_SET_LOCK_TASK_FEATURES:
                    dpm.setLockTaskFeatures(admin, NO_FLAGS);
                    break;
                case OPERATION_SET_LOCK_TASK_PACKAGES:
                    dpm.setLockTaskPackages(admin, new String[] { TEST_PACKAGE });
                    break;
                case OPERATION_SET_LOGOUT_ENABLED:
                    dpm.setLogoutEnabled(admin, /* enabled */ true);
                    break;
                case OPERATION_SET_OVERRIDE_APNS_ENABLED:
                    dpm.setOverrideApnsEnabled(admin, /* enabled */ true);
                    break;
                case OPERATION_SET_PACKAGES_SUSPENDED:
                    dpm.setPackagesSuspended(admin,  new String[] { TEST_PACKAGE },
                            /* suspend= */ true);
                    break;
                case OPERATION_SET_STATUS_BAR_DISABLED:
                    dpm.setStatusBarDisabled(admin, true);
                    break;
                case OPERATION_SET_SYSTEM_SETTING:
                    dpm.setSystemSetting(admin, ""TestSetting"", ""0"");
                    break;
                case OPERATION_SET_SYSTEM_UPDATE_POLICY:
                    dpm.setSystemUpdatePolicy(admin, null);
                    break;
                case OPERATION_SET_TRUST_AGENT_CONFIGURATION:
                    dpm.setTrustAgentConfiguration(admin, TEST_COMPONENT,
                            /* configuration= */ null);
                    break;
                case OPERATION_SET_USER_CONTROL_DISABLED_PACKAGES:
                    dpm.setUserControlDisabledPackages(admin, TEST_PACKAGES);
                    break;
                case OPERATION_START_USER_IN_BACKGROUND:
                    dpm.startUserInBackground(admin, USER_HANDLE);
                    break;
                case OPERATION_STOP_USER:
                    dpm.stopUser(admin, USER_HANDLE);
                    break;
                case OPERATION_SWITCH_USER:
                    dpm.switchUser(admin, USER_HANDLE);
                    break;
                case OPERATION_UNINSTALL_CA_CERT:
                    dpm.uninstallCaCert(admin, TEST_CA.getBytes());
                    break;
                case OPERATION_WIPE_DATA:
                    if (overloaded) {
                        dpm.wipeData(NO_FLAGS,
                                /* reason= */ ""DevicePolicySafetyCheckerIntegrationTest"");
                    } else {
                        dpm.wipeData(NO_FLAGS);
                    }
                    break;
                default:
                    throwUnsupportedOperationException(operation, overloaded);
            }
        }
    };

    /**
     * Tests that all safety-aware operations are properly implemented.
     */"	""	""	"REMOVE_USER SWITCH_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"	"getDisallowedRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/SecondaryProfileOwnerUserRestrictionsTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner.userrestrictions;

import android.os.UserManager;

import java.util.Arrays;
import java.util.HashSet;

public class SecondaryProfileOwnerUserRestrictionsTest extends BaseUserRestrictionsTest {
    public static final String[] ALLOWED = new String[] {
            // UserManager.DISALLOW_CONFIG_WIFI, // Has unrecoverable side effects.
            UserManager.DISALLOW_MODIFY_ACCOUNTS,
            UserManager.DISALLOW_INSTALL_APPS,
            UserManager.DISALLOW_UNINSTALL_APPS,
            // UserManager.DISALLOW_SHARE_LOCATION, // Has unrecoverable side effects.
            // UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, // Has unrecoverable side effects.
            // UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY, // Same as above.
            UserManager.DISALLOW_CONFIG_BLUETOOTH,
            UserManager.DISALLOW_CONFIG_CREDENTIALS,
            UserManager.DISALLOW_REMOVE_USER,
            // UserManager.DISALLOW_DEBUGGING_FEATURES, // Need for CTS
            UserManager.DISALLOW_CONFIG_VPN,
            // UserManager.ENSURE_VERIFY_APPS, // Has unrecoverable side effects.
            UserManager.DISALLOW_APPS_CONTROL,
            UserManager.DISALLOW_UNMUTE_MICROPHONE,
            UserManager.DISALLOW_ADJUST_VOLUME,
            UserManager.DISALLOW_OUTGOING_CALLS,
            UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS,
            UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE,
            UserManager.DISALLOW_OUTGOING_BEAM,
            UserManager.ALLOW_PARENT_PROFILE_APP_LINKING,
            UserManager.DISALLOW_SET_USER_ICON,
            UserManager.DISALLOW_AUTOFILL,
            UserManager.DISALLOW_CONTENT_CAPTURE,
            UserManager.DISALLOW_CONTENT_SUGGESTIONS,
            UserManager.DISALLOW_UNIFIED_PASSWORD,
    };

    public static final String[] DISALLOWED = new String[] {
            UserManager.DISALLOW_USB_FILE_TRANSFER,
            UserManager.DISALLOW_CONFIG_TETHERING,
            UserManager.DISALLOW_NETWORK_RESET,
            UserManager.DISALLOW_FACTORY_RESET,
            UserManager.DISALLOW_ADD_USER,
            UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
            UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
            UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
            UserManager.DISALLOW_SMS,
            UserManager.DISALLOW_FUN,
            UserManager.DISALLOW_SAFE_BOOT,
            UserManager.DISALLOW_CREATE_WINDOWS,
            UserManager.DISALLOW_DATA_ROAMING,
            UserManager.DISALLOW_BLUETOOTH
    };

    public static final String[] ALLOWED_BUT_LEAKY = new String[] {
        UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
    };

    @Override
    protected String[] getAllowedRestrictions() {
        return ALLOWED;
    }

    @Override
    protected String[] getDisallowedRestrictions() {
        return DISALLOWED;
    }

    @Override
    protected String[] getDefaultEnabledRestrictions() { return new String[0]; }

    /**
     * This is called after DO setting all DO restrictions. Global restrictions should be
     * visible on other users.
     */"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.car.cts.CarHostJUnit4TestCase"	"isEmpty"	"CtsCarHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/car/src/android/car/cts/CarHostJUnit4TestCase.java"	""	"public void test/*
 *.
 */

package android.car.cts;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.service.pm.PackageProto;
import android.service.pm.PackageProto.UserPermissionsProto;
import android.service.pm.PackageServiceDumpProto;

import com.android.compatibility.common.util.CommonTestUtils;
import com.android.tradefed.device.CollectingByteOutputReceiver;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.ITestInformationReceiver;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import org.junit.After;
import org.junit.AssumptionViolatedException;
import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Base class for all test cases.
 */
// NOTE: must be public because of @Rules
public abstract class CarHostJUnit4TestCase extends BaseHostJUnit4Test {

    private static final int DEFAULT_TIMEOUT_SEC = 20;

    private static final Pattern CREATE_USER_OUTPUT_PATTERN = Pattern.compile(""id=(\\d+)"");

    private static final String USER_PREFIX = ""CtsCarHostTestCases"";

    /**
     * User pattern in the output of ""cmd user list --all -v""
     * TEXT id=<id> TEXT name=<name>, TEX flags=<flags> TEXT
     * group 1: id group 2: name group 3: flags group 4: other state(like ""(running)"")
     */
    private static final Pattern USER_PATTERN = Pattern.compile(
            "".*id=(\\d+).*name=([^\\s,]+).*flags=(\\S+)(.*)"");

    private static final int USER_PATTERN_GROUP_ID = 1;
    private static final int USER_PATTERN_GROUP_NAME = 2;
    private static final int USER_PATTERN_GROUP_FLAGS = 3;
    private static final int USER_PATTERN_GROUP_OTHER_STATE = 4;

    /**
     * User's package permission pattern string format in the output of ""dumpsys package PKG_NAME""
    */
    protected static final String APP_APK = ""CtsCarApp.apk"";
    protected static final String APP_PKG = ""android.car.cts.app"";

    @Rule
    public final RequiredFeatureRule mHasAutomotiveRule = new RequiredFeatureRule(this,
            ""android.hardware.type.automotive"");

    private final HashSet<Integer> mUsersToBeRemoved = new HashSet<>();

    private int mInitialUserId;
    private Integer mInitialMaximumNumberOfUsers;

    /**
     * Saves multi-user state so it can be restored after the test.
     */
    @Before
    public void saveUserState() throws Exception {
        removeUsers(USER_PREFIX);

        mInitialUserId = getCurrentUserId();
    }

    /**
     * Restores multi-user state from before the test.
     */
    @After
    public void restoreUsersState() throws Exception {
        int currentUserId = getCurrentUserId();
        CLog.d(""restoreUsersState(): initial user: %d, current user: %d, created users: %s ""
                + ""max number of users: %d"",
                mInitialUserId, currentUserId, mUsersToBeRemoved, mInitialMaximumNumberOfUsers);
        if (currentUserId != mInitialUserId) {
            CLog.i(""Switching back from %d to %d"", currentUserId, mInitialUserId);
            switchUser(mInitialUserId);
        }

        if (!mUsersToBeRemoved.isEmpty()) {
            CLog.i(""Removing users %s"", mUsersToBeRemoved);
            for (int userId : mUsersToBeRemoved) {
                removeUser(userId);
            }
        }

        // Should have been removed above, but as the saying goes, better safe than sorry...
        removeUsers(USER_PREFIX);

        if (mInitialMaximumNumberOfUsers != null) {
            CLog.i(""Restoring max number of users to %d"", mInitialMaximumNumberOfUsers);
            setMaxNumberUsers(mInitialMaximumNumberOfUsers);
        }
    }

    /**
     * Makes sure the device supports multiple users, throwing {@link AssumptionViolatedException}
     * if it doesn't.
     */
    protected final void assumeSupportsMultipleUsers() throws Exception {
        assumeTrue(""device does not support multi-user"",
                getDevice().getMaxNumberOfUsersSupported() > 1);
    }

    /**
     * Makes sure the device can add {@code numberOfUsers} new users, increasing limit if needed or
     * failing if not possible.
     */
    protected final void requiresExtraUsers(int numberOfUsers) throws Exception {
        assumeSupportsMultipleUsers();

        int maxNumber = getDevice().getMaxNumberOfUsersSupported();
        int currentNumber = getDevice().listUsers().size();

        if (currentNumber + numberOfUsers <= maxNumber) return;

        if (!getDevice().isAdbRoot()) {
            failCannotCreateUsers(numberOfUsers, currentNumber, maxNumber, /* isAdbRoot= */ false);
        }

        // Increase limit...
        mInitialMaximumNumberOfUsers = maxNumber;
        setMaxNumberUsers(maxNumber + numberOfUsers);

        // ...and try again
        maxNumber = getDevice().getMaxNumberOfUsersSupported();
        if (currentNumber + numberOfUsers > maxNumber) {
            failCannotCreateUsers(numberOfUsers, currentNumber, maxNumber, /* isAdbRoot= */ true);
        }
    }

    private void failCannotCreateUsers(int numberOfUsers, int currentNumber, int maxNumber,
            boolean isAdbRoot) {
        String reason = isAdbRoot ? ""failed to increase it""
                : ""cannot be increased without adb root"";
        String existingUsers = """";
        try {
            existingUsers = ""Existing users: "" + executeCommand(""cmd user list --all -v"");
        } catch (Exception e) {
            // ignore
        }
        fail(""Cannot create "" + numberOfUsers + "" users: current number is "" + currentNumber
                + "", limit is "" + maxNumber + "" and could not be increased ("" + reason + ""). ""
                + existingUsers);
    }

    /**
     * Executes the shell command and returns the output.
     */
    protected String executeCommand(String command, Object... args) throws Exception {
        String fullCommand = String.format(command, args);
        return getDevice().executeShellCommand(fullCommand);
    }

    /**
     * Executes the shell command and parses output with {@code resultParser}.
     */
    protected <T> T executeAndParseCommand(Function<String, T> resultParser,
            String command, Object... args) throws Exception {
        String output = executeCommand(command, args);
        return resultParser.apply(output);
    }

    /**
     * Executes the shell command and parses the Matcher output with {@code resultParser}, failing
     * with {@code matchNotFoundErrorMessage} if it didn't match the {@code regex}.
     */
    protected <T> T executeAndParseCommand(Pattern regex, String matchNotFoundErrorMessage,
            Function<Matcher, T> resultParser,
            String command, Object... args) throws Exception {
        String output = executeCommand(command, args);
        Matcher matcher = regex.matcher(output);
        if (!matcher.find()) {
            fail(matchNotFoundErrorMessage + "". Shell command: '"" + String.format(command, args)
                    + ""'. Output: "" + output.trim() + "". Regex: "" + regex);
        }
        return resultParser.apply(matcher);
    }

    /**
     * Executes the shell command and parses the Matcher output with {@code resultParser}.
     */
    protected <T> T executeAndParseCommand(Pattern regex, Function<Matcher, T> resultParser,
            String command, Object... args) throws Exception {
        String output = executeCommand(command, args);
        return resultParser.apply(regex.matcher(output));
    }

    /**
     * Executes the shell command that returns all users and returns {@code function} applied to
     * them.
     */
    public <T> T onAllUsers(Function<List<UserInfo>, T> function) throws Exception {
        ArrayList<UserInfo> allUsers = executeAndParseCommand(USER_PATTERN, (matcher) -> {
            ArrayList<UserInfo> users = new ArrayList<>();
            while (matcher.find()) {
                users.add(new UserInfo(matcher));
            }
            return users;
        }, ""cmd user list --all -v"");
        return function.apply(allUsers);
    }

    /**
     * Gets the info for the given user.
     */
    public UserInfo getUserInfo(int userId) throws Exception {
        return onAllUsers((allUsers) -> allUsers.stream()
                .filter((u) -> u.id == userId))
                        .findFirst().get();
    }

    /**
     * Sets the maximum number of users that can be created for this car.
     *
     * @throws IllegalStateException if adb is not running as root
     */
    protected void setMaxNumberUsers(int numUsers) throws Exception {
        if (!getDevice().isAdbRoot()) {
            throw new IllegalStateException(""must be running adb root"");
        }
        executeCommand(""setprop fw.max_users %d"", numUsers);
    }

    /**
     * Gets the current user's id.
     */
    protected int getCurrentUserId() throws DeviceNotAvailableException {
        return getDevice().getCurrentUser();
    }

    /**
     * Creates a full user with car service shell command.
     */
    protected int createFullUser(String name) throws Exception {
        return createUser(name, /* flags= */ 0, ""android.os.usertype.full.SECONDARY"");
    }

    /**
     * Creates a full guest with car service shell command.
     */
    protected int createGuestUser(String name) throws Exception {
        return createUser(name, /* flags= */ 0, ""android.os.usertype.full.GUEST"");
    }

    /**
     * Creates a flexible user with car service shell command.
     *
     * <p><b>NOTE: </b>it uses User HAL flags, not core Android's.
     */
    protected int createUser(String name, int flags, String type) throws Exception {
        name = USER_PREFIX + ""."" + name;
        waitForCarServiceReady();
        int userId = executeAndParseCommand(CREATE_USER_OUTPUT_PATTERN,
                ""Could not create user with name "" + name + "", flags "" + flags + "", type"" + type,
                matcher -> Integer.parseInt(matcher.group(1)),
                ""cmd car_service create-user --flags %d --type %s %s"",
                flags, type, name);
        markUserForRemovalAfterTest(userId);
        return userId;
    }

    /**
     * Marks a user to be removed at the end of the tests.
     */
    protected void markUserForRemovalAfterTest(int userId) {
        mUsersToBeRemoved.add(userId);
    }

    /**
     * Waits until the given user is initialized.
     */
    protected void waitForUserInitialized(int userId) throws Exception {
        CommonTestUtils.waitUntil(""timed out waiting for user "" + userId + "" initialization"",
                DEFAULT_TIMEOUT_SEC, () -> isUserInitialized(userId));
    }

    /**
     * Waits until the system server is ready.
     */
    protected void waitForCarServiceReady() throws Exception {
        CommonTestUtils.waitUntil(""timed out waiting for system server "",
                DEFAULT_TIMEOUT_SEC, () -> isCarServiceReady());
    }

    protected boolean isCarServiceReady() {
        String cmd = ""service check car_service"";
        try {
            String output = getDevice().executeShellCommand(cmd);
            return !output.endsWith(""not found"");
        } catch (Exception e) {
            CLog.i(""%s failed: %s"", cmd, e.getMessage());
        }
        return false;
    }

    /**
     * Asserts that the given user is initialized.
     */
    protected void assertUserInitialized(int userId) throws Exception {
        assertWithMessage(""User %s not initialized"", userId).that(isUserInitialized(userId))
                .isTrue();
        CLog.v(""User %d is initialized"", userId);
    }

    /**
     * Checks if the given user is initialized.
     */
    protected boolean isUserInitialized(int userId) throws Exception {
        UserInfo userInfo = getUserInfo(userId);
        CLog.v(""isUserInitialized(%d): %s"", userId, userInfo);
        return userInfo.flags.contains(""INITIALIZED"");
    }

    /**
     * Switches the current user.
     */
    protected void switchUser(int userId) throws Exception {
        waitForCarServiceReady();
        String output = executeCommand(""cmd car_service switch-user %d"", userId);
        if (!output.contains(""STATUS_SUCCESSFUL"")) {
            throw new IllegalStateException(""Failed to switch to user "" + userId + "": "" + output);
        }
        waitUntilCurrentUser(userId);
    }

    /**
     * Waits until the given user is the current foreground user.
     */
    protected void waitUntilCurrentUser(int userId) throws Exception {
        CommonTestUtils.waitUntil(""timed out ("" + DEFAULT_TIMEOUT_SEC
                + ""s) waiting for current user to be "" + userId
                + "" (it is "" + getCurrentUserId() + "")"",
                DEFAULT_TIMEOUT_SEC,
                () -> (getCurrentUserId() == userId));
    }

    /**
     * Removes a user by user ID and update the list of users to be removed.
     */
    protected void removeUser(int userId) throws Exception {
        executeCommand(""cmd car_service remove-user %d"", userId);
    }

    /**
     * Removes users whose name start with the given prefix.
     */
    protected void removeUsers(String prefix) throws Exception {
        Pattern pattern = Pattern.compile(""^.*id=(\\d+), name=("" + prefix + "".*),.*$"");
        String output = executeCommand(""cmd user list --all -v"");
        for (String line : output.split(""\\n"")) {
            Matcher matcher = pattern.matcher(line);
            if (!matcher.find()) continue;

            int userId = Integer.parseInt(matcher.group(1));
            String name = matcher.group(2);
            CLog.e(""Removing user with %s prefix (id=%d, name='%s')"", prefix, userId, name);
            removeUser(userId);
        }
    }

    /**
     * Checks if an app is installed for a given user.
     */
    protected boolean isAppInstalledForUser(String packageName, int userId)
            throws DeviceNotAvailableException {
        return getDevice().isPackageInstalled(packageName, Integer.toString(userId));
    }

    /**
     * Fails the test if the app is installed for the given user.
     */
    protected void assertAppInstalledForUser(String packageName, int userId)
            throws DeviceNotAvailableException {
        assertWithMessage(""%s should BE installed for user %s"", packageName, userId).that(
                isAppInstalledForUser(packageName, userId)).isTrue();
    }

    /**
     * Fails the test if the app is NOT installed for the given user.
     */
    protected void assertAppNotInstalledForUser(String packageName, int userId)
            throws DeviceNotAvailableException {
        assertWithMessage(""%s should NOT be installed for user %s"", packageName, userId).that(
                isAppInstalledForUser(packageName, userId)).isFalse();
    }

    /**
     * Restarts the system server process.
     *
     * <p>Useful for cases where the test case changes system properties, as
     * {@link ITestDevice#reboot()} would reset them.
     */
    protected void restartSystemServer() throws Exception {
        final ITestDevice device = getDevice();
        device.executeShellCommand(""stop"");
        device.executeShellCommand(""start"");
        device.waitForDeviceAvailable();
        waitForCarServiceReady();
    }

    /**
     * Gets mapping of package and permissions granted for requested user id.
     *
     * @return Map<String, List<String>> where key is the package name and
     * the value is list of permissions granted for this user.
     */
    protected Map<String, List<String>> getPackagesAndPermissionsForUser(int userId)
            throws Exception {
        CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();
        getDevice().executeShellCommand(""dumpsys package --proto"", receiver);

        PackageServiceDumpProto dump = PackageServiceDumpProto.parser()
                .parseFrom(receiver.getOutput());

        CLog.v(""Device has %d packages while getPackagesAndPermissions"", dump.getPackagesCount());
        Map<String, List<String>> pkgMap = new HashMap<>();
        for (PackageProto pkg : dump.getPackagesList()) {
            String pkgName = pkg.getName();
            for (UserPermissionsProto userPermissions : pkg.getUserPermissionsList()) {
                if (userPermissions.getId() == userId) {
                    pkgMap.put(pkg.getName(), userPermissions.getGrantedPermissionsList());
                    break;
                }
            }
        }
        return pkgMap;
    }

    /**
     * Sleeps for the given amount of milliseconds.
     */
    protected void sleep(long ms) throws InterruptedException {
        CLog.v(""Sleeping for %dms"", ms);
        Thread.sleep(ms);
        CLog.v(""Woke up; Little Susie woke up!"");
    }

    // TODO(b/169341308): move to common infra code
    private static final class RequiredFeatureRule implements TestRule {

        private final ITestInformationReceiver mReceiver;
        private final String mFeature;

        RequiredFeatureRule(ITestInformationReceiver receiver, String feature) {
            mReceiver = receiver;
            mFeature = feature;
        }

        @Override
        public Statement apply(Statement base, Description description) {
            return new Statement() {

                @Override
                public void evaluate() throws Throwable {
                    boolean hasFeature = false;
                    try {
                        hasFeature = mReceiver.getTestInformation().getDevice()
                                .hasFeature(mFeature);
                    } catch (DeviceNotAvailableException e) {
                        CLog.e(""Could not check if device has feature %s: %e"", mFeature, e);
                        return;
                    }

                    if (!hasFeature) {
                        CLog.d(""skipping %s#%s""
                                + "" because device does not have feature '%s'"",
                                description.getClassName(), description.getMethodName(), mFeature);
                        throw new AssumptionViolatedException(""Device does not have feature '""
                                + mFeature + ""'"");
                    }
                    base.evaluate();
                }
            };
        }

        @Override
        public String toString() {
            return ""RequiredFeatureRule["" + mFeature + ""]"";
        }
    }

    /**
     * Represents a user as returned by {@code cmd user list -v}.
     */
    public static final class UserInfo {
        public final int id;
        public final String flags;
        public final String name;
        public final String otherState;

        private UserInfo(Matcher matcher) {
            id = Integer.parseInt(matcher.group(USER_PATTERN_GROUP_ID));
            flags = matcher.group(USER_PATTERN_GROUP_FLAGS);
            name = matcher.group(USER_PATTERN_GROUP_NAME);
            otherState = matcher.group(USER_PATTERN_GROUP_OTHER_STATE);
        }

        @Override
        public String toString() {
            return ""[UserInfo: id="" + id + "", flags="" + flags + "", name="" + name
                    + "", otherState="" + otherState + ""]"";
        }
    }
}"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testPerProfileUserRestriction_onParent"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	"public void testPerProfileUserRestriction_onParent() throws Settings.SettingNotFoundException {
        mUiAutomation.adoptShellPermissionIdentity(
                ""android.permission.INTERACT_ACROSS_USERS_FULL"",
                ""android.permission.CREATE_USERS"");

        DevicePolicyManager parentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);
        assertNotNull(parentDevicePolicyManager);

        int locationMode = Settings.Secure.getIntForUser(mContentResolver,
                Settings.Secure.LOCATION_MODE, UserHandle.USER_SYSTEM);

        for (String restriction : PROFILE_OWNER_ORGANIZATION_OWNED_LOCAL_RESTRICTIONS) {
            try {
                boolean hasRestrictionOnManagedProfile = mUserManager.hasUserRestriction(
                        restriction);

                parentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
                // Assert user restriction on personal profile has been added
                assertThat(hasUserRestriction(restriction)).isTrue();
                // Assert user restriction on managed profile has not changed
                assertThat(mUserManager.hasUserRestriction(restriction)).isEqualTo(
                        hasRestrictionOnManagedProfile);
            } finally {
                parentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                        restriction);
                assertThat(hasUserRestriction(restriction)).isFalse();
            }
        }

        // Restore the location mode setting after adding and removing the
        // DISALLOW_SHARE_LOCATION user restriction. This is because, modifying this user
        // restriction causes the location mode setting to be turned off.
        Settings.Secure.putIntForUser(mContentResolver, Settings.Secure.LOCATION_MODE, locationMode,
                UserHandle.USER_SYSTEM);
    }

    private static final Set<String> PROFILE_OWNER_ORGANIZATION_OWNED_GLOBAL_RESTRICTIONS =
            ImmutableSet.of(
                    UserManager.DISALLOW_CONFIG_PRIVATE_DNS,
                    UserManager.DISALLOW_CONFIG_DATE_TIME,
                    UserManager.DISALLOW_AIRPLANE_MODE
            );"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.DeviceOwnerUserRestrictionsTest"	"getDisallowedRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/DeviceOwnerUserRestrictionsTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner.userrestrictions;

import android.os.Process;
import android.os.UserHandle;
import android.os.UserManager;

public class DeviceOwnerUserRestrictionsTest extends BaseUserRestrictionsTest {
    public static final String[] ALLOWED = new String[] {
            // UserManager.DISALLOW_CONFIG_WIFI, // Has unrecoverable side effects.
            UserManager.DISALLOW_MODIFY_ACCOUNTS,
            UserManager.DISALLOW_INSTALL_APPS,
            UserManager.DISALLOW_UNINSTALL_APPS,
            // UserManager.DISALLOW_SHARE_LOCATION, // Has unrecoverable side effects.
            // UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES, // Has unrecoverable side effects.
            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
            UserManager.DISALLOW_CONFIG_BLUETOOTH,
            UserManager.DISALLOW_USB_FILE_TRANSFER,
            UserManager.DISALLOW_CONFIG_CREDENTIALS,
            UserManager.DISALLOW_REMOVE_USER,
            // UserManager.DISALLOW_DEBUGGING_FEATURES, // Need for CTS
            UserManager.DISALLOW_CONFIG_VPN,
            UserManager.DISALLOW_CONFIG_TETHERING,
            UserManager.DISALLOW_NETWORK_RESET,
            UserManager.DISALLOW_FACTORY_RESET,
            UserManager.DISALLOW_ADD_USER,
            // UserManager.ENSURE_VERIFY_APPS, // Has unrecoverable side effects.
            UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
            UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
            UserManager.DISALLOW_APPS_CONTROL,
            UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
            UserManager.DISALLOW_UNMUTE_MICROPHONE,
            UserManager.DISALLOW_ADJUST_VOLUME,
            UserManager.DISALLOW_OUTGOING_CALLS,
            UserManager.DISALLOW_SMS,
            UserManager.DISALLOW_FUN,
            UserManager.DISALLOW_CREATE_WINDOWS,
            UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS,
            UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE,
            UserManager.DISALLOW_OUTGOING_BEAM,
            UserManager.DISALLOW_SAFE_BOOT,
            UserManager.ALLOW_PARENT_PROFILE_APP_LINKING,
            // UserManager.DISALLOW_DATA_ROAMING, // Has unrecoverable side effects.
            UserManager.DISALLOW_SET_USER_ICON,
            UserManager.DISALLOW_BLUETOOTH,
            UserManager.DISALLOW_AUTOFILL,
            UserManager.DISALLOW_CONTENT_CAPTURE,
            UserManager.DISALLOW_CONTENT_SUGGESTIONS,
            UserManager.DISALLOW_UNIFIED_PASSWORD,
            UserManager.DISALLOW_CAMERA_TOGGLE,
            UserManager.DISALLOW_MICROPHONE_TOGGLE,
    };

    public static final String[] DISALLOWED = new String[] {
            // DO can set all public restrictions.
    };

    public static final String[] DEFAULT_ENABLED = new String[] {
            // No restrictions set for DO by default.
    };

    @Override
    protected String[] getAllowedRestrictions() {
        return ALLOWED;
    }

    @Override
    protected String[] getDisallowedRestrictions() {
        return DISALLOWED;
    }

    @Override
    protected String[] getDefaultEnabledRestrictions() { return DEFAULT_ENABLED; }

    /**
     * Picks a restriction that isn't applied by {@link UserManager} itself, applies it, and makes
     * sure that {@link UserManager} understands that it is applied but not as a base restriction.
     */"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.server.wm.BackgroundActivityLaunchTest"	"testPendingIntentBroadcast_appBIsBackground"	"CtsActivityManagerBackgroundActivityTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	"public void testPendingIntentBroadcast_appBIsBackground() throws Exception {
        EventReceiver receiver = new EventReceiver(
                Event.APP_A_START_BACKGROUND_ACTIVITY_BROADCAST_RECEIVED);

        // Send pendingIntent from AppA to AppB, and the AppB launch the pending intent to start
        // activity in App A
        sendPendingIntentBroadcast(0, receiver.getNotifier());

        // Waits for final hoop in AppA to start looking for activity, otherwise it could succeed
        // if the broadcast took long time to get executed (which may happen after boot).
        receiver.waitForEventOrThrow(BROADCAST_DELIVERY_TIMEOUT_MS);
        boolean result = waitForActivityFocused(APP_A_BACKGROUND_ACTIVITY);
        assertFalse(""Should not able to launch background activity"", result);
        assertTaskStack(null, APP_A_BACKGROUND_ACTIVITY);
    }

    /**
     * Returns a list of alive users on the device
     */
    private List<UserInfo> getAliveUsers() {
        // Setting the CREATE_USERS permission in AndroidManifest.xml has no effect when the test
        // is run through the CTS harness, so instead adopt it as a shell permission. We use
        // the CREATE_USERS permission instead of MANAGE_USERS because the shell can never use
        // MANAGE_USERS.
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity(Manifest.permission.CREATE_USERS);
        List<UserInfo> userList = mContext.getSystemService(UserManager.class)
                .getUsers(/* excludePartial= */ true,
                        /* excludeDying= */ true,
                        /* excludePreCreated= */ true);
        uiAutomation.dropShellPermissionIdentity();
        return userList;
    }

    /**
     * Removes the guest user from the device if present
     */
    private void removeGuestUser() {
        List<UserInfo> userList = getAliveUsers();
        for (UserInfo info : userList) {
            if (info.isGuest()) {
                removeUser(info.id);
                // Device is only allowed to have one alive guest user, so stop if it's found
                break;
            }
        }
    }

    /**
     * Removes a user from the device given their ID
     */
    private void removeUser(int userId) {
        executeShellCommand(String.format(""pm remove-user %d"", userId));
    }"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.media.cts.MediaCasTest"	"adoptShellPermissionIdentity"	"CtsMediaTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaCasTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import android.media.MediaCas;
import android.media.MediaCas.PluginDescriptor;
import android.media.MediaCas.Session;
import android.media.MediaCasException;
import android.media.MediaCasException.UnsupportedCasException;
import android.media.MediaCasStateException;
import android.media.MediaCodec;
import android.media.MediaDescrambler;
import android.media.cts.R;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.Presubmit;
import android.platform.test.annotations.RequiresDevice;
import android.test.AndroidTestCase;
import android.util.Log;

import androidx.test.filters.SmallTest;
import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.MediaUtils;
import com.android.compatibility.common.util.PropertyUtil;

import java.lang.ArrayIndexOutOfBoundsException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Presubmit
@SmallTest
@RequiresDevice
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class MediaCasTest extends AndroidTestCase {
    private static final String TAG = ""MediaCasTest"";

    // CA System Ids used for testing
    private static final int sInvalidSystemId = 0;
    private static final int sClearKeySystemId = 0xF6D8;
    private static final int API_LEVEL_BEFORE_CAS_SESSION = 28;
    private boolean mIsAtLeastR = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.R);
    private boolean mIsAtLeastS = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S);

    // ClearKey CAS/Descrambler test vectors
    private static final String sProvisionStr =
            ""{                                                   "" +
            ""  \""id\"": 21140844,                                 "" +
            ""  \""name\"": \""Test Title\"",                         "" +
            ""  \""lowercase_organization_name\"": \""Android\"",     "" +
            ""  \""asset_key\"": {                                  "" +
            ""  \""encryption_key\"": \""nezAr3CHFrmBR9R8Tedotw==\""  "" +
            ""  },                                                "" +
            ""  \""cas_type\"": 1,                                  "" +
            ""  \""track_types\"": [ ]                              "" +
            ""}                                                   "" ;

    private static final String sEcmBufferStr =
            ""00 00 01 f0 00 50 00 01  00 00 00 01 00 46 00 00"" +
            ""00 02 00 00 00 00 00 01  00 00 27 10 02 00 01 77"" +
            ""01 42 95 6c 0e e3 91 bc  fd 05 b1 60 4f 17 82 a4"" +
            ""86 9b 23 56 00 01 00 00  00 01 00 00 27 10 02 00"" +
            ""01 77 01 42 95 6c d7 43  62 f8 1c 62 19 05 c7 3a"" +
            ""42 cd fd d9 13 48                               "" ;

    private static final String sInputBufferStr =
            ""00 00 00 01 09 f0 00 00  00 01 67 42 c0 1e db 01"" +
            ""40 16 ec 04 40 00 00 03  00 40 00 00 0f 03 c5 8b"" +
            ""b8 00 00 00 01 68 ca 8c  b2 00 00 01 06 05 ff ff"" +
            ""70 dc 45 e9 bd e6 d9 48  b7 96 2c d8 20 d9 23 ee"" +
            ""ef 78 32 36 34 20 2d 20  63 6f 72 65 20 31 34 32"" +
            ""20 2d 20 48 2e 32 36 34  2f 4d 50 45 47 2d 34 20"" +
            ""41 56 43 20 63 6f 64 65  63 20 2d 20 43 6f 70 79"" +
            ""6c 65 66 74 20 32 30 30  33 2d 32 30 31 34 20 2d"" +
            ""20 68 74 74 70 3a 2f 2f  77 77 77 2e 76 69 64 65"" +
            ""6f 6c 61 6e 2e 6f 72 67  2f 78 32 36 34 2e 68 74"" +
            ""6d 6c 6e 45 21 82 38 f0  9d 7d 96 e6 94 ae e2 87"" +
            ""8f 04 49 e5 f6 8c 8b 9a  10 18 ba 94 e9 22 31 04"" +
            ""7e 60 5b c4 24 00 90 62  0d dc 85 74 75 78 d0 14"" +
            ""08 cb 02 1d 7d 9d 34 e8  81 b9 f7 09 28 79 29 8d"" +
            ""e3 14 ed 5f ca af f4 1c  49 15 e1 80 29 61 76 80"" +
            ""43 f8 58 53 40 d7 31 6d  61 81 41 e9 77 9f 9c e1"" +
            ""6d f2 ee d9 c8 67 d2 5f  48 73 e3 5c cd a7 45 58"" +
            ""bb dd 28 1d 68 fc b4 c6  f6 92 f6 30 03 aa e4 32"" +
            ""f6 34 51 4b 0f 8c f9 ac  98 22 fb 49 c8 bf ca 8c"" +
            ""80 86 5d d7 a4 52 b1 d9  a6 04 4e b3 2d 1f b8 35"" +
            ""cc 45 6d 9c 20 a7 a4 34  59 72 e3 ae ba 49 de d1"" +
            ""aa ee 3d 77 fc 5d c6 1f  9d ac c2 15 66 b8 e1 54"" +
            ""4e 74 93 db 9a 24 15 6e  20 a3 67 3e 5a 24 41 5e"" +
            ""b0 e6 35 87 1b c8 7a f9  77 65 e0 01 f2 4c e4 2b"" +
            ""a9 64 96 96 0b 46 ca ea  79 0e 78 a3 5f 43 fc 47"" +
            ""6a 12 fa c4 33 0e 88 1c  19 3a 00 c3 4e b5 d8 fa"" +
            ""8e f1 bc 3d b2 7e 50 8d  67 c3 6b ed e2 ea a6 1f"" +
            ""25 24 7c 94 74 50 49 e3  c6 58 2e fd 28 b4 c6 73"" +
            ""b1 53 74 27 94 5c df 69  b7 a1 d7 f5 d3 8a 2c 2d"" +
            ""b4 5e 8a 16 14 54 64 6e  00 6b 11 59 8a 63 38 80"" +
            ""76 c3 d5 59 f7 3f d2 fa  a5 ca 82 ff 4a 62 f0 e3"" +
            ""42 f9 3b 38 27 8a 89 aa  50 55 4b 29 f1 46 7c 75"" +
            ""ef 65 af 9b 0d 6d da 25  94 14 c1 1b f0 c5 4c 24"" +
            ""0e 65                                           "" ;

    private static final String sExpectedOutputBufferStr =
            ""00 00 00 01 09 f0 00 00  00 01 67 42 c0 1e db 01"" +
            ""40 16 ec 04 40 00 00 03  00 40 00 00 0f 03 c5 8b"" +
            ""b8 00 00 00 01 68 ca 8c  b2 00 00 01 06 05 ff ff"" +
            ""70 dc 45 e9 bd e6 d9 48  b7 96 2c d8 20 d9 23 ee"" +
            ""ef 78 32 36 34 20 2d 20  63 6f 72 65 20 31 34 32"" +
            ""20 2d 20 48 2e 32 36 34  2f 4d 50 45 47 2d 34 20"" +
            ""41 56 43 20 63 6f 64 65  63 20 2d 20 43 6f 70 79"" +
            ""6c 65 66 74 20 32 30 30  33 2d 32 30 31 34 20 2d"" +
            ""20 68 74 74 70 3a 2f 2f  77 77 77 2e 76 69 64 65"" +
            ""6f 6c 61 6e 2e 6f 72 67  2f 78 32 36 34 2e 68 74"" +
            ""6d 6c 20 2d 20 6f 70 74  69 6f 6e 73 3a 20 63 61"" +
            ""62 61 63 3d 30 20 72 65  66 3d 32 20 64 65 62 6c"" +
            ""6f 63 6b 3d 31 3a 30 3a  30 20 61 6e 61 6c 79 73"" +
            ""65 3d 30 78 31 3a 30 78  31 31 31 20 6d 65 3d 68"" +
            ""65 78 20 73 75 62 6d 65  3d 37 20 70 73 79 3d 31"" +
            ""20 70 73 79 5f 72 64 3d  31 2e 30 30 3a 30 2e 30"" +
            ""30 20 6d 69 78 65 64 5f  72 65 66 3d 31 20 6d 65"" +
            ""5f 72 61 6e 67 65 3d 31  36 20 63 68 72 6f 6d 61"" +
            ""5f 6d 65 3d 31 20 74 72  65 6c 6c 69 73 3d 31 20"" +
            ""38 78 38 64 63 74 3d 30  20 63 71 6d 3d 30 20 64"" +
            ""65 61 64 7a 6f 6e 65 3d  32 31 2c 31 31 20 66 61"" +
            ""73 74 5f 70 73 6b 69 70  3d 31 20 63 68 72 6f 6d"" +
            ""61 5f 71 70 5f 6f 66 66  73 65 74 3d 2d 32 20 74"" +
            ""68 72 65 61 64 73 3d 36  30 20 6c 6f 6f 6b 61 68"" +
            ""65 61 64 5f 74 68 72 65  61 64 73 3d 35 20 73 6c"" +
            ""69 63 65 64 5f 74 68 72  65 61 64 73 3d 30 20 6e"" +
            ""72 3d 30 20 64 65 63 69  6d 61 74 65 3d 31 20 69"" +
            ""6e 74 65 72 6c 61 63 65  64 3d 30 20 62 6c 75 72"" +
            ""61 79 5f 63 6f 6d 70 61  74 3d 30 20 63 6f 6e 73"" +
            ""74 72 61 69 6e 65 64 5f  69 6e 74 72 61 3d 30 20"" +
            ""62 66 72 61 6d 65 73 3d  30 20 77 65 69 67 68 74"" +
            ""70 3d 30 20 6b 65 79 69  6e 74 3d 32 35 30 20 6b"" +
            ""65 79 69 6e 74 5f 6d 69  6e 3d 32 35 20 73 63 65"" +
            ""6e 65                                           "" ;

    @Override
    public void setUp() throws Exception {
        super.setUp();
        // Need MANAGE_USERS or CREATE_USERS permission to access ActivityManager#getCurrentUser in
        // MediaCas. It is used by all tests, then adopt it from shell in setup
        InstrumentationRegistry
            .getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
    }

    @Override
    protected void tearDown() throws Exception {
        InstrumentationRegistry
            .getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
        super.tearDown();
    }
    /**
     * Test that all enumerated CA systems can be instantiated.
     *
     * Due to the vendor-proprietary nature of CAS, we cannot verify all operations
     * of an arbitrary plugin. We can only verify that isSystemIdSupported() is
     * consistent with the enumeration results, and all enumerated CA system ids can
     * be instantiated.
     */"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"android.multiuser.cts.UserManagerTest"	"testCloneUser"	"CtsMultiUserTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/multiuser/src/android/multiuser/cts/UserManagerTest.java"	""	"@SystemUserOnly(reason = ""Profiles are only supported on system user."")
    public void testCloneUser() throws Exception {
        // Need CREATE_USERS permission to create user in test
        mInstrumentation.getUiAutomation().adoptShellPermissionIdentity(
                Manifest.permission.CREATE_USERS, Manifest.permission.INTERACT_ACROSS_USERS);
        Set<String> disallowedPackages = new HashSet<String>();
        UserHandle userHandle = mUserManager.createProfile(
                ""Clone user"", UserManager.USER_TYPE_PROFILE_CLONE, disallowedPackages);
        assertThat(userHandle).isNotNull();

        try {
            final Context userContext = mContext.createPackageContextAsUser(""system"", 0,
                    userHandle);
            final UserManager cloneUserManager = userContext.getSystemService(UserManager.class);
            assertThat(cloneUserManager.isMediaSharedWithParent()).isTrue();
            assertThat(cloneUserManager.isCloneProfile()).isTrue();

            List<UserInfo> list = mUserManager.getUsers(true, true, true);
            List<UserInfo> cloneUsers = list.stream().filter(
                    user -> (user.id == userHandle.getIdentifier()
                            && user.isCloneProfile()))
                    .collect(Collectors.toList());
            assertThat(cloneUsers.size()).isEqualTo(1);
        } finally {
            assertThat(mUserManager.removeUser(userHandle)).isTrue();
            mInstrumentation.getUiAutomation().dropShellPermissionIdentity();
        }
    }
}"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.CreateAndManageUserTest"	"testCreateAndManageUser_StopEphemeralUser_DisallowRemoveUser"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/CreateAndManageUserTest.java"	""	"public void testCreateAndManageUser_StopEphemeralUser_DisallowRemoveUser() throws Exception {
        // Set DISALLOW_REMOVE_USER restriction
        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_REMOVE_USER);

        UserHandle userHandle = createAndManageUser(DevicePolicyManager.MAKE_USER_EPHEMERAL);
        startUserInBackgroundAndWaitForBroadcasts(userHandle);
        UserActionCallback callback = UserActionCallback.getCallbackForBroadcastActions(
                getContext(),
                BasicAdminReceiver.ACTION_USER_STOPPED, BasicAdminReceiver.ACTION_USER_REMOVED);

        callback.runAndUnregisterSelf(
                () -> stopUserAndCheckResult(userHandle, UserManager.USER_OPERATION_SUCCESS));

        // It's running just one operation (which issues a ACTION_USER_STOPPED), but as the
        // user is ephemeral, it will be automatically removed (which issues a
        // ACTION_USER_REMOVED).
        assertWithMessage(""user on broadcasts"").that(callback.getUsersOnReceivedBroadcasts())
                .containsExactly(userHandle, userHandle);
    }

    @SuppressWarnings(""unused"")
    private static void logoutUser(Context context, DevicePolicyManager devicePolicyManager,
            ComponentName componentName) {
        assertUserOperationResult(devicePolicyManager.logoutUser(componentName),
                UserManager.USER_OPERATION_SUCCESS, ""cannot logout user"");
    }"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.deviceowner.CreateAndManageUserTest"	"testCreateAndManageUser_RemoveRestrictionSet"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/CreateAndManageUserTest.java"	""	"public void testCreateAndManageUser_RemoveRestrictionSet() throws Exception {
        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_REMOVE_USER);

        UserHandle userHandle = createAndManageUser();

        // When the device owner itself has set the user restriction, it should still be allowed
        // to remove a user.
        List<UserHandle> usersOnBroadcasts = removeUserAndWaitForBroadcasts(userHandle);

        assertWithMessage(""user on broadcasts"").that(usersOnBroadcasts).containsExactly(userHandle);
    }"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.managedprofile.UserManagerTest"	"testCreateProfile_managedProfile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/UserManagerTest.java"	""	"public void testCreateProfile_managedProfile() {
        mUiAutomation.adoptShellPermissionIdentity(""android.permission.CREATE_USERS"");

        UserHandle newProfile = mUserManager.createProfile(""testProfile1"",
                UserManager.USER_TYPE_PROFILE_MANAGED, new HashSet<String>());
        assertThat(newProfile).isNotNull();

        List<UserHandle> profiles = mUserManager.getAllProfiles();
        assertThat(profiles).contains(newProfile);
    }

    /** This test should be run as the managed profile
     *  by com.android.cts.devicepolicy.ManagedProfileTest
     */"	""	""	"CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.comp.provisioning.UserRestrictionTest"	"testAddDisallowRemoveUserRestriction"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/provisioning/UserRestrictionTest.java"	""	"public void testAddDisallowRemoveUserRestriction() {
        setUserRestriction(UserManager.DISALLOW_REMOVE_USER, true);
    }"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.comp.provisioning.UserRestrictionTest"	"testClearDisallowRemoveUserRestriction"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CorpOwnedManagedProfile/src/com/android/cts/comp/provisioning/UserRestrictionTest.java"	""	"public void testClearDisallowRemoveUserRestriction() {
        setUserRestriction(UserManager.DISALLOW_REMOVE_USER, false);
    }

    private void setUserRestriction(String restriction, boolean add) {
        DevicePolicyManager dpm = getContext().getSystemService(DevicePolicyManager.class);
        ComponentName admin = AdminReceiver.getComponentName(getContext());
        if (add) {
            dpm.addUserRestriction(admin, restriction);
        } else {
            dpm.clearUserRestriction(admin, restriction);
        }
    }
}"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testUserRestrictionSetOnParentLogged"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	"public void testUserRestrictionSetOnParentLogged() throws Exception {
        assertMetricsLogged(getDevice(), () -> {
            runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".DevicePolicyLoggingParentTest"",
                    ""testUserRestrictionLogged"", mUserId);
                }, new DevicePolicyEventWrapper.Builder(EventId.ADD_USER_RESTRICTION_VALUE)
                        .setAdminPackageName(DEVICE_ADMIN_PKG)
                        .setStrings(DISALLOW_CONFIG_LOCATION, CALLED_FROM_PARENT)
                        .build(),
                new DevicePolicyEventWrapper.Builder(EventId.REMOVE_USER_RESTRICTION_VALUE)
                        .setAdminPackageName(DEVICE_ADMIN_PKG)
                        .setStrings(DISALLOW_CONFIG_LOCATION, CALLED_FROM_PARENT)
                        .build());
    }"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DeviceOwnerPlusProfileOwnerTest"	"testRequestBugreportAvailableIfAffiliated"	"CtsDevicePolicyManagerTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerPlusProfileOwnerTest.java"	""	"public void testRequestBugreportAvailableIfAffiliated() throws Exception {
        assumeCanCreateAdditionalUsers(2);

        final int secondaryUserId = setupManagedSecondaryUser();

        // No affiliation ids have been set on the secondary user, the feature shouldn't be
        // available.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testRequestBugreportThrowsSecurityException"",
                mPrimaryUserId);

        // Affiliate the DO and the secondary user.
        setSameAffiliationId(secondaryUserId);
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testRequestBugreportDoesNotThrowException"",
                mPrimaryUserId);

        setDifferentAffiliationId(secondaryUserId, COMP_DPC_PKG);
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                DEVICE_WIDE_LOGGING_TEST,
                ""testRequestBugreportThrowsSecurityException"",
                mPrimaryUserId);
    }

    private void verifyBindDeviceAdminServiceAsUser(int profileOwnerUserId) throws Exception {
        // Installing a non managing app (neither device owner nor profile owner).
        installAppAsUser(COMP_DPC_APK2, mPrimaryUserId);
        installAppAsUser(COMP_DPC_APK2, profileOwnerUserId);

        // Testing device owner -> profile owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_GOOD_SETUP_TEST,
                mPrimaryUserId);
        // Testing profile owner -> device owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_GOOD_SETUP_TEST,
                profileOwnerUserId);
    }

    private void verifyBindDeviceAdminServiceAsUserFails(int profileOwnerUserId) throws Exception {
        // Installing a non managing app (neither device owner nor profile owner).
        installAppAsUser(COMP_DPC_APK2, mPrimaryUserId);
        installAppAsUser(COMP_DPC_APK2, profileOwnerUserId);

        // Testing device owner -> profile owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_FAILS_TEST,
                mPrimaryUserId);
        // Testing profile owner -> device owner.
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                BIND_DEVICE_ADMIN_SERVICE_FAILS_TEST,
                profileOwnerUserId);
    }

    private void setSameAffiliationId(
            int profileOwnerUserId, String profileOwnerPackage) throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                AFFILIATION_TEST,
                ""testSetAffiliationId1"",
                mPrimaryUserId);
        runDeviceTestsAsUser(
                profileOwnerPackage,
                AFFILIATION_TEST,
                ""testSetAffiliationId1"",
                profileOwnerUserId);
    }

    private void setSameAffiliationId(int profileOwnerUserId) throws Exception {
        setSameAffiliationId(profileOwnerUserId, COMP_DPC_PKG);
    }

    private void setDifferentAffiliationId(
            int profileOwnerUserId, String profileOwnerPackage) throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                AFFILIATION_TEST,
                ""testSetAffiliationId1"",
                mPrimaryUserId);
        runDeviceTestsAsUser(
                profileOwnerPackage,
                AFFILIATION_TEST,
                ""testSetAffiliationId2"",
                profileOwnerUserId);
    }

    private void setDifferentAffiliationId(int profileOwnerUserId) throws Exception {
        setDifferentAffiliationId(profileOwnerUserId, COMP_DPC_PKG);
    }

    private void assertProvisionManagedProfileNotAllowed(String packageName) throws Exception {
        runDeviceTestsAsUser(
                packageName,
                MANAGEMENT_TEST,
                ""testProvisionManagedProfileNotAllowed"",
                mPrimaryUserId);
    }

    /** Returns the user id of the newly created managed profile */
    private int setupManagedProfile(String apkName, String packageName,
            String adminReceiverClassName) throws Exception {
        final int userId = createManagedProfile(mPrimaryUserId);
        installAppAsUser(apkName, userId);
        setProfileOwnerOrFail(adminReceiverClassName, userId);
        startUserAndWait(userId);
        runDeviceTestsAsUser(
                packageName,
                MANAGEMENT_TEST,
                ""testIsManagedProfile"",
                userId);
        return userId;
    }

    /** Returns the user id of the newly created secondary user */
    private int setupManagedSecondaryUser() throws Exception {
        assertTrue(""Cannot create 1 additional user"", canCreateAdditionalUsers(1));

        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGEMENT_TEST,
                ""testCreateSecondaryUser"",
                mPrimaryUserId);
        List<Integer> newUsers = getUsersCreatedByTests();
        assertEquals(1, newUsers.size());
        int secondaryUserId = newUsers.get(0);
        getDevice().startUser(secondaryUserId, /* waitFlag= */ true);
        return secondaryUserId;
    }

    /** Returns the user id of the newly created secondary user */
    private int provisionCorpOwnedManagedProfile() throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGED_PROFILE_PROVISIONING_TEST,
                ""testProvisioningCorpOwnedManagedProfile"",
                mPrimaryUserId);
        return getFirstManagedProfileUserId();
    }

    /**
     * Add {@link android.os.UserManager#DISALLOW_REMOVE_USER}.
     */
    private void addDisallowRemoveUserRestriction() throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                USER_RESTRICTION_TEST,
                ""testAddDisallowRemoveUserRestriction"",
                mPrimaryUserId);
    }

    /**
     * Clear {@link android.os.UserManager#DISALLOW_REMOVE_USER}.
     */
    private void clearDisallowRemoveUserRestriction() throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                USER_RESTRICTION_TEST,
                ""testClearDisallowRemoveUserRestriction"",
                mPrimaryUserId);
    }

    private void assertOtherProfilesEqualsBindTargetUsers(int otherProfileUserId) throws Exception {
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGEMENT_TEST,
                ""testOtherProfilesEqualsBindTargetUsers"",
                mPrimaryUserId);
        runDeviceTestsAsUser(
                COMP_DPC_PKG,
                MANAGEMENT_TEST,
                ""testOtherProfilesEqualsBindTargetUsers"",
                otherProfileUserId);
    }
}"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.devicepolicy.DevicePolicySafetyCheckerIntegrationTester"	"testOnOperationSafetyStateChanged"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/common/src/com/android/cts/devicepolicy/DevicePolicySafetyCheckerIntegrationTester.java"	""	"public void testOnOperationSafetyStateChanged(Context context, DevicePolicyManager dpm) {
        // Currently there's just one reason...
        int reason = OPERATION_SAFETY_REASON_DRIVING_DISTRACTION;
        // Operation doesn't really matter
        int operation = OPERATION_LOCK_NOW;
        Log.d(TAG, ""testOnOperationSafetyStateChanged(): dpm="" + dpm
                + "", reason="" + operationSafetyReasonToString(reason)
                + "", operation="" + operationToString(operation));
        OperationSafetyChangedCallback receiver = OperationSafetyChangedCallback.register(context);
        try {
            setOperationUnsafe(dpm, operation, reason);
            // Must force OneTimeSafetyChecker to generate the event by calling the unsafe operation
            assertThrows(UnsafeStateException.class, () -> dpm.lockNow());

            Log.d(TAG, ""Waiting isSafe=false event"");
            assertNextEvent(receiver, reason, /* isSafe= */ false);

            // OneTimeSafetyChecker automatically disables itself after one operation, which in turn
            // triggers another event
            Log.d(TAG, ""Waiting isSafe=true event"");
            assertNextEvent(receiver, reason, /* isSafe= */ true);
        } finally {
            receiver.unregister(context);
        }
    }

    private void assertNextEvent(OperationSafetyChangedCallback receiver,
            int reason, boolean isSafe) {
        OperationSafetyChangedEvent event = receiver.getNextEvent();
        Log.v(TAG, ""Received event: "" + event);
        assertWithMessage(""event (%s) reason"", event).that(event.reason).isEqualTo(reason);
        assertWithMessage(""event (%s) safety state"", event).that(event.isSafe).isEqualTo(isSafe);
    }

    /**
     * Gets the device / profile owner-specific operations.
     *
     * <p>By default it returns an empty array, but sub-classes can override to add its supported
     * operations.
     */
    protected int[] getSafetyAwareOperations() {
        return new int[] {};
    }

    /**
     * Gets the device / profile owner-specific operations that are overloaded.
     *
     * <p>For example, {@code OPERATION_WIPE_DATA} is used for both {@code wipeData(flags)} and
     * {@code wipeData(flags, reason)}, so it should be returned both here and on
     * {@link #getSafetyAwareOperations()}, then
     * {@link #runOperation(DevicePolicyManager, int, boolean)} will handle which method to call for
     * each case.
     *
     * <p>By default it returns an empty array, but sub-classes can override to add its supported
     * operations.
     */
    protected int[] getOverloadedSafetyAwareOperations() {
        return new int[] {};
    }

    /**
     * Runs the device / profile owner-specific operation.
     *
     * <p>MUST be overridden if {@link #getSafetyAwareOperations()} is overridden as well.
     */
    protected void runOperation(DevicePolicyManager dpm, ComponentName admin, int operation,
            boolean overloaded) {
        throwUnsupportedOperationException(operation, overloaded);
    }

    /**
     * Throws a {@link UnsupportedOperationException} then the given {@code operation} is not
     * supported.
     */
    protected final void throwUnsupportedOperationException(int operation, boolean overloaded) {
        throw new UnsupportedOperationException(
                ""Unsupported operation "" + getOperationName(operation, overloaded));
    }

    private void safeOperationTest(DevicePolicyManager dpm, ComponentName admin,
            List<String> failures, int operation, boolean overloaded) {
        String name = getOperationName(operation, overloaded);
        // Currently there's just one reason...
        int reason = OPERATION_SAFETY_REASON_DRIVING_DISTRACTION;

        try {
            setOperationUnsafe(dpm, operation, reason);
            runCommonOrSpecificOperation(dpm, admin, operation, overloaded);
            Log.e(TAG, name + "" didn't throw an UnsafeStateException"");
            failures.add(name);
        } catch (UnsafeStateException e) {
            Log.d(TAG, name + "" failed as expected: "" + e);
        } catch (Exception e) {
            Log.e(TAG, name + "" threw unexpected exception"", e);
            failures.add(name + ""("" + e + "")"");
        }
    }

    private String getOperationName(int operation, boolean overloaded) {
        String name = operationToString(operation);
        return overloaded ? name + ""(OVERLOADED)"" : name;
    }

    private void runCommonOrSpecificOperation(DevicePolicyManager dpm, ComponentName admin,
            int operation, boolean overloaded) throws Exception {
        String name = getOperationName(operation, overloaded);
        Log.v(TAG, ""runOperation(): "" + name);
        switch (operation) {
            case OPERATION_LOCK_NOW:
                if (overloaded) {
                    dpm.lockNow(/* flags= */ 0);
                } else {
                    dpm.lockNow();
                }
                break;
            case OPERATION_LOGOUT_USER:
                dpm.logoutUser(admin);
                break;
            case OPERATION_SET_ALWAYS_ON_VPN_PACKAGE:
                if (overloaded) {
                    dpm.setAlwaysOnVpnPackage(admin, ""vpnPackage"", /* lockdownEnabled= */ true);
                } else {
                    dpm.setAlwaysOnVpnPackage(admin, ""vpnPackage"", /* lockdownEnabled= */ true,
                            /* lockdownAllowlist= */ Set.of(""vpnPackage""));
                }
                break;
            case OPERATION_SET_MASTER_VOLUME_MUTED:
                dpm.setMasterVolumeMuted(admin, /* on= */ true);
                break;
            case OPERATION_SET_PERMISSION_GRANT_STATE:
                dpm.setPermissionGrantState(admin, ""package"", ""permission"", /* grantState= */ 0);
                break;
            case OPERATION_SET_PERMISSION_POLICY:
                dpm.setPermissionPolicy(admin, /* policy= */ 0);
                break;
            case OPERATION_SET_RESTRICTIONS_PROVIDER:
                dpm.setRestrictionsProvider(admin,
                        /* provider= */ new ComponentName(""package"", ""component""));
                break;
            case OPERATION_SET_USER_RESTRICTION:
                dpm.addUserRestriction(admin, UserManager.DISALLOW_REMOVE_USER);
                break;
            case OPERATION_REMOVE_ACTIVE_ADMIN:
                dpm.removeActiveAdmin(admin);
                break;
            case OPERATION_REMOVE_KEY_PAIR:
                dpm.removeKeyPair(admin, ""keyAlias"");
                break;
            default:
                runOperation(dpm, admin, operation, overloaded);
        }
    }

    private void setOperationUnsafe(DevicePolicyManager dpm, int operation, int reason) {
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(dpm,
                (obj) -> obj.setNextOperationSafety(operation, reason));
    }
}"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.ManagedUserPositiveTestActivity"	"isAffiliatedUser"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/ManagedUserPositiveTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static com.android.cts.verifier.managedprovisioning.Utils.createInteractiveTestItem;

import android.app.Activity;
import android.app.admin.DevicePolicyManager;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.DataSetObserver;
import android.os.Bundle;
import android.os.UserManager;
import android.provider.Settings;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.IntentDrivenTestActivity.ButtonInfo;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;
import com.android.cts.verifier.TestResult;

/**
 * Activity that lists all positive managed user tests.
 */
public class ManagedUserPositiveTestActivity extends PassFailButtons.TestListActivity {
    private static final String TAG = ""ManagedUserPositiveTestActivity"";

    private static final String ACTION_CHECK_AFFILIATED_PROFILE_OWNER =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_AFFILIATED_PROFILE_OWNER"";
    static final String EXTRA_TEST_ID = ""extra-test-id"";

    private static final String CHECK_AFFILIATED_PROFILE_OWNER_TEST_ID =
            ""CHECK_AFFILIATED_PROFILE_OWNER"";
    private static final String DEVICE_ADMIN_SETTINGS_ID = ""DEVICE_ADMIN_SETTINGS"";
    private static final String DISABLE_STATUS_BAR_TEST_ID = ""DISABLE_STATUS_BAR"";
    private static final String DISABLE_KEYGUARD_TEST_ID = ""DISABLE_KEYGUARD"";
    private static final String POLICY_TRANSPARENCY_TEST_ID = ""POLICY_TRANSPARENCY"";
    private static final String DISALLOW_REMOVE_USER_TEST_ID = ""DISALLOW_REMOVE_USER"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (ACTION_CHECK_AFFILIATED_PROFILE_OWNER.equals(getIntent().getAction())) {
            DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
            if (dpm.isProfileOwnerApp(getPackageName()) && dpm.isAffiliatedUser()) {
                TestResult.setPassedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        null, null);
            } else {
                TestResult.setFailedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        getString(R.string.managed_user_incorrect_managed_user), null);
            }
            finish();
            return;
        }

        setContentView(R.layout.positive_managed_user);
        setInfoResources(R.string.managed_user_positive_tests,
                R.string.managed_user_positive_tests_info, 0);
        setPassFailButtonClickListeners();

        final ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);
        adapter.add(TestListItem.newCategory(this, R.string.managed_user_positive_category));

        addTestsToAdapter(adapter);

        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }
        });

        setTestListAdapter(adapter);
    }

    @Override
    public void finish() {
        // If this activity was started for checking profile owner status, then no need to do any
        // tear down.
        if (!ACTION_CHECK_AFFILIATED_PROFILE_OWNER.equals(getIntent().getAction())) {
            // Pass and fail buttons are known to call finish() when clicked,
            // and this is when we want to remove the managed owner.
            DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
            dpm.logoutUser(DeviceAdminTestReceiver.getReceiverComponentName());
        }
        super.finish();
    }

    private void addTestsToAdapter(final ArrayTestListAdapter adapter) {
        adapter.add(createTestItem(this, CHECK_AFFILIATED_PROFILE_OWNER_TEST_ID,
                R.string.managed_user_check_managed_user_test,
                new Intent(ACTION_CHECK_AFFILIATED_PROFILE_OWNER)
                        .putExtra(EXTRA_TEST_ID, getIntent().getStringExtra(EXTRA_TEST_ID))));

        // device admin settings
        adapter.add(createInteractiveTestItem(this, DEVICE_ADMIN_SETTINGS_ID,
                R.string.device_owner_device_admin_visible,
                R.string.device_owner_device_admin_visible_info,
                new ButtonInfo(
                        R.string.device_owner_settings_go,
                        new Intent(Settings.ACTION_SECURITY_SETTINGS))));

        // DISABLE_STATUS_BAR_TEST
        if (isStatusBarEnabled()) {
            adapter.add(createInteractiveTestItem(this, DISABLE_STATUS_BAR_TEST_ID,
                    R.string.device_owner_disable_statusbar_test,
                    R.string.device_owner_disable_statusbar_test_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_disable_statusbar_button,
                                    createManagedUserIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_STATUSBAR_DISABLED,
                                            true)),
                            new ButtonInfo(
                                    R.string.device_owner_reenable_statusbar_button,
                                    createManagedUserIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_STATUSBAR_DISABLED,
                                            false))}));
        }

        // setKeyguardDisabled
        adapter.add(createInteractiveTestItem(this, DISABLE_KEYGUARD_TEST_ID,
                R.string.device_owner_disable_keyguard_test,
                R.string.device_owner_disable_keyguard_test_info,
                new ButtonInfo[]{
                        new ButtonInfo(
                                R.string.device_owner_disable_keyguard_button,
                                createManagedUserIntentWithBooleanParameter(
                                        CommandReceiverActivity.COMMAND_SET_KEYGUARD_DISABLED,
                                        true)),
                        new ButtonInfo(
                                R.string.device_owner_reenable_keyguard_button,
                                createManagedUserIntentWithBooleanParameter(
                                        CommandReceiverActivity.COMMAND_SET_KEYGUARD_DISABLED,
                                        false))}));

        // DISALLOW_REMOVE_USER
        adapter.add(createInteractiveTestItem(this, DISALLOW_REMOVE_USER_TEST_ID,
                R.string.disallow_remove_user,
                R.string.managed_user_disallow_remove_user_info,
                new ButtonInfo[]{
                        new ButtonInfo(
                                R.string.device_owner_user_restriction_set,
                                CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                        UserManager.DISALLOW_REMOVE_USER, true)),
                        new ButtonInfo(
                                R.string.device_owner_settings_go,
                                new Intent(Settings.ACTION_USER_SETTINGS))}));

        // Policy Transparency
        final Intent policyTransparencyTestIntent = new Intent(this,
                PolicyTransparencyTestListActivity.class);
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestListActivity.EXTRA_MODE,
                PolicyTransparencyTestListActivity.MODE_MANAGED_USER);
        // So that PolicyTransparencyTestListActivity knows which test to update with the result:
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestActivity.EXTRA_TEST_ID, POLICY_TRANSPARENCY_TEST_ID);
        adapter.add(createTestItem(this, POLICY_TRANSPARENCY_TEST_ID,
                R.string.device_profile_owner_policy_transparency_test,
                policyTransparencyTestIntent));

    }


    static TestListItem createTestItem(Activity activity, String id, int titleRes,
            Intent intent) {
        intent.putExtra(EXTRA_TEST_ID, id);
        return TestListItem.newTest(activity, titleRes, id, intent, null);
    }

    private Intent createManagedUserIntentWithBooleanParameter(String command, boolean value) {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND, command)
                .putExtra(CommandReceiverActivity.EXTRA_ENFORCED, value);
    }

    private boolean isStatusBarEnabled() {
        // Watches don't support the status bar so this is an ok proxy, but this is not the most
        // general test for that. TODO: add a test API to do a real check for status bar support.
        return !getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);
    }
}"	""	""	"REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.DeviceOwnerPositiveTestActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/DeviceOwnerPositiveTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.os.UserHandle.myUserId;

import static com.android.cts.verifier.managedprovisioning.Utils.createInteractiveTestItem;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.admin.DevicePolicyManager;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.DataSetObserver;
import android.os.Bundle;
import android.os.UserManager;
import android.provider.Settings;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;

import com.android.bedstead.dpmwrapper.TestAppSystemServiceFactory;
import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.IntentDrivenTestActivity.ButtonInfo;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;
import com.android.cts.verifier.TestResult;

/**
 * Activity that lists all positive device owner tests. Requires the following adb command be issued
 * by the user prior to starting the tests:
 *
 * adb shell dpm set-device-owner
 *  'com.android.cts.verifier/com.android.cts.verifier.managedprovisioning.DeviceAdminTestReceiver'
 */
public class DeviceOwnerPositiveTestActivity extends PassFailButtons.TestListActivity {
    private static final String TAG = ""DeviceOwnerPositiveTestActivity"";

    private static final String ACTION_CHECK_DEVICE_OWNER =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_DEVICE_OWNER"";
    private static final String ACTION_CHECK_PROFILE_OWNER =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_PROFILE_OWNER"";
    private static final String ACTION_CHECK_CURRENT_USER_AFFILIATED =
            ""com.android.cts.verifier.managedprovisioning.action.CHECK_USER_AFFILIATED"";

    static final String EXTRA_TEST_ID = ""extra-test-id"";

    private static final String CHECK_DEVICE_OWNER_TEST_ID = ""CHECK_DEVICE_OWNER"";
    private static final String CHECK_PROFILE_OWNER_TEST_ID = ""CHECK_PROFILE_OWNER"";
    private static final String CHECK_USER_AFFILIATED_TEST_ID = ""CHECK_USER_AFFILIATED"";
    private static final String DEVICE_ADMIN_SETTINGS_ID = ""DEVICE_ADMIN_SETTINGS"";
    private static final String WIFI_LOCKDOWN_TEST_ID = WifiLockdownTestActivity.class.getName();
    private static final String DISABLE_STATUS_BAR_TEST_ID = ""DISABLE_STATUS_BAR"";
    private static final String DISABLE_KEYGUARD_TEST_ID = ""DISABLE_KEYGUARD"";
    private static final String LOCK_TASK_UI_TEST_ID = ""LOCK_TASK_UI"";
    private static final String CHECK_PERMISSION_LOCKDOWN_TEST_ID =
            PermissionLockdownTestActivity.class.getName();
    private static final String DISALLOW_CONFIG_BT_ID = ""DISALLOW_CONFIG_BT"";
    private static final String DISALLOW_CONFIG_WIFI_ID = ""DISALLOW_CONFIG_WIFI"";
    private static final String DISALLOW_CONFIG_VPN_ID = ""DISALLOW_CONFIG_VPN"";
    private static final String DISALLOW_USB_FILE_TRANSFER_ID = ""DISALLOW_USB_FILE_TRANSFER"";
    private static final String SET_USER_ICON_TEST_ID = ""SET_USER_ICON"";
    private static final String DISALLOW_DATA_ROAMING_ID = ""DISALLOW_DATA_ROAMING"";
    private static final String DISALLOW_FACTORY_RESET_ID = ""DISALLOW_FACTORY_RESET"";
    private static final String POLICY_TRANSPARENCY_TEST_ID = ""POLICY_TRANSPARENCY"";
    private static final String ENTERPRISE_PRIVACY_TEST_ID = ""ENTERPRISE_PRIVACY"";
    private static final String NETWORK_LOGGING_UI_TEST_ID = ""NETWORK_LOGGING_UI"";
    private static final String DISALLOW_USER_SWITCH_TEST_ID = ""DISALLOW_USER_SWITCH"";
    private static final String USER_SWITCHER_MESSAGE_TEST_ID = ""USER_SWITCHER_MESSAGE"";
    private static final String ENABLE_LOGOUT_TEST_ID = ""ENABLE_LOGOUT"";
    private static final String MANAGED_USER_TEST_ID = ""MANAGED_USER_UI"";
    private static final String REMOVE_DEVICE_OWNER_TEST_ID = ""REMOVE_DEVICE_OWNER"";
    private static final String DISALLOW_AMBIENT_DISPLAY_ID = ""DISALLOW_AMBIENT_DISPLAY"";
    private static final String DISALLOW_REMOVE_USER_TEST_ID = ""DISALLOW_REMOVE_USER"";
    private static final String DISABLE_USB_DATA_SIGNALING_TEST_ID = ""DISABLE_USB_DATA_SIGNALING"";
    private static final String SET_REQUIRED_PASSWORD_COMPLEXITY_ID =
            ""SET_REQUIRED_PASSWORD_COMPLEXITY"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Tidy up in case previous run crashed.
        new ByodFlowTestHelper(this).tearDown();

        if (ACTION_CHECK_DEVICE_OWNER.equals(getIntent().getAction())) {
            DevicePolicyManager dpm = TestAppSystemServiceFactory.getDevicePolicyManager(this,
                    DeviceAdminTestReceiver.class);
            if (dpm.isDeviceOwnerApp(getPackageName())) {
                // Set DISALLOW_ADD_USER on behalf of ManagedProvisioning.
                dpm.addUserRestriction(DeviceAdminTestReceiver.getReceiverComponentName(),
                        UserManager.DISALLOW_ADD_USER);
                TestResult.setPassedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        null, null);
            } else {
                TestResult.setFailedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        getString(R.string.device_owner_incorrect_profile_owner, myUserId()),
                        null);
            }

            finish();
            return;
        }
        if (ACTION_CHECK_PROFILE_OWNER.equals(getIntent().getAction())) {
            DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
            if (dpm.isProfileOwnerApp(getPackageName())) {
                TestResult.setPassedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        null, null);
            } else {
                TestResult.setFailedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        getString(R.string.device_owner_incorrect_device_owner, myUserId()), null);
            }
            finish();
            return;
        }
        if (ACTION_CHECK_CURRENT_USER_AFFILIATED.equals(getIntent().getAction())) {
            DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
            if (dpm.isAffiliatedUser()) {
                TestResult.setPassedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        null, null);
            } else {
                TestResult.setFailedResult(this, getIntent().getStringExtra(EXTRA_TEST_ID),
                        getString(R.string.device_owner_user_not_affiliated, myUserId()), null);
            }
            finish();
            return;
        }

        setContentView(R.layout.positive_device_owner);
        setInfoResources(R.string.device_owner_positive_tests,
                R.string.device_owner_positive_tests_info, 0);
        setPassFailButtonClickListeners();

        final ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);
        adapter.add(TestListItem.newCategory(this, R.string.device_owner_positive_category));

        addTestsToAdapter(adapter);

        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }
        });

        setTestListAdapter(adapter);

        View setDeviceOwnerButton = findViewById(R.id.set_device_owner_button);
        setDeviceOwnerButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                StringBuilder builder = new StringBuilder();
                if (UserManager.isHeadlessSystemUserMode()) {
                    builder.append(getString(R.string.grant_headless_system_user_permissions));
                }

                String message = builder.append(getString(R.string.set_device_owner_dialog_text))
                        .toString();
                Log.i(TAG, message);
                new AlertDialog.Builder(
                        DeviceOwnerPositiveTestActivity.this)
                        .setIcon(android.R.drawable.ic_dialog_info)
                        .setTitle(R.string.set_device_owner_dialog_title)
                        .setMessage(message)
                        .setPositiveButton(android.R.string.ok, null)
                        .show();
            }
        });

    }

    @Override
    public void finish() {
        String action = getIntent().getAction();
        switch(action != null ? action : """") {
            case ACTION_CHECK_DEVICE_OWNER:
            case ACTION_CHECK_PROFILE_OWNER:
            case ACTION_CHECK_CURRENT_USER_AFFILIATED:
                // If this activity was started for checking device / profile owner status, then no
                // need to do any tear down.
                Log.d(TAG, ""NOT starting createTearDownIntent() due to "" + action);
                break;
            default:
                // Pass and fail buttons are known to call finish() when clicked,
                // and this is when we want to remove the device owner.
                Log.d(TAG, ""Starting createTearDownIntent() due to "" + action);
                startActivity(createTearDownIntent());
                break;
        }
        super.finish();
    }

    private void addTestsToAdapter(final ArrayTestListAdapter adapter) {
        adapter.add(createTestItem(this, CHECK_DEVICE_OWNER_TEST_ID,
                R.string.device_owner_check_device_owner_test,
                new Intent(ACTION_CHECK_DEVICE_OWNER)
                        .putExtra(EXTRA_TEST_ID, getIntent().getStringExtra(EXTRA_TEST_ID))));
        if (UserManager.isHeadlessSystemUserMode()) {
            adapter.add(createTestItem(this, CHECK_PROFILE_OWNER_TEST_ID,
                    R.string.device_owner_check_profile_owner_test,
                    new Intent(ACTION_CHECK_PROFILE_OWNER)
                            .putExtra(EXTRA_TEST_ID, getIntent().getStringExtra(EXTRA_TEST_ID))));
            adapter.add(createTestItem(this, CHECK_USER_AFFILIATED_TEST_ID,
                    R.string.device_owner_check_user_affiliation_test,
                    new Intent(ACTION_CHECK_CURRENT_USER_AFFILIATED)
                            .putExtra(EXTRA_TEST_ID, getIntent().getStringExtra(EXTRA_TEST_ID))));
        }

        // device admin settings
        adapter.add(createInteractiveTestItem(this, DEVICE_ADMIN_SETTINGS_ID,
                R.string.device_owner_device_admin_visible,
                R.string.device_owner_device_admin_visible_info,
                new ButtonInfo(
                        R.string.device_owner_settings_go,
                        new Intent(Settings.ACTION_SECURITY_SETTINGS))));

        PackageManager packageManager = getPackageManager();
        if (packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI)) {
            // WiFi Lock down tests
            adapter.add(createTestItem(this, WIFI_LOCKDOWN_TEST_ID,
                    R.string.device_owner_wifi_lockdown_test,
                    new Intent(this, WifiLockdownTestActivity.class)));

            // DISALLOW_CONFIG_WIFI
            adapter.add(createInteractiveTestItem(this, DISALLOW_CONFIG_WIFI_ID,
                    R.string.device_owner_disallow_config_wifi,
                    R.string.device_owner_disallow_config_wifi_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_WIFI, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_WIFI_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_WIFI, false))
            }));
        }

        // DISALLOW_AMBIENT_DISPLAY.
        // TODO: After the ambient display feature flag is added in PackageManager (b/135591614),
        // uncomment this test and run it only when ambient display is supported by the device.

        // adapter.add(createInteractiveTestItem(this, DISALLOW_AMBIENT_DISPLAY_ID,
        //         R.string.device_owner_disallow_ambient_display,
        //         R.string.device_owner_disallow_ambient_display_info,
        //         new ButtonInfo[] {
        //                 new ButtonInfo(
        //                         R.string.device_owner_user_restriction_set,
        //                         CommandReceiverActivity.createSetUserRestrictionIntent(
        //                                 UserManager.DISALLOW_AMBIENT_DISPLAY, true)),
        //                 new ButtonInfo(
        //                         R.string.device_owner_settings_go,
        //                         new Intent(Settings.ACTION_DISPLAY_SETTINGS))}));

        // DISALLOW_CONFIG_VPN
        // TODO(b/189282625): replace FEATURE_WATCH with a more specific feature
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            adapter.add(createInteractiveTestItem(this, DISALLOW_CONFIG_VPN_ID,
                    R.string.device_owner_disallow_config_vpn,
                    R.string.device_owner_disallow_config_vpn_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_user_vpn_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_VPN, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_VPN_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_vpn_test,
                                    new Intent(this, VpnTestActivity.class)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_VPN, false))
                    }));
        }

        // DISALLOW_DATA_ROAMING
        // TODO(b/189282625): replace FEATURE_WATCH with a more specific feature
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)
                && packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            adapter.add(createInteractiveTestItem(this, DISALLOW_DATA_ROAMING_ID,
                    R.string.device_owner_disallow_data_roaming,
                    R.string.device_owner_disallow_data_roaming_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_DATA_ROAMING, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_DATA_ROAMING_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_DATA_ROAMING, false))
                    }));
        }

        // DISALLOW_FACTORY_RESET
        adapter.add(createInteractiveTestItem(this, DISALLOW_FACTORY_RESET_ID,
                R.string.device_owner_disallow_factory_reset,
                R.string.device_owner_disallow_factory_reset_info,
                new ButtonInfo[] {
                        new ButtonInfo(
                                R.string.device_owner_user_restriction_set,
                                CommandReceiverActivity.createSetDeviceOwnerUserRestrictionIntent(
                                        UserManager.DISALLOW_FACTORY_RESET, true)),
                        new ButtonInfo(
                                R.string.device_owner_user_restriction_unset,
                                CommandReceiverActivity.createSetDeviceOwnerUserRestrictionIntent(
                                        UserManager.DISALLOW_FACTORY_RESET, false))
        }));

        // DISALLOW_CONFIG_BLUETOOTH
        if (packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            adapter.add(createInteractiveTestItem(this, DISALLOW_CONFIG_BT_ID,
                    R.string.device_owner_disallow_config_bt,
                    R.string.device_owner_disallow_config_bt_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_BLUETOOTH, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_BLUETOOTH_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_CONFIG_BLUETOOTH, false))
            }));
        }

        // DISALLOW_USB_FILE_TRANSFER
        // TODO(b/189282625): replace FEATURE_WATCH with a more specific feature
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            adapter.add(createInteractiveTestItem(this, DISALLOW_USB_FILE_TRANSFER_ID,
                    R.string.device_owner_disallow_usb_file_transfer_test,
                    R.string.device_owner_disallow_usb_file_transfer_test_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_USB_FILE_TRANSFER, true)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_USB_FILE_TRANSFER, false))
                    }));
        }

        // DISABLE_STATUS_BAR_TEST
        if (isStatusBarEnabled()) {
            adapter.add(createInteractiveTestItem(this, DISABLE_STATUS_BAR_TEST_ID,
                    R.string.device_owner_disable_statusbar_test,
                    R.string.device_owner_disable_statusbar_test_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_disable_statusbar_button,
                                    createDeviceOwnerIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_STATUSBAR_DISABLED,
                                                    true)),
                            new ButtonInfo(
                                    R.string.device_owner_reenable_statusbar_button,
                                    createDeviceOwnerIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_STATUSBAR_DISABLED,
                                                    false))}));
        }

        // setKeyguardDisabled
        if (isKeyguardShownWhenUserDoesntHaveCredentials() && Utils.isLockscreenSupported(this)) {
            adapter.add(createInteractiveTestItem(this, DISABLE_KEYGUARD_TEST_ID,
                    R.string.device_owner_disable_keyguard_test,
                    R.string.device_owner_disable_keyguard_test_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_disable_keyguard_button,
                                    createDeviceOwnerIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_KEYGUARD_DISABLED,
                                                    true)),
                            new ButtonInfo(
                                    R.string.device_owner_reenable_keyguard_button,
                                    createDeviceOwnerIntentWithBooleanParameter(
                                            CommandReceiverActivity.COMMAND_SET_KEYGUARD_DISABLED,
                                                    false))}));
        }

        // setLockTaskFeatures
        // TODO(b/189282625): replace FEATURE_WATCH with a more specific feature
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            final Intent lockTaskUiTestIntent = new Intent(this, LockTaskUiTestActivity.class);
            lockTaskUiTestIntent.putExtra(LockTaskUiTestActivity.EXTRA_TEST_ID,
                    LOCK_TASK_UI_TEST_ID);
            adapter.add(createTestItem(this, LOCK_TASK_UI_TEST_ID,
                    R.string.device_owner_lock_task_ui_test,
                    lockTaskUiTestIntent));
        }

        // setUserIcon
        adapter.add(createInteractiveTestItem(this, SET_USER_ICON_TEST_ID,
                R.string.device_owner_set_user_icon,
                R.string.device_owner_set_user_icon_instruction,
                new ButtonInfo[] {
                        new ButtonInfo(
                                R.string.device_owner_set_user_icon_button,
                                createSetUserIconIntent(R.drawable.user_icon_1)),
                        new ButtonInfo(
                                R.string.disallow_set_user_icon,
                                CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                        UserManager.DISALLOW_SET_USER_ICON, true)),
                        new ButtonInfo(
                                R.string.device_owner_set_user_icon2_button,
                                createSetUserIconIntent(R.drawable.user_icon_2)),
                        new ButtonInfo(
                                R.string.device_owner_settings_go,
                                new Intent(Settings.ACTION_SETTINGS)),
                        new ButtonInfo(
                                R.string.device_owner_user_restriction_unset,
                                CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                        UserManager.DISALLOW_SET_USER_ICON, false))
        }));

        // setPermissionGrantState
        adapter.add(createTestItem(this, CHECK_PERMISSION_LOCKDOWN_TEST_ID,
                R.string.device_profile_owner_permission_lockdown_test,
                new Intent(PermissionLockdownTestActivity.ACTION_CHECK_PERMISSION_LOCKDOWN)));

        // Policy Transparency
        final Intent policyTransparencyTestIntent = new Intent(this,
                PolicyTransparencyTestListActivity.class);
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestListActivity.EXTRA_MODE,
                PolicyTransparencyTestListActivity.MODE_DEVICE_OWNER);
        // So that PolicyTransparencyTestListActivity knows which test to update with the result:
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestActivity.EXTRA_TEST_ID, POLICY_TRANSPARENCY_TEST_ID);
        adapter.add(createTestItem(this, POLICY_TRANSPARENCY_TEST_ID,
                R.string.device_profile_owner_policy_transparency_test,
                policyTransparencyTestIntent));

        // Enterprise Privacy
        final Intent enterprisePolicyTestIntent = new Intent(this,
                EnterprisePrivacyTestListActivity.class);
        enterprisePolicyTestIntent.putExtra(
                EnterprisePrivacyTestListActivity.EXTRA_TEST_ID, ENTERPRISE_PRIVACY_TEST_ID);
        adapter.add(createTestItem(this, ENTERPRISE_PRIVACY_TEST_ID,
                R.string.enterprise_privacy_test,
                enterprisePolicyTestIntent));

        if (packageManager.hasSystemFeature(PackageManager.FEATURE_MANAGED_USERS)
                && UserManager.supportsMultipleUsers()) {
            // Managed user
            adapter.add(createInteractiveTestItem(this, MANAGED_USER_TEST_ID,
                    R.string.managed_user_test,
                    R.string.managed_user_positive_tests_instructions,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    createCreateManagedUserIntent())}));

            // User switcher message
            adapter.add(createInteractiveTestItem(this, USER_SWITCHER_MESSAGE_TEST_ID,
                    R.string.device_owner_user_switcher_message,
                    R.string.device_owner_user_switcher_message_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_with_user_switcher_message,
                                    createWithUserSwitcherMessageIntent()),
                            new ButtonInfo(
                                    R.string.device_owner_without_user_switcher_message,
                                    createWithoutUserSwitcherMessageIntent())}));

            // Enable logout
            adapter.add(createInteractiveTestItem(this, ENABLE_LOGOUT_TEST_ID,
                    R.string.device_owner_enable_logout,
                    R.string.device_owner_enable_logout_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    createEnableLogoutIntent())}));

            // DISALLOW_USER_SWITCH
            adapter.add(createInteractiveTestItem(this, DISALLOW_USER_SWITCH_TEST_ID,
                    R.string.device_owner_disallow_user_switch,
                    R.string.device_owner_disallow_user_switch_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_disallow_user_switch_create_user,
                                    createCreateManagedUserWithoutSetupIntent()),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_USER_SWITCH, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_USER_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_USER_SWITCH, false))
            }));

            // DISALLOW_REMOVE_USER
            adapter.add(createInteractiveTestItem(this, DISALLOW_REMOVE_USER_TEST_ID,
                    R.string.disallow_remove_user,
                    R.string.device_owner_disallow_remove_user_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.device_owner_disallow_remove_user_create_user,
                                    createCreateManagedUserWithoutSetupIntent()),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_set,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_REMOVE_USER, true)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_USER_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_user_restriction_unset,
                                    CommandReceiverActivity.createSetCurrentUserRestrictionIntent(
                                            UserManager.DISALLOW_REMOVE_USER, false)),
                            new ButtonInfo(
                                    R.string.device_owner_remove_secondary_user,
                                    createRemoveSecondaryUsersIntent())
            }));
        }

        // Network logging UI
        adapter.add(createInteractiveTestItem(this, NETWORK_LOGGING_UI_TEST_ID,
                R.string.device_owner_network_logging_ui,
                R.string.device_owner_network_logging_ui_info,
                new ButtonInfo[] {
                        new ButtonInfo(
                                R.string.device_owner_enable_network_logging_button,
                                createEnableNetworkLoggingIntent()),
                        new ButtonInfo(
                                R.string.device_owner_disable_network_logging_button,
                                createDisableNetworkLoggingIntent())}));

        // Customize lock screen message
        if (isSwipeToUnlockSupported() && Utils.isLockscreenSupported(this)) {
            adapter.add(TestListItem.newTest(this,
                    R.string.device_owner_customize_lockscreen_message,
                    LockscreenMessageTestActivity.class.getName(),
                    new Intent(this, LockscreenMessageTestActivity.class),
                    /* requiredFeatures */ null));
        }

        // setUsbDataSignalingEnabled
        if (canUsbDataSignalingBeDisabled()) {
            adapter.add(createInteractiveTestItem(this, DISABLE_USB_DATA_SIGNALING_TEST_ID,
                    R.string.device_owner_disable_usb_data_signaling_test,
                    R.string.device_owner_disable_usb_data_signaling_test_info,
                    new ButtonInfo[] {
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_disable_usb_data_signaling_test,
                                    createDisableUsbDataSignalingIntent()),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_SETTINGS)),
                            new ButtonInfo(
                                    R.string.device_owner_enable_usb_data_signaling_test,
                                    createEnableUsbDataSignalingIntent())
                    }));
        }

        // setRequiredPasswordComplexity
        if (Utils.isLockscreenSupported(this)) {
            adapter.add(createInteractiveTestItem(this, SET_REQUIRED_PASSWORD_COMPLEXITY_ID,
                    R.string.device_owner_required_password_complexity_test,
                    R.string.device_owner_required_password_complexity_test_info,
                    new ButtonInfo[]{
                            new ButtonInfo(
                                    R.string.set_low_required_password_complexity,
                                    createSetRequiredPasswordComplexityIntent(
                                            DevicePolicyManager.PASSWORD_COMPLEXITY_LOW)),
                            new ButtonInfo(
                                    R.string.set_medium_required_password_complexity,
                                    createSetRequiredPasswordComplexityIntent(
                                            DevicePolicyManager.PASSWORD_COMPLEXITY_MEDIUM)),
                            new ButtonInfo(
                                    R.string.set_high_required_password_complexity,
                                    createSetRequiredPasswordComplexityIntent(
                                            DevicePolicyManager.PASSWORD_COMPLEXITY_HIGH)),
                            new ButtonInfo(
                                    R.string.remove_required_password_complexity,
                                    createSetRequiredPasswordComplexityIntent(
                                            DevicePolicyManager.PASSWORD_COMPLEXITY_NONE)),
                            new ButtonInfo(
                                    R.string.device_owner_settings_go,
                                    new Intent(Settings.ACTION_SECURITY_SETTINGS))}));
        }

        // removeDeviceOwner
        adapter.add(createInteractiveTestItem(this, REMOVE_DEVICE_OWNER_TEST_ID,
                R.string.device_owner_remove_device_owner_test,
                R.string.device_owner_remove_device_owner_test_info,
                new ButtonInfo(
                        R.string.remove_device_owner_button,
                        createTearDownIntent())));
    }

    static TestListItem createTestItem(Activity activity, String id, int titleRes,
            Intent intent) {
        intent.putExtra(EXTRA_TEST_ID, id);
        return TestListItem.newTest(activity, titleRes, id, intent, null);
    }

    private Intent createTearDownIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_REMOVE_DEVICE_OWNER);
    }

    private Intent createDeviceOwnerIntentWithBooleanParameter(String command, boolean value) {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND, command)
                .putExtra(CommandReceiverActivity.EXTRA_ENFORCED, value);
    }

    private Intent createSetUserIconIntent(int iconRes) {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_SET_USER_ICON)
                .putExtra(CommandReceiverActivity.EXTRA_VALUE, iconRes);
    }

    private Intent createEnableNetworkLoggingIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_ENABLE_NETWORK_LOGGING);
    }

    private Intent createDisableNetworkLoggingIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_DISABLE_NETWORK_LOGGING);
    }

    private Intent createCreateManagedUserIntent() {
        // Set execution start time for counting test execution time.
        mStartTime = System.currentTimeMillis();
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_CREATE_MANAGED_USER);
    }

    private Intent createWithUserSwitcherMessageIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_WITH_USER_SWITCHER_MESSAGE);
    }

    private Intent createWithoutUserSwitcherMessageIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_WITHOUT_USER_SWITCHER_MESSAGE);
    }

    private Intent createEnableLogoutIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_ENABLE_LOGOUT);
    }

    private Intent createCreateManagedUserWithoutSetupIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_CREATE_MANAGED_USER_WITHOUT_SETUP);
    }

    private Intent createRemoveSecondaryUsersIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_REMOVE_SECONDARY_USERS);
    }

    private Intent createEnableUsbDataSignalingIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_ENABLE_USB_DATA_SIGNALING);
    }

    private Intent createDisableUsbDataSignalingIntent() {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_DISABLE_USB_DATA_SIGNALING);
    }

    private Intent createSetRequiredPasswordComplexityIntent(int complexity) {
        return new Intent(this, CommandReceiverActivity.class)
                .putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                        CommandReceiverActivity.COMMAND_SET_REQUIRED_PASSWORD_COMPLEXITY)
                .putExtra(CommandReceiverActivity.EXTRA_VALUE, complexity);
    }

    private boolean isStatusBarEnabled() {
        // Watches don't support the status bar so this is an ok proxy, but this is not the most
        // general test for that. TODO: add a test API to do a real check for status bar support.
        return !getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)
                && !isAutomotive() && !isTelevision();
    }

    private boolean isKeyguardShownWhenUserDoesntHaveCredentials() {
        return !isAutomotive();
    }

    private boolean isSwipeToUnlockSupported() {
        return !isAutomotive();
    }

    private boolean isAutomotive() {
        return getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }

    private boolean isTelevision() {
        return getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    }

    private boolean canUsbDataSignalingBeDisabled() {
        DevicePolicyManager dpm = getSystemService(DevicePolicyManager.class);
        return dpm != null && dpm.canUsbDataSignalingBeDisabled();
    }
}"	""	""	"REMOVE_USER CREATE_USER"	""	""	""	""	""	""	""	""	""	""
"2.5.3  . Software"	"3.9.3"	"A-1-1"	"3.9.3/A-1-1"	"03090300.650101"	"""[3.9.3/A-1-1] MUST implement all of the User lifecycle properties INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, REMOVE_USER. Automotive device implementations: """	""	""	"REMOVE_USER SWITCH_USER INITIAL_USER_INFO CREATE_USER"	""	""	""	""	""	""	""	""	"com.android.cts.deviceandprofileowner.userrestrictions.BaseUserRestrictionsTest"	"assertClearDefaultRestrictions"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/BaseUserRestrictionsTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner.userrestrictions;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Process;
import android.os.UserHandle;
import android.os.UserManager;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.cts.deviceandprofileowner.BaseDeviceAdminTest;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public abstract class BaseUserRestrictionsTest extends BaseDeviceAdminTest {
    protected static final String[] ALL_USER_RESTRICTIONS = new String[]{
            UserManager.DISALLOW_CONFIG_WIFI,
            UserManager.DISALLOW_MODIFY_ACCOUNTS,
            UserManager.DISALLOW_INSTALL_APPS,
            UserManager.DISALLOW_UNINSTALL_APPS,
            UserManager.DISALLOW_SHARE_LOCATION,
            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,
            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
            UserManager.DISALLOW_CONFIG_BLUETOOTH,
            UserManager.DISALLOW_USB_FILE_TRANSFER,
            UserManager.DISALLOW_CONFIG_CREDENTIALS,
            UserManager.DISALLOW_REMOVE_USER,
            UserManager.DISALLOW_DEBUGGING_FEATURES,
            UserManager.DISALLOW_CONFIG_VPN,
            UserManager.DISALLOW_CONFIG_TETHERING,
            UserManager.DISALLOW_NETWORK_RESET,
            UserManager.DISALLOW_FACTORY_RESET,
            UserManager.DISALLOW_ADD_USER,
            UserManager.ENSURE_VERIFY_APPS,
            UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
            UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
            UserManager.DISALLOW_APPS_CONTROL,
            UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
            UserManager.DISALLOW_UNMUTE_MICROPHONE,
            UserManager.DISALLOW_ADJUST_VOLUME,
            UserManager.DISALLOW_OUTGOING_CALLS,
            UserManager.DISALLOW_SMS,
            UserManager.DISALLOW_FUN,
            UserManager.DISALLOW_CREATE_WINDOWS,
            UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS,
            UserManager.DISALLOW_CROSS_PROFILE_COPY_PASTE,
            UserManager.DISALLOW_OUTGOING_BEAM,
            UserManager.DISALLOW_SAFE_BOOT,
            UserManager.ALLOW_PARENT_PROFILE_APP_LINKING,
            UserManager.DISALLOW_DATA_ROAMING,
            UserManager.DISALLOW_SET_USER_ICON,
            UserManager.DISALLOW_BLUETOOTH,
            UserManager.DISALLOW_BLUETOOTH_SHARING,
            UserManager.DISALLOW_CAMERA_TOGGLE,
            UserManager.DISALLOW_MICROPHONE_TOGGLE,
    };

    /**
     * Restrictions that affect all users when DO sets.
     */
    protected static final String[] DO_GLOBAL_RESTRICTIONS = new String[] {
            UserManager.DISALLOW_USB_FILE_TRANSFER,
            UserManager.DISALLOW_CONFIG_TETHERING,
            UserManager.DISALLOW_NETWORK_RESET,
            UserManager.DISALLOW_FACTORY_RESET,
            UserManager.DISALLOW_ADD_USER,
            UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
            UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
            UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
            UserManager.DISALLOW_SMS,
            UserManager.DISALLOW_FUN,
            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
            UserManager.DISALLOW_SAFE_BOOT,
            UserManager.DISALLOW_CREATE_WINDOWS,
            UserManager.DISALLOW_BLUETOOTH,
            // UserManager.DISALLOW_DATA_ROAMING, // Not set during CTS
            UserManager.DISALLOW_CAMERA_TOGGLE,
            UserManager.DISALLOW_MICROPHONE_TOGGLE,

            // PO can set them too, but when DO sets them, they're global.
            UserManager.DISALLOW_ADJUST_VOLUME,
            UserManager.DISALLOW_UNMUTE_MICROPHONE,
            UserManager.DISALLOW_SYSTEM_ERROR_DIALOGS
    };

    public static final String[] HIDDEN_AND_PROHIBITED = new String[] {
            ""no_record_audio"",
            ""no_wallpaper"",
            ""no_oem_unlock""
    };

    protected void assertLayeredRestriction(String restriction, boolean expected) {
        assertEquals(""Restriction "" + restriction + "": expected="" + expected,
                expected, mUserManager.hasUserRestriction(restriction));
    }

    protected void assertOwnerRestriction(String restriction, boolean expected) {
        assertEquals(""Restriction "" + restriction + "": expected="" + expected,
                expected, mDevicePolicyManager.getUserRestrictions(ADMIN_RECEIVER_COMPONENT)
                        .getBoolean(restriction));
    }

    /** Returns whether {@link UserManager} itself has applied the given restriction to the user. */
    protected boolean hasBaseUserRestriction(String restriction, UserHandle userHandle) {
        return ShellIdentityUtils.invokeMethodWithShellPermissions(mUserManager,
                (um) -> um.hasBaseUserRestriction(restriction, userHandle));
    }

    /**
     * Check that {@link UserManager#hasUserRestriction} gives the expected results for each
     * restriction.
     * @param expected the list of user restrictions that are expected to have been applied due
     *                 to DO/PO
     */
    protected void assertRestrictions(Set<String> expected) {
        final UserHandle userHandle = Process.myUserHandle();
        for (String r : ALL_USER_RESTRICTIONS) {
            assertLayeredRestriction(r,
                    expected.contains(r) || hasBaseUserRestriction(r, userHandle));
        }
    }

    /**
     * Test that the given restriction can be set and cleared, then leave it set again.
     */
    protected void assertSetClearUserRestriction(String restriction) {
        final boolean hadRestriction = mUserManager.hasUserRestriction(restriction);

        assertOwnerRestriction(restriction, false);

        // Set.  Shouldn't throw.
        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);

        assertOwnerRestriction(restriction, true);
        assertLayeredRestriction(restriction, true);

        // Then clear.
        assertClearUserRestriction(restriction);

        assertLayeredRestriction(restriction, hadRestriction);

        // Then set again.
        mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
    }

    /**
     * Test that the given restriction can be cleared.  (and leave it cleared.)
     */
    protected void assertClearUserRestriction(String restriction) {
        mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);

        assertOwnerRestriction(restriction, false);
    }

    protected void assertClearDefaultRestrictions() {
        for (String restriction : getDefaultEnabledRestrictions()) {
            assertClearUserRestriction(restriction);
        }
    }

    /**
     * Test that the given restriction *cannot* be set (or clear).
     */
    protected void assertCannotSetUserRestriction(String restriction) {
        final boolean hadRestriction = mUserManager.hasUserRestriction(restriction);

        assertOwnerRestriction(restriction, false);

        // Set should fail.
        try {
            mDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
            fail(""Restriction="" + restriction);
        } catch (SecurityException e) {
            assertTrue(""Restriction="" + restriction + "" Message was: "" + e.getMessage(),
                    e.getMessage().contains(""cannot set user restriction""));
        }

        // Shouldn't have changed.
        assertOwnerRestriction(restriction, false);
        assertLayeredRestriction(restriction, hadRestriction);

        // Clear should fail too.
        try {
            mDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
            fail(""Restriction="" + restriction);
        } catch (SecurityException e) {
            assertTrue(""Restriction="" + restriction + "" Message was: "" + e.getMessage(),
                    e.getMessage().contains(""cannot set user restriction""));
        }

        // Shouldn't have changed.
        assertOwnerRestriction(restriction, false);
        assertLayeredRestriction(restriction, hadRestriction);
    }

    /** For {@link #testSetAllRestrictions} */
    protected abstract String[] getAllowedRestrictions();

    /** For {@link #testSetAllRestrictions} */
    protected abstract String[] getDisallowedRestrictions();

    /** For {@link #testDefaultRestrictions()} */
    protected abstract String[] getDefaultEnabledRestrictions();

    /**
     * Test restrictions that should be enabled by default
     */"	""	""	"REMOVE_USER REMOVE_USER"	""	""	""	""	""	""	""	""	""	""
