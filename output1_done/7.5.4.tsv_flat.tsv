"Section"	"section_id"	"req_id"	"Test Availability"	"class_def"	"method"	"module"	"method_text"	"full_key"	"requirement"	"key_as_number"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"matched_terms"	"search_roots"	"qualified_method"	"max_matches"	"file_name"	"matched_files"	"methods_string"	"urls"	"protected"	"Area"	"Shortened"	"Test Level"
"212:651746) 7.5.4  . Camera API Behavior"	"7.5.4"	"H-1-1"	""	"android.hardware.camera2.cts.LogicalCameraDeviceTest"	"testActivePhysicalId"	"CtsCameraTestCases"	""	"7.5.4/H-1-1"	""">7.5.4/H-1-1] MUST have normal field of view (FOV) by default and it MUST be between 50 and 90 degrees. Handheld device implementations: [<a href=""#7_6_memory_and_storage"""""	""	"re_tag:50&90&degrees"	""	""	""	"re_tag:50&90&degrees"	""	""	""	"/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/LogicalCameraDeviceTest.java"	""	"public void testActivePhysicalId() throws Exception {
        final int AVAILABILITY_TIMEOUT_MS = 10;
        final LinkedBlockingQueue<Pair<String, String>> unavailablePhysicalCamEventQueue =
                new LinkedBlockingQueue<>();
        CameraManager.AvailabilityCallback ac = new CameraManager.AvailabilityCallback() {
             @Override
            public void onPhysicalCameraUnavailable(String cameraId, String physicalCameraId) {
                unavailablePhysicalCamEventQueue.offer(new Pair<>(cameraId, physicalCameraId));
            }
        };

        mCameraManager.registerAvailabilityCallback(ac, mHandler);
        Set<Pair<String, String>> unavailablePhysicalCameras = new HashSet<Pair<String, String>>();
        Pair<String, String> candidatePhysicalIds =
                unavailablePhysicalCamEventQueue.poll(AVAILABILITY_TIMEOUT_MS,
                java.util.concurrent.TimeUnit.MILLISECONDS);
        while (candidatePhysicalIds != null) {
            unavailablePhysicalCameras.add(candidatePhysicalIds);
            candidatePhysicalIds =
                unavailablePhysicalCamEventQueue.poll(AVAILABILITY_TIMEOUT_MS,
                java.util.concurrent.TimeUnit.MILLISECONDS);
        }
        mCameraManager.unregisterAvailabilityCallback(ac);

        for (String id : mCameraIdsUnderTest) {
            try {
                Log.i(TAG, ""Testing Camera "" + id);

                StaticMetadata staticInfo = mAllStaticInfo.get(id);
                if (!staticInfo.isColorOutputSupported()) {
                    Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");
                    continue;
                }

                if (!staticInfo.isLogicalMultiCamera()) {
                    Log.i(TAG, ""Camera "" + id + "" is not a logical multi-camera, skipping"");
                    continue;
                }

                if (!staticInfo.isActivePhysicalCameraIdSupported()) {
                    continue;
                }

                final Set<String> physicalIds =
                        staticInfo.getCharacteristics().getPhysicalCameraIds();
                openDevice(id);
                Size previewSz =
                        getMaxPreviewSize(mCamera.getId(), mCameraManager,
                        getPreviewSizeBound(mWindowManager, PREVIEW_SIZE_BOUND));

                String storedActiveId = null;
                for (int template : sTemplates) {
                    try {
                        CaptureRequest.Builder requestBuilder =
                                mCamera.createCaptureRequest(template);
                        SimpleCaptureCallback listener = new SimpleCaptureCallback();
                        startPreview(requestBuilder, previewSz, listener);
                        waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

                        CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
                        String activePhysicalId = result.get(
                                CaptureResult.LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID);

                        assertNotNull(""activePhysicalId must not be null"", activePhysicalId);
                        if (storedActiveId == null) {
                            storedActiveId = activePhysicalId;
                            assertTrue(
                                  ""Camera device reported invalid activePhysicalId: "" +
                                  activePhysicalId, physicalIds.contains(activePhysicalId));
                        } else {
                            assertTrue(
                                  ""Camera device reported different activePhysicalId "" +
                                  activePhysicalId + "" vs "" + storedActiveId +
                                  "" for different capture templates"",
                                  storedActiveId.equals(activePhysicalId));
                        }
                    } catch (IllegalArgumentException e) {
                        if (template == CameraDevice.TEMPLATE_MANUAL &&
                                !staticInfo.isCapabilitySupported(CameraCharacteristics.
                                REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                            // OK
                        } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG &&
                                !staticInfo.isCapabilitySupported(CameraCharacteristics.
                                REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)) {
                            // OK.
                        } else {
                            throw e; // rethrow
                        }
                    }
                }

                // Query unavailable physical cameras, and make sure the active physical id
                // isn't an unavailable physical camera.
                for (Pair<String, String> unavailPhysicalCamera: unavailablePhysicalCameras) {
                    assertFalse(unavailPhysicalCamera.first.equals(id) &&
                           unavailPhysicalCamera.second.equals(storedActiveId));
                }
            } finally {
                closeDevice();
            }
        }

    }

    /**
     * Test that for logical multi-camera of a Handheld device, the default FOV is
     * between 50 and 90 degrees for all capture templates.
     */"	""	""	""	""	""
"212:651746) 7.5.4  . Camera API Behavior"	"7.5.4"	"H-1-1"	""	"android.hardware.camera2.cts.LogicalCameraDeviceTest"	"testDefaultFov"	"CtsCameraTestCases"	""	"7.5.4/H-1-1"	""">7.5.4/H-1-1] MUST have normal field of view (FOV) by default and it MUST be between 50 and 90 degrees. Handheld device implementations: [<a href=""#7_6_memory_and_storage"""""	""	"re_tag:50&90&degrees"	""	""	""	"re_tag:50&90&degrees"	""	""	""	"/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/LogicalCameraDeviceTest.java"	""	"@CddTest(requirement=""7.5.4/C-1-1"")
    public void testDefaultFov() throws Exception {
        final double MIN_FOV = 50;
        final double MAX_FOV = 90;
        if (!isHandheldDevice()) {
            return;
        }
        for (String id : mCameraIdsUnderTest) {
            try {
                Log.i(TAG, ""Testing Camera "" + id);

                StaticMetadata staticInfo = mAllStaticInfo.get(id);
                if (!staticInfo.isColorOutputSupported()) {
                    Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");
                    continue;
                }

                if (!staticInfo.isLogicalMultiCamera()) {
                    Log.i(TAG, ""Camera "" + id + "" is not a logical multi-camera, skipping"");
                    continue;
                }

                SizeF physicalSize = staticInfo.getCharacteristics().get(
                        CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);
                double physicalDiag = Math.sqrt(Math.pow(physicalSize.getWidth(), 2)
                        + Math.pow(physicalSize.getHeight(), 2));
                Rect activeArraySize = staticInfo.getCharacteristics().get(
                        CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);

                openDevice(id);
                for (int template : sTemplates) {
                    try {
                        CaptureRequest.Builder requestBuilder =
                                mCamera.createCaptureRequest(template);
                        Float requestFocalLength = requestBuilder.get(
                                CaptureRequest.LENS_FOCAL_LENGTH);
                        assertNotNull(""LENS_FOCAL_LENGTH must not be null"", requestFocalLength);

                        Float requestZoomRatio = requestBuilder.get(
                                CaptureRequest.CONTROL_ZOOM_RATIO);
                        assertNotNull(""CONTROL_ZOOM_RATIO must not be null"", requestZoomRatio);
                        Rect requestCropRegion = requestBuilder.get(
                                CaptureRequest.SCALER_CROP_REGION);
                        assertNotNull(""SCALER_CROP_REGION must not be null"", requestCropRegion);
                        float totalZoomRatio = Math.min(
                                1.0f * activeArraySize.width() / requestCropRegion.width(),
                                1.0f * activeArraySize.height() / requestCropRegion.height()) *
                                requestZoomRatio;

                        double fov = 2 *
                                Math.toDegrees(Math.atan2(physicalDiag/(2 * totalZoomRatio),
                                requestFocalLength));

                        Log.v(TAG, ""Camera "" +  id + "" template "" + template +
                                ""'s default FOV is "" + fov);
                        mCollector.expectInRange(""Camera "" +  id + "" template "" + template +
                                ""'s default FOV must fall between [50, 90] degrees"",
                                fov, MIN_FOV, MAX_FOV);
                    } catch (IllegalArgumentException e) {
                        if (template == CameraDevice.TEMPLATE_MANUAL &&
                                !staticInfo.isCapabilitySupported(CameraCharacteristics.
                                REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                            // OK
                        } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG &&
                                !staticInfo.isCapabilitySupported(CameraCharacteristics.
                                REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)) {
                            // OK.
                        } else {
                            throw e; // rethrow
                        }
                    }
                }
            } finally {
                closeDevice();
            }
        }
    }

    /**
     * Find a common preview size that's supported by both the logical camera and
     * two of the underlying physical cameras.
     */
    private Size findCommonPreviewSize(String cameraId,
            List<String> dualPhysicalCameraIds) throws Exception {

        Set<String> physicalCameraIds =
                mStaticInfo.getCharacteristics().getPhysicalCameraIds();
        assertTrue(""Logical camera must contain at least 2 physical camera ids"",
                physicalCameraIds.size() >= 2);

        List<Size> previewSizes = getSupportedPreviewSizes(
                cameraId, mCameraManager, PREVIEW_SIZE_BOUND);
        HashMap<String, List<Size>> physicalPreviewSizesMap = new HashMap<String, List<Size>>();
        HashMap<String, StreamConfigurationMap> physicalConfigs = new HashMap<>();
        for (String physicalCameraId : physicalCameraIds) {
            CameraCharacteristics properties =
                    mCameraManager.getCameraCharacteristics(physicalCameraId);
            assertNotNull(""Can't get camera characteristics!"", properties);
            if (!mAllStaticInfo.get(physicalCameraId).isColorOutputSupported()) {
                // No color output support, skip.
                continue;
            }
            StreamConfigurationMap configMap =
                properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            physicalConfigs.put(physicalCameraId, configMap);
            physicalPreviewSizesMap.put(physicalCameraId,
                    getSupportedPreviewSizes(physicalCameraId, mCameraManager, PREVIEW_SIZE_BOUND));
        }

        // Find display size from window service.
        Context context = mActivityRule.getActivity().getApplicationContext();
        WindowManager windowManager =
                (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        Display display = windowManager.getDefaultDisplay();

        int displayWidth = display.getWidth();
        int displayHeight = display.getHeight();

        if (displayHeight > displayWidth) {
            displayHeight = displayWidth;
            displayWidth = display.getHeight();
        }

        StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        for (Size previewSize : previewSizes) {
            dualPhysicalCameraIds.clear();
            // Skip preview sizes larger than screen size
            if (previewSize.getWidth() > displayWidth ||
                    previewSize.getHeight() > displayHeight) {
                continue;
            }

            final long minFrameDuration = config.getOutputMinFrameDuration(
                   ImageFormat.YUV_420_888, previewSize);

            ArrayList<String> supportedPhysicalCameras = new ArrayList<String>();
            for (String physicalCameraId : physicalCameraIds) {
                List<Size> physicalPreviewSizes = physicalPreviewSizesMap.get(physicalCameraId);
                if (physicalPreviewSizes != null && physicalPreviewSizes.contains(previewSize)) {
                   long minDurationPhysical =
                           physicalConfigs.get(physicalCameraId).getOutputMinFrameDuration(
                           ImageFormat.YUV_420_888, previewSize);
                   if (minDurationPhysical <= minFrameDuration) {
                        dualPhysicalCameraIds.add(physicalCameraId);
                        if (dualPhysicalCameraIds.size() == 2) {
                            return previewSize;
                        }
                   }
                }
            }
        }
        return null;
    }

    /**
     * Validate that physical cameras are not cropping too much.
     *
     * This is to make sure physical processed streams have at least the same field of view as
     * the logical stream, or the maximum field of view of the physical camera, whichever is
     * smaller.
     *
     * Note that the FOV is calculated in the directio of sensor width.
     */
    private void validatePhysicalCamerasFov(TotalCaptureResult totalCaptureResult,
            List<String> physicalCameraIds) {
        Rect cropRegion = totalCaptureResult.get(CaptureResult.SCALER_CROP_REGION);
        Float focalLength = totalCaptureResult.get(CaptureResult.LENS_FOCAL_LENGTH);
        Float zoomRatio = totalCaptureResult.get(CaptureResult.CONTROL_ZOOM_RATIO);
        Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();
        SizeF sensorSize = mStaticInfo.getValueFromKeyNonNull(
                CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);

        // Assume subject distance >> focal length, and subject distance >> camera baseline.
        double fov = 2 * Math.toDegrees(Math.atan2(sensorSize.getWidth() * cropRegion.width() /
                (2 * zoomRatio * activeArraySize.width()),  focalLength));

        Map<String, CaptureResult> physicalResultsDual =
                    totalCaptureResult.getPhysicalCameraResults();
        for (String physicalId : physicalCameraIds) {
            StaticMetadata physicalStaticInfo = mAllStaticInfo.get(physicalId);
            CaptureResult physicalResult = physicalResultsDual.get(physicalId);
            Rect physicalCropRegion = physicalResult.get(CaptureResult.SCALER_CROP_REGION);
            Float physicalFocalLength = physicalResult.get(CaptureResult.LENS_FOCAL_LENGTH);
            Float physicalZoomRatio = physicalResult.get(CaptureResult.CONTROL_ZOOM_RATIO);
            Rect physicalActiveArraySize = physicalStaticInfo.getActiveArraySizeChecked();
            SizeF physicalSensorSize = mStaticInfo.getValueFromKeyNonNull(
                    CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);

            double physicalFov = 2 * Math.toDegrees(Math.atan2(
                    physicalSensorSize.getWidth() * physicalCropRegion.width() /
                    (2 * physicalZoomRatio * physicalActiveArraySize.width()), physicalFocalLength));

            double maxPhysicalFov = 2 * Math.toDegrees(Math.atan2(physicalSensorSize.getWidth() / 2,
                    physicalFocalLength));
            double expectedPhysicalFov = Math.min(maxPhysicalFov, fov);

            if (VERBOSE) {
                Log.v(TAG, ""Logical camera Fov: "" + fov + "", maxPhyiscalFov: "" + maxPhysicalFov +
                        "", physicalFov: "" + physicalFov);
            }
            assertTrue(""Physical stream FOV (Field of view) should be greater or equal to""
                    + "" min(logical stream FOV, max physical stream FOV). Physical FOV: ""
                    + physicalFov + "" vs min("" + fov + "", "" + maxPhysicalFov,
                    physicalFov - expectedPhysicalFov > -FOV_THRESHOLD);
        }
    }

    /**
     * Test physical camera YUV streaming within a particular logical camera.
     *
     * Use 2 YUV streams with PREVIEW or smaller size.
     */
    private void testBasicPhysicalStreamingForCamera(String logicalCameraId,
            List<String> physicalCameraIds, Size previewSize) throws Exception {
        List<OutputConfiguration> outputConfigs = new ArrayList<>();
        List<ImageReader> imageReaders = new ArrayList<>();

        // Add 1 logical YUV stream
        ImageReader logicalTarget = CameraTestUtils.makeImageReader(previewSize,
                ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,
                new ImageDropperListener(), mHandler);
        imageReaders.add(logicalTarget);
        outputConfigs.add(new OutputConfiguration(logicalTarget.getSurface()));

        // Add physical YUV streams
        if (physicalCameraIds.size() != 2) {
            throw new IllegalArgumentException(""phyiscalCameraIds must contain 2 camera ids"");
        }
        List<ImageReader> physicalTargets = new ArrayList<>();
        for (String physicalCameraId : physicalCameraIds) {
            ImageReader physicalTarget = CameraTestUtils.makeImageReader(previewSize,
                    ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,
                    new ImageDropperListener(), mHandler);
            OutputConfiguration config = new OutputConfiguration(physicalTarget.getSurface());
            config.setPhysicalCameraId(physicalCameraId);
            outputConfigs.add(config);
            physicalTargets.add(physicalTarget);
        }

        SessionConfigSupport sessionConfigSupport = isSessionConfigSupported(
                mCamera, mHandler, outputConfigs, /*inputConfig*/ null,
                SessionConfiguration.SESSION_REGULAR, false/*defaultSupport*/);
        assertTrue(""Session configuration query for logical camera failed with error"",
                !sessionConfigSupport.error);
        if (!sessionConfigSupport.callSupported) {
            return;
        }

        mSessionListener = new BlockingSessionCallback();
        mSessionWaiter = mSessionListener.getStateWaiter();
        mSession = configureCameraSessionWithConfig(mCamera, outputConfigs,
                mSessionListener, mHandler);
        if (!sessionConfigSupport.configSupported) {
            mSessionWaiter.waitForState(BlockingSessionCallback.SESSION_CONFIGURE_FAILED,
                    SESSION_CONFIGURE_TIMEOUT_MS);
            return;
        }

        // Stream logical YUV stream and note down the FPS
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        requestBuilder.addTarget(logicalTarget.getSurface());

        SimpleCaptureCallback simpleResultListener =
                new SimpleCaptureCallback();
        StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        final long minFrameDuration = config.getOutputMinFrameDuration(
                ImageFormat.YUV_420_888, previewSize);
        if (minFrameDuration > 0) {
            Range<Integer> targetRange = getSuitableFpsRangeForDuration(logicalCameraId,
                    minFrameDuration);
            requestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, targetRange);
        }
        mSession.setRepeatingRequest(requestBuilder.build(),
                simpleResultListener, mHandler);

        // Converge AE
        waitForAeStable(simpleResultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

        if (mStaticInfo.isAeLockSupported()) {
            // Lock AE if supported.
            requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);
            mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,
                    mHandler);
            waitForResultValue(simpleResultListener, CaptureResult.CONTROL_AE_STATE,
                    CaptureResult.CONTROL_AE_STATE_LOCKED, NUM_RESULTS_WAIT_TIMEOUT);
        }

        // Verify results
        CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,
                mStaticInfo, mAllStaticInfo, null/*requestedPhysicalIds*/,
                requestBuilder, NUM_FRAMES_CHECKED);

        // Collect timestamps for one logical stream only.
        long prevTimestamp = -1;
        long[] logicalTimestamps = new long[NUM_FRAMES_CHECKED];
        for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {
            TotalCaptureResult totalCaptureResult =
                    simpleResultListener.getTotalCaptureResult(
                    CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);
            logicalTimestamps[i] = totalCaptureResult.get(CaptureResult.SENSOR_TIMESTAMP);
        }

        double logicalAvgDurationMs = (logicalTimestamps[NUM_FRAMES_CHECKED-1] -
                logicalTimestamps[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));

        // Request one logical stream and one physical stream
        simpleResultListener = new SimpleCaptureCallback();
        requestBuilder.addTarget(physicalTargets.get(1).getSurface());
        mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,
                mHandler);

        // Verify results for physical streams request.
        CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,
                mStaticInfo, mAllStaticInfo, physicalCameraIds.subList(1, 2), requestBuilder,
                NUM_FRAMES_CHECKED);


        // Start requesting on both logical and physical streams
        SimpleCaptureCallback simpleResultListenerDual =
                new SimpleCaptureCallback();
        for (ImageReader physicalTarget : physicalTargets) {
            requestBuilder.addTarget(physicalTarget.getSurface());
        }
        mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListenerDual,
                mHandler);

        // Verify results for physical streams request.
        CaptureResultTest.validateCaptureResult(mCollector, simpleResultListenerDual,
                mStaticInfo, mAllStaticInfo, physicalCameraIds, requestBuilder,
                NUM_FRAMES_CHECKED);

        // Acquire the timestamps of the physical camera.
        long[] logicalTimestamps2 = new long[NUM_FRAMES_CHECKED];
        long [][] physicalTimestamps = new long[physicalTargets.size()][];
        for (int i = 0; i < physicalTargets.size(); i++) {
            physicalTimestamps[i] = new long[NUM_FRAMES_CHECKED];
        }
        for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {
            TotalCaptureResult totalCaptureResultDual =
                    simpleResultListenerDual.getTotalCaptureResult(
                    CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);
            logicalTimestamps2[i] = totalCaptureResultDual.get(CaptureResult.SENSOR_TIMESTAMP);

            int index = 0;
            Map<String, CaptureResult> physicalResultsDual =
                    totalCaptureResultDual.getPhysicalCameraResults();
            for (String physicalId : physicalCameraIds) {
                 if (physicalResultsDual.containsKey(physicalId)) {
                     physicalTimestamps[index][i] = physicalResultsDual.get(physicalId).get(
                             CaptureResult.SENSOR_TIMESTAMP);
                 } else {
                     physicalTimestamps[index][i] = -1;
                 }
                 index++;
            }
        }

        // Check both logical and physical streams' crop region, and make sure their FOVs
        // are similar.
        TotalCaptureResult totalCaptureResult =
                simpleResultListenerDual.getTotalCaptureResult(
                CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);
        validatePhysicalCamerasFov(totalCaptureResult, physicalCameraIds);

        // Check timestamp monolithity for individual camera and across cameras
        for (int i = 0; i < NUM_FRAMES_CHECKED-1; i++) {
            assertTrue(""Logical camera timestamp must monolithically increase"",
                    logicalTimestamps2[i] < logicalTimestamps2[i+1]);
        }
        for (int i = 0; i < physicalCameraIds.size(); i++) {
            for (int j = 0 ; j < NUM_FRAMES_CHECKED-1; j++) {
                if (physicalTimestamps[i][j] != -1 && physicalTimestamps[i][j+1] != -1) {
                    assertTrue(""Physical camera timestamp must monolithically increase"",
                            physicalTimestamps[i][j] < physicalTimestamps[i][j+1]);
                }
                if (j > 0 && physicalTimestamps[i][j] != -1) {
                    assertTrue(""Physical camera's timestamp N must be greater than logical "" +
                            ""camera's timestamp N-1"",
                            physicalTimestamps[i][j] > logicalTimestamps[j-1]);
                }
                if (physicalTimestamps[i][j] != -1) {
                    assertTrue(""Physical camera's timestamp N must be less than logical camera's "" +
                            ""timestamp N+1"", physicalTimestamps[i][j] > logicalTimestamps[j+1]);
                }
            }
        }

        double logicalAvgDurationMs2 = (logicalTimestamps2[NUM_FRAMES_CHECKED-1] -
                logicalTimestamps2[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));
        // Check CALIBRATED synchronization between physical cameras
        Integer syncType = mStaticInfo.getCharacteristics().get(
                CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE);
        double fpsRatio = (logicalAvgDurationMs2 - logicalAvgDurationMs)/logicalAvgDurationMs;
        if (syncType == CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED) {
            // Check framerate doesn't slow down with physical streams
            mCollector.expectTrue(
                    ""The average frame duration with concurrent physical streams is"" +
                    logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +
                    "" ms for logical streams only"", fpsRatio <= FRAME_DURATION_THRESHOLD);

            long maxTimestampDelta = 0;
            for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {
                long delta = Math.abs(physicalTimestamps[0][i] - physicalTimestamps[1][i]);
                if (delta > maxTimestampDelta) {
                    maxTimestampDelta = delta;
                }
            }

            Log.i(TAG, ""Maximum difference between physical camera timestamps: ""
                    + maxTimestampDelta);

            // The maximum timestamp difference should not be larger than the threshold.
            mCollector.expectTrue(
                    ""The maximum timestamp deltas between the physical cameras ""
                    + maxTimestampDelta + "" is larger than "" + MAX_TIMESTAMP_DIFFERENCE_THRESHOLD,
                    maxTimestampDelta <= MAX_TIMESTAMP_DIFFERENCE_THRESHOLD);
        } else {
            // Do not enforce fps check for APPROXIMATE synced device.
            if (fpsRatio > FRAME_DURATION_THRESHOLD) {
                Log.w(TAG, ""The average frame duration with concurrent physical streams is"" +
                        logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +
                        "" ms for logical streams only"");
            }
        }

        if (VERBOSE) {
            while (simpleResultListenerDual.hasMoreFailures()) {
                ArrayList<CaptureFailure> failures =
                    simpleResultListenerDual.getCaptureFailures(/*maxNumFailures*/ 1);
                for (CaptureFailure failure : failures) {
                    String physicalCameraId = failure.getPhysicalCameraId();
                    if (physicalCameraId != null) {
                        Log.v(TAG, ""Capture result failure for physical camera id: "" +
                                physicalCameraId);
                    }
                }
            }
        }

        // Stop preview
        if (mSession != null) {
            mSession.close();
        }
    }

    /**
     * The CDD defines a handheld device as one that has a battery and a screen size between
     * 2.5 and 8 inches.
     */
    private boolean isHandheldDevice() throws Exception {
        double screenInches = getScreenSizeInInches();
        return deviceHasBattery() && screenInches >= 2.5 && screenInches <= 8.0;
    }

    private boolean deviceHasBattery() {
        final Intent batteryInfo = mContext.registerReceiver(null,
                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
        return batteryInfo != null && batteryInfo.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);
    }

    private double getScreenSizeInInches() {
        DisplayMetrics dm = new DisplayMetrics();
        mWindowManager.getDefaultDisplay().getMetrics(dm);
        double widthInInchesSquared = Math.pow(dm.widthPixels/dm.xdpi,2);
        double heightInInchesSquared = Math.pow(dm.heightPixels/dm.ydpi,2);
        return Math.sqrt(widthInInchesSquared + heightInInchesSquared);
    }
}"	""	""	""	""	""
"212:651746) 7.5.4  . Camera API Behavior"	"7.5.4"	"H-1-1"	""	"android.hardware.camera2.cts.LogicalCameraDeviceTest"	"testActivePhysicalId"	"CtsCameraTestCases"	""	"7.5.4/H-1-1"	""">7.5.4/H-1-1] MUST have normal field of view (FOV) by default and it MUST be between 50 and 90 degrees. Handheld device implementations: [<a href=""#7_6_memory_and_storage"""""	""	"re_tag:50&90&degrees"	""	""	""	"re_tag:50&90&degrees"	""	""	""	"/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/LogicalCameraDeviceTest.java"	""	"public void testActivePhysicalId() throws Exception {
        final int AVAILABILITY_TIMEOUT_MS = 10;
        final LinkedBlockingQueue<Pair<String, String>> unavailablePhysicalCamEventQueue =
                new LinkedBlockingQueue<>();
        CameraManager.AvailabilityCallback ac = new CameraManager.AvailabilityCallback() {
             @Override
            public void onPhysicalCameraUnavailable(String cameraId, String physicalCameraId) {
                unavailablePhysicalCamEventQueue.offer(new Pair<>(cameraId, physicalCameraId));
            }
        };

        mCameraManager.registerAvailabilityCallback(ac, mHandler);
        Set<Pair<String, String>> unavailablePhysicalCameras = new HashSet<Pair<String, String>>();
        Pair<String, String> candidatePhysicalIds =
                unavailablePhysicalCamEventQueue.poll(AVAILABILITY_TIMEOUT_MS,
                java.util.concurrent.TimeUnit.MILLISECONDS);
        while (candidatePhysicalIds != null) {
            unavailablePhysicalCameras.add(candidatePhysicalIds);
            candidatePhysicalIds =
                unavailablePhysicalCamEventQueue.poll(AVAILABILITY_TIMEOUT_MS,
                java.util.concurrent.TimeUnit.MILLISECONDS);
        }
        mCameraManager.unregisterAvailabilityCallback(ac);

        for (String id : mCameraIdsUnderTest) {
            try {
                Log.i(TAG, ""Testing Camera "" + id);

                StaticMetadata staticInfo = mAllStaticInfo.get(id);
                if (!staticInfo.isColorOutputSupported()) {
                    Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");
                    continue;
                }

                if (!staticInfo.isLogicalMultiCamera()) {
                    Log.i(TAG, ""Camera "" + id + "" is not a logical multi-camera, skipping"");
                    continue;
                }

                if (!staticInfo.isActivePhysicalCameraIdSupported()) {
                    continue;
                }

                final Set<String> physicalIds =
                        staticInfo.getCharacteristics().getPhysicalCameraIds();
                openDevice(id);
                Size previewSz =
                        getMaxPreviewSize(mCamera.getId(), mCameraManager,
                        getPreviewSizeBound(mWindowManager, PREVIEW_SIZE_BOUND));

                String storedActiveId = null;
                for (int template : sTemplates) {
                    try {
                        CaptureRequest.Builder requestBuilder =
                                mCamera.createCaptureRequest(template);
                        SimpleCaptureCallback listener = new SimpleCaptureCallback();
                        startPreview(requestBuilder, previewSz, listener);
                        waitForSettingsApplied(listener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

                        CaptureResult result = listener.getCaptureResult(WAIT_FOR_RESULT_TIMEOUT_MS);
                        String activePhysicalId = result.get(
                                CaptureResult.LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID);

                        assertNotNull(""activePhysicalId must not be null"", activePhysicalId);
                        if (storedActiveId == null) {
                            storedActiveId = activePhysicalId;
                            assertTrue(
                                  ""Camera device reported invalid activePhysicalId: "" +
                                  activePhysicalId, physicalIds.contains(activePhysicalId));
                        } else {
                            assertTrue(
                                  ""Camera device reported different activePhysicalId "" +
                                  activePhysicalId + "" vs "" + storedActiveId +
                                  "" for different capture templates"",
                                  storedActiveId.equals(activePhysicalId));
                        }
                    } catch (IllegalArgumentException e) {
                        if (template == CameraDevice.TEMPLATE_MANUAL &&
                                !staticInfo.isCapabilitySupported(CameraCharacteristics.
                                REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                            // OK
                        } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG &&
                                !staticInfo.isCapabilitySupported(CameraCharacteristics.
                                REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)) {
                            // OK.
                        } else {
                            throw e; // rethrow
                        }
                    }
                }

                // Query unavailable physical cameras, and make sure the active physical id
                // isn't an unavailable physical camera.
                for (Pair<String, String> unavailPhysicalCamera: unavailablePhysicalCameras) {
                    assertFalse(unavailPhysicalCamera.first.equals(id) &&
                           unavailPhysicalCamera.second.equals(storedActiveId));
                }
            } finally {
                closeDevice();
            }
        }

    }

    /**
     * Test that for logical multi-camera of a Handheld device, the default FOV is
     * between 50 and 90 degrees for all capture templates.
     */"	""	""	""	""	""
"212:651746) 7.5.4  . Camera API Behavior"	"7.5.4"	"H-1-1"	""	"android.hardware.camera2.cts.LogicalCameraDeviceTest"	"testDefaultFov"	"CtsCameraTestCases"	""	"7.5.4/H-1-1"	""">7.5.4/H-1-1] MUST have normal field of view (FOV) by default and it MUST be between 50 and 90 degrees. Handheld device implementations: [<a href=""#7_6_memory_and_storage"""""	""	"re_tag:50&90&degrees"	""	""	""	"re_tag:50&90&degrees"	""	""	""	"/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/LogicalCameraDeviceTest.java"	""	"@CddTest(requirement=""7.5.4/C-1-1"")
    public void testDefaultFov() throws Exception {
        final double MIN_FOV = 50;
        final double MAX_FOV = 90;
        if (!isHandheldDevice()) {
            return;
        }
        for (String id : mCameraIdsUnderTest) {
            try {
                Log.i(TAG, ""Testing Camera "" + id);

                StaticMetadata staticInfo = mAllStaticInfo.get(id);
                if (!staticInfo.isColorOutputSupported()) {
                    Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");
                    continue;
                }

                if (!staticInfo.isLogicalMultiCamera()) {
                    Log.i(TAG, ""Camera "" + id + "" is not a logical multi-camera, skipping"");
                    continue;
                }

                SizeF physicalSize = staticInfo.getCharacteristics().get(
                        CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);
                double physicalDiag = Math.sqrt(Math.pow(physicalSize.getWidth(), 2)
                        + Math.pow(physicalSize.getHeight(), 2));
                Rect activeArraySize = staticInfo.getCharacteristics().get(
                        CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);

                openDevice(id);
                for (int template : sTemplates) {
                    try {
                        CaptureRequest.Builder requestBuilder =
                                mCamera.createCaptureRequest(template);
                        Float requestFocalLength = requestBuilder.get(
                                CaptureRequest.LENS_FOCAL_LENGTH);
                        assertNotNull(""LENS_FOCAL_LENGTH must not be null"", requestFocalLength);

                        Float requestZoomRatio = requestBuilder.get(
                                CaptureRequest.CONTROL_ZOOM_RATIO);
                        assertNotNull(""CONTROL_ZOOM_RATIO must not be null"", requestZoomRatio);
                        Rect requestCropRegion = requestBuilder.get(
                                CaptureRequest.SCALER_CROP_REGION);
                        assertNotNull(""SCALER_CROP_REGION must not be null"", requestCropRegion);
                        float totalZoomRatio = Math.min(
                                1.0f * activeArraySize.width() / requestCropRegion.width(),
                                1.0f * activeArraySize.height() / requestCropRegion.height()) *
                                requestZoomRatio;

                        double fov = 2 *
                                Math.toDegrees(Math.atan2(physicalDiag/(2 * totalZoomRatio),
                                requestFocalLength));

                        Log.v(TAG, ""Camera "" +  id + "" template "" + template +
                                ""'s default FOV is "" + fov);
                        mCollector.expectInRange(""Camera "" +  id + "" template "" + template +
                                ""'s default FOV must fall between [50, 90] degrees"",
                                fov, MIN_FOV, MAX_FOV);
                    } catch (IllegalArgumentException e) {
                        if (template == CameraDevice.TEMPLATE_MANUAL &&
                                !staticInfo.isCapabilitySupported(CameraCharacteristics.
                                REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                            // OK
                        } else if (template == CameraDevice.TEMPLATE_ZERO_SHUTTER_LAG &&
                                !staticInfo.isCapabilitySupported(CameraCharacteristics.
                                REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING)) {
                            // OK.
                        } else {
                            throw e; // rethrow
                        }
                    }
                }
            } finally {
                closeDevice();
            }
        }
    }

    /**
     * Find a common preview size that's supported by both the logical camera and
     * two of the underlying physical cameras.
     */
    private Size findCommonPreviewSize(String cameraId,
            List<String> dualPhysicalCameraIds) throws Exception {

        Set<String> physicalCameraIds =
                mStaticInfo.getCharacteristics().getPhysicalCameraIds();
        assertTrue(""Logical camera must contain at least 2 physical camera ids"",
                physicalCameraIds.size() >= 2);

        List<Size> previewSizes = getSupportedPreviewSizes(
                cameraId, mCameraManager, PREVIEW_SIZE_BOUND);
        HashMap<String, List<Size>> physicalPreviewSizesMap = new HashMap<String, List<Size>>();
        HashMap<String, StreamConfigurationMap> physicalConfigs = new HashMap<>();
        for (String physicalCameraId : physicalCameraIds) {
            CameraCharacteristics properties =
                    mCameraManager.getCameraCharacteristics(physicalCameraId);
            assertNotNull(""Can't get camera characteristics!"", properties);
            if (!mAllStaticInfo.get(physicalCameraId).isColorOutputSupported()) {
                // No color output support, skip.
                continue;
            }
            StreamConfigurationMap configMap =
                properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            physicalConfigs.put(physicalCameraId, configMap);
            physicalPreviewSizesMap.put(physicalCameraId,
                    getSupportedPreviewSizes(physicalCameraId, mCameraManager, PREVIEW_SIZE_BOUND));
        }

        // Find display size from window service.
        Context context = mActivityRule.getActivity().getApplicationContext();
        WindowManager windowManager =
                (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        Display display = windowManager.getDefaultDisplay();

        int displayWidth = display.getWidth();
        int displayHeight = display.getHeight();

        if (displayHeight > displayWidth) {
            displayHeight = displayWidth;
            displayWidth = display.getHeight();
        }

        StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        for (Size previewSize : previewSizes) {
            dualPhysicalCameraIds.clear();
            // Skip preview sizes larger than screen size
            if (previewSize.getWidth() > displayWidth ||
                    previewSize.getHeight() > displayHeight) {
                continue;
            }

            final long minFrameDuration = config.getOutputMinFrameDuration(
                   ImageFormat.YUV_420_888, previewSize);

            ArrayList<String> supportedPhysicalCameras = new ArrayList<String>();
            for (String physicalCameraId : physicalCameraIds) {
                List<Size> physicalPreviewSizes = physicalPreviewSizesMap.get(physicalCameraId);
                if (physicalPreviewSizes != null && physicalPreviewSizes.contains(previewSize)) {
                   long minDurationPhysical =
                           physicalConfigs.get(physicalCameraId).getOutputMinFrameDuration(
                           ImageFormat.YUV_420_888, previewSize);
                   if (minDurationPhysical <= minFrameDuration) {
                        dualPhysicalCameraIds.add(physicalCameraId);
                        if (dualPhysicalCameraIds.size() == 2) {
                            return previewSize;
                        }
                   }
                }
            }
        }
        return null;
    }

    /**
     * Validate that physical cameras are not cropping too much.
     *
     * This is to make sure physical processed streams have at least the same field of view as
     * the logical stream, or the maximum field of view of the physical camera, whichever is
     * smaller.
     *
     * Note that the FOV is calculated in the directio of sensor width.
     */
    private void validatePhysicalCamerasFov(TotalCaptureResult totalCaptureResult,
            List<String> physicalCameraIds) {
        Rect cropRegion = totalCaptureResult.get(CaptureResult.SCALER_CROP_REGION);
        Float focalLength = totalCaptureResult.get(CaptureResult.LENS_FOCAL_LENGTH);
        Float zoomRatio = totalCaptureResult.get(CaptureResult.CONTROL_ZOOM_RATIO);
        Rect activeArraySize = mStaticInfo.getActiveArraySizeChecked();
        SizeF sensorSize = mStaticInfo.getValueFromKeyNonNull(
                CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);

        // Assume subject distance >> focal length, and subject distance >> camera baseline.
        double fov = 2 * Math.toDegrees(Math.atan2(sensorSize.getWidth() * cropRegion.width() /
                (2 * zoomRatio * activeArraySize.width()),  focalLength));

        Map<String, CaptureResult> physicalResultsDual =
                    totalCaptureResult.getPhysicalCameraResults();
        for (String physicalId : physicalCameraIds) {
            StaticMetadata physicalStaticInfo = mAllStaticInfo.get(physicalId);
            CaptureResult physicalResult = physicalResultsDual.get(physicalId);
            Rect physicalCropRegion = physicalResult.get(CaptureResult.SCALER_CROP_REGION);
            Float physicalFocalLength = physicalResult.get(CaptureResult.LENS_FOCAL_LENGTH);
            Float physicalZoomRatio = physicalResult.get(CaptureResult.CONTROL_ZOOM_RATIO);
            Rect physicalActiveArraySize = physicalStaticInfo.getActiveArraySizeChecked();
            SizeF physicalSensorSize = mStaticInfo.getValueFromKeyNonNull(
                    CameraCharacteristics.SENSOR_INFO_PHYSICAL_SIZE);

            double physicalFov = 2 * Math.toDegrees(Math.atan2(
                    physicalSensorSize.getWidth() * physicalCropRegion.width() /
                    (2 * physicalZoomRatio * physicalActiveArraySize.width()), physicalFocalLength));

            double maxPhysicalFov = 2 * Math.toDegrees(Math.atan2(physicalSensorSize.getWidth() / 2,
                    physicalFocalLength));
            double expectedPhysicalFov = Math.min(maxPhysicalFov, fov);

            if (VERBOSE) {
                Log.v(TAG, ""Logical camera Fov: "" + fov + "", maxPhyiscalFov: "" + maxPhysicalFov +
                        "", physicalFov: "" + physicalFov);
            }
            assertTrue(""Physical stream FOV (Field of view) should be greater or equal to""
                    + "" min(logical stream FOV, max physical stream FOV). Physical FOV: ""
                    + physicalFov + "" vs min("" + fov + "", "" + maxPhysicalFov,
                    physicalFov - expectedPhysicalFov > -FOV_THRESHOLD);
        }
    }

    /**
     * Test physical camera YUV streaming within a particular logical camera.
     *
     * Use 2 YUV streams with PREVIEW or smaller size.
     */
    private void testBasicPhysicalStreamingForCamera(String logicalCameraId,
            List<String> physicalCameraIds, Size previewSize) throws Exception {
        List<OutputConfiguration> outputConfigs = new ArrayList<>();
        List<ImageReader> imageReaders = new ArrayList<>();

        // Add 1 logical YUV stream
        ImageReader logicalTarget = CameraTestUtils.makeImageReader(previewSize,
                ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,
                new ImageDropperListener(), mHandler);
        imageReaders.add(logicalTarget);
        outputConfigs.add(new OutputConfiguration(logicalTarget.getSurface()));

        // Add physical YUV streams
        if (physicalCameraIds.size() != 2) {
            throw new IllegalArgumentException(""phyiscalCameraIds must contain 2 camera ids"");
        }
        List<ImageReader> physicalTargets = new ArrayList<>();
        for (String physicalCameraId : physicalCameraIds) {
            ImageReader physicalTarget = CameraTestUtils.makeImageReader(previewSize,
                    ImageFormat.YUV_420_888, MAX_IMAGE_COUNT,
                    new ImageDropperListener(), mHandler);
            OutputConfiguration config = new OutputConfiguration(physicalTarget.getSurface());
            config.setPhysicalCameraId(physicalCameraId);
            outputConfigs.add(config);
            physicalTargets.add(physicalTarget);
        }

        SessionConfigSupport sessionConfigSupport = isSessionConfigSupported(
                mCamera, mHandler, outputConfigs, /*inputConfig*/ null,
                SessionConfiguration.SESSION_REGULAR, false/*defaultSupport*/);
        assertTrue(""Session configuration query for logical camera failed with error"",
                !sessionConfigSupport.error);
        if (!sessionConfigSupport.callSupported) {
            return;
        }

        mSessionListener = new BlockingSessionCallback();
        mSessionWaiter = mSessionListener.getStateWaiter();
        mSession = configureCameraSessionWithConfig(mCamera, outputConfigs,
                mSessionListener, mHandler);
        if (!sessionConfigSupport.configSupported) {
            mSessionWaiter.waitForState(BlockingSessionCallback.SESSION_CONFIGURE_FAILED,
                    SESSION_CONFIGURE_TIMEOUT_MS);
            return;
        }

        // Stream logical YUV stream and note down the FPS
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        requestBuilder.addTarget(logicalTarget.getSurface());

        SimpleCaptureCallback simpleResultListener =
                new SimpleCaptureCallback();
        StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(
                CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        final long minFrameDuration = config.getOutputMinFrameDuration(
                ImageFormat.YUV_420_888, previewSize);
        if (minFrameDuration > 0) {
            Range<Integer> targetRange = getSuitableFpsRangeForDuration(logicalCameraId,
                    minFrameDuration);
            requestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, targetRange);
        }
        mSession.setRepeatingRequest(requestBuilder.build(),
                simpleResultListener, mHandler);

        // Converge AE
        waitForAeStable(simpleResultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY);

        if (mStaticInfo.isAeLockSupported()) {
            // Lock AE if supported.
            requestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);
            mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,
                    mHandler);
            waitForResultValue(simpleResultListener, CaptureResult.CONTROL_AE_STATE,
                    CaptureResult.CONTROL_AE_STATE_LOCKED, NUM_RESULTS_WAIT_TIMEOUT);
        }

        // Verify results
        CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,
                mStaticInfo, mAllStaticInfo, null/*requestedPhysicalIds*/,
                requestBuilder, NUM_FRAMES_CHECKED);

        // Collect timestamps for one logical stream only.
        long prevTimestamp = -1;
        long[] logicalTimestamps = new long[NUM_FRAMES_CHECKED];
        for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {
            TotalCaptureResult totalCaptureResult =
                    simpleResultListener.getTotalCaptureResult(
                    CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);
            logicalTimestamps[i] = totalCaptureResult.get(CaptureResult.SENSOR_TIMESTAMP);
        }

        double logicalAvgDurationMs = (logicalTimestamps[NUM_FRAMES_CHECKED-1] -
                logicalTimestamps[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));

        // Request one logical stream and one physical stream
        simpleResultListener = new SimpleCaptureCallback();
        requestBuilder.addTarget(physicalTargets.get(1).getSurface());
        mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListener,
                mHandler);

        // Verify results for physical streams request.
        CaptureResultTest.validateCaptureResult(mCollector, simpleResultListener,
                mStaticInfo, mAllStaticInfo, physicalCameraIds.subList(1, 2), requestBuilder,
                NUM_FRAMES_CHECKED);


        // Start requesting on both logical and physical streams
        SimpleCaptureCallback simpleResultListenerDual =
                new SimpleCaptureCallback();
        for (ImageReader physicalTarget : physicalTargets) {
            requestBuilder.addTarget(physicalTarget.getSurface());
        }
        mSession.setRepeatingRequest(requestBuilder.build(), simpleResultListenerDual,
                mHandler);

        // Verify results for physical streams request.
        CaptureResultTest.validateCaptureResult(mCollector, simpleResultListenerDual,
                mStaticInfo, mAllStaticInfo, physicalCameraIds, requestBuilder,
                NUM_FRAMES_CHECKED);

        // Acquire the timestamps of the physical camera.
        long[] logicalTimestamps2 = new long[NUM_FRAMES_CHECKED];
        long [][] physicalTimestamps = new long[physicalTargets.size()][];
        for (int i = 0; i < physicalTargets.size(); i++) {
            physicalTimestamps[i] = new long[NUM_FRAMES_CHECKED];
        }
        for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {
            TotalCaptureResult totalCaptureResultDual =
                    simpleResultListenerDual.getTotalCaptureResult(
                    CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);
            logicalTimestamps2[i] = totalCaptureResultDual.get(CaptureResult.SENSOR_TIMESTAMP);

            int index = 0;
            Map<String, CaptureResult> physicalResultsDual =
                    totalCaptureResultDual.getPhysicalCameraResults();
            for (String physicalId : physicalCameraIds) {
                 if (physicalResultsDual.containsKey(physicalId)) {
                     physicalTimestamps[index][i] = physicalResultsDual.get(physicalId).get(
                             CaptureResult.SENSOR_TIMESTAMP);
                 } else {
                     physicalTimestamps[index][i] = -1;
                 }
                 index++;
            }
        }

        // Check both logical and physical streams' crop region, and make sure their FOVs
        // are similar.
        TotalCaptureResult totalCaptureResult =
                simpleResultListenerDual.getTotalCaptureResult(
                CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS);
        validatePhysicalCamerasFov(totalCaptureResult, physicalCameraIds);

        // Check timestamp monolithity for individual camera and across cameras
        for (int i = 0; i < NUM_FRAMES_CHECKED-1; i++) {
            assertTrue(""Logical camera timestamp must monolithically increase"",
                    logicalTimestamps2[i] < logicalTimestamps2[i+1]);
        }
        for (int i = 0; i < physicalCameraIds.size(); i++) {
            for (int j = 0 ; j < NUM_FRAMES_CHECKED-1; j++) {
                if (physicalTimestamps[i][j] != -1 && physicalTimestamps[i][j+1] != -1) {
                    assertTrue(""Physical camera timestamp must monolithically increase"",
                            physicalTimestamps[i][j] < physicalTimestamps[i][j+1]);
                }
                if (j > 0 && physicalTimestamps[i][j] != -1) {
                    assertTrue(""Physical camera's timestamp N must be greater than logical "" +
                            ""camera's timestamp N-1"",
                            physicalTimestamps[i][j] > logicalTimestamps[j-1]);
                }
                if (physicalTimestamps[i][j] != -1) {
                    assertTrue(""Physical camera's timestamp N must be less than logical camera's "" +
                            ""timestamp N+1"", physicalTimestamps[i][j] > logicalTimestamps[j+1]);
                }
            }
        }

        double logicalAvgDurationMs2 = (logicalTimestamps2[NUM_FRAMES_CHECKED-1] -
                logicalTimestamps2[0])/(NS_PER_MS*(NUM_FRAMES_CHECKED-1));
        // Check CALIBRATED synchronization between physical cameras
        Integer syncType = mStaticInfo.getCharacteristics().get(
                CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE);
        double fpsRatio = (logicalAvgDurationMs2 - logicalAvgDurationMs)/logicalAvgDurationMs;
        if (syncType == CameraCharacteristics.LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED) {
            // Check framerate doesn't slow down with physical streams
            mCollector.expectTrue(
                    ""The average frame duration with concurrent physical streams is"" +
                    logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +
                    "" ms for logical streams only"", fpsRatio <= FRAME_DURATION_THRESHOLD);

            long maxTimestampDelta = 0;
            for (int i = 0; i < NUM_FRAMES_CHECKED; i++) {
                long delta = Math.abs(physicalTimestamps[0][i] - physicalTimestamps[1][i]);
                if (delta > maxTimestampDelta) {
                    maxTimestampDelta = delta;
                }
            }

            Log.i(TAG, ""Maximum difference between physical camera timestamps: ""
                    + maxTimestampDelta);

            // The maximum timestamp difference should not be larger than the threshold.
            mCollector.expectTrue(
                    ""The maximum timestamp deltas between the physical cameras ""
                    + maxTimestampDelta + "" is larger than "" + MAX_TIMESTAMP_DIFFERENCE_THRESHOLD,
                    maxTimestampDelta <= MAX_TIMESTAMP_DIFFERENCE_THRESHOLD);
        } else {
            // Do not enforce fps check for APPROXIMATE synced device.
            if (fpsRatio > FRAME_DURATION_THRESHOLD) {
                Log.w(TAG, ""The average frame duration with concurrent physical streams is"" +
                        logicalAvgDurationMs2 + "" ms vs "" + logicalAvgDurationMs +
                        "" ms for logical streams only"");
            }
        }

        if (VERBOSE) {
            while (simpleResultListenerDual.hasMoreFailures()) {
                ArrayList<CaptureFailure> failures =
                    simpleResultListenerDual.getCaptureFailures(/*maxNumFailures*/ 1);
                for (CaptureFailure failure : failures) {
                    String physicalCameraId = failure.getPhysicalCameraId();
                    if (physicalCameraId != null) {
                        Log.v(TAG, ""Capture result failure for physical camera id: "" +
                                physicalCameraId);
                    }
                }
            }
        }

        // Stop preview
        if (mSession != null) {
            mSession.close();
        }
    }

    /**
     * The CDD defines a handheld device as one that has a battery and a screen size between
     * 2.5 and 8 inches.
     */
    private boolean isHandheldDevice() throws Exception {
        double screenInches = getScreenSizeInInches();
        return deviceHasBattery() && screenInches >= 2.5 && screenInches <= 8.0;
    }

    private boolean deviceHasBattery() {
        final Intent batteryInfo = mContext.registerReceiver(null,
                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
        return batteryInfo != null && batteryInfo.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);
    }

    private double getScreenSizeInInches() {
        DisplayMetrics dm = new DisplayMetrics();
        mWindowManager.getDefaultDisplay().getMetrics(dm);
        double widthInInchesSquared = Math.pow(dm.widthPixels/dm.xdpi,2);
        double heightInInchesSquared = Math.pow(dm.heightPixels/dm.ydpi,2);
        return Math.sqrt(widthInInchesSquared + heightInInchesSquared);
    }
}"	""	""	""	""	""
