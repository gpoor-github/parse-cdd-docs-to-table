"Section"	"section_id"	"req_id"	"Test Availability"	"class_def"	"method"	"module"	"method_text"	"full_key"	"requirement"	"key_as_number"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"matched_terms"	"search_roots"	"qualified_method"	"max_matches"	"file_name"	"matched_files"	"methods_string"	"urls"	"protected"	"Area"	"Shortened"	"Test Level"
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.content.cts.ImageCaptureUriExtraToClipDataTest"	"testUriExtraOutputMigratedToClipData_imageCaptureIntent"	"CtsContentTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ImageCaptureUriExtraToClipDataTest.java"	""	"public void testUriExtraOutputMigratedToClipData_imageCaptureIntent() {         startActivityWithAction(MediaStore.ACTION_IMAGE_CAPTURE);         waitForFileReady();         assertFileContents();     }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.content.cts.ImageCaptureUriExtraToClipDataTest"	"testUriExtraOutputMigratedToClipData_imageCaptureSecureIntent"	"CtsContentTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ImageCaptureUriExtraToClipDataTest.java"	""	"public void testUriExtraOutputMigratedToClipData_imageCaptureSecureIntent() {         startActivityWithAction(MediaStore.ACTION_IMAGE_CAPTURE_SECURE);         waitForFileReady();         assertFileContents();     }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.content.cts.ImageCaptureUriExtraToClipDataTest"	"testUriExtraOutputMigratedToClipData_videoCaptureIntent"	"CtsContentTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	""	""	"public void testUriExtraOutputMigratedToClipData_videoCaptureIntent() {         startActivityWithAction(MediaStore.ACTION_VIDEO_CAPTURE);         waitForFileReady();         assertFileContents();     }      private void startActivityWithAction(String action) {         Intent intent = new Intent(action);         intent.setComponent(new ComponentName(""android.content.cts"",                         ""android.content.cts.ImageCaptureActivity""));         intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(mTestFile));         intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         getContext().startActivity(intent);     }      private void waitForFileReady() {         try {             assertTrue(mFileReadySemaphore.tryAcquire(5, TimeUnit.SECONDS));         } catch (InterruptedException e) {             fail(e.toString());         }     }      private void assertFileContents() {         char[] buffer = new char[TEST_INPUT.length()];         try {             FileReader reader = new FileReader(mTestFile);             reader.read(buffer);             reader.close();         } catch (IOException e) {             // Problem             fail(e.toString());         }         String fileContents = new String(buffer);         assertEquals(TEST_INPUT, fileContents);     } }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.app.cts.WallpaperManagerTest"	"invokeOnColorsChangedListenerTest_systemOnly"	"CtsAndroidAppTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/WallpaperManagerTest.java"	""	"public void invokeOnColorsChangedListenerTest_systemOnly() {         int both = WallpaperManager.FLAG_LOCK | WallpaperManager.FLAG_SYSTEM;         // Expect both since the first step is to migrate the current wallpaper         // to the lock screen.         verifyColorListenerInvoked(WallpaperManager.FLAG_SYSTEM, both);     }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.content.cts.ContextTest"	"testMoveSharedPreferencesFrom"	"CtsContentTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	"public void testMoveSharedPreferencesFrom() throws Exception {         final Context deviceContext = mContext.createDeviceProtectedStorageContext();          mContext.getSharedPreferences(""test"", Context.MODE_PRIVATE).edit().putInt(""answer"", 42)                 .commit();          // Verify that we can migrate         assertTrue(deviceContext.moveSharedPreferencesFrom(mContext, ""test""));         assertEquals(0, mContext.getSharedPreferences(""test"", Context.MODE_PRIVATE)                 .getInt(""answer"", 0));         assertEquals(42, deviceContext.getSharedPreferences(""test"", Context.MODE_PRIVATE)                 .getInt(""answer"", 0));          // Trying to migrate again when already done is a no-op         assertTrue(deviceContext.moveSharedPreferencesFrom(mContext, ""test""));         assertEquals(0, mContext.getSharedPreferences(""test"", Context.MODE_PRIVATE)                 .getInt(""answer"", 0));         assertEquals(42, deviceContext.getSharedPreferences(""test"", Context.MODE_PRIVATE)                 .getInt(""answer"", 0));          // Add a new value and verify that we can migrate back         deviceContext.getSharedPreferences(""test"", Context.MODE_PRIVATE).edit()                 .putInt(""question"", 24).commit();          assertTrue(mContext.moveSharedPreferencesFrom(deviceContext, ""test""));         assertEquals(42, mContext.getSharedPreferences(""test"", Context.MODE_PRIVATE)                 .getInt(""answer"", 0));         assertEquals(24, mContext.getSharedPreferences(""test"", Context.MODE_PRIVATE)                 .getInt(""question"", 0));         assertEquals(0, deviceContext.getSharedPreferences(""test"", Context.MODE_PRIVATE)                 .getInt(""answer"", 0));         assertEquals(0, deviceContext.getSharedPreferences(""test"", Context.MODE_PRIVATE)                 .getInt(""question"", 0));     }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.content.cts.ContextTest"	"testMoveDatabaseFrom"	"CtsContentTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	"public void testMoveDatabaseFrom() throws Exception {         final Context deviceContext = mContext.createDeviceProtectedStorageContext();          SQLiteDatabase db = mContext.openOrCreateDatabase(""test.db"",                 Context.MODE_PRIVATE | Context.MODE_ENABLE_WRITE_AHEAD_LOGGING, null);         db.execSQL(""CREATE TABLE list(item TEXT);"");         db.execSQL(""INSERT INTO list VALUES ('cat')"");         db.execSQL(""INSERT INTO list VALUES ('dog')"");         db.close();          // Verify that we can migrate         assertTrue(deviceContext.moveDatabaseFrom(mContext, ""test.db""));         db = deviceContext.openOrCreateDatabase(""test.db"",                 Context.MODE_PRIVATE | Context.MODE_ENABLE_WRITE_AHEAD_LOGGING, null);         Cursor c = db.query(""list"", null, null, null, null, null, null);         assertEquals(2, c.getCount());         assertTrue(c.moveToFirst());         assertEquals(""cat"", c.getString(0));         assertTrue(c.moveToNext());         assertEquals(""dog"", c.getString(0));         c.close();         db.execSQL(""INSERT INTO list VALUES ('mouse')"");         db.close();          // Trying to migrate again when already done is a no-op         assertTrue(deviceContext.moveDatabaseFrom(mContext, ""test.db""));          // Verify that we can migrate back         assertTrue(mContext.moveDatabaseFrom(deviceContext, ""test.db""));         db = mContext.openOrCreateDatabase(""test.db"",                 Context.MODE_PRIVATE | Context.MODE_ENABLE_WRITE_AHEAD_LOGGING, null);         c = db.query(""list"", null, null, null, null, null, null);         assertEquals(3, c.getCount());         assertTrue(c.moveToFirst());         assertEquals(""cat"", c.getString(0));         assertTrue(c.moveToNext());         assertEquals(""dog"", c.getString(0));         assertTrue(c.moveToNext());         assertEquals(""mouse"", c.getString(0));         c.close();         db.close();     }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.content.cts.ReadableUriExtraToClipDataTest"	"testUriExtraStreamMigratedToClipData_sendIntent"	"CtsContentTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ReadableUriExtraToClipDataTest.java"	""	"public void testUriExtraStreamMigratedToClipData_sendIntent() {         Intent intent = new Intent(Intent.ACTION_SEND);         intent.setComponent(new ComponentName(getContext(), ReadableFileReceiverActivity.class));         intent.putExtra(Intent.EXTRA_STREAM, mTestFileUris.get(0));         intent.setType(""*/*"");         intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);          getContext().startActivity(intent);          waitForConfirmationReadSuccess();     }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.content.cts.ReadableUriExtraToClipDataTest"	"testUriExtraStreamMigratedToClipData_sendMultipleIntent"	"CtsContentTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ReadableUriExtraToClipDataTest.java"	""	"public void testUriExtraStreamMigratedToClipData_sendMultipleIntent() {         Intent intent = new Intent(Intent.ACTION_SEND_MULTIPLE);         intent.setComponent(new ComponentName(getContext(), ReadableFileReceiverActivity.class));         intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, mTestFileUris);         intent.setType(""*/*"");         intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);          getContext().startActivity(intent);          waitForConfirmationReadSuccess();     }      private void writeTestInputToFile(File file) {         try {             FileWriter writer = new FileWriter(file);             writer.write(TEST_INPUT);             writer.flush();             writer.close();         } catch (IOException e) {             fail(e.toString());             return;         }     }      private void waitForConfirmationReadSuccess() {         try {             assertTrue(mReadSuccessSemaphore.tryAcquire(5, TimeUnit.SECONDS));         } catch (InterruptedException e) {             fail(e.toString());         }     } }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.media.cts.AudioManagerTest"	"isMicrophoneMute"	"CtsMediaTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/media/src/android/media/cts/AudioManagerTest.java"	""	"public void test/*  *.  */  package android.media.cts;  import static android.media.AudioManager.ADJUST_LOWER; import static android.media.AudioManager.ADJUST_RAISE; import static android.media.AudioManager.ADJUST_SAME; import static android.media.AudioManager.MODE_IN_CALL; import static android.media.AudioManager.MODE_IN_COMMUNICATION; import static android.media.AudioManager.MODE_NORMAL; import static android.media.AudioManager.MODE_RINGTONE; import static android.media.AudioManager.RINGER_MODE_NORMAL; import static android.media.AudioManager.RINGER_MODE_SILENT; import static android.media.AudioManager.RINGER_MODE_VIBRATE; import static android.media.AudioManager.STREAM_ACCESSIBILITY; import static android.media.AudioManager.STREAM_MUSIC; import static android.media.AudioManager.STREAM_RING; import static android.media.AudioManager.USE_DEFAULT_STREAM_TYPE; import static android.media.AudioManager.VIBRATE_SETTING_OFF; import static android.media.AudioManager.VIBRATE_SETTING_ON; import static android.media.AudioManager.VIBRATE_SETTING_ONLY_SILENT; import static android.media.AudioManager.VIBRATE_TYPE_NOTIFICATION; import static android.media.AudioManager.VIBRATE_TYPE_RINGER; import static android.provider.Settings.System.SOUND_EFFECTS_ENABLED;  import android.app.INotificationManager; import android.app.NotificationChannel; import android.app.NotificationManager; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.content.pm.PackageManager; import android.content.res.Resources; import android.media.AudioAttributes; import android.media.AudioDeviceInfo; import android.media.AudioManager; import android.media.MediaPlayer; import android.media.MicrophoneInfo; import android.os.ServiceManager; import android.os.Vibrator; import android.platform.test.annotations.AppModeFull; import android.provider.Settings; import android.provider.Settings.System; import android.test.InstrumentationTestCase; import android.text.TextUtils; import android.util.Log; import android.view.SoundEffectConstants;  import com.android.compatibility.common.util.CddTest; import com.android.compatibility.common.util.MediaUtils; import com.android.internal.annotations.GuardedBy;  import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.Map;  @NonMediaMainlineTest public class AudioManagerTest extends InstrumentationTestCase {     private final static String TAG = ""AudioManagerTest"";      private final static long ASYNC_TIMING_TOLERANCE_MS = 50;     private final static int MP3_TO_PLAY = R.raw.testmp3;     private final static long TIME_TO_PLAY = 2000;     private final static String APPOPS_OP_STR = ""android:write_settings"";     private AudioManager mAudioManager;     private NotificationManager mNm;     private boolean mHasVibrator;     private boolean mUseFixedVolume;     private boolean mIsTelevision;     private boolean mIsSingleVolume;     private boolean mSkipRingerTests;     // From N onwards, ringer mode adjustments that toggle DND are not allowed unless     // package has DND access. Many tests in this package toggle DND access in order     // to get device out of the DND state for the test to proceed correctly.     // But DND access is disabled completely on low ram devices,     // so completely skip those tests here.     // These tests are migrated to CTS verifier tests to ensure test coverage.     private Context mContext;     private int mOriginalRingerMode;     private Map<Integer, Integer> mOriginalStreamVolumes = new HashMap<>();     private NotificationManager.Policy mOriginalNotificationPolicy;     private int mOriginalZen;     private boolean mDoNotCheckUnmute;     private boolean mAppsBypassingDnd;      @Override     protected void setUp() throws Exception {         super.setUp();         mContext = getInstrumentation().getContext();         Utils.enableAppOps(mContext.getPackageName(), APPOPS_OP_STR, getInstrumentation());         mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);         Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);         mNm = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);         mAppsBypassingDnd = NotificationManager.getService().areChannelsBypassingDnd();         mHasVibrator = (vibrator != null) && vibrator.hasVibrator();         mUseFixedVolume = mContext.getResources().getBoolean(                 Resources.getSystem().getIdentifier(""config_useFixedVolume"", ""bool"", ""android""));         PackageManager packageManager = mContext.getPackageManager();         mIsTelevision = packageManager != null                 && (packageManager.hasSystemFeature(PackageManager.FEATURE_LEANBACK)                         || packageManager.hasSystemFeature(PackageManager.FEATURE_TELEVISION));         mIsSingleVolume = mContext.getResources().getBoolean(                 Resources.getSystem().getIdentifier(""config_single_volume"", ""bool"", ""android""));         mSkipRingerTests = mUseFixedVolume || mIsTelevision || mIsSingleVolume;          // Store the original volumes that that they can be recovered in tearDown().         final int[] streamTypes = {             AudioManager.STREAM_VOICE_CALL,             AudioManager.STREAM_SYSTEM,             AudioManager.STREAM_RING,             AudioManager.STREAM_MUSIC,             AudioManager.STREAM_ALARM,             AudioManager.STREAM_NOTIFICATION,             AudioManager.STREAM_DTMF,             AudioManager.STREAM_ACCESSIBILITY,         };         mOriginalRingerMode = mAudioManager.getRingerMode();         for (int streamType : streamTypes) {             mOriginalStreamVolumes.put(streamType, mAudioManager.getStreamVolume(streamType));         }          try {             Utils.toggleNotificationPolicyAccess(                     mContext.getPackageName(), getInstrumentation(), true);             mOriginalNotificationPolicy = mNm.getNotificationPolicy();             mOriginalZen = mNm.getCurrentInterruptionFilter();         } finally {             setInterruptionFilter(NotificationManager.INTERRUPTION_FILTER_ALL);             Utils.toggleNotificationPolicyAccess(                     mContext.getPackageName(), getInstrumentation(), false);         }          // Check original mirchrophone mute/unmute status         mDoNotCheckUnmute = false;         if (mAudioManager.isMicrophoneMute()) {             mAudioManager.setMicrophoneMute(false);             if (mAudioManager.isMicrophoneMute()) {                 Log.w(TAG, ""Mic seems muted by hardware! Please unmute and rerrun the test."");                 mDoNotCheckUnmute = true;             }         }     }      @Override     protected void tearDown() throws Exception {         try {             Utils.toggleNotificationPolicyAccess(                     mContext.getPackageName(), getInstrumentation(), true);             mNm.setNotificationPolicy(mOriginalNotificationPolicy);             setInterruptionFilter(mOriginalZen);              // Recover the volume and the ringer mode that the test may have overwritten.             for (Map.Entry<Integer, Integer> e : mOriginalStreamVolumes.entrySet()) {                 mAudioManager.setStreamVolume(e.getKey(), e.getValue(),                                               AudioManager.FLAG_ALLOW_RINGER_MODES);             }             mAudioManager.setRingerMode(mOriginalRingerMode);         } finally {             Utils.toggleNotificationPolicyAccess(                     mContext.getPackageName(), getInstrumentation(), false);         }     }      @AppModeFull(reason = ""Instant apps cannot hold android.permission.MODIFY_AUDIO_SETTINGS"")"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.hardware.camera2.cts.OfflineSessionTest"	"testInvalidOutput"	"CtsCameraTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/OfflineSessionTest.java"	""	"public void testInvalidOutput() throws Exception {         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             try {                 Log.i(TAG, ""Testing camera device "" + mCameraIdsUnderTest[i]);                  if (!mAllStaticInfo.get(mCameraIdsUnderTest[i]).isColorOutputSupported()) {                     Log.i(TAG, ""Camera "" + mCameraIdsUnderTest[i] +                             "" does not support color outputs, skipping"");                     continue;                 }                  if (!mAllStaticInfo.get(mCameraIdsUnderTest[i]).isOfflineProcessingSupported()) {                     Log.i(TAG, ""Camera "" + mCameraIdsUnderTest[i] +                             "" does not support offline processing, skipping"");                     continue;                 }                  openDevice(mCameraIdsUnderTest[i]);                  CaptureRequest.Builder previewRequest =                         mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);                 CaptureRequest.Builder stillCaptureRequest =                         mCamera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);                 Size previewSize = mOrderedPreviewSizes.get(0);                 Size stillSize = mOrderedStillSizes.get(0);                 SimpleCaptureCallback resultListener = new SimpleCaptureCallback();                 SimpleImageReaderListener imageListener = new SimpleImageReaderListener();                  startPreview(previewRequest, previewSize, resultListener);                  CaptureResult result = resultListener.getCaptureResult(WAIT_FOR_FRAMES_TIMEOUT_MS);                  Long timestamp = result.get(CaptureResult.SENSOR_TIMESTAMP);                 assertNotNull(""Can't read a capture result timestamp"", timestamp);                  CaptureResult result2 = resultListener.getCaptureResult(WAIT_FOR_FRAMES_TIMEOUT_MS);                  Long timestamp2 = result2.get(CaptureResult.SENSOR_TIMESTAMP);                 assertNotNull(""Can't read a capture result 2 timestamp"", timestamp2);                  assertTrue(""Bad timestamps"", timestamp2 > timestamp);                  createImageReader(stillSize, ImageFormat.JPEG, MAX_READER_IMAGES, imageListener);                  BlockingOfflineSessionCallback offlineCb = new BlockingOfflineSessionCallback();                  try {                     ArrayList<Surface> offlineSurfaces = new ArrayList<Surface>();                     offlineSurfaces.add(mReaderSurface);                     mSession.switchToOffline(offlineSurfaces, new HandlerExecutor(mHandler),                             offlineCb);                     fail(""Offline session switch accepts unregistered output surface"");                 } catch (IllegalArgumentException e) {                     //Expected                 }                  if (mSession.supportsOfflineProcessing(mPreviewSurface)) {                     ArrayList<Surface> offlineSurfaces = new ArrayList<Surface>();                     offlineSurfaces.add(mPreviewSurface);                     mSession.switchToOffline(offlineSurfaces, new HandlerExecutor(mHandler),                             offlineCb);                     // We only have a single repeating request, in this case the camera                     // implementation should fail to find any capture requests that can                     // be migrated to offline mode and notify the failure accordingly.                     offlineCb.waitForState(BlockingOfflineSessionCallback.STATE_SWITCH_FAILED,                             WAIT_FOR_STATE_TIMEOUT_MS);                 } else {                     stopPreview();                 }                  closeImageReader();             } finally {                 closeDevice();             }         }     }      /**      * Test camera callback sequence during and after offline session switch.      *      * <p>Camera clients must receive respective capture results or failures for all      * non-offline outputs after the offline switch call returns.      * In case the switch was successful clients must be notified about the      * remaining offline requests via the registered offline callback.</p>      */"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.provider.cts.media.MediaStore_Audio_Genres_MembersTest"	"testStoreAudioGenresMembersExternal"	"CtsProviderTestCases"	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Audio_Genres_MembersTest.java"	""	"@Ignore(""Genres cannot be directly modified"")     public void testStoreAudioGenresMembersExternal() {         ContentValues values = new ContentValues();         values.put(Genres.NAME, Audio1.GENRE);         Uri uri = mContentResolver.insert(Genres.getContentUri(mVolumeName), values);         Cursor c = mContentResolver.query(uri, null, null, null, null);         c.moveToFirst();          long genreId = c.getLong(c.getColumnIndex(Genres._ID));         long genre2Id = -1; // used later         c.close();          // verify that the Uri has the correct format and genre value         assertEquals(ContentUris.withAppendedId(Genres.getContentUri(mVolumeName), genreId),                 uri);          // insert audio as the member of the genre         values.clear();         values.put(Members.AUDIO_ID, mAudioIdOfJam);         Uri membersUri = Members.getContentUri(mVolumeName, genreId);         assertNotNull(mContentResolver.insert(membersUri, values));          try {             // query, slow path             c = mContentResolver.query(membersUri, null, null, null, null);              assertEquals(1, c.getCount());             c.moveToFirst();              assertEquals(mAudioIdOfJam, c.getLong(c.getColumnIndex(Members.AUDIO_ID)));             assertEquals(genreId, c.getLong(c.getColumnIndex(Members.GENRE_ID)));             assertEquals(mAudioIdOfJam, c.getLong(c.getColumnIndex(Members._ID)));             final String expected1 = Audio1.getInstance().getContentValues(mVolumeName)                     .getAsString(Members.DATA);             assertEquals(expected1, c.getString(c.getColumnIndex(Members.DATA)));             assertTrue(c.getLong(c.getColumnIndex(Members.DATE_ADDED)) > 0);             assertEquals(Audio1.DATE_MODIFIED, c.getLong(c.getColumnIndex(Members.DATE_MODIFIED)));             assertEquals(Audio1.DISPLAY_NAME, c.getString(c.getColumnIndex(Members.DISPLAY_NAME)));             assertEquals(Audio1.MIME_TYPE, c.getString(c.getColumnIndex(Members.MIME_TYPE)));             assertEquals(Audio1.SIZE, c.getInt(c.getColumnIndex(Members.SIZE)));             assertEquals(Audio1.TITLE, c.getString(c.getColumnIndex(Members.TITLE)));             assertEquals(Audio1.ALBUM, c.getString(c.getColumnIndex(Members.ALBUM)));             String albumKey = c.getString(c.getColumnIndex(Members.ALBUM_KEY));             assertNotNull(albumKey);             long albumId = c.getLong(c.getColumnIndex(Members.ALBUM_ID));             assertTrue(albumId > 0);             assertEquals(Audio1.ARTIST, c.getString(c.getColumnIndex(Members.ARTIST)));             String artistKey = c.getString(c.getColumnIndex(Members.ARTIST_KEY));             assertNotNull(artistKey);             long artistId = c.getLong(c.getColumnIndex(Members.ARTIST_ID));             assertTrue(artistId > 0);             assertEquals(Audio1.COMPOSER, c.getString(c.getColumnIndex(Members.COMPOSER)));             assertEquals(Audio1.DURATION, c.getLong(c.getColumnIndex(Members.DURATION)));             assertEquals(Audio1.IS_ALARM, c.getInt(c.getColumnIndex(Members.IS_ALARM)));             assertEquals(Audio1.IS_MUSIC, c.getInt(c.getColumnIndex(Members.IS_MUSIC)));             assertEquals(Audio1.IS_NOTIFICATION,                     c.getInt(c.getColumnIndex(Members.IS_NOTIFICATION)));             assertEquals(Audio1.IS_RINGTONE, c.getInt(c.getColumnIndex(Members.IS_RINGTONE)));             assertEquals(Audio1.TRACK, c.getInt(c.getColumnIndex(Members.TRACK)));             assertEquals(Audio1.YEAR, c.getInt(c.getColumnIndex(Members.YEAR)));             String titleKey = c.getString(c.getColumnIndex(Members.TITLE_KEY));             assertNotNull(titleKey);             c.close();              // query again, fast path             c = mContentResolver.query(membersUri,                     new String[] { Members.AUDIO_ID, Members.GENRE_ID},                     null, null, null);             assertEquals(1, c.getCount());             c.moveToFirst();             assertEquals(mAudioIdOfJam, c.getLong(c.getColumnIndex(Members.AUDIO_ID)));             assertEquals(genreId, c.getLong(c.getColumnIndex(Members.GENRE_ID)));             c.close();              // Query with a constraint on _id. Note that _id corresponds to the _id             // column in the audio table, not the one in the audio_genres_map table.             // We need to preserve this behavior for backward compatibility.             c = mContentResolver.query(membersUri, null,                     Members._ID + ""=?"", new String[] {Long.toString(mAudioIdOfJam)}, null);             assertEquals(1, c.getCount());             c.moveToFirst();             assertEquals(mAudioIdOfJam, c.getLong(c.getColumnIndex(Members._ID)));             c.close();              // Query members across all genres             // TODO: migrate this to using public API             Uri allMembersUri = MediaStore.Audio.Genres.getContentUri(mVolumeName).buildUpon()                     .appendPath(""all"").appendPath(""members"").build();             c = mContentResolver.query(allMembersUri, null, null, null, null);             int colidx = c.getColumnIndex(Members.AUDIO_ID);             int jamcnt = 0;             // The song should appear only once, for the genre we used when inserting it             while(c.moveToNext()) {                 if (c.getLong(colidx) == mAudioIdOfJam) {                     jamcnt++;                     assertEquals(genreId, c.getLong(c.getColumnIndex(Members.GENRE_ID)));                 }             }             assertEquals(1, jamcnt);             c.close();              // Query the same Uri, but add a where clause to restrict it to the one entry we added             c = mContentResolver.query(allMembersUri, null,                     Members.AUDIO_ID + ""=?"", new String[] {Long.toString(mAudioIdOfJam)}, null);             assertEquals(1, c.getCount());             c.moveToFirst();             assertEquals(genreId, c.getLong(c.getColumnIndex(Members.GENRE_ID)));             assertEquals(mAudioIdOfJam, c.getLong(c.getColumnIndex(Members.AUDIO_ID)));             c.close();              // create another genre             values.clear();             values.put(Genres.NAME, Audio1.GENRE + ""-2"");             uri = mContentResolver.insert(Genres.getContentUri(mVolumeName), values);             c = mContentResolver.query(uri, null, null, null, null);             c.moveToFirst();             genre2Id = c.getLong(c.getColumnIndex(Genres._ID));             c.close();              // insert the song into the second genre             values.clear();             values.put(Members.AUDIO_ID, mAudioIdOfJam);             Uri members2Uri = Members.getContentUri(mVolumeName, genre2Id);             assertNotNull(mContentResolver.insert(members2Uri, values));              // Query members across all genres again             c = mContentResolver.query(allMembersUri, null, null, null, null);             colidx = c.getColumnIndex(Members.AUDIO_ID);             int jamcnt1 = 0;             int jamcnt2 = 0;             // This time the song should appear twice, once for each genre             while(c.moveToNext()) {                 if (c.getLong(colidx) == mAudioIdOfJam) {                     long g = c.getLong(c.getColumnIndex(Members.GENRE_ID));                     if (g == genreId) {                         jamcnt1++;                     } else if (g == genre2Id) {                         jamcnt2++;                     } else {                         fail(""wrong genre found"");                     }                 }             }             assertEquals(1, jamcnt1);             assertEquals(1, jamcnt2);             c.close();              // Delete the members, note that this does not delete the genre itself             assertEquals(1, mContentResolver.delete(membersUri, null, null)); // check number of rows deleted              // verify the genre is now empty             c = mContentResolver.query(membersUri, null, null, null, null);             assertEquals(0, c.getCount());             c.close();              // same for 2nd genre             assertEquals(1, mContentResolver.delete(members2Uri, null, null));             c = mContentResolver.query(members2Uri, null, null, null, null);             assertEquals(0, c.getCount());             c.close();              // insert again, then verify that deleting the audio entry cleans up its genre member             // entry as well             values.put(Members.AUDIO_ID, mAudioIdOfJam);             membersUri = Members.getContentUri(mVolumeName, genreId);             assertNotNull(mContentResolver.insert(membersUri, values));             // Query members across all genres             c = mContentResolver.query(allMembersUri,                     new String[] { Members.AUDIO_ID, Members.GENRE_ID}, null, null, null);             colidx = c.getColumnIndex(Members.AUDIO_ID);             jamcnt = 0;             // The song should appear only once, for the genre we used when inserting it             while(c.moveToNext()) {                 if (c.getLong(colidx) == mAudioIdOfJam) {                     jamcnt++;                     assertEquals(genreId, c.getLong(c.getColumnIndex(Members.GENRE_ID)));                 }             }             assertEquals(1, jamcnt);             c.close();             mContentResolver.delete(Media.getContentUri(mVolumeName),                     Media._ID + ""="" + mAudioIdOfJam, null);             // Query members across all genres             c = mContentResolver.query(allMembersUri,                     new String[] { Members.AUDIO_ID, Members.GENRE_ID}, null, null, null);             colidx = c.getColumnIndex(Members.AUDIO_ID);             jamcnt = 0;             // The song should no longer appear in the genre             while(c.moveToNext()) {                 if (c.getLong(colidx) == mAudioIdOfJam) {                     jamcnt++;                 }             }             assertEquals(0, jamcnt);             c.close();         } finally {             // the members are deleted when deleting the genre which they belong to             mContentResolver.delete(Genres.getContentUri(mVolumeName),                     Genres._ID + ""="" + genreId, null);             if (genre2Id >= 0) {                 mContentResolver.delete(Genres.getContentUri(mVolumeName),                         Genres._ID + ""="" + genre2Id, null);             }             c = mContentResolver.query(membersUri, null, null, null, null);             assertEquals(0, c.getCount());             c.close();         }     } }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"android.cts.statsd.atom.UidAtomTests"	"testPictureInPictureState"	""	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/statsd/src/android/cts/statsd/atom/UidAtomTests.java"	""	"public void testPictureInPictureState() throws Exception {         String supported = getDevice().executeShellCommand(""am supports-multiwindow"");         if (!hasFeature(FEATURE_WATCH, false) ||                 !hasFeature(FEATURE_PICTURE_IN_PICTURE, true) ||                 !supported.contains(""true"")) {             LogUtil.CLog.d(""Skipping picture in picture atom test."");             return;         }          StatsdConfig.Builder conf = createConfigBuilder();         // PictureInPictureStateChanged atom is used prior to rvc-qpr         addAtomEvent(conf, Atom.PICTURE_IN_PICTURE_STATE_CHANGED_FIELD_NUMBER,                 /*useAttribution=*/false);         // Picture-in-picture logs' been migrated to UiEvent since rvc-qpr         FieldValueMatcher.Builder pkgMatcher = createFvm(UiEventReported.PACKAGE_NAME_FIELD_NUMBER)                 .setEqString(DEVICE_SIDE_TEST_PACKAGE);         addAtomEvent(conf, Atom.UI_EVENT_REPORTED_FIELD_NUMBER, Arrays.asList(pkgMatcher));         uploadConfig(conf);          LogUtil.CLog.d(""Playing video in Picture-in-Picture mode"");         runActivity(""VideoPlayerActivity"", ""action"", ""action.play_video_picture_in_picture_mode"");          // Sorted list of events in order in which they occurred.         List<EventMetricData> data = getEventMetricDataList();          // Filter out the PictureInPictureStateChanged and UiEventReported atom         List<EventMetricData> pictureInPictureStateChangedData = data.stream()                 .filter(e -> e.getAtom().hasPictureInPictureStateChanged())                 .collect(Collectors.toList());         List<EventMetricData> uiEventReportedData = data.stream()                 .filter(e -> e.getAtom().hasUiEventReported())                 .collect(Collectors.toList());          if (!pictureInPictureStateChangedData.isEmpty()) {             LogUtil.CLog.d(""Assert using PictureInPictureStateChanged"");             Set<Integer> entered = new HashSet<>(                     Arrays.asList(PictureInPictureStateChanged.State.ENTERED_VALUE));             List<Set<Integer>> stateSet = Arrays.asList(entered);             assertStatesOccurred(stateSet, data, WAIT_TIME_LONG,                     atom -> atom.getPictureInPictureStateChanged().getState().getNumber());         } else if (!uiEventReportedData.isEmpty()) {             LogUtil.CLog.d(""Assert using UiEventReported"");             // See PipUiEventEnum for definitions             final int enterPipEventId = 603;             // Assert that log for entering PiP happens exactly once, we do not use             // assertStateOccurred here since PiP may log something else when activity finishes.             List<EventMetricData> entered = uiEventReportedData.stream()                     .filter(e -> e.getAtom().getUiEventReported().getEventId() == enterPipEventId)                     .collect(Collectors.toList());             assertThat(entered).hasSize(1);         } else {             fail(""No logging event from PictureInPictureStateChanged nor UiEventReported"");         }     }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"com.android.cts.managedprofile.ProvisioningTest"	"PersistableBundle"	""	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ProvisioningTest.java"	""	"/*  *.  */ package com.android.cts.managedprofile;  import static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_KEEP_ACCOUNT_ON_MIGRATION; import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_SKIP_ENCRYPTION;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  import android.accounts.Account; import android.accounts.AccountManager; import android.app.admin.DeviceAdminReceiver; import android.app.admin.DevicePolicyManager; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.SharedPreferences; import android.os.PersistableBundle; import android.util.Log;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest;  import com.android.compatibility.common.util.devicepolicy.provisioning.SilentProvisioningTestManager;  import org.junit.Before; import org.junit.Test;  @SmallTest public class ProvisioningTest {     private static final String TAG = ProvisioningTest.class.getSimpleName();      private static final String SHARED_PREFERENCE_FILE_NAME = ""shared-preferences-file-name"";      private static final PersistableBundle ADMIN_EXTRAS_BUNDLE = new PersistableBundle();     private static final String ADMIN_EXTRAS_BUNDLE_KEY_1 = ""KEY_1"";     private static final String ADMIN_EXTRAS_BUNDLE_VALUE_1 = ""VALUE_1"";     static {         ADMIN_EXTRAS_BUNDLE.putString(ADMIN_EXTRAS_BUNDLE_KEY_1, ADMIN_EXTRAS_BUNDLE_VALUE_1);     }      public static final String KEY_PROVISIONING_SUCCESSFUL_RECEIVED =             ""key-provisioning-successful-received"";      private static final ComponentName ADMIN_RECEIVER_COMPONENT = new ComponentName(             ProvisioningAdminReceiver.class.getPackage().getName(),             ProvisioningAdminReceiver.class.getName());      public static class ProvisioningAdminReceiver extends DeviceAdminReceiver {         @Override         public void onProfileProvisioningComplete(Context context, Intent intent) {             super.onProfileProvisioningComplete(context, intent);             // Enabled profile             getManager(context).setProfileName(ADMIN_RECEIVER_COMPONENT, ""Managed Profile"");             getManager(context).setProfileEnabled(ADMIN_RECEIVER_COMPONENT);             Log.i(TAG, ""onProfileProvisioningComplete"");              saveBundle(context, intent.getParcelableExtra(EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE));         }     }      private Context mContext;     private DevicePolicyManager mDpm;      @Before     public void setUp() {         mContext = InstrumentationRegistry.getTargetContext();         mDpm = mContext.getSystemService(DevicePolicyManager.class);     }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"com.android.cts.managedprofile.ProvisioningTest"	"testAccountExist"	""	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ProvisioningTest.java"	""	"public void testAccountExist() {         AccountManager am = AccountManager.get(mContext);         for (Account account : am.getAccountsByType(AccountAuthenticator.ACCOUNT_TYPE)) {             if (AccountAuthenticator.TEST_ACCOUNT.equals(account)) {                 return;             }         }         fail(""can't find migrated account"");     }"	""	""	""	""	""
"274:790271) 9.16  . Application Data Migration"	"9.16"	"C-1-4"	""	"com.android.cts.managedprofile.ProvisioningTest"	"testAccountNotExist"	""	""	"9.16/C-1-4"	"""C-1-4] MUST only migrate application data to the same application on the target device, with the same package name AND signing certificate. """	""	"migrate"	""	""	""	"migrate"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ProvisioningTest.java"	""	"public void testAccountNotExist() {         AccountManager am = AccountManager.get(mContext);         assertTrue(""test account still exists after account migration"",                 am.getAccountsByType(AccountAuthenticator.ACCOUNT_TYPE).length == 0);     }      private Intent createBaseProvisioningIntent() {         return new Intent(ACTION_PROVISION_MANAGED_PROFILE)                 .putExtra(EXTRA_PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME, ADMIN_RECEIVER_COMPONENT)                 .putExtra(EXTRA_PROVISIONING_SKIP_ENCRYPTION, true)                 .putExtra(EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE, ADMIN_EXTRAS_BUNDLE)                 .putExtra(EXTRA_PROVISIONING_ACCOUNT_TO_MIGRATE, addAndGetTestAccount());     }      private void provisionManagedProfile(Intent intent) throws InterruptedException {         SilentProvisioningTestManager provisioningManager = new SilentProvisioningTestManager(mContext);         assertTrue(provisioningManager.startProvisioningAndWait(intent));         Log.i(TAG, ""managed profile provisioning successful"");     }      private Account addAndGetTestAccount() {         Account account = AccountAuthenticator.TEST_ACCOUNT;         AccountManager.get(mContext).addAccountExplicitly(account, null, null);         return account;     }      private static void saveBundle(Context context, PersistableBundle bundle) {         if (bundle == null) {             Log.e(TAG, ""null saveBundle"");             return;         }          getSharedPreferences(context).edit()                 .putString(ADMIN_EXTRAS_BUNDLE_KEY_1, bundle.getString(ADMIN_EXTRAS_BUNDLE_KEY_1))                 .commit();     }      private static PersistableBundle loadBundle(Context context) {         SharedPreferences pref = getSharedPreferences(context);         PersistableBundle bundle = new PersistableBundle();         bundle.putString(ADMIN_EXTRAS_BUNDLE_KEY_1,                 pref.getString(ADMIN_EXTRAS_BUNDLE_KEY_1, null));         return bundle;     }      public static SharedPreferences getSharedPreferences(Context context) {         return context.getSharedPreferences(SHARED_PREFERENCE_FILE_NAME, 0);     }  }"	""	""	""	""	""













