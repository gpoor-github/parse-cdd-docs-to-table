"Section"	"section_id"	"req_id"	"Test Availability"	"class_def"	"method"	"module"	"method_text"	"full_key"	"requirement"	"key_as_number"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"matched_terms"	"search_roots"	"qualified_method"	"max_matches"	"file_name"	"matched_files"	"methods_string"	"urls"	"protected"	"Area"	"Shortened"	"Test Level"
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-1"	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-1"	"""C-1-1] MUST provide a captive portal application to handle the intent ACTION_CAPTIVE_PORTAL_SIGN_IN and display the captive portal login page, by sending that intent, on call to the System API ConnectivityManager#startCaptivePortalApp(Network, Bundle). """	""	"ACTION_CAPTIVE_PORTAL_SIGN_IN"	""	""	""	"ACTION_CAPTIVE_PORTAL_SIGN_IN"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSettingsPermission() {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         final PackageManager pm = getContext().getPackageManager();          final ArraySet<String> allowedPackages = new ArraySet();         final ArraySet<Integer> allowedUIDs = new ArraySet();         // explicitly add allowed UIDs         allowedUIDs.add(Process.SYSTEM_UID);         allowedUIDs.add(Process.SHELL_UID);         allowedUIDs.add(Process.PHONE_UID);         allowedUIDs.add(Process.NETWORK_STACK_UID);         allowedUIDs.add(Process.NFC_UID);          // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using         // this fact to determined allowed package name for sysui. This is a signature permission,         // so allow any package with this permission.         final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.BIND_QUICK_SETTINGS_TILE         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         for (PackageInfo info : sysuiPackages) {             allowedPackages.add(info.packageName);         }          // the captive portal flow also currently holds the NETWORK_SETTINGS permission         final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);         final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);         if (ri != null) {             allowedPackages.add(ri.activityInfo.packageName);         }          final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.NETWORK_SETTINGS         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         StringBuilder stringBuilder = new StringBuilder();         for (PackageInfo pi : holding) {             String packageName = pi.packageName;              // this is an explicitly allowed package             if (allowedPackages.contains(packageName)) continue;              // now check if the packages are from allowed UIDs             int uid = -1;             try {                 uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);             } catch (PackageManager.NameNotFoundException e) {                 continue;             }             if (!allowedUIDs.contains(uid)) {                 stringBuilder.append(""The NETWORK_SETTINGS permission must not be held by ""                     + packageName + "":"" + uid + "" and must be revoked for security reasons\n"");             }         }         if (stringBuilder.length() > 0) {             fail(stringBuilder.toString());         }     }      /**      * Verify that the {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} permission is      * only held by the device setup wizard application.      * <p>      * Only the SetupWizard app should <em>ever</em> attempt to acquire this      * permission, since it would give those apps extremely broad access to connectivity      * functionality.  The permission is intended to be granted to only the device setup wizard.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-1"	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-1"	"""C-1-1] MUST provide a captive portal application to handle the intent ACTION_CAPTIVE_PORTAL_SIGN_IN and display the captive portal login page, by sending that intent, on call to the System API ConnectivityManager#startCaptivePortalApp(Network, Bundle). """	""	"ACTION_CAPTIVE_PORTAL_SIGN_IN"	""	""	""	"ACTION_CAPTIVE_PORTAL_SIGN_IN"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSettingsPermission() {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         final PackageManager pm = getContext().getPackageManager();          final ArraySet<String> allowedPackages = new ArraySet();         final ArraySet<Integer> allowedUIDs = new ArraySet();         // explicitly add allowed UIDs         allowedUIDs.add(Process.SYSTEM_UID);         allowedUIDs.add(Process.SHELL_UID);         allowedUIDs.add(Process.PHONE_UID);         allowedUIDs.add(Process.NETWORK_STACK_UID);         allowedUIDs.add(Process.NFC_UID);          // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using         // this fact to determined allowed package name for sysui. This is a signature permission,         // so allow any package with this permission.         final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.BIND_QUICK_SETTINGS_TILE         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         for (PackageInfo info : sysuiPackages) {             allowedPackages.add(info.packageName);         }          // the captive portal flow also currently holds the NETWORK_SETTINGS permission         final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);         final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);         if (ri != null) {             allowedPackages.add(ri.activityInfo.packageName);         }          final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.NETWORK_SETTINGS         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         StringBuilder stringBuilder = new StringBuilder();         for (PackageInfo pi : holding) {             String packageName = pi.packageName;              // this is an explicitly allowed package             if (allowedPackages.contains(packageName)) continue;              // now check if the packages are from allowed UIDs             int uid = -1;             try {                 uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);             } catch (PackageManager.NameNotFoundException e) {                 continue;             }             if (!allowedUIDs.contains(uid)) {                 stringBuilder.append(""The NETWORK_SETTINGS permission must not be held by ""                     + packageName + "":"" + uid + "" and must be revoked for security reasons\n"");             }         }         if (stringBuilder.length() > 0) {             fail(stringBuilder.toString());         }     }      /**      * Verify that the {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} permission is      * only held by the device setup wizard application.      * <p>      * Only the SetupWizard app should <em>ever</em> attempt to acquire this      * permission, since it would give those apps extremely broad access to connectivity      * functionality.  The permission is intended to be granted to only the device setup wizard.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-2"	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-2"	"""C-1-2] MUST perform detection of captive portals and support login through the captive portal application when the device is connected to any network type, including cellular/mobile network, WiFi, Ethernet or Bluetooth. """	""	"portal captive"	""	""	""	"portal"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSettingsPermission() {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         final PackageManager pm = getContext().getPackageManager();          final ArraySet<String> allowedPackages = new ArraySet();         final ArraySet<Integer> allowedUIDs = new ArraySet();         // explicitly add allowed UIDs         allowedUIDs.add(Process.SYSTEM_UID);         allowedUIDs.add(Process.SHELL_UID);         allowedUIDs.add(Process.PHONE_UID);         allowedUIDs.add(Process.NETWORK_STACK_UID);         allowedUIDs.add(Process.NFC_UID);          // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using         // this fact to determined allowed package name for sysui. This is a signature permission,         // so allow any package with this permission.         final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.BIND_QUICK_SETTINGS_TILE         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         for (PackageInfo info : sysuiPackages) {             allowedPackages.add(info.packageName);         }          // the captive portal flow also currently holds the NETWORK_SETTINGS permission         final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);         final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);         if (ri != null) {             allowedPackages.add(ri.activityInfo.packageName);         }          final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.NETWORK_SETTINGS         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         StringBuilder stringBuilder = new StringBuilder();         for (PackageInfo pi : holding) {             String packageName = pi.packageName;              // this is an explicitly allowed package             if (allowedPackages.contains(packageName)) continue;              // now check if the packages are from allowed UIDs             int uid = -1;             try {                 uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);             } catch (PackageManager.NameNotFoundException e) {                 continue;             }             if (!allowedUIDs.contains(uid)) {                 stringBuilder.append(""The NETWORK_SETTINGS permission must not be held by ""                     + packageName + "":"" + uid + "" and must be revoked for security reasons\n"");             }         }         if (stringBuilder.length() > 0) {             fail(stringBuilder.toString());         }     }      /**      * Verify that the {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} permission is      * only held by the device setup wizard application.      * <p>      * Only the SetupWizard app should <em>ever</em> attempt to acquire this      * permission, since it would give those apps extremely broad access to connectivity      * functionality.  The permission is intended to be granted to only the device setup wizard.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-2"	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-2"	"""C-1-2] MUST perform detection of captive portals and support login through the captive portal application when the device is connected to any network type, including cellular/mobile network, WiFi, Ethernet or Bluetooth. """	""	"portal captive"	""	""	""	"captive"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSettingsPermission() {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         final PackageManager pm = getContext().getPackageManager();          final ArraySet<String> allowedPackages = new ArraySet();         final ArraySet<Integer> allowedUIDs = new ArraySet();         // explicitly add allowed UIDs         allowedUIDs.add(Process.SYSTEM_UID);         allowedUIDs.add(Process.SHELL_UID);         allowedUIDs.add(Process.PHONE_UID);         allowedUIDs.add(Process.NETWORK_STACK_UID);         allowedUIDs.add(Process.NFC_UID);          // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using         // this fact to determined allowed package name for sysui. This is a signature permission,         // so allow any package with this permission.         final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.BIND_QUICK_SETTINGS_TILE         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         for (PackageInfo info : sysuiPackages) {             allowedPackages.add(info.packageName);         }          // the captive portal flow also currently holds the NETWORK_SETTINGS permission         final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);         final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);         if (ri != null) {             allowedPackages.add(ri.activityInfo.packageName);         }          final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.NETWORK_SETTINGS         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         StringBuilder stringBuilder = new StringBuilder();         for (PackageInfo pi : holding) {             String packageName = pi.packageName;              // this is an explicitly allowed package             if (allowedPackages.contains(packageName)) continue;              // now check if the packages are from allowed UIDs             int uid = -1;             try {                 uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);             } catch (PackageManager.NameNotFoundException e) {                 continue;             }             if (!allowedUIDs.contains(uid)) {                 stringBuilder.append(""The NETWORK_SETTINGS permission must not be held by ""                     + packageName + "":"" + uid + "" and must be revoked for security reasons\n"");             }         }         if (stringBuilder.length() > 0) {             fail(stringBuilder.toString());         }     }      /**      * Verify that the {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} permission is      * only held by the device setup wizard application.      * <p>      * Only the SetupWizard app should <em>ever</em> attempt to acquire this      * permission, since it would give those apps extremely broad access to connectivity      * functionality.  The permission is intended to be granted to only the device setup wizard.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-2"	""	"android.net.cts.NetworkInfo_DetailedStateTest"	"testValues"	""	""	"7.4.5.3/C-1-2"	"""C-1-2] MUST perform detection of captive portals and support login through the captive portal application when the device is connected to any network type, including cellular/mobile network, WiFi, Ethernet or Bluetooth. """	""	"portal captive"	""	""	""	"portal"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/NetworkInfo_DetailedStateTest.java"	""	"public void testValues() {         DetailedState[] expected = DetailedState.values();         assertEquals(13, expected.length);         assertEquals(DetailedState.IDLE, expected[0]);         assertEquals(DetailedState.SCANNING, expected[1]);         assertEquals(DetailedState.CONNECTING, expected[2]);         assertEquals(DetailedState.AUTHENTICATING, expected[3]);         assertEquals(DetailedState.OBTAINING_IPADDR, expected[4]);         assertEquals(DetailedState.CONNECTED, expected[5]);         assertEquals(DetailedState.SUSPENDED, expected[6]);         assertEquals(DetailedState.DISCONNECTING, expected[7]);         assertEquals(DetailedState.DISCONNECTED, expected[8]);         assertEquals(DetailedState.FAILED, expected[9]);         assertEquals(DetailedState.BLOCKED, expected[10]);         assertEquals(DetailedState.VERIFYING_POOR_LINK, expected[11]);         assertEquals(DetailedState.CAPTIVE_PORTAL_CHECK, expected[12]);     }  }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-2"	""	"android.net.cts.NetworkInfo_DetailedStateTest"	"testValues"	""	""	"7.4.5.3/C-1-2"	"""C-1-2] MUST perform detection of captive portals and support login through the captive portal application when the device is connected to any network type, including cellular/mobile network, WiFi, Ethernet or Bluetooth. """	""	"portal captive"	""	""	""	"captive"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/NetworkInfo_DetailedStateTest.java"	""	"public void testValues() {         DetailedState[] expected = DetailedState.values();         assertEquals(13, expected.length);         assertEquals(DetailedState.IDLE, expected[0]);         assertEquals(DetailedState.SCANNING, expected[1]);         assertEquals(DetailedState.CONNECTING, expected[2]);         assertEquals(DetailedState.AUTHENTICATING, expected[3]);         assertEquals(DetailedState.OBTAINING_IPADDR, expected[4]);         assertEquals(DetailedState.CONNECTED, expected[5]);         assertEquals(DetailedState.SUSPENDED, expected[6]);         assertEquals(DetailedState.DISCONNECTING, expected[7]);         assertEquals(DetailedState.DISCONNECTED, expected[8]);         assertEquals(DetailedState.FAILED, expected[9]);         assertEquals(DetailedState.BLOCKED, expected[10]);         assertEquals(DetailedState.VERIFYING_POOR_LINK, expected[11]);         assertEquals(DetailedState.CAPTIVE_PORTAL_CHECK, expected[12]);     }  }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-2"	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-2"	"""C-1-2] MUST perform detection of captive portals and support login through the captive portal application when the device is connected to any network type, including cellular/mobile network, WiFi, Ethernet or Bluetooth. """	""	"portal captive"	""	""	""	"portal"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSettingsPermission() {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         final PackageManager pm = getContext().getPackageManager();          final ArraySet<String> allowedPackages = new ArraySet();         final ArraySet<Integer> allowedUIDs = new ArraySet();         // explicitly add allowed UIDs         allowedUIDs.add(Process.SYSTEM_UID);         allowedUIDs.add(Process.SHELL_UID);         allowedUIDs.add(Process.PHONE_UID);         allowedUIDs.add(Process.NETWORK_STACK_UID);         allowedUIDs.add(Process.NFC_UID);          // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using         // this fact to determined allowed package name for sysui. This is a signature permission,         // so allow any package with this permission.         final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.BIND_QUICK_SETTINGS_TILE         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         for (PackageInfo info : sysuiPackages) {             allowedPackages.add(info.packageName);         }          // the captive portal flow also currently holds the NETWORK_SETTINGS permission         final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);         final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);         if (ri != null) {             allowedPackages.add(ri.activityInfo.packageName);         }          final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.NETWORK_SETTINGS         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         StringBuilder stringBuilder = new StringBuilder();         for (PackageInfo pi : holding) {             String packageName = pi.packageName;              // this is an explicitly allowed package             if (allowedPackages.contains(packageName)) continue;              // now check if the packages are from allowed UIDs             int uid = -1;             try {                 uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);             } catch (PackageManager.NameNotFoundException e) {                 continue;             }             if (!allowedUIDs.contains(uid)) {                 stringBuilder.append(""The NETWORK_SETTINGS permission must not be held by ""                     + packageName + "":"" + uid + "" and must be revoked for security reasons\n"");             }         }         if (stringBuilder.length() > 0) {             fail(stringBuilder.toString());         }     }      /**      * Verify that the {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} permission is      * only held by the device setup wizard application.      * <p>      * Only the SetupWizard app should <em>ever</em> attempt to acquire this      * permission, since it would give those apps extremely broad access to connectivity      * functionality.  The permission is intended to be granted to only the device setup wizard.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-2"	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-2"	"""C-1-2] MUST perform detection of captive portals and support login through the captive portal application when the device is connected to any network type, including cellular/mobile network, WiFi, Ethernet or Bluetooth. """	""	"portal captive"	""	""	""	"captive"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testNetworkSettingsPermission() {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         final PackageManager pm = getContext().getPackageManager();          final ArraySet<String> allowedPackages = new ArraySet();         final ArraySet<Integer> allowedUIDs = new ArraySet();         // explicitly add allowed UIDs         allowedUIDs.add(Process.SYSTEM_UID);         allowedUIDs.add(Process.SHELL_UID);         allowedUIDs.add(Process.PHONE_UID);         allowedUIDs.add(Process.NETWORK_STACK_UID);         allowedUIDs.add(Process.NFC_UID);          // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using         // this fact to determined allowed package name for sysui. This is a signature permission,         // so allow any package with this permission.         final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.BIND_QUICK_SETTINGS_TILE         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         for (PackageInfo info : sysuiPackages) {             allowedPackages.add(info.packageName);         }          // the captive portal flow also currently holds the NETWORK_SETTINGS permission         final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);         final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);         if (ri != null) {             allowedPackages.add(ri.activityInfo.packageName);         }          final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {                 android.Manifest.permission.NETWORK_SETTINGS         }, PackageManager.MATCH_UNINSTALLED_PACKAGES);         StringBuilder stringBuilder = new StringBuilder();         for (PackageInfo pi : holding) {             String packageName = pi.packageName;              // this is an explicitly allowed package             if (allowedPackages.contains(packageName)) continue;              // now check if the packages are from allowed UIDs             int uid = -1;             try {                 uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);             } catch (PackageManager.NameNotFoundException e) {                 continue;             }             if (!allowedUIDs.contains(uid)) {                 stringBuilder.append(""The NETWORK_SETTINGS permission must not be held by ""                     + packageName + "":"" + uid + "" and must be revoked for security reasons\n"");             }         }         if (stringBuilder.length() > 0) {             fail(stringBuilder.toString());         }     }      /**      * Verify that the {@link android.Manifest.permission#NETWORK_SETUP_WIZARD} permission is      * only held by the device setup wizard application.      * <p>      * Only the SetupWizard app should <em>ever</em> attempt to acquire this      * permission, since it would give those apps extremely broad access to connectivity      * functionality.  The permission is intended to be granted to only the device setup wizard.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-2"	""	"android.net.cts.NetworkInfo_DetailedStateTest"	"testValues"	""	""	"7.4.5.3/C-1-2"	"""C-1-2] MUST perform detection of captive portals and support login through the captive portal application when the device is connected to any network type, including cellular/mobile network, WiFi, Ethernet or Bluetooth. """	""	"portal captive"	""	""	""	"portal"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/NetworkInfo_DetailedStateTest.java"	""	"public void testValues() {         DetailedState[] expected = DetailedState.values();         assertEquals(13, expected.length);         assertEquals(DetailedState.IDLE, expected[0]);         assertEquals(DetailedState.SCANNING, expected[1]);         assertEquals(DetailedState.CONNECTING, expected[2]);         assertEquals(DetailedState.AUTHENTICATING, expected[3]);         assertEquals(DetailedState.OBTAINING_IPADDR, expected[4]);         assertEquals(DetailedState.CONNECTED, expected[5]);         assertEquals(DetailedState.SUSPENDED, expected[6]);         assertEquals(DetailedState.DISCONNECTING, expected[7]);         assertEquals(DetailedState.DISCONNECTED, expected[8]);         assertEquals(DetailedState.FAILED, expected[9]);         assertEquals(DetailedState.BLOCKED, expected[10]);         assertEquals(DetailedState.VERIFYING_POOR_LINK, expected[11]);         assertEquals(DetailedState.CAPTIVE_PORTAL_CHECK, expected[12]);     }  }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-2"	""	"android.net.cts.NetworkInfo_DetailedStateTest"	"testValues"	""	""	"7.4.5.3/C-1-2"	"""C-1-2] MUST perform detection of captive portals and support login through the captive portal application when the device is connected to any network type, including cellular/mobile network, WiFi, Ethernet or Bluetooth. """	""	"portal captive"	""	""	""	"captive"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/NetworkInfo_DetailedStateTest.java"	""	"public void testValues() {         DetailedState[] expected = DetailedState.values();         assertEquals(13, expected.length);         assertEquals(DetailedState.IDLE, expected[0]);         assertEquals(DetailedState.SCANNING, expected[1]);         assertEquals(DetailedState.CONNECTING, expected[2]);         assertEquals(DetailedState.AUTHENTICATING, expected[3]);         assertEquals(DetailedState.OBTAINING_IPADDR, expected[4]);         assertEquals(DetailedState.CONNECTED, expected[5]);         assertEquals(DetailedState.SUSPENDED, expected[6]);         assertEquals(DetailedState.DISCONNECTING, expected[7]);         assertEquals(DetailedState.DISCONNECTED, expected[8]);         assertEquals(DetailedState.FAILED, expected[9]);         assertEquals(DetailedState.BLOCKED, expected[10]);         assertEquals(DetailedState.VERIFYING_POOR_LINK, expected[11]);         assertEquals(DetailedState.CAPTIVE_PORTAL_CHECK, expected[12]);     }  }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.DnsResolverTest"	"getTestableNetworks"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsResolverTest.java"	""	"public void test/*  *.  */  package android.net.cts;  import static android.net.DnsResolver.CLASS_IN; import static android.net.DnsResolver.FLAG_EMPTY; import static android.net.DnsResolver.FLAG_NO_CACHE_LOOKUP; import static android.net.DnsResolver.TYPE_A; import static android.net.DnsResolver.TYPE_AAAA; import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR; import static android.system.OsConstants.ETIMEDOUT;  import android.annotation.NonNull; import android.annotation.Nullable; import android.content.Context; import android.content.ContentResolver; import android.net.ConnectivityManager; import android.net.ConnectivityManager.NetworkCallback; import android.net.DnsResolver; import android.net.LinkProperties; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkRequest; import android.net.ParseException; import android.net.cts.util.CtsNetUtils; import android.os.CancellationSignal; import android.os.Handler; import android.os.Looper; import android.platform.test.annotations.AppModeFull; import android.provider.Settings; import android.system.ErrnoException; import android.test.AndroidTestCase; import android.util.Log;  import com.android.net.module.util.DnsPacket; import com.android.testutils.SkipPresubmit;  import java.net.Inet4Address; import java.net.Inet6Address; import java.net.InetAddress; import java.util.ArrayList; import java.util.List; import java.util.concurrent.CountDownLatch; import java.util.concurrent.Executor; import java.util.concurrent.TimeUnit;  @AppModeFull(reason = ""WRITE_SECURE_SETTINGS permission can't be granted to instant apps"") public class DnsResolverTest extends AndroidTestCase {     private static final String TAG = ""DnsResolverTest"";     private static final char[] HEX_CHARS = {             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'     };      static final String TEST_DOMAIN = ""www.google.com"";     static final String TEST_NX_DOMAIN = ""test1-nx.metric.gstatic.com"";     static final String INVALID_PRIVATE_DNS_SERVER = ""invalid.google"";     static final String GOOGLE_PRIVATE_DNS_SERVER = ""dns.google"";     static final byte[] TEST_BLOB = new byte[]{             /* Header */             0x55, 0x66, /* Transaction ID */             0x01, 0x00, /* Flags */             0x00, 0x01, /* Questions */             0x00, 0x00, /* Answer RRs */             0x00, 0x00, /* Authority RRs */             0x00, 0x00, /* Additional RRs */             /* Queries */             0x03, 0x77, 0x77, 0x77, 0x06, 0x67, 0x6F, 0x6F, 0x67, 0x6c, 0x65,             0x03, 0x63, 0x6f, 0x6d, 0x00, /* Name */             0x00, 0x01, /* Type */             0x00, 0x01  /* Class */     };     static final int TIMEOUT_MS = 12_000;     static final int CANCEL_TIMEOUT_MS = 3_000;     static final int CANCEL_RETRY_TIMES = 5;     static final int QUERY_TIMES = 10;     static final int NXDOMAIN = 3;      private ContentResolver mCR;     private ConnectivityManager mCM;     private CtsNetUtils mCtsNetUtils;     private Executor mExecutor;     private Executor mExecutorInline;     private DnsResolver mDns;      private String mOldMode;     private String mOldDnsSpecifier;      @Override     protected void setUp() throws Exception {         super.setUp();         mCM = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);         mDns = DnsResolver.getInstance();         mExecutor = new Handler(Looper.getMainLooper())::post;         mExecutorInline = (Runnable r) -> r.run();         mCR = getContext().getContentResolver();         mCtsNetUtils = new CtsNetUtils(getContext());         mCtsNetUtils.storePrivateDnsSetting();     }      @Override     protected void tearDown() throws Exception {         mCtsNetUtils.restorePrivateDnsSetting();         super.tearDown();     }      private static String byteArrayToHexString(byte[] bytes) {         char[] hexChars = new char[bytes.length * 2];         for (int i = 0; i < bytes.length; ++i) {             int b = bytes[i] & 0xFF;             hexChars[i * 2] = HEX_CHARS[b >>> 4];             hexChars[i * 2 + 1] = HEX_CHARS[b & 0x0F];         }         return new String(hexChars);     }      private Network[] getTestableNetworks() {         final ArrayList<Network> testableNetworks = new ArrayList<Network>();         for (Network network : mCM.getAllNetworks()) {             final NetworkCapabilities nc = mCM.getNetworkCapabilities(network);             if (nc != null                     && nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)                     && nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {                 testableNetworks.add(network);             }         }          assertTrue(                 ""This test requires that at least one network be connected. "" +                         ""Please ensure that the device is connected to a network."",                 testableNetworks.size() >= 1);         // In order to test query with null network, add null as an element.         // Test cases which query with null network will go on default network.         testableNetworks.add(null);         return testableNetworks.toArray(new Network[0]);     }      static private void assertGreaterThan(String msg, int first, int second) {         assertTrue(msg + "" Excepted "" + first + "" to be greater than "" + second, first > second);     }      private static class DnsParseException extends Exception {         public DnsParseException(String msg) {             super(msg);         }     }      private static class DnsAnswer extends DnsPacket {         DnsAnswer(@NonNull byte[] data) throws DnsParseException {             super(data);              // Check QR field.(query (0), or a response (1)).             if ((mHeader.flags & (1 << 15)) == 0) {                 throw new DnsParseException(""Not an answer packet"");             }         }          int getRcode() {             return mHeader.rcode;         }          int getANCount() {             return mHeader.getRecordCount(ANSECTION);         }          int getQDCount() {             return mHeader.getRecordCount(QDSECTION);         }     }      /**      * A query callback that ensures that the query is cancelled and that onAnswer is never      * called. If the query succeeds before it is cancelled, needRetry will return true so the      * test can retry.      */     class VerifyCancelCallback implements DnsResolver.Callback<byte[]> {         private final CountDownLatch mLatch = new CountDownLatch(1);         private final String mMsg;         private final CancellationSignal mCancelSignal;         private int mRcode;         private DnsAnswer mDnsAnswer;         private String mErrorMsg = null;          VerifyCancelCallback(@NonNull String msg, @Nullable CancellationSignal cancel) {             mMsg = msg;             mCancelSignal = cancel;         }          VerifyCancelCallback(@NonNull String msg) {             this(msg, null);         }          public boolean waitForAnswer(int timeout) throws InterruptedException {             return mLatch.await(timeout, TimeUnit.MILLISECONDS);         }          public boolean waitForAnswer() throws InterruptedException {             return waitForAnswer(TIMEOUT_MS);         }          public boolean needRetry() throws InterruptedException {             return mLatch.await(CANCEL_TIMEOUT_MS, TimeUnit.MILLISECONDS);         }          @Override         public void onAnswer(@NonNull byte[] answer, int rcode) {             if (mCancelSignal != null && mCancelSignal.isCanceled()) {                 mErrorMsg = mMsg + "" should not have returned any answers"";                 mLatch.countDown();                 return;             }              mRcode = rcode;             try {                 mDnsAnswer = new DnsAnswer(answer);             } catch (ParseException | DnsParseException e) {                 mErrorMsg = mMsg + e.getMessage();                 mLatch.countDown();                 return;             }             Log.d(TAG, ""Reported blob: "" + byteArrayToHexString(answer));             mLatch.countDown();         }          @Override         public void onError(@NonNull DnsResolver.DnsException error) {             mErrorMsg = mMsg + error.getMessage();             mLatch.countDown();         }          private void assertValidAnswer() {             assertNull(mErrorMsg);             assertNotNull(mMsg + "" No valid answer"", mDnsAnswer);             assertEquals(mMsg + "" Unexpected error: reported rcode"" + mRcode +                     "" blob's rcode "" + mDnsAnswer.getRcode(), mRcode, mDnsAnswer.getRcode());         }          public void assertHasAnswer() {             assertValidAnswer();             // Check rcode field.(0, No error condition).             assertEquals(mMsg + "" Response error, rcode: "" + mRcode, mRcode, 0);             // Check answer counts.             assertGreaterThan(mMsg + "" No answer found"", mDnsAnswer.getANCount(), 0);             // Check question counts.             assertGreaterThan(mMsg + "" No question found"", mDnsAnswer.getQDCount(), 0);         }          public void assertNXDomain() {             assertValidAnswer();             // Check rcode field.(3, NXDomain).             assertEquals(mMsg + "" Unexpected rcode: "" + mRcode, mRcode, NXDOMAIN);             // Check answer counts. Expect 0 answer.             assertEquals(mMsg + "" Not an empty answer"", mDnsAnswer.getANCount(), 0);             // Check question counts.             assertGreaterThan(mMsg + "" No question found"", mDnsAnswer.getQDCount(), 0);         }          public void assertEmptyAnswer() {             assertValidAnswer();             // Check rcode field.(0, No error condition).             assertEquals(mMsg + "" Response error, rcode: "" + mRcode, mRcode, 0);             // Check answer counts. Expect 0 answer.             assertEquals(mMsg + "" Not an empty answer"", mDnsAnswer.getANCount(), 0);             // Check question counts.             assertGreaterThan(mMsg + "" No question found"", mDnsAnswer.getQDCount(), 0);         }     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.DnsResolverTest"	"testRawQueryNXDomainInlineWithPrivateDns"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsResolverTest.java"	""	"public void testRawQueryNXDomainInlineWithPrivateDns() throws Exception {         doTestRawQueryNXDomainWithPrivateDns(mExecutorInline);     }      public void doTestRawQuery(Executor executor) throws InterruptedException {         final String msg = ""RawQuery "" + TEST_DOMAIN;         for (Network network : getTestableNetworks()) {             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             mDns.rawQuery(network, TEST_DOMAIN, CLASS_IN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,                     executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertHasAnswer();         }     }      public void doTestRawQueryBlob(Executor executor) throws InterruptedException {         final byte[] blob = new byte[]{                 /* Header */                 0x55, 0x66, /* Transaction ID */                 0x01, 0x00, /* Flags */                 0x00, 0x01, /* Questions */                 0x00, 0x00, /* Answer RRs */                 0x00, 0x00, /* Authority RRs */                 0x00, 0x00, /* Additional RRs */                 /* Queries */                 0x03, 0x77, 0x77, 0x77, 0x06, 0x67, 0x6F, 0x6F, 0x67, 0x6c, 0x65,                 0x03, 0x63, 0x6f, 0x6d, 0x00, /* Name */                 0x00, 0x01, /* Type */                 0x00, 0x01  /* Class */         };         final String msg = ""RawQuery blob "" + byteArrayToHexString(blob);         for (Network network : getTestableNetworks()) {             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             mDns.rawQuery(network, blob, FLAG_NO_CACHE_LOOKUP, executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertHasAnswer();         }     }      public void doTestRawQueryRoot(Executor executor) throws InterruptedException {         final String dname = """";         final String msg = ""RawQuery empty dname(ROOT) "";         for (Network network : getTestableNetworks()) {             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             mDns.rawQuery(network, dname, CLASS_IN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,                     executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             // Except no answer record because the root does not have AAAA records.             callback.assertEmptyAnswer();         }     }      public void doTestRawQueryNXDomain(Executor executor) throws InterruptedException {         final String msg = ""RawQuery "" + TEST_NX_DOMAIN;          for (Network network : getTestableNetworks()) {             final NetworkCapabilities nc = (network != null)                     ? mCM.getNetworkCapabilities(network)                     : mCM.getNetworkCapabilities(mCM.getActiveNetwork());             assertNotNull(""Couldn't determine NetworkCapabilities for "" + network, nc);             // Some cellular networks configure their DNS servers never to return NXDOMAIN, so don't             // test NXDOMAIN on these DNS servers.             // b/144521720             if (nc.hasTransport(TRANSPORT_CELLULAR)) continue;             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             mDns.rawQuery(network, TEST_NX_DOMAIN, CLASS_IN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,                     executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertNXDomain();         }     }      public void doTestRawQueryNXDomainWithPrivateDns(Executor executor)             throws InterruptedException {         final String msg = ""RawQuery "" + TEST_NX_DOMAIN + "" with private DNS"";         // Enable private DNS strict mode and set server to dns.google before doing NxDomain test.         // b/144521720         mCtsNetUtils.setPrivateDnsStrictMode(GOOGLE_PRIVATE_DNS_SERVER);         for (Network network :  getTestableNetworks()) {             final Network networkForPrivateDns =                     (network != null) ? network : mCM.getActiveNetwork();             assertNotNull(""Can't find network to await private DNS on"", networkForPrivateDns);             mCtsNetUtils.awaitPrivateDnsSetting(msg + "" wait private DNS setting timeout"",                     networkForPrivateDns, GOOGLE_PRIVATE_DNS_SERVER, true);             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             mDns.rawQuery(network, TEST_NX_DOMAIN, CLASS_IN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,                     executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertNXDomain();         }     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.DnsResolverTest"	"testPrivateDnsBypass"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsResolverTest.java"	""	"public void testPrivateDnsBypass() throws InterruptedException {         final Network[] testNetworks = getTestableNetworks();          // Set an invalid private DNS server         mCtsNetUtils.setPrivateDnsStrictMode(INVALID_PRIVATE_DNS_SERVER);         final String msg = ""Test PrivateDnsBypass "" + TEST_DOMAIN;         for (Network network : testNetworks) {             // This test cannot be ran with null network because we need to explicitly pass a             // private DNS bypassable network or bind one.             if (network == null) continue;              // wait for private DNS setting propagating             mCtsNetUtils.awaitPrivateDnsSetting(msg + "" wait private DNS setting timeout"",                     network, INVALID_PRIVATE_DNS_SERVER, false);              final CountDownLatch latch = new CountDownLatch(1);             final DnsResolver.Callback<List<InetAddress>> errorCallback =                     new DnsResolver.Callback<List<InetAddress>>() {                         @Override                         public void onAnswer(@NonNull List<InetAddress> answerList, int rcode) {                             fail(msg + "" should not get valid answer"");                         }                          @Override                         public void onError(@NonNull DnsResolver.DnsException error) {                             assertEquals(DnsResolver.ERROR_SYSTEM, error.code);                             assertEquals(ETIMEDOUT, ((ErrnoException) error.getCause()).errno);                             latch.countDown();                         }                     };             // Private DNS strict mode with invalid DNS server is set             // Expect no valid answer returned but ErrnoException with ETIMEDOUT             mDns.query(network, TEST_DOMAIN, FLAG_NO_CACHE_LOOKUP, mExecutor, null, errorCallback);              assertTrue(msg + "" invalid server round. No response after "" + TIMEOUT_MS + ""ms."",                     latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));              final VerifyCancelInetAddressCallback callback =                     new VerifyCancelInetAddressCallback(msg, null);             // Bypass privateDns, expect query works fine             mDns.query(network.getPrivateDnsBypassingCopy(),                     TEST_DOMAIN, FLAG_NO_CACHE_LOOKUP, mExecutor, null, callback);              assertTrue(msg + "" bypass private DNS round. No answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertNoError();             assertTrue(msg + "" returned 0 results"", !callback.isAnswerEmpty());              // To ensure private DNS bypass still work even if passing null network.             // Bind process network with a private DNS bypassable network.             mCM.bindProcessToNetwork(network.getPrivateDnsBypassingCopy());             final VerifyCancelInetAddressCallback callbackWithNullNetwork =                     new VerifyCancelInetAddressCallback(msg + "" with null network "", null);             mDns.query(null,                     TEST_DOMAIN, FLAG_NO_CACHE_LOOKUP, mExecutor, null, callbackWithNullNetwork);              assertTrue(msg + "" with null network bypass private DNS round. No answer after "" +                     TIMEOUT_MS + ""ms."", callbackWithNullNetwork.waitForAnswer());             callbackWithNullNetwork.assertNoError();             assertTrue(msg + "" with null network returned 0 results"",                     !callbackWithNullNetwork.isAnswerEmpty());              // Reset process network to default.             mCM.bindProcessToNetwork(null);         }     }      public void doTestContinuousQueries(Executor executor) throws InterruptedException {         final String msg = ""Test continuous "" + QUERY_TIMES + "" queries "" + TEST_DOMAIN;         for (Network network : getTestableNetworks()) {             for (int i = 0; i < QUERY_TIMES ; ++i) {                 final VerifyCancelInetAddressCallback callback =                         new VerifyCancelInetAddressCallback(msg, null);                 // query v6/v4 in turn                 boolean queryV6 = (i % 2 == 0);                 mDns.query(network, TEST_DOMAIN, queryV6 ? TYPE_AAAA : TYPE_A,                         FLAG_NO_CACHE_LOOKUP, executor, null, callback);                  assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                         callback.waitForAnswer());                 callback.assertNoError();                 assertTrue(msg + "" returned 0 results"", !callback.isAnswerEmpty());                 assertTrue(msg + "" returned "" + (queryV6 ? ""Ipv4"" : ""Ipv6"") + "" results"",                         queryV6 ? !callback.hasIpv4Answer() : !callback.hasIpv6Answer());             }         }     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.wifi.cts.WifiMigrationTest"	"testWifiMigrationSettingsDataBuilder"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"logging"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiMigrationTest.java"	""	"public void testWifiMigrationSettingsDataBuilder() throws Exception {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         WifiMigration.SettingsMigrationData migrationData =                 new WifiMigration.SettingsMigrationData.Builder()                         .setScanAlwaysAvailable(true)                         .setP2pFactoryResetPending(true)                         .setScanThrottleEnabled(true)                         .setSoftApTimeoutEnabled(true)                         .setWakeUpEnabled(true)                         .setVerboseLoggingEnabled(true)                         .setP2pDeviceName(TEST_SSID_UNQUOTED)                         .build();          assertNotNull(migrationData);         assertTrue(migrationData.isScanAlwaysAvailable());         assertTrue(migrationData.isP2pFactoryResetPending());         assertTrue(migrationData.isScanThrottleEnabled());         assertTrue(migrationData.isSoftApTimeoutEnabled());         assertTrue(migrationData.isWakeUpEnabled());         assertTrue(migrationData.isVerboseLoggingEnabled());         assertEquals(TEST_SSID_UNQUOTED, migrationData.getP2pDeviceName());     }      /**      * Tests {@link android.net.wifi.WifiMigration.SettingsMigrationData} class.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.Ikev2VpnTest"	"Ikev2VpnTest"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"/*  *.  */  package android.net.cts;  import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET; import static android.net.NetworkCapabilities.TRANSPORT_VPN; import static android.net.cts.util.CtsNetUtils.TestNetworkCallback;  import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;  import static org.junit.Assert.assertArrayEquals; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.Manifest; import android.annotation.NonNull; import android.app.AppOpsManager; import android.content.Context; import android.content.Intent; import android.net.ConnectivityManager; import android.net.Ikev2VpnProfile; import android.net.IpSecAlgorithm; import android.net.LinkAddress; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkRequest; import android.net.ProxyInfo; import android.net.TestNetworkInterface; import android.net.TestNetworkManager; import android.net.VpnManager; import android.net.cts.util.CtsNetUtils; import android.os.Build; import android.os.Process; import android.platform.test.annotations.AppModeFull;  import androidx.test.InstrumentationRegistry;  import com.android.internal.util.HexDump; import com.android.org.bouncycastle.x509.X509V1CertificateGenerator; import com.android.testutils.DevSdkIgnoreRule.IgnoreUpTo; import com.android.testutils.DevSdkIgnoreRunner;  import org.junit.After; import org.junit.Test; import org.junit.runner.RunWith;  import java.math.BigInteger; import java.net.InetAddress; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PrivateKey; import java.security.cert.X509Certificate; import java.util.Arrays; import java.util.Date; import java.util.List; import java.util.concurrent.TimeUnit;  import javax.security.auth.x500.X500Principal;  @RunWith(DevSdkIgnoreRunner.class) @IgnoreUpTo(Build.VERSION_CODES.Q) @AppModeFull(reason = ""Appops state changes disallowed for instant apps (OP_ACTIVATE_PLATFORM_VPN)"") public class Ikev2VpnTest {     private static final String TAG = Ikev2VpnTest.class.getSimpleName();      // Test vectors for IKE negotiation in test mode.     private static final String SUCCESSFUL_IKE_INIT_RESP_V4 =             ""46b8eca1e0d72a18b2b5d9006d47a0022120222000000000000002d0220000300000002c01010004030000""                     + ""0c0100000c800e0100030000080300000c030000080200000400000008040000102800020800""                     + ""100000b8070f159fe5141d8754ca86f72ecc28d66f514927e96cbe9eec0adb42bf2c276a0ab7""                     + ""a97fa93555f4be9218c14e7f286bb28c6b4fb13825a420f2ffc165854f200bab37d69c8963d4""                     + ""0acb831d983163aa50622fd35c182efe882cf54d6106222abcfaa597255d302f1b95ab71c142""                     + ""c279ea5839a180070bff73f9d03fab815f0d5ee2adec7e409d1e35979f8bd92ffd8aab13d1a0""                     + ""0657d816643ae767e9ae84d2ccfa2bcce1a50572be8d3748ae4863c41ae90da16271e014270f""                     + ""77edd5cd2e3299f3ab27d7203f93d770bacf816041cdcecd0f9af249033979da4369cb242dd9""                     + ""6d172e60513ff3db02de63e50eb7d7f596ada55d7946cad0af0669d1f3e2804846ab3f2a930d""                     + ""df56f7f025f25c25ada694e6231abbb87ee8cfd072c8481dc0b0f6b083fdc3bd89b080e49feb""                     + ""0288eef6fdf8a26ee2fc564a11e7385215cf2deaf2a9965638fc279c908ccdf04094988d91a2""                     + ""464b4a8c0326533aff5119ed79ecbd9d99a218b44f506a5eb09351e67da86698b4c58718db25""                     + ""d55f426fb4c76471b27a41fbce00777bc233c7f6e842e39146f466826de94f564cad8b92bfbe""                     + ""87c99c4c7973ec5f1eea8795e7da82819753aa7c4fcfdab77066c56b939330c4b0d354c23f83""                     + ""ea82fa7a64c4b108f1188379ea0eb4918ee009d804100e6bf118771b9058d42141c847d5ec37""                     + ""6e5ec591c71fc9dac01063c2bd31f9c783b28bf1182900002430f3d5de3449462b31dd28bc27""                     + ""297b6ad169bccce4f66c5399c6e0be9120166f2900001c0000400428b8df2e66f69c8584a186""                     + ""c5eac66783551d49b72900001c000040054e7a622e802d5cbfb96d5f30a6e433994370173529""                     + ""0000080000402e290000100000402f00020003000400050000000800004014"";     private static final String SUCCESSFUL_IKE_INIT_RESP_V6 =             ""46b8eca1e0d72a1800d9ea1babce26bf2120222000000000000002d0220000300000002c01010004030000""                     + ""0c0100000c800e0100030000080300000c030000080200000400000008040000102800020800""                     + ""100000ea0e6dd9ca5930a9a45c323a41f64bfd8cdef7730f5fbff37d7c377da427f489a42aa8""                     + ""c89233380e6e925990d49de35c2cdcf63a61302c731a4b3569df1ee1bf2457e55a6751838ede""                     + ""abb75cc63ba5c9e4355e8e784f383a5efe8a44727dc14aeaf8dacc2620fb1c8875416dc07739""                     + ""7fe4decc1bd514a9c7d270cf21fd734c63a25c34b30b68686e54e8a198f37f27cb491fe27235""                     + ""fab5476b036d875ccab9a68d65fbf3006197f9bebbf94de0d3802b4fafe1d48d931ce3a1a346""                     + ""2d65bd639e9bd7fa46299650a9dbaf9b324e40b466942d91a59f41ef8042f8474c4850ed0f63""                     + ""e9238949d41cd8bbaea9aefdb65443a6405792839563aa5dc5c36b5ce8326ccf8a94d9622b85""                     + ""038d390d5fc0299e14e1f022966d4ac66515f6108ca04faec44821fe5bbf2ed4f84ff5671219""                     + ""608cb4c36b44a31ba010c9088f8d5ff943bb9ff857f74be1755f57a5783874adc57f42bb174e""                     + ""4ad3215de628707014dbcb1707bd214658118fdd7a42b3e1638b991ce5b812a667f1145be811""                     + ""685e3cd3baf9b18d062657b64c206a4d19a531c252a6a51a04aeaf42c618620cdbab65baca23""                     + ""82c57ed888422aeaacf7f1bc3fe2247ff7e7eaca218b74d7b31d02f2b0afa123f802529e7e6c""                     + ""3259d418290740ddbf55686e26998d7edcbbf895664972fed666f2f20af40503aa2af436ec6d""                     + ""4ec981ab19b9088755d94ae7a7c2066ea331d4e56e290000243fefe5555fce552d57a84e682c""                     + ""d4a6dfb3f2f94a94464d5bec3d88b88e9559642900001c00004004eb4afff764e7b79bca78b1""                     + ""3a89100d36d678ae982900001c00004005d177216a3c26f782076e12570d40bfaaa148822929""                     + ""0000080000402e290000100000402f00020003000400050000000800004014"";     private static final String SUCCESSFUL_IKE_AUTH_RESP_V4 =             ""46b8eca1e0d72a18b2b5d9006d47a0022e20232000000001000000e0240000c420a2500a3da4c66fa6929e""                     + ""600f36349ba0e38de14f78a3ad0416cba8c058735712a3d3f9a0a6ed36de09b5e9e02697e7c4""                     + ""2d210ac86cfbd709503cfa51e2eab8cfdc6427d136313c072968f6506a546eb5927164200592""                     + ""6e36a16ee994e63f029432a67bc7d37ca619e1bd6e1678df14853067ecf816b48b81e8746069""                     + ""406363e5aa55f13cb2afda9dbebee94256c29d630b17dd7f1ee52351f92b6e1c3d8551c513f1""                     + ""d74ac52a80b2041397e109fe0aeb3c105b0d4be0ae343a943398764281"";     private static final String SUCCESSFUL_IKE_AUTH_RESP_V6 =             ""46b8eca1e0d72a1800d9ea1babce26bf2e20232000000001000000f0240000d4aaf6eaa6c06b50447e6f54""                     + ""827fd8a9d9d6ac8015c1ebb3e8cb03fc6e54b49a107441f50004027cc5021600828026367f03""                     + ""bc425821cd7772ee98637361300c9b76056e874fea2bd4a17212370b291894264d8c023a01d1""                     + ""c3b691fd4b7c0b534e8c95af4c4638e2d125cb21c6267e2507cd745d72e8da109c47b9259c6c""                     + ""57a26f6bc5b337b9b9496d54bdde0333d7a32e6e1335c9ee730c3ecd607a8689aa7b0577b74f""                     + ""3bf437696a9fd5fc0aee3ed346cd9e15d1dda293df89eb388a8719388a60ca7625754de12cdb""                     + ""efe4c886c5c401"";     private static final long IKE_INITIATOR_SPI = Long.parseLong(""46B8ECA1E0D72A18"", 16);      private static final InetAddress LOCAL_OUTER_4 = InetAddress.parseNumericAddress(""192.0.2.1"");     private static final InetAddress LOCAL_OUTER_6 =             InetAddress.parseNumericAddress(""2001:db8::1"");      private static final int IP4_PREFIX_LEN = 32;     private static final int IP6_PREFIX_LEN = 128;      // TODO: Use IPv6 address when we can generate test vectors (GCE does not allow IPv6 yet).     private static final String TEST_SERVER_ADDR_V4 = ""192.0.2.2"";     private static final String TEST_SERVER_ADDR_V6 = ""2001:db8::2"";     private static final String TEST_IDENTITY = ""client.cts.android.com"";     private static final List<String> TEST_ALLOWED_ALGORITHMS =             Arrays.asList(IpSecAlgorithm.AUTH_CRYPT_AES_GCM);      private static final ProxyInfo TEST_PROXY_INFO =             ProxyInfo.buildDirectProxy(""proxy.cts.android.com"", 1234);     private static final int TEST_MTU = 1300;      private static final byte[] TEST_PSK = ""ikeAndroidPsk"".getBytes();     private static final String TEST_USER = ""username"";     private static final String TEST_PASSWORD = ""pa55w0rd"";      // Static state to reduce setup/teardown     private static final Context sContext = InstrumentationRegistry.getContext();     private static final ConnectivityManager sCM =             (ConnectivityManager) sContext.getSystemService(Context.CONNECTIVITY_SERVICE);     private static final VpnManager sVpnMgr =             (VpnManager) sContext.getSystemService(Context.VPN_MANAGEMENT_SERVICE);     private static final CtsNetUtils mCtsNetUtils = new CtsNetUtils(sContext);      private final X509Certificate mServerRootCa;     private final CertificateAndKey mUserCertKey;      public Ikev2VpnTest() throws Exception {         // Build certificates         mServerRootCa = generateRandomCertAndKeyPair().cert;         mUserCertKey = generateRandomCertAndKeyPair();     }      @After     public void tearDown() {         setAppop(AppOpsManager.OP_ACTIVATE_VPN, false);         setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, false);     }      /**      * Sets the given appop using shell commands      *      * <p>This method must NEVER be called from within a shell permission, as it will attempt to      * acquire, and then drop the shell permission identity. This results in the caller losing the      * shell permission identity due to these calls not being reference counted.      */     public void setAppop(int appop, boolean allow) {         // Requires shell permission to update appops.         runWithShellPermissionIdentity(() -> {             mCtsNetUtils.setAppopPrivileged(appop, allow);         }, Manifest.permission.MANAGE_TEST_NETWORKS);     }      private Ikev2VpnProfile buildIkev2VpnProfileCommon(             Ikev2VpnProfile.Builder builder, boolean isRestrictedToTestNetworks) throws Exception {         if (isRestrictedToTestNetworks) {             builder.restrictToTestNetworks();         }          return builder.setBypassable(true)                 .setAllowedAlgorithms(TEST_ALLOWED_ALGORITHMS)                 .setProxy(TEST_PROXY_INFO)                 .setMaxMtu(TEST_MTU)                 .setMetered(false)                 .build();     }      private Ikev2VpnProfile buildIkev2VpnProfilePsk(boolean isRestrictedToTestNetworks)             throws Exception {         return buildIkev2VpnProfilePsk(TEST_SERVER_ADDR_V6, isRestrictedToTestNetworks);     }      private Ikev2VpnProfile buildIkev2VpnProfilePsk(             String remote, boolean isRestrictedToTestNetworks) throws Exception {         final Ikev2VpnProfile.Builder builder =                 new Ikev2VpnProfile.Builder(remote, TEST_IDENTITY).setAuthPsk(TEST_PSK);          return buildIkev2VpnProfileCommon(builder, isRestrictedToTestNetworks);     }      private Ikev2VpnProfile buildIkev2VpnProfileUsernamePassword(boolean isRestrictedToTestNetworks)             throws Exception {         final Ikev2VpnProfile.Builder builder =                 new Ikev2VpnProfile.Builder(TEST_SERVER_ADDR_V6, TEST_IDENTITY)                         .setAuthUsernamePassword(TEST_USER, TEST_PASSWORD, mServerRootCa);          return buildIkev2VpnProfileCommon(builder, isRestrictedToTestNetworks);     }      private Ikev2VpnProfile buildIkev2VpnProfileDigitalSignature(boolean isRestrictedToTestNetworks)             throws Exception {         final Ikev2VpnProfile.Builder builder =                 new Ikev2VpnProfile.Builder(TEST_SERVER_ADDR_V6, TEST_IDENTITY)                         .setAuthDigitalSignature(                                 mUserCertKey.cert, mUserCertKey.key, mServerRootCa);          return buildIkev2VpnProfileCommon(builder, isRestrictedToTestNetworks);     }      private void checkBasicIkev2VpnProfile(@NonNull Ikev2VpnProfile profile) throws Exception {         assertEquals(TEST_SERVER_ADDR_V6, profile.getServerAddr());         assertEquals(TEST_IDENTITY, profile.getUserIdentity());         assertEquals(TEST_PROXY_INFO, profile.getProxyInfo());         assertEquals(TEST_ALLOWED_ALGORITHMS, profile.getAllowedAlgorithms());         assertTrue(profile.isBypassable());         assertFalse(profile.isMetered());         assertEquals(TEST_MTU, profile.getMaxMtu());         assertFalse(profile.isRestrictedToTestNetworks());     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.Ikev2VpnTest"	"testBuildIkev2VpnProfilePsk"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"public void testBuildIkev2VpnProfilePsk() throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          final Ikev2VpnProfile profile =                 buildIkev2VpnProfilePsk(false /* isRestrictedToTestNetworks */);          checkBasicIkev2VpnProfile(profile);         assertArrayEquals(TEST_PSK, profile.getPresharedKey());          // Verify nothing else is set.         assertNull(profile.getUsername());         assertNull(profile.getPassword());         assertNull(profile.getServerRootCaCert());         assertNull(profile.getRsaPrivateKey());         assertNull(profile.getUserCert());     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.Ikev2VpnTest"	"testBuildIkev2VpnProfileUsernamePassword"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"public void testBuildIkev2VpnProfileUsernamePassword() throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          final Ikev2VpnProfile profile =                 buildIkev2VpnProfileUsernamePassword(false /* isRestrictedToTestNetworks */);          checkBasicIkev2VpnProfile(profile);         assertEquals(TEST_USER, profile.getUsername());         assertEquals(TEST_PASSWORD, profile.getPassword());         assertEquals(mServerRootCa, profile.getServerRootCaCert());          // Verify nothing else is set.         assertNull(profile.getPresharedKey());         assertNull(profile.getRsaPrivateKey());         assertNull(profile.getUserCert());     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.Ikev2VpnTest"	"testBuildIkev2VpnProfileDigitalSignature"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"public void testBuildIkev2VpnProfileDigitalSignature() throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          final Ikev2VpnProfile profile =                 buildIkev2VpnProfileDigitalSignature(false /* isRestrictedToTestNetworks */);          checkBasicIkev2VpnProfile(profile);         assertEquals(mUserCertKey.cert, profile.getUserCert());         assertEquals(mUserCertKey.key, profile.getRsaPrivateKey());         assertEquals(mServerRootCa, profile.getServerRootCaCert());          // Verify nothing else is set.         assertNull(profile.getUsername());         assertNull(profile.getPassword());         assertNull(profile.getPresharedKey());     }      private void verifyProvisionVpnProfile(             boolean hasActivateVpn, boolean hasActivatePlatformVpn, boolean expectIntent)             throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          setAppop(AppOpsManager.OP_ACTIVATE_VPN, hasActivateVpn);         setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, hasActivatePlatformVpn);          final Ikev2VpnProfile profile =                 buildIkev2VpnProfilePsk(false /* isRestrictedToTestNetworks */);         final Intent intent = sVpnMgr.provisionVpnProfile(profile);         assertEquals(expectIntent, intent != null);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.Ikev2VpnTest"	"testDeleteVpnProfile"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"public void testDeleteVpnProfile() throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, true);          final Ikev2VpnProfile profile =                 buildIkev2VpnProfilePsk(false /* isRestrictedToTestNetworks */);         assertNull(sVpnMgr.provisionVpnProfile(profile));          // Verify that deleting the profile works (even without the appop)         setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, false);         sVpnMgr.deleteProvisionedVpnProfile();          // Test that the profile was deleted - starting it should throw an IAE.         try {             setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, true);             sVpnMgr.startProvisionedVpnProfile();             fail(""Expected IllegalArgumentException due to missing profile"");         } catch (IllegalArgumentException expected) {         }     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.Ikev2VpnTest"	"testStartVpnProfileNoPreviousConsent"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/Ikev2VpnTest.java"	""	"public void testStartVpnProfileNoPreviousConsent() throws Exception {         assumeTrue(mCtsNetUtils.hasIpsecTunnelsFeature());          setAppop(AppOpsManager.OP_ACTIVATE_VPN, false);         setAppop(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, false);          // Make sure the VpnProfile is not provisioned already.         sVpnMgr.stopProvisionedVpnProfile();          try {             sVpnMgr.startProvisionedVpnProfile();             fail(""Expected SecurityException for missing consent"");         } catch (SecurityException expected) {         }     }      private void checkStartStopVpnProfileBuildsNetworks(IkeTunUtils tunUtils, boolean testIpv6)             throws Exception {         String serverAddr = testIpv6 ? TEST_SERVER_ADDR_V6 : TEST_SERVER_ADDR_V4;         String initResp = testIpv6 ? SUCCESSFUL_IKE_INIT_RESP_V6 : SUCCESSFUL_IKE_INIT_RESP_V4;         String authResp = testIpv6 ? SUCCESSFUL_IKE_AUTH_RESP_V6 : SUCCESSFUL_IKE_AUTH_RESP_V4;         boolean hasNat = !testIpv6;          // Requires MANAGE_TEST_NETWORKS to provision a test-mode profile.         mCtsNetUtils.setAppopPrivileged(AppOpsManager.OP_ACTIVATE_PLATFORM_VPN, true);          final Ikev2VpnProfile profile =                 buildIkev2VpnProfilePsk(serverAddr, true /* isRestrictedToTestNetworks */);         assertNull(sVpnMgr.provisionVpnProfile(profile));          sVpnMgr.startProvisionedVpnProfile();          // Inject IKE negotiation         int expectedMsgId = 0;         tunUtils.awaitReqAndInjectResp(IKE_INITIATOR_SPI, expectedMsgId++, false /* isEncap */,                 HexDump.hexStringToByteArray(initResp));         tunUtils.awaitReqAndInjectResp(IKE_INITIATOR_SPI, expectedMsgId++, hasNat /* isEncap */,                 HexDump.hexStringToByteArray(authResp));          // Verify the VPN network came up         final NetworkRequest nr = new NetworkRequest.Builder()                 .clearCapabilities().addTransportType(TRANSPORT_VPN).build();          final TestNetworkCallback cb = new TestNetworkCallback();         sCM.requestNetwork(nr, cb);         cb.waitForAvailable();         final Network vpnNetwork = cb.currentNetwork;         assertNotNull(vpnNetwork);          final NetworkCapabilities caps = sCM.getNetworkCapabilities(vpnNetwork);         assertTrue(caps.hasTransport(TRANSPORT_VPN));         assertTrue(caps.hasCapability(NET_CAPABILITY_INTERNET));         assertEquals(Process.myUid(), caps.getOwnerUid());          sVpnMgr.stopProvisionedVpnProfile();         cb.waitForLost();         assertEquals(vpnNetwork, cb.lastLostNetwork);     }      private void doTestStartStopVpnProfile(boolean testIpv6) throws Exception {         // Non-final; these variables ensure we clean up properly after our test if we have         // allocated test network resources         final TestNetworkManager tnm = sContext.getSystemService(TestNetworkManager.class);         TestNetworkInterface testIface = null;         TestNetworkCallback tunNetworkCallback = null;          try {             // Build underlying test network             testIface = tnm.createTunInterface(                     new LinkAddress[] {                             new LinkAddress(LOCAL_OUTER_4, IP4_PREFIX_LEN),                             new LinkAddress(LOCAL_OUTER_6, IP6_PREFIX_LEN)});              // Hold on to this callback to ensure network does not get reaped.             tunNetworkCallback = mCtsNetUtils.setupAndGetTestNetwork(                     testIface.getInterfaceName());             final IkeTunUtils tunUtils = new IkeTunUtils(testIface.getFileDescriptor());              checkStartStopVpnProfileBuildsNetworks(tunUtils, testIpv6);         } finally {             // Make sure to stop the VPN profile. This is safe to call multiple times.             sVpnMgr.stopProvisionedVpnProfile();              if (testIface != null) {                 testIface.getFileDescriptor().close();             }              if (tunNetworkCallback != null) {                 sCM.unregisterNetworkCallback(tunNetworkCallback);             }              final Network testNetwork = tunNetworkCallback.currentNetwork;             if (testNetwork != null) {                 tnm.teardownTestNetwork(testNetwork);             }         }     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.wifi.cts.WifiManagerTest"	"ProvisioningCallback"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"logging"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void test/*  *.  */  package android.net.wifi.cts;  import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED; import static android.net.NetworkCapabilities.TRANSPORT_WIFI; import static android.net.wifi.WifiConfiguration.INVALID_NETWORK_ID;  import static com.google.common.truth.Truth.assertWithMessage;  import static org.junit.Assert.assertNotEquals;  import android.app.UiAutomation; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.pm.ResolveInfo; import android.net.ConnectivityManager; import android.net.LinkProperties; import android.net.MacAddress; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkInfo; import android.net.NetworkRequest; import android.net.TetheringManager; import android.net.Uri; import android.net.util.MacAddressUtils; import android.net.wifi.ScanResult; import android.net.wifi.SoftApCapability; import android.net.wifi.SoftApConfiguration; import android.net.wifi.SoftApInfo; import android.net.wifi.WifiClient; import android.net.wifi.WifiConfiguration; import android.net.wifi.WifiInfo; import android.net.wifi.WifiManager; import android.net.wifi.WifiManager.WifiLock; import android.net.wifi.WifiNetworkConnectionStatistics; import android.net.wifi.WifiNetworkSuggestion; import android.net.wifi.hotspot2.ConfigParser; import android.net.wifi.hotspot2.OsuProvider; import android.net.wifi.hotspot2.PasspointConfiguration; import android.net.wifi.hotspot2.ProvisioningCallback; import android.net.wifi.hotspot2.pps.Credential; import android.net.wifi.hotspot2.pps.HomeSp; import android.os.Handler; import android.os.HandlerExecutor; import android.os.HandlerThread; import android.os.Process; import android.os.SystemClock; import android.os.UserHandle; import android.platform.test.annotations.AppModeFull; import android.provider.Settings; import android.support.test.uiautomator.UiDevice; import android.telephony.TelephonyManager; import android.test.AndroidTestCase; import android.text.TextUtils; import android.util.ArraySet; import android.util.Log;  import androidx.test.platform.app.InstrumentationRegistry;  import com.android.compatibility.common.util.PollingCheck; import com.android.compatibility.common.util.ShellIdentityUtils; import com.android.compatibility.common.util.SystemUtil; import com.android.compatibility.common.util.FeatureUtil; import com.android.compatibility.common.util.ThrowingRunnable;  import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.lang.reflect.Constructor; import java.net.HttpURLConnection; import java.net.InetAddress; import java.net.URL; import java.util.ArrayList; import java.util.Arrays; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Locale; import java.util.Map; import java.util.Objects; import java.util.Set; import java.util.concurrent.ConcurrentLinkedQueue; import java.util.concurrent.CountDownLatch; import java.util.concurrent.Executor; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.stream.Collectors;  @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"") public class WifiManagerTest extends WifiJUnit3TestBase {     private static class MySync {         int expectedState = STATE_NULL;     }      private WifiManager mWifiManager;     private ConnectivityManager mConnectivityManager;     private TetheringManager mTetheringManager;     private WifiLock mWifiLock;     private static MySync mMySync;     private List<ScanResult> mScanResults = null;     private NetworkInfo mNetworkInfo;     private final Object mLock = new Object();     private UiDevice mUiDevice;     private boolean mWasVerboseLoggingEnabled;     private boolean mWasScanThrottleEnabled;     private SoftApConfiguration mOriginalSoftApConfig = null;      // Please refer to WifiManager     private static final int MIN_RSSI = -100;     private static final int MAX_RSSI = -55;      private static final int STATE_NULL = 0;     private static final int STATE_WIFI_CHANGING = 1;     private static final int STATE_WIFI_ENABLED = 2;     private static final int STATE_WIFI_DISABLED = 3;     private static final int STATE_SCANNING = 4;     private static final int STATE_SCAN_DONE = 5;      private static final String TAG = ""WifiManagerTest"";     private static final String SSID1 = ""\""WifiManagerTest\"""";     // A full single scan duration is about 6-7 seconds if country code is set     // to US. If country code is set to world mode (00), we would expect a scan     // duration of roughly 8 seconds. So we set scan timeout as 9 seconds here.     private static final int SCAN_TEST_WAIT_DURATION_MS = 9000;     private static final int TEST_WAIT_DURATION_MS = 10_000;     private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;     private static final int WAIT_MSEC = 60;     private static final int DURATION_SCREEN_TOGGLE = 2000;     private static final int DURATION_SETTINGS_TOGGLE = 1_000;     private static final int WIFI_SCAN_TEST_INTERVAL_MILLIS = 60 * 1000;     private static final int WIFI_SCAN_TEST_CACHE_DELAY_MILLIS = 3 * 60 * 1000;     private static final int WIFI_SCAN_TEST_ITERATIONS = 5;      private static final int ENFORCED_NUM_NETWORK_SUGGESTIONS_PER_APP = 50;      private static final String TEST_PAC_URL = ""http://www.example.com/proxy.pac"";     private static final String MANAGED_PROVISIONING_PACKAGE_NAME             = ""com.android.managedprovisioning"";      private static final String TEST_SSID_UNQUOTED = ""testSsid1"";     private static final String TEST_IP_ADDRESS = ""192.168.5.5"";     private static final String TEST_MAC_ADDRESS = ""aa:bb:cc:dd:ee:ff"";     private static final MacAddress TEST_MAC = MacAddress.fromString(TEST_MAC_ADDRESS);     private static final String TEST_PASSPHRASE = ""passphrase"";     private static final String PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT =             ""assets/ValidPasspointProfile.base64"";     private static final String TYPE_WIFI_CONFIG = ""application/x-wifi-config"";     private static final String TEST_PSK_CAP = ""[RSN-PSK-CCMP]"";     private static final String TEST_BSSID = ""00:01:02:03:04:05"";      private IntentFilter mIntentFilter;     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {         @Override         public void onReceive(Context context, Intent intent) {             final String action = intent.getAction();             if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {                  synchronized (mMySync) {                     if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {                         mScanResults = mWifiManager.getScanResults();                     } else {                         mScanResults = null;                     }                     mMySync.expectedState = STATE_SCAN_DONE;                     mMySync.notifyAll();                 }             } else if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {                 int newState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,                         WifiManager.WIFI_STATE_UNKNOWN);                 synchronized (mMySync) {                     if (newState == WifiManager.WIFI_STATE_ENABLED) {                         Log.d(TAG, ""*** New WiFi state is ENABLED ***"");                         mMySync.expectedState = STATE_WIFI_ENABLED;                         mMySync.notifyAll();                     } else if (newState == WifiManager.WIFI_STATE_DISABLED) {                         Log.d(TAG, ""*** New WiFi state is DISABLED ***"");                         mMySync.expectedState = STATE_WIFI_DISABLED;                         mMySync.notifyAll();                     }                 }             } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {                 synchronized (mMySync) {                     mNetworkInfo =                             (NetworkInfo) intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);                     if (mNetworkInfo.getState() == NetworkInfo.State.CONNECTED)                         mMySync.notifyAll();                 }             }         }     };     // Initialize with an invalid status value (0)     private int mProvisioningStatus = 0;     // Initialize with an invalid status value (0)     private int mProvisioningFailureStatus = 0;     private boolean mProvisioningComplete = false;     private ProvisioningCallback mProvisioningCallback = new ProvisioningCallback() {         @Override         public void onProvisioningFailure(int status) {             synchronized (mLock) {                 mProvisioningFailureStatus = status;                 mLock.notify();             }         }          @Override         public void onProvisioningStatus(int status) {             synchronized (mLock) {                 mProvisioningStatus = status;                 mLock.notify();             }         }          @Override         public void onProvisioningComplete() {             mProvisioningComplete = true;         }     };     private static final String TEST_SSID = ""TEST SSID"";     private static final String TEST_FRIENDLY_NAME = ""Friendly Name"";     private static final Map<String, String> TEST_FRIENDLY_NAMES =             new HashMap<String, String>() {                 {                     put(""en"", TEST_FRIENDLY_NAME);                     put(""kr"", TEST_FRIENDLY_NAME + 2);                     put(""jp"", TEST_FRIENDLY_NAME + 3);                 }             };     private static final String TEST_SERVICE_DESCRIPTION = ""Dummy Service"";     private static final Uri TEST_SERVER_URI = Uri.parse(""https://test.com"");     private static final String TEST_NAI = ""test.access.com"";     private static final List<Integer> TEST_METHOD_LIST =             Arrays.asList(1 /* METHOD_SOAP_XML_SPP */);     private final HandlerThread mHandlerThread = new HandlerThread(""WifiManagerTest"");     protected final Executor mExecutor;     {         mHandlerThread.start();         mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));     }      @Override     protected void setUp() throws Exception {         super.setUp();         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         mMySync = new MySync();         mIntentFilter = new IntentFilter();         mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);         mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);         mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);         mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);         mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);         mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);         mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);         mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);          mContext.registerReceiver(mReceiver, mIntentFilter);         mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);         mConnectivityManager = getContext().getSystemService(ConnectivityManager.class);         mTetheringManager = getContext().getSystemService(TetheringManager.class);         assertNotNull(mWifiManager);         assertNotNull(mTetheringManager);          // turn on verbose logging for tests         mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.isVerboseLoggingEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(true));         // Disable scan throttling for tests.         mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.isScanThrottleEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setScanThrottleEnabled(false));          mWifiLock = mWifiManager.createWifiLock(TAG);         mWifiLock.acquire();         // enable Wifi         if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);         PollingCheck.check(""Wifi not enabled"", TEST_WAIT_DURATION_MS,                 () -> mWifiManager.isWifiEnabled());          mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());         turnScreenOnNoDelay();          synchronized (mMySync) {             mMySync.expectedState = STATE_NULL;         }          List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(                 mWifiManager::getConfiguredNetworks);         assertFalse(""Need at least one saved network"", savedNetworks.isEmpty());          // Get original config for restore         mOriginalSoftApConfig = ShellIdentityUtils.invokeWithShellPermissions(                 mWifiManager::getSoftApConfiguration);     }      @Override     protected void tearDown() throws Exception {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             super.tearDown();             return;         }         if (!mWifiManager.isWifiEnabled())             setWifiEnabled(true);         mWifiLock.release();         mContext.unregisterReceiver(mReceiver);         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));         // restore original softap config         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setSoftApConfiguration(mOriginalSoftApConfig));         Thread.sleep(TEST_WAIT_DURATION_MS);         super.tearDown();     }      private void setWifiEnabled(boolean enable) throws Exception {         synchronized (mMySync) {             if (mWifiManager.isWifiEnabled() != enable) {                 // the new state is different, we expect it to change                 mMySync.expectedState = STATE_WIFI_CHANGING;             } else {                 mMySync.expectedState = (enable ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);             }             // now trigger the change using shell commands.             SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));             waitForExpectedWifiState(enable);         }     }      private void waitForExpectedWifiState(boolean enabled) throws InterruptedException {         synchronized (mMySync) {             long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS;             int expected = (enabled ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);             while (System.currentTimeMillis() < timeout                     && mMySync.expectedState != expected) {                 mMySync.wait(WAIT_MSEC);             }         }     }      // Get the current scan status from sticky broadcast.     private boolean isScanCurrentlyAvailable() {         IntentFilter intentFilter = new IntentFilter();         intentFilter.addAction(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED);         Intent intent = mContext.registerReceiver(null, intentFilter);         assertNotNull(intent);         if (intent.getAction().equals(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED)) {             return intent.getBooleanExtra(WifiManager.EXTRA_SCAN_AVAILABLE, false);         }         return false;     }      private void startScan() throws Exception {         synchronized (mMySync) {             mMySync.expectedState = STATE_SCANNING;             mScanResults = null;             assertTrue(mWifiManager.startScan());             long timeout = System.currentTimeMillis() + SCAN_TEST_WAIT_DURATION_MS;             while (System.currentTimeMillis() < timeout && mMySync.expectedState == STATE_SCANNING)                 mMySync.wait(WAIT_MSEC);         }     }      private void waitForNetworkInfoState(NetworkInfo.State state, int timeoutMillis)             throws Exception {         synchronized (mMySync) {             if (mNetworkInfo.getState() == state) return;             long timeout = System.currentTimeMillis() + timeoutMillis;             while (System.currentTimeMillis() < timeout                     && mNetworkInfo.getState() != state)                 mMySync.wait(WAIT_MSEC);             assertEquals(state, mNetworkInfo.getState());         }     }      private void waitForConnection() throws Exception {         waitForNetworkInfoState(NetworkInfo.State.CONNECTED, WIFI_CONNECT_TIMEOUT_MILLIS);     }      private void waitForDisconnection() throws Exception {         waitForNetworkInfoState(NetworkInfo.State.DISCONNECTED, TEST_WAIT_DURATION_MS);     }      private void ensureNotNetworkInfoState(NetworkInfo.State state) throws Exception {         synchronized (mMySync) {             long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS + WAIT_MSEC;             while (System.currentTimeMillis() < timeout) {                 assertNotEquals(state, mNetworkInfo.getState());                 mMySync.wait(WAIT_MSEC);             }         }     }      private void ensureNotConnected() throws Exception {         ensureNotNetworkInfoState(NetworkInfo.State.CONNECTED);     }      private void ensureNotDisconnected() throws Exception {         ensureNotNetworkInfoState(NetworkInfo.State.DISCONNECTED);     }      private boolean existSSID(String ssid) {         for (final WifiConfiguration w : mWifiManager.getConfiguredNetworks()) {             if (w.SSID.equals(ssid))                 return true;         }         return false;     }      private int findConfiguredNetworks(String SSID, List<WifiConfiguration> networks) {         for (final WifiConfiguration w : networks) {             if (w.SSID.equals(SSID))                 return networks.indexOf(w);         }         return -1;     }      /**      * Test creation of WifiManager Lock.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.wifi.cts.WifiManagerTest"	"testAutoWakeUpEnabled"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"logging"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAutoWakeUpEnabled() throws Exception {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();         Boolean currState = null;         try {             uiAutomation.adoptShellPermissionIdentity();             currState = mWifiManager.isAutoWakeupEnabled();             boolean newState = !currState;             mWifiManager.setAutoWakeupEnabled(newState);             PollingCheck.check(                     ""Wifi settings toggle failed!"",                     DURATION_SETTINGS_TOGGLE,                     () -> mWifiManager.isAutoWakeupEnabled() == newState);             assertEquals(newState, mWifiManager.isAutoWakeupEnabled());         } finally {             if (currState != null) mWifiManager.setAutoWakeupEnabled(currState);             uiAutomation.dropShellPermissionIdentity();         }     }      /**      * Tests {@link WifiManager#setVerboseLoggingEnabled(boolean)} &      * {@link WifiManager#isVerboseLoggingEnabled()}.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.wifi.cts.WifiManagerTest"	"testVerboseLoggingEnabled"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"logging"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testVerboseLoggingEnabled() throws Exception {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();         Boolean currState = null;         try {             uiAutomation.adoptShellPermissionIdentity();             currState = mWifiManager.isVerboseLoggingEnabled();             boolean newState = !currState;             mWifiManager.setVerboseLoggingEnabled(newState);             PollingCheck.check(                     ""Wifi settings toggle failed!"",                     DURATION_SETTINGS_TOGGLE,                     () -> mWifiManager.isVerboseLoggingEnabled() == newState);             assertEquals(newState, mWifiManager.isVerboseLoggingEnabled());         } finally {             if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);             uiAutomation.dropShellPermissionIdentity();         }     }      /**      * Tests {@link WifiManager#factoryReset()} cannot be invoked from a non-privileged app.      *      * Note: This intentionally does not test the full reset functionality because it causes      * the existing saved networks on the device to be lost after the test. If you add the      * networks back after reset, the ownership of saved networks will change.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.wifi.cts.ConcurrencyTest"	"ActionListener"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"logging"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	"public void test/*  *.  */  package android.net.wifi.cts;  import static org.junit.Assert.assertNotEquals;  import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.content.pm.PackageManager; import android.net.ConnectivityManager; import android.net.ConnectivityManager.NetworkCallback; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkInfo; import android.net.NetworkRequest; import android.net.wifi.WifiManager; import android.net.wifi.p2p.WifiP2pDevice; import android.net.wifi.p2p.WifiP2pGroup; import android.net.wifi.p2p.WifiP2pGroupList; import android.net.wifi.p2p.WifiP2pInfo; import android.net.wifi.p2p.WifiP2pManager; import android.net.wifi.p2p.nsd.WifiP2pServiceInfo; import android.net.wifi.p2p.nsd.WifiP2pUpnpServiceInfo; import android.provider.Settings; import android.platform.test.annotations.AppModeFull; import android.test.AndroidTestCase; import android.util.Log;  import com.android.compatibility.common.util.ShellIdentityUtils; import com.android.compatibility.common.util.SystemUtil;  import java.util.Arrays; import java.util.ArrayList; import java.util.BitSet; import java.util.LinkedList; import java.util.List; import java.util.concurrent.CountDownLatch; import java.util.concurrent.TimeUnit; import java.util.stream.Collectors;  @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"") public class ConcurrencyTest extends WifiJUnit3TestBase {     private class MySync {         static final int WIFI_STATE = 0;         static final int P2P_STATE = 1;         static final int DISCOVERY_STATE = 2;         static final int NETWORK_INFO = 3;          public BitSet pendingSync = new BitSet();          public int expectedWifiState;         public int expectedP2pState;         public int expectedDiscoveryState;         public NetworkInfo expectedNetworkInfo;     }      private class MyResponse {         public boolean valid = false;          public boolean success;         public int failureReason;         public int p2pState;         public int discoveryState;         public NetworkInfo networkInfo;         public WifiP2pInfo p2pInfo;         public String deviceName;         public WifiP2pGroupList persistentGroups;         public WifiP2pGroup group = new WifiP2pGroup();     }      private WifiManager mWifiManager;     private WifiP2pManager mWifiP2pManager;     private WifiP2pManager.Channel mWifiP2pChannel;     private MySync mMySync = new MySync();     private MyResponse mMyResponse = new MyResponse();     private boolean mWasVerboseLoggingEnabled;      private static final String TAG = ""ConcurrencyTest"";     private static final int TIMEOUT_MSEC = 6000;     private static final int WAIT_MSEC = 60;     private static final int DURATION = 10000;     private IntentFilter mIntentFilter;     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {         @Override         public void onReceive(Context context, Intent intent) {             final String action = intent.getAction();             if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {                 synchronized (mMySync) {                     mMySync.pendingSync.set(MySync.WIFI_STATE);                     mMySync.expectedWifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,                             WifiManager.WIFI_STATE_DISABLED);                     mMySync.notify();                 }             } else if(action.equals(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)) {                 synchronized (mMySync) {                     mMySync.pendingSync.set(MySync.P2P_STATE);                     mMySync.expectedP2pState = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE,                             WifiP2pManager.WIFI_P2P_STATE_DISABLED);                     mMySync.notify();                 }             } else if (action.equals(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION)) {                 synchronized (mMySync) {                     mMySync.pendingSync.set(MySync.DISCOVERY_STATE);                     mMySync.expectedDiscoveryState = intent.getIntExtra(                             WifiP2pManager.EXTRA_DISCOVERY_STATE,                             WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED);                     mMySync.notify();                 }             } else if (action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)) {                 synchronized (mMySync) {                     mMySync.pendingSync.set(MySync.NETWORK_INFO);                     mMySync.expectedNetworkInfo = (NetworkInfo) intent.getExtra(                             WifiP2pManager.EXTRA_NETWORK_INFO, null);                     Log.d(TAG, ""Get WIFI_P2P_CONNECTION_CHANGED_ACTION: ""                             + mMySync.expectedNetworkInfo);                     mMySync.notify();                 }             }         }     };      private WifiP2pManager.ActionListener mActionListener = new WifiP2pManager.ActionListener() {         @Override         public void onSuccess() {             synchronized (mMyResponse) {                 mMyResponse.valid = true;                 mMyResponse.success = true;                 mMyResponse.notify();             }         }          @Override         public void onFailure(int reason) {             synchronized (mMyResponse) {                 Log.d(TAG, ""failure reason: "" + reason);                 mMyResponse.valid = true;                 mMyResponse.success = false;                 mMyResponse.failureReason = reason;                 mMyResponse.notify();             }         }     };      @Override     protected void setUp() throws Exception {        super.setUp();        if (!WifiFeature.isWifiSupported(getContext()) &&                 !WifiFeature.isP2pSupported(getContext())) {             // skip the test if WiFi && p2p are not supported             return;         }          mIntentFilter = new IntentFilter();         mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);         mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);         mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION);         mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);          mContext.registerReceiver(mReceiver, mIntentFilter);         mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);         assertNotNull(mWifiManager);         if (mWifiManager.isWifiEnabled()) {             SystemUtil.runShellCommand(""svc wifi disable"");             Thread.sleep(DURATION);         }          // turn on verbose logging for tests         mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.isVerboseLoggingEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(true));          assertTrue(!mWifiManager.isWifiEnabled());         mMySync.expectedWifiState = WifiManager.WIFI_STATE_DISABLED;         mMySync.expectedP2pState = WifiP2pManager.WIFI_P2P_STATE_DISABLED;         mMySync.expectedDiscoveryState = WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED;         mMySync.expectedNetworkInfo = null;     }      @Override     protected void tearDown() throws Exception {         if (!WifiFeature.isWifiSupported(getContext()) &&                 !WifiFeature.isP2pSupported(getContext())) {             // skip the test if WiFi and p2p are not supported             super.tearDown();             return;         }         mContext.unregisterReceiver(mReceiver);          ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));          enableWifi();         super.tearDown();     }      private boolean waitForBroadcasts(List<Integer> waitSyncList) {         synchronized (mMySync) {             long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;             while (System.currentTimeMillis() < timeout) {                 List<Integer> handledSyncList = waitSyncList.stream()                         .filter(w -> mMySync.pendingSync.get(w))                         .collect(Collectors.toList());                 handledSyncList.forEach(w -> mMySync.pendingSync.clear(w));                 waitSyncList.removeAll(handledSyncList);                 if (waitSyncList.isEmpty()) {                     break;                 }                 try {                     mMySync.wait(WAIT_MSEC);                 } catch (InterruptedException e) { }             }             if (!waitSyncList.isEmpty()) {                 Log.i(TAG, ""Missing broadcast: "" + waitSyncList);             }             return waitSyncList.isEmpty();         }     }      private boolean waitForBroadcasts(int waitSingleSync) {         return waitForBroadcasts(                 new LinkedList<Integer>(Arrays.asList(waitSingleSync)));     }      private boolean waitForServiceResponse(MyResponse waitResponse) {         synchronized (waitResponse) {             long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;             while (System.currentTimeMillis() < timeout) {                 try {                     waitResponse.wait(WAIT_MSEC);                 } catch (InterruptedException e) { }                  if (waitResponse.valid) {                     return true;                 }             }             return false;         }     }      // Return true if location is enabled.     private boolean isLocationEnabled() {         return Settings.Secure.getInt(getContext().getContentResolver(),                 Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF)                 != Settings.Secure.LOCATION_MODE_OFF;     }      // Returns true if the device has location feature.     private boolean hasLocationFeature() {         return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION);     }      private void resetResponse(MyResponse responseObj) {         synchronized (responseObj) {             responseObj.valid = false;             responseObj.networkInfo = null;             responseObj.p2pInfo = null;             responseObj.deviceName = null;             responseObj.persistentGroups = null;             responseObj.group = null;         }     }      /*      * Enables Wifi and block until connection is established.      */     private void enableWifi() throws InterruptedException {         if (!mWifiManager.isWifiEnabled()) {             SystemUtil.runShellCommand(""svc wifi enable"");         }          ConnectivityManager cm =             (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);         NetworkRequest request =             new NetworkRequest.Builder().addTransportType(NetworkCapabilities.TRANSPORT_WIFI)                                         .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                                         .build();         final CountDownLatch latch = new CountDownLatch(1);         NetworkCallback networkCallback = new NetworkCallback() {             @Override             public void onAvailable(Network network) {                 latch.countDown();             }         };         cm.registerNetworkCallback(request, networkCallback);         latch.await(DURATION, TimeUnit.MILLISECONDS);          cm.unregisterNetworkCallback(networkCallback);     }      private boolean setupWifiP2p() {         // Cannot support p2p alone         if (!WifiFeature.isWifiSupported(getContext())) {             assertTrue(!WifiFeature.isP2pSupported(getContext()));             return false;         }          if (!WifiFeature.isP2pSupported(getContext())) {             // skip the test if p2p is not supported             return false;         }          if (!hasLocationFeature()) {             Log.d(TAG, ""Skipping test as location is not supported"");             return false;         }         if (!isLocationEnabled()) {             fail(""Please enable location for this test - since P-release WiFi Direct""                     + "" needs Location enabled."");         }          mWifiP2pManager =                 (WifiP2pManager) getContext().getSystemService(Context.WIFI_P2P_SERVICE);         mWifiP2pChannel = mWifiP2pManager.initialize(                 getContext(), getContext().getMainLooper(), null);          assertNotNull(mWifiP2pManager);         assertNotNull(mWifiP2pChannel);          long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;         while (!mWifiManager.isWifiEnabled() && System.currentTimeMillis() < timeout) {             try {                 enableWifi();             } catch (InterruptedException e) { }         }          assertTrue(mWifiManager.isWifiEnabled());          assertTrue(waitForBroadcasts(                 new LinkedList<Integer>(                 Arrays.asList(MySync.WIFI_STATE, MySync.P2P_STATE))));          assertEquals(WifiManager.WIFI_STATE_ENABLED, mMySync.expectedWifiState);         assertEquals(WifiP2pManager.WIFI_P2P_STATE_ENABLED, mMySync.expectedP2pState);          assertTrue(waitForBroadcasts(MySync.NETWORK_INFO));         // wait for changing to EnabledState         assertNotNull(mMySync.expectedNetworkInfo);          return true;     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.HostsideRestrictBackgroundNetworkTests"	"testDataSaverMode_disabled"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/src/com/android/cts/net/HostsideRestrictBackgroundNetworkTests.java"	""	"public void testDataSaverMode_disabled() throws Exception {         runDeviceTests(TEST_PKG, TEST_PKG + "".DataSaverModeTest"",                 ""testGetRestrictBackgroundStatus_disabled"");     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.HostsideRestrictBackgroundNetworkTests"	"testDataSaverMode_whitelisted"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/src/com/android/cts/net/HostsideRestrictBackgroundNetworkTests.java"	""	"public void testDataSaverMode_whitelisted() throws Exception {         runDeviceTests(TEST_PKG, TEST_PKG + "".DataSaverModeTest"",                 ""testGetRestrictBackgroundStatus_whitelisted"");     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.HostsideRestrictBackgroundNetworkTests"	"testDataSaverMode_enabled"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/src/com/android/cts/net/HostsideRestrictBackgroundNetworkTests.java"	""	"public void testDataSaverMode_enabled() throws Exception {         runDeviceTests(TEST_PKG, TEST_PKG + "".DataSaverModeTest"",                 ""testGetRestrictBackgroundStatus_enabled"");     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.HostsideRestrictBackgroundNetworkTests"	"testDataSaverMode_blacklisted"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/src/com/android/cts/net/HostsideRestrictBackgroundNetworkTests.java"	""	"public void testDataSaverMode_blacklisted() throws Exception {         runDeviceTests(TEST_PKG, TEST_PKG + "".DataSaverModeTest"",                 ""testGetRestrictBackgroundStatus_blacklisted"");     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.HostsideRestrictBackgroundNetworkTests"	"testDataSaverMode_reinstall"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/src/com/android/cts/net/HostsideRestrictBackgroundNetworkTests.java"	""	"public void testDataSaverMode_reinstall() throws Exception {         final int oldUid = getUid(TEST_APP2_PKG);          // Make sure whitelist is revoked when package is removed         addRestrictBackgroundWhitelist(oldUid);          uninstallPackage(TEST_APP2_PKG, true);         assertPackageUninstalled(TEST_APP2_PKG);         assertRestrictBackgroundWhitelist(oldUid, false);          installPackage(TEST_APP2_APK);         final int newUid = getUid(TEST_APP2_PKG);         assertRestrictBackgroundWhitelist(oldUid, false);         assertRestrictBackgroundWhitelist(newUid, false);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.HostsideRestrictBackgroundNetworkTests"	"testDataSaverMode_requiredWhitelistedPackages"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/src/com/android/cts/net/HostsideRestrictBackgroundNetworkTests.java"	""	"public void testDataSaverMode_requiredWhitelistedPackages() throws Exception {         runDeviceTests(TEST_PKG, TEST_PKG + "".DataSaverModeTest"",                 ""testGetRestrictBackgroundStatus_requiredWhitelistedPackages"");     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.HostsideRestrictBackgroundNetworkTests"	"testAppIdleAndBatterySaver_tempPowerSaveAndAppIdleWhitelists"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/src/com/android/cts/net/HostsideRestrictBackgroundNetworkTests.java"	""	"public void testAppIdleAndBatterySaver_tempPowerSaveAndAppIdleWhitelists() throws Exception {         runDeviceTests(TEST_PKG, TEST_PKG + "".MixedModesTest"",                 ""testAppIdleAndBatterySaver_tempPowerSaveAndAppIdleWhitelists"");     }      /*******************      * Helper methods. *      *******************/      private void assertRestrictBackgroundWhitelist(int uid, boolean expected) throws Exception {         final int max_tries = 5;         boolean actual = false;         for (int i = 1; i <= max_tries; i++) {             final String output = runCommand(""cmd netpolicy list restrict-background-whitelist "");             actual = output.contains(Integer.toString(uid));             if (expected == actual) {                 return;             }             Log.v(TAG, ""whitelist check for uid "" + uid + "" doesn't match yet (expected ""                     + expected + "", got "" + actual + ""); sleeping 1s before polling again"");             Thread.sleep(1000);         }         fail(""whitelist check for uid "" + uid + "" failed: expected ""                 + expected + "", got "" + actual);     }      private void assertPowerSaveModeWhitelist(String packageName, boolean expected)             throws Exception {         // TODO: currently the power-save mode is behaving like idle, but once it changes, we'll         // need to use netpolicy for whitelisting         assertDelayedCommand(""dumpsys deviceidle whitelist ="" + packageName,                 Boolean.toString(expected));     }      /**      * Asserts the result of a command, wait and re-running it a couple times if necessary.      */     private void assertDelayedCommand(String command, String expectedResult)             throws InterruptedException, DeviceNotAvailableException {         final int maxTries = 5;         for (int i = 1; i <= maxTries; i++) {             final String result = runCommand(command).trim();             if (result.equals(expectedResult)) return;             Log.v(TAG, ""Command '"" + command + ""' returned '"" + result + "" instead of '""                     + expectedResult + ""' on attempt #; sleeping 1s before polling again"");             Thread.sleep(1000);         }         fail(""Command '"" + command + ""' did not return '"" + expectedResult + ""' after "" + maxTries                 + "" attempts"");     }      protected void addRestrictBackgroundWhitelist(int uid) throws Exception {         runCommand(""cmd netpolicy add restrict-background-whitelist "" + uid);         assertRestrictBackgroundWhitelist(uid, true);     }      private void addPowerSaveModeWhitelist(String packageName) throws Exception {         Log.i(TAG, ""Adding package "" + packageName + "" to power-save-mode whitelist"");         // TODO: currently the power-save mode is behaving like idle, but once it changes, we'll         // need to use netpolicy for whitelisting         runCommand(""dumpsys deviceidle whitelist +"" + packageName);         assertPowerSaveModeWhitelist(packageName, true); // Sanity check     }      protected boolean isDozeModeEnabled() throws Exception {         final String result = runCommand(""cmd deviceidle enabled deep"").trim();         return result.equals(""1"");     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.NetworkCallbackTest"	"TestNetworkCallback"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/NetworkCallbackTest.java"	""	"/*  *.  */  package com.android.cts.net.hostside;  import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED; import static com.android.cts.net.hostside.NetworkPolicyTestUtils.canChangeActiveNetworkMeteredness; import static com.android.cts.net.hostside.NetworkPolicyTestUtils.setRestrictBackground; import static com.android.cts.net.hostside.NetworkPolicyTestUtils.isActiveNetworkMetered; import static com.android.cts.net.hostside.Property.BATTERY_SAVER_MODE; import static com.android.cts.net.hostside.Property.DATA_SAVER_MODE;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.net.Network; import android.net.NetworkCapabilities; import android.util.Log;  import org.junit.After; import org.junit.Before; import org.junit.Rule; import org.junit.Test;  import java.util.Objects; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.TimeUnit;  public class NetworkCallbackTest extends AbstractRestrictBackgroundNetworkTestCase {     private Network mNetwork;     private final TestNetworkCallback mTestNetworkCallback = new TestNetworkCallback();     @Rule     public final MeterednessConfigurationRule mMeterednessConfiguration             = new MeterednessConfigurationRule();      enum CallbackState {         NONE,         AVAILABLE,         LOST,         BLOCKED_STATUS,         CAPABILITIES     }      private static class CallbackInfo {         public final CallbackState state;         public final Network network;         public final Object arg;          CallbackInfo(CallbackState s, Network n, Object o) {             state = s; network = n; arg = o;         }          public String toString() {             return String.format(""%s (%s) (%s)"", state, network, arg);         }          @Override         public boolean equals(Object o) {             if (!(o instanceof CallbackInfo)) return false;             // Ignore timeMs, since it's unpredictable.             final CallbackInfo other = (CallbackInfo) o;             return (state == other.state) && Objects.equals(network, other.network)                     && Objects.equals(arg, other.arg);         }          @Override         public int hashCode() {             return Objects.hash(state, network, arg);         }     }      private class TestNetworkCallback extends INetworkCallback.Stub {         private static final int TEST_CONNECT_TIMEOUT_MS = 30_000;         private static final int TEST_CALLBACK_TIMEOUT_MS = 5_000;          private final LinkedBlockingQueue<CallbackInfo> mCallbacks = new LinkedBlockingQueue<>();          protected void setLastCallback(CallbackState state, Network network, Object o) {             mCallbacks.offer(new CallbackInfo(state, network, o));         }          CallbackInfo nextCallback(int timeoutMs) {             CallbackInfo cb = null;             try {                 cb = mCallbacks.poll(timeoutMs, TimeUnit.MILLISECONDS);             } catch (InterruptedException e) {             }             if (cb == null) {                 fail(""Did not receive callback after "" + timeoutMs + ""ms"");             }             return cb;         }          CallbackInfo expectCallback(CallbackState state, Network expectedNetwork, Object o) {             final CallbackInfo expected = new CallbackInfo(state, expectedNetwork, o);             final CallbackInfo actual = nextCallback(TEST_CALLBACK_TIMEOUT_MS);             assertEquals(""Unexpected callback:"", expected, actual);             return actual;         }          @Override         public void onAvailable(Network network) {             setLastCallback(CallbackState.AVAILABLE, network, null);         }          @Override         public void onLost(Network network) {             setLastCallback(CallbackState.LOST, network, null);         }          @Override         public void onBlockedStatusChanged(Network network, boolean blocked) {             setLastCallback(CallbackState.BLOCKED_STATUS, network, blocked);         }          @Override         public void onCapabilitiesChanged(Network network, NetworkCapabilities cap) {             setLastCallback(CallbackState.CAPABILITIES, network, cap);         }          public Network expectAvailableCallbackAndGetNetwork() {             final CallbackInfo cb = nextCallback(TEST_CONNECT_TIMEOUT_MS);             if (cb.state != CallbackState.AVAILABLE) {                 fail(""Network is not available. Instead obtained the following callback :""                         + cb);             }             return cb.network;         }          public void expectBlockedStatusCallback(Network expectedNetwork, boolean expectBlocked) {             expectCallback(CallbackState.BLOCKED_STATUS, expectedNetwork, expectBlocked);         }          public void expectBlockedStatusCallbackEventually(Network expectedNetwork,                 boolean expectBlocked) {             final long deadline = System.currentTimeMillis() + TEST_CALLBACK_TIMEOUT_MS;             do {                 final CallbackInfo cb = nextCallback((int) (deadline - System.currentTimeMillis()));                 if (cb.state == CallbackState.BLOCKED_STATUS                         && cb.network.equals(expectedNetwork)) {                     assertEquals(expectBlocked, cb.arg);                     return;                 }             } while (System.currentTimeMillis() <= deadline);             fail(""Didn't receive onBlockedStatusChanged()"");         }          public void expectCapabilitiesCallbackEventually(Network expectedNetwork, boolean hasCap,                 int cap) {             final long deadline = System.currentTimeMillis() + TEST_CALLBACK_TIMEOUT_MS;             do {                 final CallbackInfo cb = nextCallback((int) (deadline - System.currentTimeMillis()));                 if (cb.state != CallbackState.CAPABILITIES                         || !expectedNetwork.equals(cb.network)                         || (hasCap != ((NetworkCapabilities) cb.arg).hasCapability(cap))) {                     Log.i(""NetworkCallbackTest#expectCapabilitiesCallback"",                             ""Ignoring non-matching callback : "" + cb);                     continue;                 }                 // Found a match, return                 return;             } while (System.currentTimeMillis() <= deadline);             fail(""Didn't receive the expected callback to onCapabilitiesChanged(). Check the ""                     + ""log for a list of received callbacks, if any."");         }     }      @Before     public void setUp() throws Exception {         super.setUp();          assumeTrue(isActiveNetworkMetered(true) || canChangeActiveNetworkMeteredness());          registerBroadcastReceiver();          removeRestrictBackgroundWhitelist(mUid);         removeRestrictBackgroundBlacklist(mUid);         assertRestrictBackgroundChangedReceived(0);          // Initial state         setBatterySaverMode(false);         setRestrictBackground(false);          // Make wifi a metered network.         mMeterednessConfiguration.configureNetworkMeteredness(true);          // Register callback         registerNetworkCallback((INetworkCallback.Stub) mTestNetworkCallback);         // Once the wifi is marked as metered, the wifi will reconnect. Wait for onAvailable()         // callback to ensure wifi is connected before the test and store the default network.         mNetwork = mTestNetworkCallback.expectAvailableCallbackAndGetNetwork();         // Check that the network is metered.         mTestNetworkCallback.expectCapabilitiesCallbackEventually(mNetwork,                 false /* hasCapability */, NET_CAPABILITY_NOT_METERED);         mTestNetworkCallback.expectBlockedStatusCallback(mNetwork, false);     }      @After     public void tearDown() throws Exception {         super.tearDown();          setRestrictBackground(false);         setBatterySaverMode(false);         unregisterNetworkCallback();     }      @RequiredProperties({DATA_SAVER_MODE})"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.NetworkCallbackTest"	"testOnBlockedStatusChanged_dataSaver"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/NetworkCallbackTest.java"	""	"public void testOnBlockedStatusChanged_dataSaver() throws Exception {         try {             // Enable restrict background             setRestrictBackground(true);             assertBackgroundNetworkAccess(false);             mTestNetworkCallback.expectBlockedStatusCallbackEventually(mNetwork, true);              // Add to whitelist             addRestrictBackgroundWhitelist(mUid);             assertBackgroundNetworkAccess(true);             mTestNetworkCallback.expectBlockedStatusCallbackEventually(mNetwork, false);              // Remove from whitelist             removeRestrictBackgroundWhitelist(mUid);             assertBackgroundNetworkAccess(false);             mTestNetworkCallback.expectBlockedStatusCallbackEventually(mNetwork, true);         } finally {             mMeterednessConfiguration.resetNetworkMeteredness();         }          // Set to non-metered network         mMeterednessConfiguration.configureNetworkMeteredness(false);         mTestNetworkCallback.expectCapabilitiesCallbackEventually(mNetwork,                 true /* hasCapability */, NET_CAPABILITY_NOT_METERED);         try {             assertBackgroundNetworkAccess(true);             mTestNetworkCallback.expectBlockedStatusCallbackEventually(mNetwork, false);              // Disable restrict background, should not trigger callback             setRestrictBackground(false);             assertBackgroundNetworkAccess(true);         } finally {             mMeterednessConfiguration.resetNetworkMeteredness();         }     }      @RequiredProperties({BATTERY_SAVER_MODE})"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.AbstractRestrictBackgroundNetworkTestCase"	"finishActivity"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/AbstractRestrictBackgroundNetworkTestCase.java"	""	"Api     public static final int BATTERY_PLUGGED_ANY =             BATTERY_PLUGGED_AC | BATTERY_PLUGGED_USB | BATTERY_PLUGGED_WIRELESS;      private static final String NETWORK_STATUS_SEPARATOR = ""\\|"";     private static final int SECOND_IN_MS = 1000;     static final int NETWORK_TIMEOUT_MS = 15 * SECOND_IN_MS;     private static int PROCESS_STATE_FOREGROUND_SERVICE;      private static final String KEY_NETWORK_STATE_OBSERVER = TEST_PKG + "".observer"";      protected static final int TYPE_COMPONENT_ACTIVTIY = 0;     protected static final int TYPE_COMPONENT_FOREGROUND_SERVICE = 1;      private static final int BATTERY_STATE_TIMEOUT_MS = 5000;     private static final int BATTERY_STATE_CHECK_INTERVAL_MS = 500;      private static final int FOREGROUND_PROC_NETWORK_TIMEOUT_MS = 6000;      // Must be higher than NETWORK_TIMEOUT_MS     private static final int ORDERED_BROADCAST_TIMEOUT_MS = NETWORK_TIMEOUT_MS * 4;      private static final IntentFilter BATTERY_CHANGED_FILTER =             new IntentFilter(Intent.ACTION_BATTERY_CHANGED);      private static final String APP_NOT_FOREGROUND_ERROR = ""app_not_fg"";      protected static final long TEMP_POWERSAVE_WHITELIST_DURATION_MS = 5_000; // 5 sec      protected Context mContext;     protected Instrumentation mInstrumentation;     protected ConnectivityManager mCm;     protected int mUid;     private int mMyUid;     private MyServiceClient mServiceClient;     private String mDeviceIdleConstantsSetting;      @Rule     public final RuleChain mRuleChain = RuleChain.outerRule(new RequiredPropertiesRule())             .around(new MeterednessConfigurationRule());      protected void setUp() throws Exception {          PROCESS_STATE_FOREGROUND_SERVICE = (Integer) ActivityManager.class                 .getDeclaredField(""PROCESS_STATE_FOREGROUND_SERVICE"").get(null);         mInstrumentation = getInstrumentation();         mContext = getContext();         mCm = getConnectivityManager();         mUid = getUid(TEST_APP2_PKG);         mMyUid = getUid(mContext.getPackageName());         mServiceClient = new MyServiceClient(mContext);         mServiceClient.bind();         mDeviceIdleConstantsSetting = ""device_idle_constants"";         executeShellCommand(""cmd netpolicy start-watching "" + mUid);         setAppIdle(false);          Log.i(TAG, ""Apps status:\n""                 + ""\ttest app: uid="" + mMyUid + "", state="" + getProcessStateByUid(mMyUid) + ""\n""                 + ""\tapp2: uid="" + mUid + "", state="" + getProcessStateByUid(mUid));     }      protected void tearDown() throws Exception {         executeShellCommand(""cmd netpolicy stop-watching"");         mServiceClient.unbind();     }      protected int getUid(String packageName) throws Exception {         return mContext.getPackageManager().getPackageUid(packageName, 0);     }      protected void assertRestrictBackgroundChangedReceived(int expectedCount) throws Exception {         assertRestrictBackgroundChangedReceived(DYNAMIC_RECEIVER, expectedCount);         assertRestrictBackgroundChangedReceived(MANIFEST_RECEIVER, 0);     }      protected void assertRestrictBackgroundChangedReceived(String receiverName, int expectedCount)             throws Exception {         int attempts = 0;         int count = 0;         final int maxAttempts = 5;         do {             attempts++;             count = getNumberBroadcastsReceived(receiverName, ACTION_RESTRICT_BACKGROUND_CHANGED);             assertFalse(""Expected count "" + expectedCount + "" but actual is "" + count,                     count > expectedCount);             if (count == expectedCount) {                 break;             }             Log.d(TAG, ""Expecting count "" + expectedCount + "" but actual is "" + count + "" after ""                     + attempts + "" attempts; sleeping ""                     + SLEEP_TIME_SEC + "" seconds before trying again"");             SystemClock.sleep(SLEEP_TIME_SEC * SECOND_IN_MS);         } while (attempts <= maxAttempts);         assertEquals(""Number of expected broadcasts for "" + receiverName + "" not reached after ""                 + maxAttempts * SLEEP_TIME_SEC + "" seconds"", expectedCount, count);     }      protected String sendOrderedBroadcast(Intent intent) throws Exception {         return sendOrderedBroadcast(intent, ORDERED_BROADCAST_TIMEOUT_MS);     }      protected String sendOrderedBroadcast(Intent intent, int timeoutMs) throws Exception {         final LinkedBlockingQueue<String> result = new LinkedBlockingQueue<>(1);         Log.d(TAG, ""Sending ordered broadcast: "" + intent);         mContext.sendOrderedBroadcast(intent, null, new BroadcastReceiver() {              @Override             public void onReceive(Context context, Intent intent) {                 final String resultData = getResultData();                 if (resultData == null) {                     Log.e(TAG, ""Received null data from ordered intent"");                     return;                 }                 result.offer(resultData);             }         }, null, 0, null, null);          final String resultData = result.poll(timeoutMs, TimeUnit.MILLISECONDS);         Log.d(TAG, ""Ordered broadcast response after "" + timeoutMs + ""ms: "" + resultData );         return resultData;     }      protected int getNumberBroadcastsReceived(String receiverName, String action) throws Exception {         return mServiceClient.getCounters(receiverName, action);     }      protected void assertRestrictBackgroundStatus(int expectedStatus) throws Exception {         final String status = mServiceClient.getRestrictBackgroundStatus();         assertNotNull(""didn't get API status from app2"", status);         assertEquals(restrictBackgroundValueToString(expectedStatus),                 restrictBackgroundValueToString(Integer.parseInt(status)));     }      protected void assertBackgroundNetworkAccess(boolean expectAllowed) throws Exception {         assertBackgroundState(); // Sanity check.         assertNetworkAccess(expectAllowed /* expectAvailable */, false /* needScreenOn */);     }      protected void assertForegroundNetworkAccess() throws Exception {         assertForegroundState(); // Sanity check.         // We verified that app is in foreground state but if the screen turns-off while         // verifying for network access, the app will go into background state (in case app's         // foreground status was due to top activity). So, turn the screen on when verifying         // network connectivity.         assertNetworkAccess(true /* expectAvailable */, true /* needScreenOn */);     }      protected void assertForegroundServiceNetworkAccess() throws Exception {         assertForegroundServiceState(); // Sanity check.         assertNetworkAccess(true /* expectAvailable */, false /* needScreenOn */);     }      /**      * Asserts that an app always have access while on foreground or running a foreground service.      *      * <p>This method will launch an activity and a foreground service to make the assertion, but      * will finish the activity / stop the service afterwards.      */     protected void assertsForegroundAlwaysHasNetworkAccess() throws Exception{         // Checks foreground first.         launchComponentAndAssertNetworkAccess(TYPE_COMPONENT_ACTIVTIY);         finishActivity();          // Then foreground service         launchComponentAndAssertNetworkAccess(TYPE_COMPONENT_FOREGROUND_SERVICE);         stopForegroundService();     }      protected final void assertBackgroundState() throws Exception {         final int maxTries = 30;         ProcessState state = null;         for (int i = 1; i <= maxTries; i++) {             state = getProcessStateByUid(mUid);             Log.v(TAG, ""assertBackgroundState(): status for app2 ("" + mUid + "") on attempt #"" + i                     + "": "" + state);             if (isBackground(state.state)) {                 return;             }             Log.d(TAG, ""App not on background state ("" + state + "") on attempt #"" + i                     + ""; sleeping 1s before trying again"");             SystemClock.sleep(SECOND_IN_MS);         }         fail(""App2 is not on background state after "" + maxTries + "" attempts: "" + state );     }      protected final void assertForegroundState() throws Exception {         final int maxTries = 30;         ProcessState state = null;         for (int i = 1; i <= maxTries; i++) {             state = getProcessStateByUid(mUid);             Log.v(TAG, ""assertForegroundState(): status for app2 ("" + mUid + "") on attempt #"" + i                     + "": "" + state);             if (!isBackground(state.state)) {                 return;             }             Log.d(TAG, ""App not on foreground state on attempt #"" + i                     + ""; sleeping 1s before trying again"");             turnScreenOn();             SystemClock.sleep(SECOND_IN_MS);         }         fail(""App2 is not on foreground state after "" + maxTries + "" attempts: "" + state );     }      protected final void assertForegroundServiceState() throws Exception {         final int maxTries = 30;         ProcessState state = null;         for (int i = 1; i <= maxTries; i++) {             state = getProcessStateByUid(mUid);             Log.v(TAG, ""assertForegroundServiceState(): status for app2 ("" + mUid + "") on attempt #""                     + i + "": "" + state);             if (state.state == PROCESS_STATE_FOREGROUND_SERVICE) {                 return;             }             Log.d(TAG, ""App not on foreground service state on attempt #"" + i                     + ""; sleeping 1s before trying again"");             SystemClock.sleep(SECOND_IN_MS);         }         fail(""App2 is not on foreground service state after "" + maxTries + "" attempts: "" + state );     }      /**      * Returns whether an app state should be considered ""background"" for restriction purposes.      */     protected boolean isBackground(int state) {         return state > PROCESS_STATE_FOREGROUND_SERVICE;     }      /**      * Asserts whether the active network is available or not.      */     private void assertNetworkAccess(boolean expectAvailable, boolean needScreenOn)             throws Exception {         final int maxTries = 5;         String error = null;         int timeoutMs = 500;          for (int i = 1; i <= maxTries; i++) {             error = checkNetworkAccess(expectAvailable);              if (error.isEmpty()) return;              // TODO: ideally, it should retry only when it cannot connect to an external site,             // or no retry at all! But, currently, the initial change fails almost always on             // battery saver tests because the netd changes are made asynchronously.             // Once b/27803922 is fixed, this retry mechanism should be revisited.              Log.w(TAG, ""Network status didn't match for expectAvailable="" + expectAvailable                     + "" on attempt #"" + i + "": "" + error + ""\n""                     + ""Sleeping "" + timeoutMs + ""ms before trying again"");             if (needScreenOn) {                 turnScreenOn();             }             // No sleep after the last turn             if (i < maxTries) {                 SystemClock.sleep(timeoutMs);             }             // Exponential back-off.             timeoutMs = Math.min(timeoutMs*2, NETWORK_TIMEOUT_MS);         }         fail(""Invalid state for expectAvailable="" + expectAvailable + "" after "" + maxTries                 + "" attempts.\nLast error: "" + error);     }      /**      * Checks whether the network is available as expected.      *      * @return error message with the mismatch (or empty if assertion passed).      */     private String checkNetworkAccess(boolean expectAvailable) throws Exception {         final String resultData = mServiceClient.checkNetworkStatus();         return checkForAvailabilityInResultData(resultData, expectAvailable);     }      private String checkForAvailabilityInResultData(String resultData, boolean expectAvailable) {         if (resultData == null) {             assertNotNull(""Network status from app2 is null"", resultData);         }         // Network status format is described on MyBroadcastReceiver.checkNetworkStatus()         final String[] parts = resultData.split(NETWORK_STATUS_SEPARATOR);         assertEquals(""Wrong network status: "" + resultData, 5, parts.length); // Sanity check         final State state = parts[0].equals(""null"") ? null : State.valueOf(parts[0]);         final DetailedState detailedState = parts[1].equals(""null"")                 ? null : DetailedState.valueOf(parts[1]);         final boolean connected = Boolean.valueOf(parts[2]);         final String connectionCheckDetails = parts[3];         final String networkInfo = parts[4];          final StringBuilder errors = new StringBuilder();         final State expectedState;         final DetailedState expectedDetailedState;         if (expectAvailable) {             expectedState = State.CONNECTED;             expectedDetailedState = DetailedState.CONNECTED;         } else {             expectedState = State.DISCONNECTED;             expectedDetailedState = DetailedState.BLOCKED;         }          if (expectAvailable != connected) {             errors.append(String.format(""External site connection failed: expected %s, got %s\n"",                     expectAvailable, connected));         }         if (expectedState != state || expectedDetailedState != detailedState) {             errors.append(String.format(""Connection state mismatch: expected %s/%s, got %s/%s\n"",                     expectedState, expectedDetailedState, state, detailedState));         }          if (errors.length() > 0) {             errors.append(""\tnetworkInfo: "" + networkInfo + ""\n"");             errors.append(""\tconnectionCheckDetails: "" + connectionCheckDetails + ""\n"");         }         return errors.toString();     }      /**      * Runs a Shell command which is not expected to generate output.      */     protected void executeSilentShellCommand(String command) {         final String result = executeShellCommand(command);         assertTrue(""Command '"" + command + ""' failed: "" + result, result.trim().isEmpty());     }      /**      * Asserts the result of a command, wait and re-running it a couple times if necessary.      */     protected void assertDelayedShellCommand(String command, final String expectedResult)             throws Exception {         assertDelayedShellCommand(command, 5, 1, expectedResult);     }      protected void assertDelayedShellCommand(String command, int maxTries, int napTimeSeconds,             final String expectedResult) throws Exception {         assertDelayedShellCommand(command, maxTries, napTimeSeconds, new ExpectResultChecker() {              @Override             public boolean isExpected(String result) {                 return expectedResult.equals(result);             }              @Override             public String getExpected() {                 return expectedResult;             }         });     }      protected void assertDelayedShellCommand(String command, int maxTries, int napTimeSeconds,             ExpectResultChecker checker) throws Exception {         String result = """";         for (int i = 1; i <= maxTries; i++) {             result = executeShellCommand(command).trim();             if (checker.isExpected(result)) return;             Log.v(TAG, ""Command '"" + command + ""' returned '"" + result + "" instead of '""                     + checker.getExpected() + ""' on attempt #"" + i                     + ""; sleeping "" + napTimeSeconds + ""s before trying again"");             SystemClock.sleep(napTimeSeconds * SECOND_IN_MS);         }         fail(""Command '"" + command + ""' did not return '"" + checker.getExpected() + ""' after ""                 + maxTries                 + "" attempts. Last result: '"" + result + ""'"");     }      protected void addRestrictBackgroundWhitelist(int uid) throws Exception {         executeShellCommand(""cmd netpolicy add restrict-background-whitelist "" + uid);         assertRestrictBackgroundWhitelist(uid, true);         // UID policies live by the Highlander rule: ""There can be only one"".         // Hence, if app is whitelisted, it should not be blacklisted.         assertRestrictBackgroundBlacklist(uid, false);     }      protected void removeRestrictBackgroundWhitelist(int uid) throws Exception {         executeShellCommand(""cmd netpolicy remove restrict-background-whitelist "" + uid);         assertRestrictBackgroundWhitelist(uid, false);     }      protected void assertRestrictBackgroundWhitelist(int uid, boolean expected) throws Exception {         assertRestrictBackground(""restrict-background-whitelist"", uid, expected);     }      protected void addRestrictBackgroundBlacklist(int uid) throws Exception {         executeShellCommand(""cmd netpolicy add restrict-background-blacklist "" + uid);         assertRestrictBackgroundBlacklist(uid, true);         // UID policies live by the Highlander rule: ""There can be only one"".         // Hence, if app is blacklisted, it should not be whitelisted.         assertRestrictBackgroundWhitelist(uid, false);     }      protected void removeRestrictBackgroundBlacklist(int uid) throws Exception {         executeShellCommand(""cmd netpolicy remove restrict-background-blacklist "" + uid);         assertRestrictBackgroundBlacklist(uid, false);     }      protected void assertRestrictBackgroundBlacklist(int uid, boolean expected) throws Exception {         assertRestrictBackground(""restrict-background-blacklist"", uid, expected);     }      protected void addAppIdleWhitelist(int uid) throws Exception {         executeShellCommand(""cmd netpolicy add app-idle-whitelist "" + uid);         assertAppIdleWhitelist(uid, true);     }      protected void removeAppIdleWhitelist(int uid) throws Exception {         executeShellCommand(""cmd netpolicy remove app-idle-whitelist "" + uid);         assertAppIdleWhitelist(uid, false);     }      protected void assertAppIdleWhitelist(int uid, boolean expected) throws Exception {         assertRestrictBackground(""app-idle-whitelist"", uid, expected);     }      private void assertRestrictBackground(String list, int uid, boolean expected) throws Exception {         final int maxTries = 5;         boolean actual = false;         final String expectedUid = Integer.toString(uid);         String uids = """";         for (int i = 1; i <= maxTries; i++) {             final String output =                     executeShellCommand(""cmd netpolicy list "" + list);             uids = output.split("":"")[1];             for (String candidate : uids.split("" "")) {                 actual = candidate.trim().equals(expectedUid);                 if (expected == actual) {                     return;                 }             }             Log.v(TAG, list + "" check for uid "" + uid + "" doesn't match yet (expected ""                     + expected + "", got "" + actual + ""); sleeping 1s before polling again"");             SystemClock.sleep(SECOND_IN_MS);         }         fail(list + "" check for uid "" + uid + "" failed: expected "" + expected + "", got "" + actual                 + "". Full list: "" + uids);     }      protected void addTempPowerSaveModeWhitelist(String packageName, long duration)             throws Exception {         Log.i(TAG, ""Adding pkg "" + packageName + "" to temp-power-save-mode whitelist"");         executeShellCommand(""dumpsys deviceidle tempwhitelist -d "" + duration + "" "" + packageName);     }      protected void assertPowerSaveModeWhitelist(String packageName, boolean expected)             throws Exception {         // TODO: currently the power-save mode is behaving like idle, but once it changes, we'll         // need to use netpolicy for whitelisting         assertDelayedShellCommand(""dumpsys deviceidle whitelist ="" + packageName,                 Boolean.toString(expected));     }      protected void addPowerSaveModeWhitelist(String packageName) throws Exception {         Log.i(TAG, ""Adding package "" + packageName + "" to power-save-mode whitelist"");         // TODO: currently the power-save mode is behaving like idle, but once it changes, we'll         // need to use netpolicy for whitelisting         executeShellCommand(""dumpsys deviceidle whitelist +"" + packageName);         assertPowerSaveModeWhitelist(packageName, true); // Sanity check     }      protected void removePowerSaveModeWhitelist(String packageName) throws Exception {         Log.i(TAG, ""Removing package "" + packageName + "" from power-save-mode whitelist"");         // TODO: currently the power-save mode is behaving like idle, but once it changes, we'll         // need to use netpolicy for whitelisting         executeShellCommand(""dumpsys deviceidle whitelist -"" + packageName);         assertPowerSaveModeWhitelist(packageName, false); // Sanity check     }      protected void assertPowerSaveModeExceptIdleWhitelist(String packageName, boolean expected)             throws Exception {         // TODO: currently the power-save mode is behaving like idle, but once it changes, we'll         // need to use netpolicy for whitelisting         assertDelayedShellCommand(""dumpsys deviceidle except-idle-whitelist ="" + packageName,                 Boolean.toString(expected));     }      protected void addPowerSaveModeExceptIdleWhitelist(String packageName) throws Exception {         Log.i(TAG, ""Adding package "" + packageName + "" to power-save-mode-except-idle whitelist"");         // TODO: currently the power-save mode is behaving like idle, but once it changes, we'll         // need to use netpolicy for whitelisting         executeShellCommand(""dumpsys deviceidle except-idle-whitelist +"" + packageName);         assertPowerSaveModeExceptIdleWhitelist(packageName, true); // Sanity check     }      protected void removePowerSaveModeExceptIdleWhitelist(String packageName) throws Exception {         Log.i(TAG, ""Removing package "" + packageName                 + "" from power-save-mode-except-idle whitelist"");         // TODO: currently the power-save mode is behaving like idle, but once it changes, we'll         // need to use netpolicy for whitelisting         executeShellCommand(""dumpsys deviceidle except-idle-whitelist reset"");         assertPowerSaveModeExceptIdleWhitelist(packageName, false); // Sanity check     }      protected void turnBatteryOn() throws Exception {         executeSilentShellCommand(""cmd battery unplug"");         executeSilentShellCommand(""cmd battery set status ""                 + BatteryManager.BATTERY_STATUS_DISCHARGING);         assertBatteryState(false);     }      protected void turnBatteryOff() throws Exception {         executeSilentShellCommand(""cmd battery set ac "" + BATTERY_PLUGGED_ANY);         executeSilentShellCommand(""cmd battery set level 100"");         executeSilentShellCommand(""cmd battery set status ""                 + BatteryManager.BATTERY_STATUS_CHARGING);         assertBatteryState(true);     }      private void assertBatteryState(boolean pluggedIn) throws Exception {         final long endTime = SystemClock.elapsedRealtime() + BATTERY_STATE_TIMEOUT_MS;         while (isDevicePluggedIn() != pluggedIn && SystemClock.elapsedRealtime() <= endTime) {             Thread.sleep(BATTERY_STATE_CHECK_INTERVAL_MS);         }         if (isDevicePluggedIn() != pluggedIn) {             fail(""Timed out waiting for the plugged-in state to change,""                     + "" expected pluggedIn: "" + pluggedIn);         }     }      private boolean isDevicePluggedIn() {         final Intent batteryIntent = mContext.registerReceiver(null, BATTERY_CHANGED_FILTER);         return batteryIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1) > 0;     }      protected void turnScreenOff() throws Exception {         executeSilentShellCommand(""input keyevent KEYCODE_SLEEP"");     }      protected void turnScreenOn() throws Exception {         executeSilentShellCommand(""input keyevent KEYCODE_WAKEUP"");         executeSilentShellCommand(""wm dismiss-keyguard"");     }      protected void setBatterySaverMode(boolean enabled) throws Exception {         Log.i(TAG, ""Setting Battery Saver Mode to "" + enabled);         if (enabled) {             turnBatteryOn();             executeSilentShellCommand(""cmd power set-mode 1"");         } else {             executeSilentShellCommand(""cmd power set-mode 0"");             turnBatteryOff();         }     }      protected void setDozeMode(boolean enabled) throws Exception {         // Sanity check, since tests should check beforehand....         assertTrue(""Device does not support Doze Mode"", isDozeModeSupported());          Log.i(TAG, ""Setting Doze Mode to "" + enabled);         if (enabled) {             turnBatteryOn();             turnScreenOff();             executeShellCommand(""dumpsys deviceidle force-idle deep"");         } else {             turnScreenOn();             turnBatteryOff();             executeShellCommand(""dumpsys deviceidle unforce"");         }         // Sanity check.         assertDozeMode(enabled);     }      protected void assertDozeMode(boolean enabled) throws Exception {         assertDelayedShellCommand(""dumpsys deviceidle get deep"", enabled ? ""IDLE"" : ""ACTIVE"");     }      protected void setAppIdle(boolean enabled) throws Exception {         Log.i(TAG, ""Setting app idle to "" + enabled);         executeSilentShellCommand(""am set-inactive "" + TEST_APP2_PKG + "" "" + enabled );         assertAppIdle(enabled); // Sanity check     }      protected void setAppIdleNoAssert(boolean enabled) throws Exception {         Log.i(TAG, ""Setting app idle to "" + enabled);         executeSilentShellCommand(""am set-inactive "" + TEST_APP2_PKG + "" "" + enabled );     }      protected void assertAppIdle(boolean enabled) throws Exception {         try {             assertDelayedShellCommand(""am get-inactive "" + TEST_APP2_PKG, 15, 2, ""Idle="" + enabled);         } catch (Throwable e) {             throw e;         }     }      /**      * Starts a service that will register a broadcast receiver to receive      * {@code RESTRICT_BACKGROUND_CHANGE} intents.      * <p>      * The service must run in a separate app because otherwise it would be killed every time      * {@link #runDeviceTests(String, String)} is executed.      */     protected void registerBroadcastReceiver() throws Exception {         mServiceClient.registerBroadcastReceiver();          final Intent intent = new Intent(ACTION_RECEIVER_READY)                 .addFlags(Intent.FLAG_RECEIVER_FOREGROUND);         // Wait until receiver is ready.         final int maxTries = 10;         for (int i = 1; i <= maxTries; i++) {             final String message = sendOrderedBroadcast(intent, SECOND_IN_MS * 4);             Log.d(TAG, ""app2 receiver acked: "" + message);             if (message != null) {                 return;             }             Log.v(TAG, ""app2 receiver is not ready yet; sleeping 1s before polling again"");             SystemClock.sleep(SECOND_IN_MS);         }         fail(""app2 receiver is not ready"");     }      protected void registerNetworkCallback(INetworkCallback cb) throws Exception {         mServiceClient.registerNetworkCallback(cb);     }      protected void unregisterNetworkCallback() throws Exception {         mServiceClient.unregisterNetworkCallback();     }      /**      * Registers a {@link NotificationListenerService} implementation that will execute the      * notification actions right after the notification is sent.      */     protected void registerNotificationListenerService() throws Exception {         executeShellCommand(""cmd notification allow_listener ""                 + MyNotificationListenerService.getId());         final NotificationManager nm = mContext.getSystemService(NotificationManager.class);         final ComponentName listenerComponent = MyNotificationListenerService.getComponentName();         assertTrue(listenerComponent + "" has not been granted access"",                 nm.isNotificationListenerAccessGranted(listenerComponent));     }      protected void setPendingIntentWhitelistDuration(int durationMs) throws Exception {         executeSilentShellCommand(String.format(                 ""settings put global %s %s=%d"", mDeviceIdleConstantsSetting,                 ""notification_whitelist_duration"", durationMs));     }      protected void resetDeviceIdleSettings() throws Exception {         executeShellCommand(String.format(""settings delete global %s"",                 mDeviceIdleConstantsSetting));     }      protected void launchComponentAndAssertNetworkAccess(int type) throws Exception {         if (type == TYPE_COMPONENT_FOREGROUND_SERVICE) {             startForegroundService();             assertForegroundServiceNetworkAccess();             return;         } else if (type == TYPE_COMPONENT_ACTIVTIY) {             turnScreenOn();             // Wait for screen-on state to propagate through the system.             SystemClock.sleep(2000);             final CountDownLatch latch = new CountDownLatch(1);             final Intent launchIntent = getIntentForComponent(type);             final Bundle extras = new Bundle();             final String[] errors = new String[]{null};             extras.putBinder(KEY_NETWORK_STATE_OBSERVER, getNewNetworkStateObserver(latch, errors));             launchIntent.putExtras(extras);             mContext.startActivity(launchIntent);             if (latch.await(FOREGROUND_PROC_NETWORK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {                 if (!errors[0].isEmpty()) {                     if (errors[0] == APP_NOT_FOREGROUND_ERROR) {                         // App didn't come to foreground when the activity is started, so try again.                         assertForegroundNetworkAccess();                     } else {                         fail(""Network is not available for app2 ("" + mUid + ""): "" + errors[0]);                     }                 }             } else {                 fail(""Timed out waiting for network availability status from app2 ("" + mUid + "")"");             }         } else {             throw new IllegalArgumentException(""Unknown type: "" + type);         }     }      private void startForegroundService() throws Exception {         final Intent launchIntent = getIntentForComponent(TYPE_COMPONENT_FOREGROUND_SERVICE);         mContext.startForegroundService(launchIntent);         assertForegroundServiceState();     }      private Intent getIntentForComponent(int type) {         final Intent intent = new Intent();         if (type == TYPE_COMPONENT_ACTIVTIY) {             intent.setComponent(new ComponentName(TEST_APP2_PKG, TEST_APP2_ACTIVITY_CLASS))                     .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         } else if (type == TYPE_COMPONENT_FOREGROUND_SERVICE) {             intent.setComponent(new ComponentName(TEST_APP2_PKG, TEST_APP2_SERVICE_CLASS))                     .setFlags(1);         } else {             fail(""Unknown type: "" + type);         }         return intent;     }      protected void stopForegroundService() throws Exception {         executeShellCommand(String.format(""am startservice -f 2 %s/%s"",                 TEST_APP2_PKG, TEST_APP2_SERVICE_CLASS));         // NOTE: cannot assert state because it depends on whether activity was on top before.     }      private Binder getNewNetworkStateObserver(final CountDownLatch latch,             final String[] errors) {         return new INetworkStateObserver.Stub() {             @Override             public boolean isForeground() {                 try {                     final ProcessState state = getProcessStateByUid(mUid);                     return !isBackground(state.state);                 } catch (Exception e) {                     Log.d(TAG, ""Error while reading the proc state for "" + mUid + "": "" + e);                     return false;                 }             }              @Override             public void onNetworkStateChecked(String resultData) {                 errors[0] = resultData == null                         ? APP_NOT_FOREGROUND_ERROR                         : checkForAvailabilityInResultData(resultData, true);                 latch.countDown();             }         };     }      /**      * Finishes an activity on app2 so its process is demoted fromforeground status.      */     protected void finishActivity() throws Exception {         executeShellCommand(""am broadcast -a ""                 + "" com.android.cts.net.hostside.app2.action.FINISH_ACTIVITY ""                 + ""--receiver-foreground --receiver-registered-only"");     }      protected void sendNotification(int notificationId, String notificationType) throws Exception {         Log.d(TAG, ""Sending notification broadcast (id="" + notificationId                 + "", type="" + notificationType);         mServiceClient.sendNotification(notificationId, notificationType);     }      protected String showToast() {         final Intent intent = new Intent(ACTION_SHOW_TOAST);         intent.setPackage(TEST_APP2_PKG);         Log.d(TAG, ""Sending request to show toast"");         try {             return sendOrderedBroadcast(intent, 3 * SECOND_IN_MS);         } catch (Exception e) {             return """";         }     }      private ProcessState getProcessStateByUid(int uid) throws Exception {         return new ProcessState(executeShellCommand(""cmd activity get-uid-state "" + uid));     }      private static class ProcessState {         private final String fullState;         final int state;          ProcessState(String fullState) {             this.fullState = fullState;             try {                 this.state = Integer.parseInt(fullState.split("" "")[0]);             } catch (Exception e) {                 throw new IllegalArgumentException(""Could not parse "" + fullState);             }         }          @Override         public String toString() {             return fullState;         }     }      /**      * Helper class used to assert the result of a Shell command.      */     protected static interface ExpectResultChecker {         /**          * Checkes whether the result of the command matched the expectation.          */         boolean isExpected(String result);         /**          * Gets the expected result so it's displayed on log and failure messages.          */         String getExpected();     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"isNotNull"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"logging"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"/*  *.  */  package android.net.wifi.cts;  import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_FAILURE; import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_NO_PROBE; import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_SUCCESS; import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_UNKNOWN;  import static com.google.common.truth.Truth.assertThat; import static com.google.common.truth.Truth.assertWithMessage;  import static org.junit.Assume.assumeTrue;  import android.app.UiAutomation; import android.content.Context; import android.net.wifi.WifiConfiguration; import android.net.wifi.WifiManager; import android.net.wifi.WifiUsabilityStatsEntry; import android.os.Build; import android.platform.test.annotations.AppModeFull; import android.support.test.uiautomator.UiDevice; import android.telephony.TelephonyManager;  import androidx.test.filters.SmallTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.PollingCheck; import com.android.compatibility.common.util.PropertyUtil; import com.android.compatibility.common.util.ShellIdentityUtils; import com.android.compatibility.common.util.SystemUtil;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.List; import java.util.concurrent.CountDownLatch; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit;  /**  * Tests for wifi connected network scorer interface and usability stats.  */ @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"") @SmallTest @RunWith(AndroidJUnit4.class) public class ConnectedNetworkScorerTest extends WifiJUnit4TestBase {     private Context mContext;     private WifiManager mWifiManager;     private UiDevice mUiDevice;     private boolean mWasVerboseLoggingEnabled;      private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;     private static final int DURATION = 10_000;     private static final int DURATION_SCREEN_TOGGLE = 2000;      @Before     public void setUp() throws Exception {         mContext = InstrumentationRegistry.getInstrumentation().getContext();          // skip the test if WiFi is not supported         assumeTrue(WifiFeature.isWifiSupported(mContext));          mWifiManager = mContext.getSystemService(WifiManager.class);         assertThat(mWifiManager).isNotNull();          // turn on verbose logging for tests         mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.isVerboseLoggingEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(true));          // enable Wifi         if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);         PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());          // turn screen on         mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());         turnScreenOn();          // check we have >= 1 saved network         List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.getConfiguredNetworks());         assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();          // ensure Wifi is connected         ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());         PollingCheck.check(                 ""Wifi not connected"",                 WIFI_CONNECT_TIMEOUT_MILLIS,                 () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);     }      @After     public void tearDown() throws Exception {         if (!WifiFeature.isWifiSupported(mContext)) return;         if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);         turnScreenOff();         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));     }      private void setWifiEnabled(boolean enable) throws Exception {         // now trigger the change using shell commands.         SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));     }      private void turnScreenOn() throws Exception {         mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");         mUiDevice.executeShellCommand(""wm dismiss-keyguard"");         // Since the screen on/off intent is ordered, they will not be sent right now.         Thread.sleep(DURATION_SCREEN_TOGGLE);     }      private void turnScreenOff() throws Exception {         mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");     }      private static class TestUsabilityStatsListener implements             WifiManager.OnWifiUsabilityStatsListener {         private final CountDownLatch mCountDownLatch;         public int seqNum;         public boolean isSameBssidAndFre;         public WifiUsabilityStatsEntry statsEntry;          TestUsabilityStatsListener(CountDownLatch countDownLatch) {             mCountDownLatch = countDownLatch;         }          @Override         public void onWifiUsabilityStats(int seqNum, boolean isSameBssidAndFreq,                 WifiUsabilityStatsEntry statsEntry) {             this.seqNum = seqNum;             this.isSameBssidAndFre = isSameBssidAndFreq;             this.statsEntry = statsEntry;             mCountDownLatch.countDown();         }     }      /**      * Tests the {@link android.net.wifi.WifiUsabilityStatsEntry} retrieved from      * {@link WifiManager.OnWifiUsabilityStatsListener}.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.DataSaverModeTest"	"registerBroadcastReceiver"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/DataSaverModeTest.java"	""	"/*  *.  */  package com.android.cts.net.hostside;  import static android.net.ConnectivityManager.RESTRICT_BACKGROUND_STATUS_DISABLED; import static android.net.ConnectivityManager.RESTRICT_BACKGROUND_STATUS_ENABLED; import static android.net.ConnectivityManager.RESTRICT_BACKGROUND_STATUS_WHITELISTED;  import static com.android.cts.net.hostside.NetworkPolicyTestUtils.setRestrictBackground; import static com.android.cts.net.hostside.Property.DATA_SAVER_MODE; import static com.android.cts.net.hostside.Property.METERED_NETWORK; import static com.android.cts.net.hostside.Property.NO_DATA_SAVER_MODE;  import static org.junit.Assert.fail;  import com.android.compatibility.common.util.CddTest;  import org.junit.After; import org.junit.Before; import org.junit.Test;  import androidx.test.filters.LargeTest;  @RequiredProperties({DATA_SAVER_MODE, METERED_NETWORK}) @LargeTest public class DataSaverModeTest extends AbstractRestrictBackgroundNetworkTestCase {      private static final String[] REQUIRED_WHITELISTED_PACKAGES = {         ""com.android.providers.downloads""     };      @Before     public void setUp() throws Exception {         super.setUp();          // Set initial state.         setRestrictBackground(false);         removeRestrictBackgroundWhitelist(mUid);         removeRestrictBackgroundBlacklist(mUid);          registerBroadcastReceiver();         assertRestrictBackgroundChangedReceived(0);    }      @After     public void tearDown() throws Exception {         super.tearDown();          setRestrictBackground(false);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.DataSaverModeTest"	"testGetRestrictBackgroundStatus_disabled"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/DataSaverModeTest.java"	""	"public void testGetRestrictBackgroundStatus_disabled() throws Exception {         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_DISABLED);          // Sanity check: make sure status is always disabled, never whitelisted         addRestrictBackgroundWhitelist(mUid);         assertRestrictBackgroundChangedReceived(0);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_DISABLED);          assertsForegroundAlwaysHasNetworkAccess();         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_DISABLED);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.DataSaverModeTest"	"testGetRestrictBackgroundStatus_whitelisted"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/DataSaverModeTest.java"	""	"public void testGetRestrictBackgroundStatus_whitelisted() throws Exception {         setRestrictBackground(true);         assertRestrictBackgroundChangedReceived(1);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_ENABLED);          addRestrictBackgroundWhitelist(mUid);         assertRestrictBackgroundChangedReceived(2);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_WHITELISTED);          removeRestrictBackgroundWhitelist(mUid);         assertRestrictBackgroundChangedReceived(3);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_ENABLED);          assertsForegroundAlwaysHasNetworkAccess();         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_ENABLED);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.DataSaverModeTest"	"testGetRestrictBackgroundStatus_enabled"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/DataSaverModeTest.java"	""	"public void testGetRestrictBackgroundStatus_enabled() throws Exception {         setRestrictBackground(true);         assertRestrictBackgroundChangedReceived(1);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_ENABLED);          assertsForegroundAlwaysHasNetworkAccess();         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_ENABLED);          // Make sure foreground app doesn't lose access upon enabling Data Saver.         setRestrictBackground(false);         launchComponentAndAssertNetworkAccess(TYPE_COMPONENT_ACTIVTIY);         setRestrictBackground(true);         assertForegroundNetworkAccess();          // Although it should not have access while the screen is off.         turnScreenOff();         assertBackgroundNetworkAccess(false);         turnScreenOn();         assertForegroundNetworkAccess();          // Goes back to background state.         finishActivity();         assertBackgroundNetworkAccess(false);          // Make sure foreground service doesn't lose access upon enabling Data Saver.         setRestrictBackground(false);         launchComponentAndAssertNetworkAccess(TYPE_COMPONENT_FOREGROUND_SERVICE);         setRestrictBackground(true);         assertForegroundNetworkAccess();         stopForegroundService();         assertBackgroundNetworkAccess(false);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.DataSaverModeTest"	"testGetRestrictBackgroundStatus_blacklisted"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/DataSaverModeTest.java"	""	"public void testGetRestrictBackgroundStatus_blacklisted() throws Exception {         addRestrictBackgroundBlacklist(mUid);         assertRestrictBackgroundChangedReceived(1);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_ENABLED);          assertsForegroundAlwaysHasNetworkAccess();         assertRestrictBackgroundChangedReceived(1);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_ENABLED);          // UID policies live by the Highlander rule: ""There can be only one"".         // Hence, if app is whitelisted, it should not be blacklisted anymore.         setRestrictBackground(true);         assertRestrictBackgroundChangedReceived(2);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_ENABLED);         addRestrictBackgroundWhitelist(mUid);         assertRestrictBackgroundChangedReceived(3);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_WHITELISTED);          // Check status after removing blacklist.         // ...re-enables first         addRestrictBackgroundBlacklist(mUid);         assertRestrictBackgroundChangedReceived(4);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_ENABLED);         assertsForegroundAlwaysHasNetworkAccess();         // ... remove blacklist - access's still rejected because Data Saver is on         removeRestrictBackgroundBlacklist(mUid);         assertRestrictBackgroundChangedReceived(4);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_ENABLED);         assertsForegroundAlwaysHasNetworkAccess();         // ... finally, disable Data Saver         setRestrictBackground(false);         assertRestrictBackgroundChangedReceived(5);         assertDataSaverStatusOnBackground(RESTRICT_BACKGROUND_STATUS_DISABLED);         assertsForegroundAlwaysHasNetworkAccess();     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.DataSaverModeTest"	"testGetRestrictBackgroundStatus_requiredWhitelistedPackages"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/DataSaverModeTest.java"	""	"public void testGetRestrictBackgroundStatus_requiredWhitelistedPackages() throws Exception {         final StringBuilder error = new StringBuilder();         for (String packageName : REQUIRED_WHITELISTED_PACKAGES) {             int uid = -1;             try {                 uid = getUid(packageName);                 assertRestrictBackgroundWhitelist(uid, true);             } catch (Throwable t) {                 error.append(""\nFailed for '"").append(packageName).append(""'"");                 if (uid > 0) {                     error.append("" (uid "").append(uid).append("")"");                 }                 error.append("": "").append(t).append(""\n"");             }         }         if (error.length() > 0) {             fail(error.toString());         }     }      @RequiredProperties({NO_DATA_SAVER_MODE})     @CddTest(requirement=""7.4.7/C-2-2"")"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.DataSaverModeTest"	"testBroadcastNotSentOnUnsupportedDevices"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/DataSaverModeTest.java"	""	"public void testBroadcastNotSentOnUnsupportedDevices() throws Exception {         setRestrictBackground(true);         assertRestrictBackgroundChangedReceived(0);          setRestrictBackground(false);         assertRestrictBackgroundChangedReceived(0);          setRestrictBackground(true);         assertRestrictBackgroundChangedReceived(0);     }      private void assertDataSaverStatusOnBackground(int expectedStatus) throws Exception {         assertRestrictBackgroundStatus(expectedStatus);         assertBackgroundNetworkAccess(expectedStatus != RESTRICT_BACKGROUND_STATUS_ENABLED);     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.AbstractBatterySaverModeTestCase"	"registerBroadcastReceiver"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/AbstractBatterySaverModeTestCase.java"	""	"/*  *.  */  package com.android.cts.net.hostside;  import static com.android.cts.net.hostside.Property.BATTERY_SAVER_MODE;  import org.junit.After; import org.junit.Before; import org.junit.Test;  /**  * Base class for metered and non-metered Battery Saver Mode tests.  */ @RequiredProperties({BATTERY_SAVER_MODE}) abstract class AbstractBatterySaverModeTestCase extends AbstractRestrictBackgroundNetworkTestCase {      @Before     public final void setUp() throws Exception {         super.setUp();          // Set initial state.         removePowerSaveModeWhitelist(TEST_APP2_PKG);         removePowerSaveModeExceptIdleWhitelist(TEST_APP2_PKG);         setBatterySaverMode(false);          registerBroadcastReceiver();     }      @After     public final void tearDown() throws Exception {         super.tearDown();          setBatterySaverMode(false);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"isVerboseLoggingEnabled"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"logging"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"/*  *.  */  package android.net.wifi.cts;  import static android.net.NetworkCapabilitiesProto.TRANSPORT_WIFI; import static android.os.Process.myUid;  import static com.google.common.truth.Truth.assertThat;  import static junit.framework.TestCase.assertFalse;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.app.UiAutomation; import android.content.Context; import android.net.ConnectivityManager; import android.net.LinkProperties; import android.net.MacAddress; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkRequest; import android.net.wifi.ScanResult; import android.net.wifi.WifiConfiguration; import android.net.wifi.WifiEnterpriseConfig; import android.net.wifi.WifiInfo; import android.net.wifi.WifiManager; import android.net.wifi.WifiManager.NetworkRequestMatchCallback; import android.net.wifi.WifiNetworkSpecifier; import android.os.PatternMatcher; import android.os.WorkSource; import android.platform.test.annotations.AppModeFull; import android.support.test.uiautomator.UiDevice; import android.text.TextUtils;  import androidx.test.filters.SmallTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.PollingCheck; import com.android.compatibility.common.util.ShellIdentityUtils; import com.android.compatibility.common.util.SystemUtil;  import org.junit.After; import org.junit.AfterClass; import org.junit.Before; import org.junit.BeforeClass; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.List; import java.util.concurrent.Executors;  /**  * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a  * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,  * ConnectivityManager.NetworkCallback)}.  *  * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.  * TODO(b/150716005): Use assumeTrue for wifi support check.  */ @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"") @SmallTest @RunWith(AndroidJUnit4.class) public class WifiNetworkSpecifierTest extends WifiJUnit4TestBase {     private static final String TAG = ""WifiNetworkSpecifierTest"";      private static boolean sWasVerboseLoggingEnabled;     private static boolean sWasScanThrottleEnabled;      private Context mContext;     private WifiManager mWifiManager;     private ConnectivityManager mConnectivityManager;     private UiDevice mUiDevice;     private final Object mLock = new Object();     private final Object mUiLock = new Object();     private WifiConfiguration mTestNetwork;     private TestNetworkCallback mNetworkCallback;      private static final int DURATION = 10_000;     private static final int DURATION_UI_INTERACTION = 25_000;     private static final int DURATION_NETWORK_CONNECTION = 60_000;     private static final int DURATION_SCREEN_TOGGLE = 2000;     private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;      @BeforeClass     public static void setUpClass() throws Exception {         Context context = InstrumentationRegistry.getInstrumentation().getContext();         // skip the test if WiFi is not supported         assumeTrue(WifiFeature.isWifiSupported(context));          WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);         assertNotNull(wifiManager);          // turn on verbose logging for tests         sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> wifiManager.isVerboseLoggingEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> wifiManager.setVerboseLoggingEnabled(true));         // Disable scan throttling for tests.         sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> wifiManager.isScanThrottleEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> wifiManager.setScanThrottleEnabled(false));          // enable Wifi         if (!wifiManager.isWifiEnabled()) setWifiEnabled(true);         PollingCheck.check(""Wifi not enabled"", DURATION, () -> wifiManager.isWifiEnabled());          List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(                 () -> wifiManager.getPrivilegedConfiguredNetworks());          // Disconnect & disable auto-join on the saved network to prevent auto-connect from         // interfering with the test.         ShellIdentityUtils.invokeWithShellPermissions(                 () -> {                     for (WifiConfiguration savedNetwork : savedNetworks) {                         wifiManager.disableNetwork(savedNetwork.networkId);                     }                 });     }      @AfterClass     public static void tearDownClass() throws Exception {         Context context = InstrumentationRegistry.getInstrumentation().getContext();         if (!WifiFeature.isWifiSupported(context)) return;          WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);         assertNotNull(wifiManager);          if (!wifiManager.isWifiEnabled()) setWifiEnabled(true);          // Re-enable networks.         ShellIdentityUtils.invokeWithShellPermissions(                 () -> {                     for (WifiConfiguration savedNetwork : wifiManager.getConfiguredNetworks()) {                         wifiManager.enableNetwork(savedNetwork.networkId, false);                     }                 });         ShellIdentityUtils.invokeWithShellPermissions(                 () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));         ShellIdentityUtils.invokeWithShellPermissions(                 () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));     }      @Before     public void setUp() throws Exception {         mContext = InstrumentationRegistry.getInstrumentation().getContext();         mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);         mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);         mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());          // turn screen on         turnScreenOn();          List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.getPrivilegedConfiguredNetworks());         // check we have >= 1 saved network         assertFalse(""Need at least one saved network"", savedNetworks.isEmpty());         // Pick the last saved network on the device (assumes that it is in range)         mTestNetwork = savedNetworks.get(savedNetworks.size()  - 1);          // Wait for Wifi to be disconnected.         PollingCheck.check(                 ""Wifi not disconnected"",                 20000,                 () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);     }      @After     public void tearDown() throws Exception {         // If there is failure, ensure we unregister the previous request.         if (mNetworkCallback != null) {             mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);         }         turnScreenOff();     }      private static void setWifiEnabled(boolean enable) throws Exception {         // now trigger the change using shell commands.         SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));     }      private void turnScreenOn() throws Exception {         mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");         mUiDevice.executeShellCommand(""wm dismiss-keyguard"");         // Since the screen on/off intent is ordered, they will not be sent right now.         Thread.sleep(DURATION_SCREEN_TOGGLE);     }      private void turnScreenOff() throws Exception {         mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");         // Since the screen on/off intent is ordered, they will not be sent right now.         Thread.sleep(DURATION_SCREEN_TOGGLE);     }      private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {         private final Object mLock;         public boolean onAvailableCalled = false;         public boolean onUnavailableCalled = false;         public NetworkCapabilities networkCapabilities;          TestNetworkCallback(Object lock) {             mLock = lock;         }          @Override         public void onAvailable(Network network, NetworkCapabilities networkCapabilities,                 LinkProperties linkProperties, boolean blocked) {             synchronized (mLock) {                 onAvailableCalled = true;                 this.networkCapabilities = networkCapabilities;                 mLock.notify();             }         }          @Override         public void onUnavailable() {             synchronized (mLock) {                 onUnavailableCalled = true;                 mLock.notify();             }         }     }      private static class TestNetworkRequestMatchCallback implements NetworkRequestMatchCallback {         private final Object mLock;          public boolean onRegistrationCalled = false;         public boolean onAbortCalled = false;         public boolean onMatchCalled = false;         public boolean onConnectSuccessCalled = false;         public boolean onConnectFailureCalled = false;         public WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback = null;         public List<ScanResult> matchedScanResults = null;          TestNetworkRequestMatchCallback(Object lock) {             mLock = lock;         }          @Override         public void onUserSelectionCallbackRegistration(                 WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback) {             synchronized (mLock) {                 onRegistrationCalled = true;                 this.userSelectionCallback = userSelectionCallback;                 mLock.notify();             }         }          @Override         public void onAbort() {             synchronized (mLock) {                 onAbortCalled = true;                 mLock.notify();             }         }          @Override         public void onMatch(List<ScanResult> scanResults) {             synchronized (mLock) {                 // This can be invoked multiple times. So, ignore after the first one to avoid                 // disturbing the rest of the test sequence.                 if (onMatchCalled) return;                 onMatchCalled = true;                 matchedScanResults = scanResults;                 mLock.notify();             }         }          @Override         public void onUserSelectionConnectSuccess(WifiConfiguration config) {             synchronized (mLock) {                 onConnectSuccessCalled = true;                 mLock.notify();             }         }          @Override         public void onUserSelectionConnectFailure(WifiConfiguration config) {             synchronized (mLock) {                 onConnectFailureCalled = true;                 mLock.notify();             }         }     }      private void handleUiInteractions(boolean shouldUserReject) {         UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();         TestNetworkRequestMatchCallback networkRequestMatchCallback =                 new TestNetworkRequestMatchCallback(mUiLock);         try {             uiAutomation.adoptShellPermissionIdentity();              // 1. Wait for registration callback.             synchronized (mUiLock) {                 try {                     mWifiManager.registerNetworkRequestMatchCallback(                             Executors.newSingleThreadExecutor(), networkRequestMatchCallback);                     mUiLock.wait(DURATION_UI_INTERACTION);                 } catch (InterruptedException e) {                 }             }             assertTrue(networkRequestMatchCallback.onRegistrationCalled);             assertNotNull(networkRequestMatchCallback.userSelectionCallback);              // 2. Wait for matching scan results             synchronized (mUiLock) {                 try {                     mUiLock.wait(DURATION_UI_INTERACTION);                 } catch (InterruptedException e) {                 }             }             assertTrue(networkRequestMatchCallback.onMatchCalled);             assertNotNull(networkRequestMatchCallback.matchedScanResults);             assertThat(networkRequestMatchCallback.matchedScanResults.size()).isAtLeast(1);              // 3. Trigger connection to one of the matched networks or reject the request.             if (shouldUserReject) {                 networkRequestMatchCallback.userSelectionCallback.reject();             } else {                 networkRequestMatchCallback.userSelectionCallback.select(mTestNetwork);             }              // 4. Wait for connection success or abort.             synchronized (mUiLock) {                 try {                     mUiLock.wait(DURATION_UI_INTERACTION);                 } catch (InterruptedException e) {                 }             }             if (shouldUserReject) {                 assertTrue(networkRequestMatchCallback.onAbortCalled);             } else {                 assertTrue(networkRequestMatchCallback.onConnectSuccessCalled);             }         } finally {             mWifiManager.unregisterNetworkRequestMatchCallback(networkRequestMatchCallback);             uiAutomation.dropShellPermissionIdentity();         }     }      /**      * Tests the entire connection flow using the provided specifier.      *      * @param specifier Specifier to use for network request.      * @param shouldUserReject Whether to simulate user rejection or not.      */     private void testConnectionFlowWithSpecifier(             WifiNetworkSpecifier specifier, boolean shouldUserReject) {         // Fork a thread to handle the UI interactions.         Thread uiThread = new Thread(() -> handleUiInteractions(shouldUserReject));          // File the network request & wait for the callback.         mNetworkCallback = new TestNetworkCallback(mLock);         synchronized (mLock) {             try {                 // File a request for wifi network.                 mConnectivityManager.requestNetwork(                         new NetworkRequest.Builder()                                 .addTransportType(TRANSPORT_WIFI)                                 .setNetworkSpecifier(specifier)                                 .build(),                         mNetworkCallback);                 // Wait for the request to reach the wifi stack before kick-starting the UI                 // interactions.                 Thread.sleep(100);                 // Start the UI interactions.                 uiThread.run();                 // now wait for callback                 mLock.wait(DURATION_NETWORK_CONNECTION);             } catch (InterruptedException e) {             }         }         if (shouldUserReject) {             assertTrue(mNetworkCallback.onUnavailableCalled);         } else {             assertTrue(mNetworkCallback.onAvailableCalled);         }          try {             // Ensure that the UI interaction thread has completed.             uiThread.join(DURATION_UI_INTERACTION);         } catch (InterruptedException e) {             fail(""UI interaction interrupted"");         }          // Release the request after the test.         mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);         mNetworkCallback = null;     }      private void testSuccessfulConnectionWithSpecifier(WifiNetworkSpecifier specifier) {         testConnectionFlowWithSpecifier(specifier, false);     }      private void testUserRejectionWithSpecifier(WifiNetworkSpecifier specifier) {         testConnectionFlowWithSpecifier(specifier, true);     }      private static String removeDoubleQuotes(String string) {         return WifiInfo.sanitizeSsid(string);     }      private WifiNetworkSpecifier.Builder createSpecifierBuilderWithCredentialFromSavedNetwork() {         WifiNetworkSpecifier.Builder specifierBuilder = new WifiNetworkSpecifier.Builder();         if (mTestNetwork.preSharedKey != null) {             if (mTestNetwork.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {                 specifierBuilder.setWpa2Passphrase(removeDoubleQuotes(mTestNetwork.preSharedKey));             } else if (mTestNetwork.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {                 specifierBuilder.setWpa3Passphrase(removeDoubleQuotes(mTestNetwork.preSharedKey));             } else {                 fail(""Unsupported security type found in saved networks"");             }         } else if (!mTestNetwork.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {             specifierBuilder.setIsEnhancedOpen(false);         } else if (!mTestNetwork.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {             fail(""Unsupported security type found in saved networks"");         }         specifierBuilder.setIsHiddenSsid(mTestNetwork.hiddenSSID);         return specifierBuilder;     }      /**      * Tests the entire connection flow using a specific SSID in the specifier.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.MixedModesTest"	"registerBroadcastReceiver"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/MixedModesTest.java"	""	"/*  *.  */ package com.android.cts.net.hostside;  import static com.android.cts.net.hostside.NetworkPolicyTestUtils.setRestrictBackground; import static com.android.cts.net.hostside.Property.APP_STANDBY_MODE; import static com.android.cts.net.hostside.Property.BATTERY_SAVER_MODE; import static com.android.cts.net.hostside.Property.DATA_SAVER_MODE; import static com.android.cts.net.hostside.Property.DOZE_MODE; import static com.android.cts.net.hostside.Property.METERED_NETWORK; import static com.android.cts.net.hostside.Property.NON_METERED_NETWORK;  import android.os.SystemClock; import android.util.Log;  import org.junit.After; import org.junit.Before; import org.junit.Test;  /**  * Test cases for the more complex scenarios where multiple restrictions (like Battery Saver Mode  * and Data Saver Mode) are applied simultaneously.  * <p>  * <strong>NOTE: </strong>it might sound like the test methods on this class are testing too much,  * which would make it harder to diagnose individual failures, but the assumption is that such  * failure most likely will happen when the restriction is tested individually as well.  */ public class MixedModesTest extends AbstractRestrictBackgroundNetworkTestCase {     private static final String TAG = ""MixedModesTest"";      @Before     public void setUp() throws Exception {         super.setUp();          // Set initial state.         removeRestrictBackgroundWhitelist(mUid);         removeRestrictBackgroundBlacklist(mUid);         removePowerSaveModeWhitelist(TEST_APP2_PKG);         removePowerSaveModeExceptIdleWhitelist(TEST_APP2_PKG);          registerBroadcastReceiver();     }      @After     public void tearDown() throws Exception {         super.tearDown();          try {             setRestrictBackground(false);         } finally {             setBatterySaverMode(false);         }     }      /**      * Tests all DS ON and BS ON scenarios from network-policy-restrictions.md on metered networks.      */     @RequiredProperties({DATA_SAVER_MODE, BATTERY_SAVER_MODE, METERED_NETWORK})"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.MixedModesTest"	"testDataAndBatterySaverModes_meteredNetwork"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/MixedModesTest.java"	""	"public void testDataAndBatterySaverModes_meteredNetwork() throws Exception {         final MeterednessConfigurationRule meterednessConfiguration                 = new MeterednessConfigurationRule();         meterednessConfiguration.configureNetworkMeteredness(true);         try {             setRestrictBackground(true);             setBatterySaverMode(true);              Log.v(TAG, ""Not whitelisted for any."");             assertBackgroundNetworkAccess(false);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(false);              Log.v(TAG, ""Whitelisted for Data Saver but not for Battery Saver."");             addRestrictBackgroundWhitelist(mUid);             removePowerSaveModeWhitelist(TEST_APP2_PKG);             assertBackgroundNetworkAccess(false);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(false);             removeRestrictBackgroundWhitelist(mUid);              Log.v(TAG, ""Whitelisted for Battery Saver but not for Data Saver."");             addPowerSaveModeWhitelist(TEST_APP2_PKG);             removeRestrictBackgroundWhitelist(mUid);             assertBackgroundNetworkAccess(false);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(false);             removePowerSaveModeWhitelist(TEST_APP2_PKG);              Log.v(TAG, ""Whitelisted for both."");             addRestrictBackgroundWhitelist(mUid);             addPowerSaveModeWhitelist(TEST_APP2_PKG);             assertBackgroundNetworkAccess(true);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(true);             removePowerSaveModeWhitelist(TEST_APP2_PKG);             assertBackgroundNetworkAccess(false);             removeRestrictBackgroundWhitelist(mUid);              Log.v(TAG, ""Blacklisted for Data Saver, not whitelisted for Battery Saver."");             addRestrictBackgroundBlacklist(mUid);             removePowerSaveModeWhitelist(TEST_APP2_PKG);             assertBackgroundNetworkAccess(false);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(false);             removeRestrictBackgroundBlacklist(mUid);              Log.v(TAG, ""Blacklisted for Data Saver, whitelisted for Battery Saver."");             addRestrictBackgroundBlacklist(mUid);             addPowerSaveModeWhitelist(TEST_APP2_PKG);             assertBackgroundNetworkAccess(false);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(false);             removeRestrictBackgroundBlacklist(mUid);             removePowerSaveModeWhitelist(TEST_APP2_PKG);         } finally {             meterednessConfiguration.resetNetworkMeteredness();         }     }      /**      * Tests all DS ON and BS ON scenarios from network-policy-restrictions.md on non-metered      * networks.      */     @RequiredProperties({DATA_SAVER_MODE, BATTERY_SAVER_MODE, NON_METERED_NETWORK})"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.MixedModesTest"	"testDataAndBatterySaverModes_nonMeteredNetwork"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/MixedModesTest.java"	""	"public void testDataAndBatterySaverModes_nonMeteredNetwork() throws Exception {         final MeterednessConfigurationRule meterednessConfiguration                 = new MeterednessConfigurationRule();         meterednessConfiguration.configureNetworkMeteredness(false);         try {             setRestrictBackground(true);             setBatterySaverMode(true);              Log.v(TAG, ""Not whitelisted for any."");             assertBackgroundNetworkAccess(false);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(false);              Log.v(TAG, ""Whitelisted for Data Saver but not for Battery Saver."");             addRestrictBackgroundWhitelist(mUid);             removePowerSaveModeWhitelist(TEST_APP2_PKG);             assertBackgroundNetworkAccess(false);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(false);             removeRestrictBackgroundWhitelist(mUid);              Log.v(TAG, ""Whitelisted for Battery Saver but not for Data Saver."");             addPowerSaveModeWhitelist(TEST_APP2_PKG);             removeRestrictBackgroundWhitelist(mUid);             assertBackgroundNetworkAccess(true);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(true);             removePowerSaveModeWhitelist(TEST_APP2_PKG);              Log.v(TAG, ""Whitelisted for both."");             addRestrictBackgroundWhitelist(mUid);             addPowerSaveModeWhitelist(TEST_APP2_PKG);             assertBackgroundNetworkAccess(true);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(true);             removePowerSaveModeWhitelist(TEST_APP2_PKG);             assertBackgroundNetworkAccess(false);             removeRestrictBackgroundWhitelist(mUid);              Log.v(TAG, ""Blacklisted for Data Saver, not whitelisted for Battery Saver."");             addRestrictBackgroundBlacklist(mUid);             removePowerSaveModeWhitelist(TEST_APP2_PKG);             assertBackgroundNetworkAccess(false);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(false);             removeRestrictBackgroundBlacklist(mUid);              Log.v(TAG, ""Blacklisted for Data Saver, whitelisted for Battery Saver."");             addRestrictBackgroundBlacklist(mUid);             addPowerSaveModeWhitelist(TEST_APP2_PKG);             assertBackgroundNetworkAccess(true);             assertsForegroundAlwaysHasNetworkAccess();             assertBackgroundNetworkAccess(true);             removeRestrictBackgroundBlacklist(mUid);             removePowerSaveModeWhitelist(TEST_APP2_PKG);         } finally {             meterednessConfiguration.resetNetworkMeteredness();         }     }      /**      * Tests that powersave whitelists works as expected when doze and battery saver modes      * are enabled.      */     @RequiredProperties({DOZE_MODE, BATTERY_SAVER_MODE})"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.wifi.cts.ScanResultTest"	"isNotNull"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"logging"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void test/*  *.  */  package android.net.wifi.cts;  import static com.google.common.truth.Truth.assertThat; import static com.google.common.truth.Truth.assertWithMessage;  import java.nio.ByteBuffer; import java.util.List;  import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.net.wifi.ScanResult; import android.net.wifi.ScanResult.InformationElement; import android.net.wifi.WifiInfo; import android.net.wifi.WifiManager; import android.net.wifi.WifiManager.WifiLock; import android.platform.test.annotations.AppModeFull; import android.test.AndroidTestCase;  import com.android.compatibility.common.util.PollingCheck; import com.android.compatibility.common.util.ShellIdentityUtils; import com.android.compatibility.common.util.SystemUtil;  @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"") public class ScanResultTest extends WifiJUnit3TestBase {     private static class MySync {         int expectedState = STATE_NULL;     }      private WifiManager mWifiManager;     private WifiLock mWifiLock;     private static MySync mMySync;     private boolean mWasVerboseLoggingEnabled;     private boolean mWasScanThrottleEnabled;      private static final int STATE_NULL = 0;     private static final int STATE_WIFI_CHANGING = 1;     private static final int STATE_WIFI_CHANGED = 2;     private static final int STATE_START_SCAN = 3;     private static final int STATE_SCAN_RESULTS_AVAILABLE = 4;     private static final int STATE_SCAN_FAILURE = 5;      private static final String TAG = ""WifiInfoTest"";     private static final int TIMEOUT_MSEC = 6000;     private static final int WAIT_MSEC = 60;     private static final int ENABLE_WAIT_MSEC = 10000;     private static final int SCAN_WAIT_MSEC = 10000;     private static final int SCAN_MAX_RETRY_COUNT = 6;     private static final int SCAN_FIND_BSSID_MAX_RETRY_COUNT = 5;     private static final long SCAN_FIND_BSSID_WAIT_MSEC = 5_000L;     private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;      private static final String TEST_SSID = ""TEST_SSID"";     public static final String TEST_BSSID = ""04:ac:fe:45:34:10"";     public static final String TEST_CAPS = ""CCMP"";     public static final int TEST_LEVEL = -56;     public static final int TEST_FREQUENCY = 2412;     public static final long TEST_TIMESTAMP = 4660L;      private IntentFilter mIntentFilter;     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {         @Override         public void onReceive(Context context, Intent intent) {             final String action = intent.getAction();             if (action.equals(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION)) {                 synchronized (mMySync) {                     mMySync.expectedState = STATE_WIFI_CHANGED;                     mMySync.notify();                 }             } else if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {                 synchronized (mMySync) {                     if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {                         mMySync.expectedState = STATE_SCAN_RESULTS_AVAILABLE;                     } else {                         mMySync.expectedState = STATE_SCAN_FAILURE;                     }                     mMySync.notify();                 }             }         }     };      @Override     protected void setUp() throws Exception {         super.setUp();         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             return;         }         mMySync = new MySync();         mIntentFilter = new IntentFilter();         mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);         mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);         mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);         mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);         mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);         mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);         mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);         mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);          mContext.registerReceiver(mReceiver, mIntentFilter);         mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);         assertThat(mWifiManager).isNotNull();          // turn on verbose logging for tests         mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.isVerboseLoggingEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(true));         // Disable scan throttling for tests.         mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.isScanThrottleEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setScanThrottleEnabled(false));          mWifiLock = mWifiManager.createWifiLock(TAG);         mWifiLock.acquire();          // enable Wifi         if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);         PollingCheck.check(""Wifi not enabled"", ENABLE_WAIT_MSEC,                 () -> mWifiManager.isWifiEnabled());          mMySync.expectedState = STATE_NULL;     }      @Override     protected void tearDown() throws Exception {         if (!WifiFeature.isWifiSupported(getContext())) {             // skip the test if WiFi is not supported             super.tearDown();             return;         }         mWifiLock.release();         mContext.unregisterReceiver(mReceiver);         if (!mWifiManager.isWifiEnabled())             setWifiEnabled(true);         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));         Thread.sleep(ENABLE_WAIT_MSEC);         super.tearDown();     }      private void setWifiEnabled(boolean enable) throws Exception {         synchronized (mMySync) {             mMySync.expectedState = STATE_WIFI_CHANGING;             if (enable) {                 SystemUtil.runShellCommand(""svc wifi enable"");             } else {                 SystemUtil.runShellCommand(""svc wifi disable"");             }             waitForBroadcast(TIMEOUT_MSEC, STATE_WIFI_CHANGED);        }     }      private boolean waitForBroadcast(long timeout, int expectedState) throws Exception {         long waitTime = System.currentTimeMillis() + timeout;         while (System.currentTimeMillis() < waitTime                 && mMySync.expectedState != expectedState)             mMySync.wait(WAIT_MSEC);         return mMySync.expectedState == expectedState;     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.wifi.cts.WifiLocationInfoTest"	"isNotNull"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"logging"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"/*  *.  */  package android.net.wifi.cts;  import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION; import static android.Manifest.permission.ACCESS_FINE_LOCATION;  import static com.google.common.truth.Truth.assertThat; import static com.google.common.truth.Truth.assertWithMessage;  import static org.junit.Assume.assumeTrue;  import android.content.ComponentName; import android.content.Context; import android.net.wifi.WifiConfiguration; import android.net.wifi.WifiManager; import android.platform.test.annotations.AppModeFull;  import androidx.test.filters.SmallTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.rule.ActivityTestRule; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.PollingCheck; import com.android.compatibility.common.util.ShellIdentityUtils; import com.android.compatibility.common.util.SystemUtil;  import org.junit.After; import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.runner.RunWith;  import java.util.List;  /**  * Tests location sensitive APIs exposed by Wi-Fi.  * Ensures that permissions on these APIs are properly enforced.  */ @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"") @SmallTest @RunWith(AndroidJUnit4.class) public class WifiLocationInfoTest extends WifiJUnit4TestBase {     private static final String TAG = ""WifiLocationInfoTest"";      private static final String WIFI_LOCATION_TEST_APP_APK_PATH =             ""/data/local/tmp/cts/wifi/CtsWifiLocationTestApp.apk"";     private static final String WIFI_LOCATION_TEST_APP_PACKAGE_NAME =             ""android.net.wifi.cts.app"";     private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY =             WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusActivity"";     private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE =             WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusService"";     private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY =             WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusActivity"";     private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE =             WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusService"";     private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY =             WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusActivity"";     private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE =             WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusService"";      private static final int DURATION_MS = 10_000;     private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;      @Rule     public final ActivityTestRule<WaitForResultActivity> mActivityRule =             new ActivityTestRule<>(WaitForResultActivity.class);      private Context mContext;     private WifiManager mWifiManager;     private boolean mWasVerboseLoggingEnabled;     private boolean mWasScanThrottleEnabled;      @Before     public void setUp() throws Exception {         mContext = InstrumentationRegistry.getInstrumentation().getContext();         // skip the test if WiFi is not supported         assumeTrue(WifiFeature.isWifiSupported(mContext));          mWifiManager = mContext.getSystemService(WifiManager.class);         assertThat(mWifiManager).isNotNull();          installApp(WIFI_LOCATION_TEST_APP_APK_PATH);          // turn on verbose logging for tests         mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.isVerboseLoggingEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(true));         // Disable scan throttling for tests.         mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.isScanThrottleEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setScanThrottleEnabled(false));          // enable Wifi         if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);         PollingCheck.check(""Wifi not enabled"", DURATION_MS, () -> mWifiManager.isWifiEnabled());          // check we have >= 1 saved network         List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.getConfiguredNetworks());         assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();          // ensure Wifi is connected         ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());         PollingCheck.check(                 ""Wifi not connected"",                 WIFI_CONNECT_TIMEOUT_MILLIS,                 () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);     }      @After     public void tearDown() throws Exception {         if (!WifiFeature.isWifiSupported(mContext)) return;          uninstallApp(WIFI_LOCATION_TEST_APP_PACKAGE_NAME);          if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));     }      private void setWifiEnabled(boolean enable) throws Exception {         // now trigger the change using shell commands.         SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));     }      private void turnScreenOn() throws Exception {         InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(                 ""input keyevent KEYCODE_WAKEUP"");         InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(""""                 + ""wm dismiss-keyguard"");         // Since the screen on/off intent is ordered, they will not be sent right now.         Thread.sleep(2_000);     }      private void turnScreenOff() throws Exception {         InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(                 ""input keyevent KEYCODE_SLEEP"");         // Since the screen on/off intent is ordered, they will not be sent right now.         Thread.sleep(2_000);     }      private void installApp(String apk) throws InterruptedException {         String installResult = SystemUtil.runShellCommand(""pm install -r -d "" + apk);         Thread.sleep(10_000);         assertThat(installResult.trim()).isEqualTo(""Success"");     }      private void uninstallApp(String pkg) throws InterruptedException {         String uninstallResult = SystemUtil.runShellCommand(                 ""pm uninstall "" + pkg);         Thread.sleep(10_000);         assertThat(uninstallResult.trim()).isEqualTo(""Success"");     }      private void startFgActivityAndAssertStatusIs(             ComponentName componentName, boolean status) throws Exception {         turnScreenOn();          WaitForResultActivity activity = mActivityRule.getActivity();         activity.startActivityToWaitForResult(componentName);         assertThat(activity.waitForActivityResult(DURATION_MS)).isEqualTo(status);     }      private void startBgServiceAndAssertStatusIs(             ComponentName componentName, boolean status) throws Exception {         turnScreenOff();          WaitForResultActivity activity = mActivityRule.getActivity();         activity.startServiceToWaitForResult(componentName);         assertThat(activity.waitForServiceResult(DURATION_MS)).isEqualTo(status);     }      private void triggerScanFgActivityAndAssertStatusIs(boolean status) throws Exception {         startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,                 WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY), status);     }      private void triggerScanBgServiceAndAssertStatusIs(boolean status) throws Exception {         startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,                 WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE), status);     }      private void retrieveScanResultsFgActivityAndAssertStatusIs(boolean status) throws Exception {         startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,                 WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY), status);     }      private void retrieveScanResultsBgServiceAndAssertStatusIs(boolean status) throws Exception {         startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,                 WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE), status);     }      private void retrieveConnectionInfoFgActivityAndAssertStatusIs(boolean status)             throws Exception {         startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,                 WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY), status);     }      private void retrieveConnectionInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {         startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,                 WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE), status);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"isNotNull"	"CtsWifiTestCases"	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"logging"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"/*  *.  */  package android.net.wifi.cts;  import static android.content.pm.PackageManager.PERMISSION_GRANTED; import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_METERED; import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NONE; import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NOT_METERED;  import static com.google.common.truth.Truth.assertThat; import static com.google.common.truth.Truth.assertWithMessage;  import static org.junit.Assume.assumeTrue;  import android.app.UiAutomation; import android.content.Context; import android.net.IpConfiguration; import android.net.LinkAddress; import android.net.ProxyInfo; import android.net.StaticIpConfiguration; import android.net.Uri; import android.net.wifi.SoftApConfiguration; import android.net.wifi.WifiConfiguration; import android.net.wifi.WifiEnterpriseConfig; import android.net.wifi.WifiManager; import android.platform.test.annotations.AppModeFull; import android.support.test.uiautomator.UiDevice; import android.util.Log;  import androidx.test.filters.SmallTest; import androidx.test.platform.app.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.compatibility.common.util.PollingCheck; import com.android.compatibility.common.util.ShellIdentityUtils; import com.android.compatibility.common.util.SystemUtil; import com.android.compatibility.common.util.ThrowingRunnable;   import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.DataInputStream; import java.io.IOException; import java.io.InputStream; import java.net.InetAddress; import java.net.UnknownHostException; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Set; import java.util.stream.Collectors;  /**  * Tests for wifi backup/restore functionality.  */ @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"") @SmallTest @RunWith(AndroidJUnit4.class) public class WifiBackupRestoreTest extends WifiJUnit4TestBase {     private static final String TAG = ""WifiBackupRestoreTest"";     private static final String LEGACY_SUPP_CONF_FILE =             ""assets/BackupLegacyFormatSupplicantConf.txt"";     private static final String LEGACY_IP_CONF_FILE =             ""assets/BackupLegacyFormatIpConf.txt"";     private static final String V1_0_FILE = ""assets/BackupV1.0Format.xml"";     private static final String V1_1_FILE = ""assets/BackupV1.1Format.xml"";     private static final String V1_2_FILE = ""assets/BackupV1.2Format.xml"";      public static final String EXPECTED_LEGACY_STATIC_IP_LINK_ADDRESS = ""192.168.48.2"";     public static final int EXPECTED_LEGACY_STATIC_IP_LINK_PREFIX_LENGTH = 8;     public static final String EXPECTED_LEGACY_STATIC_IP_GATEWAY_ADDRESS = ""192.168.48.1"";     public static final String[] EXPECTED_LEGACY_STATIC_IP_DNS_SERVER_ADDRESSES =             new String[]{""192.168.48.1"", ""192.168.48.10""};     public static final String EXPECTED_LEGACY_STATIC_PROXY_HOST = ""192.168.48.1"";     public static final int EXPECTED_LEGACY_STATIC_PROXY_PORT = 8000;     public static final String EXPECTED_LEGACY_STATIC_PROXY_EXCLUSION_LIST = """";     public static final String EXPECTED_LEGACY_PAC_PROXY_LOCATION = ""http://"";      private Context mContext;     private WifiManager mWifiManager;     private UiDevice mUiDevice;     private boolean mWasVerboseLoggingEnabled;      private static final int DURATION = 10_000;     private static final int DURATION_SCREEN_TOGGLE = 2000;      @Before     public void setUp() throws Exception {         mContext = InstrumentationRegistry.getInstrumentation().getContext();         // skip the test if WiFi is not supported         assumeTrue(WifiFeature.isWifiSupported(mContext));          mWifiManager = mContext.getSystemService(WifiManager.class);         assertThat(mWifiManager).isNotNull();          // turn on verbose logging for tests         mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.isVerboseLoggingEnabled());         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(true));         // Disable scan throttling for tests.         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setScanThrottleEnabled(false));          if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);         mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());         turnScreenOn();         PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());          List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.getPrivilegedConfiguredNetworks());         assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();     }      @After     public void tearDown() throws Exception {         if (!WifiFeature.isWifiSupported(mContext)) return;         if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);         turnScreenOff();         ShellIdentityUtils.invokeWithShellPermissions(                 () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));     }      private void setWifiEnabled(boolean enable) throws Exception {         // now trigger the change using shell commands.         SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));     }      private void turnScreenOn() throws Exception {         mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");         mUiDevice.executeShellCommand(""wm dismiss-keyguard"");         // Since the screen on/off intent is ordered, they will not be sent right now.         Thread.sleep(DURATION_SCREEN_TOGGLE);     }      private void turnScreenOff() throws Exception {         mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");         // Since the screen on/off intent is ordered, they will not be sent right now.         Thread.sleep(DURATION_SCREEN_TOGGLE);     }      private void flipMeteredOverride(WifiConfiguration network) {         if (network.meteredOverride == METERED_OVERRIDE_NONE) {             network.meteredOverride = METERED_OVERRIDE_METERED;         } else if (network.meteredOverride == METERED_OVERRIDE_METERED) {             network.meteredOverride = METERED_OVERRIDE_NOT_METERED;         } else if (network.meteredOverride == METERED_OVERRIDE_NOT_METERED) {             network.meteredOverride = METERED_OVERRIDE_NONE;         }     }      /** WifiConfiguration#isEnterprise() is @hide, so copy/paste partial implementation here. */     private static boolean isEnterprise(WifiConfiguration config) {         WifiEnterpriseConfig enterpriseConfig = config.enterpriseConfig;         return enterpriseConfig != null                 && enterpriseConfig.getEapMethod() != WifiEnterpriseConfig.Eap.NONE;     }      /**      * Tests for {@link WifiManager#retrieveBackupData()} &      * {@link WifiManager#restoreBackupData(byte[])}      * Note: If the network was not created by an app with OVERRIDE_WIFI_CONFIG permission (held      * by AOSP settings app for example), then the backup data will not contain that network. If      * the device does not contain any such pre-existing saved network, then this test will be      * a no-op, will only ensure that the device does not crash when invoking the API's.      */"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.VpnTest"	"finish"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/VpnTest.java"	""	"Api.     private static final String PRIVATE_DNS_MODE_SETTING = ""private_dns_mode"";     private static final String PRIVATE_DNS_MODE_PROVIDER_HOSTNAME = ""hostname"";     private static final String PRIVATE_DNS_MODE_OPPORTUNISTIC = ""opportunistic"";     private static final String PRIVATE_DNS_SPECIFIER_SETTING = ""private_dns_specifier"";      public static String TAG = ""VpnTest"";     public static int TIMEOUT_MS = 3 * 1000;     public static int SOCKET_TIMEOUT_MS = 100;     public static String TEST_HOST = ""connectivitycheck.gstatic.com"";      private UiDevice mDevice;     private MyActivity mActivity;     private String mPackageName;     private ConnectivityManager mCM;     private WifiManager mWifiManager;     private RemoteSocketFactoryClient mRemoteSocketFactoryClient;      Network mNetwork;     NetworkCallback mCallback;     final Object mLock = new Object();     final Object mLockShutdown = new Object();      private String mOldPrivateDnsMode;     private String mOldPrivateDnsSpecifier;      private boolean supportedHardware() {         final PackageManager pm = getInstrumentation().getContext().getPackageManager();         return !pm.hasSystemFeature(""android.hardware.type.watch"");     }      @Override     public void setUp() throws Exception {         super.setUp();          mNetwork = null;         mCallback = null;         storePrivateDnsSetting();          mDevice = UiDevice.getInstance(getInstrumentation());         mActivity = launchActivity(getInstrumentation().getTargetContext().getPackageName(),                 MyActivity.class, null);         mPackageName = mActivity.getPackageName();         mCM = (ConnectivityManager) mActivity.getSystemService(Context.CONNECTIVITY_SERVICE);         mWifiManager = (WifiManager) mActivity.getSystemService(Context.WIFI_SERVICE);         mRemoteSocketFactoryClient = new RemoteSocketFactoryClient(mActivity);         mRemoteSocketFactoryClient.bind();         mDevice.waitForIdle();     }      @Override     public void tearDown() throws Exception {         restorePrivateDnsSetting();         mRemoteSocketFactoryClient.unbind();         if (mCallback != null) {             mCM.unregisterNetworkCallback(mCallback);         }         Log.i(TAG, ""Stopping VPN"");         stopVpn();         mActivity.finish();         super.tearDown();     }      private void prepareVpn() throws Exception {         final int REQUEST_ID = 42;          // Attempt to prepare.         Log.i(TAG, ""Preparing VPN"");         Intent intent = VpnService.prepare(mActivity);          if (intent != null) {             // Start the confirmation dialog and click OK.             mActivity.startActivityForResult(intent, REQUEST_ID);             mDevice.waitForIdle();              String packageName = intent.getComponent().getPackageName();             String resourceIdRegex = ""android:id/button1$|button_start_vpn"";             final UiObject okButton = new UiObject(new UiSelector()                     .className(""android.widget.Button"")                     .packageName(packageName)                     .resourceIdMatches(resourceIdRegex));             if (okButton.waitForExists(TIMEOUT_MS) == false) {                 mActivity.finishActivity(REQUEST_ID);                 fail(""VpnService.prepare returned an Intent for '"" + intent.getComponent() + ""' "" +                      ""to display the VPN confirmation dialog, but this test could not find the "" +                      ""button to allow the VPN application to connect. Please ensure that the ""  +                      ""component displays a button with a resource ID matching the regexp: '"" +                      resourceIdRegex + ""'."");             }              // Click the button and wait for RESULT_OK.             okButton.click();             try {                 int result = mActivity.getResult(TIMEOUT_MS);                 if (result != MyActivity.RESULT_OK) {                     fail(""The VPN confirmation dialog did not return RESULT_OK when clicking on "" +                          ""the button matching the regular expression '"" + resourceIdRegex +                          ""' of "" + intent.getComponent() + ""'. Please ensure that clicking on "" +                          ""that button allows the VPN application to connect. "" +                          ""Return value: "" + result);                 }             } catch (InterruptedException e) {                 fail(""VPN confirmation dialog did not return after "" + TIMEOUT_MS + ""ms"");             }              // Now we should be prepared.             intent = VpnService.prepare(mActivity);             if (intent != null) {                 fail(""VpnService.prepare returned non-null even after the VPN dialog "" +                      intent.getComponent() + ""returned RESULT_OK."");             }         }     }      // TODO: Consider replacing arguments with a Builder.     private void startVpn(         String[] addresses, String[] routes, String allowedApplications,         String disallowedApplications, @Nullable ProxyInfo proxyInfo,         @Nullable ArrayList<Network> underlyingNetworks, boolean isAlwaysMetered) throws Exception {         prepareVpn();          // Register a callback so we will be notified when our VPN comes up.         final NetworkRequest request = new NetworkRequest.Builder()                 .addTransportType(NetworkCapabilities.TRANSPORT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                 .build();         mCallback = new NetworkCallback() {             public void onAvailable(Network network) {                 synchronized (mLock) {                     Log.i(TAG, ""Got available callback for network="" + network);                     mNetwork = network;                     mLock.notify();                 }             }         };         mCM.registerNetworkCallback(request, mCallback);  // Unregistered in tearDown.          // Start the service and wait up for TIMEOUT_MS ms for the VPN to come up.         Intent intent = new Intent(mActivity, MyVpnService.class)                 .putExtra(mPackageName + "".cmd"", ""connect"")                 .putExtra(mPackageName + "".addresses"", TextUtils.join("","", addresses))                 .putExtra(mPackageName + "".routes"", TextUtils.join("","", routes))                 .putExtra(mPackageName + "".allowedapplications"", allowedApplications)                 .putExtra(mPackageName + "".disallowedapplications"", disallowedApplications)                 .putExtra(mPackageName + "".httpProxy"", proxyInfo)                 .putParcelableArrayListExtra(                     mPackageName + "".underlyingNetworks"", underlyingNetworks)                 .putExtra(mPackageName + "".isAlwaysMetered"", isAlwaysMetered);          mActivity.startService(intent);         synchronized (mLock) {             if (mNetwork == null) {                  Log.i(TAG, ""bf mLock"");                  mLock.wait(TIMEOUT_MS);                  Log.i(TAG, ""af mLock"");             }         }          if (mNetwork == null) {             fail(""VPN did not become available after "" + TIMEOUT_MS + ""ms"");         }          // Unfortunately, when the available callback fires, the VPN UID ranges are not yet         // configured. Give the system some time to do so. http://b/18436087 .         try { Thread.sleep(3000); } catch(InterruptedException e) {}     }      private void stopVpn() {         // Register a callback so we will be notified when our VPN comes up.         final NetworkRequest request = new NetworkRequest.Builder()                 .addTransportType(NetworkCapabilities.TRANSPORT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                 .build();         mCallback = new NetworkCallback() {             public void onLost(Network network) {                 synchronized (mLockShutdown) {                     Log.i(TAG, ""Got lost callback for network="" + network                             + "",mNetwork = "" + mNetwork);                     if( mNetwork == network){                         mLockShutdown.notify();                     }                 }             }        };         mCM.registerNetworkCallback(request, mCallback);  // Unregistered in tearDown.         // Simply calling mActivity.stopService() won't stop the service, because the system binds         // to the service for the purpose of sending it a revoke command if another VPN comes up,         // and stopping a bound service has no effect. Instead, ""start"" the service again with an         // Intent that tells it to disconnect.         Intent intent = new Intent(mActivity, MyVpnService.class)                 .putExtra(mPackageName + "".cmd"", ""disconnect"");         mActivity.startService(intent);         synchronized (mLockShutdown) {             try {                  Log.i(TAG, ""bf mLockShutdown"");                  mLockShutdown.wait(TIMEOUT_MS);                  Log.i(TAG, ""af mLockShutdown"");             } catch(InterruptedException e) {}         }     }      private static void closeQuietly(Closeable c) {         if (c != null) {             try {                 c.close();             } catch (IOException e) {             }         }     }      private static void checkPing(String to) throws IOException, ErrnoException {         InetAddress address = InetAddress.getByName(to);         FileDescriptor s;         final int LENGTH = 64;         byte[] packet = new byte[LENGTH];         byte[] header;          // Construct a ping packet.         Random random = new Random();         random.nextBytes(packet);         if (address instanceof Inet6Address) {             s = Os.socket(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6);             header = new byte[] { (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00 };         } else {             // Note that this doesn't actually work due to http://b/18558481 .             s = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);             header = new byte[] { (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00 };         }         System.arraycopy(header, 0, packet, 0, header.length);          // Send the packet.         int port = random.nextInt(65534) + 1;         Os.connect(s, address, port);         Os.write(s, packet, 0, packet.length);          // Expect a reply.         StructPollfd pollfd = new StructPollfd();         pollfd.events = (short) POLLIN;  // ""error: possible loss of precision""         pollfd.fd = s;         int ret = Os.poll(new StructPollfd[] { pollfd }, SOCKET_TIMEOUT_MS);         assertEquals(""Expected reply after sending ping"", 1, ret);          byte[] reply = new byte[LENGTH];         int read = Os.read(s, reply, 0, LENGTH);         assertEquals(LENGTH, read);          // Find out what the kernel set the ICMP ID to.         InetSocketAddress local = (InetSocketAddress) Os.getsockname(s);         port = local.getPort();         packet[4] = (byte) ((port >> 8) & 0xff);         packet[5] = (byte) (port & 0xff);          // Check the contents.         if (packet[0] == (byte) 0x80) {             packet[0] = (byte) 0x81;         } else {             packet[0] = 0;         }         // Zero out the checksum in the reply so it matches the uninitialized checksum in packet.         reply[2] = reply[3] = 0;         MoreAsserts.assertEquals(packet, reply);     }      // Writes data to out and checks that it appears identically on in.     private static void writeAndCheckData(             OutputStream out, InputStream in, byte[] data) throws IOException {         out.write(data, 0, data.length);         out.flush();          byte[] read = new byte[data.length];         int bytesRead = 0, totalRead = 0;         do {             bytesRead = in.read(read, totalRead, read.length - totalRead);             totalRead += bytesRead;         } while (bytesRead >= 0 && totalRead < data.length);         assertEquals(totalRead, data.length);         MoreAsserts.assertEquals(data, read);     }      private void checkTcpReflection(String to, String expectedFrom) throws IOException {         // Exercise TCP over the VPN by ""connecting to ourselves"". We open a server socket and a         // client socket, and connect the client socket to a remote host, with the port of the         // server socket. The PacketReflector reflects the packets, changing the source addresses         // but not the ports, so our client socket is connected to our server socket, though both         // sockets think their peers are on the ""remote"" IP address.          // Open a listening socket.         ServerSocket listen = new ServerSocket(0, 10, InetAddress.getByName(""::""));          // Connect the client socket to it.         InetAddress toAddr = InetAddress.getByName(to);         Socket client = new Socket();         try {             client.connect(new InetSocketAddress(toAddr, listen.getLocalPort()), SOCKET_TIMEOUT_MS);             if (expectedFrom == null) {                 closeQuietly(listen);                 closeQuietly(client);                 fail(""Expected connection to fail, but it succeeded."");             }         } catch (IOException e) {             if (expectedFrom != null) {                 closeQuietly(listen);                 fail(""Expected connection to succeed, but it failed."");             } else {                 // We expected the connection to fail, and it did, so there's nothing more to test.                 return;             }         }          // The connection succeeded, and we expected it to succeed. Send some data; if things are         // working, the data will be sent to the VPN, reflected by the PacketReflector, and arrive         // at our server socket. For good measure, send some data in the other direction.         Socket server = null;         try {             // Accept the connection on the server side.             listen.setSoTimeout(SOCKET_TIMEOUT_MS);             server = listen.accept();             checkConnectionOwnerUidTcp(client);             checkConnectionOwnerUidTcp(server);             // Check that the source and peer addresses are as expected.             assertEquals(expectedFrom, client.getLocalAddress().getHostAddress());             assertEquals(expectedFrom, server.getLocalAddress().getHostAddress());             assertEquals(                     new InetSocketAddress(toAddr, client.getLocalPort()),                     server.getRemoteSocketAddress());             assertEquals(                     new InetSocketAddress(toAddr, server.getLocalPort()),                     client.getRemoteSocketAddress());              // Now write some data.             final int LENGTH = 32768;             byte[] data = new byte[LENGTH];             new Random().nextBytes(data);              // Make sure our writes don't block or time out, because we're single-threaded and can't             // read and write at the same time.             server.setReceiveBufferSize(LENGTH * 2);             client.setSendBufferSize(LENGTH * 2);             client.setSoTimeout(SOCKET_TIMEOUT_MS);             server.setSoTimeout(SOCKET_TIMEOUT_MS);              // Send some data from client to server, then from server to client.             writeAndCheckData(client.getOutputStream(), server.getInputStream(), data);             writeAndCheckData(server.getOutputStream(), client.getInputStream(), data);         } finally {             closeQuietly(listen);             closeQuietly(client);             closeQuietly(server);         }     }      private void checkConnectionOwnerUidUdp(DatagramSocket s, boolean expectSuccess) {         final int expectedUid = expectSuccess ? Process.myUid() : INVALID_UID;         InetSocketAddress loc = new InetSocketAddress(s.getLocalAddress(), s.getLocalPort());         InetSocketAddress rem = new InetSocketAddress(s.getInetAddress(), s.getPort());         int uid = mCM.getConnectionOwnerUid(OsConstants.IPPROTO_UDP, loc, rem);         assertEquals(expectedUid, uid);     }      private void checkConnectionOwnerUidTcp(Socket s) {         final int expectedUid = Process.myUid();         InetSocketAddress loc = new InetSocketAddress(s.getLocalAddress(), s.getLocalPort());         InetSocketAddress rem = new InetSocketAddress(s.getInetAddress(), s.getPort());         int uid = mCM.getConnectionOwnerUid(OsConstants.IPPROTO_TCP, loc, rem);         assertEquals(expectedUid, uid);     }      private void checkUdpEcho(String to, String expectedFrom) throws IOException {         DatagramSocket s;         InetAddress address = InetAddress.getByName(to);         if (address instanceof Inet6Address) {  // http://b/18094870             s = new DatagramSocket(0, InetAddress.getByName(""::""));         } else {             s = new DatagramSocket();         }         s.setSoTimeout(SOCKET_TIMEOUT_MS);          Random random = new Random();         byte[] data = new byte[random.nextInt(1650)];         random.nextBytes(data);         DatagramPacket p = new DatagramPacket(data, data.length);         s.connect(address, 7);          if (expectedFrom != null) {             assertEquals(""Unexpected source address: "",                          expectedFrom, s.getLocalAddress().getHostAddress());         }          try {             if (expectedFrom != null) {                 s.send(p);                 checkConnectionOwnerUidUdp(s, true);                 s.receive(p);                 MoreAsserts.assertEquals(data, p.getData());             } else {                 try {                     s.send(p);                     s.receive(p);                     fail(""Received unexpected reply"");                 } catch (IOException expected) {                     checkConnectionOwnerUidUdp(s, false);                 }             }         } finally {             s.close();         }     }      private void checkTrafficOnVpn() throws Exception {         checkUdpEcho(""192.0.2.251"", ""192.0.2.2"");         checkUdpEcho(""2001:db8:dead:beef::f00"", ""2001:db8:1:2::ffe"");         checkPing(""2001:db8:dead:beef::f00"");         checkTcpReflection(""192.0.2.252"", ""192.0.2.2"");         checkTcpReflection(""2001:db8:dead:beef::f00"", ""2001:db8:1:2::ffe"");     }      private void checkNoTrafficOnVpn() throws Exception {         checkUdpEcho(""192.0.2.251"", null);         checkUdpEcho(""2001:db8:dead:beef::f00"", null);         checkTcpReflection(""192.0.2.252"", null);         checkTcpReflection(""2001:db8:dead:beef::f00"", null);     }      private FileDescriptor openSocketFd(String host, int port, int timeoutMs) throws Exception {         Socket s = new Socket(host, port);         s.setSoTimeout(timeoutMs);         // Dup the filedescriptor so ParcelFileDescriptor's finalizer doesn't garbage collect it         // and cause our fd to become invalid. http://b/35927643 .         FileDescriptor fd = Os.dup(ParcelFileDescriptor.fromSocket(s).getFileDescriptor());         s.close();         return fd;     }      private FileDescriptor openSocketFdInOtherApp(             String host, int port, int timeoutMs) throws Exception {         Log.d(TAG, String.format(""Creating test socket in UID=%d, my UID=%d"",                 mRemoteSocketFactoryClient.getUid(), Os.getuid()));         FileDescriptor fd = mRemoteSocketFactoryClient.openSocketFd(host, port, TIMEOUT_MS);         return fd;     }      private void sendRequest(FileDescriptor fd, String host) throws Exception {         String request = ""GET /generate_204 HTTP/1.1\r\n"" +                 ""Host: "" + host + ""\r\n"" +                 ""Connection: keep-alive\r\n\r\n"";         byte[] requestBytes = request.getBytes(StandardCharsets.UTF_8);         int ret = Os.write(fd, requestBytes, 0, requestBytes.length);         Log.d(TAG, ""Wrote "" + ret + ""bytes"");          String expected = ""HTTP/1.1 204 No Content\r\n"";         byte[] response = new byte[expected.length()];         Os.read(fd, response, 0, response.length);          String actual = new String(response, StandardCharsets.UTF_8);         assertEquals(expected, actual);         Log.d(TAG, ""Got response: "" + actual);     }      private void assertSocketStillOpen(FileDescriptor fd, String host) throws Exception {         try {             assertTrue(fd.valid());             sendRequest(fd, host);             assertTrue(fd.valid());         } finally {             Os.close(fd);         }     }      private void assertSocketClosed(FileDescriptor fd, String host) throws Exception {         try {             assertTrue(fd.valid());             sendRequest(fd, host);             fail(""Socket opened before VPN connects should be closed when VPN connects"");         } catch (ErrnoException expected) {             assertEquals(ECONNABORTED, expected.errno);             assertTrue(fd.valid());         } finally {             Os.close(fd);         }     }      private ContentResolver getContentResolver() {         return getInstrumentation().getContext().getContentResolver();     }      private boolean isPrivateDnsInStrictMode() {         return PRIVATE_DNS_MODE_PROVIDER_HOSTNAME.equals(                 Settings.Global.getString(getContentResolver(), PRIVATE_DNS_MODE_SETTING));     }      private void storePrivateDnsSetting() {         mOldPrivateDnsMode = Settings.Global.getString(getContentResolver(),                 PRIVATE_DNS_MODE_SETTING);         mOldPrivateDnsSpecifier = Settings.Global.getString(getContentResolver(),                 PRIVATE_DNS_SPECIFIER_SETTING);     }      private void restorePrivateDnsSetting() {         Settings.Global.putString(getContentResolver(), PRIVATE_DNS_MODE_SETTING,                 mOldPrivateDnsMode);         Settings.Global.putString(getContentResolver(), PRIVATE_DNS_SPECIFIER_SETTING,                 mOldPrivateDnsSpecifier);     }      // TODO: replace with CtsNetUtils.awaitPrivateDnsSetting in Q or above.     private void expectPrivateDnsHostname(final String hostname) throws Exception {         final NetworkRequest request = new NetworkRequest.Builder()                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)                 .build();         final CountDownLatch latch = new CountDownLatch(1);         final NetworkCallback callback = new NetworkCallback() {             @Override             public void onLinkPropertiesChanged(Network network, LinkProperties lp) {                 if (network.equals(mNetwork) &&                         Objects.equals(lp.getPrivateDnsServerName(), hostname)) {                     latch.countDown();                 }             }         };          mCM.registerNetworkCallback(request, callback);          try {             assertTrue(""Private DNS hostname was not "" + hostname + "" after "" + TIMEOUT_MS + ""ms"",                     latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));         } finally {             mCM.unregisterNetworkCallback(callback);         }     }      private void setAndVerifyPrivateDns(boolean strictMode) throws Exception {         final ContentResolver cr = getInstrumentation().getContext().getContentResolver();         String privateDnsHostname;          if (strictMode) {             privateDnsHostname = ""vpncts-nx.metric.gstatic.com"";             Settings.Global.putString(cr, PRIVATE_DNS_SPECIFIER_SETTING, privateDnsHostname);             Settings.Global.putString(cr, PRIVATE_DNS_MODE_SETTING,                     PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);         } else {             Settings.Global.putString(cr, PRIVATE_DNS_MODE_SETTING, PRIVATE_DNS_MODE_OPPORTUNISTIC);             privateDnsHostname = null;         }          expectPrivateDnsHostname(privateDnsHostname);          String randomName = ""vpncts-"" + new Random().nextInt(1000000000) + ""-ds.metric.gstatic.com"";         if (strictMode) {             // Strict mode private DNS is enabled. DNS lookups should fail, because the private DNS             // server name is invalid.             try {                 InetAddress.getByName(randomName);                 fail(""VPN DNS lookup should fail with private DNS enabled"");             } catch (UnknownHostException expected) {             }         } else {             // Strict mode private DNS is disabled. DNS lookup should succeed, because the VPN             // provides no DNS servers, and thus DNS falls through to the default network.             assertNotNull(""VPN DNS lookup should succeed with private DNS disabled"",                     InetAddress.getByName(randomName));         }     }      // Tests that strict mode private DNS is used on VPNs.     private void checkStrictModePrivateDns() throws Exception {         final boolean initialMode = isPrivateDnsInStrictMode();         setAndVerifyPrivateDns(!initialMode);         setAndVerifyPrivateDns(initialMode);     }      public void testDefault() throws Exception {         if (!supportedHardware()) return;         // If adb TCP port opened, this test may running by adb over network.         // All of socket would be destroyed in this test. So this test don't         // support adb over network, see b/119382723.         if (SystemProperties.getInt(""persist.adb.tcp.port"", -1) > -1                 || SystemProperties.getInt(""service.adb.tcp.port"", -1) > -1) {             Log.i(TAG, ""adb is running over the network, so skip this test"");             return;         }          final BlockingBroadcastReceiver receiver = new BlockingBroadcastReceiver(                 getInstrumentation().getTargetContext(), MyVpnService.ACTION_ESTABLISHED);         receiver.register();          FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""0.0.0.0/0"", ""::/0""},                  """", """", null, null /* underlyingNetworks */, false /* isAlwaysMetered */);          final Intent intent = receiver.awaitForBroadcast(TimeUnit.MINUTES.toMillis(1));         assertNotNull(""Failed to receive broadcast from VPN service"", intent);         assertFalse(""Wrong VpnService#isAlwaysOn"",                 intent.getBooleanExtra(MyVpnService.EXTRA_ALWAYS_ON, true));         assertFalse(""Wrong VpnService#isLockdownEnabled"",                 intent.getBooleanExtra(MyVpnService.EXTRA_LOCKDOWN_ENABLED, true));          assertSocketClosed(fd, TEST_HOST);          checkTrafficOnVpn();          checkStrictModePrivateDns();          receiver.unregisterQuietly();     }      public void testAppAllowed() throws Exception {         if (!supportedHardware()) return;          FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);          // Shell app must not be put in here or it would kill the ADB-over-network use case         String allowedApps = mRemoteSocketFactoryClient.getPackageName() + "","" + mPackageName;         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""192.0.2.0/24"", ""2001:db8::/32""},                  allowedApps, """", null, null /* underlyingNetworks */, false /* isAlwaysMetered */);          assertSocketClosed(fd, TEST_HOST);          checkTrafficOnVpn();          checkStrictModePrivateDns();     }      public void testAppDisallowed() throws Exception {         if (!supportedHardware()) return;          FileDescriptor localFd = openSocketFd(TEST_HOST, 80, TIMEOUT_MS);         FileDescriptor remoteFd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);          String disallowedApps = mRemoteSocketFactoryClient.getPackageName() + "","" + mPackageName;         // If adb TCP port opened, this test may running by adb over TCP.         // Add com.android.shell appllication into blacklist to exclude adb socket for VPN test,         // see b/119382723.         // Note: The test don't support running adb over network for root device         disallowedApps = disallowedApps + "",com.android.shell"";         Log.i(TAG, ""Append shell app to disallowedApps: "" + disallowedApps);         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""192.0.2.0/24"", ""2001:db8::/32""},                  """", disallowedApps, null, null /* underlyingNetworks */,                  false /* isAlwaysMetered */);          assertSocketStillOpen(localFd, TEST_HOST);         assertSocketStillOpen(remoteFd, TEST_HOST);          checkNoTrafficOnVpn();     }      public void testGetConnectionOwnerUidSecurity() throws Exception {         if (!supportedHardware()) return;          DatagramSocket s;         InetAddress address = InetAddress.getByName(""localhost"");         s = new DatagramSocket();         s.setSoTimeout(SOCKET_TIMEOUT_MS);         s.connect(address, 7);         InetSocketAddress loc = new InetSocketAddress(s.getLocalAddress(), s.getLocalPort());         InetSocketAddress rem = new InetSocketAddress(s.getInetAddress(), s.getPort());         try {             int uid = mCM.getConnectionOwnerUid(OsConstants.IPPROTO_TCP, loc, rem);             fail(""Only an active VPN app may call this API."");         } catch (SecurityException expected) {             return;         }     }      public void testSetProxy() throws  Exception {         if (!supportedHardware()) return;         ProxyInfo initialProxy = mCM.getDefaultProxy();         // Receiver for the proxy change broadcast.         BlockingBroadcastReceiver proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();          String allowedApps = mPackageName;         ProxyInfo testProxyInfo = ProxyInfo.buildDirectProxy(""10.0.0.1"", 8888);         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """",                 testProxyInfo, null /* underlyingNetworks */, false /* isAlwaysMetered */);          // Check that the proxy change broadcast is received         try {             assertNotNull(""No proxy change was broadcast when VPN is connected."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }          // Proxy is set correctly in network and in link properties.         assertNetworkHasExpectedProxy(testProxyInfo, mNetwork);         assertDefaultProxy(testProxyInfo);          proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         stopVpn();         try {             assertNotNull(""No proxy change was broadcast when VPN was disconnected."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }          // After disconnecting from VPN, the proxy settings are the ones of the initial network.         assertDefaultProxy(initialProxy);     }      public void testSetProxyDisallowedApps() throws Exception {         if (!supportedHardware()) return;         ProxyInfo initialProxy = mCM.getDefaultProxy();          // If adb TCP port opened, this test may running by adb over TCP.         // Add com.android.shell appllication into blacklist to exclude adb socket for VPN test,         // see b/119382723.         // Note: The test don't support running adb over network for root device         String disallowedApps = mPackageName + "",com.android.shell"";         ProxyInfo testProxyInfo = ProxyInfo.buildDirectProxy(""10.0.0.1"", 8888);         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, """", disallowedApps,                 testProxyInfo, null /* underlyingNetworks */, false /* isAlwaysMetered */);          // The disallowed app does has the proxy configs of the default network.         assertNetworkHasExpectedProxy(initialProxy, mCM.getActiveNetwork());         assertDefaultProxy(initialProxy);     }      public void testNoProxy() throws Exception {         if (!supportedHardware()) return;         ProxyInfo initialProxy = mCM.getDefaultProxy();         BlockingBroadcastReceiver proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         String allowedApps = mPackageName;         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 null /* underlyingNetworks */, false /* isAlwaysMetered */);          try {             assertNotNull(""No proxy change was broadcast."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }          // The VPN network has no proxy set.         assertNetworkHasExpectedProxy(null, mNetwork);          proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         stopVpn();         try {             assertNotNull(""No proxy change was broadcast."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }         // After disconnecting from VPN, the proxy settings are the ones of the initial network.         assertDefaultProxy(initialProxy);         assertNetworkHasExpectedProxy(initialProxy, mCM.getActiveNetwork());     }      public void testBindToNetworkWithProxy() throws Exception {         if (!supportedHardware()) return;         String allowedApps = mPackageName;         Network initialNetwork = mCM.getActiveNetwork();         ProxyInfo initialProxy = mCM.getDefaultProxy();         ProxyInfo testProxyInfo = ProxyInfo.buildDirectProxy(""10.0.0.1"", 8888);         // Receiver for the proxy change broadcast.         BlockingBroadcastReceiver proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """",                 testProxyInfo, null /* underlyingNetworks */, false /* isAlwaysMetered */);          assertDefaultProxy(testProxyInfo);         mCM.bindProcessToNetwork(initialNetwork);         try {             assertNotNull(""No proxy change was broadcast."",                 proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }         assertDefaultProxy(initialProxy);     }      public void testVpnMeterednessWithNoUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         // VPN is not routing any traffic i.e. its underlying networks is an empty array.         ArrayList<Network> underlyingNetworks = new ArrayList<>();         String allowedApps = mPackageName;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, false /* isAlwaysMetered */);          // VPN should now be the active network.         assertEquals(mNetwork, mCM.getActiveNetwork());         assertVpnTransportContains(NetworkCapabilities.TRANSPORT_VPN);         // VPN with no underlying networks should be metered by default.         assertTrue(isNetworkMetered(mNetwork));         assertTrue(mCM.isActiveNetworkMetered());     }      public void testVpnMeterednessWithNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testVpnMeterednessWithNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN tracks platform default.         ArrayList<Network> underlyingNetworks = null;         String allowedApps = mPackageName;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, false /*isAlwaysMetered */);          // Ensure VPN transports contains underlying network's transports.         assertVpnTransportContains(underlyingNetwork);         // Its meteredness should be same as that of underlying network.         assertEquals(isNetworkMetered(underlyingNetwork), isNetworkMetered(mNetwork));         // Meteredness based on VPN capabilities and CM#isActiveNetworkMetered should be in sync.         assertEquals(isNetworkMetered(mNetwork), mCM.isActiveNetworkMetered());     }      public void testVpnMeterednessWithNonNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testVpnMeterednessWithNonNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN explicitly declares WiFi to be its underlying network.         ArrayList<Network> underlyingNetworks = new ArrayList<>(1);         underlyingNetworks.add(underlyingNetwork);         String allowedApps = mPackageName;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, false /* isAlwaysMetered */);          // Ensure VPN transports contains underlying network's transports.         assertVpnTransportContains(underlyingNetwork);         // Its meteredness should be same as that of underlying network.         assertEquals(isNetworkMetered(underlyingNetwork), isNetworkMetered(mNetwork));         // Meteredness based on VPN capabilities and CM#isActiveNetworkMetered should be in sync.         assertEquals(isNetworkMetered(mNetwork), mCM.isActiveNetworkMetered());     }      public void testAlwaysMeteredVpnWithNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testAlwaysMeteredVpnWithNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN tracks platform default.         ArrayList<Network> underlyingNetworks = null;         String allowedApps = mPackageName;         boolean isAlwaysMetered = true;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, isAlwaysMetered);          // VPN's meteredness does not depend on underlying network since it is always metered.         assertTrue(isNetworkMetered(mNetwork));         assertTrue(mCM.isActiveNetworkMetered());     }      public void testAlwaysMeteredVpnWithNonNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testAlwaysMeteredVpnWithNonNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN explicitly declares its underlying network.         ArrayList<Network> underlyingNetworks = new ArrayList<>(1);         underlyingNetworks.add(underlyingNetwork);         String allowedApps = mPackageName;         boolean isAlwaysMetered = true;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, isAlwaysMetered);          // VPN's meteredness does not depend on underlying network since it is always metered.         assertTrue(isNetworkMetered(mNetwork));         assertTrue(mCM.isActiveNetworkMetered());     }      public void testB141603906() throws Exception {         if (!supportedHardware()) {             return;         }         final InetSocketAddress src = new InetSocketAddress(0);         final InetSocketAddress dst = new InetSocketAddress(0);         final int NUM_THREADS = 8;         final int NUM_SOCKETS = 5000;         final Thread[] threads = new Thread[NUM_THREADS];         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""0.0.0.0/0"", ""::/0""},                  """" /* allowedApplications */, ""com.android.shell"" /* disallowedApplications */,                 null /* proxyInfo */, null /* underlyingNetworks */, false /* isAlwaysMetered */);          for (int i = 0; i < NUM_THREADS; i++) {             threads[i] = new Thread(() -> {                 for (int j = 0; j < NUM_SOCKETS; j++) {                     mCM.getConnectionOwnerUid(IPPROTO_TCP, src, dst);                 }             });         }         for (Thread thread : threads) {             thread.start();         }         for (Thread thread : threads) {             thread.join();         }         stopVpn();     }      private boolean isNetworkMetered(Network network) {         NetworkCapabilities nc = mCM.getNetworkCapabilities(network);         return !nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);     }      private void assertVpnTransportContains(Network underlyingNetwork) {         int[] transports = mCM.getNetworkCapabilities(underlyingNetwork).getTransportTypes();         assertVpnTransportContains(transports);     }      private void assertVpnTransportContains(int... transports) {         NetworkCapabilities vpnCaps = mCM.getNetworkCapabilities(mNetwork);         for (int transport : transports) {             assertTrue(vpnCaps.hasTransport(transport));         }     }      private void assertDefaultProxy(ProxyInfo expected) {         assertEquals(""Incorrect proxy config."", expected, mCM.getDefaultProxy());         String expectedHost = expected == null ? null : expected.getHost();         String expectedPort = expected == null ? null : String.valueOf(expected.getPort());         assertEquals(""Incorrect proxy host system property."", expectedHost,             System.getProperty(""http.proxyHost""));         assertEquals(""Incorrect proxy port system property."", expectedPort,             System.getProperty(""http.proxyPort""));     }      private void assertNetworkHasExpectedProxy(ProxyInfo expected, Network network) {         LinkProperties lp = mCM.getLinkProperties(network);         assertNotNull(""The network link properties object is null."", lp);         assertEquals(""Incorrect proxy config."", expected, lp.getHttpProxy());          assertEquals(expected, mCM.getProxyForNetwork(network));     }      class ProxyChangeBroadcastReceiver extends BlockingBroadcastReceiver {         private boolean received;          public ProxyChangeBroadcastReceiver() {             super(VpnTest.this.getInstrumentation().getContext(), Proxy.PROXY_CHANGE_ACTION);             received = false;         }          @Override         public void onReceive(Context context, Intent intent) {             if (!received) {                 // Do not call onReceive() more than once.                 super.onReceive(context, intent);             }             received = true;         }     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.AbstractAppIdleTestCase"	"registerBroadcastReceiver"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/AbstractAppIdleTestCase.java"	""	"/*  *.  */  package com.android.cts.net.hostside;  import static com.android.cts.net.hostside.Property.APP_STANDBY_MODE; import static com.android.cts.net.hostside.Property.BATTERY_SAVER_MODE;  import static org.junit.Assert.assertEquals;  import android.os.SystemClock;  import org.junit.After; import org.junit.Before; import org.junit.Test;  /**  * Base class for metered and non-metered tests on idle apps.  */ @RequiredProperties({APP_STANDBY_MODE}) abstract class AbstractAppIdleTestCase extends AbstractRestrictBackgroundNetworkTestCase {      @Before     public final void setUp() throws Exception {         super.setUp();          // Set initial state.         removePowerSaveModeWhitelist(TEST_APP2_PKG);         removePowerSaveModeExceptIdleWhitelist(TEST_APP2_PKG);         setAppIdle(false);         turnBatteryOn();          registerBroadcastReceiver();     }      @After     public final void tearDown() throws Exception {         super.tearDown();          executeSilentShellCommand(""cmd battery reset"");         setAppIdle(false);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.AbstractAppIdleTestCase"	"testAppIdleNetworkAccess_whenCharging"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/AbstractAppIdleTestCase.java"	""	"public void testAppIdleNetworkAccess_whenCharging() throws Exception {         // Check that app is paroled when charging         setAppIdle(true);         assertBackgroundNetworkAccess(false);         turnBatteryOff();         assertBackgroundNetworkAccess(true);         turnBatteryOn();         assertBackgroundNetworkAccess(false);          // Check that app is restricted when not idle but power-save is on         setAppIdle(false);         assertBackgroundNetworkAccess(true);         setBatterySaverMode(true);         assertBackgroundNetworkAccess(false);         // Use setBatterySaverMode API to leave power-save mode instead of plugging in charger         setBatterySaverMode(false);         turnBatteryOff();         assertBackgroundNetworkAccess(true);          // And when no longer charging, it still has network access, since it's not idle         turnBatteryOn();         assertBackgroundNetworkAccess(true);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.ConnectivityManagerTest"	"disconnectFromCell"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"/*  *.  */  package android.net.cts;  import static android.Manifest.permission.CONNECTIVITY_USE_RESTRICTED_NETWORKS; import static android.content.pm.PackageManager.FEATURE_ETHERNET; import static android.content.pm.PackageManager.FEATURE_TELEPHONY; import static android.content.pm.PackageManager.FEATURE_USB_HOST; import static android.content.pm.PackageManager.FEATURE_WIFI; import static android.content.pm.PackageManager.GET_PERMISSIONS; import static android.content.pm.PackageManager.PERMISSION_GRANTED; import static android.net.NetworkCapabilities.NET_CAPABILITY_IMS; import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET; import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED; import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED; import static android.net.NetworkCapabilities.TRANSPORT_WIFI; import static android.net.cts.util.CtsNetUtils.ConnectivityActionReceiver; import static android.net.cts.util.CtsNetUtils.HTTP_PORT; import static android.net.cts.util.CtsNetUtils.NETWORK_CALLBACK_ACTION; import static android.net.cts.util.CtsNetUtils.TEST_HOST; import static android.net.cts.util.CtsNetUtils.TestNetworkCallback; import static android.os.MessageQueue.OnFileDescriptorEventListener.EVENT_INPUT; import static android.provider.Settings.Global.NETWORK_METERED_MULTIPATH_PREFERENCE; import static android.system.OsConstants.AF_INET; import static android.system.OsConstants.AF_INET6; import static android.system.OsConstants.AF_UNSPEC;  import static com.android.compatibility.common.util.SystemUtil.runShellCommand; import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail; import static org.junit.Assume.assumeTrue;  import android.annotation.NonNull; import android.app.Instrumentation; import android.app.PendingIntent; import android.app.UiAutomation; import android.content.ContentResolver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.res.Resources; import android.net.ConnectivityManager; import android.net.ConnectivityManager.NetworkCallback; import android.net.IpSecManager; import android.net.IpSecManager.UdpEncapsulationSocket; import android.net.LinkProperties; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkConfig; import android.net.NetworkInfo; import android.net.NetworkInfo.DetailedState; import android.net.NetworkInfo.State; import android.net.NetworkRequest; import android.net.NetworkUtils; import android.net.SocketKeepalive; import android.net.cts.util.CtsNetUtils; import android.net.util.KeepaliveUtils; import android.net.wifi.WifiManager; import android.os.Binder; import android.os.Build; import android.os.Looper; import android.os.MessageQueue; import android.os.SystemClock; import android.os.SystemProperties; import android.os.VintfRuntimeInfo; import android.platform.test.annotations.AppModeFull; import android.provider.Settings; import android.text.TextUtils; import android.util.Log; import android.util.Pair;  import androidx.test.InstrumentationRegistry; import androidx.test.runner.AndroidJUnit4;  import com.android.internal.util.ArrayUtils; import com.android.testutils.SkipPresubmit;  import libcore.io.Streams;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  import java.io.FileDescriptor; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.Inet4Address; import java.net.Inet6Address; import java.net.InetAddress; import java.net.InetSocketAddress; import java.net.Socket; import java.net.URL; import java.net.UnknownHostException; import java.nio.charset.StandardCharsets; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.concurrent.CountDownLatch; import java.util.concurrent.Executor; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.TimeUnit; import java.util.function.Supplier; import java.util.regex.Matcher; import java.util.regex.Pattern;  @RunWith(AndroidJUnit4.class) public class ConnectivityManagerTest {      private static final String TAG = ConnectivityManagerTest.class.getSimpleName();      public static final int TYPE_MOBILE = ConnectivityManager.TYPE_MOBILE;     public static final int TYPE_WIFI = ConnectivityManager.TYPE_WIFI;      private static final int HOST_ADDRESS = 0x7f000001;// represent ip 127.0.0.1     private static final int KEEPALIVE_CALLBACK_TIMEOUT_MS = 2000;     private static final int INTERVAL_KEEPALIVE_RETRY_MS = 500;     private static final int MAX_KEEPALIVE_RETRY_COUNT = 3;     private static final int MIN_KEEPALIVE_INTERVAL = 10;      // Changing meteredness on wifi involves reconnecting, which can take several seconds (involves     // re-associating, DHCP...)     private static final int NETWORK_CHANGE_METEREDNESS_TIMEOUT = 30_000;     private static final int NUM_TRIES_MULTIPATH_PREF_CHECK = 20;     private static final long INTERVAL_MULTIPATH_PREF_CHECK_MS = 500;     // device could have only one interface: data, wifi.     private static final int MIN_NUM_NETWORK_TYPES = 1;      // Minimum supported keepalive counts for wifi and cellular.     public static final int MIN_SUPPORTED_CELLULAR_KEEPALIVE_COUNT = 1;     public static final int MIN_SUPPORTED_WIFI_KEEPALIVE_COUNT = 3;      private static final String NETWORK_METERED_MULTIPATH_PREFERENCE_RES_NAME =             ""config_networkMeteredMultipathPreference"";     private static final String KEEPALIVE_ALLOWED_UNPRIVILEGED_RES_NAME =             ""config_allowedUnprivilegedKeepalivePerUid"";     private static final String KEEPALIVE_RESERVED_PER_SLOT_RES_NAME =             ""config_reservedPrivilegedKeepaliveSlots"";      private Context mContext;     private Instrumentation mInstrumentation;     private ConnectivityManager mCm;     private WifiManager mWifiManager;     private PackageManager mPackageManager;     private final HashMap<Integer, NetworkConfig> mNetworks =             new HashMap<Integer, NetworkConfig>();     boolean mWifiWasDisabled;     private UiAutomation mUiAutomation;     private CtsNetUtils mCtsNetUtils;      @Before     public void setUp() throws Exception {         mInstrumentation = InstrumentationRegistry.getInstrumentation();         mContext = mInstrumentation.getContext();         mCm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);         mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);         mPackageManager = mContext.getPackageManager();         mCtsNetUtils = new CtsNetUtils(mContext);         mWifiWasDisabled = false;          // Get com.android.internal.R.array.networkAttributes         int resId = mContext.getResources().getIdentifier(""networkAttributes"", ""array"", ""android"");         String[] naStrings = mContext.getResources().getStringArray(resId);         //TODO: What is the ""correct"" way to determine if this is a wifi only device?         boolean wifiOnly = SystemProperties.getBoolean(""ro.radio.noril"", false);         for (String naString : naStrings) {             try {                 NetworkConfig n = new NetworkConfig(naString);                 if (wifiOnly && ConnectivityManager.isNetworkTypeMobile(n.type)) {                     continue;                 }                 mNetworks.put(n.type, n);             } catch (Exception e) {}         }         mUiAutomation = mInstrumentation.getUiAutomation();     }      @After     public void tearDown() throws Exception {         // Return WiFi to its original disabled state after tests that explicitly connect.         if (mWifiWasDisabled) {             mCtsNetUtils.disconnectFromWifi(null);         }         if (mCtsNetUtils.cellConnectAttempted()) {             mCtsNetUtils.disconnectFromCell();         }     }      /**      * Make sure WiFi is connected to an access point if it is not already. If      * WiFi is enabled as a result of this function, it will be disabled      * automatically in tearDown().      */     private Network ensureWifiConnected() {         mWifiWasDisabled = !mWifiManager.isWifiEnabled();         // Even if wifi is enabled, the network may not be connected or ready yet         return mCtsNetUtils.connectToWifi();     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.ConnectivityManagerTest"	"testRequestNetworkCallback_onUnavailable"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"public void testRequestNetworkCallback_onUnavailable() {         final boolean previousWifiEnabledState = mWifiManager.isWifiEnabled();         if (previousWifiEnabledState) {             mCtsNetUtils.disconnectFromWifi(null);         }          final TestNetworkCallback callback = new TestNetworkCallback();         mCm.requestNetwork(new NetworkRequest.Builder()                 .addTransportType(TRANSPORT_WIFI)                 .build(), callback, 100);          try {             // Wait to get callback for unavailability of requested network             assertTrue(""Did not receive NetworkCallback#onUnavailable"",                     callback.waitForUnavailable());         } catch (InterruptedException e) {             fail(""NetworkCallback wait was interrupted."");         } finally {             mCm.unregisterNetworkCallback(callback);             if (previousWifiEnabledState) {                 mCtsNetUtils.connectToWifi();             }         }     }      private InetAddress getFirstV4Address(Network network) {         LinkProperties linkProperties = mCm.getLinkProperties(network);         for (InetAddress address : linkProperties.getAddresses()) {             if (address instanceof Inet4Address) {                 return address;             }         }         return null;     }      /** Verify restricted networks cannot be requested. */     @AppModeFull(reason = ""CHANGE_NETWORK_STATE permission can't be granted to instant apps"")"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.ConnectivityManagerTest"	"testRestrictedNetworks"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"public void testRestrictedNetworks() {         // Verify we can request unrestricted networks:         NetworkRequest request = new NetworkRequest.Builder()                 .addCapability(NET_CAPABILITY_INTERNET).build();         NetworkCallback callback = new NetworkCallback();         mCm.requestNetwork(request, callback);         mCm.unregisterNetworkCallback(callback);         // Verify we cannot request restricted networks:         request = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_IMS).build();         callback = new NetworkCallback();         try {             mCm.requestNetwork(request, callback);             fail(""No exception thrown when restricted network requested."");         } catch (SecurityException expected) {}     }      // Returns ""true"", ""false"" or ""none""     private String getWifiMeteredStatus(String ssid) throws Exception {         // Interestingly giving the SSID as an argument to list wifi-networks         // only works iff the network in question has the ""false"" policy.         // Also unfortunately runShellCommand does not pass the command to the interpreter         // so it's not possible to | grep the ssid.         final String command = ""cmd netpolicy list wifi-networks"";         final String policyString = runShellCommand(mInstrumentation, command);          final Matcher m = Pattern.compile(""^"" + ssid + "";(true|false|none)$"",                 Pattern.MULTILINE | Pattern.UNIX_LINES).matcher(policyString);         if (!m.find()) {             fail(""Unexpected format from cmd netpolicy"");         }         return m.group(1);     }      // metered should be ""true"", ""false"" or ""none""     private void setWifiMeteredStatus(String ssid, String metered) throws Exception {         final String setCommand = ""cmd netpolicy set metered-network "" + ssid + "" "" + metered;         runShellCommand(mInstrumentation, setCommand);         assertEquals(getWifiMeteredStatus(ssid), metered);     }      private String unquoteSSID(String ssid) {         // SSID is returned surrounded by quotes if it can be decoded as UTF-8.         // Otherwise it's guaranteed not to start with a quote.         if (ssid.charAt(0) == '""') {             return ssid.substring(1, ssid.length() - 1);         } else {             return ssid;         }     }      private void waitForActiveNetworkMetered(int targetTransportType, boolean requestedMeteredness)             throws Exception {         final CountDownLatch latch = new CountDownLatch(1);         final NetworkCallback networkCallback = new NetworkCallback() {             @Override             public void onCapabilitiesChanged(Network network, NetworkCapabilities nc) {                 if (!nc.hasTransport(targetTransportType)) return;                  final boolean metered = !nc.hasCapability(NET_CAPABILITY_NOT_METERED);                 if (metered == requestedMeteredness) {                     latch.countDown();                 }             }         };         // Registering a callback here guarantees onCapabilitiesChanged is called immediately         // with the current setting. Therefore, if the setting has already been changed,         // this method will return right away, and if not it will wait for the setting to change.         mCm.registerDefaultNetworkCallback(networkCallback);         if (!latch.await(NETWORK_CHANGE_METEREDNESS_TIMEOUT, TimeUnit.MILLISECONDS)) {             fail(""Timed out waiting for active network metered status to change to ""                  + requestedMeteredness + "" ; network = "" + mCm.getActiveNetwork());         }         mCm.unregisterNetworkCallback(networkCallback);     }      private void assertMultipathPreferenceIsEventually(Network network, int oldValue,             int expectedValue) {         // Sanity check : if oldValue == expectedValue, there is no way to guarantee the test         // is not flaky.         assertNotSame(oldValue, expectedValue);          for (int i = 0; i < NUM_TRIES_MULTIPATH_PREF_CHECK; ++i) {             final int actualValue = mCm.getMultipathPreference(network);             if (actualValue == expectedValue) {                 return;             }             if (actualValue != oldValue) {                 fail(""Multipath preference is neither previous ("" + oldValue                         + "") nor expected ("" + expectedValue + "")"");             }             SystemClock.sleep(INTERVAL_MULTIPATH_PREF_CHECK_MS);         }         fail(""Timed out waiting for multipath preference to change. expected = ""                 + expectedValue + "" ; actual = "" + mCm.getMultipathPreference(network));     }      private int getCurrentMeteredMultipathPreference(ContentResolver resolver) {         final String rawMeteredPref = Settings.Global.getString(resolver,                 NETWORK_METERED_MULTIPATH_PREFERENCE);         return TextUtils.isEmpty(rawMeteredPref)             ? getIntResourceForName(NETWORK_METERED_MULTIPATH_PREFERENCE_RES_NAME)             : Integer.parseInt(rawMeteredPref);     }      private int findNextPrefValue(ContentResolver resolver) {         // A bit of a nuclear hammer, but race conditions in CTS are bad. To be able to         // detect a correct setting value without race conditions, the next pref must         // be a valid value (range 0..3) that is different from the old setting of the         // metered preference and from the unmetered preference.         final int meteredPref = getCurrentMeteredMultipathPreference(resolver);         final int unmeteredPref = ConnectivityManager.MULTIPATH_PREFERENCE_UNMETERED;         if (0 != meteredPref && 0 != unmeteredPref) return 0;         if (1 != meteredPref && 1 != unmeteredPref) return 1;         return 2;     }      /**      * Verify that getMultipathPreference does return appropriate values      * for metered and unmetered networks.      */     @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.ConnectivityManagerTest"	"testSocketKeepaliveUnprivileged"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"@SkipPresubmit(reason = ""Keepalive is not supported on virtual hardware"")     public void testSocketKeepaliveUnprivileged() throws Exception {         if (!mPackageManager.hasSystemFeature(FEATURE_WIFI)) {             Log.i(TAG, ""testSocketKeepaliveUnprivileged cannot execute unless device""                     + "" supports WiFi"");             return;         }          final Network network = ensureWifiConnected();         final int supported = getSupportedKeepalivesForNet(network);         if (supported == 0) {             return;         }         final InetAddress srcAddr = getFirstV4Address(network);         assumeTrue(""This test requires native IPv4"", srcAddr != null);          // Resource ID might be shifted on devices that compiled with different symbols.         // Thus, resolve ID at runtime is needed.         final int allowedUnprivilegedPerUid =                 getIntResourceForName(KEEPALIVE_ALLOWED_UNPRIVILEGED_RES_NAME);         final int reservedPrivilegedSlots =                 getIntResourceForName(KEEPALIVE_RESERVED_PER_SLOT_RES_NAME);         // Verifies that unprivileged request per uid cannot exceed the limit customized in the         // resource. Currently, unprivileged keepalive slots are limited to Nat-T only, this test         // does not apply to TCP.         assertGreaterOrEqual(supported, reservedPrivilegedSlots);         assertGreaterOrEqual(supported, allowedUnprivilegedPerUid);         final int expectedUnprivileged =                 Math.min(allowedUnprivilegedPerUid, supported - reservedPrivilegedSlots);         assertEquals(expectedUnprivileged,                 createConcurrentSocketKeepalives(network, srcAddr, supported + 1, 0));     }      private static void assertGreaterOrEqual(long greater, long lesser) {         assertTrue("""" + greater + "" expected to be greater than or equal to "" + lesser,                 greater >= lesser);     }      /**      * Verifies that apps are not allowed to access restricted networks even if they declare the      * CONNECTIVITY_USE_RESTRICTED_NETWORKS permission in their manifests.      * See. b/144679405.      */     @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.ConnectivityManagerTest"	"testRestrictedNetworkPermission"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"public void testRestrictedNetworkPermission() throws Exception {         // Ensure that CONNECTIVITY_USE_RESTRICTED_NETWORKS isn't granted to this package.         final PackageInfo app = mPackageManager.getPackageInfo(mContext.getPackageName(),                 GET_PERMISSIONS);         final int index = ArrayUtils.indexOf(                 app.requestedPermissions, CONNECTIVITY_USE_RESTRICTED_NETWORKS);         assertTrue(index >= 0);         assertTrue(app.requestedPermissionsFlags[index] != PERMISSION_GRANTED);          // Ensure that NetworkUtils.queryUserAccess always returns false since this package should         // not have netd system permission to call this function.         final Network wifiNetwork = ensureWifiConnected();         assertFalse(NetworkUtils.queryUserAccess(Binder.getCallingUid(), wifiNetwork.netId));          // Ensure that this package cannot bind to any restricted network that's currently         // connected.         Network[] networks = mCm.getAllNetworks();         for (Network network : networks) {             NetworkCapabilities nc = mCm.getNetworkCapabilities(network);             if (nc != null && !nc.hasCapability(NET_CAPABILITY_NOT_RESTRICTED)) {                 try {                     network.bindSocket(new Socket());                     fail(""Bind to restricted network "" + network + "" unexpectedly succeeded"");                 } catch (IOException expected) {}             }         }     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"com.android.cts.net.hostside.AbstractDozeModeTestCase"	"registerBroadcastReceiver"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/AbstractDozeModeTestCase.java"	""	"/*  *.  */  package com.android.cts.net.hostside;  import static com.android.cts.net.hostside.Property.DOZE_MODE; import static com.android.cts.net.hostside.Property.NOT_LOW_RAM_DEVICE;  import android.os.SystemClock;  import org.junit.After; import org.junit.Before; import org.junit.Test;  /**  * Base class for metered and non-metered Doze Mode tests.  */ @RequiredProperties({DOZE_MODE}) abstract class AbstractDozeModeTestCase extends AbstractRestrictBackgroundNetworkTestCase {      @Before     public final void setUp() throws Exception {         super.setUp();          // Set initial state.         removePowerSaveModeWhitelist(TEST_APP2_PKG);         removePowerSaveModeExceptIdleWhitelist(TEST_APP2_PKG);         setDozeMode(false);          registerBroadcastReceiver();     }      @After     public final void tearDown() throws Exception {         super.tearDown();          setDozeMode(false);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.MultinetworkApiTest"	"getTestableNetworks"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/MultinetworkApiTest.java"	""	"public void test/*  *.  */  package android.net.cts;  import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;  import android.content.Context; import android.content.ContentResolver; import android.net.ConnectivityManager; import android.net.Network; import android.net.NetworkCapabilities; import android.net.NetworkUtils; import android.net.cts.util.CtsNetUtils; import android.platform.test.annotations.AppModeFull; import android.provider.Settings; import android.system.ErrnoException; import android.system.OsConstants; import android.test.AndroidTestCase;  import java.util.ArrayList;  public class MultinetworkApiTest extends AndroidTestCase {      static {         System.loadLibrary(""nativemultinetwork_jni"");     }      private static final String TAG = ""MultinetworkNativeApiTest"";     static final String GOOGLE_PRIVATE_DNS_SERVER = ""dns.google"";      /**      * @return 0 on success      */     private static native int runGetaddrinfoCheck(long networkHandle);     private static native int runSetprocnetwork(long networkHandle);     private static native int runSetsocknetwork(long networkHandle);     private static native int runDatagramCheck(long networkHandle);     private static native void runResNapiMalformedCheck(long networkHandle);     private static native void runResNcancelCheck(long networkHandle);     private static native void runResNqueryCheck(long networkHandle);     private static native void runResNsendCheck(long networkHandle);     private static native void runResNnxDomainCheck(long networkHandle);       private ContentResolver mCR;     private ConnectivityManager mCM;     private CtsNetUtils mCtsNetUtils;     private String mOldMode;     private String mOldDnsSpecifier;      @Override     protected void setUp() throws Exception {         super.setUp();         mCM = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);         mCR = getContext().getContentResolver();         mCtsNetUtils = new CtsNetUtils(getContext());     }      @Override     protected void tearDown() throws Exception {         super.tearDown();     }      private Network[] getTestableNetworks() {         final ArrayList<Network> testableNetworks = new ArrayList<Network>();         for (Network network : mCM.getAllNetworks()) {             final NetworkCapabilities nc = mCM.getNetworkCapabilities(network);             if (nc != null                     && nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED)                     && nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {                 testableNetworks.add(network);             }         }          assertTrue(                 ""This test requires that at least one network be connected. "" +                 ""Please ensure that the device is connected to a network."",                 testableNetworks.size() >= 1);         return testableNetworks.toArray(new Network[0]);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-3"	""	"android.net.cts.MultinetworkApiTest"	"testResNApiNXDomainPrivateDns"	""	""	"7.4.5.3/C-1-3"	"""C-1-3] MUST support logging in to captive portals using cleartext DNS when the device is configured to use private DNS strict mode. """	""	"logging strict"	""	""	""	"strict"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/MultinetworkApiTest.java"	""	"public void testResNApiNXDomainPrivateDns() throws InterruptedException {         mCtsNetUtils.storePrivateDnsSetting();         // Enable private DNS strict mode and set server to dns.google before doing NxDomain test.         // b/144521720         try {             mCtsNetUtils.setPrivateDnsStrictMode(GOOGLE_PRIVATE_DNS_SERVER);             for (Network network : getTestableNetworks()) {               // Wait for private DNS setting to propagate.               mCtsNetUtils.awaitPrivateDnsSetting(""NxDomain test wait private DNS setting timeout"",                         network, GOOGLE_PRIVATE_DNS_SERVER, true);               runResNnxDomainCheck(network.getNetworkHandle());             }         } finally {             mCtsNetUtils.restorePrivateDnsSetting();         }     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-4"	""	"com.android.cts.net.hostside.VpnTest"	"finish"	""	""	"7.4.5.3/C-1-4"	"""C-1-4] MUST use encrypted DNS as per the SDK documentation for android.net.LinkProperties.getPrivateDnsServerName and android.net.LinkProperties.isPrivateDnsActive for all network traffic that is not explicitly communicating with the captive portal. """	""	"isPrivateDnsActive android.net.LinkProperties.getPrivateDnsServerName android.net.LinkProperties.isPrivateDnsActive getPrivateDnsServerName"	""	""	""	"getPrivateDnsServerName"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/VpnTest.java"	""	"Api.     private static final String PRIVATE_DNS_MODE_SETTING = ""private_dns_mode"";     private static final String PRIVATE_DNS_MODE_PROVIDER_HOSTNAME = ""hostname"";     private static final String PRIVATE_DNS_MODE_OPPORTUNISTIC = ""opportunistic"";     private static final String PRIVATE_DNS_SPECIFIER_SETTING = ""private_dns_specifier"";      public static String TAG = ""VpnTest"";     public static int TIMEOUT_MS = 3 * 1000;     public static int SOCKET_TIMEOUT_MS = 100;     public static String TEST_HOST = ""connectivitycheck.gstatic.com"";      private UiDevice mDevice;     private MyActivity mActivity;     private String mPackageName;     private ConnectivityManager mCM;     private WifiManager mWifiManager;     private RemoteSocketFactoryClient mRemoteSocketFactoryClient;      Network mNetwork;     NetworkCallback mCallback;     final Object mLock = new Object();     final Object mLockShutdown = new Object();      private String mOldPrivateDnsMode;     private String mOldPrivateDnsSpecifier;      private boolean supportedHardware() {         final PackageManager pm = getInstrumentation().getContext().getPackageManager();         return !pm.hasSystemFeature(""android.hardware.type.watch"");     }      @Override     public void setUp() throws Exception {         super.setUp();          mNetwork = null;         mCallback = null;         storePrivateDnsSetting();          mDevice = UiDevice.getInstance(getInstrumentation());         mActivity = launchActivity(getInstrumentation().getTargetContext().getPackageName(),                 MyActivity.class, null);         mPackageName = mActivity.getPackageName();         mCM = (ConnectivityManager) mActivity.getSystemService(Context.CONNECTIVITY_SERVICE);         mWifiManager = (WifiManager) mActivity.getSystemService(Context.WIFI_SERVICE);         mRemoteSocketFactoryClient = new RemoteSocketFactoryClient(mActivity);         mRemoteSocketFactoryClient.bind();         mDevice.waitForIdle();     }      @Override     public void tearDown() throws Exception {         restorePrivateDnsSetting();         mRemoteSocketFactoryClient.unbind();         if (mCallback != null) {             mCM.unregisterNetworkCallback(mCallback);         }         Log.i(TAG, ""Stopping VPN"");         stopVpn();         mActivity.finish();         super.tearDown();     }      private void prepareVpn() throws Exception {         final int REQUEST_ID = 42;          // Attempt to prepare.         Log.i(TAG, ""Preparing VPN"");         Intent intent = VpnService.prepare(mActivity);          if (intent != null) {             // Start the confirmation dialog and click OK.             mActivity.startActivityForResult(intent, REQUEST_ID);             mDevice.waitForIdle();              String packageName = intent.getComponent().getPackageName();             String resourceIdRegex = ""android:id/button1$|button_start_vpn"";             final UiObject okButton = new UiObject(new UiSelector()                     .className(""android.widget.Button"")                     .packageName(packageName)                     .resourceIdMatches(resourceIdRegex));             if (okButton.waitForExists(TIMEOUT_MS) == false) {                 mActivity.finishActivity(REQUEST_ID);                 fail(""VpnService.prepare returned an Intent for '"" + intent.getComponent() + ""' "" +                      ""to display the VPN confirmation dialog, but this test could not find the "" +                      ""button to allow the VPN application to connect. Please ensure that the ""  +                      ""component displays a button with a resource ID matching the regexp: '"" +                      resourceIdRegex + ""'."");             }              // Click the button and wait for RESULT_OK.             okButton.click();             try {                 int result = mActivity.getResult(TIMEOUT_MS);                 if (result != MyActivity.RESULT_OK) {                     fail(""The VPN confirmation dialog did not return RESULT_OK when clicking on "" +                          ""the button matching the regular expression '"" + resourceIdRegex +                          ""' of "" + intent.getComponent() + ""'. Please ensure that clicking on "" +                          ""that button allows the VPN application to connect. "" +                          ""Return value: "" + result);                 }             } catch (InterruptedException e) {                 fail(""VPN confirmation dialog did not return after "" + TIMEOUT_MS + ""ms"");             }              // Now we should be prepared.             intent = VpnService.prepare(mActivity);             if (intent != null) {                 fail(""VpnService.prepare returned non-null even after the VPN dialog "" +                      intent.getComponent() + ""returned RESULT_OK."");             }         }     }      // TODO: Consider replacing arguments with a Builder.     private void startVpn(         String[] addresses, String[] routes, String allowedApplications,         String disallowedApplications, @Nullable ProxyInfo proxyInfo,         @Nullable ArrayList<Network> underlyingNetworks, boolean isAlwaysMetered) throws Exception {         prepareVpn();          // Register a callback so we will be notified when our VPN comes up.         final NetworkRequest request = new NetworkRequest.Builder()                 .addTransportType(NetworkCapabilities.TRANSPORT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                 .build();         mCallback = new NetworkCallback() {             public void onAvailable(Network network) {                 synchronized (mLock) {                     Log.i(TAG, ""Got available callback for network="" + network);                     mNetwork = network;                     mLock.notify();                 }             }         };         mCM.registerNetworkCallback(request, mCallback);  // Unregistered in tearDown.          // Start the service and wait up for TIMEOUT_MS ms for the VPN to come up.         Intent intent = new Intent(mActivity, MyVpnService.class)                 .putExtra(mPackageName + "".cmd"", ""connect"")                 .putExtra(mPackageName + "".addresses"", TextUtils.join("","", addresses))                 .putExtra(mPackageName + "".routes"", TextUtils.join("","", routes))                 .putExtra(mPackageName + "".allowedapplications"", allowedApplications)                 .putExtra(mPackageName + "".disallowedapplications"", disallowedApplications)                 .putExtra(mPackageName + "".httpProxy"", proxyInfo)                 .putParcelableArrayListExtra(                     mPackageName + "".underlyingNetworks"", underlyingNetworks)                 .putExtra(mPackageName + "".isAlwaysMetered"", isAlwaysMetered);          mActivity.startService(intent);         synchronized (mLock) {             if (mNetwork == null) {                  Log.i(TAG, ""bf mLock"");                  mLock.wait(TIMEOUT_MS);                  Log.i(TAG, ""af mLock"");             }         }          if (mNetwork == null) {             fail(""VPN did not become available after "" + TIMEOUT_MS + ""ms"");         }          // Unfortunately, when the available callback fires, the VPN UID ranges are not yet         // configured. Give the system some time to do so. http://b/18436087 .         try { Thread.sleep(3000); } catch(InterruptedException e) {}     }      private void stopVpn() {         // Register a callback so we will be notified when our VPN comes up.         final NetworkRequest request = new NetworkRequest.Builder()                 .addTransportType(NetworkCapabilities.TRANSPORT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                 .build();         mCallback = new NetworkCallback() {             public void onLost(Network network) {                 synchronized (mLockShutdown) {                     Log.i(TAG, ""Got lost callback for network="" + network                             + "",mNetwork = "" + mNetwork);                     if( mNetwork == network){                         mLockShutdown.notify();                     }                 }             }        };         mCM.registerNetworkCallback(request, mCallback);  // Unregistered in tearDown.         // Simply calling mActivity.stopService() won't stop the service, because the system binds         // to the service for the purpose of sending it a revoke command if another VPN comes up,         // and stopping a bound service has no effect. Instead, ""start"" the service again with an         // Intent that tells it to disconnect.         Intent intent = new Intent(mActivity, MyVpnService.class)                 .putExtra(mPackageName + "".cmd"", ""disconnect"");         mActivity.startService(intent);         synchronized (mLockShutdown) {             try {                  Log.i(TAG, ""bf mLockShutdown"");                  mLockShutdown.wait(TIMEOUT_MS);                  Log.i(TAG, ""af mLockShutdown"");             } catch(InterruptedException e) {}         }     }      private static void closeQuietly(Closeable c) {         if (c != null) {             try {                 c.close();             } catch (IOException e) {             }         }     }      private static void checkPing(String to) throws IOException, ErrnoException {         InetAddress address = InetAddress.getByName(to);         FileDescriptor s;         final int LENGTH = 64;         byte[] packet = new byte[LENGTH];         byte[] header;          // Construct a ping packet.         Random random = new Random();         random.nextBytes(packet);         if (address instanceof Inet6Address) {             s = Os.socket(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6);             header = new byte[] { (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00 };         } else {             // Note that this doesn't actually work due to http://b/18558481 .             s = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);             header = new byte[] { (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00 };         }         System.arraycopy(header, 0, packet, 0, header.length);          // Send the packet.         int port = random.nextInt(65534) + 1;         Os.connect(s, address, port);         Os.write(s, packet, 0, packet.length);          // Expect a reply.         StructPollfd pollfd = new StructPollfd();         pollfd.events = (short) POLLIN;  // ""error: possible loss of precision""         pollfd.fd = s;         int ret = Os.poll(new StructPollfd[] { pollfd }, SOCKET_TIMEOUT_MS);         assertEquals(""Expected reply after sending ping"", 1, ret);          byte[] reply = new byte[LENGTH];         int read = Os.read(s, reply, 0, LENGTH);         assertEquals(LENGTH, read);          // Find out what the kernel set the ICMP ID to.         InetSocketAddress local = (InetSocketAddress) Os.getsockname(s);         port = local.getPort();         packet[4] = (byte) ((port >> 8) & 0xff);         packet[5] = (byte) (port & 0xff);          // Check the contents.         if (packet[0] == (byte) 0x80) {             packet[0] = (byte) 0x81;         } else {             packet[0] = 0;         }         // Zero out the checksum in the reply so it matches the uninitialized checksum in packet.         reply[2] = reply[3] = 0;         MoreAsserts.assertEquals(packet, reply);     }      // Writes data to out and checks that it appears identically on in.     private static void writeAndCheckData(             OutputStream out, InputStream in, byte[] data) throws IOException {         out.write(data, 0, data.length);         out.flush();          byte[] read = new byte[data.length];         int bytesRead = 0, totalRead = 0;         do {             bytesRead = in.read(read, totalRead, read.length - totalRead);             totalRead += bytesRead;         } while (bytesRead >= 0 && totalRead < data.length);         assertEquals(totalRead, data.length);         MoreAsserts.assertEquals(data, read);     }      private void checkTcpReflection(String to, String expectedFrom) throws IOException {         // Exercise TCP over the VPN by ""connecting to ourselves"". We open a server socket and a         // client socket, and connect the client socket to a remote host, with the port of the         // server socket. The PacketReflector reflects the packets, changing the source addresses         // but not the ports, so our client socket is connected to our server socket, though both         // sockets think their peers are on the ""remote"" IP address.          // Open a listening socket.         ServerSocket listen = new ServerSocket(0, 10, InetAddress.getByName(""::""));          // Connect the client socket to it.         InetAddress toAddr = InetAddress.getByName(to);         Socket client = new Socket();         try {             client.connect(new InetSocketAddress(toAddr, listen.getLocalPort()), SOCKET_TIMEOUT_MS);             if (expectedFrom == null) {                 closeQuietly(listen);                 closeQuietly(client);                 fail(""Expected connection to fail, but it succeeded."");             }         } catch (IOException e) {             if (expectedFrom != null) {                 closeQuietly(listen);                 fail(""Expected connection to succeed, but it failed."");             } else {                 // We expected the connection to fail, and it did, so there's nothing more to test.                 return;             }         }          // The connection succeeded, and we expected it to succeed. Send some data; if things are         // working, the data will be sent to the VPN, reflected by the PacketReflector, and arrive         // at our server socket. For good measure, send some data in the other direction.         Socket server = null;         try {             // Accept the connection on the server side.             listen.setSoTimeout(SOCKET_TIMEOUT_MS);             server = listen.accept();             checkConnectionOwnerUidTcp(client);             checkConnectionOwnerUidTcp(server);             // Check that the source and peer addresses are as expected.             assertEquals(expectedFrom, client.getLocalAddress().getHostAddress());             assertEquals(expectedFrom, server.getLocalAddress().getHostAddress());             assertEquals(                     new InetSocketAddress(toAddr, client.getLocalPort()),                     server.getRemoteSocketAddress());             assertEquals(                     new InetSocketAddress(toAddr, server.getLocalPort()),                     client.getRemoteSocketAddress());              // Now write some data.             final int LENGTH = 32768;             byte[] data = new byte[LENGTH];             new Random().nextBytes(data);              // Make sure our writes don't block or time out, because we're single-threaded and can't             // read and write at the same time.             server.setReceiveBufferSize(LENGTH * 2);             client.setSendBufferSize(LENGTH * 2);             client.setSoTimeout(SOCKET_TIMEOUT_MS);             server.setSoTimeout(SOCKET_TIMEOUT_MS);              // Send some data from client to server, then from server to client.             writeAndCheckData(client.getOutputStream(), server.getInputStream(), data);             writeAndCheckData(server.getOutputStream(), client.getInputStream(), data);         } finally {             closeQuietly(listen);             closeQuietly(client);             closeQuietly(server);         }     }      private void checkConnectionOwnerUidUdp(DatagramSocket s, boolean expectSuccess) {         final int expectedUid = expectSuccess ? Process.myUid() : INVALID_UID;         InetSocketAddress loc = new InetSocketAddress(s.getLocalAddress(), s.getLocalPort());         InetSocketAddress rem = new InetSocketAddress(s.getInetAddress(), s.getPort());         int uid = mCM.getConnectionOwnerUid(OsConstants.IPPROTO_UDP, loc, rem);         assertEquals(expectedUid, uid);     }      private void checkConnectionOwnerUidTcp(Socket s) {         final int expectedUid = Process.myUid();         InetSocketAddress loc = new InetSocketAddress(s.getLocalAddress(), s.getLocalPort());         InetSocketAddress rem = new InetSocketAddress(s.getInetAddress(), s.getPort());         int uid = mCM.getConnectionOwnerUid(OsConstants.IPPROTO_TCP, loc, rem);         assertEquals(expectedUid, uid);     }      private void checkUdpEcho(String to, String expectedFrom) throws IOException {         DatagramSocket s;         InetAddress address = InetAddress.getByName(to);         if (address instanceof Inet6Address) {  // http://b/18094870             s = new DatagramSocket(0, InetAddress.getByName(""::""));         } else {             s = new DatagramSocket();         }         s.setSoTimeout(SOCKET_TIMEOUT_MS);          Random random = new Random();         byte[] data = new byte[random.nextInt(1650)];         random.nextBytes(data);         DatagramPacket p = new DatagramPacket(data, data.length);         s.connect(address, 7);          if (expectedFrom != null) {             assertEquals(""Unexpected source address: "",                          expectedFrom, s.getLocalAddress().getHostAddress());         }          try {             if (expectedFrom != null) {                 s.send(p);                 checkConnectionOwnerUidUdp(s, true);                 s.receive(p);                 MoreAsserts.assertEquals(data, p.getData());             } else {                 try {                     s.send(p);                     s.receive(p);                     fail(""Received unexpected reply"");                 } catch (IOException expected) {                     checkConnectionOwnerUidUdp(s, false);                 }             }         } finally {             s.close();         }     }      private void checkTrafficOnVpn() throws Exception {         checkUdpEcho(""192.0.2.251"", ""192.0.2.2"");         checkUdpEcho(""2001:db8:dead:beef::f00"", ""2001:db8:1:2::ffe"");         checkPing(""2001:db8:dead:beef::f00"");         checkTcpReflection(""192.0.2.252"", ""192.0.2.2"");         checkTcpReflection(""2001:db8:dead:beef::f00"", ""2001:db8:1:2::ffe"");     }      private void checkNoTrafficOnVpn() throws Exception {         checkUdpEcho(""192.0.2.251"", null);         checkUdpEcho(""2001:db8:dead:beef::f00"", null);         checkTcpReflection(""192.0.2.252"", null);         checkTcpReflection(""2001:db8:dead:beef::f00"", null);     }      private FileDescriptor openSocketFd(String host, int port, int timeoutMs) throws Exception {         Socket s = new Socket(host, port);         s.setSoTimeout(timeoutMs);         // Dup the filedescriptor so ParcelFileDescriptor's finalizer doesn't garbage collect it         // and cause our fd to become invalid. http://b/35927643 .         FileDescriptor fd = Os.dup(ParcelFileDescriptor.fromSocket(s).getFileDescriptor());         s.close();         return fd;     }      private FileDescriptor openSocketFdInOtherApp(             String host, int port, int timeoutMs) throws Exception {         Log.d(TAG, String.format(""Creating test socket in UID=%d, my UID=%d"",                 mRemoteSocketFactoryClient.getUid(), Os.getuid()));         FileDescriptor fd = mRemoteSocketFactoryClient.openSocketFd(host, port, TIMEOUT_MS);         return fd;     }      private void sendRequest(FileDescriptor fd, String host) throws Exception {         String request = ""GET /generate_204 HTTP/1.1\r\n"" +                 ""Host: "" + host + ""\r\n"" +                 ""Connection: keep-alive\r\n\r\n"";         byte[] requestBytes = request.getBytes(StandardCharsets.UTF_8);         int ret = Os.write(fd, requestBytes, 0, requestBytes.length);         Log.d(TAG, ""Wrote "" + ret + ""bytes"");          String expected = ""HTTP/1.1 204 No Content\r\n"";         byte[] response = new byte[expected.length()];         Os.read(fd, response, 0, response.length);          String actual = new String(response, StandardCharsets.UTF_8);         assertEquals(expected, actual);         Log.d(TAG, ""Got response: "" + actual);     }      private void assertSocketStillOpen(FileDescriptor fd, String host) throws Exception {         try {             assertTrue(fd.valid());             sendRequest(fd, host);             assertTrue(fd.valid());         } finally {             Os.close(fd);         }     }      private void assertSocketClosed(FileDescriptor fd, String host) throws Exception {         try {             assertTrue(fd.valid());             sendRequest(fd, host);             fail(""Socket opened before VPN connects should be closed when VPN connects"");         } catch (ErrnoException expected) {             assertEquals(ECONNABORTED, expected.errno);             assertTrue(fd.valid());         } finally {             Os.close(fd);         }     }      private ContentResolver getContentResolver() {         return getInstrumentation().getContext().getContentResolver();     }      private boolean isPrivateDnsInStrictMode() {         return PRIVATE_DNS_MODE_PROVIDER_HOSTNAME.equals(                 Settings.Global.getString(getContentResolver(), PRIVATE_DNS_MODE_SETTING));     }      private void storePrivateDnsSetting() {         mOldPrivateDnsMode = Settings.Global.getString(getContentResolver(),                 PRIVATE_DNS_MODE_SETTING);         mOldPrivateDnsSpecifier = Settings.Global.getString(getContentResolver(),                 PRIVATE_DNS_SPECIFIER_SETTING);     }      private void restorePrivateDnsSetting() {         Settings.Global.putString(getContentResolver(), PRIVATE_DNS_MODE_SETTING,                 mOldPrivateDnsMode);         Settings.Global.putString(getContentResolver(), PRIVATE_DNS_SPECIFIER_SETTING,                 mOldPrivateDnsSpecifier);     }      // TODO: replace with CtsNetUtils.awaitPrivateDnsSetting in Q or above.     private void expectPrivateDnsHostname(final String hostname) throws Exception {         final NetworkRequest request = new NetworkRequest.Builder()                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)                 .build();         final CountDownLatch latch = new CountDownLatch(1);         final NetworkCallback callback = new NetworkCallback() {             @Override             public void onLinkPropertiesChanged(Network network, LinkProperties lp) {                 if (network.equals(mNetwork) &&                         Objects.equals(lp.getPrivateDnsServerName(), hostname)) {                     latch.countDown();                 }             }         };          mCM.registerNetworkCallback(request, callback);          try {             assertTrue(""Private DNS hostname was not "" + hostname + "" after "" + TIMEOUT_MS + ""ms"",                     latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));         } finally {             mCM.unregisterNetworkCallback(callback);         }     }      private void setAndVerifyPrivateDns(boolean strictMode) throws Exception {         final ContentResolver cr = getInstrumentation().getContext().getContentResolver();         String privateDnsHostname;          if (strictMode) {             privateDnsHostname = ""vpncts-nx.metric.gstatic.com"";             Settings.Global.putString(cr, PRIVATE_DNS_SPECIFIER_SETTING, privateDnsHostname);             Settings.Global.putString(cr, PRIVATE_DNS_MODE_SETTING,                     PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);         } else {             Settings.Global.putString(cr, PRIVATE_DNS_MODE_SETTING, PRIVATE_DNS_MODE_OPPORTUNISTIC);             privateDnsHostname = null;         }          expectPrivateDnsHostname(privateDnsHostname);          String randomName = ""vpncts-"" + new Random().nextInt(1000000000) + ""-ds.metric.gstatic.com"";         if (strictMode) {             // Strict mode private DNS is enabled. DNS lookups should fail, because the private DNS             // server name is invalid.             try {                 InetAddress.getByName(randomName);                 fail(""VPN DNS lookup should fail with private DNS enabled"");             } catch (UnknownHostException expected) {             }         } else {             // Strict mode private DNS is disabled. DNS lookup should succeed, because the VPN             // provides no DNS servers, and thus DNS falls through to the default network.             assertNotNull(""VPN DNS lookup should succeed with private DNS disabled"",                     InetAddress.getByName(randomName));         }     }      // Tests that strict mode private DNS is used on VPNs.     private void checkStrictModePrivateDns() throws Exception {         final boolean initialMode = isPrivateDnsInStrictMode();         setAndVerifyPrivateDns(!initialMode);         setAndVerifyPrivateDns(initialMode);     }      public void testDefault() throws Exception {         if (!supportedHardware()) return;         // If adb TCP port opened, this test may running by adb over network.         // All of socket would be destroyed in this test. So this test don't         // support adb over network, see b/119382723.         if (SystemProperties.getInt(""persist.adb.tcp.port"", -1) > -1                 || SystemProperties.getInt(""service.adb.tcp.port"", -1) > -1) {             Log.i(TAG, ""adb is running over the network, so skip this test"");             return;         }          final BlockingBroadcastReceiver receiver = new BlockingBroadcastReceiver(                 getInstrumentation().getTargetContext(), MyVpnService.ACTION_ESTABLISHED);         receiver.register();          FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""0.0.0.0/0"", ""::/0""},                  """", """", null, null /* underlyingNetworks */, false /* isAlwaysMetered */);          final Intent intent = receiver.awaitForBroadcast(TimeUnit.MINUTES.toMillis(1));         assertNotNull(""Failed to receive broadcast from VPN service"", intent);         assertFalse(""Wrong VpnService#isAlwaysOn"",                 intent.getBooleanExtra(MyVpnService.EXTRA_ALWAYS_ON, true));         assertFalse(""Wrong VpnService#isLockdownEnabled"",                 intent.getBooleanExtra(MyVpnService.EXTRA_LOCKDOWN_ENABLED, true));          assertSocketClosed(fd, TEST_HOST);          checkTrafficOnVpn();          checkStrictModePrivateDns();          receiver.unregisterQuietly();     }      public void testAppAllowed() throws Exception {         if (!supportedHardware()) return;          FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);          // Shell app must not be put in here or it would kill the ADB-over-network use case         String allowedApps = mRemoteSocketFactoryClient.getPackageName() + "","" + mPackageName;         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""192.0.2.0/24"", ""2001:db8::/32""},                  allowedApps, """", null, null /* underlyingNetworks */, false /* isAlwaysMetered */);          assertSocketClosed(fd, TEST_HOST);          checkTrafficOnVpn();          checkStrictModePrivateDns();     }      public void testAppDisallowed() throws Exception {         if (!supportedHardware()) return;          FileDescriptor localFd = openSocketFd(TEST_HOST, 80, TIMEOUT_MS);         FileDescriptor remoteFd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);          String disallowedApps = mRemoteSocketFactoryClient.getPackageName() + "","" + mPackageName;         // If adb TCP port opened, this test may running by adb over TCP.         // Add com.android.shell appllication into blacklist to exclude adb socket for VPN test,         // see b/119382723.         // Note: The test don't support running adb over network for root device         disallowedApps = disallowedApps + "",com.android.shell"";         Log.i(TAG, ""Append shell app to disallowedApps: "" + disallowedApps);         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""192.0.2.0/24"", ""2001:db8::/32""},                  """", disallowedApps, null, null /* underlyingNetworks */,                  false /* isAlwaysMetered */);          assertSocketStillOpen(localFd, TEST_HOST);         assertSocketStillOpen(remoteFd, TEST_HOST);          checkNoTrafficOnVpn();     }      public void testGetConnectionOwnerUidSecurity() throws Exception {         if (!supportedHardware()) return;          DatagramSocket s;         InetAddress address = InetAddress.getByName(""localhost"");         s = new DatagramSocket();         s.setSoTimeout(SOCKET_TIMEOUT_MS);         s.connect(address, 7);         InetSocketAddress loc = new InetSocketAddress(s.getLocalAddress(), s.getLocalPort());         InetSocketAddress rem = new InetSocketAddress(s.getInetAddress(), s.getPort());         try {             int uid = mCM.getConnectionOwnerUid(OsConstants.IPPROTO_TCP, loc, rem);             fail(""Only an active VPN app may call this API."");         } catch (SecurityException expected) {             return;         }     }      public void testSetProxy() throws  Exception {         if (!supportedHardware()) return;         ProxyInfo initialProxy = mCM.getDefaultProxy();         // Receiver for the proxy change broadcast.         BlockingBroadcastReceiver proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();          String allowedApps = mPackageName;         ProxyInfo testProxyInfo = ProxyInfo.buildDirectProxy(""10.0.0.1"", 8888);         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """",                 testProxyInfo, null /* underlyingNetworks */, false /* isAlwaysMetered */);          // Check that the proxy change broadcast is received         try {             assertNotNull(""No proxy change was broadcast when VPN is connected."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }          // Proxy is set correctly in network and in link properties.         assertNetworkHasExpectedProxy(testProxyInfo, mNetwork);         assertDefaultProxy(testProxyInfo);          proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         stopVpn();         try {             assertNotNull(""No proxy change was broadcast when VPN was disconnected."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }          // After disconnecting from VPN, the proxy settings are the ones of the initial network.         assertDefaultProxy(initialProxy);     }      public void testSetProxyDisallowedApps() throws Exception {         if (!supportedHardware()) return;         ProxyInfo initialProxy = mCM.getDefaultProxy();          // If adb TCP port opened, this test may running by adb over TCP.         // Add com.android.shell appllication into blacklist to exclude adb socket for VPN test,         // see b/119382723.         // Note: The test don't support running adb over network for root device         String disallowedApps = mPackageName + "",com.android.shell"";         ProxyInfo testProxyInfo = ProxyInfo.buildDirectProxy(""10.0.0.1"", 8888);         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, """", disallowedApps,                 testProxyInfo, null /* underlyingNetworks */, false /* isAlwaysMetered */);          // The disallowed app does has the proxy configs of the default network.         assertNetworkHasExpectedProxy(initialProxy, mCM.getActiveNetwork());         assertDefaultProxy(initialProxy);     }      public void testNoProxy() throws Exception {         if (!supportedHardware()) return;         ProxyInfo initialProxy = mCM.getDefaultProxy();         BlockingBroadcastReceiver proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         String allowedApps = mPackageName;         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 null /* underlyingNetworks */, false /* isAlwaysMetered */);          try {             assertNotNull(""No proxy change was broadcast."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }          // The VPN network has no proxy set.         assertNetworkHasExpectedProxy(null, mNetwork);          proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         stopVpn();         try {             assertNotNull(""No proxy change was broadcast."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }         // After disconnecting from VPN, the proxy settings are the ones of the initial network.         assertDefaultProxy(initialProxy);         assertNetworkHasExpectedProxy(initialProxy, mCM.getActiveNetwork());     }      public void testBindToNetworkWithProxy() throws Exception {         if (!supportedHardware()) return;         String allowedApps = mPackageName;         Network initialNetwork = mCM.getActiveNetwork();         ProxyInfo initialProxy = mCM.getDefaultProxy();         ProxyInfo testProxyInfo = ProxyInfo.buildDirectProxy(""10.0.0.1"", 8888);         // Receiver for the proxy change broadcast.         BlockingBroadcastReceiver proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """",                 testProxyInfo, null /* underlyingNetworks */, false /* isAlwaysMetered */);          assertDefaultProxy(testProxyInfo);         mCM.bindProcessToNetwork(initialNetwork);         try {             assertNotNull(""No proxy change was broadcast."",                 proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }         assertDefaultProxy(initialProxy);     }      public void testVpnMeterednessWithNoUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         // VPN is not routing any traffic i.e. its underlying networks is an empty array.         ArrayList<Network> underlyingNetworks = new ArrayList<>();         String allowedApps = mPackageName;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, false /* isAlwaysMetered */);          // VPN should now be the active network.         assertEquals(mNetwork, mCM.getActiveNetwork());         assertVpnTransportContains(NetworkCapabilities.TRANSPORT_VPN);         // VPN with no underlying networks should be metered by default.         assertTrue(isNetworkMetered(mNetwork));         assertTrue(mCM.isActiveNetworkMetered());     }      public void testVpnMeterednessWithNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testVpnMeterednessWithNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN tracks platform default.         ArrayList<Network> underlyingNetworks = null;         String allowedApps = mPackageName;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, false /*isAlwaysMetered */);          // Ensure VPN transports contains underlying network's transports.         assertVpnTransportContains(underlyingNetwork);         // Its meteredness should be same as that of underlying network.         assertEquals(isNetworkMetered(underlyingNetwork), isNetworkMetered(mNetwork));         // Meteredness based on VPN capabilities and CM#isActiveNetworkMetered should be in sync.         assertEquals(isNetworkMetered(mNetwork), mCM.isActiveNetworkMetered());     }      public void testVpnMeterednessWithNonNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testVpnMeterednessWithNonNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN explicitly declares WiFi to be its underlying network.         ArrayList<Network> underlyingNetworks = new ArrayList<>(1);         underlyingNetworks.add(underlyingNetwork);         String allowedApps = mPackageName;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, false /* isAlwaysMetered */);          // Ensure VPN transports contains underlying network's transports.         assertVpnTransportContains(underlyingNetwork);         // Its meteredness should be same as that of underlying network.         assertEquals(isNetworkMetered(underlyingNetwork), isNetworkMetered(mNetwork));         // Meteredness based on VPN capabilities and CM#isActiveNetworkMetered should be in sync.         assertEquals(isNetworkMetered(mNetwork), mCM.isActiveNetworkMetered());     }      public void testAlwaysMeteredVpnWithNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testAlwaysMeteredVpnWithNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN tracks platform default.         ArrayList<Network> underlyingNetworks = null;         String allowedApps = mPackageName;         boolean isAlwaysMetered = true;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, isAlwaysMetered);          // VPN's meteredness does not depend on underlying network since it is always metered.         assertTrue(isNetworkMetered(mNetwork));         assertTrue(mCM.isActiveNetworkMetered());     }      public void testAlwaysMeteredVpnWithNonNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testAlwaysMeteredVpnWithNonNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN explicitly declares its underlying network.         ArrayList<Network> underlyingNetworks = new ArrayList<>(1);         underlyingNetworks.add(underlyingNetwork);         String allowedApps = mPackageName;         boolean isAlwaysMetered = true;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, isAlwaysMetered);          // VPN's meteredness does not depend on underlying network since it is always metered.         assertTrue(isNetworkMetered(mNetwork));         assertTrue(mCM.isActiveNetworkMetered());     }      public void testB141603906() throws Exception {         if (!supportedHardware()) {             return;         }         final InetSocketAddress src = new InetSocketAddress(0);         final InetSocketAddress dst = new InetSocketAddress(0);         final int NUM_THREADS = 8;         final int NUM_SOCKETS = 5000;         final Thread[] threads = new Thread[NUM_THREADS];         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""0.0.0.0/0"", ""::/0""},                  """" /* allowedApplications */, ""com.android.shell"" /* disallowedApplications */,                 null /* proxyInfo */, null /* underlyingNetworks */, false /* isAlwaysMetered */);          for (int i = 0; i < NUM_THREADS; i++) {             threads[i] = new Thread(() -> {                 for (int j = 0; j < NUM_SOCKETS; j++) {                     mCM.getConnectionOwnerUid(IPPROTO_TCP, src, dst);                 }             });         }         for (Thread thread : threads) {             thread.start();         }         for (Thread thread : threads) {             thread.join();         }         stopVpn();     }      private boolean isNetworkMetered(Network network) {         NetworkCapabilities nc = mCM.getNetworkCapabilities(network);         return !nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);     }      private void assertVpnTransportContains(Network underlyingNetwork) {         int[] transports = mCM.getNetworkCapabilities(underlyingNetwork).getTransportTypes();         assertVpnTransportContains(transports);     }      private void assertVpnTransportContains(int... transports) {         NetworkCapabilities vpnCaps = mCM.getNetworkCapabilities(mNetwork);         for (int transport : transports) {             assertTrue(vpnCaps.hasTransport(transport));         }     }      private void assertDefaultProxy(ProxyInfo expected) {         assertEquals(""Incorrect proxy config."", expected, mCM.getDefaultProxy());         String expectedHost = expected == null ? null : expected.getHost();         String expectedPort = expected == null ? null : String.valueOf(expected.getPort());         assertEquals(""Incorrect proxy host system property."", expectedHost,             System.getProperty(""http.proxyHost""));         assertEquals(""Incorrect proxy port system property."", expectedPort,             System.getProperty(""http.proxyPort""));     }      private void assertNetworkHasExpectedProxy(ProxyInfo expected, Network network) {         LinkProperties lp = mCM.getLinkProperties(network);         assertNotNull(""The network link properties object is null."", lp);         assertEquals(""Incorrect proxy config."", expected, lp.getHttpProxy());          assertEquals(expected, mCM.getProxyForNetwork(network));     }      class ProxyChangeBroadcastReceiver extends BlockingBroadcastReceiver {         private boolean received;          public ProxyChangeBroadcastReceiver() {             super(VpnTest.this.getInstrumentation().getContext(), Proxy.PROXY_CHANGE_ACTION);             received = false;         }          @Override         public void onReceive(Context context, Intent intent) {             if (!received) {                 // Do not call onReceive() more than once.                 super.onReceive(context, intent);             }             received = true;         }     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-5"	""	"android.net.cts.DnsResolverTest"	"testRawQueryNXDomainInlineWithPrivateDns"	""	""	"7.4.5.3/C-1-5"	"""C-1-5] MUST ensure that, while the user is logging in to a captive portal, the default network used by applications (as returned by ConnectivityManager.getActiveNetwork, ConnectivityManager.registerDefaultNetworkCallback, and used by default by Java networking APIs such as java.net.Socket, and native APIs such as connect()) is any other available network that provides internet access, if available. <h4 id="""	""	"getActiveNetwork ConnectivityManager.getActiveNetwork ConnectivityManager.registerDefaultNetworkCallback"	""	""	""	"getActiveNetwork"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsResolverTest.java"	""	"public void testRawQueryNXDomainInlineWithPrivateDns() throws Exception {         doTestRawQueryNXDomainWithPrivateDns(mExecutorInline);     }      public void doTestRawQuery(Executor executor) throws InterruptedException {         final String msg = ""RawQuery "" + TEST_DOMAIN;         for (Network network : getTestableNetworks()) {             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             mDns.rawQuery(network, TEST_DOMAIN, CLASS_IN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,                     executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertHasAnswer();         }     }      public void doTestRawQueryBlob(Executor executor) throws InterruptedException {         final byte[] blob = new byte[]{                 /* Header */                 0x55, 0x66, /* Transaction ID */                 0x01, 0x00, /* Flags */                 0x00, 0x01, /* Questions */                 0x00, 0x00, /* Answer RRs */                 0x00, 0x00, /* Authority RRs */                 0x00, 0x00, /* Additional RRs */                 /* Queries */                 0x03, 0x77, 0x77, 0x77, 0x06, 0x67, 0x6F, 0x6F, 0x67, 0x6c, 0x65,                 0x03, 0x63, 0x6f, 0x6d, 0x00, /* Name */                 0x00, 0x01, /* Type */                 0x00, 0x01  /* Class */         };         final String msg = ""RawQuery blob "" + byteArrayToHexString(blob);         for (Network network : getTestableNetworks()) {             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             mDns.rawQuery(network, blob, FLAG_NO_CACHE_LOOKUP, executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertHasAnswer();         }     }      public void doTestRawQueryRoot(Executor executor) throws InterruptedException {         final String dname = """";         final String msg = ""RawQuery empty dname(ROOT) "";         for (Network network : getTestableNetworks()) {             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             mDns.rawQuery(network, dname, CLASS_IN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,                     executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             // Except no answer record because the root does not have AAAA records.             callback.assertEmptyAnswer();         }     }      public void doTestRawQueryNXDomain(Executor executor) throws InterruptedException {         final String msg = ""RawQuery "" + TEST_NX_DOMAIN;          for (Network network : getTestableNetworks()) {             final NetworkCapabilities nc = (network != null)                     ? mCM.getNetworkCapabilities(network)                     : mCM.getNetworkCapabilities(mCM.getActiveNetwork());             assertNotNull(""Couldn't determine NetworkCapabilities for "" + network, nc);             // Some cellular networks configure their DNS servers never to return NXDOMAIN, so don't             // test NXDOMAIN on these DNS servers.             // b/144521720             if (nc.hasTransport(TRANSPORT_CELLULAR)) continue;             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             mDns.rawQuery(network, TEST_NX_DOMAIN, CLASS_IN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,                     executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertNXDomain();         }     }      public void doTestRawQueryNXDomainWithPrivateDns(Executor executor)             throws InterruptedException {         final String msg = ""RawQuery "" + TEST_NX_DOMAIN + "" with private DNS"";         // Enable private DNS strict mode and set server to dns.google before doing NxDomain test.         // b/144521720         mCtsNetUtils.setPrivateDnsStrictMode(GOOGLE_PRIVATE_DNS_SERVER);         for (Network network :  getTestableNetworks()) {             final Network networkForPrivateDns =                     (network != null) ? network : mCM.getActiveNetwork();             assertNotNull(""Can't find network to await private DNS on"", networkForPrivateDns);             mCtsNetUtils.awaitPrivateDnsSetting(msg + "" wait private DNS setting timeout"",                     networkForPrivateDns, GOOGLE_PRIVATE_DNS_SERVER, true);             final VerifyCancelCallback callback = new VerifyCancelCallback(msg);             mDns.rawQuery(network, TEST_NX_DOMAIN, CLASS_IN, TYPE_AAAA, FLAG_NO_CACHE_LOOKUP,                     executor, null, callback);              assertTrue(msg + "" but no answer after "" + TIMEOUT_MS + ""ms."",                     callback.waitForAnswer());             callback.assertNXDomain();         }     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-5"	""	"com.android.cts.verifier.net.MultiNetworkConnectivityTestActivity"	"startTest"	""	""	"7.4.5.3/C-1-5"	"""C-1-5] MUST ensure that, while the user is logging in to a captive portal, the default network used by applications (as returned by ConnectivityManager.getActiveNetwork, ConnectivityManager.registerDefaultNetworkCallback, and used by default by Java networking APIs such as java.net.Socket, and native APIs such as connect()) is any other available network that provides internet access, if available. <h4 id="""	""	"getActiveNetwork ConnectivityManager.getActiveNetwork ConnectivityManager.registerDefaultNetworkCallback"	""	""	""	"getActiveNetwork"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/net/MultiNetworkConnectivityTestActivity.java"	""	"public void testCompleted(MultiNetworkValidator validator) {                     if (validator == mMultiNetworkValidators.get(mMultiNetworkValidators.size()                             - 1)) {                         // Done all tests.                         boolean passed = true;                         for (MultiNetworkValidator multiNetworkValidator :                                 mMultiNetworkValidators) {                             passed = passed && multiNetworkValidator.mTestResult;                         }                         setTestResultAndFinish(passed);                     } else if (!validator.mTestResult) {                         setTestResultAndFinish(false);                     } else {                         for (int i = 0; i < mMultiNetworkValidators.size(); i++) {                             if (mMultiNetworkValidators.get(i) == validator) {                                 mCurrentValidator = mMultiNetworkValidators.get(i + 1);                                 mTestNameView.setText(mCurrentValidator.mTestDescription);                                 mCurrentValidator.startTest();                                 break;                             }                         }                     }                 }             };     private List<MultiNetworkValidator> mMultiNetworkValidators = Collections.emptyList();     private final Runnable mTimeToCompletionRunnable = new Runnable() {         @Override         public void run() {             mSecondsToCompletion--;             if (mSecondsToCompletion > 0) {                 mStartButton.setText("""" + mSecondsToCompletion);                 mMainHandler.postDelayed(this, 1000);             }         }     };      // User interface elements.     private Button mStartButton;     private TextView mTestNameView;     private TextView mTestInfoView;     private EditText mAccessPointSsidEditText;     private EditText mPskEditText;      // Current state memebers.     private MultiNetworkValidator mCurrentValidator;     private int mSecondsToCompletion;     private String mAccessPointSsid = """";     private String mPskValue = """";     private ConnectivityManager mConnectivityManager;     private WifiManager mWifiManager;      private int mRecordedWifiConfiguration = -1;      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         mConnectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);         mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);         mMultiNetworkValidators = createMultiNetworkValidators();          recordCurrentWifiState();         setupUserInterface();         setupBroadcastReceivers();     }      @Override     protected void onResume() {         super.onResume();         setupCurrentTestStateOnResume();     }      @Override     protected void onDestroy() {         super.onDestroy();         destroyBroadcastReceivers();         restoreOriginalWifiState();     }      private void recordCurrentWifiState() {         if (!mWifiManager.isWifiEnabled()) {             return;         }         WifiInfo wifiInfo = mWifiManager.getConnectionInfo();         if (wifiInfo != null && SupplicantState.COMPLETED.equals(wifiInfo.getSupplicantState())) {             mRecordedWifiConfiguration = wifiInfo.getNetworkId();         }     }      private List<MultiNetworkValidator> createMultiNetworkValidators() {         MultiNetworkValidator[] allValidators = {             new ConnectToWifiWithNoInternetValidator(                     R.string.multinetwork_connectivity_test_1_desc),             new LegacyConnectToWifiWithNoInternetValidator(                     R.string.multinetwork_connectivity_test_2_desc),             new LegacyConnectToWifiWithIntermittentInternetValidator(                     R.string.multinetwork_connectivity_test_3_desc)         };          List<MultiNetworkValidator> result = new ArrayList<>();         boolean isLowRamDevice = isLowRamDevice();         for (MultiNetworkValidator validator : allValidators) {           if (!isLowRamDevice || validator.shouldRunOnLowRamDevice()) {             result.add(validator);           }         }         return result;     }      private void restoreOriginalWifiState() {         if (mRecordedWifiConfiguration >= 0) {             mWifiManager.enableNetwork(mRecordedWifiConfiguration, true);         }     }      private boolean requestSystemAlertWindowPerimissionIfRequired() {         if (isLowRamDevice()) {           // For low ram devices, we won't run tests that depend on this permission.           return true;         }          boolean hadPermission = false;         if (!Settings.canDrawOverlays(this)) {             AlertDialog alertDialog = new AlertDialog.Builder(this)                 .setMessage(R.string.multinetwork_connectivity_overlay_permission_message)                 .setPositiveButton(                   R.string.multinetwork_connectivity_overlay_permission_positive,                   (a, b) -> {                       Intent myIntent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);                       startActivity(myIntent);                   })                 .setNegativeButton(                   R.string.multinetwork_connectivity_overlay_permission_negative,                   (a, b) -> {})                 .create();             alertDialog.show();         } else {           hadPermission = true;         }          return hadPermission;     }      private void requestUserEnableWifiAsync(boolean enableWifi, SetWifiCallback callback) {         if (isWifiEnabled() == enableWifi) {           callback.onComplete(/* isSuccess = */ true);           return;         }          int wifiEnableMessage = enableWifi ? R.string.multinetwork_connectivity_turn_wifi_on :                                              R.string.multinetwork_connectivity_turn_wifi_off;          AlertDialog alertDialog = new AlertDialog.Builder(this)             .setMessage(wifiEnableMessage)             .setPositiveButton(R.string.multinetwork_connectivity_turn_wifi_positive,                 (a, b) -> requestUserEnableWifiAsync(enableWifi, callback))             .setNegativeButton(R.string.multinetwork_connectivity_turn_wifi_negative,                 (a, b) -> callback.onComplete(/* isSuccess = */ false))             .create();         alertDialog.show();     }      private void toggleWifiAsync(SetWifiCallback callback) {         // Turn off WiFi.         requestUserEnableWifiAsync(false, (isSuccess) -> {           if (isSuccess) {               // Turn on WiFi.               requestUserEnableWifiAsync(true, callback);           } else {               callback.onComplete(/* isSuccess = */ false);           }         });     }      private boolean isWifiEnabled() {       WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE);       int wifiState = wifiManager.getWifiState();       return wifiState == WifiManager.WIFI_STATE_ENABLED           || wifiState == WifiManager.WIFI_STATE_ENABLING;     }      private void setupUserInterface() {         setContentView(R.layout.multinetwork_connectivity);         setInfoResources(                 R.string.multinetwork_connectivity_test,                 R.string.multinetwork_connectivity_test_instructions,                 -1);         mStartButton = findViewById(R.id.start_multinet_btn);         mTestNameView = findViewById(R.id.current_test);         mTestInfoView = findViewById(R.id.test_progress_info);         mAccessPointSsidEditText = findViewById(R.id.test_ap_ssid);         mPskEditText = findViewById(R.id.test_ap_psk);         mAccessPointSsidEditText.addTextChangedListener(new TextWatcher() {             @Override             public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}              @Override             public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}              @Override             public void afterTextChanged(Editable editable) {                 mAccessPointSsid = editable.toString();                 Log.i(TAG, ""Connecting to "" + mAccessPointSsid);                 mStartButton.setEnabled(isReadyToStart());             }         });         mPskEditText.addTextChangedListener(new TextWatcher() {             @Override             public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}              @Override             public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}              @Override             public void afterTextChanged(Editable editable) {                 mPskValue = editable.toString();                 mStartButton.setEnabled(isReadyToStart());             }         });         mStartButton.setOnClickListener(view -> processStartClicked());     }      private void setupBroadcastReceivers() {         IntentFilter intentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);         intentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);         intentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);         intentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);         registerReceiver(mMultiNetConnectivityReceiver, intentFilter);     }      private void destroyBroadcastReceivers() {         unregisterReceiver(mMultiNetConnectivityReceiver);     }      private boolean isReadyToStart() {         return !(TextUtils.isEmpty(mAccessPointSsid) || TextUtils.isEmpty(mPskValue));     }      private static boolean isNetworkCellularAndHasInternet(ConnectivityManager connectivityManager,             Network network) {         NetworkCapabilities capabilities = connectivityManager.getNetworkCapabilities(network);         return capabilities.hasTransport(TRANSPORT_CELLULAR)                 && capabilities.hasCapability(NET_CAPABILITY_INTERNET);     }      private boolean isMobileDataEnabled(TelephonyManager telephonyManager) {         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {             return telephonyManager.isDataEnabled();         }         Network[] allNetworks = mConnectivityManager.getAllNetworks();         for (Network network : allNetworks) {             if (isNetworkCellularAndHasInternet(mConnectivityManager, network)) {                 return true;             }         }         return false;     }      private boolean checkPreRequisites() {         TelephonyManager telephonyManager =                 (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);         if (telephonyManager == null) {             Log.e(TAG, ""Device does not have telephony manager"");             mTestInfoView.setText(R.string.multinetwork_connectivity_test_all_prereq_1);             return false;         } else if (!isMobileDataEnabled(telephonyManager)) {             Log.e(TAG, ""Device mobile data is not available"");             mTestInfoView.setText(R.string.multinetwork_connectivity_test_all_prereq_2);             return false;         }         return true;     }      /**      * If tester went back and came in again, make sure that test resumes from the previous state.      */     private void setupCurrentTestStateOnResume() {         mCurrentValidator = null;         mStartButton.setEnabled(false);          if (!checkPreRequisites()) {             return;         }          for (MultiNetworkValidator multiNetworkValidator : mMultiNetworkValidators) {           if (multiNetworkValidator.mValidatorState != COMPLETED) {             mCurrentValidator = multiNetworkValidator;             break;           }         }         if (mCurrentValidator != null) {             mTestNameView.setText(mCurrentValidator.mTestDescription);              switch (mCurrentValidator.mValidatorState) {                 case NOT_STARTED:                     mStartButton.setText(R.string.multinetwork_connectivity_test_start);                     mStartButton.setEnabled(isReadyToStart());                     break;                 case STARTED:                     mTestInfoView.setText(getResources().getString(                             mCurrentValidator.mTestProgressMessage));                     break;                 case WAITING_FOR_USER_INPUT:                     mStartButton.setText(R.string.multinetwork_connectivity_test_continue);                     mStartButton.setEnabled(true);                     mTestInfoView.setText(getResources().getString(                             mCurrentValidator.mTestProgressMessage));                 case COMPLETED:                     break;             }             mTestNameView.setText(mCurrentValidator.mTestDescription);         } else {             // All tests completed, so need to re run. It's not likely to get here as             // the default action when all test completes is to mark success and finish.             mStartButton.setText(R.string.multinetwork_connectivity_test_rerun);             mStartButton.setEnabled(true);             rerunMultinetworkTests();             mCurrentValidator = mMultiNetworkValidators.get(0);         }     }      private void rerunMultinetworkTests() {         for (MultiNetworkValidator validator : mMultiNetworkValidators) {             validator.reset();         }     }      private void requestUserConfirmation() {         mMainHandler.post(() -> {             mStartButton.setText(R.string.multinetwork_connectivity_test_continue);             mStartButton.setEnabled(true);         });     }      private void processStartClicked() {         if (!requestSystemAlertWindowPerimissionIfRequired()) {           Log.e(TAG, ""System alert dialog permission not granted to CTSVerifier"");           return;         }          if (mCurrentValidator == null) {             rerunMultinetworkTests();             setupCurrentTestStateOnResume();         }         mStartButton.setEnabled(false);         if (mCurrentValidator.mValidatorState == NOT_STARTED) {             mCurrentValidator.startTest();         } else if (mCurrentValidator.mValidatorState == WAITING_FOR_USER_INPUT) {             mStartButton.setEnabled(false);             mCurrentValidator.continueWithTest();         }     }      private WifiConfiguration buildWifiConfiguration() {         WifiConfiguration wifiConfiguration = new WifiConfiguration();         wifiConfiguration.SSID = ""\"""" + mAccessPointSsid + ""\"""";         wifiConfiguration.preSharedKey = ""\"""" + mPskValue + ""\"""";         wifiConfiguration.status = WifiConfiguration.Status.ENABLED;         wifiConfiguration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);         wifiConfiguration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);         wifiConfiguration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);         wifiConfiguration.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);         wifiConfiguration.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);         wifiConfiguration.allowedProtocols.set(WifiConfiguration.Protocol.RSN);         return wifiConfiguration;     }      private int getOrAddLegacyNetwork() {         List<WifiConfiguration> availableConfigurations = mWifiManager.getConfiguredNetworks();         for (WifiConfiguration configuration : availableConfigurations) {             if (mAccessPointSsid.equals(configuration.SSID)) {                 return configuration.networkId;             }         }         int newNetwork = mWifiManager.addNetwork(buildWifiConfiguration());         return newNetwork;     }      private boolean isConnectedToExpectedWifiNetwork() {         WifiInfo wifiInfo = mWifiManager.getConnectionInfo();         DhcpInfo dhcpInfo = mWifiManager.getDhcpInfo();         Log.i(TAG, ""Checking connected to expected "" + mAccessPointSsid);         if (wifiInfo != null                 && wifiInfo.getSupplicantState().equals(SupplicantState.COMPLETED)                 && dhcpInfo != null) {             String failsafeSsid = String.format(""\""%s\"""", mAccessPointSsid);             Log.i(TAG, ""Connected to "" + wifiInfo.getSSID() + "" expected "" + mAccessPointSsid);             return mAccessPointSsid.equals(wifiInfo.getSSID())                     || failsafeSsid.equals(wifiInfo.getSSID());         }         return false;     }      private void startTimerCountdownDisplay(int timeoutInSeconds) {         mMainHandler.post(() -> mSecondsToCompletion = timeoutInSeconds);         mMainHandler.post(mTimeToCompletionRunnable);     }      private void stopTimerCountdownDisplay() {         mMainHandler.removeCallbacks(mTimeToCompletionRunnable);         mStartButton.setText(""--"");     }      private boolean isLowRamDevice() {         ActivityManager activityManager =             (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);         return activityManager.isLowRamDevice();     }      /**      * Manage the connectivity state for each MultinetworkValidation.      */     private class TestConnectivityState {         private final MultiNetworkValidator mMultiNetworkValidator;          final NetworkCallback mWifiNetworkCallback = new NetworkCallback() {             @Override             public void onAvailable(Network network) {                 Log.i(TAG, ""Wifi network available "" + network.netId);                 stopTimerDisplayIfRequested();                 mMultiNetworkValidator.onWifiNetworkConnected(network);             }              @Override             public void onUnavailable() {                 Log.e(TAG, ""Failed to connect to wifi"");                 stopTimerDisplayIfRequested();                 mMultiNetworkValidator.onWifiNetworkUnavailable();             }         };         final NetworkCallback mCellularNetworkCallback = new NetworkCallback() {             @Override             public void onAvailable(Network network) {                 Log.i(TAG, ""Cellular network available "" + network.netId);                 stopTimerDisplayIfRequested();                 mMultiNetworkValidator.onCellularNetworkConnected(network);             }              @Override             public void onUnavailable() {                 Log.e(TAG, ""Cellular network unavailable "");                 stopTimerDisplayIfRequested();                 mMultiNetworkValidator.onCellularNetworkUnavailable();             }         };         boolean mCellularNetworkRequested;         boolean mWifiNetworkRequested;         boolean mTimerStartRequested;          TestConnectivityState(MultiNetworkValidator validator) {             mMultiNetworkValidator = validator;         }          void reset() {             mMainHandler.post(() -> stopTimerDisplayIfRequested());             if (mWifiNetworkRequested) {                 mConnectivityManager.unregisterNetworkCallback(mWifiNetworkCallback);                 mWifiNetworkRequested = false;             }             if (mCellularNetworkRequested) {                 mConnectivityManager.unregisterNetworkCallback(mCellularNetworkCallback);                 mCellularNetworkRequested = false;             }         }          private void legacyConnectToWifiNetwork(boolean requireInternet) {             // If device is not connected to the expected WifiNetwork, connect to the wifi Network.             // Timeout with failure if it can't connect.             if (!isConnectedToExpectedWifiNetwork()) {                 int network = getOrAddLegacyNetwork();                 WifiManager wifiManager = (WifiManager) getApplicationContext()                         .getSystemService(Context.WIFI_SERVICE);                 wifiManager.enableNetwork(network, true);             }             startTimerDisplay(WIFI_NETWORK_CONNECT_TIMEOUT_MS / 1000);             NetworkRequest.Builder networkRequestBuilder = new NetworkRequest.Builder()                     .addTransportType(TRANSPORT_WIFI);             if (requireInternet) {                 networkRequestBuilder.addCapability(NET_CAPABILITY_INTERNET);             }             NetworkRequest networkRequest = networkRequestBuilder.build();             mWifiNetworkRequested = true;             mConnectivityManager.requestNetwork(networkRequest, mWifiNetworkCallback,                     mMainHandler, WIFI_NETWORK_CONNECT_TIMEOUT_MS);         }          private void connectToWifiNetworkWithNoInternet() {             NetworkSpecifier specifier =                 new WifiNetworkSpecifier.Builder()                   .setSsid(mAccessPointSsid)                   .setWpa2Passphrase(mPskValue)                   .build();              NetworkRequest networkRequest = new NetworkRequest.Builder()                     .addTransportType(TRANSPORT_WIFI)                     .setNetworkSpecifier(specifier)                     .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                     .build();              mWifiNetworkRequested = true;             mConnectivityManager.requestNetwork(networkRequest, mWifiNetworkCallback,                     mMainHandler);         }          private void connectToCellularNetwork() {             NetworkRequest networkRequest = new NetworkRequest.Builder()                     .addTransportType(TRANSPORT_CELLULAR)                     .addCapability(NET_CAPABILITY_INTERNET)                     .build();             startTimerDisplay(CELLULAR_NETWORK_CONNECT_TIMEOUT_MS / 1000);             mCellularNetworkRequested = true;             mConnectivityManager.requestNetwork(networkRequest, mCellularNetworkCallback,                     mMainHandler, CELLULAR_NETWORK_CONNECT_TIMEOUT_MS);         }          private void startTimerDisplay(int timeInSeconds) {             startTimerCountdownDisplay(timeInSeconds);             mTimerStartRequested = true;         }          /** Timer is a shared resource, change the state only if it's started in a request. */         private void stopTimerDisplayIfRequested() {             if (mTimerStartRequested) {                 mTimerStartRequested = false;                 stopTimerCountdownDisplay();             }         }     }      /**      * Manage the lifecycle of each test to be run in the validator.      *      * Each test goes through this cycle      * - Start      * - Connect to cellular network      * - Connect to wifi network      * - Check expectation      * - End test      */     private abstract class MultiNetworkValidator {         final String mTestName;         final MultinetworkTestCallback mTestCallback;         final TestConnectivityState mConnectivityState;         final boolean mRunTestOnLowMemoryDevices;          int mTestDescription;         boolean mTestResult = false;         ValidatorState mValidatorState;         int mTestResultMessage = -1;         int mTestProgressMessage;          MultiNetworkValidator(MultinetworkTestCallback testCallback,                 String testName,                 int testDescription,                 boolean runTestOnLowMemoryDevices) {             mTestCallback = testCallback;             mTestName = testName;             mTestDescription = testDescription;             mConnectivityState = new TestConnectivityState(this);             mValidatorState = NOT_STARTED;             mRunTestOnLowMemoryDevices = runTestOnLowMemoryDevices;         }          /** Start test if not started. */         void startTest() {             Handler uiThreadHandler = new Handler(Looper.getMainLooper());             if (mValidatorState == NOT_STARTED) {                 mTestCallback.testStarted();                 toggleWifiAsync(hasToggled -> {                     if (!hasToggled) {                         onUnableToSetWifi();                         return;                     }                     mTestCallback.testProgress(                         R.string.multinetwork_connectivity_test_connect_cellular);                     mConnectivityState.connectToCellularNetwork();                 });             }         }          /** Make sure that the state is restored for re-running the test. */         void reset() {             mValidatorState = NOT_STARTED;             mTestResultMessage = -1;             mTestProgressMessage = -1;         }          /** Called when user has requested to continue with the test */         void continueWithTest() {             mValidatorState = STARTED;         }          void onCellularNetworkUnavailable() {             endTest(false, R.string.multinetwork_status_mobile_connect_timed_out);         }          void onUnableToSetWifi() {             endTest(false, R.string.multinetwork_status_unable_to_toggle_wifi);         }          void endTest(boolean status, int messageResId) {             Log.i(TAG, ""Ending test with status "" + status + "" message "" +                 MultiNetworkConnectivityTestActivity.this.getResources().getString(messageResId));             mMainHandler.post(() -> {                 mTestResult = status;                 mTestResultMessage = messageResId;                 mValidatorState = COMPLETED;                 mTestCallback.testCompleted(MultiNetworkValidator.this);                 mConnectivityState.reset();             });         }          /** Called when cellular network is connected. */         void onCellularNetworkConnected(Network network) {             onContinuePreWifiConnect();         }          /**          * @param transport The active network has this transport type          * @return          */         boolean isExpectedTransportForActiveNetwork(int transport) {             Network activeNetwork = mConnectivityManager.getActiveNetwork();             NetworkCapabilities activeNetworkCapabilities =                     mConnectivityManager.getNetworkCapabilities(activeNetwork);             Log.i(TAG, ""Network capabilities for "" + activeNetwork.netId + "" ""                     + activeNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));             return activeNetworkCapabilities.hasTransport(transport)                     && activeNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET);         }          /**          * @param network to check if connected or not.          * @return          */         boolean isNetworkConnected(Network network) {             NetworkInfo networkInfo = mConnectivityManager.getNetworkInfo(network);             boolean status = networkInfo != null && networkInfo.isConnectedOrConnecting();             Log.i(TAG, ""Network connection status "" + network.netId + "" "" + status);             return status;         }          /**          * Called before connecting to wifi. Specially if the concrete validator wants to          * prompt a message          */         abstract void onContinuePreWifiConnect();          /** Called when a wifi network is connected and available */         void onWifiNetworkConnected(Network network) {             Log.i(TAG, ""Wifi network connected "" + network.netId);         }          void onWifiNetworkUnavailable() {             endTest(false, R.string.multinetwork_status_wifi_connect_timed_out);         }          boolean shouldRunOnLowRamDevice() {           return mRunTestOnLowMemoryDevices;         }     }      /**      * Test that device does not lose cellular connectivity when it's connected to an access      * point with no connectivity using legacy API's.      */     private class LegacyConnectToWifiWithNoInternetValidator extends MultiNetworkValidator {          LegacyConnectToWifiWithNoInternetValidator(int description) {             super(mMultinetworkTestCallback,                 ""legacy_no_internet_test"",                 description,                 /* runTestOnLowMemoryDevices = */ false);         }           @Override         void continueWithTest() {             super.continueWithTest();             connectToWifi();         }          @Override         void onContinuePreWifiConnect() {             mTestProgressMessage = R.string.multinetwork_connectivity_test_1_prereq;             mTestCallback.testProgress(mTestProgressMessage);             mValidatorState = WAITING_FOR_USER_INPUT;             requestUserConfirmation();         }          @Override         void onWifiNetworkConnected(Network wifiNetwork) {             super.onWifiNetworkConnected(wifiNetwork);             if (isConnectedToExpectedWifiNetwork()) {                 startTimerCountdownDisplay(CELLULAR_NETWORK_RESTORE_TIMEOUT_MS / 1000);                 mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_2);                  // Wait for CELLULAR_NETWORK_RESTORE_TIMEOUT_MS, before checking if there is still                 // the active network as the cell network.                 mMainHandler.postDelayed(() -> {                     stopTimerCountdownDisplay();                     mMainHandler.post(() -> {                         if (isExpectedTransportForActiveNetwork(TRANSPORT_CELLULAR)                                 && isNetworkConnected(wifiNetwork)) {                             Log.d(TAG, ""PASS test as device has connectivity"");                             endTest(true, R.string.multinetwork_status_mobile_restore_success);                         } else {                             Log.d(TAG, ""Fail test as device didn't have connectivity"");                             endTest(false, R.string.multinetwork_status_mobile_restore_failed);                         }                     });                 }, CELLULAR_NETWORK_RESTORE_TIMEOUT_MS);             } else {                 endTest(false, R.string.multinetwork_status_wifi_connect_wrong_ap);             }         }          void connectToWifi() {             mTestCallback.testProgress(R.string.multinetwork_connectivity_test_connect_wifi);             mConnectivityState.legacyConnectToWifiNetwork(false);         }     }      /**      * Test that device restores lost cellular connectivity when it's connected to an access      * point which loses internet connectivity using legacy API's.      */     private class LegacyConnectToWifiWithIntermittentInternetValidator         extends MultiNetworkValidator {         boolean mWaitingForWifiConnect = false;         boolean mWaitingForCelluarToConnectBack = false;         Network mWifiNetwork;          LegacyConnectToWifiWithIntermittentInternetValidator(int description) {             super(mMultinetworkTestCallback,                 ""legacy_no_internet_test"",                 description,                 /* runTestOnLowMemoryDevices = */ false);         }          @Override         void continueWithTest() {             super.continueWithTest();             if (mWaitingForWifiConnect) {                 connectToWifi();             } else if (mWaitingForCelluarToConnectBack) {                 mWaitingForCelluarToConnectBack = false;                 waitForConnectivityRestore();             }         }          @Override         void onContinuePreWifiConnect() {             mTestProgressMessage = R.string.multinetwork_connectivity_test_2_prereq_1;             mTestCallback.testProgress(mTestProgressMessage);             mValidatorState = WAITING_FOR_USER_INPUT;             mWaitingForWifiConnect = true;             requestUserConfirmation();         }          void connectToWifi() {             mTestCallback.testProgress(R.string.multinetwork_connectivity_test_connect_wifi);             mConnectivityState.legacyConnectToWifiNetwork(true);         }          @Override         void onWifiNetworkConnected(Network wifiNetwork) {             super.onWifiNetworkConnected(wifiNetwork);             if (isConnectedToExpectedWifiNetwork()) {                 // If the device is connected to the expected network, then update the wifi                 // network to the latest.                 mWifiNetwork = wifiNetwork;                 // Do further processing only when the test is requesting and waiting for a wifi                 // connection.                 if (mWaitingForWifiConnect) {                     mWaitingForWifiConnect = false;                     startTimerCountdownDisplay(WIFI_NETWORK_CONNECT_TO_BE_ACTIVE_MS / 1000);                      // Wait for WIFI_NETWORK_CONNECT_TO_BE_ACTIVE_MS, before checking                     // if device has the active network as wifi network..                     mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_2);                     mMainHandler.postDelayed(() -> {                         stopTimerCountdownDisplay();                         // In this case both active and peer are same as Wifi has internet access.                         if (isExpectedTransportForActiveNetwork(TRANSPORT_WIFI)                                 && isNetworkConnected(mWifiNetwork)) {                             // Ask the user to turn off wifi on the router and check connectivity.                             mTestProgressMessage =                                     R.string.multinetwork_connectivity_test_2_prereq_2;                             mValidatorState = WAITING_FOR_USER_INPUT;                             mTestCallback.testProgress(mTestProgressMessage);                             mWaitingForCelluarToConnectBack = true;                             requestUserConfirmation();                         } else {                             Log.d(TAG, ""Fail test as device didn't have connectivity"");                             endTest(false, R.string.multinetwork_status_wifi_connectivity_failed);                         }                     }, WIFI_NETWORK_CONNECT_TO_BE_ACTIVE_MS);                 }             } else {                 endTest(false, R.string.multinetwork_status_wifi_connect_wrong_ap);             }         }          @Override         void reset() {             super.reset();             mWaitingForCelluarToConnectBack = false;             mWaitingForWifiConnect = false;             mWifiNetwork = null;         }          @Override         void onWifiNetworkUnavailable() {             if (mWaitingForWifiConnect) {                 super.onWifiNetworkUnavailable();             }         }          void waitForConnectivityRestore() {             mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_1);             mConnectivityManager.reportNetworkConnectivity(mWifiNetwork, false);             startTimerCountdownDisplay(                     CELLULAR_NETWORK_RESTORE_AFTER_WIFI_INTERNET_LOST_TIMEOUT_MS / 1000);             // Wait for CELLULAR_NETWORK_RESTORE_AFTER_WIFI_INTERNET_LOST_TIMEOUT_MS,             // before checking if device now has the active network as cell network.             mMainHandler.postDelayed(() -> {                 stopTimerCountdownDisplay();                 // Check if device has fallen back to cellular network when it loses internet access                 // in the wifi network.                 if (isExpectedTransportForActiveNetwork(TRANSPORT_CELLULAR)                         && isNetworkConnected(mWifiNetwork)) {                     Log.d(TAG, ""PASS test as device has connectivity"");                     endTest(true, R.string.multinetwork_status_mobile_restore_success);                 } else {                     Log.d(TAG, ""Fail test as device didn't have connectivity"");                     endTest(false, R.string.multinetwork_status_mobile_restore_failed);                 }             }, CELLULAR_NETWORK_RESTORE_AFTER_WIFI_INTERNET_LOST_TIMEOUT_MS);         }     }      /**      * Test that device does not lose cellular connectivity when it's connected to an access      * point with no connectivity using the new API's.      */     private class ConnectToWifiWithNoInternetValidator extends MultiNetworkValidator {          ConnectToWifiWithNoInternetValidator(int description) {             super(mMultinetworkTestCallback,                 ""no_internet_test"",                 description,                 /* runTestOnLowMemoryDevices = */ true);         }           @Override         void continueWithTest() {             super.continueWithTest();             connectToWifi();         }          @Override         void onContinuePreWifiConnect() {             mTestProgressMessage = R.string.multinetwork_connectivity_test_1_prereq;             mTestCallback.testProgress(mTestProgressMessage);             mValidatorState = WAITING_FOR_USER_INPUT;             requestUserConfirmation();         }          void connectToWifi() {             mTestCallback.testProgress(R.string.multinetwork_connectivity_test_connect_wifi);             mConnectivityState.connectToWifiNetworkWithNoInternet();         }          @Override         void onWifiNetworkConnected(Network wifiNetwork) {             super.onWifiNetworkConnected(wifiNetwork);             if (isConnectedToExpectedWifiNetwork()) {                 startTimerCountdownDisplay(CELLULAR_NETWORK_RESTORE_TIMEOUT_MS / 1000);                 mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_2);                  // Wait for CELLULAR_NETWORK_RESTORE_TIMEOUT_MS, before checking if there is still                 // the active network as the cell network.                 mMainHandler.postDelayed(() -> {                     stopTimerCountdownDisplay();                     mMainHandler.post(() -> {                         if (isExpectedTransportForActiveNetwork(TRANSPORT_CELLULAR)                                 && isNetworkConnected(wifiNetwork)) {                             Log.d(TAG, ""PASS test as device has connectivity"");                             endTest(true, R.string.multinetwork_status_mobile_restore_success);                         } else {                             Log.d(TAG, ""Fail test as device didn't have connectivity"");                             endTest(false, R.string.multinetwork_status_mobile_restore_failed);                         }                     });                 }, CELLULAR_NETWORK_RESTORE_TIMEOUT_MS);             } else {                 endTest(false, R.string.multinetwork_status_wifi_connect_wrong_ap);             }         }     }      private interface SetWifiCallback {         void onComplete(boolean isSuccess);     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-5"	""	"com.android.cts.verifier.net.MultiNetworkConnectivityTestActivity"	"startTest"	""	""	"7.4.5.3/C-1-5"	"""C-1-5] MUST ensure that, while the user is logging in to a captive portal, the default network used by applications (as returned by ConnectivityManager.getActiveNetwork, ConnectivityManager.registerDefaultNetworkCallback, and used by default by Java networking APIs such as java.net.Socket, and native APIs such as connect()) is any other available network that provides internet access, if available. <h4 id="""	""	"getActiveNetwork ConnectivityManager.getActiveNetwork ConnectivityManager.registerDefaultNetworkCallback"	""	""	""	"ConnectivityManager.getActiveNetwork"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/net/MultiNetworkConnectivityTestActivity.java"	""	"public void testCompleted(MultiNetworkValidator validator) {                     if (validator == mMultiNetworkValidators.get(mMultiNetworkValidators.size()                             - 1)) {                         // Done all tests.                         boolean passed = true;                         for (MultiNetworkValidator multiNetworkValidator :                                 mMultiNetworkValidators) {                             passed = passed && multiNetworkValidator.mTestResult;                         }                         setTestResultAndFinish(passed);                     } else if (!validator.mTestResult) {                         setTestResultAndFinish(false);                     } else {                         for (int i = 0; i < mMultiNetworkValidators.size(); i++) {                             if (mMultiNetworkValidators.get(i) == validator) {                                 mCurrentValidator = mMultiNetworkValidators.get(i + 1);                                 mTestNameView.setText(mCurrentValidator.mTestDescription);                                 mCurrentValidator.startTest();                                 break;                             }                         }                     }                 }             };     private List<MultiNetworkValidator> mMultiNetworkValidators = Collections.emptyList();     private final Runnable mTimeToCompletionRunnable = new Runnable() {         @Override         public void run() {             mSecondsToCompletion--;             if (mSecondsToCompletion > 0) {                 mStartButton.setText("""" + mSecondsToCompletion);                 mMainHandler.postDelayed(this, 1000);             }         }     };      // User interface elements.     private Button mStartButton;     private TextView mTestNameView;     private TextView mTestInfoView;     private EditText mAccessPointSsidEditText;     private EditText mPskEditText;      // Current state memebers.     private MultiNetworkValidator mCurrentValidator;     private int mSecondsToCompletion;     private String mAccessPointSsid = """";     private String mPskValue = """";     private ConnectivityManager mConnectivityManager;     private WifiManager mWifiManager;      private int mRecordedWifiConfiguration = -1;      @Override     protected void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);         mConnectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);         mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);         mMultiNetworkValidators = createMultiNetworkValidators();          recordCurrentWifiState();         setupUserInterface();         setupBroadcastReceivers();     }      @Override     protected void onResume() {         super.onResume();         setupCurrentTestStateOnResume();     }      @Override     protected void onDestroy() {         super.onDestroy();         destroyBroadcastReceivers();         restoreOriginalWifiState();     }      private void recordCurrentWifiState() {         if (!mWifiManager.isWifiEnabled()) {             return;         }         WifiInfo wifiInfo = mWifiManager.getConnectionInfo();         if (wifiInfo != null && SupplicantState.COMPLETED.equals(wifiInfo.getSupplicantState())) {             mRecordedWifiConfiguration = wifiInfo.getNetworkId();         }     }      private List<MultiNetworkValidator> createMultiNetworkValidators() {         MultiNetworkValidator[] allValidators = {             new ConnectToWifiWithNoInternetValidator(                     R.string.multinetwork_connectivity_test_1_desc),             new LegacyConnectToWifiWithNoInternetValidator(                     R.string.multinetwork_connectivity_test_2_desc),             new LegacyConnectToWifiWithIntermittentInternetValidator(                     R.string.multinetwork_connectivity_test_3_desc)         };          List<MultiNetworkValidator> result = new ArrayList<>();         boolean isLowRamDevice = isLowRamDevice();         for (MultiNetworkValidator validator : allValidators) {           if (!isLowRamDevice || validator.shouldRunOnLowRamDevice()) {             result.add(validator);           }         }         return result;     }      private void restoreOriginalWifiState() {         if (mRecordedWifiConfiguration >= 0) {             mWifiManager.enableNetwork(mRecordedWifiConfiguration, true);         }     }      private boolean requestSystemAlertWindowPerimissionIfRequired() {         if (isLowRamDevice()) {           // For low ram devices, we won't run tests that depend on this permission.           return true;         }          boolean hadPermission = false;         if (!Settings.canDrawOverlays(this)) {             AlertDialog alertDialog = new AlertDialog.Builder(this)                 .setMessage(R.string.multinetwork_connectivity_overlay_permission_message)                 .setPositiveButton(                   R.string.multinetwork_connectivity_overlay_permission_positive,                   (a, b) -> {                       Intent myIntent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);                       startActivity(myIntent);                   })                 .setNegativeButton(                   R.string.multinetwork_connectivity_overlay_permission_negative,                   (a, b) -> {})                 .create();             alertDialog.show();         } else {           hadPermission = true;         }          return hadPermission;     }      private void requestUserEnableWifiAsync(boolean enableWifi, SetWifiCallback callback) {         if (isWifiEnabled() == enableWifi) {           callback.onComplete(/* isSuccess = */ true);           return;         }          int wifiEnableMessage = enableWifi ? R.string.multinetwork_connectivity_turn_wifi_on :                                              R.string.multinetwork_connectivity_turn_wifi_off;          AlertDialog alertDialog = new AlertDialog.Builder(this)             .setMessage(wifiEnableMessage)             .setPositiveButton(R.string.multinetwork_connectivity_turn_wifi_positive,                 (a, b) -> requestUserEnableWifiAsync(enableWifi, callback))             .setNegativeButton(R.string.multinetwork_connectivity_turn_wifi_negative,                 (a, b) -> callback.onComplete(/* isSuccess = */ false))             .create();         alertDialog.show();     }      private void toggleWifiAsync(SetWifiCallback callback) {         // Turn off WiFi.         requestUserEnableWifiAsync(false, (isSuccess) -> {           if (isSuccess) {               // Turn on WiFi.               requestUserEnableWifiAsync(true, callback);           } else {               callback.onComplete(/* isSuccess = */ false);           }         });     }      private boolean isWifiEnabled() {       WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE);       int wifiState = wifiManager.getWifiState();       return wifiState == WifiManager.WIFI_STATE_ENABLED           || wifiState == WifiManager.WIFI_STATE_ENABLING;     }      private void setupUserInterface() {         setContentView(R.layout.multinetwork_connectivity);         setInfoResources(                 R.string.multinetwork_connectivity_test,                 R.string.multinetwork_connectivity_test_instructions,                 -1);         mStartButton = findViewById(R.id.start_multinet_btn);         mTestNameView = findViewById(R.id.current_test);         mTestInfoView = findViewById(R.id.test_progress_info);         mAccessPointSsidEditText = findViewById(R.id.test_ap_ssid);         mPskEditText = findViewById(R.id.test_ap_psk);         mAccessPointSsidEditText.addTextChangedListener(new TextWatcher() {             @Override             public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}              @Override             public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}              @Override             public void afterTextChanged(Editable editable) {                 mAccessPointSsid = editable.toString();                 Log.i(TAG, ""Connecting to "" + mAccessPointSsid);                 mStartButton.setEnabled(isReadyToStart());             }         });         mPskEditText.addTextChangedListener(new TextWatcher() {             @Override             public void beforeTextChanged(CharSequence charSequence, int i, int i1, int i2) {}              @Override             public void onTextChanged(CharSequence charSequence, int i, int i1, int i2) {}              @Override             public void afterTextChanged(Editable editable) {                 mPskValue = editable.toString();                 mStartButton.setEnabled(isReadyToStart());             }         });         mStartButton.setOnClickListener(view -> processStartClicked());     }      private void setupBroadcastReceivers() {         IntentFilter intentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);         intentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);         intentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);         intentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);         registerReceiver(mMultiNetConnectivityReceiver, intentFilter);     }      private void destroyBroadcastReceivers() {         unregisterReceiver(mMultiNetConnectivityReceiver);     }      private boolean isReadyToStart() {         return !(TextUtils.isEmpty(mAccessPointSsid) || TextUtils.isEmpty(mPskValue));     }      private static boolean isNetworkCellularAndHasInternet(ConnectivityManager connectivityManager,             Network network) {         NetworkCapabilities capabilities = connectivityManager.getNetworkCapabilities(network);         return capabilities.hasTransport(TRANSPORT_CELLULAR)                 && capabilities.hasCapability(NET_CAPABILITY_INTERNET);     }      private boolean isMobileDataEnabled(TelephonyManager telephonyManager) {         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {             return telephonyManager.isDataEnabled();         }         Network[] allNetworks = mConnectivityManager.getAllNetworks();         for (Network network : allNetworks) {             if (isNetworkCellularAndHasInternet(mConnectivityManager, network)) {                 return true;             }         }         return false;     }      private boolean checkPreRequisites() {         TelephonyManager telephonyManager =                 (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);         if (telephonyManager == null) {             Log.e(TAG, ""Device does not have telephony manager"");             mTestInfoView.setText(R.string.multinetwork_connectivity_test_all_prereq_1);             return false;         } else if (!isMobileDataEnabled(telephonyManager)) {             Log.e(TAG, ""Device mobile data is not available"");             mTestInfoView.setText(R.string.multinetwork_connectivity_test_all_prereq_2);             return false;         }         return true;     }      /**      * If tester went back and came in again, make sure that test resumes from the previous state.      */     private void setupCurrentTestStateOnResume() {         mCurrentValidator = null;         mStartButton.setEnabled(false);          if (!checkPreRequisites()) {             return;         }          for (MultiNetworkValidator multiNetworkValidator : mMultiNetworkValidators) {           if (multiNetworkValidator.mValidatorState != COMPLETED) {             mCurrentValidator = multiNetworkValidator;             break;           }         }         if (mCurrentValidator != null) {             mTestNameView.setText(mCurrentValidator.mTestDescription);              switch (mCurrentValidator.mValidatorState) {                 case NOT_STARTED:                     mStartButton.setText(R.string.multinetwork_connectivity_test_start);                     mStartButton.setEnabled(isReadyToStart());                     break;                 case STARTED:                     mTestInfoView.setText(getResources().getString(                             mCurrentValidator.mTestProgressMessage));                     break;                 case WAITING_FOR_USER_INPUT:                     mStartButton.setText(R.string.multinetwork_connectivity_test_continue);                     mStartButton.setEnabled(true);                     mTestInfoView.setText(getResources().getString(                             mCurrentValidator.mTestProgressMessage));                 case COMPLETED:                     break;             }             mTestNameView.setText(mCurrentValidator.mTestDescription);         } else {             // All tests completed, so need to re run. It's not likely to get here as             // the default action when all test completes is to mark success and finish.             mStartButton.setText(R.string.multinetwork_connectivity_test_rerun);             mStartButton.setEnabled(true);             rerunMultinetworkTests();             mCurrentValidator = mMultiNetworkValidators.get(0);         }     }      private void rerunMultinetworkTests() {         for (MultiNetworkValidator validator : mMultiNetworkValidators) {             validator.reset();         }     }      private void requestUserConfirmation() {         mMainHandler.post(() -> {             mStartButton.setText(R.string.multinetwork_connectivity_test_continue);             mStartButton.setEnabled(true);         });     }      private void processStartClicked() {         if (!requestSystemAlertWindowPerimissionIfRequired()) {           Log.e(TAG, ""System alert dialog permission not granted to CTSVerifier"");           return;         }          if (mCurrentValidator == null) {             rerunMultinetworkTests();             setupCurrentTestStateOnResume();         }         mStartButton.setEnabled(false);         if (mCurrentValidator.mValidatorState == NOT_STARTED) {             mCurrentValidator.startTest();         } else if (mCurrentValidator.mValidatorState == WAITING_FOR_USER_INPUT) {             mStartButton.setEnabled(false);             mCurrentValidator.continueWithTest();         }     }      private WifiConfiguration buildWifiConfiguration() {         WifiConfiguration wifiConfiguration = new WifiConfiguration();         wifiConfiguration.SSID = ""\"""" + mAccessPointSsid + ""\"""";         wifiConfiguration.preSharedKey = ""\"""" + mPskValue + ""\"""";         wifiConfiguration.status = WifiConfiguration.Status.ENABLED;         wifiConfiguration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);         wifiConfiguration.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);         wifiConfiguration.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);         wifiConfiguration.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);         wifiConfiguration.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);         wifiConfiguration.allowedProtocols.set(WifiConfiguration.Protocol.RSN);         return wifiConfiguration;     }      private int getOrAddLegacyNetwork() {         List<WifiConfiguration> availableConfigurations = mWifiManager.getConfiguredNetworks();         for (WifiConfiguration configuration : availableConfigurations) {             if (mAccessPointSsid.equals(configuration.SSID)) {                 return configuration.networkId;             }         }         int newNetwork = mWifiManager.addNetwork(buildWifiConfiguration());         return newNetwork;     }      private boolean isConnectedToExpectedWifiNetwork() {         WifiInfo wifiInfo = mWifiManager.getConnectionInfo();         DhcpInfo dhcpInfo = mWifiManager.getDhcpInfo();         Log.i(TAG, ""Checking connected to expected "" + mAccessPointSsid);         if (wifiInfo != null                 && wifiInfo.getSupplicantState().equals(SupplicantState.COMPLETED)                 && dhcpInfo != null) {             String failsafeSsid = String.format(""\""%s\"""", mAccessPointSsid);             Log.i(TAG, ""Connected to "" + wifiInfo.getSSID() + "" expected "" + mAccessPointSsid);             return mAccessPointSsid.equals(wifiInfo.getSSID())                     || failsafeSsid.equals(wifiInfo.getSSID());         }         return false;     }      private void startTimerCountdownDisplay(int timeoutInSeconds) {         mMainHandler.post(() -> mSecondsToCompletion = timeoutInSeconds);         mMainHandler.post(mTimeToCompletionRunnable);     }      private void stopTimerCountdownDisplay() {         mMainHandler.removeCallbacks(mTimeToCompletionRunnable);         mStartButton.setText(""--"");     }      private boolean isLowRamDevice() {         ActivityManager activityManager =             (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);         return activityManager.isLowRamDevice();     }      /**      * Manage the connectivity state for each MultinetworkValidation.      */     private class TestConnectivityState {         private final MultiNetworkValidator mMultiNetworkValidator;          final NetworkCallback mWifiNetworkCallback = new NetworkCallback() {             @Override             public void onAvailable(Network network) {                 Log.i(TAG, ""Wifi network available "" + network.netId);                 stopTimerDisplayIfRequested();                 mMultiNetworkValidator.onWifiNetworkConnected(network);             }              @Override             public void onUnavailable() {                 Log.e(TAG, ""Failed to connect to wifi"");                 stopTimerDisplayIfRequested();                 mMultiNetworkValidator.onWifiNetworkUnavailable();             }         };         final NetworkCallback mCellularNetworkCallback = new NetworkCallback() {             @Override             public void onAvailable(Network network) {                 Log.i(TAG, ""Cellular network available "" + network.netId);                 stopTimerDisplayIfRequested();                 mMultiNetworkValidator.onCellularNetworkConnected(network);             }              @Override             public void onUnavailable() {                 Log.e(TAG, ""Cellular network unavailable "");                 stopTimerDisplayIfRequested();                 mMultiNetworkValidator.onCellularNetworkUnavailable();             }         };         boolean mCellularNetworkRequested;         boolean mWifiNetworkRequested;         boolean mTimerStartRequested;          TestConnectivityState(MultiNetworkValidator validator) {             mMultiNetworkValidator = validator;         }          void reset() {             mMainHandler.post(() -> stopTimerDisplayIfRequested());             if (mWifiNetworkRequested) {                 mConnectivityManager.unregisterNetworkCallback(mWifiNetworkCallback);                 mWifiNetworkRequested = false;             }             if (mCellularNetworkRequested) {                 mConnectivityManager.unregisterNetworkCallback(mCellularNetworkCallback);                 mCellularNetworkRequested = false;             }         }          private void legacyConnectToWifiNetwork(boolean requireInternet) {             // If device is not connected to the expected WifiNetwork, connect to the wifi Network.             // Timeout with failure if it can't connect.             if (!isConnectedToExpectedWifiNetwork()) {                 int network = getOrAddLegacyNetwork();                 WifiManager wifiManager = (WifiManager) getApplicationContext()                         .getSystemService(Context.WIFI_SERVICE);                 wifiManager.enableNetwork(network, true);             }             startTimerDisplay(WIFI_NETWORK_CONNECT_TIMEOUT_MS / 1000);             NetworkRequest.Builder networkRequestBuilder = new NetworkRequest.Builder()                     .addTransportType(TRANSPORT_WIFI);             if (requireInternet) {                 networkRequestBuilder.addCapability(NET_CAPABILITY_INTERNET);             }             NetworkRequest networkRequest = networkRequestBuilder.build();             mWifiNetworkRequested = true;             mConnectivityManager.requestNetwork(networkRequest, mWifiNetworkCallback,                     mMainHandler, WIFI_NETWORK_CONNECT_TIMEOUT_MS);         }          private void connectToWifiNetworkWithNoInternet() {             NetworkSpecifier specifier =                 new WifiNetworkSpecifier.Builder()                   .setSsid(mAccessPointSsid)                   .setWpa2Passphrase(mPskValue)                   .build();              NetworkRequest networkRequest = new NetworkRequest.Builder()                     .addTransportType(TRANSPORT_WIFI)                     .setNetworkSpecifier(specifier)                     .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                     .build();              mWifiNetworkRequested = true;             mConnectivityManager.requestNetwork(networkRequest, mWifiNetworkCallback,                     mMainHandler);         }          private void connectToCellularNetwork() {             NetworkRequest networkRequest = new NetworkRequest.Builder()                     .addTransportType(TRANSPORT_CELLULAR)                     .addCapability(NET_CAPABILITY_INTERNET)                     .build();             startTimerDisplay(CELLULAR_NETWORK_CONNECT_TIMEOUT_MS / 1000);             mCellularNetworkRequested = true;             mConnectivityManager.requestNetwork(networkRequest, mCellularNetworkCallback,                     mMainHandler, CELLULAR_NETWORK_CONNECT_TIMEOUT_MS);         }          private void startTimerDisplay(int timeInSeconds) {             startTimerCountdownDisplay(timeInSeconds);             mTimerStartRequested = true;         }          /** Timer is a shared resource, change the state only if it's started in a request. */         private void stopTimerDisplayIfRequested() {             if (mTimerStartRequested) {                 mTimerStartRequested = false;                 stopTimerCountdownDisplay();             }         }     }      /**      * Manage the lifecycle of each test to be run in the validator.      *      * Each test goes through this cycle      * - Start      * - Connect to cellular network      * - Connect to wifi network      * - Check expectation      * - End test      */     private abstract class MultiNetworkValidator {         final String mTestName;         final MultinetworkTestCallback mTestCallback;         final TestConnectivityState mConnectivityState;         final boolean mRunTestOnLowMemoryDevices;          int mTestDescription;         boolean mTestResult = false;         ValidatorState mValidatorState;         int mTestResultMessage = -1;         int mTestProgressMessage;          MultiNetworkValidator(MultinetworkTestCallback testCallback,                 String testName,                 int testDescription,                 boolean runTestOnLowMemoryDevices) {             mTestCallback = testCallback;             mTestName = testName;             mTestDescription = testDescription;             mConnectivityState = new TestConnectivityState(this);             mValidatorState = NOT_STARTED;             mRunTestOnLowMemoryDevices = runTestOnLowMemoryDevices;         }          /** Start test if not started. */         void startTest() {             Handler uiThreadHandler = new Handler(Looper.getMainLooper());             if (mValidatorState == NOT_STARTED) {                 mTestCallback.testStarted();                 toggleWifiAsync(hasToggled -> {                     if (!hasToggled) {                         onUnableToSetWifi();                         return;                     }                     mTestCallback.testProgress(                         R.string.multinetwork_connectivity_test_connect_cellular);                     mConnectivityState.connectToCellularNetwork();                 });             }         }          /** Make sure that the state is restored for re-running the test. */         void reset() {             mValidatorState = NOT_STARTED;             mTestResultMessage = -1;             mTestProgressMessage = -1;         }          /** Called when user has requested to continue with the test */         void continueWithTest() {             mValidatorState = STARTED;         }          void onCellularNetworkUnavailable() {             endTest(false, R.string.multinetwork_status_mobile_connect_timed_out);         }          void onUnableToSetWifi() {             endTest(false, R.string.multinetwork_status_unable_to_toggle_wifi);         }          void endTest(boolean status, int messageResId) {             Log.i(TAG, ""Ending test with status "" + status + "" message "" +                 MultiNetworkConnectivityTestActivity.this.getResources().getString(messageResId));             mMainHandler.post(() -> {                 mTestResult = status;                 mTestResultMessage = messageResId;                 mValidatorState = COMPLETED;                 mTestCallback.testCompleted(MultiNetworkValidator.this);                 mConnectivityState.reset();             });         }          /** Called when cellular network is connected. */         void onCellularNetworkConnected(Network network) {             onContinuePreWifiConnect();         }          /**          * @param transport The active network has this transport type          * @return          */         boolean isExpectedTransportForActiveNetwork(int transport) {             Network activeNetwork = mConnectivityManager.getActiveNetwork();             NetworkCapabilities activeNetworkCapabilities =                     mConnectivityManager.getNetworkCapabilities(activeNetwork);             Log.i(TAG, ""Network capabilities for "" + activeNetwork.netId + "" ""                     + activeNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));             return activeNetworkCapabilities.hasTransport(transport)                     && activeNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET);         }          /**          * @param network to check if connected or not.          * @return          */         boolean isNetworkConnected(Network network) {             NetworkInfo networkInfo = mConnectivityManager.getNetworkInfo(network);             boolean status = networkInfo != null && networkInfo.isConnectedOrConnecting();             Log.i(TAG, ""Network connection status "" + network.netId + "" "" + status);             return status;         }          /**          * Called before connecting to wifi. Specially if the concrete validator wants to          * prompt a message          */         abstract void onContinuePreWifiConnect();          /** Called when a wifi network is connected and available */         void onWifiNetworkConnected(Network network) {             Log.i(TAG, ""Wifi network connected "" + network.netId);         }          void onWifiNetworkUnavailable() {             endTest(false, R.string.multinetwork_status_wifi_connect_timed_out);         }          boolean shouldRunOnLowRamDevice() {           return mRunTestOnLowMemoryDevices;         }     }      /**      * Test that device does not lose cellular connectivity when it's connected to an access      * point with no connectivity using legacy API's.      */     private class LegacyConnectToWifiWithNoInternetValidator extends MultiNetworkValidator {          LegacyConnectToWifiWithNoInternetValidator(int description) {             super(mMultinetworkTestCallback,                 ""legacy_no_internet_test"",                 description,                 /* runTestOnLowMemoryDevices = */ false);         }           @Override         void continueWithTest() {             super.continueWithTest();             connectToWifi();         }          @Override         void onContinuePreWifiConnect() {             mTestProgressMessage = R.string.multinetwork_connectivity_test_1_prereq;             mTestCallback.testProgress(mTestProgressMessage);             mValidatorState = WAITING_FOR_USER_INPUT;             requestUserConfirmation();         }          @Override         void onWifiNetworkConnected(Network wifiNetwork) {             super.onWifiNetworkConnected(wifiNetwork);             if (isConnectedToExpectedWifiNetwork()) {                 startTimerCountdownDisplay(CELLULAR_NETWORK_RESTORE_TIMEOUT_MS / 1000);                 mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_2);                  // Wait for CELLULAR_NETWORK_RESTORE_TIMEOUT_MS, before checking if there is still                 // the active network as the cell network.                 mMainHandler.postDelayed(() -> {                     stopTimerCountdownDisplay();                     mMainHandler.post(() -> {                         if (isExpectedTransportForActiveNetwork(TRANSPORT_CELLULAR)                                 && isNetworkConnected(wifiNetwork)) {                             Log.d(TAG, ""PASS test as device has connectivity"");                             endTest(true, R.string.multinetwork_status_mobile_restore_success);                         } else {                             Log.d(TAG, ""Fail test as device didn't have connectivity"");                             endTest(false, R.string.multinetwork_status_mobile_restore_failed);                         }                     });                 }, CELLULAR_NETWORK_RESTORE_TIMEOUT_MS);             } else {                 endTest(false, R.string.multinetwork_status_wifi_connect_wrong_ap);             }         }          void connectToWifi() {             mTestCallback.testProgress(R.string.multinetwork_connectivity_test_connect_wifi);             mConnectivityState.legacyConnectToWifiNetwork(false);         }     }      /**      * Test that device restores lost cellular connectivity when it's connected to an access      * point which loses internet connectivity using legacy API's.      */     private class LegacyConnectToWifiWithIntermittentInternetValidator         extends MultiNetworkValidator {         boolean mWaitingForWifiConnect = false;         boolean mWaitingForCelluarToConnectBack = false;         Network mWifiNetwork;          LegacyConnectToWifiWithIntermittentInternetValidator(int description) {             super(mMultinetworkTestCallback,                 ""legacy_no_internet_test"",                 description,                 /* runTestOnLowMemoryDevices = */ false);         }          @Override         void continueWithTest() {             super.continueWithTest();             if (mWaitingForWifiConnect) {                 connectToWifi();             } else if (mWaitingForCelluarToConnectBack) {                 mWaitingForCelluarToConnectBack = false;                 waitForConnectivityRestore();             }         }          @Override         void onContinuePreWifiConnect() {             mTestProgressMessage = R.string.multinetwork_connectivity_test_2_prereq_1;             mTestCallback.testProgress(mTestProgressMessage);             mValidatorState = WAITING_FOR_USER_INPUT;             mWaitingForWifiConnect = true;             requestUserConfirmation();         }          void connectToWifi() {             mTestCallback.testProgress(R.string.multinetwork_connectivity_test_connect_wifi);             mConnectivityState.legacyConnectToWifiNetwork(true);         }          @Override         void onWifiNetworkConnected(Network wifiNetwork) {             super.onWifiNetworkConnected(wifiNetwork);             if (isConnectedToExpectedWifiNetwork()) {                 // If the device is connected to the expected network, then update the wifi                 // network to the latest.                 mWifiNetwork = wifiNetwork;                 // Do further processing only when the test is requesting and waiting for a wifi                 // connection.                 if (mWaitingForWifiConnect) {                     mWaitingForWifiConnect = false;                     startTimerCountdownDisplay(WIFI_NETWORK_CONNECT_TO_BE_ACTIVE_MS / 1000);                      // Wait for WIFI_NETWORK_CONNECT_TO_BE_ACTIVE_MS, before checking                     // if device has the active network as wifi network..                     mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_2);                     mMainHandler.postDelayed(() -> {                         stopTimerCountdownDisplay();                         // In this case both active and peer are same as Wifi has internet access.                         if (isExpectedTransportForActiveNetwork(TRANSPORT_WIFI)                                 && isNetworkConnected(mWifiNetwork)) {                             // Ask the user to turn off wifi on the router and check connectivity.                             mTestProgressMessage =                                     R.string.multinetwork_connectivity_test_2_prereq_2;                             mValidatorState = WAITING_FOR_USER_INPUT;                             mTestCallback.testProgress(mTestProgressMessage);                             mWaitingForCelluarToConnectBack = true;                             requestUserConfirmation();                         } else {                             Log.d(TAG, ""Fail test as device didn't have connectivity"");                             endTest(false, R.string.multinetwork_status_wifi_connectivity_failed);                         }                     }, WIFI_NETWORK_CONNECT_TO_BE_ACTIVE_MS);                 }             } else {                 endTest(false, R.string.multinetwork_status_wifi_connect_wrong_ap);             }         }          @Override         void reset() {             super.reset();             mWaitingForCelluarToConnectBack = false;             mWaitingForWifiConnect = false;             mWifiNetwork = null;         }          @Override         void onWifiNetworkUnavailable() {             if (mWaitingForWifiConnect) {                 super.onWifiNetworkUnavailable();             }         }          void waitForConnectivityRestore() {             mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_1);             mConnectivityManager.reportNetworkConnectivity(mWifiNetwork, false);             startTimerCountdownDisplay(                     CELLULAR_NETWORK_RESTORE_AFTER_WIFI_INTERNET_LOST_TIMEOUT_MS / 1000);             // Wait for CELLULAR_NETWORK_RESTORE_AFTER_WIFI_INTERNET_LOST_TIMEOUT_MS,             // before checking if device now has the active network as cell network.             mMainHandler.postDelayed(() -> {                 stopTimerCountdownDisplay();                 // Check if device has fallen back to cellular network when it loses internet access                 // in the wifi network.                 if (isExpectedTransportForActiveNetwork(TRANSPORT_CELLULAR)                         && isNetworkConnected(mWifiNetwork)) {                     Log.d(TAG, ""PASS test as device has connectivity"");                     endTest(true, R.string.multinetwork_status_mobile_restore_success);                 } else {                     Log.d(TAG, ""Fail test as device didn't have connectivity"");                     endTest(false, R.string.multinetwork_status_mobile_restore_failed);                 }             }, CELLULAR_NETWORK_RESTORE_AFTER_WIFI_INTERNET_LOST_TIMEOUT_MS);         }     }      /**      * Test that device does not lose cellular connectivity when it's connected to an access      * point with no connectivity using the new API's.      */     private class ConnectToWifiWithNoInternetValidator extends MultiNetworkValidator {          ConnectToWifiWithNoInternetValidator(int description) {             super(mMultinetworkTestCallback,                 ""no_internet_test"",                 description,                 /* runTestOnLowMemoryDevices = */ true);         }           @Override         void continueWithTest() {             super.continueWithTest();             connectToWifi();         }          @Override         void onContinuePreWifiConnect() {             mTestProgressMessage = R.string.multinetwork_connectivity_test_1_prereq;             mTestCallback.testProgress(mTestProgressMessage);             mValidatorState = WAITING_FOR_USER_INPUT;             requestUserConfirmation();         }          void connectToWifi() {             mTestCallback.testProgress(R.string.multinetwork_connectivity_test_connect_wifi);             mConnectivityState.connectToWifiNetworkWithNoInternet();         }          @Override         void onWifiNetworkConnected(Network wifiNetwork) {             super.onWifiNetworkConnected(wifiNetwork);             if (isConnectedToExpectedWifiNetwork()) {                 startTimerCountdownDisplay(CELLULAR_NETWORK_RESTORE_TIMEOUT_MS / 1000);                 mTestCallback.testProgress(R.string.multinetwork_connectivity_test_progress_2);                  // Wait for CELLULAR_NETWORK_RESTORE_TIMEOUT_MS, before checking if there is still                 // the active network as the cell network.                 mMainHandler.postDelayed(() -> {                     stopTimerCountdownDisplay();                     mMainHandler.post(() -> {                         if (isExpectedTransportForActiveNetwork(TRANSPORT_CELLULAR)                                 && isNetworkConnected(wifiNetwork)) {                             Log.d(TAG, ""PASS test as device has connectivity"");                             endTest(true, R.string.multinetwork_status_mobile_restore_success);                         } else {                             Log.d(TAG, ""Fail test as device didn't have connectivity"");                             endTest(false, R.string.multinetwork_status_mobile_restore_failed);                         }                     });                 }, CELLULAR_NETWORK_RESTORE_TIMEOUT_MS);             } else {                 endTest(false, R.string.multinetwork_status_wifi_connect_wrong_ap);             }         }     }      private interface SetWifiCallback {         void onComplete(boolean isSuccess);     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-5"	""	"com.android.cts.net.hostside.VpnTest"	"finish"	""	""	"7.4.5.3/C-1-5"	"""C-1-5] MUST ensure that, while the user is logging in to a captive portal, the default network used by applications (as returned by ConnectivityManager.getActiveNetwork, ConnectivityManager.registerDefaultNetworkCallback, and used by default by Java networking APIs such as java.net.Socket, and native APIs such as connect()) is any other available network that provides internet access, if available. <h4 id="""	""	"getActiveNetwork ConnectivityManager.getActiveNetwork ConnectivityManager.registerDefaultNetworkCallback"	""	""	""	"getActiveNetwork"	""	""	""	"/home/gpoor/cts-source/cts/hostsidetests/net/app/src/com/android/cts/net/hostside/VpnTest.java"	""	"Api.     private static final String PRIVATE_DNS_MODE_SETTING = ""private_dns_mode"";     private static final String PRIVATE_DNS_MODE_PROVIDER_HOSTNAME = ""hostname"";     private static final String PRIVATE_DNS_MODE_OPPORTUNISTIC = ""opportunistic"";     private static final String PRIVATE_DNS_SPECIFIER_SETTING = ""private_dns_specifier"";      public static String TAG = ""VpnTest"";     public static int TIMEOUT_MS = 3 * 1000;     public static int SOCKET_TIMEOUT_MS = 100;     public static String TEST_HOST = ""connectivitycheck.gstatic.com"";      private UiDevice mDevice;     private MyActivity mActivity;     private String mPackageName;     private ConnectivityManager mCM;     private WifiManager mWifiManager;     private RemoteSocketFactoryClient mRemoteSocketFactoryClient;      Network mNetwork;     NetworkCallback mCallback;     final Object mLock = new Object();     final Object mLockShutdown = new Object();      private String mOldPrivateDnsMode;     private String mOldPrivateDnsSpecifier;      private boolean supportedHardware() {         final PackageManager pm = getInstrumentation().getContext().getPackageManager();         return !pm.hasSystemFeature(""android.hardware.type.watch"");     }      @Override     public void setUp() throws Exception {         super.setUp();          mNetwork = null;         mCallback = null;         storePrivateDnsSetting();          mDevice = UiDevice.getInstance(getInstrumentation());         mActivity = launchActivity(getInstrumentation().getTargetContext().getPackageName(),                 MyActivity.class, null);         mPackageName = mActivity.getPackageName();         mCM = (ConnectivityManager) mActivity.getSystemService(Context.CONNECTIVITY_SERVICE);         mWifiManager = (WifiManager) mActivity.getSystemService(Context.WIFI_SERVICE);         mRemoteSocketFactoryClient = new RemoteSocketFactoryClient(mActivity);         mRemoteSocketFactoryClient.bind();         mDevice.waitForIdle();     }      @Override     public void tearDown() throws Exception {         restorePrivateDnsSetting();         mRemoteSocketFactoryClient.unbind();         if (mCallback != null) {             mCM.unregisterNetworkCallback(mCallback);         }         Log.i(TAG, ""Stopping VPN"");         stopVpn();         mActivity.finish();         super.tearDown();     }      private void prepareVpn() throws Exception {         final int REQUEST_ID = 42;          // Attempt to prepare.         Log.i(TAG, ""Preparing VPN"");         Intent intent = VpnService.prepare(mActivity);          if (intent != null) {             // Start the confirmation dialog and click OK.             mActivity.startActivityForResult(intent, REQUEST_ID);             mDevice.waitForIdle();              String packageName = intent.getComponent().getPackageName();             String resourceIdRegex = ""android:id/button1$|button_start_vpn"";             final UiObject okButton = new UiObject(new UiSelector()                     .className(""android.widget.Button"")                     .packageName(packageName)                     .resourceIdMatches(resourceIdRegex));             if (okButton.waitForExists(TIMEOUT_MS) == false) {                 mActivity.finishActivity(REQUEST_ID);                 fail(""VpnService.prepare returned an Intent for '"" + intent.getComponent() + ""' "" +                      ""to display the VPN confirmation dialog, but this test could not find the "" +                      ""button to allow the VPN application to connect. Please ensure that the ""  +                      ""component displays a button with a resource ID matching the regexp: '"" +                      resourceIdRegex + ""'."");             }              // Click the button and wait for RESULT_OK.             okButton.click();             try {                 int result = mActivity.getResult(TIMEOUT_MS);                 if (result != MyActivity.RESULT_OK) {                     fail(""The VPN confirmation dialog did not return RESULT_OK when clicking on "" +                          ""the button matching the regular expression '"" + resourceIdRegex +                          ""' of "" + intent.getComponent() + ""'. Please ensure that clicking on "" +                          ""that button allows the VPN application to connect. "" +                          ""Return value: "" + result);                 }             } catch (InterruptedException e) {                 fail(""VPN confirmation dialog did not return after "" + TIMEOUT_MS + ""ms"");             }              // Now we should be prepared.             intent = VpnService.prepare(mActivity);             if (intent != null) {                 fail(""VpnService.prepare returned non-null even after the VPN dialog "" +                      intent.getComponent() + ""returned RESULT_OK."");             }         }     }      // TODO: Consider replacing arguments with a Builder.     private void startVpn(         String[] addresses, String[] routes, String allowedApplications,         String disallowedApplications, @Nullable ProxyInfo proxyInfo,         @Nullable ArrayList<Network> underlyingNetworks, boolean isAlwaysMetered) throws Exception {         prepareVpn();          // Register a callback so we will be notified when our VPN comes up.         final NetworkRequest request = new NetworkRequest.Builder()                 .addTransportType(NetworkCapabilities.TRANSPORT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                 .build();         mCallback = new NetworkCallback() {             public void onAvailable(Network network) {                 synchronized (mLock) {                     Log.i(TAG, ""Got available callback for network="" + network);                     mNetwork = network;                     mLock.notify();                 }             }         };         mCM.registerNetworkCallback(request, mCallback);  // Unregistered in tearDown.          // Start the service and wait up for TIMEOUT_MS ms for the VPN to come up.         Intent intent = new Intent(mActivity, MyVpnService.class)                 .putExtra(mPackageName + "".cmd"", ""connect"")                 .putExtra(mPackageName + "".addresses"", TextUtils.join("","", addresses))                 .putExtra(mPackageName + "".routes"", TextUtils.join("","", routes))                 .putExtra(mPackageName + "".allowedapplications"", allowedApplications)                 .putExtra(mPackageName + "".disallowedapplications"", disallowedApplications)                 .putExtra(mPackageName + "".httpProxy"", proxyInfo)                 .putParcelableArrayListExtra(                     mPackageName + "".underlyingNetworks"", underlyingNetworks)                 .putExtra(mPackageName + "".isAlwaysMetered"", isAlwaysMetered);          mActivity.startService(intent);         synchronized (mLock) {             if (mNetwork == null) {                  Log.i(TAG, ""bf mLock"");                  mLock.wait(TIMEOUT_MS);                  Log.i(TAG, ""af mLock"");             }         }          if (mNetwork == null) {             fail(""VPN did not become available after "" + TIMEOUT_MS + ""ms"");         }          // Unfortunately, when the available callback fires, the VPN UID ranges are not yet         // configured. Give the system some time to do so. http://b/18436087 .         try { Thread.sleep(3000); } catch(InterruptedException e) {}     }      private void stopVpn() {         // Register a callback so we will be notified when our VPN comes up.         final NetworkRequest request = new NetworkRequest.Builder()                 .addTransportType(NetworkCapabilities.TRANSPORT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)                 .build();         mCallback = new NetworkCallback() {             public void onLost(Network network) {                 synchronized (mLockShutdown) {                     Log.i(TAG, ""Got lost callback for network="" + network                             + "",mNetwork = "" + mNetwork);                     if( mNetwork == network){                         mLockShutdown.notify();                     }                 }             }        };         mCM.registerNetworkCallback(request, mCallback);  // Unregistered in tearDown.         // Simply calling mActivity.stopService() won't stop the service, because the system binds         // to the service for the purpose of sending it a revoke command if another VPN comes up,         // and stopping a bound service has no effect. Instead, ""start"" the service again with an         // Intent that tells it to disconnect.         Intent intent = new Intent(mActivity, MyVpnService.class)                 .putExtra(mPackageName + "".cmd"", ""disconnect"");         mActivity.startService(intent);         synchronized (mLockShutdown) {             try {                  Log.i(TAG, ""bf mLockShutdown"");                  mLockShutdown.wait(TIMEOUT_MS);                  Log.i(TAG, ""af mLockShutdown"");             } catch(InterruptedException e) {}         }     }      private static void closeQuietly(Closeable c) {         if (c != null) {             try {                 c.close();             } catch (IOException e) {             }         }     }      private static void checkPing(String to) throws IOException, ErrnoException {         InetAddress address = InetAddress.getByName(to);         FileDescriptor s;         final int LENGTH = 64;         byte[] packet = new byte[LENGTH];         byte[] header;          // Construct a ping packet.         Random random = new Random();         random.nextBytes(packet);         if (address instanceof Inet6Address) {             s = Os.socket(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6);             header = new byte[] { (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00 };         } else {             // Note that this doesn't actually work due to http://b/18558481 .             s = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);             header = new byte[] { (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00 };         }         System.arraycopy(header, 0, packet, 0, header.length);          // Send the packet.         int port = random.nextInt(65534) + 1;         Os.connect(s, address, port);         Os.write(s, packet, 0, packet.length);          // Expect a reply.         StructPollfd pollfd = new StructPollfd();         pollfd.events = (short) POLLIN;  // ""error: possible loss of precision""         pollfd.fd = s;         int ret = Os.poll(new StructPollfd[] { pollfd }, SOCKET_TIMEOUT_MS);         assertEquals(""Expected reply after sending ping"", 1, ret);          byte[] reply = new byte[LENGTH];         int read = Os.read(s, reply, 0, LENGTH);         assertEquals(LENGTH, read);          // Find out what the kernel set the ICMP ID to.         InetSocketAddress local = (InetSocketAddress) Os.getsockname(s);         port = local.getPort();         packet[4] = (byte) ((port >> 8) & 0xff);         packet[5] = (byte) (port & 0xff);          // Check the contents.         if (packet[0] == (byte) 0x80) {             packet[0] = (byte) 0x81;         } else {             packet[0] = 0;         }         // Zero out the checksum in the reply so it matches the uninitialized checksum in packet.         reply[2] = reply[3] = 0;         MoreAsserts.assertEquals(packet, reply);     }      // Writes data to out and checks that it appears identically on in.     private static void writeAndCheckData(             OutputStream out, InputStream in, byte[] data) throws IOException {         out.write(data, 0, data.length);         out.flush();          byte[] read = new byte[data.length];         int bytesRead = 0, totalRead = 0;         do {             bytesRead = in.read(read, totalRead, read.length - totalRead);             totalRead += bytesRead;         } while (bytesRead >= 0 && totalRead < data.length);         assertEquals(totalRead, data.length);         MoreAsserts.assertEquals(data, read);     }      private void checkTcpReflection(String to, String expectedFrom) throws IOException {         // Exercise TCP over the VPN by ""connecting to ourselves"". We open a server socket and a         // client socket, and connect the client socket to a remote host, with the port of the         // server socket. The PacketReflector reflects the packets, changing the source addresses         // but not the ports, so our client socket is connected to our server socket, though both         // sockets think their peers are on the ""remote"" IP address.          // Open a listening socket.         ServerSocket listen = new ServerSocket(0, 10, InetAddress.getByName(""::""));          // Connect the client socket to it.         InetAddress toAddr = InetAddress.getByName(to);         Socket client = new Socket();         try {             client.connect(new InetSocketAddress(toAddr, listen.getLocalPort()), SOCKET_TIMEOUT_MS);             if (expectedFrom == null) {                 closeQuietly(listen);                 closeQuietly(client);                 fail(""Expected connection to fail, but it succeeded."");             }         } catch (IOException e) {             if (expectedFrom != null) {                 closeQuietly(listen);                 fail(""Expected connection to succeed, but it failed."");             } else {                 // We expected the connection to fail, and it did, so there's nothing more to test.                 return;             }         }          // The connection succeeded, and we expected it to succeed. Send some data; if things are         // working, the data will be sent to the VPN, reflected by the PacketReflector, and arrive         // at our server socket. For good measure, send some data in the other direction.         Socket server = null;         try {             // Accept the connection on the server side.             listen.setSoTimeout(SOCKET_TIMEOUT_MS);             server = listen.accept();             checkConnectionOwnerUidTcp(client);             checkConnectionOwnerUidTcp(server);             // Check that the source and peer addresses are as expected.             assertEquals(expectedFrom, client.getLocalAddress().getHostAddress());             assertEquals(expectedFrom, server.getLocalAddress().getHostAddress());             assertEquals(                     new InetSocketAddress(toAddr, client.getLocalPort()),                     server.getRemoteSocketAddress());             assertEquals(                     new InetSocketAddress(toAddr, server.getLocalPort()),                     client.getRemoteSocketAddress());              // Now write some data.             final int LENGTH = 32768;             byte[] data = new byte[LENGTH];             new Random().nextBytes(data);              // Make sure our writes don't block or time out, because we're single-threaded and can't             // read and write at the same time.             server.setReceiveBufferSize(LENGTH * 2);             client.setSendBufferSize(LENGTH * 2);             client.setSoTimeout(SOCKET_TIMEOUT_MS);             server.setSoTimeout(SOCKET_TIMEOUT_MS);              // Send some data from client to server, then from server to client.             writeAndCheckData(client.getOutputStream(), server.getInputStream(), data);             writeAndCheckData(server.getOutputStream(), client.getInputStream(), data);         } finally {             closeQuietly(listen);             closeQuietly(client);             closeQuietly(server);         }     }      private void checkConnectionOwnerUidUdp(DatagramSocket s, boolean expectSuccess) {         final int expectedUid = expectSuccess ? Process.myUid() : INVALID_UID;         InetSocketAddress loc = new InetSocketAddress(s.getLocalAddress(), s.getLocalPort());         InetSocketAddress rem = new InetSocketAddress(s.getInetAddress(), s.getPort());         int uid = mCM.getConnectionOwnerUid(OsConstants.IPPROTO_UDP, loc, rem);         assertEquals(expectedUid, uid);     }      private void checkConnectionOwnerUidTcp(Socket s) {         final int expectedUid = Process.myUid();         InetSocketAddress loc = new InetSocketAddress(s.getLocalAddress(), s.getLocalPort());         InetSocketAddress rem = new InetSocketAddress(s.getInetAddress(), s.getPort());         int uid = mCM.getConnectionOwnerUid(OsConstants.IPPROTO_TCP, loc, rem);         assertEquals(expectedUid, uid);     }      private void checkUdpEcho(String to, String expectedFrom) throws IOException {         DatagramSocket s;         InetAddress address = InetAddress.getByName(to);         if (address instanceof Inet6Address) {  // http://b/18094870             s = new DatagramSocket(0, InetAddress.getByName(""::""));         } else {             s = new DatagramSocket();         }         s.setSoTimeout(SOCKET_TIMEOUT_MS);          Random random = new Random();         byte[] data = new byte[random.nextInt(1650)];         random.nextBytes(data);         DatagramPacket p = new DatagramPacket(data, data.length);         s.connect(address, 7);          if (expectedFrom != null) {             assertEquals(""Unexpected source address: "",                          expectedFrom, s.getLocalAddress().getHostAddress());         }          try {             if (expectedFrom != null) {                 s.send(p);                 checkConnectionOwnerUidUdp(s, true);                 s.receive(p);                 MoreAsserts.assertEquals(data, p.getData());             } else {                 try {                     s.send(p);                     s.receive(p);                     fail(""Received unexpected reply"");                 } catch (IOException expected) {                     checkConnectionOwnerUidUdp(s, false);                 }             }         } finally {             s.close();         }     }      private void checkTrafficOnVpn() throws Exception {         checkUdpEcho(""192.0.2.251"", ""192.0.2.2"");         checkUdpEcho(""2001:db8:dead:beef::f00"", ""2001:db8:1:2::ffe"");         checkPing(""2001:db8:dead:beef::f00"");         checkTcpReflection(""192.0.2.252"", ""192.0.2.2"");         checkTcpReflection(""2001:db8:dead:beef::f00"", ""2001:db8:1:2::ffe"");     }      private void checkNoTrafficOnVpn() throws Exception {         checkUdpEcho(""192.0.2.251"", null);         checkUdpEcho(""2001:db8:dead:beef::f00"", null);         checkTcpReflection(""192.0.2.252"", null);         checkTcpReflection(""2001:db8:dead:beef::f00"", null);     }      private FileDescriptor openSocketFd(String host, int port, int timeoutMs) throws Exception {         Socket s = new Socket(host, port);         s.setSoTimeout(timeoutMs);         // Dup the filedescriptor so ParcelFileDescriptor's finalizer doesn't garbage collect it         // and cause our fd to become invalid. http://b/35927643 .         FileDescriptor fd = Os.dup(ParcelFileDescriptor.fromSocket(s).getFileDescriptor());         s.close();         return fd;     }      private FileDescriptor openSocketFdInOtherApp(             String host, int port, int timeoutMs) throws Exception {         Log.d(TAG, String.format(""Creating test socket in UID=%d, my UID=%d"",                 mRemoteSocketFactoryClient.getUid(), Os.getuid()));         FileDescriptor fd = mRemoteSocketFactoryClient.openSocketFd(host, port, TIMEOUT_MS);         return fd;     }      private void sendRequest(FileDescriptor fd, String host) throws Exception {         String request = ""GET /generate_204 HTTP/1.1\r\n"" +                 ""Host: "" + host + ""\r\n"" +                 ""Connection: keep-alive\r\n\r\n"";         byte[] requestBytes = request.getBytes(StandardCharsets.UTF_8);         int ret = Os.write(fd, requestBytes, 0, requestBytes.length);         Log.d(TAG, ""Wrote "" + ret + ""bytes"");          String expected = ""HTTP/1.1 204 No Content\r\n"";         byte[] response = new byte[expected.length()];         Os.read(fd, response, 0, response.length);          String actual = new String(response, StandardCharsets.UTF_8);         assertEquals(expected, actual);         Log.d(TAG, ""Got response: "" + actual);     }      private void assertSocketStillOpen(FileDescriptor fd, String host) throws Exception {         try {             assertTrue(fd.valid());             sendRequest(fd, host);             assertTrue(fd.valid());         } finally {             Os.close(fd);         }     }      private void assertSocketClosed(FileDescriptor fd, String host) throws Exception {         try {             assertTrue(fd.valid());             sendRequest(fd, host);             fail(""Socket opened before VPN connects should be closed when VPN connects"");         } catch (ErrnoException expected) {             assertEquals(ECONNABORTED, expected.errno);             assertTrue(fd.valid());         } finally {             Os.close(fd);         }     }      private ContentResolver getContentResolver() {         return getInstrumentation().getContext().getContentResolver();     }      private boolean isPrivateDnsInStrictMode() {         return PRIVATE_DNS_MODE_PROVIDER_HOSTNAME.equals(                 Settings.Global.getString(getContentResolver(), PRIVATE_DNS_MODE_SETTING));     }      private void storePrivateDnsSetting() {         mOldPrivateDnsMode = Settings.Global.getString(getContentResolver(),                 PRIVATE_DNS_MODE_SETTING);         mOldPrivateDnsSpecifier = Settings.Global.getString(getContentResolver(),                 PRIVATE_DNS_SPECIFIER_SETTING);     }      private void restorePrivateDnsSetting() {         Settings.Global.putString(getContentResolver(), PRIVATE_DNS_MODE_SETTING,                 mOldPrivateDnsMode);         Settings.Global.putString(getContentResolver(), PRIVATE_DNS_SPECIFIER_SETTING,                 mOldPrivateDnsSpecifier);     }      // TODO: replace with CtsNetUtils.awaitPrivateDnsSetting in Q or above.     private void expectPrivateDnsHostname(final String hostname) throws Exception {         final NetworkRequest request = new NetworkRequest.Builder()                 .removeCapability(NetworkCapabilities.NET_CAPABILITY_NOT_VPN)                 .build();         final CountDownLatch latch = new CountDownLatch(1);         final NetworkCallback callback = new NetworkCallback() {             @Override             public void onLinkPropertiesChanged(Network network, LinkProperties lp) {                 if (network.equals(mNetwork) &&                         Objects.equals(lp.getPrivateDnsServerName(), hostname)) {                     latch.countDown();                 }             }         };          mCM.registerNetworkCallback(request, callback);          try {             assertTrue(""Private DNS hostname was not "" + hostname + "" after "" + TIMEOUT_MS + ""ms"",                     latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));         } finally {             mCM.unregisterNetworkCallback(callback);         }     }      private void setAndVerifyPrivateDns(boolean strictMode) throws Exception {         final ContentResolver cr = getInstrumentation().getContext().getContentResolver();         String privateDnsHostname;          if (strictMode) {             privateDnsHostname = ""vpncts-nx.metric.gstatic.com"";             Settings.Global.putString(cr, PRIVATE_DNS_SPECIFIER_SETTING, privateDnsHostname);             Settings.Global.putString(cr, PRIVATE_DNS_MODE_SETTING,                     PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);         } else {             Settings.Global.putString(cr, PRIVATE_DNS_MODE_SETTING, PRIVATE_DNS_MODE_OPPORTUNISTIC);             privateDnsHostname = null;         }          expectPrivateDnsHostname(privateDnsHostname);          String randomName = ""vpncts-"" + new Random().nextInt(1000000000) + ""-ds.metric.gstatic.com"";         if (strictMode) {             // Strict mode private DNS is enabled. DNS lookups should fail, because the private DNS             // server name is invalid.             try {                 InetAddress.getByName(randomName);                 fail(""VPN DNS lookup should fail with private DNS enabled"");             } catch (UnknownHostException expected) {             }         } else {             // Strict mode private DNS is disabled. DNS lookup should succeed, because the VPN             // provides no DNS servers, and thus DNS falls through to the default network.             assertNotNull(""VPN DNS lookup should succeed with private DNS disabled"",                     InetAddress.getByName(randomName));         }     }      // Tests that strict mode private DNS is used on VPNs.     private void checkStrictModePrivateDns() throws Exception {         final boolean initialMode = isPrivateDnsInStrictMode();         setAndVerifyPrivateDns(!initialMode);         setAndVerifyPrivateDns(initialMode);     }      public void testDefault() throws Exception {         if (!supportedHardware()) return;         // If adb TCP port opened, this test may running by adb over network.         // All of socket would be destroyed in this test. So this test don't         // support adb over network, see b/119382723.         if (SystemProperties.getInt(""persist.adb.tcp.port"", -1) > -1                 || SystemProperties.getInt(""service.adb.tcp.port"", -1) > -1) {             Log.i(TAG, ""adb is running over the network, so skip this test"");             return;         }          final BlockingBroadcastReceiver receiver = new BlockingBroadcastReceiver(                 getInstrumentation().getTargetContext(), MyVpnService.ACTION_ESTABLISHED);         receiver.register();          FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""0.0.0.0/0"", ""::/0""},                  """", """", null, null /* underlyingNetworks */, false /* isAlwaysMetered */);          final Intent intent = receiver.awaitForBroadcast(TimeUnit.MINUTES.toMillis(1));         assertNotNull(""Failed to receive broadcast from VPN service"", intent);         assertFalse(""Wrong VpnService#isAlwaysOn"",                 intent.getBooleanExtra(MyVpnService.EXTRA_ALWAYS_ON, true));         assertFalse(""Wrong VpnService#isLockdownEnabled"",                 intent.getBooleanExtra(MyVpnService.EXTRA_LOCKDOWN_ENABLED, true));          assertSocketClosed(fd, TEST_HOST);          checkTrafficOnVpn();          checkStrictModePrivateDns();          receiver.unregisterQuietly();     }      public void testAppAllowed() throws Exception {         if (!supportedHardware()) return;          FileDescriptor fd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);          // Shell app must not be put in here or it would kill the ADB-over-network use case         String allowedApps = mRemoteSocketFactoryClient.getPackageName() + "","" + mPackageName;         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""192.0.2.0/24"", ""2001:db8::/32""},                  allowedApps, """", null, null /* underlyingNetworks */, false /* isAlwaysMetered */);          assertSocketClosed(fd, TEST_HOST);          checkTrafficOnVpn();          checkStrictModePrivateDns();     }      public void testAppDisallowed() throws Exception {         if (!supportedHardware()) return;          FileDescriptor localFd = openSocketFd(TEST_HOST, 80, TIMEOUT_MS);         FileDescriptor remoteFd = openSocketFdInOtherApp(TEST_HOST, 80, TIMEOUT_MS);          String disallowedApps = mRemoteSocketFactoryClient.getPackageName() + "","" + mPackageName;         // If adb TCP port opened, this test may running by adb over TCP.         // Add com.android.shell appllication into blacklist to exclude adb socket for VPN test,         // see b/119382723.         // Note: The test don't support running adb over network for root device         disallowedApps = disallowedApps + "",com.android.shell"";         Log.i(TAG, ""Append shell app to disallowedApps: "" + disallowedApps);         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""192.0.2.0/24"", ""2001:db8::/32""},                  """", disallowedApps, null, null /* underlyingNetworks */,                  false /* isAlwaysMetered */);          assertSocketStillOpen(localFd, TEST_HOST);         assertSocketStillOpen(remoteFd, TEST_HOST);          checkNoTrafficOnVpn();     }      public void testGetConnectionOwnerUidSecurity() throws Exception {         if (!supportedHardware()) return;          DatagramSocket s;         InetAddress address = InetAddress.getByName(""localhost"");         s = new DatagramSocket();         s.setSoTimeout(SOCKET_TIMEOUT_MS);         s.connect(address, 7);         InetSocketAddress loc = new InetSocketAddress(s.getLocalAddress(), s.getLocalPort());         InetSocketAddress rem = new InetSocketAddress(s.getInetAddress(), s.getPort());         try {             int uid = mCM.getConnectionOwnerUid(OsConstants.IPPROTO_TCP, loc, rem);             fail(""Only an active VPN app may call this API."");         } catch (SecurityException expected) {             return;         }     }      public void testSetProxy() throws  Exception {         if (!supportedHardware()) return;         ProxyInfo initialProxy = mCM.getDefaultProxy();         // Receiver for the proxy change broadcast.         BlockingBroadcastReceiver proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();          String allowedApps = mPackageName;         ProxyInfo testProxyInfo = ProxyInfo.buildDirectProxy(""10.0.0.1"", 8888);         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """",                 testProxyInfo, null /* underlyingNetworks */, false /* isAlwaysMetered */);          // Check that the proxy change broadcast is received         try {             assertNotNull(""No proxy change was broadcast when VPN is connected."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }          // Proxy is set correctly in network and in link properties.         assertNetworkHasExpectedProxy(testProxyInfo, mNetwork);         assertDefaultProxy(testProxyInfo);          proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         stopVpn();         try {             assertNotNull(""No proxy change was broadcast when VPN was disconnected."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }          // After disconnecting from VPN, the proxy settings are the ones of the initial network.         assertDefaultProxy(initialProxy);     }      public void testSetProxyDisallowedApps() throws Exception {         if (!supportedHardware()) return;         ProxyInfo initialProxy = mCM.getDefaultProxy();          // If adb TCP port opened, this test may running by adb over TCP.         // Add com.android.shell appllication into blacklist to exclude adb socket for VPN test,         // see b/119382723.         // Note: The test don't support running adb over network for root device         String disallowedApps = mPackageName + "",com.android.shell"";         ProxyInfo testProxyInfo = ProxyInfo.buildDirectProxy(""10.0.0.1"", 8888);         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, """", disallowedApps,                 testProxyInfo, null /* underlyingNetworks */, false /* isAlwaysMetered */);          // The disallowed app does has the proxy configs of the default network.         assertNetworkHasExpectedProxy(initialProxy, mCM.getActiveNetwork());         assertDefaultProxy(initialProxy);     }      public void testNoProxy() throws Exception {         if (!supportedHardware()) return;         ProxyInfo initialProxy = mCM.getDefaultProxy();         BlockingBroadcastReceiver proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         String allowedApps = mPackageName;         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 null /* underlyingNetworks */, false /* isAlwaysMetered */);          try {             assertNotNull(""No proxy change was broadcast."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }          // The VPN network has no proxy set.         assertNetworkHasExpectedProxy(null, mNetwork);          proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         stopVpn();         try {             assertNotNull(""No proxy change was broadcast."",                     proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }         // After disconnecting from VPN, the proxy settings are the ones of the initial network.         assertDefaultProxy(initialProxy);         assertNetworkHasExpectedProxy(initialProxy, mCM.getActiveNetwork());     }      public void testBindToNetworkWithProxy() throws Exception {         if (!supportedHardware()) return;         String allowedApps = mPackageName;         Network initialNetwork = mCM.getActiveNetwork();         ProxyInfo initialProxy = mCM.getDefaultProxy();         ProxyInfo testProxyInfo = ProxyInfo.buildDirectProxy(""10.0.0.1"", 8888);         // Receiver for the proxy change broadcast.         BlockingBroadcastReceiver proxyBroadcastReceiver = new ProxyChangeBroadcastReceiver();         proxyBroadcastReceiver.register();         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """",                 testProxyInfo, null /* underlyingNetworks */, false /* isAlwaysMetered */);          assertDefaultProxy(testProxyInfo);         mCM.bindProcessToNetwork(initialNetwork);         try {             assertNotNull(""No proxy change was broadcast."",                 proxyBroadcastReceiver.awaitForBroadcast());         } finally {             proxyBroadcastReceiver.unregisterQuietly();         }         assertDefaultProxy(initialProxy);     }      public void testVpnMeterednessWithNoUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         // VPN is not routing any traffic i.e. its underlying networks is an empty array.         ArrayList<Network> underlyingNetworks = new ArrayList<>();         String allowedApps = mPackageName;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, false /* isAlwaysMetered */);          // VPN should now be the active network.         assertEquals(mNetwork, mCM.getActiveNetwork());         assertVpnTransportContains(NetworkCapabilities.TRANSPORT_VPN);         // VPN with no underlying networks should be metered by default.         assertTrue(isNetworkMetered(mNetwork));         assertTrue(mCM.isActiveNetworkMetered());     }      public void testVpnMeterednessWithNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testVpnMeterednessWithNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN tracks platform default.         ArrayList<Network> underlyingNetworks = null;         String allowedApps = mPackageName;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, false /*isAlwaysMetered */);          // Ensure VPN transports contains underlying network's transports.         assertVpnTransportContains(underlyingNetwork);         // Its meteredness should be same as that of underlying network.         assertEquals(isNetworkMetered(underlyingNetwork), isNetworkMetered(mNetwork));         // Meteredness based on VPN capabilities and CM#isActiveNetworkMetered should be in sync.         assertEquals(isNetworkMetered(mNetwork), mCM.isActiveNetworkMetered());     }      public void testVpnMeterednessWithNonNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testVpnMeterednessWithNonNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN explicitly declares WiFi to be its underlying network.         ArrayList<Network> underlyingNetworks = new ArrayList<>(1);         underlyingNetworks.add(underlyingNetwork);         String allowedApps = mPackageName;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, false /* isAlwaysMetered */);          // Ensure VPN transports contains underlying network's transports.         assertVpnTransportContains(underlyingNetwork);         // Its meteredness should be same as that of underlying network.         assertEquals(isNetworkMetered(underlyingNetwork), isNetworkMetered(mNetwork));         // Meteredness based on VPN capabilities and CM#isActiveNetworkMetered should be in sync.         assertEquals(isNetworkMetered(mNetwork), mCM.isActiveNetworkMetered());     }      public void testAlwaysMeteredVpnWithNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testAlwaysMeteredVpnWithNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN tracks platform default.         ArrayList<Network> underlyingNetworks = null;         String allowedApps = mPackageName;         boolean isAlwaysMetered = true;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, isAlwaysMetered);          // VPN's meteredness does not depend on underlying network since it is always metered.         assertTrue(isNetworkMetered(mNetwork));         assertTrue(mCM.isActiveNetworkMetered());     }      public void testAlwaysMeteredVpnWithNonNullUnderlyingNetwork() throws Exception {         if (!supportedHardware()) {             return;         }         Network underlyingNetwork = mCM.getActiveNetwork();         if (underlyingNetwork == null) {             Log.i(TAG, ""testAlwaysMeteredVpnWithNonNullUnderlyingNetwork cannot execute""                     + "" unless there is an active network"");             return;         }         // VPN explicitly declares its underlying network.         ArrayList<Network> underlyingNetworks = new ArrayList<>(1);         underlyingNetworks.add(underlyingNetwork);         String allowedApps = mPackageName;         boolean isAlwaysMetered = true;          startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                 new String[] {""0.0.0.0/0"", ""::/0""}, allowedApps, """", null,                 underlyingNetworks, isAlwaysMetered);          // VPN's meteredness does not depend on underlying network since it is always metered.         assertTrue(isNetworkMetered(mNetwork));         assertTrue(mCM.isActiveNetworkMetered());     }      public void testB141603906() throws Exception {         if (!supportedHardware()) {             return;         }         final InetSocketAddress src = new InetSocketAddress(0);         final InetSocketAddress dst = new InetSocketAddress(0);         final int NUM_THREADS = 8;         final int NUM_SOCKETS = 5000;         final Thread[] threads = new Thread[NUM_THREADS];         startVpn(new String[] {""192.0.2.2/32"", ""2001:db8:1:2::ffe/128""},                  new String[] {""0.0.0.0/0"", ""::/0""},                  """" /* allowedApplications */, ""com.android.shell"" /* disallowedApplications */,                 null /* proxyInfo */, null /* underlyingNetworks */, false /* isAlwaysMetered */);          for (int i = 0; i < NUM_THREADS; i++) {             threads[i] = new Thread(() -> {                 for (int j = 0; j < NUM_SOCKETS; j++) {                     mCM.getConnectionOwnerUid(IPPROTO_TCP, src, dst);                 }             });         }         for (Thread thread : threads) {             thread.start();         }         for (Thread thread : threads) {             thread.join();         }         stopVpn();     }      private boolean isNetworkMetered(Network network) {         NetworkCapabilities nc = mCM.getNetworkCapabilities(network);         return !nc.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);     }      private void assertVpnTransportContains(Network underlyingNetwork) {         int[] transports = mCM.getNetworkCapabilities(underlyingNetwork).getTransportTypes();         assertVpnTransportContains(transports);     }      private void assertVpnTransportContains(int... transports) {         NetworkCapabilities vpnCaps = mCM.getNetworkCapabilities(mNetwork);         for (int transport : transports) {             assertTrue(vpnCaps.hasTransport(transport));         }     }      private void assertDefaultProxy(ProxyInfo expected) {         assertEquals(""Incorrect proxy config."", expected, mCM.getDefaultProxy());         String expectedHost = expected == null ? null : expected.getHost();         String expectedPort = expected == null ? null : String.valueOf(expected.getPort());         assertEquals(""Incorrect proxy host system property."", expectedHost,             System.getProperty(""http.proxyHost""));         assertEquals(""Incorrect proxy port system property."", expectedPort,             System.getProperty(""http.proxyPort""));     }      private void assertNetworkHasExpectedProxy(ProxyInfo expected, Network network) {         LinkProperties lp = mCM.getLinkProperties(network);         assertNotNull(""The network link properties object is null."", lp);         assertEquals(""Incorrect proxy config."", expected, lp.getHttpProxy());          assertEquals(expected, mCM.getProxyForNetwork(network));     }      class ProxyChangeBroadcastReceiver extends BlockingBroadcastReceiver {         private boolean received;          public ProxyChangeBroadcastReceiver() {             super(VpnTest.this.getInstrumentation().getContext(), Proxy.PROXY_CHANGE_ACTION);             received = false;         }          @Override         public void onReceive(Context context, Intent intent) {             if (!received) {                 // Do not call onReceive() more than once.                 super.onReceive(context, intent);             }             received = true;         }     } }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-5"	""	"android.net.cts.ConnectivityManagerTest"	"testGetActiveNetworkInfo"	""	""	"7.4.5.3/C-1-5"	"""C-1-5] MUST ensure that, while the user is logging in to a captive portal, the default network used by applications (as returned by ConnectivityManager.getActiveNetwork, ConnectivityManager.registerDefaultNetworkCallback, and used by default by Java networking APIs such as java.net.Socket, and native APIs such as connect()) is any other available network that provides internet access, if available. <h4 id="""	""	"getActiveNetwork ConnectivityManager.getActiveNetwork ConnectivityManager.registerDefaultNetworkCallback"	""	""	""	"getActiveNetwork"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"public void testGetActiveNetworkInfo() {         NetworkInfo ni = mCm.getActiveNetworkInfo();          assertNotNull(""You must have an active network connection to complete CTS"", ni);         assertTrue(ConnectivityManager.isNetworkTypeValid(ni.getType()));         assertTrue(ni.getState() == State.CONNECTED);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-5"	""	"android.net.cts.ConnectivityManagerTest"	"testGetActiveNetwork"	""	""	"7.4.5.3/C-1-5"	"""C-1-5] MUST ensure that, while the user is logging in to a captive portal, the default network used by applications (as returned by ConnectivityManager.getActiveNetwork, ConnectivityManager.registerDefaultNetworkCallback, and used by default by Java networking APIs such as java.net.Socket, and native APIs such as connect()) is any other available network that provides internet access, if available. <h4 id="""	""	"getActiveNetwork ConnectivityManager.getActiveNetwork ConnectivityManager.registerDefaultNetworkCallback"	""	""	""	"getActiveNetwork"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"public void testGetActiveNetwork() {         Network network = mCm.getActiveNetwork();         assertNotNull(""You must have an active network connection to complete CTS"", network);          NetworkInfo ni = mCm.getNetworkInfo(network);         assertNotNull(""Network returned from getActiveNetwork was invalid"", ni);          // Similar to testGetActiveNetworkInfo above.         assertTrue(ConnectivityManager.isNetworkTypeValid(ni.getType()));         assertTrue(ni.getState() == State.CONNECTED);     }"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-5"	""	"android.net.cts.ConnectivityManagerTest"	"testRestrictedNetworks"	""	""	"7.4.5.3/C-1-5"	"""C-1-5] MUST ensure that, while the user is logging in to a captive portal, the default network used by applications (as returned by ConnectivityManager.getActiveNetwork, ConnectivityManager.registerDefaultNetworkCallback, and used by default by Java networking APIs such as java.net.Socket, and native APIs such as connect()) is any other available network that provides internet access, if available. <h4 id="""	""	"getActiveNetwork ConnectivityManager.getActiveNetwork ConnectivityManager.registerDefaultNetworkCallback"	""	""	""	"getActiveNetwork"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityManagerTest.java"	""	"public void testRestrictedNetworks() {         // Verify we can request unrestricted networks:         NetworkRequest request = new NetworkRequest.Builder()                 .addCapability(NET_CAPABILITY_INTERNET).build();         NetworkCallback callback = new NetworkCallback();         mCm.requestNetwork(request, callback);         mCm.unregisterNetworkCallback(callback);         // Verify we cannot request restricted networks:         request = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_IMS).build();         callback = new NetworkCallback();         try {             mCm.requestNetwork(request, callback);             fail(""No exception thrown when restricted network requested."");         } catch (SecurityException expected) {}     }      // Returns ""true"", ""false"" or ""none""     private String getWifiMeteredStatus(String ssid) throws Exception {         // Interestingly giving the SSID as an argument to list wifi-networks         // only works iff the network in question has the ""false"" policy.         // Also unfortunately runShellCommand does not pass the command to the interpreter         // so it's not possible to | grep the ssid.         final String command = ""cmd netpolicy list wifi-networks"";         final String policyString = runShellCommand(mInstrumentation, command);          final Matcher m = Pattern.compile(""^"" + ssid + "";(true|false|none)$"",                 Pattern.MULTILINE | Pattern.UNIX_LINES).matcher(policyString);         if (!m.find()) {             fail(""Unexpected format from cmd netpolicy"");         }         return m.group(1);     }      // metered should be ""true"", ""false"" or ""none""     private void setWifiMeteredStatus(String ssid, String metered) throws Exception {         final String setCommand = ""cmd netpolicy set metered-network "" + ssid + "" "" + metered;         runShellCommand(mInstrumentation, setCommand);         assertEquals(getWifiMeteredStatus(ssid), metered);     }      private String unquoteSSID(String ssid) {         // SSID is returned surrounded by quotes if it can be decoded as UTF-8.         // Otherwise it's guaranteed not to start with a quote.         if (ssid.charAt(0) == '""') {             return ssid.substring(1, ssid.length() - 1);         } else {             return ssid;         }     }      private void waitForActiveNetworkMetered(int targetTransportType, boolean requestedMeteredness)             throws Exception {         final CountDownLatch latch = new CountDownLatch(1);         final NetworkCallback networkCallback = new NetworkCallback() {             @Override             public void onCapabilitiesChanged(Network network, NetworkCapabilities nc) {                 if (!nc.hasTransport(targetTransportType)) return;                  final boolean metered = !nc.hasCapability(NET_CAPABILITY_NOT_METERED);                 if (metered == requestedMeteredness) {                     latch.countDown();                 }             }         };         // Registering a callback here guarantees onCapabilitiesChanged is called immediately         // with the current setting. Therefore, if the setting has already been changed,         // this method will return right away, and if not it will wait for the setting to change.         mCm.registerDefaultNetworkCallback(networkCallback);         if (!latch.await(NETWORK_CHANGE_METEREDNESS_TIMEOUT, TimeUnit.MILLISECONDS)) {             fail(""Timed out waiting for active network metered status to change to ""                  + requestedMeteredness + "" ; network = "" + mCm.getActiveNetwork());         }         mCm.unregisterNetworkCallback(networkCallback);     }      private void assertMultipathPreferenceIsEventually(Network network, int oldValue,             int expectedValue) {         // Sanity check : if oldValue == expectedValue, there is no way to guarantee the test         // is not flaky.         assertNotSame(oldValue, expectedValue);          for (int i = 0; i < NUM_TRIES_MULTIPATH_PREF_CHECK; ++i) {             final int actualValue = mCm.getMultipathPreference(network);             if (actualValue == expectedValue) {                 return;             }             if (actualValue != oldValue) {                 fail(""Multipath preference is neither previous ("" + oldValue                         + "") nor expected ("" + expectedValue + "")"");             }             SystemClock.sleep(INTERVAL_MULTIPATH_PREF_CHECK_MS);         }         fail(""Timed out waiting for multipath preference to change. expected = ""                 + expectedValue + "" ; actual = "" + mCm.getMultipathPreference(network));     }      private int getCurrentMeteredMultipathPreference(ContentResolver resolver) {         final String rawMeteredPref = Settings.Global.getString(resolver,                 NETWORK_METERED_MULTIPATH_PREFERENCE);         return TextUtils.isEmpty(rawMeteredPref)             ? getIntResourceForName(NETWORK_METERED_MULTIPATH_PREFERENCE_RES_NAME)             : Integer.parseInt(rawMeteredPref);     }      private int findNextPrefValue(ContentResolver resolver) {         // A bit of a nuclear hammer, but race conditions in CTS are bad. To be able to         // detect a correct setting value without race conditions, the next pref must         // be a valid value (range 0..3) that is different from the old setting of the         // metered preference and from the unmetered preference.         final int meteredPref = getCurrentMeteredMultipathPreference(resolver);         final int unmeteredPref = ConnectivityManager.MULTIPATH_PREFERENCE_UNMETERED;         if (0 != meteredPref && 0 != unmeteredPref) return 0;         if (1 != meteredPref && 1 != unmeteredPref) return 1;         return 2;     }      /**      * Verify that getMultipathPreference does return appropriate values      * for metered and unmetered networks.      */     @AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")"	""	""	""	""	""
"204:632149) 7.4.5.3  . Captive Portals"	"7.4.5.3"	"C-1-5"	""	"android.net.cts.DnsTest"	"testDnsWorks"	""	""	"7.4.5.3/C-1-5"	"""C-1-5] MUST ensure that, while the user is logging in to a captive portal, the default network used by applications (as returned by ConnectivityManager.getActiveNetwork, ConnectivityManager.registerDefaultNetworkCallback, and used by default by Java networking APIs such as java.net.Socket, and native APIs such as connect()) is any other available network that provides internet access, if available. <h4 id="""	""	"getActiveNetwork ConnectivityManager.getActiveNetwork ConnectivityManager.registerDefaultNetworkCallback"	""	""	""	"getActiveNetwork"	""	""	""	"/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/DnsTest.java"	""	"public void testDnsWorks() throws Exception {         ensureIpv6Connectivity();          InetAddress addrs[] = {};         try {             addrs = InetAddress.getAllByName(""www.google.com"");         } catch (UnknownHostException e) {}         assertTrue(""[RERUN] DNS could not resolve www.google.com. Check internet connection"",                 addrs.length != 0);         boolean foundV4 = false, foundV6 = false;         for (InetAddress addr : addrs) {             if (addr instanceof Inet4Address) foundV4 = true;             else if (addr instanceof Inet6Address) foundV6 = true;             if (DBG) Log.e(TAG, ""www.google.com gave "" + addr.toString());         }          // We should have at least one of the addresses to connect!         assertTrue(""www.google.com must have IPv4 and/or IPv6 address"", foundV4 || foundV6);          // Skip the rest of the test if the active network for watch is PROXY.         // TODO: Check NetworkInfo type in addition to type name once ag/601257 is merged.         if (getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)                 && activeNetworkInfoIsProxy()) {             Log.i(TAG, ""Skipping test because the active network type name is PROXY."");             return;         }          // Clear test state so we don't get confused with the previous results.         addrs = new InetAddress[0];         foundV4 = foundV6 = false;         try {             addrs = InetAddress.getAllByName(""ipv6.google.com"");         } catch (UnknownHostException e) {}         String msg =             ""[RERUN] DNS could not resolve ipv6.google.com, check the network supports IPv6. lp="" +             mCm.getActiveLinkProperties();         assertTrue(msg, addrs.length != 0);         for (InetAddress addr : addrs) {             msg = ""[RERUN] ipv6.google.com returned IPv4 address: "" + addr.getHostAddress() +                     "", check your network's DNS server. lp="" + mCm.getActiveLinkProperties();             assertFalse (msg, addr instanceof Inet4Address);             foundV6 |= (addr instanceof Inet6Address);             if (DBG) Log.e(TAG, ""ipv6.google.com gave "" + addr.toString());         }          assertTrue(foundV6);          assertTrue(testNativeDns());     }      private static final String[] URLS = { ""www.google.com"", ""ipv6.google.com"", ""www.yahoo.com"",             ""facebook.com"", ""youtube.com"", ""blogspot.com"", ""baidu.com"", ""wikipedia.org"", // live.com fails rev lookup.             ""twitter.com"", ""qq.com"", ""msn.com"", ""yahoo.co.jp"", ""linkedin.com"",             ""taobao.com"", ""google.co.in"", ""sina.com.cn"", ""amazon.com"", ""wordpress.com"",             ""google.co.uk"", ""ebay.com"", ""yandex.ru"", ""163.com"", ""google.co.jp"", ""google.fr"",             ""microsoft.com"", ""paypal.com"", ""google.com.br"", ""flickr.com"",             ""mail.ru"", ""craigslist.org"", ""fc2.com"", ""google.it"", // ""apple.com"", fails rev lookup             ""google.es"",             ""imdb.com"", ""google.ru"", ""soho.com"", ""bbc.co.uk"", ""vkontakte.ru"", ""ask.com"",             ""tumblr.com"", ""weibo.com"", ""go.com"", ""xvideos.com"", ""livejasmin.com"", ""cnn.com"",             ""youku.com"", ""blogspot.com"", ""soso.com"", ""google.ca"", ""aol.com"", ""tudou.com"",             ""xhamster.com"", ""megaupload.com"", ""ifeng.com"", ""zedo.com"", ""mediafire.com"", ""ameblo.jp"",             ""pornhub.com"", ""google.co.id"", ""godaddy.com"", ""adobe.com"", ""rakuten.co.jp"", ""about.com"",             ""espn.go.com"", ""4shared.com"", ""alibaba.com"",""ebay.de"", ""yieldmanager.com"",             ""wordpress.org"", ""livejournal.com"", ""google.com.tr"", ""google.com.mx"", ""renren.com"",            ""livedoor.com"", ""google.com.au"", ""youporn.com"", ""uol.com.br"", ""cnet.com"", ""conduit.com"",             ""google.pl"", ""myspace.com"", ""nytimes.com"", ""ebay.co.uk"", ""chinaz.com"", ""hao123.com"",             ""thepiratebay.org"", ""doubleclick.com"", ""alipay.com"", ""netflix.com"", ""cnzz.com"",             ""huffingtonpost.com"", ""twitpic.com"", ""weather.com"", ""babylon.com"", ""amazon.de"",             ""dailymotion.com"", ""orkut.com"", ""orkut.com.br"", ""google.com.sa"", ""odnoklassniki.ru"",             ""amazon.co.jp"", ""google.nl"", ""goo.ne.jp"", ""stumbleupon.com"", ""tube8.com"", ""tmall.com"",             ""imgur.com"", ""globo.com"", ""secureserver.net"", ""fileserve.com"", ""tianya.cn"", ""badoo.com"",             ""ehow.com"", ""photobucket.com"", ""imageshack.us"", ""xnxx.com"", ""deviantart.com"",             ""filestube.com"", ""addthis.com"", ""douban.com"", ""vimeo.com"", ""sogou.com"",             ""stackoverflow.com"", ""reddit.com"", ""dailymail.co.uk"", ""redtube.com"", ""megavideo.com"",             ""taringa.net"", ""pengyou.com"", ""amazon.co.uk"", ""fbcdn.net"", ""aweber.com"", ""spiegel.de"",             ""rapidshare.com"", ""mixi.jp"", ""360buy.com"", ""google.cn"", ""digg.com"", ""answers.com"",             ""bit.ly"", ""indiatimes.com"", ""skype.com"", ""yfrog.com"", ""optmd.com"", ""google.com.eg"",             ""google.com.pk"", ""58.com"", ""hotfile.com"", ""google.co.th"",             ""bankofamerica.com"", ""sourceforge.net"", ""maktoob.com"", ""warriorforum.com"", ""rediff.com"",             ""google.co.za"", ""56.com"", ""torrentz.eu"", ""clicksor.com"", ""avg.com"",             ""download.com"", ""ku6.com"", ""statcounter.com"", ""foxnews.com"", ""google.com.ar"",             ""nicovideo.jp"", ""reference.com"", ""liveinternet.ru"", ""ucoz.ru"", ""xinhuanet.com"",             ""xtendmedia.com"", ""naver.com"", ""youjizz.com"", ""domaintools.com"", ""sparkstudios.com"",             ""rambler.ru"", ""scribd.com"", ""kaixin001.com"", ""mashable.com"", ""adultfirendfinder.com"",             ""files.wordpress.com"", ""guardian.co.uk"", ""bild.de"", ""yelp.com"", ""wikimedia.org"",             ""chase.com"", ""onet.pl"", ""ameba.jp"", ""pconline.com.cn"", ""free.fr"", ""etsy.com"",             ""typepad.com"", ""youdao.com"", ""megaclick.com"", ""digitalpoint.com"", ""blogfa.com"",             ""salesforce.com"", ""adf.ly"", ""ganji.com"", ""wikia.com"", ""archive.org"", ""terra.com.br"",             ""w3schools.com"", ""ezinearticles.com"", ""wjs.com"", ""google.com.my"", ""clickbank.com"",             ""squidoo.com"", ""hulu.com"", ""repubblica.it"", ""google.be"", ""allegro.pl"", ""comcast.net"",             ""narod.ru"", ""zol.com.cn"", ""orange.fr"", ""soufun.com"", ""hatena.ne.jp"", ""google.gr"",             ""in.com"", ""techcrunch.com"", ""orkut.co.in"", ""xunlei.com"",             ""reuters.com"", ""google.com.vn"", ""hostgator.com"", ""kaskus.us"", ""espncricinfo.com"",             ""hootsuite.com"", ""qiyi.com"", ""gmx.net"", ""xing.com"", ""php.net"", ""soku.com"", ""web.de"",             ""libero.it"", ""groupon.com"", ""51.la"", ""slideshare.net"", ""booking.com"", ""seesaa.net"",             ""126.com"", ""telegraph.co.uk"", ""wretch.cc"", ""twimg.com"", ""rutracker.org"", ""angege.com"",             ""nba.com"", ""dell.com"", ""leboncoin.fr"", ""people.com"", ""google.com.tw"", ""walmart.com"",             ""daum.net"", ""2ch.net"", ""constantcontact.com"", ""nifty.com"", ""mywebsearch.com"",             ""tripadvisor.com"", ""google.se"", ""paipai.com"", ""google.com.ua"", ""ning.com"", ""hp.com"",             ""google.at"", ""joomla.org"", ""icio.us"", ""hudong.com"", ""csdn.net"", ""getfirebug.com"",             ""ups.com"", ""cj.com"", ""google.ch"", ""camzap.com"", ""wordreference.com"", ""tagged.com"",             ""wp.pl"", ""mozilla.com"", ""google.ru"", ""usps.com"", ""china.com"", ""themeforest.net"",             ""search-results.com"", ""tribalfusion.com"", ""thefreedictionary.com"", ""isohunt.com"",             ""linkwithin.com"", ""cam4.com"", ""plentyoffish.com"", ""wellsfargo.com"", ""metacafe.com"",             ""depositfiles.com"", ""freelancer.com"", ""opendns.com"", ""homeway.com"", ""engadget.com"",             ""10086.cn"", ""360.cn"", ""marca.com"", ""dropbox.com"", ""ign.com"", ""match.com"", ""google.pt"",             ""facemoods.com"", ""hardsextube.com"", ""google.com.ph"", ""lockerz.com"", ""istockphoto.com"",             ""partypoker.com"", ""netlog.com"", ""outbrain.com"", ""elpais.com"", ""fiverr.com"",             ""biglobe.ne.jp"", ""corriere.it"", ""love21cn.com"", ""yesky.com"", ""spankwire.com"",             ""ig.com.br"", ""imagevenue.com"", ""hubpages.com"", ""google.co.ve""};  // TODO - this works, but is slow and cts doesn't do anything with the result. // Maybe require a min performance, a min cache size (detectable) and/or move // to perf testing     private static final int LOOKUP_COUNT_GOAL = URLS.length;     public void skiptestDnsPerf() {         ArrayList<String> results = new ArrayList<String>();         int failures = 0;         try {             for (int numberOfUrls = URLS.length; numberOfUrls > 0; numberOfUrls--) {                 failures = 0;                 int iterationLimit = LOOKUP_COUNT_GOAL / numberOfUrls;                 long startTime = SystemClock.elapsedRealtimeNanos();                 for (int iteration = 0; iteration < iterationLimit; iteration++) {                     for (int urlIndex = 0; urlIndex < numberOfUrls; urlIndex++) {                         try {                             InetAddress addr = InetAddress.getByName(URLS[urlIndex]);                         } catch (UnknownHostException e) {                             Log.e(TAG, ""failed first lookup of "" + URLS[urlIndex]);                             failures++;                             try {                                 InetAddress addr = InetAddress.getByName(URLS[urlIndex]);                             } catch (UnknownHostException ee) {                                 failures++;                                 Log.e(TAG, ""failed SECOND lookup of "" + URLS[urlIndex]);                             }                         }                     }                 }                 long endTime = SystemClock.elapsedRealtimeNanos();                 float nsPer = ((float)(endTime-startTime) / iterationLimit) / numberOfUrls/ 1000;                 String thisResult = new String(""getByName for "" + numberOfUrls + "" took "" +                         (endTime - startTime)/1000 + ""("" + nsPer + "") with "" +                         failures + "" failures\n"");                 Log.d(TAG, thisResult);                 results.add(thisResult);             }             // build up a list of addresses             ArrayList<byte[]> addressList = new ArrayList<byte[]>();             for (String url : URLS) {                 try {                     InetAddress addr = InetAddress.getByName(url);                     addressList.add(addr.getAddress());                 } catch (UnknownHostException e) {                     Log.e(TAG, ""Exception making reverseDNS list: "" + e.toString());                 }             }             for (int numberOfAddrs = addressList.size(); numberOfAddrs > 0; numberOfAddrs--) {                 int iterationLimit = LOOKUP_COUNT_GOAL / numberOfAddrs;                 failures = 0;                 long startTime = SystemClock.elapsedRealtimeNanos();                 for (int iteration = 0; iteration < iterationLimit; iteration++) {                     for (int addrIndex = 0; addrIndex < numberOfAddrs; addrIndex++) {                         try {                             InetAddress addr = InetAddress.getByAddress(addressList.get(addrIndex));                             String hostname = addr.getHostName();                         } catch (UnknownHostException e) {                             failures++;                             Log.e(TAG, ""Failure doing reverse DNS lookup: "" + e.toString());                             try {                                 InetAddress addr =                                         InetAddress.getByAddress(addressList.get(addrIndex));                                 String hostname = addr.getHostName();                              } catch (UnknownHostException ee) {                                 failures++;                                 Log.e(TAG, ""Failure doing SECOND reverse DNS lookup: "" +                                         ee.toString());                             }                         }                     }                 }                 long endTime = SystemClock.elapsedRealtimeNanos();                 float nsPer = ((endTime-startTime) / iterationLimit) / numberOfAddrs / 1000;                 String thisResult = new String(""getHostName for "" + numberOfAddrs + "" took "" +                         (endTime - startTime)/1000 + ""("" + nsPer + "") with "" +                         failures + "" failures\n"");                 Log.d(TAG, thisResult);                 results.add(thisResult);             }             for (String result : results) Log.d(TAG, result);              InetAddress exit = InetAddress.getByName(""exitrightnow.com"");             Log.e(TAG, "" exit address= ""+exit.toString());          } catch (Exception e) {             Log.e(TAG, ""bad URL in testDnsPerf: "" + e.toString());         }     }      private boolean activeNetworkInfoIsProxy() {         NetworkInfo info = mCm.getActiveNetworkInfo();         if (PROXY_NETWORK_TYPE.equals(info.getTypeName())) {             return true;         }          return false;     }      private void ensureIpv6Connectivity() throws InterruptedException {         CountDownLatch latch = new CountDownLatch(1);         final int TIMEOUT_MS = 5_000;          final NetworkCallback callback = new NetworkCallback() {             @Override             public void onLinkPropertiesChanged(Network network, LinkProperties lp) {                 if (lp.hasGlobalIpv6Address()) {                     latch.countDown();                 }             }         };         mCm.registerDefaultNetworkCallback(callback);          String msg = ""Default network did not provide IPv6 connectivity after "" + TIMEOUT_MS                 + ""ms. Please connect to an IPv6-capable network. lp=""                 + mCm.getActiveLinkProperties();         try {             assertTrue(msg, latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));         } finally {             mCm.unregisterNetworkCallback(callback);         }     } }"	""	""	""	""	""
